{"ast":null,"code":"import { BackEase, EasingFunction } from \"../../Animations/easing\";\nimport { Animation } from \"../../Animations/animation\";\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\n\nvar BouncingBehavior =\n/** @class */\nfunction () {\n  function BouncingBehavior() {\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\n    this.transitionDuration = 450;\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\n\n    this.lowerRadiusTransitionRange = 2;\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\n\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false; // Animations\n\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n\n  Object.defineProperty(BouncingBehavior.prototype, \"name\", {\n    /**\r\n     * Gets the name of the behavior.\r\n     */\n    get: function () {\n      return \"Bouncing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BouncingBehavior.prototype, \"autoTransitionRange\", {\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\n    get: function () {\n      return this._autoTransitionRange;\n    },\n\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._autoTransitionRange === value) {\n        return;\n      }\n\n      this._autoTransitionRange = value;\n      var camera = this._attachedCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      if (value) {\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n          if (!mesh) {\n            return;\n          }\n\n          mesh.computeWorldMatrix(true);\n          var diagonal = mesh.getBoundingInfo().diagonalLength;\n          _this.lowerRadiusTransitionRange = diagonal * 0.05;\n          _this.upperRadiusTransitionRange = diagonal * 0.05;\n        });\n      } else if (this._onMeshTargetChangedObserver) {\n        camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the behavior.\r\n   */\n\n  BouncingBehavior.prototype.init = function () {// Do notihng\n  };\n  /**\r\n   * Attaches the behavior to its arc rotate camera.\r\n   * @param camera Defines the camera to attach the behavior to\r\n   */\n\n\n  BouncingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      if (!_this._attachedCamera) {\n        return;\n      } // Add the bounce animation to the lower radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.lowerRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.lowerRadiusTransitionRange);\n      } // Add the bounce animation to the upper radius limit\n\n\n      if (_this._isRadiusAtLimit(_this._attachedCamera.upperRadiusLimit)) {\n        _this._applyBoundRadiusAnimation(_this.upperRadiusTransitionRange);\n      }\n    });\n  };\n  /**\r\n   * Detaches the behavior from its current arc rotate camera.\r\n   */\n\n\n  BouncingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\r\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n   * @param radiusLimit The limit to check against.\r\n   * @return Bool to indicate if at limit.\r\n   */\n\n\n  BouncingBehavior.prototype._isRadiusAtLimit = function (radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n   * @param radiusDelta The delta by which to animate to. Can be negative.\r\n   */\n\n\n  BouncingBehavior.prototype._applyBoundRadiusAnimation = function (radiusDelta) {\n    var _this = this;\n\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    } // Prevent zoom until bounce has completed\n\n\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0; // Animate to the radius limit\n\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () {\n      return _this._clearAnimationLocks();\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\r\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n   */\n\n\n  BouncingBehavior.prototype._clearAnimationLocks = function () {\n    this._radiusIsAnimating = false;\n\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  };\n  /**\r\n   * Stops and removes all animations that have been applied to the camera\r\n   */\n\n\n  BouncingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n\n      this._animatables[0].stop();\n\n      this._animatables.shift();\n    }\n  };\n  /**\r\n   * The easing function used by animations\r\n   */\n\n\n  BouncingBehavior.EasingFunction = new BackEase(0.3);\n  /**\r\n   * The easing mode used by animations\r\n   */\n\n  BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;\n  return BouncingBehavior;\n}();\n\nexport { BouncingBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Cameras/bouncingBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        let camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                let diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do notihng\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @return Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60,\r\n            this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}