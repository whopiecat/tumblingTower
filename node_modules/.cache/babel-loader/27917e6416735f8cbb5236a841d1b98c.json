{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { Axis } from \"../../Maths/math.axis\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\nimport { Ray } from \"../../Culling/ray\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\nimport { Viewport } from \"../../Maths/math.viewport\";\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\n\nvar WebXRControllerPointerSelection =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPointerSelection, _super);\n  /**\r\n   * constructs a new background remover module\r\n   * @param _xrSessionManager the session manager for this module\r\n   * @param _options read-only options to be used in this module\r\n   */\n\n\n  function WebXRControllerPointerSelection(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      var _a = _this._generateNewMeshPair(xrController.pointer),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh; // get two new meshes\n\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        id: WebXRControllerPointerSelection._idCounter++\n      };\n\n      if (_this._attachedController) {\n        if (!_this._options.enablePointerSelectionOnAllControllers && _this._options.preferredHandedness && xrController.inputSource.handedness === _this._options.preferredHandedness) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!_this._options.enablePointerSelectionOnAllControllers) {\n          _this._attachedController = xrController.uniqueId;\n        }\n      }\n\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return _this._attachTrackedPointerRayMode(xrController);\n\n        case \"gaze\":\n          return _this._attachGazeMode(xrController);\n\n        case \"screen\":\n          return _this._attachScreenRayMode(xrController);\n      }\n    };\n\n    _this._controllers = {};\n    _this._tmpVectorForPickCompare = new Vector3();\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\n\n    _this.disablePointerLighting = true;\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\n\n    _this.disableSelectionMeshLighting = true;\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\n\n    _this.displayLaserPointer = true;\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\n\n    _this.displaySelectionMesh = true;\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\n\n    _this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\r\n     * Default color of the laser pointer\r\n     */\n\n    _this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\r\n     * default color of the selection ring\r\n     */\n\n    _this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\n\n    _this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    _this._identityMatrix = Matrix.Identity();\n    _this._screenCoordinatesRef = Vector3.Zero();\n    _this._viewportRef = new Viewport(0, 0, 0, 0);\n    _this._scene = _this._xrSessionManager.scene;\n    return _this;\n  }\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n\n    if (this._options.gazeCamera) {\n      var webXRCamera = this._options.gazeCamera;\n\n      var _a = this._generateNewMeshPair(webXRCamera),\n          laserPointer = _a.laserPointer,\n          selectionMesh = _a.selectionMesh;\n\n      this._controllers[\"camera\"] = {\n        webXRCamera: webXRCamera,\n        laserPointer: laserPointer,\n        selectionMesh: selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        id: WebXRControllerPointerSelection._idCounter++\n      };\n\n      this._attachGazeMode();\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n    return true;\n  };\n  /**\r\n   * Will get the mesh under a specific pointer.\r\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n   * @param controllerId the controllerId to check\r\n   * @returns The mesh under pointer or null if no mesh is under the pointer\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getMeshUnderPointer = function (controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Get the xr controller that correlates to the pointer id in the pointer event\r\n   *\r\n   * @param id the pointer id to search for\r\n   * @returns the controller that correlates to this id or null if not found\r\n   */\n\n\n  WebXRControllerPointerSelection.prototype.getXRControllerByPointerId = function (id) {\n    var keys = Object.keys(this._controllers);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n\n    return null;\n  };\n\n  WebXRControllerPointerSelection.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    Object.keys(this._controllers).forEach(function (id) {\n      // only do this for the selected pointer\n      var controllerData = _this._controllers[id];\n\n      if (!_this._options.enablePointerSelectionOnAllControllers && id !== _this._attachedController) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n\n      controllerData.laserPointer.isVisible = _this.displayLaserPointer;\n      var controllerGlobalPosition; // Every frame check collisions/input\n\n      if (controllerData.xrController) {\n        controllerGlobalPosition = controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n\n      if (_this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = _this._options.maxPointerDistance;\n      } // update pointerX and pointerY of the scene. Only if the flag is set to true!\n\n\n      if (!_this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        var scene = _this._xrSessionManager.scene;\n        var camera = _this._options.xrInput.xrCamera;\n\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), _this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, _this._identityMatrix, scene.getTransformMatrix(), _this._viewportRef, _this._screenCoordinatesRef);\n          scene.pointerX = _this._screenCoordinatesRef.x;\n          scene.pointerY = _this._screenCoordinatesRef.y;\n        }\n      }\n\n      controllerData.pick = _this._scene.pickWithRay(controllerData.tmpRay, _this._scene.pointerMovePredicate || _this.raySelectionPredicate);\n      var pick = controllerData.pick;\n\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        _this._updatePointerDistance(controllerData.laserPointer, pick.distance); // Update cursor state\n\n\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance); // To avoid z-fighting\n\n        var pickNormal = _this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n\n        var deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n\n        if (pickNormal) {\n          var axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          var axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n\n        controllerData.selectionMesh.isVisible = true && _this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n\n        _this._updatePointerDistance(controllerData.laserPointer, 1);\n\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._attachGazeMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"]; // attached when touched, detaches when raised\n\n    var timeToSelect = this._options.timeToSelect || 3000;\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var oldPick = new PickingInfo();\n    var discMesh = TorusBuilder.CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    var timer = 0;\n    var downTriggered = false;\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!controllerData.pick) {\n        return;\n      }\n\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n\n      if (controllerData.pick.hit) {\n        if (!_this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n\n          timer += _this._scene.getEngine().getDeltaTime();\n\n          if (timer >= timeToSelect) {\n            _this._scene.simulatePointerDown(controllerData.pick, {\n              pointerId: controllerData.id\n            });\n\n            downTriggered = true; // pointer up right after down, if disable on touch out\n\n            if (_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, {\n                pointerId: controllerData.id\n              });\n            }\n\n            discMesh.isVisible = false;\n          } else {\n            var scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!_this._options.disablePointerUpOnTouchOut) {\n              _this._scene.simulatePointerUp(controllerData.pick, {\n                pointerId: controllerData.id\n              });\n            }\n          }\n\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n\n      _this._scene.simulatePointerMove(controllerData.pick, {\n        pointerId: controllerData.id\n      });\n\n      oldPick = controllerData.pick;\n    });\n\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(function () {\n        if (controllerData.pick && !_this._options.disablePointerUpOnTouchOut && downTriggered) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n        }\n\n        discMesh.dispose();\n      });\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._attachScreenRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n    var downTriggered = false;\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      if (!controllerData.pick || _this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n\n      if (!downTriggered) {\n        _this._scene.simulatePointerDown(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n\n        downTriggered = true;\n\n        if (_this._options.disablePointerUpOnTouchOut) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n        }\n      } else {\n        _this._scene.simulatePointerMove(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n    xrController.onDisposeObservable.addOnce(function () {\n      if (controllerData.pick && downTriggered && !_this._options.disablePointerUpOnTouchOut) {\n        _this._scene.simulatePointerUp(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n  };\n\n  WebXRControllerPointerSelection.prototype._attachTrackedPointerRayMode = function (xrController) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrController.uniqueId];\n\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(function () {\n      controllerData.laserPointer.material.disableLighting = _this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = _this.disableSelectionMeshLighting;\n\n      if (controllerData.pick) {\n        _this._scene.simulatePointerMove(controllerData.pick, {\n          pointerId: controllerData.id\n        });\n      }\n    });\n\n    if (xrController.inputSource.gamepad) {\n      var init = function (motionController) {\n        if (_this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(_this._options.overrideButtonId);\n        }\n\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(function (component) {\n          if (component.changes.pressed) {\n            var pressed = component.changes.pressed.current;\n\n            if (controllerData.pick) {\n              if (_this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === _this._attachedController) {\n                if (pressed) {\n                  _this._scene.simulatePointerDown(controllerData.pick, {\n                    pointerId: controllerData.id\n                  });\n\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n                } else {\n                  _this._scene.simulatePointerUp(controllerData.pick, {\n                    pointerId: controllerData.id\n                  });\n\n                  controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n                }\n              } else {}\n            } else {\n              if (pressed && !_this._options.enablePointerSelectionOnAllControllers && !_this._options.disableSwitchOnClick) {\n                _this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      var selectStartListener = function (event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerDown(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshPickedColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerPickedColor;\n        }\n      };\n\n      var selectEndListener = function (event) {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          _this._scene.simulatePointerUp(controllerData.pick, {\n            pointerId: controllerData.id\n          });\n\n          controllerData.selectionMesh.material.emissiveColor = _this.selectionMeshDefaultColor;\n          controllerData.laserPointer.material.emissiveColor = _this.laserPointerDefaultColor;\n        }\n      };\n\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._convertNormalToDirectionOfRay = function (normal, ray) {\n    if (normal) {\n      var angle = Math.acos(Vector3.Dot(normal, ray.direction));\n\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n\n    return normal;\n  };\n\n  WebXRControllerPointerSelection.prototype._detachController = function (xrControllerUniqueId) {\n    var _this = this;\n\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(function (eventName) {\n        var func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n\n        if (func) {\n          _this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n\n    controllerData.selectionMesh.dispose();\n    controllerData.laserPointer.dispose(); // remove from the map\n\n    delete this._controllers[xrControllerUniqueId];\n\n    if (this._attachedController === xrControllerUniqueId) {\n      // check for other controllers\n      var keys = Object.keys(this._controllers);\n\n      if (keys.length) {\n        this._attachedController = keys[0];\n      } else {\n        this._attachedController = \"\";\n      }\n    }\n  };\n\n  WebXRControllerPointerSelection.prototype._generateNewMeshPair = function (meshParent) {\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    var laserPointer = CylinderBuilder.CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    var laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n\n    this._updatePointerDistance(laserPointer, 1);\n\n    laserPointer.isPickable = false; // Create a gaze tracker for the  XR controller\n\n    var selectionMesh = TorusBuilder.CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    var targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    return {\n      laserPointer: laserPointer,\n      selectionMesh: selectionMesh\n    };\n  };\n\n  WebXRControllerPointerSelection.prototype._pickingMoved = function (oldPick, newPick) {\n    var _a;\n\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n\n    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n\n    var delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n\n    var length = this._tmpVectorForPickCompare.length();\n\n    if (length > delta) {\n      return true;\n    }\n\n    return false;\n  };\n\n  WebXRControllerPointerSelection.prototype._updatePointerDistance = function (_laserPointer, distance) {\n    if (distance === void 0) {\n      distance = 100;\n    }\n\n    _laserPointer.scaling.y = distance; // a bit of distance from the controller\n\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n\n    _laserPointer.position.z = distance / 2 + 0.05;\n  };\n\n  Object.defineProperty(WebXRControllerPointerSelection.prototype, \"lasterPointerDefaultColor\", {\n    /** @hidden */\n    get: function () {\n      // here due to a typo\n      return this.laserPointerDefaultColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WebXRControllerPointerSelection._idCounter = 200;\n  /**\r\n   * The module's name\r\n   */\n\n  WebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRControllerPointerSelection.Version = 1;\n  return WebXRControllerPointerSelection;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPointerSelection }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPointerSelection(xrSessionManager, options);\n  };\n}, WebXRControllerPointerSelection.Version, true);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRControllerPointerSelection.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { WebXRInput } from \"../webXRInput\";\r\nimport { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Scene } from \"../../scene\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport { WebXRCamera } from \"../webXRCamera\";\r\nimport { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _idCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            id: WebXRControllerPointerSelection._idCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPointerSelectionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                id: WebXRControllerPointerSelection._idCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n\r\n                    scene.pointerX = this._screenCoordinatesRef.x;\r\n                    scene.pointerY = this._screenCoordinatesRef.y;\r\n                }\r\n            }\r\n            controllerData.pick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                let pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                let deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    let axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    let axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        let discMesh = TorusBuilder.CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            if (controllerData.pick && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n            }\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._scene.simulatePointerMove(controllerData.pick, { pointerId: controllerData.id });\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            } else {\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, { pointerId: controllerData.id });\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, { pointerId: controllerData.id });\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            let angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func);\r\n                }\r\n            });\r\n        }\r\n        controllerData.selectionMesh.dispose();\r\n        controllerData.laserPointer.dispose();\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n        if (this._attachedController === xrControllerUniqueId) {\r\n            // check for other controllers\r\n            const keys = Object.keys(this._controllers);\r\n            if (keys.length) {\r\n                this._attachedController = keys[0];\r\n            } else {\r\n                this._attachedController = \"\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = CylinderBuilder.CreateCylinder(\r\n            \"laserPointer\",\r\n            {\r\n                height: 1,\r\n                diameterTop: 0.0002,\r\n                diameterBottom: 0.004,\r\n                tessellation: 20,\r\n                subdivisions: 1,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        laserPointer.parent = meshParent;\r\n        let laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = TorusBuilder.CreateTorus(\r\n            \"gazeTracker\",\r\n            {\r\n                diameter: 0.0035 * 3,\r\n                thickness: 0.0025 * 3,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        let targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}