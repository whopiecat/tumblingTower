{"ast":null,"code":"import { Size } from '../../Maths/math.size';\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\n\nvar ThinTexture =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new ThinTexture.\r\n   * Base class of all the textures in babylon.\r\n   * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n   * @param internalTexture Define the internalTexture to wrap\r\n   */\n  function ThinTexture(internalTexture) {\n    this._wrapU = 1;\n    this._wrapV = 1;\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n\n    this.wrapR = 1;\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\n\n    this.anisotropicFilteringLevel = 4;\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\n\n    this.delayLoadState = 0;\n    /** @hidden */\n\n    this._texture = null;\n    this._engine = null;\n    this._cachedSize = Size.Zero();\n    this._cachedBaseSize = Size.Zero();\n    this._texture = internalTexture;\n\n    if (this._texture) {\n      this._engine = this._texture.getEngine();\n    }\n  }\n\n  Object.defineProperty(ThinTexture.prototype, \"wrapU\", {\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n    get: function () {\n      return this._wrapU;\n    },\n    set: function (value) {\n      this._wrapU = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"wrapV\", {\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n    get: function () {\n      return this._wrapV;\n    },\n    set: function (value) {\n      this._wrapV = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"coordinatesMode\", {\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"isCube\", {\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.isCube;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.isCube = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"is3D\", {\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is3D;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is3D = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ThinTexture.prototype, \"is2DArray\", {\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is2DArray;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is2DArray = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the class name of the texture.\r\n   * @returns \"ThinTexture\"\r\n   */\n\n  ThinTexture.prototype.getClassName = function () {\n    return \"ThinTexture\";\n  };\n  /**\r\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n   * @returns true if fully ready\r\n   */\n\n\n  ThinTexture.prototype.isReady = function () {\n    if (this.delayLoadState === 4) {\n      this.delayLoad();\n      return false;\n    }\n\n    if (this._texture) {\n      return this._texture.isReady;\n    }\n\n    return false;\n  };\n  /**\r\n   * Triggers the load sequence in delayed load mode.\r\n   */\n\n\n  ThinTexture.prototype.delayLoad = function () {};\n  /**\r\n   * Get the underlying lower level texture from Babylon.\r\n   * @returns the insternal texture\r\n   */\n\n\n  ThinTexture.prototype.getInternalTexture = function () {\n    return this._texture;\n  };\n  /**\r\n   * Get the size of the texture.\r\n   * @returns the texture size.\r\n   */\n\n\n  ThinTexture.prototype.getSize = function () {\n    if (this._texture) {\n      if (this._texture.width) {\n        this._cachedSize.width = this._texture.width;\n        this._cachedSize.height = this._texture.height;\n        return this._cachedSize;\n      }\n\n      if (this._texture._size) {\n        this._cachedSize.width = this._texture._size;\n        this._cachedSize.height = this._texture._size;\n        return this._cachedSize;\n      }\n    }\n\n    return this._cachedSize;\n  };\n  /**\r\n   * Get the base size of the texture.\r\n   * It can be different from the size if the texture has been resized for POT for instance\r\n   * @returns the base size\r\n   */\n\n\n  ThinTexture.prototype.getBaseSize = function () {\n    if (!this.isReady() || !this._texture) {\n      this._cachedBaseSize.width = 0;\n      this._cachedBaseSize.height = 0;\n      return this._cachedBaseSize;\n    }\n\n    if (this._texture._size) {\n      this._cachedBaseSize.width = this._texture._size;\n      this._cachedBaseSize.height = this._texture._size;\n      return this._cachedBaseSize;\n    }\n\n    this._cachedBaseSize.width = this._texture.baseWidth;\n    this._cachedBaseSize.height = this._texture.baseHeight;\n    return this._cachedBaseSize;\n  };\n  /**\r\n   * Update the sampling mode of the texture.\r\n   * Default is Trilinear mode.\r\n   *\r\n   * | Value | Type               | Description |\r\n   * | ----- | ------------------ | ----------- |\r\n   * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n   * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n   * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n   * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n   * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n   * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n   * | 7    | NEAREST_LINEAR |             |\r\n   * | 8    | NEAREST_NEAREST |             |\r\n   * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n   * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n   * | 11   | LINEAR_LINEAR |             |\r\n   * | 12   | LINEAR_NEAREST |             |\r\n   *\r\n   *    > _mag_: magnification filter (close to the viewer)\r\n   *    > _min_: minification filter (far from the viewer)\r\n   *    > _mip_: filter used between mip map levels\r\n   *@param samplingMode Define the new sampling mode of the texture\r\n   */\n\n\n  ThinTexture.prototype.updateSamplingMode = function (samplingMode) {\n    if (this._texture && this._engine) {\n      this._engine.updateTextureSamplingMode(samplingMode, this._texture);\n    }\n  };\n  /**\r\n   * Release and destroy the underlying lower level texture aka internalTexture.\r\n   */\n\n\n  ThinTexture.prototype.releaseInternalTexture = function () {\n    if (this._texture) {\n      this._texture.dispose();\n\n      this._texture = null;\n    }\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  ThinTexture.prototype.dispose = function () {\n    if (this._texture) {\n      this.releaseInternalTexture();\n      this._engine = null;\n    }\n  };\n\n  return ThinTexture;\n}();\n\nexport { ThinTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/thinTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\n\r\n\r\nimport { ISize, Size } from '../../Maths/math.size';\r\n\r\nimport { ThinEngine } from '../../Engines/thinEngine';\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = 1;\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = 1;\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = 1;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = 0;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    public set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    public set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    public set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<ThinEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture>) {\r\n        this._texture = internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === 4) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {\r\n    }\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the insternal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}