{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { Plane } from '../Maths/math.plane';\n\nvar intersectBoxAASphere = function (boxMin, boxMax, sphereCenter, sphereRadius) {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n\n  return true;\n};\n\nvar getLowestRoot = function () {\n  var result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    var determinant = b * b - 4.0 * a * c;\n\n    if (determinant < 0) {\n      return result;\n    }\n\n    var sqrtD = Math.sqrt(determinant);\n    var r1 = (-b - sqrtD) / (2.0 * a);\n    var r2 = (-b + sqrtD) / (2.0 * a);\n\n    if (r1 > r2) {\n      var temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n\n    return result;\n  };\n}();\n/** @hidden */\n\n\nvar Collider =\n/** @class */\nfunction () {\n  function Collider() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @hidden */\n\n    this._radius = Vector3.One();\n    /** @hidden */\n\n    this._retry = 0;\n    /** @hidden */\n\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n\n  Object.defineProperty(Collider.prototype, \"collisionMask\", {\n    get: function () {\n      return this._collisionMask;\n    },\n    set: function (mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Collider.prototype, \"slidePlaneNormal\", {\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\n    get: function () {\n      return this._slidePlaneNormal;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /** @hidden */\n\n  Collider.prototype._initialize = function (source, dir, e) {\n    this._velocity = dir;\n    Vector3.NormalizeToRef(dir, this._normalizedVelocity);\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    var d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n\n    if (d < 0) {\n      return false;\n    }\n\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {\n    var distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    var max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n\n    return true;\n  };\n  /** @hidden */\n\n\n  Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    var t0;\n    var embeddedInPlane = false; //defensive programming, actually not needed.\n\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n\n    var trianglePlane = trianglePlaneArray[faceIndex];\n\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n\n    var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n\n      if (t0 > t1) {\n        var temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n\n      if (t0 < 0) {\n        t0 = 0;\n      }\n\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n\n    var found = false;\n    var t = 1.0;\n\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n\n      this._velocity.scaleToRef(t0, this._tempVector);\n\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n\n    if (!found) {\n      var velocitySquaredLength = this._velocity.lengthSquared();\n\n      var a = velocitySquaredLength;\n\n      this._basePoint.subtractToRef(p1, this._tempVector);\n\n      var b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      var c = this._tempVector.lengthSquared() - 1.0;\n      var lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p1);\n      }\n\n      this._basePoint.subtractToRef(p2, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p2);\n      }\n\n      this._basePoint.subtractToRef(p3, this._tempVector);\n\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n\n        this._collisionPoint.copyFrom(p3);\n      }\n\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n\n      var edgeSquaredLength = this._edge.lengthSquared();\n\n      var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n\n      if (lowestRoot.found) {\n        f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n\n          this._edge.scaleInPlace(f);\n\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n\n    if (found) {\n      var distToCollision = t * this._velocity.length();\n\n      if (!this.collisionFound || distToCollision < this._nearestDistance) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n\n          this._nearestDistance = distToCollision;\n          this.collisionFound = true;\n        }\n\n        this.collidedMesh = hostMesh;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh) {\n    if (!indices || indices.length === 0) {\n      for (var i = 0; i < pts.length; i += 3) {\n        var p1 = pts[i];\n        var p2 = pts[i + 1];\n        var p3 = pts[i + 2];\n\n        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n      }\n    } else {\n      for (var i = indexStart; i < indexEnd; i += 3) {\n        var p1 = pts[indices[i] - decal];\n        var p2 = pts[indices[i + 1] - decal];\n        var p3 = pts[indices[i + 2] - decal];\n\n        this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Collider.prototype._getResponse = function (pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n\n    this._basePoint.addToRef(vel, pos);\n\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n\n    this._slidePlaneNormal.normalize();\n\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  };\n\n  return Collider;\n}();\n\nexport { Collider };","map":{"version":3,"sources":["../../../sourceES6/core/Collisions/collider.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Plane } from '../Maths/math.plane';\r\n\r\nvar intersectBoxAASphere = (boxMin: Vector3, boxMax: Vector3, sphereCenter: Vector3, sphereRadius: number): boolean => {\r\n    if (boxMin.x > sphereCenter.x + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.x - sphereRadius > boxMax.x) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.y > sphereCenter.y + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.y - sphereRadius > boxMax.y) {\r\n        return false;\r\n    }\r\n\r\n    if (boxMin.z > sphereCenter.z + sphereRadius) {\r\n        return false;\r\n    }\r\n\r\n    if (sphereCenter.z - sphereRadius > boxMax.z) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nvar getLowestRoot: (a: number, b: number, c: number, maxR: number) => { root: number, found: boolean } =\r\n    (function() {\r\n        var result = { root: 0, found: false };\r\n        return function(a: number, b: number, c: number, maxR: number) {\r\n            result.root = 0; result.found = false;\r\n            var determinant = b * b - 4.0 * a * c;\r\n            if (determinant < 0) {\r\n                return result;\r\n            }\r\n\r\n            var sqrtD = Math.sqrt(determinant);\r\n            var r1 = (-b - sqrtD) / (2.0 * a);\r\n            var r2 = (-b + sqrtD) / (2.0 * a);\r\n\r\n            if (r1 > r2) {\r\n                var temp = r2;\r\n                r2 = r1;\r\n                r1 = temp;\r\n            }\r\n\r\n            if (r1 > 0 && r1 < maxR) {\r\n                result.root = r1;\r\n                result.found = true;\r\n                return result;\r\n            }\r\n\r\n            if (r2 > 0 && r2 < maxR) {\r\n                result.root = r2;\r\n                result.found = true;\r\n                return result;\r\n            }\r\n\r\n            return result;\r\n        };\r\n    }\r\n    )();\r\n\r\n/** @hidden */\r\nexport class Collider {\r\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\r\n    // https://www.peroxide.dk/papers/collision/collision.pdf\r\n\r\n    /** Define if a collision was found */\r\n    public collisionFound: boolean;\r\n\r\n    /**\r\n     * Define last intersection point in local space\r\n     */\r\n    public intersectionPoint: Vector3;\r\n\r\n    /**\r\n     * Define last collided mesh\r\n     */\r\n    public collidedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _collisionPoint = Vector3.Zero();\r\n    private _planeIntersectionPoint = Vector3.Zero();\r\n    private _tempVector = Vector3.Zero();\r\n    private _tempVector2 = Vector3.Zero();\r\n    private _tempVector3 = Vector3.Zero();\r\n    private _tempVector4 = Vector3.Zero();\r\n    private _edge = Vector3.Zero();\r\n    private _baseToVertex = Vector3.Zero();\r\n    private _destinationPoint = Vector3.Zero();\r\n    private _slidePlaneNormal = Vector3.Zero();\r\n    private _displacementVector = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _radius = Vector3.One();\r\n    /** @hidden */\r\n    public _retry = 0;\r\n    private _velocity: Vector3;\r\n    private _basePoint: Vector3;\r\n    private _epsilon: number;\r\n    /** @hidden */\r\n    public _velocityWorldLength: number;\r\n    /** @hidden */\r\n    public _basePointWorld = Vector3.Zero();\r\n    private _velocityWorld = Vector3.Zero();\r\n    private _normalizedVelocity = Vector3.Zero();\r\n    /** @hidden */\r\n    public _initialVelocity: Vector3;\r\n    /** @hidden */\r\n    public _initialPosition: Vector3;\r\n    private _nearestDistance: number;\r\n\r\n    private _collisionMask = -1;\r\n\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the plane normal used to compute the sliding response (in local space)\r\n     */\r\n    public get slidePlaneNormal(): Vector3 {\r\n        return this._slidePlaneNormal;\r\n    }\r\n\r\n    // Methods\r\n    /** @hidden */\r\n    public _initialize(source: Vector3, dir: Vector3, e: number): void {\r\n        this._velocity = dir;\r\n        Vector3.NormalizeToRef(dir, this._normalizedVelocity);\r\n        this._basePoint = source;\r\n\r\n        source.multiplyToRef(this._radius, this._basePointWorld);\r\n        dir.multiplyToRef(this._radius, this._velocityWorld);\r\n\r\n        this._velocityWorldLength = this._velocityWorld.length();\r\n\r\n        this._epsilon = e;\r\n        this.collisionFound = false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkPointInTriangle(point: Vector3, pa: Vector3, pb: Vector3, pc: Vector3, n: Vector3): boolean {\r\n        pa.subtractToRef(point, this._tempVector);\r\n        pb.subtractToRef(point, this._tempVector2);\r\n\r\n        Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\r\n        var d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        pc.subtractToRef(point, this._tempVector3);\r\n        Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        if (d < 0) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\r\n        d = Vector3.Dot(this._tempVector4, n);\r\n        return d >= 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _canDoCollision(sphereCenter: Vector3, sphereRadius: number, vecMin: Vector3, vecMax: Vector3): boolean {\r\n        var distance = Vector3.Distance(this._basePointWorld, sphereCenter);\r\n\r\n        var max = Math.max(this._radius.x, this._radius.y, this._radius.z);\r\n\r\n        if (distance > this._velocityWorldLength + max + sphereRadius) {\r\n            return false;\r\n        }\r\n\r\n        if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _testTriangle(faceIndex: number, trianglePlaneArray: Array<Plane>, p1: Vector3, p2: Vector3, p3: Vector3, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        var t0;\r\n        var embeddedInPlane = false;\r\n\r\n        //defensive programming, actually not needed.\r\n        if (!trianglePlaneArray) {\r\n            trianglePlaneArray = [];\r\n        }\r\n\r\n        if (!trianglePlaneArray[faceIndex]) {\r\n            trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\r\n            trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\r\n        }\r\n\r\n        var trianglePlane = trianglePlaneArray[faceIndex];\r\n\r\n        if ((!hasMaterial) && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\r\n            return;\r\n        }\r\n\r\n        var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\r\n        var normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\r\n\r\n        if (normalDotVelocity == 0) {\r\n            if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\r\n                return;\r\n            }\r\n            embeddedInPlane = true;\r\n            t0 = 0;\r\n        }\r\n        else {\r\n            t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n            var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\r\n\r\n            if (t0 > t1) {\r\n                var temp = t1;\r\n                t1 = t0;\r\n                t0 = temp;\r\n            }\r\n\r\n            if (t0 > 1.0 || t1 < 0.0) {\r\n                return;\r\n            }\r\n\r\n            if (t0 < 0) {\r\n                t0 = 0;\r\n            }\r\n            if (t0 > 1.0) {\r\n                t0 = 1.0;\r\n            }\r\n        }\r\n\r\n        this._collisionPoint.copyFromFloats(0, 0, 0);\r\n\r\n        var found = false;\r\n        var t = 1.0;\r\n\r\n        if (!embeddedInPlane) {\r\n            this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\r\n            this._velocity.scaleToRef(t0, this._tempVector);\r\n            this._planeIntersectionPoint.addInPlace(this._tempVector);\r\n\r\n            if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\r\n                found = true;\r\n                t = t0;\r\n                this._collisionPoint.copyFrom(this._planeIntersectionPoint);\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            var velocitySquaredLength = this._velocity.lengthSquared();\r\n\r\n            var a = velocitySquaredLength;\r\n\r\n            this._basePoint.subtractToRef(p1, this._tempVector);\r\n            var b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));\r\n            var c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            var lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p1);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p2, this._tempVector);\r\n            b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p2);\r\n            }\r\n\r\n            this._basePoint.subtractToRef(p3, this._tempVector);\r\n            b = 2.0 * (Vector3.Dot(this._velocity, this._tempVector));\r\n            c = this._tempVector.lengthSquared() - 1.0;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                t = lowestRoot.root;\r\n                found = true;\r\n                this._collisionPoint.copyFrom(p3);\r\n            }\r\n\r\n            p2.subtractToRef(p1, this._edge);\r\n            p1.subtractToRef(this._basePoint, this._baseToVertex);\r\n            var edgeSquaredLength = this._edge.lengthSquared();\r\n            var edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            var edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\r\n            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p1.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p3.subtractToRef(p2, this._edge);\r\n            p2.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\r\n            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p2.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n\r\n            p1.subtractToRef(p3, this._edge);\r\n            p3.subtractToRef(this._basePoint, this._baseToVertex);\r\n            edgeSquaredLength = this._edge.lengthSquared();\r\n            edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\r\n            edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\r\n\r\n            a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\r\n            b = edgeSquaredLength * (2.0 * Vector3.Dot(this._velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\r\n            c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\r\n\r\n            lowestRoot = getLowestRoot(a, b, c, t);\r\n            if (lowestRoot.found) {\r\n                f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\r\n\r\n                if (f >= 0.0 && f <= 1.0) {\r\n                    t = lowestRoot.root;\r\n                    found = true;\r\n                    this._edge.scaleInPlace(f);\r\n                    p3.addToRef(this._edge, this._collisionPoint);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            var distToCollision = t * this._velocity.length();\r\n\r\n            if (!this.collisionFound || distToCollision < this._nearestDistance) {\r\n                // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\r\n                // onCollide observable are triggered if collideMesh is set\r\n                // this allow trigger volumes to be created.\r\n                if (hostMesh.collisionResponse) {\r\n                    if (!this.intersectionPoint) {\r\n                        this.intersectionPoint = this._collisionPoint.clone();\r\n                    } else {\r\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\r\n                    }\r\n                    this._nearestDistance = distToCollision;\r\n                    this.collisionFound = true;\r\n                }\r\n                this.collidedMesh = hostMesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _collide(trianglePlaneArray: Array<Plane>, pts: Vector3[], indices: IndicesArray, indexStart: number, indexEnd: number, decal: number, hasMaterial: boolean, hostMesh: AbstractMesh): void {\r\n        if (!indices || indices.length === 0) {\r\n            for (let i = 0; i < pts.length; i += 3) {\r\n                const p1 = pts[i];\r\n                const p2 = pts[i + 1];\r\n                const p3 = pts[i + 2];\r\n\r\n                this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n            }\r\n        } else {\r\n            for (let i = indexStart; i < indexEnd; i += 3) {\r\n                const p1 = pts[indices[i] - decal];\r\n                const p2 = pts[indices[i + 1] - decal];\r\n                const p3 = pts[indices[i + 2] - decal];\r\n\r\n                this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getResponse(pos: Vector3, vel: Vector3): void {\r\n        pos.addToRef(vel, this._destinationPoint);\r\n        vel.scaleInPlace((this._nearestDistance / vel.length()));\r\n\r\n        this._basePoint.addToRef(vel, pos);\r\n        pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\r\n        this._slidePlaneNormal.normalize();\r\n        this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\r\n\r\n        pos.addInPlace(this._displacementVector);\r\n        this.intersectionPoint.addInPlace(this._displacementVector);\r\n\r\n        this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\r\n        this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\r\n\r\n        this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}