{"ast":null,"code":"import { Color3 } from '../Maths/math.color';\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { ParticleSystem } from \"../Particles/particleSystem\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/** Internal class used to store shapes for emitters */\n\nvar ParticleSystemSetEmitterCreationOptions =\n/** @class */\nfunction () {\n  function ParticleSystemSetEmitterCreationOptions() {}\n\n  return ParticleSystemSetEmitterCreationOptions;\n}();\n/**\r\n * Represents a set of particle systems working together to create a specific effect\r\n */\n\n\nvar ParticleSystemSet =\n/** @class */\nfunction () {\n  function ParticleSystemSet() {\n    /**\r\n     * Gets the particle system list\r\n     */\n    this.systems = new Array();\n  }\n\n  Object.defineProperty(ParticleSystemSet.prototype, \"emitterNode\", {\n    /**\r\n     * Gets the emitter node used with this set\r\n     */\n    get: function () {\n      return this._emitterNode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a new emitter mesh as a sphere\r\n   * @param options defines the options used to create the sphere\r\n   * @param renderingGroupId defines the renderingGroupId to use for the sphere\r\n   * @param scene defines the hosting scene\r\n   */\n\n  ParticleSystemSet.prototype.setEmitterAsSphere = function (options, renderingGroupId, scene) {\n    if (this._emitterNode) {\n      this._emitterNode.dispose();\n    }\n\n    this._emitterCreationOptions = {\n      kind: \"Sphere\",\n      options: options,\n      renderingGroupId: renderingGroupId\n    };\n    var emitterMesh = SphereBuilder.CreateSphere(\"emitterSphere\", {\n      diameter: options.diameter,\n      segments: options.segments\n    }, scene);\n    emitterMesh.renderingGroupId = renderingGroupId;\n    var material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n    material.emissiveColor = options.color;\n    emitterMesh.material = material;\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.emitter = emitterMesh;\n    }\n\n    this._emitterNode = emitterMesh;\n  };\n  /**\r\n   * Starts all particle systems of the set\r\n   * @param emitter defines an optional mesh to use as emitter for the particle systems\r\n   */\n\n\n  ParticleSystemSet.prototype.start = function (emitter) {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n\n      if (emitter) {\n        system.emitter = emitter;\n      }\n\n      system.start();\n    }\n  };\n  /**\r\n   * Release all associated resources\r\n   */\n\n\n  ParticleSystemSet.prototype.dispose = function () {\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      system.dispose();\n    }\n\n    this.systems = [];\n\n    if (this._emitterNode) {\n      this._emitterNode.dispose();\n\n      this._emitterNode = null;\n    }\n  };\n  /**\r\n   * Serialize the set into a JSON compatible object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns a JSON compatible representation of the set\r\n   */\n\n\n  ParticleSystemSet.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var result = {};\n    result.systems = [];\n\n    for (var _i = 0, _a = this.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(system.serialize(serializeTexture));\n    }\n\n    if (this._emitterNode) {\n      result.emitter = this._emitterCreationOptions;\n    }\n\n    return result;\n  };\n  /**\r\n   * Parse a new ParticleSystemSet from a serialized source\r\n   * @param data defines a JSON compatible representation of the set\r\n   * @param scene defines the hosting scene\r\n   * @param gpu defines if we want GPU particles or CPU particles\r\n   * @returns a new ParticleSystemSet\r\n   */\n\n\n  ParticleSystemSet.Parse = function (data, scene, gpu) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    var result = new ParticleSystemSet();\n    var rootUrl = this.BaseAssetsUrl + \"/textures/\";\n    scene = scene || EngineStore.LastCreatedScene;\n\n    for (var _i = 0, _a = data.systems; _i < _a.length; _i++) {\n      var system = _a[_i];\n      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true) : ParticleSystem.Parse(system, scene, rootUrl, true));\n    }\n\n    if (data.emitter) {\n      var options = data.emitter.options;\n\n      switch (data.emitter.kind) {\n        case \"Sphere\":\n          result.setEmitterAsSphere({\n            diameter: options.diameter,\n            segments: options.segments,\n            color: Color3.FromArray(options.color)\n          }, data.emitter.renderingGroupId, scene);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Gets or sets base Assets URL\r\n   */\n\n\n  ParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n  return ParticleSystemSet;\n}();\n\nexport { ParticleSystemSet };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/particleSystemSet.ts"],"names":[],"mappings":"AACA,SAAS,MAAT,QAAuB,qBAAvB;AAGA,SAAS,aAAT,QAA8B,kCAA9B;AAEA,SAAS,iBAAT,QAAkC,qBAAlC;AACA,SAAS,WAAT,QAA4B,wBAA5B;AACA,SAAS,cAAT,QAA+B,6BAA/B;AAEA,SAAS,gBAAT,QAAiC,+BAAjC;AAEA;;AACA,IAAA,uCAAA;AAAA;AAAA,YAAA;AAAA,WAAA,uCAAA,GAAA,CAIC;;AAAD,SAAA,uCAAA;AAAC,CAJD,EAAA;AAMA;;;;;AAGA,IAAA,iBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,iBAAA,GAAA;AASI;;;AAGO,SAAA,OAAA,GAAU,IAAI,KAAJ,EAAV;AAyHV;;AApHG,EAAA,MAAA,CAAA,cAAA,CAAW,iBAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,aAAO,KAAK,YAAZ;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAIA;;;;;;;AAMO,EAAA,iBAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,OAA1B,EAA0F,gBAA1F,EAAoH,KAApH,EAAgI;AAC5H,QAAI,KAAK,YAAT,EAAuB;AACnB,WAAK,YAAL,CAAkB,OAAlB;AACH;;AAED,SAAK,uBAAL,GAA+B;AAC3B,MAAA,IAAI,EAAE,QADqB;AAE3B,MAAA,OAAO,EAAE,OAFkB;AAG3B,MAAA,gBAAgB,EAAE;AAHS,KAA/B;AAMA,QAAI,WAAW,GAAG,aAAa,CAAC,YAAd,CAA2B,eAA3B,EAA4C;AAAE,MAAA,QAAQ,EAAE,OAAO,CAAC,QAApB;AAA8B,MAAA,QAAQ,EAAE,OAAO,CAAC;AAAhD,KAA5C,EAAwG,KAAxG,CAAlB;AACA,IAAA,WAAW,CAAC,gBAAZ,GAA+B,gBAA/B;AAEA,QAAI,QAAQ,GAAG,IAAI,gBAAJ,CAAqB,uBAArB,EAA8C,KAA9C,CAAf;AACA,IAAA,QAAQ,CAAC,aAAT,GAAyB,OAAO,CAAC,KAAjC;AACA,IAAA,WAAW,CAAC,QAAZ,GAAuB,QAAvB;;AAEA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAiC;AAA5B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,MAAM,CAAC,OAAP,GAAiB,WAAjB;AACH;;AAED,SAAK,YAAL,GAAoB,WAApB;AACH,GAvBM;AAyBP;;;;;;AAIO,EAAA,iBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,OAAb,EAAmC;AAC/B,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAiC;AAA5B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;;AACD,UAAI,OAAJ,EAAa;AACT,QAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;AACH;;AACD,MAAA,MAAM,CAAC,KAAP;AACH;AACJ,GAPM;AASP;;;;;AAGO,EAAA,iBAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAiC;AAA5B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,MAAM,CAAC,OAAP;AACH;;AAED,SAAK,OAAL,GAAe,EAAf;;AAEA,QAAI,KAAK,YAAT,EAAuB;AACnB,WAAK,YAAL,CAAkB,OAAlB;;AACA,WAAK,YAAL,GAAoB,IAApB;AACH;AACJ,GAXM;AAaP;;;;;;;AAKO,EAAA,iBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,gBAAjB,EAAyC;AAAxB,QAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,gBAAA,GAAA,KAAA;AAAwB;;AACrC,QAAI,MAAM,GAAQ,EAAlB;AAEA,IAAA,MAAM,CAAC,OAAP,GAAiB,EAAjB;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAiC;AAA5B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,MAAM,CAAC,SAAP,CAAiB,gBAAjB,CAApB;AACH;;AAED,QAAI,KAAK,YAAT,EAAuB;AACnB,MAAA,MAAM,CAAC,OAAP,GAAiB,KAAK,uBAAtB;AACH;;AAED,WAAO,MAAP;AACH,GAbM;AAeP;;;;;;;;;AAOc,EAAA,iBAAA,CAAA,KAAA,GAAd,UAAoB,IAApB,EAA+B,KAA/B,EAA6C,GAA7C,EAAwD;AAAX,QAAA,GAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,GAAA,GAAA,KAAA;AAAW;;AACpD,QAAI,MAAM,GAAG,IAAI,iBAAJ,EAAb;AACA,QAAI,OAAO,GAAG,KAAK,aAAL,GAAqB,YAAnC;AAEA,IAAA,KAAK,GAAG,KAAK,IAAI,WAAW,CAAC,gBAA7B;;AAEA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,IAAI,CAAC,OAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAiC;AAA5B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,GAAG,GAAG,iBAAiB,CAAC,KAAlB,CAAwB,MAAxB,EAAgC,KAAhC,EAAuC,OAAvC,EAAgD,IAAhD,CAAH,GAA2D,cAAc,CAAC,KAAf,CAAqB,MAArB,EAA6B,KAA7B,EAAoC,OAApC,EAA6C,IAA7C,CAAlF;AACH;;AAED,QAAI,IAAI,CAAC,OAAT,EAAkB;AACd,UAAI,OAAO,GAAG,IAAI,CAAC,OAAL,CAAa,OAA3B;;AACA,cAAQ,IAAI,CAAC,OAAL,CAAa,IAArB;AACI,aAAK,QAAL;AACI,UAAA,MAAM,CAAC,kBAAP,CAA0B;AACtB,YAAA,QAAQ,EAAE,OAAO,CAAC,QADI;AAEtB,YAAA,QAAQ,EAAE,OAAO,CAAC,QAFI;AAGtB,YAAA,KAAK,EAAE,MAAM,CAAC,SAAP,CAAiB,OAAO,CAAC,KAAzB;AAHe,WAA1B,EAIG,IAAI,CAAC,OAAL,CAAa,gBAJhB,EAIkC,KAJlC;AAKA;AAPR;AASH;;AAED,WAAO,MAAP;AACH,GAxBa;AA3Gd;;;;;AAGc,EAAA,iBAAA,CAAA,aAAA,GAAgB,wCAAhB;AAiIlB,SAAA,iBAAA;AAAC,CArID,EAAA;;SAAa,iB","sourcesContent":["import { Nullable } from \"../types\";\nimport { Color3 } from '../Maths/math.color';\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { IParticleSystem } from \"./IParticleSystem\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { ParticleSystem } from \"../Particles/particleSystem\";\nimport { Scene, IDisposable } from \"../scene\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n\n/** Internal class used to store shapes for emitters */\nclass ParticleSystemSetEmitterCreationOptions {\n    public kind: string;\n    public options: any;\n    public renderingGroupId: number;\n}\n\n/**\n * Represents a set of particle systems working together to create a specific effect\n */\nexport class ParticleSystemSet implements IDisposable {\n    /**\n     * Gets or sets base Assets URL\n     */\n    public static BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n\n    private _emitterCreationOptions: ParticleSystemSetEmitterCreationOptions;\n    private _emitterNode: Nullable<TransformNode>;\n\n    /**\n     * Gets the particle system list\n     */\n    public systems = new Array<IParticleSystem>();\n\n    /**\n     * Gets the emitter node used with this set\n     */\n    public get emitterNode(): Nullable<TransformNode> {\n        return this._emitterNode;\n    }\n\n    /**\n     * Creates a new emitter mesh as a sphere\n     * @param options defines the options used to create the sphere\n     * @param renderingGroupId defines the renderingGroupId to use for the sphere\n     * @param scene defines the hosting scene\n     */\n    public setEmitterAsSphere(options: { diameter: number, segments: number, color: Color3 }, renderingGroupId: number, scene: Scene) {\n        if (this._emitterNode) {\n            this._emitterNode.dispose();\n        }\n\n        this._emitterCreationOptions = {\n            kind: \"Sphere\",\n            options: options,\n            renderingGroupId: renderingGroupId\n        };\n\n        let emitterMesh = SphereBuilder.CreateSphere(\"emitterSphere\", { diameter: options.diameter, segments: options.segments }, scene);\n        emitterMesh.renderingGroupId = renderingGroupId;\n\n        var material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n        material.emissiveColor = options.color;\n        emitterMesh.material = material;\n\n        for (var system of this.systems) {\n            system.emitter = emitterMesh;\n        }\n\n        this._emitterNode = emitterMesh;\n    }\n\n    /**\n     * Starts all particle systems of the set\n     * @param emitter defines an optional mesh to use as emitter for the particle systems\n     */\n    public start(emitter?: AbstractMesh): void {\n        for (var system of this.systems) {\n            if (emitter) {\n                system.emitter = emitter;\n            }\n            system.start();\n        }\n    }\n\n    /**\n     * Release all associated resources\n     */\n    public dispose(): void {\n        for (var system of this.systems) {\n            system.dispose();\n        }\n\n        this.systems = [];\n\n        if (this._emitterNode) {\n            this._emitterNode.dispose();\n            this._emitterNode = null;\n        }\n    }\n\n    /**\n     * Serialize the set into a JSON compatible object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns a JSON compatible representation of the set\n     */\n    public serialize(serializeTexture = false): any {\n        var result: any = {};\n\n        result.systems = [];\n        for (var system of this.systems) {\n            result.systems.push(system.serialize(serializeTexture));\n        }\n\n        if (this._emitterNode) {\n            result.emitter = this._emitterCreationOptions;\n        }\n\n        return result;\n    }\n\n    /**\n     * Parse a new ParticleSystemSet from a serialized source\n     * @param data defines a JSON compatible representation of the set\n     * @param scene defines the hosting scene\n     * @param gpu defines if we want GPU particles or CPU particles\n     * @returns a new ParticleSystemSet\n     */\n    public static Parse(data: any, scene: Scene, gpu = false): ParticleSystemSet {\n        var result = new ParticleSystemSet();\n        var rootUrl = this.BaseAssetsUrl + \"/textures/\";\n\n        scene = scene || EngineStore.LastCreatedScene;\n\n        for (var system of data.systems) {\n            result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true) : ParticleSystem.Parse(system, scene, rootUrl, true));\n        }\n\n        if (data.emitter) {\n            let options = data.emitter.options;\n            switch (data.emitter.kind) {\n                case \"Sphere\":\n                    result.setEmitterAsSphere({\n                        diameter: options.diameter,\n                        segments: options.segments,\n                        color: Color3.FromArray(options.color)\n                    }, data.emitter.renderingGroupId, scene);\n                    break;\n            }\n        }\n\n        return result;\n    }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}