{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { InputBlock } from '../Input/inputBlock';\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { CubeTexture } from '../../../Textures/cubeTexture';\nimport { Texture } from '../../../Textures/texture';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { Scalar } from '../../../../Maths/math.scalar';\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\n\nvar RefractionBlock =\n/** @class */\nfunction (_super) {\n  __extends(RefractionBlock, _super);\n  /**\r\n   * Create a new RefractionBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function RefractionBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\n\n\n    _this.linkRefractionWithTransparency = false;\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\n\n    _this.invertRefractionY = false;\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", _this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  RefractionBlock.prototype.getClassName = function () {\n    return \"RefractionBlock\";\n  };\n\n  Object.defineProperty(RefractionBlock.prototype, \"intensity\", {\n    /**\r\n     * Gets the intensity input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"tintAtDistance\", {\n    /**\r\n     * Gets the tint at distance input component\r\n     */\n    get: function () {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"view\", {\n    /**\r\n     * Gets the view input component\r\n     */\n    get: function () {\n      return this.viewConnectionPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"refraction\", {\n    /**\r\n     * Gets the refraction object output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RefractionBlock.prototype, \"hasTexture\", {\n    /**\r\n     * Returns true if the block has a texture\r\n     */\n    get: function () {\n      return !!this._getTexture();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RefractionBlock.prototype._getTexture = function () {\n    if (this.texture) {\n      return this.texture;\n    }\n\n    return this._scene.environmentTexture;\n  };\n\n  RefractionBlock.prototype.autoConfigure = function (material) {\n    if (!this.intensity.isConnected) {\n      var intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  RefractionBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    var refractionTexture = this._getTexture();\n\n    var refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n\n    if (!refraction) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n  };\n\n  RefractionBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  RefractionBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {\n    var _a, _b;\n\n    _super.prototype.bind.call(this, effect, nodeMaterial, mesh);\n\n    var refractionTexture = this._getTexture();\n\n    if (!refractionTexture) {\n      return;\n    }\n\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\n    var depth = 1.0;\n\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n\n    var indexOfRefraction = (_b = (_a = this.indexOfRefractionConnectionPoint.connectInputBlock) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat3(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\n    var width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n  };\n  /**\r\n   * Gets the main code of the block (fragment side)\r\n   * @param state current state of the node material building\r\n   * @returns the shader code\r\n   */\n\n\n  RefractionBlock.prototype.getCode = function (state) {\n    var code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += \"#ifdef \" + this._define3DName + \"\\r\\n\";\n    state._samplerDeclaration += \"uniform samplerCube \" + this._cubeSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \" + this._2DSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n\n    state._emitFunction(\"sampleRefraction\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleRefraction(s, c) textureCube(s, c)\\n            #else\\n                #define sampleRefraction(s, c) texture2D(s, c)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    state._emitFunction(\"sampleRefractionLod\", \"\\n            #ifdef \" + this._define3DName + \"\\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\\n            #else\\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\\n            #endif\\r\\n\", \"//\" + this.name);\n\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec3\");\n\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n\n    return code;\n  };\n\n  RefractionBlock.prototype._buildBlock = function (state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  };\n\n  RefractionBlock.prototype._dumpPropertiesCode = function () {\n    var codeString = _super.prototype._dumpPropertiesCode.call(this);\n\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = this._codeVariableName + \".texture = new BABYLON.CubeTexture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n      } else {\n        codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n      }\n\n      codeString += this._codeVariableName + \".texture.coordinatesMode = \" + this.texture.coordinatesMode + \";\\r\\n\";\n    }\n\n    codeString += this._codeVariableName + \".linkRefractionWithTransparency = \" + this.linkRefractionWithTransparency + \";\\r\\n\";\n    codeString += this._codeVariableName + \".invertRefractionY = \" + this.invertRefractionY + \";\\r\\n\";\n    return codeString;\n  };\n\n  RefractionBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    return serializationObject;\n  };\n\n  RefractionBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n  };\n\n  __decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n    \"notifiers\": {\n      \"update\": true\n    }\n  })], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n\n  return RefractionBlock;\n}(NodeMaterialBlock);\n\nexport { RefractionBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.RefractionBlock\"] = RefractionBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/PBR/refractionBlock.ts"],"names":[],"mappings":";AAAA,SAAS,qCAAT,QAAsD,mDAAtD;AAEA,SAAsC,oCAAtC,QAAkF,wCAAlF;AACA,SAAS,wBAAT,QAAyC,sCAAzC;AAEA,SAAS,UAAT,QAA2B,4BAA3B;AACA,SAAS,UAAT,QAA2B,qBAA3B;AACA,SAAS,uCAAT,QAAwD,+CAAxD;AAOA,SAAS,sBAAT,EAAiC,sBAAjC,QAA+D,6BAA/D;AAEA,SAAS,iBAAT,QAAkC,yBAAlC;AACA,SAAS,WAAT,QAA4B,+BAA5B;AACA,SAAS,OAAT,QAAwB,2BAAxB;AACA,SAAS,wBAAT,QAAyC,sCAAzC;AACA,SAAS,MAAT,QAAuB,+BAAvB;AAEA;;;;AAGA,IAAA,eAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAqC,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;AAuDjC;;;;;;AAIA,WAAA,eAAA,CAAmB,IAAnB,EAA+B;AAA/B,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,wBAAwB,CAAC,QAArC,KAA8C,IADlD;AAtBA;;;;;;AAKO,IAAA,KAAA,CAAA,8BAAA,GAA0C,KAA1C;AAEP;;;;AAIO,IAAA,KAAA,CAAA,iBAAA,GAA6B,KAA7B;AAcH,IAAA,KAAI,CAAC,SAAL,GAAiB,IAAjB;;AAEA,IAAA,KAAI,CAAC,aAAL,CAAmB,WAAnB,EAAgC,qCAAqC,CAAC,KAAtE,EAA6E,KAA7E,EAAoF,wBAAwB,CAAC,QAA7G;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,gBAAnB,EAAqC,qCAAqC,CAAC,KAA3E,EAAkF,IAAlF,EAAwF,wBAAwB,CAAC,QAAjH;;AAEA,IAAA,KAAI,CAAC,cAAL,CAAoB,YAApB,EAAkC,qCAAqC,CAAC,MAAxE,EAAgF,wBAAwB,CAAC,QAAzG,EACI,IAAI,uCAAJ,CAA4C,YAA5C,EAA0D,KAA1D,EAAgE,oCAAoC,CAAC,MAArG,EAA6G,eAA7G,EAA8H,iBAA9H,CADJ;;;AAEH;AAED;;;;;;AAIO,EAAA,eAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,iBAAP;AACH,GAFM;;AAOP,EAAA,MAAA,CAAA,cAAA,CAAW,eAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,eAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAHzB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFwB;qBAAA;;AAAA,GAAzB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,eAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAHf;;;SAGA,YAAA;AACI,aAAO,KAAK,mBAAZ;AACH,KAFc;qBAAA;;AAAA,GAAf;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,eAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,CAAd,CAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,eAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,CAAC,CAAC,KAAK,WAAL,EAAT;AACH,KAFoB;qBAAA;;AAAA,GAArB;;AAIU,EAAA,eAAA,CAAA,SAAA,CAAA,WAAA,GAAV,YAAA;AACI,QAAI,KAAK,OAAT,EAAkB;AACd,aAAO,KAAK,OAAZ;AACH;;AAED,WAAO,KAAK,MAAL,CAAY,kBAAnB;AACH,GANS;;AAQH,EAAA,eAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,QAArB,EAA2C;AACvC,QAAI,CAAC,KAAK,SAAL,CAAe,WAApB,EAAiC;AAC7B,UAAI,cAAc,GAAG,IAAI,UAAJ,CAAe,sBAAf,EAAuC,wBAAwB,CAAC,QAAhE,EAA0E,qCAAqC,CAAC,KAAhH,CAArB;AACA,MAAA,cAAc,CAAC,KAAf,GAAuB,CAAvB;AACA,MAAA,cAAc,CAAC,MAAf,CAAsB,SAAtB,CAAgC,KAAK,SAArC;AACH;;AAED,QAAI,KAAK,IAAL,IAAa,CAAC,KAAK,IAAL,CAAU,WAA5B,EAAyC;AACrC,UAAI,SAAS,GAAG,QAAQ,CAAC,wBAAT,CAAkC,UAAC,CAAD,EAAE;AAAK,eAAA,CAAC,CAAC,WAAF,KAAkB,wBAAwB,CAA1C,IAAA;AAA+C,OAAxF,CAAhB;;AAEA,UAAI,CAAC,SAAL,EAAgB;AACZ,QAAA,SAAS,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAZ;AACA,QAAA,SAAS,CAAC,gBAAV,CAA2B,wBAAwB,CAAC,IAApD;AACH;;AACD,MAAA,SAAS,CAAC,MAAV,CAAiB,SAAjB,CAA2B,KAAK,IAAhC;AACH;AACJ,GAhBM;;AAkBA,EAAA,eAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,IAAtB,EAA0C,YAA1C,EAAsE,OAAtE,EAAkG;AAC9F,IAAA,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,EAAqB,IAArB,EAA2B,YAA3B,EAAyC,OAAzC;;AAEA,QAAM,iBAAiB,GAAG,KAAK,WAAL,EAA1B;;AACA,QAAM,UAAU,GAAG,iBAAiB,IAAI,iBAAiB,CAAC,gBAA1D;AAEA,IAAA,OAAO,CAAC,QAAR,CAAiB,eAAjB,EAAkC,UAAlC,EAA8C,IAA9C;;AAEA,QAAI,CAAC,UAAL,EAAiB;AACb;AACH;;AAED,IAAA,OAAO,CAAC,QAAR,CAAiB,KAAK,aAAtB,EAAqC,iBAAkB,CAAC,MAAxD,EAAgE,IAAhE;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,KAAK,yBAAtB,EAAiD,iBAAkB,CAAC,eAApE,EAAqF,IAArF;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,KAAK,+BAAtB,EAAuD,iBAAkB,CAAC,iBAA1E,EAA6F,IAA7F;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,KAAK,gBAAtB,EAAwC,KAAK,MAAL,CAAY,oBAAZ,GAAmC,CAAC,iBAAkB,CAAC,OAAvD,GAAiE,iBAAkB,CAAC,OAA5H,EAAqI,IAArI;AAEA,IAAA,OAAO,CAAC,QAAR,CAAiB,iCAAjB,EAAoD,KAAK,8BAAzD,EAAyF,IAAzF;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,oBAAjB,EAAuC,iBAAkB,CAAC,UAA1D,EAAsE,IAAtE;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,mBAAjB,EAAsC,iBAAkB,CAAC,MAAzD,EAAiE,IAAjE;AACH,GApBM;;AAsBA,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAM,OAAO,GAAG,KAAK,WAAL,EAAhB;;AAEA,QAAI,OAAO,IAAI,CAAC,OAAO,CAAC,oBAAR,EAAhB,EAAgD;AAC5C,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH,GARM;;AAUA,EAAA,eAAA,CAAA,SAAA,CAAA,IAAA,GAAP,UAAY,MAAZ,EAA4B,YAA5B,EAAwD,IAAxD,EAAqE,OAArE,EAAsF;;;AAClF,IAAA,MAAA,CAAA,SAAA,CAAM,IAAN,CAAU,IAAV,CAAU,IAAV,EAAW,MAAX,EAAmB,YAAnB,EAAiC,IAAjC;;AAEA,QAAM,iBAAiB,GAAG,KAAK,WAAL,EAA1B;;AAEA,QAAI,CAAC,iBAAL,EAAwB;AACpB;AACH;;AAED,QAAI,iBAAiB,CAAC,MAAtB,EAA8B;AAC1B,MAAA,MAAM,CAAC,UAAP,CAAkB,KAAK,gBAAvB,EAAyC,iBAAzC;AACH,KAFD,MAEO;AACH,MAAA,MAAM,CAAC,UAAP,CAAkB,KAAK,cAAvB,EAAuC,iBAAvC;AACH;;AAED,IAAA,MAAM,CAAC,SAAP,CAAiB,KAAK,qBAAtB,EAA6C,iBAAiB,CAAC,0BAAlB,EAA7C;AAEA,QAAI,KAAK,GAAG,GAAZ;;AACA,QAAI,CAAC,iBAAiB,CAAC,MAAvB,EAA+B;AAC3B,UAAU,iBAAkB,CAAC,KAA7B,EAAoC;AAChC,QAAA,KAAK,GAAS,iBAAkB,CAAC,KAAjC;AACH;AACJ;;AAED,QAAM,iBAAiB,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAG,KAAK,gCAAL,CAAsC,iBAAzC,MAA0D,IAA1D,IAA0D,EAAA,KAAA,KAAA,CAA1D,GAA0D,KAAA,CAA1D,GAA0D,EAAA,CAAE,KAA5D,MAAiE,IAAjE,IAAiE,EAAA,KAAA,KAAA,CAAjE,GAAiE,EAAjE,GAAqE,GAA5F;AAEA,IAAA,MAAM,CAAC,SAAP,CAAiB,KAAK,qBAAtB,EAA6C,iBAAiB,CAAC,KAA/D,EAAsE,IAAI,iBAA1E,EAA6F,KAA7F,EAAoG,KAAK,iBAAL,GAAyB,CAAC,CAA1B,GAA8B,CAAlI;AAEA,IAAA,MAAM,CAAC,SAAP,CAAiB,KAAK,iCAAtB,EAAyD,iBAAiB,CAAC,OAAlB,GAA4B,KAArF,EAA4F,iBAAiB,CAAC,kBAA9G,EAAkI,iBAAiB,CAAC,mBAApJ;AAEA,QAAM,KAAK,GAAG,iBAAiB,CAAC,OAAlB,GAA4B,KAA1C;AAEA,IAAA,MAAM,CAAC,SAAP,CAAiB,KAAK,6BAAtB,EAAqD,KAArD,EAA4D,MAAM,CAAC,IAAP,CAAY,KAAZ,CAA5D;AACH,GAjCM;AAmCP;;;;;;;AAKO,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAA4C;AACxC,QAAI,IAAI,GAAG,EAAX;AAEA,IAAA,KAAK,CAAC,UAAN,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAArC;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,aAAjB,CAA+B,IAA/B,CAAoC,IAApC,EAJwC,CAMxC;;AACA,SAAK,gBAAL,GAAwB,KAAK,CAAC,oBAAN,CAA2B,KAAK,IAAL,GAAY,aAAvC,CAAxB;AACA,IAAA,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,KAAK,gBAAzB;AAEA,SAAK,cAAL,GAAsB,KAAK,CAAC,oBAAN,CAA2B,KAAK,IAAL,GAAY,WAAvC,CAAtB;AACA,IAAA,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,KAAK,cAAzB;AAEA,SAAK,aAAL,GAAqB,KAAK,CAAC,kBAAN,CAAyB,qBAAzB,CAArB;AAEA,IAAA,KAAK,CAAC,mBAAN,IAA6B,YAAU,KAAK,aAAf,GAA4B,MAAzD;AACA,IAAA,KAAK,CAAC,mBAAN,IAA6B,yBAAuB,KAAK,gBAA5B,GAA4C,OAAzE;AACA,IAAA,KAAK,CAAC,mBAAN,IAA6B,WAA7B;AACA,IAAA,KAAK,CAAC,mBAAN,IAA6B,uBAAqB,KAAK,cAA1B,GAAwC,OAArE;AACA,IAAA,KAAK,CAAC,mBAAN,IAA6B,YAA7B,CAnBwC,CAqBxC;;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,iBAAjB,CAAmC,IAAnC,CAAwC,IAAxC;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAArC;AAEA,SAAK,yBAAL,GAAiC,KAAK,CAAC,kBAAN,CAAyB,yBAAzB,CAAjC;AACA,SAAK,+BAAL,GAAuC,KAAK,CAAC,kBAAN,CAAyB,6BAAzB,CAAvC;AACA,SAAK,gBAAL,GAAwB,KAAK,CAAC,kBAAN,CAAyB,4BAAzB,CAAxB;AAEA,SAAK,qBAAL,GAA6B,KAAK,CAAC,oBAAN,CAA2B,kBAA3B,CAA7B;;AAEA,IAAA,KAAK,CAAC,sBAAN,CAA6B,KAAK,qBAAlC,EAAyD,MAAzD;;AAEA,IAAA,KAAK,CAAC,aAAN,CAAoB,kBAApB,EAAwC,0BAC3B,KAAK,aADsB,GACT,+KAD/B,EAKiB,OAAK,KAAK,IAL3B;;AAOA,IAAA,KAAK,CAAC,aAAN,CAAoB,qBAApB,EAA2C,0BAC9B,KAAK,aADyB,GACZ,6MAD/B,EAKiB,OAAK,KAAK,IAL3B;;AAOA,SAAK,iCAAL,GAAyC,KAAK,CAAC,oBAAN,CAA2B,8BAA3B,CAAzC;;AAEA,IAAA,KAAK,CAAC,sBAAN,CAA6B,KAAK,iCAAlC,EAAqE,MAArE;;AAEA,SAAK,qBAAL,GAA6B,KAAK,CAAC,oBAAN,CAA2B,kBAA3B,CAA7B;;AAEA,IAAA,KAAK,CAAC,sBAAN,CAA6B,KAAK,qBAAlC,EAAyD,MAAzD;;AAEA,SAAK,6BAAL,GAAqC,KAAK,CAAC,oBAAN,CAA2B,0BAA3B,CAArC;;AAEA,IAAA,KAAK,CAAC,sBAAN,CAA6B,KAAK,6BAAlC,EAAiE,MAAjE;;AAEA,WAAO,IAAP;AACH,GA5DM;;AA8DG,EAAA,eAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,KAAtB,EAAmD;AAC/C,SAAK,MAAL,GAAc,KAAK,CAAC,UAAN,CAAiB,KAA/B;AAEA,WAAO,IAAP;AACH,GAJS;;AAMA,EAAA,eAAA,CAAA,SAAA,CAAA,mBAAA,GAAV,YAAA;AACI,QAAI,UAAU,GAAW,MAAA,CAAA,SAAA,CAAM,mBAAN,CAAyB,IAAzB,CAAyB,IAAzB,CAAzB;;AAEA,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,KAAK,OAAL,CAAa,MAAjB,EAAyB;AACrB,QAAA,UAAU,GAAM,KAAK,iBAAL,GAAsB,uCAAtB,GAA6D,KAAK,OAAL,CAAa,IAA1E,GAA8E,UAA9F;AACH,OAFD,MAEO;AACH,QAAA,UAAU,GAAM,KAAK,iBAAL,GAAsB,mCAAtB,GAAyD,KAAK,OAAL,CAAa,IAAtE,GAA0E,UAA1F;AACH;;AACD,MAAA,UAAU,IAAO,KAAK,iBAAL,GAAsB,6BAAtB,GAAoD,KAAK,OAAL,CAAa,eAAjE,GAAgF,OAAjG;AACH;;AAED,IAAA,UAAU,IAAO,KAAK,iBAAL,GAAsB,oCAAtB,GAA2D,KAAK,8BAAhE,GAA8F,OAA/G;AACA,IAAA,UAAU,IAAO,KAAK,iBAAL,GAAsB,uBAAtB,GAA8C,KAAK,iBAAnD,GAAoE,OAArF;AAEA,WAAO,UAAP;AACH,GAhBS;;AAkBH,EAAA,eAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,mBAAmB,GAAG,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf,CAA1B;;AAEA,QAAI,KAAK,OAAT,EAAkB;AACd,MAAA,mBAAmB,CAAC,OAApB,GAA8B,KAAK,OAAL,CAAa,SAAb,EAA9B;AACH;;AAED,IAAA,mBAAmB,CAAC,8BAApB,GAAqD,KAAK,8BAA1D;AACA,IAAA,mBAAmB,CAAC,iBAApB,GAAwC,KAAK,iBAA7C;AAEA,WAAO,mBAAP;AACH,GAXM;;AAaA,EAAA,eAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,mBAApB,EAA8C,KAA9C,EAA4D,OAA5D,EAA2E;AACvE,IAAA,MAAA,CAAA,SAAA,CAAM,YAAN,CAAkB,IAAlB,CAAkB,IAAlB,EAAmB,mBAAnB,EAAwC,KAAxC,EAA+C,OAA/C;;AAEA,QAAI,mBAAmB,CAAC,OAAxB,EAAiC;AAC7B,MAAA,OAAO,GAAG,mBAAmB,CAAC,OAApB,CAA4B,GAA5B,CAAgC,OAAhC,CAAwC,OAAxC,MAAqD,CAArD,GAAyD,EAAzD,GAA8D,OAAxE;;AACA,UAAI,mBAAmB,CAAC,OAApB,CAA4B,MAAhC,EAAwC;AACpC,aAAK,OAAL,GAAe,WAAW,CAAC,KAAZ,CAAkB,mBAAmB,CAAC,OAAtC,EAA+C,KAA/C,EAAsD,OAAtD,CAAf;AACH,OAFD,MAEO;AACH,aAAK,OAAL,GAAe,OAAO,CAAC,KAAR,CAAc,mBAAmB,CAAC,OAAlC,EAA2C,KAA3C,EAAkD,OAAlD,CAAf;AACH;AACJ;;AAED,SAAK,8BAAL,GAAsC,mBAAmB,CAAC,8BAA1D;AACA,SAAK,iBAAL,GAAyB,mBAAmB,CAAC,iBAA7C;AACH,GAdM;;AA7QP,EAAA,UAAA,CAAA,CADC,sBAAsB,CAAC,iCAAD,EAAoC,sBAAsB,CAAC,OAA3D,EAAoE,UAApE,EAAgF;AAAE,iBAAa;AAAE,gBAAU;AAAZ;AAAf,GAAhF,CACvB,CAAA,E,yBAAA,E,gCAAA,E,KAAuD,CAAvD,CAAA;;AAMA,EAAA,UAAA,CAAA,CADC,sBAAsB,CAAC,qBAAD,EAAwB,sBAAsB,CAAC,OAA/C,EAAwD,UAAxD,EAAoE;AAAE,iBAAa;AAAE,gBAAU;AAAZ;AAAf,GAApE,CACvB,CAAA,E,yBAAA,E,mBAAA,E,KAA0C,CAA1C,CAAA;;AAsRJ,SAAA,eAAA;AAAC,CAtUD,CAAqC,iBAArC,CAAA;;SAAa,e;AAwUb,UAAU,CAAC,eAAX,CAA2B,yBAA3B,IAAwD,eAAxD","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { Nullable } from '../../../../types';\r\nimport { BaseTexture } from '../../../Textures/baseTexture';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { SubMesh } from '../../../../Meshes/subMesh';\r\nimport { Effect } from '../../../effect';\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport { Scene } from '../../../../scene';\r\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { CubeTexture } from '../../../Textures/cubeTexture';\r\nimport { Texture } from '../../../Textures/texture';\r\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\r\nimport { Scalar } from '../../../../Maths/math.scalar';\r\n\r\n/**\r\n * Block used to implement the refraction part of the sub surface module of the PBR material\r\n */\r\nexport class RefractionBlock extends NodeMaterialBlock {\r\n\r\n    /** @hidden */\r\n    public _define3DName: string;\r\n    /** @hidden */\r\n    public _refractionMatrixName: string;\r\n    /** @hidden */\r\n    public _defineLODRefractionAlpha: string;\r\n    /** @hidden */\r\n    public _defineLinearSpecularRefraction: string;\r\n    /** @hidden */\r\n    public _defineOppositeZ: string;\r\n    /** @hidden */\r\n    public _cubeSamplerName: string;\r\n    /** @hidden */\r\n    public _2DSamplerName: string;\r\n    /** @hidden */\r\n    public _vRefractionMicrosurfaceInfosName: string;\r\n    /** @hidden */\r\n    public _vRefractionInfosName: string;\r\n    /** @hidden */\r\n    public _vRefractionFilteringInfoName: string;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n    */\r\n\r\n    /** @hidden */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /** @hidden */\r\n    public indexOfRefractionConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { \"notifiers\": { \"update\": true }})\r\n    public linkRefractionWithTransparency: boolean = false;\r\n\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { \"notifiers\": { \"update\": true }})\r\n    public invertRefractionY: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new RefractionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"RefractionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the tint at distance input component\r\n     */\r\n    public get tintAtDistance(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the refraction object output component\r\n     */\r\n    public get refraction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.intensity.isConnected) {\r\n            let intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\r\n            intensityInput.value = 1;\r\n            intensityInput.output.connectTo(this.intensity);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const refractionTexture = this._getTexture();\r\n        const refraction = refractionTexture && refractionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"SS_REFRACTION\", refraction, true);\r\n\r\n        if (!refraction) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, refractionTexture!.isCube, true);\r\n        defines.setValue(this._defineLODRefractionAlpha, refractionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularRefraction, refractionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !refractionTexture!.invertZ : refractionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\r\n        defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture!.gammaSpace, true);\r\n        defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture!.isRGBD, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const refractionTexture = this._getTexture();\r\n\r\n        if (!refractionTexture) {\r\n            return;\r\n        }\r\n\r\n        if (refractionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, refractionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, refractionTexture);\r\n        }\r\n\r\n        effect.setMatrix(this._refractionMatrixName, refractionTexture.getReflectionTextureMatrix());\r\n\r\n        let depth = 1.0;\r\n        if (!refractionTexture.isCube) {\r\n            if ((<any>refractionTexture).depth) {\r\n                depth = (<any>refractionTexture).depth;\r\n            }\r\n        }\r\n\r\n        const indexOfRefraction = this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\r\n\r\n        effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n        effect.setFloat3(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\r\n\r\n        const width = refractionTexture.getSize().width;\r\n\r\n        effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState): string {\r\n        let code = \"\";\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\r\n        this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\r\n\r\n        this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\r\n\r\n        state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\r\n\r\n        state._emitFunction(\"sampleRefraction\", `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefraction(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleRefraction(s, c) texture2D(s, c)\r\n            #endif\\r\\n`, `//${this.name}`);\r\n\r\n        state._emitFunction(\"sampleRefractionLod\", `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\r\\n`, `//${this.name}`);\r\n\r\n        this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec3\");\r\n\r\n        this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\r\n\r\n        state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\r\n\r\n        this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString: string = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            if (this.texture.isCube) {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\r\n            } else {\r\n                codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\r\n            }\r\n            codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        if (this.texture) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\r\n        serializationObject.invertRefractionY = this.invertRefractionY;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\r\n        this.invertRefractionY = serializationObject.invertRefractionY;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.RefractionBlock\"] = RefractionBlock;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}