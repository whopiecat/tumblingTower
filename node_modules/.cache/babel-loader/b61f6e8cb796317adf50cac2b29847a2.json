{"ast":null,"code":"import { Camera } from \"../Cameras/camera\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\"; // Adds the parser to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, function (parsedData, scene, container, rootUrl) {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = new Array();\n    }\n\n    for (var index = 0; index < parsedData.effectLayers.length; index++) {\n      var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\n\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  var index = this.effectLayers.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\n\n\nvar EffectLayerSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function EffectLayerSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene;\n    this._engine = scene.getEngine();\n    scene.effectLayers = new Array();\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.register = function () {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.rebuild = function () {\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var effectLayer = layers_1[_i];\n\n      effectLayer._rebuild();\n    }\n  };\n  /**\r\n   * Serializes the component data to the specified json object\r\n   * @param serializationObject The object to serialize to\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.serialize = function (serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\n      var effectLayer = layers_2[_i];\n\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  };\n  /**\r\n   * Adds all the elements from the container to the scene\r\n   * @param container the container holding the elements\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.addFromContainer = function (container) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.addEffectLayer(o);\n    });\n  };\n  /**\r\n   * Removes all the elements in the container from the scene\r\n   * @param container contains the elements to remove\r\n   * @param dispose if the removed element should be disposed (default: false)\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {\n    var _this = this;\n\n    if (!container.effectLayers) {\n      return;\n    }\n\n    container.effectLayers.forEach(function (o) {\n      _this.scene.removeEffectLayer(o);\n\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  EffectLayerSceneComponent.prototype.dispose = function () {\n    var layers = this.scene.effectLayers;\n\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._isReadyForMesh = function (mesh, hardwareInstancedRendering) {\n    var layers = this.scene.effectLayers;\n\n    for (var _i = 0, layers_3 = layers; _i < layers_3.length; _i++) {\n      var layer = layers_3[_i];\n\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  EffectLayerSceneComponent.prototype._renderMainTexture = function (camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    var needRebind = false;\n    var layers = this.scene.effectLayers;\n\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n\n      for (var _i = 0, layers_4 = layers; _i < layers_4.length; _i++) {\n        var effectLayer = layers_4[_i];\n\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          var renderTarget = effectLayer._mainTexture;\n\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n\n      this.scene.incrementRenderId();\n    }\n\n    return needRebind;\n  };\n\n  EffectLayerSceneComponent.prototype._setStencil = function () {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._setStencilBack = function () {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._draw = function (renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n\n      var layers = this.scene.effectLayers;\n\n      for (var i = 0; i < layers.length; i++) {\n        var effectLayer = layers[i];\n\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n\n      this._engine.setDepthBuffer(true);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawCamera = function () {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  };\n\n  EffectLayerSceneComponent.prototype._drawRenderingGroup = function (index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  };\n\n  return EffectLayerSceneComponent;\n}();\n\nexport { EffectLayerSceneComponent };\n\nEffectLayer._SceneComponentInitialization = function (scene) {\n  var component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"sources":["../../../sourceES6/core/Layers/effectLayerSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { SceneComponentConstants, ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { AssetContainer } from \"../assetContainer\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = new Array<EffectLayer>();\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            var effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of effect layers (highlights/glow) added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/highlight_layer\r\n         * @see https://doc.babylonjs.com/how_to/glow_layer\r\n         */\r\n        effectLayers: Array<EffectLayer>;\r\n\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeEffectLayer = function(toRemove: EffectLayer): number {\r\n    var index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addEffectLayer = function(newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        scene.effectLayers = new Array<EffectLayer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        let layers = this.scene.effectLayers;\r\n        for (let effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        let layers = this.scene.effectLayers;\r\n        for (let effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        let layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        let layers = this.scene.effectLayers;\r\n        for (let layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            for (var subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        let layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (let effectLayer of layers) {\r\n                if (effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))) {\r\n\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    let renderTarget = (<RenderTargetTexture>(<any>effectLayer)._mainTexture);\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            let layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}