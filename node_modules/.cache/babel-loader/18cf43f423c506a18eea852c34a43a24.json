{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Material } from \"../Materials/material\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Engine } from '../Engines/engine';\nimport { Color4 } from '../Maths/math.color';\nimport \"../Shaders/glowMapMerge.fragment\";\nimport \"../Shaders/glowMapMerge.vertex\";\nimport \"../Layers/effectLayerSceneComponent\";\n\nAbstractScene.prototype.getGlowLayerByName = function (name) {\n  for (var index = 0; index < this.effectLayers.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/how_to/glow_layer\r\n */\n\n\nvar GlowLayer =\n/** @class */\nfunction (_super) {\n  __extends(GlowLayer, _super);\n  /**\r\n   * Instantiates a new glow Layer and references it to the scene.\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n   */\n\n\n  function GlowLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._intensity = 1.0;\n    _this._includedOnlyMeshes = [];\n    _this._excludedMeshes = [];\n    _this._meshesUsingTheirOwnMaterials = [];\n    _this.neutralColor = new Color4(0, 0, 0, 1); // Adapt options\n\n    _this._options = __assign({\n      mainTextureRatio: GlowLayer.DefaultTextureRatio,\n      blurKernelSize: 32,\n      mainTextureFixedSize: undefined,\n      camera: null,\n      mainTextureSamples: 1,\n      renderingGroupId: -1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: 1,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(GlowLayer.prototype, \"blurKernelSize\", {\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\n    get: function () {\n      return this._horizontalBlurPostprocess1.kernel;\n    },\n\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\n    set: function (value) {\n      this._horizontalBlurPostprocess1.kernel = value;\n      this._verticalBlurPostprocess1.kernel = value;\n      this._horizontalBlurPostprocess2.kernel = value;\n      this._verticalBlurPostprocess2.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlowLayer.prototype, \"intensity\", {\n    /**\r\n     * Gets the glow intensity.\r\n     */\n    get: function () {\n      return this._intensity;\n    },\n\n    /**\r\n     * Sets the glow intensity.\r\n     */\n    set: function (value) {\n      this._intensity = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the effect name of the layer.\r\n   * @return The effect name\r\n   */\n\n  GlowLayer.prototype.getEffectName = function () {\n    return GlowLayer.EffectName;\n  };\n  /**\r\n   * Create the merge effect. This is the shader use to blit the information back\r\n   * to the main canvas at the end of the scene rendering.\r\n   */\n\n\n  GlowLayer.prototype._createMergeEffect = function () {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], \"#define EMISSIVE \\n\");\n  };\n  /**\r\n   * Creates the render target textures and post processes used in the glow layer.\r\n   */\n\n\n  GlowLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width;\n    var blurTextureHeight = this._mainTextureDesiredSize.height;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture1.renderParticles = false;\n    this._blurTexture1.ignoreCameraViewport = true;\n    var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\n    var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\n    this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, this._scene, false, true, textureType);\n    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\n\n    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._blurTexture2.renderParticles = false;\n    this._blurTexture2.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture1, this._blurTexture2];\n    this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess1.width = blurTextureWidth;\n    this._horizontalBlurPostprocess1.height = blurTextureHeight;\n\n    this._horizontalBlurPostprocess1.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._mainTexture);\n    });\n\n    this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2.width = blurTextureWidth2;\n    this._horizontalBlurPostprocess2.height = blurTextureHeight2;\n\n    this._horizontalBlurPostprocess2.onApplyObservable.add(function (effect) {\n      effect.setTexture(\"textureSampler\", _this._blurTexture1);\n    });\n\n    this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\n    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._mainTexture.samples = this._options.mainTextureSamples;\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      var internalTexture = _this._blurTexture1.getInternalTexture();\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses1, internalTexture, true);\n\n        var internalTexture2 = _this._blurTexture2.getInternalTexture();\n\n        if (internalTexture2) {\n          _this._scene.postProcessManager.directRender(_this._postProcesses2, internalTexture2, true);\n        }\n\n        _this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);\n      }\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify wether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  GlowLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh) {\n      return false;\n    }\n\n    var emissiveTexture = material.emissiveTexture;\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\r\n   * Returns whether or nood the layer needs stencil enabled during the mesh rendering.\r\n   */\n\n\n  GlowLayer.prototype.needStencil = function () {\n    return false;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  GlowLayer.prototype._canRenderMesh = function (mesh, material) {\n    return true;\n  };\n  /**\r\n   * Implementation specific of rendering the generating effect on the main canvas.\r\n   * @param effect The effect used to render through\r\n   */\n\n\n  GlowLayer.prototype._internalRender = function (effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture1);\n    effect.setTexture(\"textureSampler2\", this._blurTexture2);\n    effect.setFloat(\"offset\", this._intensity); // Cache\n\n    var engine = this._engine;\n    var previousStencilBuffer = engine.getStencilBuffer(); // Draw order\n\n    engine.setStencilBuffer(false);\n    engine.drawElementsType(Material.TriangleFillMode, 0, 6); // Draw order\n\n    engine.setStencilBuffer(previousStencilBuffer);\n  };\n  /**\r\n   * Sets the required values for both the emissive texture and and the main color.\r\n   */\n\n\n  GlowLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var textureLevel = 1.0;\n\n    if (this.customEmissiveTextureSelector) {\n      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\n    } else {\n      if (material) {\n        this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n        if (this._emissiveTextureAndColor.texture) {\n          textureLevel = this._emissiveTextureAndColor.texture.level;\n        }\n      } else {\n        this._emissiveTextureAndColor.texture = null;\n      }\n    }\n\n    if (this.customEmissiveColorSelector) {\n      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\n    } else {\n      if (material.emissiveColor) {\n        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);\n      } else {\n        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }\n    }\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  GlowLayer.prototype._shouldRenderMesh = function (mesh) {\n    return this.hasMesh(mesh);\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  GlowLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define GLOW\");\n  };\n  /**\r\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n   * @param mesh The mesh to exclude from the glow layer\r\n   */\n\n\n  GlowLayer.prototype.addExcludedMesh = function (mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\r\n    * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n    * @param mesh The mesh to remove\r\n    */\n\n\n  GlowLayer.prototype.removeExcludedMesh = function (mesh) {\n    var index = this._excludedMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n   * @param mesh The mesh to include in the glow layer\r\n   */\n\n\n  GlowLayer.prototype.addIncludedOnlyMesh = function (mesh) {\n    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._includedOnlyMeshes.push(mesh.uniqueId);\n    }\n  };\n  /**\r\n    * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n    * @param mesh The mesh to remove\r\n    */\n\n\n  GlowLayer.prototype.removeIncludedOnlyMesh = function (mesh) {\n    var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\n\n    if (index !== -1) {\n      this._includedOnlyMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Determine if a given mesh will be used in the glow layer\r\n   * @param mesh The mesh to test\r\n   * @returns true if the mesh will be highlighted by the current glow layer\r\n   */\n\n\n  GlowLayer.prototype.hasMesh = function (mesh) {\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    } // Included Mesh\n\n\n    if (this._includedOnlyMeshes.length) {\n      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\n    } // Excluded Mesh\n\n\n    if (this._excludedMeshes.length) {\n      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\n    }\n\n    return true;\n  };\n  /**\r\n   * Defines whether the current material of the mesh should be use to render the effect.\r\n   * @param mesh defines the current mesh to render\r\n   */\n\n\n  GlowLayer.prototype._useMeshMaterial = function (mesh) {\n    if (this._meshesUsingTheirOwnMaterials.length == 0) {\n      return false;\n    }\n\n    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\n  };\n  /**\r\n   * Add a mesh to be rendered through its own material and not with emissive only.\r\n   * @param mesh The mesh for which we need to use its material\r\n   */\n\n\n  GlowLayer.prototype.referenceMeshToUseItsOwnMaterial = function (mesh) {\n    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\n  };\n  /**\r\n   * Remove a mesh from being rendered through its own material and not with emissive only.\r\n   * @param mesh The mesh for which we need to not use its material\r\n   */\n\n\n  GlowLayer.prototype.unReferenceMeshFromUsingItsOwnMaterial = function (mesh) {\n    var index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n\n    while (index >= 0) {\n      this._meshesUsingTheirOwnMaterials.splice(index, 1);\n\n      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    }\n  };\n  /**\r\n   * Free any resources and references associated to a mesh.\r\n   * Internal use\r\n   * @param mesh The mesh to free.\r\n   * @hidden\r\n   */\n\n\n  GlowLayer.prototype._disposeMesh = function (mesh) {\n    this.removeIncludedOnlyMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  GlowLayer.prototype.getClassName = function () {\n    return \"GlowLayer\";\n  };\n  /**\r\n   * Serializes this glow layer\r\n   * @returns a serialized glow layer object\r\n   */\n\n\n  GlowLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.GlowLayer\";\n    var index; // Included meshes\n\n    serializationObject.includedMeshes = [];\n\n    if (this._includedOnlyMeshes.length) {\n      for (index = 0; index < this._includedOnlyMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[index]);\n\n        if (mesh) {\n          serializationObject.includedMeshes.push(mesh.id);\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes.length) {\n      for (index = 0; index < this._excludedMeshes.length; index++) {\n        var mesh = this._scene.getMeshByUniqueID(this._excludedMeshes[index]);\n\n        if (mesh) {\n          serializationObject.excludedMeshes.push(mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a Glow Layer from parsed glow layer data\r\n   * @param parsedGlowLayer defines glow layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the glow layer information\r\n   * @returns a parsed Glow Layer\r\n   */\n\n\n  GlowLayer.Parse = function (parsedGlowLayer, scene, rootUrl) {\n    var gl = SerializationHelper.Parse(function () {\n      return new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options);\n    }, parsedGlowLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedGlowLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        gl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedGlowLayer.includedMeshes[index]);\n\n      if (mesh) {\n        gl.addIncludedOnlyMesh(mesh);\n      }\n    }\n\n    return gl;\n  };\n  /**\r\n   * Effect Name of the layer.\r\n   */\n\n\n  GlowLayer.EffectName = \"GlowLayer\";\n  /**\r\n   * The default blur kernel size used for the glow.\r\n   */\n\n  GlowLayer.DefaultBlurKernelSize = 32;\n  /**\r\n   * The default texture size ratio used for the glow.\r\n   */\n\n  GlowLayer.DefaultTextureRatio = 0.5;\n\n  __decorate([serialize()], GlowLayer.prototype, \"blurKernelSize\", null);\n\n  __decorate([serialize()], GlowLayer.prototype, \"intensity\", null);\n\n  __decorate([serialize(\"options\")], GlowLayer.prototype, \"_options\", void 0);\n\n  return GlowLayer;\n}(EffectLayer);\n\nexport { GlowLayer };\n_TypeStore.RegisteredTypes[\"BABYLON.GlowLayer\"] = GlowLayer;","map":{"version":3,"sources":["../../../sourceES6/core/Layers/glowLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\n\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Engine } from '../Engines/engine';\r\nimport { Color4 } from '../Maths/math.color';\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @return The highlight layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getGlowLayerByName = function(name: string): Nullable<GlowLayer> {\r\n    for (var index = 0; index < this.effectLayers.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independant blur.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * How big is the kernel of the blur texture.\r\n     */\r\n    blurKernelSize: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Enable MSAA by chosing the number of samples.\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/how_to/glow_layer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        this._horizontalBlurPostprocess1.kernel = value;\r\n        this._verticalBlurPostprocess1.kernel = value;\r\n        this._horizontalBlurPostprocess2.kernel = value;\r\n        this._verticalBlurPostprocess2.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._horizontalBlurPostprocess1.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    private _options: IGlowLayerOptions;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n\r\n    private _includedOnlyMeshes: number[] = [];\r\n    private _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: 1,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\", \"textureSampler2\"],\r\n            \"#define EMISSIVE \\n\");\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        var blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        var blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        var textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = 2;\r\n        }\r\n        else {\r\n            textureType = 0;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType);\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        var blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        var blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType);\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight\r\n        },\r\n            null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight\r\n        },\r\n            null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), this._options.blurKernelSize / 2, {\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2\r\n        },\r\n            null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), this._options.blurKernelSize / 2, {\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2\r\n        },\r\n            null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            let internalTexture = this._blurTexture1.getInternalTexture();\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(\r\n                    this._postProcesses1,\r\n                    internalTexture,\r\n                    true);\r\n\r\n                let internalTexture2 = this._blurTexture2.getInternalTexture();\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(\r\n                        this._postProcesses2,\r\n                        internalTexture2,\r\n                        true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => { pp.autoClear = false; });\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify wether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        let material = subMesh.getMaterial();\r\n        let mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or nood the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        var engine = this._engine;\r\n        var previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        var textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            }\r\n            else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha);\r\n            }\r\n            else {\r\n                this._emissiveTextureAndColor.color.set(\r\n                    this.neutralColor.r,\r\n                    this.neutralColor.g,\r\n                    this.neutralColor.b,\r\n                    this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n      * @param mesh The mesh to remove\r\n      */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        var index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n      * @param mesh The mesh to remove\r\n      */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        var index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @hidden\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n      * Gets the class name of the effect layer\r\n      * @returns the string with the class name of the effect layer\r\n      */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        var index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        if (this._includedOnlyMeshes.length) {\r\n            for (index = 0; index < this._includedOnlyMeshes.length; index++) {\r\n                var mesh = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes.length) {\r\n            for (index = 0; index < this._excludedMeshes.length; index++) {\r\n                var mesh = this._scene.getMeshByUniqueID(this._excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        var gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        var index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            var mesh = scene.getMeshByID(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            var mesh = scene.getMeshByID(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.GlowLayer\"] = GlowLayer;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}