{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport \"../Engines/Extensions/engine.uniformBuffer\";\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\n\nvar UniformBuffer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new Uniform buffer objects.\r\n   *\r\n   * Handles blocks of uniform on the GPU.\r\n   *\r\n   * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n   *\r\n   * For more information, please refer to :\r\n   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n   * @param engine Define the engine the buffer is associated with\r\n   * @param data Define the data contained in the buffer\r\n   * @param dynamic Define if the buffer is updatable\r\n   */\n  function UniformBuffer(engine, data, dynamic) {\n    /** @hidden */\n    this._alreadyBound = false; // Matrix cache\n\n    this._valueCache = {};\n    this._engine = engine;\n    this._noUBO = !engine.supportsUniformBuffers;\n    this._dynamic = dynamic;\n    this._data = data || [];\n    this._uniformLocations = {};\n    this._uniformSizes = {};\n    this._uniformLocationPointer = 0;\n    this._needSync = false;\n\n    if (this._noUBO) {\n      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n      this.updateFloat = this._updateFloatForEffect;\n      this.updateFloat2 = this._updateFloat2ForEffect;\n      this.updateFloat3 = this._updateFloat3ForEffect;\n      this.updateFloat4 = this._updateFloat4ForEffect;\n      this.updateMatrix = this._updateMatrixForEffect;\n      this.updateVector3 = this._updateVector3ForEffect;\n      this.updateVector4 = this._updateVector4ForEffect;\n      this.updateColor3 = this._updateColor3ForEffect;\n      this.updateColor4 = this._updateColor4ForEffect;\n    } else {\n      this._engine._uniformBuffers.push(this);\n\n      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n      this.updateFloat = this._updateFloatForUniform;\n      this.updateFloat2 = this._updateFloat2ForUniform;\n      this.updateFloat3 = this._updateFloat3ForUniform;\n      this.updateFloat4 = this._updateFloat4ForUniform;\n      this.updateMatrix = this._updateMatrixForUniform;\n      this.updateVector3 = this._updateVector3ForUniform;\n      this.updateVector4 = this._updateVector4ForUniform;\n      this.updateColor3 = this._updateColor3ForUniform;\n      this.updateColor4 = this._updateColor4ForUniform;\n    }\n  }\n\n  Object.defineProperty(UniformBuffer.prototype, \"useUbo\", {\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\n    get: function () {\n      return !this._noUBO;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UniformBuffer.prototype, \"isSync\", {\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\n    get: function () {\n      return !this._needSync;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n   * Also, a dynamic UniformBuffer will disable cache verification and always\r\n   * update the underlying WebGL uniform buffer to the GPU.\r\n   * @returns if Dynamic, otherwise false\r\n   */\n\n  UniformBuffer.prototype.isDynamic = function () {\n    return this._dynamic !== undefined;\n  };\n  /**\r\n   * The data cache on JS side.\r\n   * @returns the underlying data as a float array\r\n   */\n\n\n  UniformBuffer.prototype.getData = function () {\n    return this._bufferData;\n  };\n  /**\r\n   * The underlying WebGL Uniform buffer.\r\n   * @returns the webgl buffer\r\n   */\n\n\n  UniformBuffer.prototype.getBuffer = function () {\n    return this._buffer;\n  };\n  /**\r\n   * std140 layout specifies how to align data within an UBO structure.\r\n   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n   * for specs.\r\n   */\n\n\n  UniformBuffer.prototype._fillAlignment = function (size) {\n    // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n    // and 4x4 matrices\n    // TODO : change if other types are used\n    var alignment;\n\n    if (size <= 2) {\n      alignment = size;\n    } else {\n      alignment = 4;\n    }\n\n    if (this._uniformLocationPointer % alignment !== 0) {\n      var oldPointer = this._uniformLocationPointer;\n      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;\n      var diff = this._uniformLocationPointer - oldPointer;\n\n      for (var i = 0; i < diff; i++) {\n        this._data.push(0);\n      }\n    }\n  };\n  /**\r\n   * Adds an uniform in the buffer.\r\n   * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n   * for the layout to be correct !\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param size Data size, or data directly.\r\n   */\n\n\n  UniformBuffer.prototype.addUniform = function (name, size) {\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._uniformLocations[name] !== undefined) {\n      // Already existing uniform\n      return;\n    } // This function must be called in the order of the shader layout !\n    // size can be the size of the uniform, or data directly\n\n\n    var data;\n\n    if (size instanceof Array) {\n      data = size;\n      size = data.length;\n    } else {\n      size = size;\n      data = []; // Fill with zeros\n\n      for (var i = 0; i < size; i++) {\n        data.push(0);\n      }\n    }\n\n    this._fillAlignment(size);\n\n    this._uniformSizes[name] = size;\n    this._uniformLocations[name] = this._uniformLocationPointer;\n    this._uniformLocationPointer += size;\n\n    for (var i = 0; i < size; i++) {\n      this._data.push(data[i]);\n    }\n\n    this._needSync = true;\n  };\n  /**\r\n   * Adds a Matrix 4x4 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param mat A 4x4 matrix.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix = function (name, mat) {\n    this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\n  };\n  /**\r\n   * Adds a vec2 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param x Define the x component value of the vec2\r\n   * @param y Define the y component value of the vec2\r\n   */\n\n\n  UniformBuffer.prototype.addFloat2 = function (name, x, y) {\n    var temp = [x, y];\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param x Define the x component value of the vec3\r\n   * @param y Define the y component value of the vec3\r\n   * @param z Define the z component value of the vec3\r\n   */\n\n\n  UniformBuffer.prototype.addFloat3 = function (name, x, y, z) {\n    var temp = [x, y, z];\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param color Define the vec3 from a Color\r\n   */\n\n\n  UniformBuffer.prototype.addColor3 = function (name, color) {\n    var temp = new Array();\n    color.toArray(temp);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec4 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param color Define the rgb components from a Color\r\n   * @param alpha Define the a component of the vec4\r\n   */\n\n\n  UniformBuffer.prototype.addColor4 = function (name, color, alpha) {\n    var temp = new Array();\n    color.toArray(temp);\n    temp.push(alpha);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a vec3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   * @param vector Define the vec3 components from a Vector\r\n   */\n\n\n  UniformBuffer.prototype.addVector3 = function (name, vector) {\n    var temp = new Array();\n    vector.toArray(temp);\n    this.addUniform(name, temp);\n  };\n  /**\r\n   * Adds a Matrix 3x3 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix3x3 = function (name) {\n    this.addUniform(name, 12);\n  };\n  /**\r\n   * Adds a Matrix 2x2 to the uniform buffer.\r\n   * @param name Name of the uniform, as used in the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.addMatrix2x2 = function (name) {\n    this.addUniform(name, 8);\n  };\n  /**\r\n   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n   */\n\n\n  UniformBuffer.prototype.create = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    if (this._buffer) {\n      return; // nothing to do\n    } // See spec, alignment must be filled as a vec4\n\n\n    this._fillAlignment(4);\n\n    this._bufferData = new Float32Array(this._data);\n\n    this._rebuild();\n\n    this._needSync = true;\n  };\n  /** @hidden */\n\n\n  UniformBuffer.prototype._rebuild = function () {\n    if (this._noUBO || !this._bufferData) {\n      return;\n    }\n\n    if (this._dynamic) {\n      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\n    } else {\n      this._buffer = this._engine.createUniformBuffer(this._bufferData);\n    }\n  };\n  /**\r\n   * Updates the WebGL Uniform Buffer on the GPU.\r\n   * If the `dynamic` flag is set to true, no cache comparison is done.\r\n   * Otherwise, the buffer will be updated only if the cache differs.\r\n   */\n\n\n  UniformBuffer.prototype.update = function () {\n    if (!this._buffer) {\n      this.create();\n      return;\n    }\n\n    if (!this._dynamic && !this._needSync) {\n      return;\n    }\n\n    this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n\n    this._needSync = false;\n  };\n  /**\r\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n   * @param data Define the flattened data\r\n   * @param size Define the size of the data.\r\n   */\n\n\n  UniformBuffer.prototype.updateUniform = function (uniformName, data, size) {\n    var location = this._uniformLocations[uniformName];\n\n    if (location === undefined) {\n      if (this._buffer) {\n        // Cannot add an uniform if the buffer is already created\n        Logger.Error(\"Cannot add an uniform after UBO has been created.\");\n        return;\n      }\n\n      this.addUniform(uniformName, size);\n      location = this._uniformLocations[uniformName];\n    }\n\n    if (!this._buffer) {\n      this.create();\n    }\n\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      var changed = false;\n\n      for (var i = 0; i < size; i++) {\n        // We are checking the matrix cache before calling updateUniform so we do not need to check it here\n        // Hence the test for size === 16 to simply commit the matrix values\n        if (size === 16 || this._bufferData[location + i] !== data[i]) {\n          changed = true;\n          this._bufferData[location + i] = data[i];\n        }\n      }\n\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (var i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  };\n\n  UniformBuffer.prototype._cacheMatrix = function (name, matrix) {\n    var cache = this._valueCache[name];\n    var flag = matrix.updateFlag;\n\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n\n    this._valueCache[name] = flag;\n    return true;\n  }; // Update methods\n\n\n  UniformBuffer.prototype._updateMatrix3x3ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 3; i++) {\n      UniformBuffer._tempBuffer[i * 4] = matrix[i * 3];\n      UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n      UniformBuffer._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n      UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._tempBuffer, 12);\n  };\n\n  UniformBuffer.prototype._updateMatrix3x3ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix3x3(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForEffect = function (name, matrix) {\n    this._currentEffect.setMatrix2x2(name, matrix);\n  };\n\n  UniformBuffer.prototype._updateMatrix2x2ForUniform = function (name, matrix) {\n    // To match std140, matrix must be realigned\n    for (var i = 0; i < 2; i++) {\n      UniformBuffer._tempBuffer[i * 4] = matrix[i * 2];\n      UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n      UniformBuffer._tempBuffer[i * 4 + 2] = 0.0;\n      UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n    }\n\n    this.updateUniform(name, UniformBuffer._tempBuffer, 8);\n  };\n\n  UniformBuffer.prototype._updateFloatForEffect = function (name, x) {\n    this._currentEffect.setFloat(name, x);\n  };\n\n  UniformBuffer.prototype._updateFloatForUniform = function (name, x) {\n    UniformBuffer._tempBuffer[0] = x;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 1);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForEffect = function (name, x, y, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat2(name + suffix, x, y);\n  };\n\n  UniformBuffer.prototype._updateFloat2ForUniform = function (name, x, y) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 2);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForEffect = function (name, x, y, z, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat3(name + suffix, x, y, z);\n  };\n\n  UniformBuffer.prototype._updateFloat3ForUniform = function (name, x, y, z) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    UniformBuffer._tempBuffer[2] = z;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForEffect = function (name, x, y, z, w, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n  };\n\n  UniformBuffer.prototype._updateFloat4ForUniform = function (name, x, y, z, w) {\n    UniformBuffer._tempBuffer[0] = x;\n    UniformBuffer._tempBuffer[1] = y;\n    UniformBuffer._tempBuffer[2] = z;\n    UniformBuffer._tempBuffer[3] = w;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateMatrixForEffect = function (name, mat) {\n    this._currentEffect.setMatrix(name, mat);\n  };\n\n  UniformBuffer.prototype._updateMatrixForUniform = function (name, mat) {\n    if (this._cacheMatrix(name, mat)) {\n      this.updateUniform(name, mat.toArray(), 16);\n    }\n  };\n\n  UniformBuffer.prototype._updateVector3ForEffect = function (name, vector) {\n    this._currentEffect.setVector3(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector3ForUniform = function (name, vector) {\n    vector.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateVector4ForEffect = function (name, vector) {\n    this._currentEffect.setVector4(name, vector);\n  };\n\n  UniformBuffer.prototype._updateVector4ForUniform = function (name, vector) {\n    vector.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n\n  UniformBuffer.prototype._updateColor3ForEffect = function (name, color, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor3(name + suffix, color);\n  };\n\n  UniformBuffer.prototype._updateColor3ForUniform = function (name, color) {\n    color.toArray(UniformBuffer._tempBuffer);\n    this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n  };\n\n  UniformBuffer.prototype._updateColor4ForEffect = function (name, color, alpha, suffix) {\n    if (suffix === void 0) {\n      suffix = \"\";\n    }\n\n    this._currentEffect.setColor4(name + suffix, color, alpha);\n  };\n\n  UniformBuffer.prototype._updateColor4ForUniform = function (name, color, alpha) {\n    color.toArray(UniformBuffer._tempBuffer);\n    UniformBuffer._tempBuffer[3] = alpha;\n    this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n  };\n  /**\r\n   * Sets a sampler uniform on the effect.\r\n   * @param name Define the name of the sampler.\r\n   * @param texture Define the texture to set in the sampler\r\n   */\n\n\n  UniformBuffer.prototype.setTexture = function (name, texture) {\n    this._currentEffect.setTexture(name, texture);\n  };\n  /**\r\n   * Directly updates the value of the uniform in the cache AND on the GPU.\r\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n   * @param data Define the flattened data\r\n   */\n\n\n  UniformBuffer.prototype.updateUniformDirectly = function (uniformName, data) {\n    this.updateUniform(uniformName, data, data.length);\n    this.update();\n  };\n  /**\r\n   * Binds this uniform buffer to an effect.\r\n   * @param effect Define the effect to bind the buffer to\r\n   * @param name Name of the uniform block in the shader.\r\n   */\n\n\n  UniformBuffer.prototype.bindToEffect = function (effect, name) {\n    this._currentEffect = effect;\n\n    if (this._noUBO || !this._buffer) {\n      return;\n    }\n\n    this._alreadyBound = true;\n    effect.bindUniformBuffer(this._buffer, name);\n  };\n  /**\r\n   * Disposes the uniform buffer.\r\n   */\n\n\n  UniformBuffer.prototype.dispose = function () {\n    if (this._noUBO) {\n      return;\n    }\n\n    var uniformBuffers = this._engine._uniformBuffers;\n    var index = uniformBuffers.indexOf(this);\n\n    if (index !== -1) {\n      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\n      uniformBuffers.pop();\n    }\n\n    if (!this._buffer) {\n      return;\n    }\n\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n    }\n  }; // Pool for avoiding memory leaks\n\n\n  UniformBuffer._MAX_UNIFORM_SIZE = 256;\n  UniformBuffer._tempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\n  return UniformBuffer;\n}();\n\nexport { UniformBuffer };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/uniformBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Nullable, FloatArray } from \"../types\";\r\nimport { Matrix, Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Effect } from \"./effect\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { IMatrixLike } from '../Maths/math.like';\r\n\r\nimport \"../Engines/Extensions/engine.uniformBuffer\";\r\n\r\n/**\r\n * Uniform buffer objects.\r\n *\r\n * Handles blocks of uniform on the GPU.\r\n *\r\n * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n *\r\n * For more information, please refer to :\r\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n */\r\nexport class UniformBuffer {\r\n    private _engine: Engine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    private _data: number[];\r\n    private _bufferData: Float32Array;\r\n    private _dynamic?: boolean;\r\n    private _uniformLocations: { [key: string]: number; };\r\n    private _uniformSizes: { [key: string]: number; };\r\n    private _uniformLocationPointer: number;\r\n    private _needSync: boolean;\r\n    private _noUBO: boolean;\r\n    private _currentEffect: Effect;\r\n\r\n    /** @hidden */\r\n    public _alreadyBound = false;\r\n\r\n    // Pool for avoiding memory leaks\r\n    private static _MAX_UNIFORM_SIZE = 256;\r\n    private static _tempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\r\n\r\n    /**\r\n     * Lambda to Update a 3x3 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix3x3: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 2x2 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix2x2: (name: string, matrix: Float32Array) => void;\r\n\r\n    /**\r\n     * Lambda to Update a single float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat: (name: string, x: number) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec2 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat2: (name: string, x: number, y: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec3 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat3: (name: string, x: number, y: number, z: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a vec4 of float in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateFloat4: (name: string, x: number, y: number, z: number, w: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update a 4x4 Matrix in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateMatrix: (name: string, mat: Matrix) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector3: (name: string, vector: Vector3) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Vector in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateVector4: (name: string, vector: Vector4) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec3 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor3: (name: string, color: Color3, suffix?: string) => void;\r\n\r\n    /**\r\n     * Lambda to Update vec4 of float from a Color in a uniform buffer.\r\n     * This is dynamic to allow compat with webgl 1 and 2.\r\n     * You will need to pass the name of the uniform as well as the value.\r\n     */\r\n    public updateColor4: (name: string, color: Color3, alpha: number, suffix?: string) => void;\r\n\r\n    /**\r\n     * Instantiates a new Uniform buffer objects.\r\n     *\r\n     * Handles blocks of uniform on the GPU.\r\n     *\r\n     * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\r\n     *\r\n     * For more information, please refer to :\r\n     * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\r\n     * @param engine Define the engine the buffer is associated with\r\n     * @param data Define the data contained in the buffer\r\n     * @param dynamic Define if the buffer is updatable\r\n     */\r\n    constructor(engine: Engine, data?: number[], dynamic?: boolean) {\r\n        this._engine = engine;\r\n        this._noUBO = !engine.supportsUniformBuffers;\r\n        this._dynamic = dynamic;\r\n\r\n        this._data = data || [];\r\n\r\n        this._uniformLocations = {};\r\n        this._uniformSizes = {};\r\n        this._uniformLocationPointer = 0;\r\n        this._needSync = false;\r\n\r\n        if (this._noUBO) {\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\r\n            this.updateFloat = this._updateFloatForEffect;\r\n            this.updateFloat2 = this._updateFloat2ForEffect;\r\n            this.updateFloat3 = this._updateFloat3ForEffect;\r\n            this.updateFloat4 = this._updateFloat4ForEffect;\r\n            this.updateMatrix = this._updateMatrixForEffect;\r\n            this.updateVector3 = this._updateVector3ForEffect;\r\n            this.updateVector4 = this._updateVector4ForEffect;\r\n            this.updateColor3 = this._updateColor3ForEffect;\r\n            this.updateColor4 = this._updateColor4ForEffect;\r\n        } else {\r\n            this._engine._uniformBuffers.push(this);\r\n\r\n            this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\r\n            this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\r\n            this.updateFloat = this._updateFloatForUniform;\r\n            this.updateFloat2 = this._updateFloat2ForUniform;\r\n            this.updateFloat3 = this._updateFloat3ForUniform;\r\n            this.updateFloat4 = this._updateFloat4ForUniform;\r\n            this.updateMatrix = this._updateMatrixForUniform;\r\n            this.updateVector3 = this._updateVector3ForUniform;\r\n            this.updateVector4 = this._updateVector4ForUniform;\r\n            this.updateColor3 = this._updateColor3ForUniform;\r\n            this.updateColor4 = this._updateColor4ForUniform;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Indicates if the buffer is using the WebGL2 UBO implementation,\r\n     * or just falling back on setUniformXXX calls.\r\n     */\r\n    public get useUbo(): boolean {\r\n        return !this._noUBO;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is in sync\r\n     * with the javascript cache data.\r\n     */\r\n    public get isSync(): boolean {\r\n        return !this._needSync;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the WebGL underlying uniform buffer is dynamic.\r\n     * Also, a dynamic UniformBuffer will disable cache verification and always\r\n     * update the underlying WebGL uniform buffer to the GPU.\r\n     * @returns if Dynamic, otherwise false\r\n     */\r\n    public isDynamic(): boolean {\r\n        return this._dynamic !== undefined;\r\n    }\r\n\r\n    /**\r\n     * The data cache on JS side.\r\n     * @returns the underlying data as a float array\r\n     */\r\n    public getData(): Float32Array {\r\n        return this._bufferData;\r\n    }\r\n\r\n    /**\r\n     * The underlying WebGL Uniform buffer.\r\n     * @returns the webgl buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * std140 layout specifies how to align data within an UBO structure.\r\n     * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\r\n     * for specs.\r\n     */\r\n    private _fillAlignment(size: number) {\r\n        // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\r\n        // and 4x4 matrices\r\n        // TODO : change if other types are used\r\n\r\n        var alignment;\r\n        if (size <= 2) {\r\n            alignment = size;\r\n        } else {\r\n            alignment = 4;\r\n        }\r\n\r\n        if ((this._uniformLocationPointer % alignment) !== 0) {\r\n            var oldPointer = this._uniformLocationPointer;\r\n            this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\r\n            var diff = this._uniformLocationPointer - oldPointer;\r\n\r\n            for (var i = 0; i < diff; i++) {\r\n                this._data.push(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an uniform in the buffer.\r\n     * Warning : the subsequents calls of this function must be in the same order as declared in the shader\r\n     * for the layout to be correct !\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param size Data size, or data directly.\r\n     */\r\n    public addUniform(name: string, size: number | number[]) {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        if (this._uniformLocations[name] !== undefined) {\r\n            // Already existing uniform\r\n            return;\r\n        }\r\n        // This function must be called in the order of the shader layout !\r\n        // size can be the size of the uniform, or data directly\r\n        var data;\r\n        if (size instanceof Array) {\r\n            data = size;\r\n            size = data.length;\r\n        } else {\r\n            size = <number>size;\r\n            data = [];\r\n\r\n            // Fill with zeros\r\n            for (var i = 0; i < size; i++) {\r\n                data.push(0);\r\n            }\r\n        }\r\n\r\n        this._fillAlignment(<number>size);\r\n        this._uniformSizes[name] = <number>size;\r\n        this._uniformLocations[name] = this._uniformLocationPointer;\r\n        this._uniformLocationPointer += <number>size;\r\n\r\n        for (var i = 0; i < size; i++) {\r\n            this._data.push(data[i]);\r\n        }\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 4x4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param mat A 4x4 matrix.\r\n     */\r\n    public addMatrix(name: string, mat: Matrix) {\r\n        this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\r\n    }\r\n\r\n    /**\r\n     * Adds a vec2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec2\r\n     * @param y Define the y component value of the vec2\r\n     */\r\n    public addFloat2(name: string, x: number, y: number) {\r\n        var temp = [x, y];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param x Define the x component value of the vec3\r\n     * @param y Define the y component value of the vec3\r\n     * @param z Define the z component value of the vec3\r\n     */\r\n    public addFloat3(name: string, x: number, y: number, z: number) {\r\n        var temp = [x, y, z];\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the vec3 from a Color\r\n     */\r\n    public addColor3(name: string, color: Color3) {\r\n        var temp = new Array<number>();\r\n        color.toArray(temp);\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec4 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param color Define the rgb components from a Color\r\n     * @param alpha Define the a component of the vec4\r\n     */\r\n    public addColor4(name: string, color: Color3, alpha: number) {\r\n        var temp = new Array<number>();\r\n        color.toArray(temp);\r\n        temp.push(alpha);\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a vec3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     * @param vector Define the vec3 components from a Vector\r\n     */\r\n    public addVector3(name: string, vector: Vector3) {\r\n        var temp = new Array<number>();\r\n        vector.toArray(temp);\r\n        this.addUniform(name, temp);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 3x3 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix3x3(name: string) {\r\n        this.addUniform(name, 12);\r\n    }\r\n\r\n    /**\r\n     * Adds a Matrix 2x2 to the uniform buffer.\r\n     * @param name Name of the uniform, as used in the uniform block in the shader.\r\n     */\r\n    public addMatrix2x2(name: string) {\r\n        this.addUniform(name, 8);\r\n    }\r\n\r\n    /**\r\n     * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\r\n     */\r\n    public create(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n        if (this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        // See spec, alignment must be filled as a vec4\r\n        this._fillAlignment(4);\r\n        this._bufferData = new Float32Array(this._data);\r\n\r\n        this._rebuild();\r\n\r\n        this._needSync = true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._noUBO || !this._bufferData) {\r\n            return;\r\n        }\r\n\r\n        if (this._dynamic) {\r\n            this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\r\n        } else {\r\n            this._buffer = this._engine.createUniformBuffer(this._bufferData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the WebGL Uniform Buffer on the GPU.\r\n     * If the `dynamic` flag is set to true, no cache comparison is done.\r\n     * Otherwise, the buffer will be updated only if the cache differs.\r\n     */\r\n    public update(): void {\r\n        if (!this._buffer) {\r\n            this.create();\r\n            return;\r\n        }\r\n\r\n        if (!this._dynamic && !this._needSync) {\r\n            return;\r\n        }\r\n\r\n        this._engine.updateUniformBuffer(this._buffer, this._bufferData);\r\n\r\n        this._needSync = false;\r\n    }\r\n\r\n    /**\r\n     * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     * @param size Define the size of the data.\r\n     */\r\n    public updateUniform(uniformName: string, data: FloatArray, size: number) {\r\n\r\n        var location = this._uniformLocations[uniformName];\r\n        if (location === undefined) {\r\n            if (this._buffer) {\r\n                // Cannot add an uniform if the buffer is already created\r\n                Logger.Error(\"Cannot add an uniform after UBO has been created.\");\r\n                return;\r\n            }\r\n            this.addUniform(uniformName, size);\r\n            location = this._uniformLocations[uniformName];\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            this.create();\r\n        }\r\n\r\n        if (!this._dynamic) {\r\n            // Cache for static uniform buffers\r\n            var changed = false;\r\n\r\n            for (var i = 0; i < size; i++) {\r\n                // We are checking the matrix cache before calling updateUniform so we do not need to check it here\r\n                // Hence the test for size === 16 to simply commit the matrix values\r\n                if (size === 16 || this._bufferData[location + i] !== data[i]) {\r\n                    changed = true;\r\n                    this._bufferData[location + i] = data[i];\r\n                }\r\n            }\r\n\r\n            this._needSync = this._needSync || changed;\r\n        } else {\r\n            // No cache for dynamic\r\n            for (var i = 0; i < size; i++) {\r\n                this._bufferData[location + i] = data[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Matrix cache\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _cacheMatrix(name: string, matrix: IMatrixLike): boolean {\r\n        var cache = this._valueCache[name];\r\n        var flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[name] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Update methods\r\n\r\n    private _updateMatrix3x3ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (var i = 0; i < 3; i++) {\r\n            UniformBuffer._tempBuffer[i * 4] = matrix[i * 3];\r\n            UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\r\n            UniformBuffer._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\r\n            UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 12);\r\n    }\r\n\r\n    private _updateMatrix3x3ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix3x3(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForEffect(name: string, matrix: Float32Array): void {\r\n        this._currentEffect.setMatrix2x2(name, matrix);\r\n    }\r\n\r\n    private _updateMatrix2x2ForUniform(name: string, matrix: Float32Array): void {\r\n        // To match std140, matrix must be realigned\r\n        for (var i = 0; i < 2; i++) {\r\n            UniformBuffer._tempBuffer[i * 4] = matrix[i * 2];\r\n            UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\r\n            UniformBuffer._tempBuffer[i * 4 + 2] = 0.0;\r\n            UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\r\n        }\r\n\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 8);\r\n    }\r\n\r\n    private _updateFloatForEffect(name: string, x: number) {\r\n        this._currentEffect.setFloat(name, x);\r\n    }\r\n\r\n    private _updateFloatForUniform(name: string, x: number) {\r\n        UniformBuffer._tempBuffer[0] = x;\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 1);\r\n    }\r\n\r\n    private _updateFloat2ForEffect(name: string, x: number, y: number, suffix = \"\") {\r\n        this._currentEffect.setFloat2(name + suffix, x, y);\r\n    }\r\n\r\n    private _updateFloat2ForUniform(name: string, x: number, y: number) {\r\n        UniformBuffer._tempBuffer[0] = x;\r\n        UniformBuffer._tempBuffer[1] = y;\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 2);\r\n    }\r\n\r\n    private _updateFloat3ForEffect(name: string, x: number, y: number, z: number, suffix = \"\") {\r\n        this._currentEffect.setFloat3(name + suffix, x, y, z);\r\n    }\r\n\r\n    private _updateFloat3ForUniform(name: string, x: number, y: number, z: number) {\r\n        UniformBuffer._tempBuffer[0] = x;\r\n        UniformBuffer._tempBuffer[1] = y;\r\n        UniformBuffer._tempBuffer[2] = z;\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 3);\r\n\r\n    }\r\n\r\n    private _updateFloat4ForEffect(name: string, x: number, y: number, z: number, w: number, suffix = \"\") {\r\n        this._currentEffect.setFloat4(name + suffix, x, y, z, w);\r\n    }\r\n\r\n    private _updateFloat4ForUniform(name: string, x: number, y: number, z: number, w: number) {\r\n        UniformBuffer._tempBuffer[0] = x;\r\n        UniformBuffer._tempBuffer[1] = y;\r\n        UniformBuffer._tempBuffer[2] = z;\r\n        UniformBuffer._tempBuffer[3] = w;\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 4);\r\n    }\r\n\r\n    private _updateMatrixForEffect(name: string, mat: Matrix) {\r\n        this._currentEffect.setMatrix(name, mat);\r\n    }\r\n\r\n    private _updateMatrixForUniform(name: string, mat: Matrix) {\r\n        if (this._cacheMatrix(name, mat)) {\r\n            this.updateUniform(name, <any>mat.toArray(), 16);\r\n        }\r\n    }\r\n\r\n    private _updateVector3ForEffect(name: string, vector: Vector3) {\r\n        this._currentEffect.setVector3(name, vector);\r\n    }\r\n\r\n    private _updateVector3ForUniform(name: string, vector: Vector3) {\r\n        vector.toArray(UniformBuffer._tempBuffer);\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 3);\r\n    }\r\n\r\n    private _updateVector4ForEffect(name: string, vector: Vector4) {\r\n        this._currentEffect.setVector4(name, vector);\r\n    }\r\n\r\n    private _updateVector4ForUniform(name: string, vector: Vector4) {\r\n        vector.toArray(UniformBuffer._tempBuffer);\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 4);\r\n    }\r\n\r\n    private _updateColor3ForEffect(name: string, color: Color3, suffix = \"\") {\r\n        this._currentEffect.setColor3(name + suffix, color);\r\n    }\r\n\r\n    private _updateColor3ForUniform(name: string, color: Color3) {\r\n        color.toArray(UniformBuffer._tempBuffer);\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 3);\r\n    }\r\n\r\n    private _updateColor4ForEffect(name: string, color: Color3, alpha: number, suffix = \"\") {\r\n        this._currentEffect.setColor4(name + suffix, color, alpha);\r\n    }\r\n\r\n    private _updateColor4ForUniform(name: string, color: Color3, alpha: number) {\r\n        color.toArray(UniformBuffer._tempBuffer);\r\n        UniformBuffer._tempBuffer[3] = alpha;\r\n        this.updateUniform(name, UniformBuffer._tempBuffer, 4);\r\n    }\r\n\r\n    /**\r\n     * Sets a sampler uniform on the effect.\r\n     * @param name Define the name of the sampler.\r\n     * @param texture Define the texture to set in the sampler\r\n     */\r\n    public setTexture(name: string, texture: Nullable<BaseTexture>) {\r\n        this._currentEffect.setTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Directly updates the value of the uniform in the cache AND on the GPU.\r\n     * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\r\n     * @param data Define the flattened data\r\n     */\r\n    public updateUniformDirectly(uniformName: string, data: FloatArray) {\r\n        this.updateUniform(uniformName, data, data.length);\r\n\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Binds this uniform buffer to an effect.\r\n     * @param effect Define the effect to bind the buffer to\r\n     * @param name Name of the uniform block in the shader.\r\n     */\r\n    public bindToEffect(effect: Effect, name: string): void {\r\n        this._currentEffect = effect;\r\n\r\n        if (this._noUBO || !this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._alreadyBound = true;\r\n        effect.bindUniformBuffer(this._buffer, name);\r\n    }\r\n\r\n    /**\r\n     * Disposes the uniform buffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._noUBO) {\r\n            return;\r\n        }\r\n\r\n        const uniformBuffers = this._engine._uniformBuffers;\r\n        let index = uniformBuffers.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\r\n            uniformBuffers.pop();\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}