{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Ray } from \"../../Culling/ray\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { WebVRController } from \"./webVRController\";\nimport { GenericController } from \"./genericController\";\nimport { PoseEnabledController, PoseEnabledControllerType, PoseEnabledControllerHelper } from \"./poseEnabledController\";\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\n\nvar LoadedMeshInfo =\n/** @class */\nfunction () {\n  function LoadedMeshInfo() {\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\n    this.buttonMeshes = {};\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\n\n    this.axisMeshes = {};\n  }\n\n  return LoadedMeshInfo;\n}();\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\n\n\nvar WindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(WindowsMotionController, _super);\n  /**\r\n   * Creates a new WindowsMotionController from a gamepad\r\n   * @param vrGamepad the gamepad that the controller should be created from\r\n   */\n\n\n  function WindowsMotionController(vrGamepad) {\n    var _this = _super.call(this, vrGamepad) || this;\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        'trigger': 'SELECT',\n        'menu': 'MENU',\n        'grip': 'GRASP',\n        'thumbstick': 'THUMBSTICK_PRESS',\n        'trackpad': 'TOUCHPAD_PRESS'\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        'trigger': 'onTriggerStateChangedObservable',\n        'menu': 'onSecondaryButtonStateChangedObservable',\n        'grip': 'onMainButtonStateChangedObservable',\n        'thumbstick': 'onPadStateChangedObservable',\n        'trackpad': 'onTrackpadChangedObservable'\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: ['THUMBSTICK_X', 'THUMBSTICK_Y', 'TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_Y'],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\n\n    _this.onTrackpadChangedObservable = new Observable();\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\n\n    _this.onTrackpadValuesChangedObservable = new Observable();\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\n\n    _this.trackpad = {\n      x: 0,\n      y: 0\n    };\n    _this.controllerType = PoseEnabledControllerType.WINDOWS;\n    _this._loadedMeshInfo = null;\n    return _this;\n  }\n\n  Object.defineProperty(WindowsMotionController.prototype, \"onTriggerButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\n    get: function () {\n      return this.onTriggerStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onMenuButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\n    get: function () {\n      return this.onSecondaryButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onGripButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\n    get: function () {\n      return this.onMainButtonStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\n    get: function () {\n      return this.onPadStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\n    get: function () {\n      return this.onTrackpadChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WindowsMotionController.prototype, \"onTouchpadValuesChangedObservable\", {\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\n    get: function () {\n      return this.onTrackpadValuesChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_X')];\n      this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_Y')];\n      this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\r\n   * Called once per frame by the engine.\r\n   */\n\n\n  WindowsMotionController.prototype.update = function () {\n    _super.prototype.update.call(this);\n\n    if (this.browserGamepad.axes) {\n      this._updateTrackpad(); // Only need to animate axes if there is a loaded mesh\n\n\n      if (this._loadedMeshInfo) {\n        for (var axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\n          this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\n        }\n      }\n    }\n  };\n  /**\r\n   * Called once for each button that changed state since the last frame\r\n   * @param buttonIdx Which button index changed\r\n   * @param state New state of the button\r\n   * @param changes Which properties on the state changed since last frame\r\n   */\n\n\n  WindowsMotionController.prototype._handleButtonChange = function (buttonIdx, state, changes) {\n    var buttonName = this._mapping.buttons[buttonIdx];\n\n    if (!buttonName) {\n      return;\n    } // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\n\n\n    this._updateTrackpad(); // Only emit events for buttons that we know how to map from index to name\n\n\n    var observable = this[this._mapping.buttonObservableNames[buttonName]];\n\n    if (observable) {\n      observable.notifyObservers(state);\n    }\n\n    this._lerpButtonTransform(buttonName, state.value);\n  };\n  /**\r\n   * Moves the buttons on the controller mesh based on their current state\r\n   * @param buttonName the name of the button to move\r\n   * @param buttonValue the value of the button which determines the buttons new position\r\n   */\n\n\n  WindowsMotionController.prototype._lerpButtonTransform = function (buttonName, buttonValue) {\n    // If there is no loaded mesh, there is nothing to transform.\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\n\n    if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    }\n\n    Quaternion.SlerpToRef(meshInfo.unpressed.rotationQuaternion, meshInfo.pressed.rotationQuaternion, buttonValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.unpressed.position, meshInfo.pressed.position, buttonValue, meshInfo.value.position);\n  };\n  /**\r\n   * Moves the axis on the controller mesh based on its current state\r\n   * @param axis the index of the axis\r\n   * @param axisValue the value of the axis which determines the meshes new position\r\n   * @hidden\r\n   */\n\n\n  WindowsMotionController.prototype._lerpAxisTransform = function (axis, axisValue) {\n    if (!this._loadedMeshInfo) {\n      return;\n    }\n\n    var meshInfo = this._loadedMeshInfo.axisMeshes[axis];\n\n    if (!meshInfo) {\n      return;\n    }\n\n    if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\n      return;\n    } // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n\n\n    var lerpValue = axisValue * 0.5 + 0.5;\n    Quaternion.SlerpToRef(meshInfo.min.rotationQuaternion, meshInfo.max.rotationQuaternion, lerpValue, meshInfo.value.rotationQuaternion);\n    Vector3.LerpToRef(meshInfo.min.position, meshInfo.max.position, lerpValue, meshInfo.value.position);\n  };\n  /**\r\n   * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n   * @param scene scene in which to add meshes\r\n   * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n   */\n\n\n  WindowsMotionController.prototype.initControllerMesh = function (scene, meshLoaded, forceDefault) {\n    var _this = this;\n\n    if (forceDefault === void 0) {\n      forceDefault = false;\n    }\n\n    var path;\n    var filename; // Checking if GLB loader is present\n\n    if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\n      // Determine the device specific folder based on the ID suffix\n      var device = 'default';\n\n      if (this.id && !forceDefault) {\n        var match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\n        device = match && match[0] || device;\n      } // Hand\n\n\n      if (this.hand === 'left') {\n        filename = WindowsMotionController.MODEL_LEFT_FILENAME;\n      } else {\n        // Right is the default if no hand is specified\n        filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\n      }\n\n      path = WindowsMotionController.MODEL_BASE_URL + device + '/';\n    } else {\n      Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\n      path = GenericController.MODEL_BASE_URL;\n      filename = GenericController.MODEL_FILENAME;\n    }\n\n    SceneLoader.ImportMesh(\"\", path, filename, scene, function (meshes) {\n      // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\n      _this._loadedMeshInfo = _this.processModel(scene, meshes);\n\n      if (!_this._loadedMeshInfo) {\n        return;\n      }\n\n      _this._defaultModel = _this._loadedMeshInfo.rootNode;\n\n      _this.attachToMesh(_this._defaultModel);\n\n      if (meshLoaded) {\n        meshLoaded(_this._defaultModel);\n      }\n    }, null, function (scene, message) {\n      Logger.Log(message);\n      Logger.Warn('Failed to retrieve controller model from the remote server: ' + path + filename);\n\n      if (!forceDefault) {\n        _this.initControllerMesh(scene, meshLoaded, true);\n      }\n    });\n  };\n  /**\r\n   * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n   * can be transformed by button presses and axes values, based on this._mapping.\r\n   *\r\n   * @param scene scene in which the meshes exist\r\n   * @param meshes list of meshes that make up the controller model to process\r\n   * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n   */\n\n\n  WindowsMotionController.prototype.processModel = function (scene, meshes) {\n    var loadedMeshInfo = null; // Create a new mesh to contain the glTF hierarchy\n\n    var parentMesh = new Mesh(this.id + \" \" + this.hand, scene); // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\n\n    var childMesh = null;\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n\n      if (!mesh.parent) {\n        // Exclude controller meshes from picking results\n        mesh.isPickable = false; // Handle root node, attach to the new parentMesh\n\n        childMesh = mesh;\n        break;\n      }\n    }\n\n    if (childMesh) {\n      childMesh.setParent(parentMesh); // Create our mesh info. Note that this method will always return non-null.\n\n      loadedMeshInfo = this.createMeshInfo(parentMesh);\n    } else {\n      Logger.Warn('Could not find root node in model file.');\n    }\n\n    return loadedMeshInfo;\n  };\n\n  WindowsMotionController.prototype.createMeshInfo = function (rootNode) {\n    var loadedMeshInfo = new LoadedMeshInfo();\n    var i;\n    loadedMeshInfo.rootNode = rootNode; // Reset the caches\n\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {}; // Button Meshes\n\n    for (i = 0; i < this._mapping.buttons.length; i++) {\n      var buttonMeshName = this._mapping.buttonMeshNames[this._mapping.buttons[i]];\n\n      if (!buttonMeshName) {\n        Logger.Log('Skipping unknown button at index: ' + i + ' with mapped name: ' + this._mapping.buttons[i]);\n        continue;\n      }\n\n      var buttonMesh = getChildByName(rootNode, buttonMeshName);\n\n      if (!buttonMesh) {\n        Logger.Warn('Missing button mesh with name: ' + buttonMeshName);\n        continue;\n      }\n\n      var buttonMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(buttonMesh, 'VALUE'),\n        pressed: getImmediateChildByName(buttonMesh, 'PRESSED'),\n        unpressed: getImmediateChildByName(buttonMesh, 'UNPRESSED')\n      };\n\n      if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\n        loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n        Logger.Warn('Missing button submesh under mesh with name: ' + buttonMeshName + '(VALUE: ' + !!buttonMeshInfo.value + ', PRESSED: ' + !!buttonMeshInfo.pressed + ', UNPRESSED:' + !!buttonMeshInfo.unpressed + ')');\n      }\n    } // Axis Meshes\n\n\n    for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\n      var axisMeshName = this._mapping.axisMeshNames[i];\n\n      if (!axisMeshName) {\n        Logger.Log('Skipping unknown axis at index: ' + i);\n        continue;\n      }\n\n      var axisMesh = getChildByName(rootNode, axisMeshName);\n\n      if (!axisMesh) {\n        Logger.Warn('Missing axis mesh with name: ' + axisMeshName);\n        continue;\n      }\n\n      var axisMeshInfo = {\n        index: i,\n        value: getImmediateChildByName(axisMesh, 'VALUE'),\n        min: getImmediateChildByName(axisMesh, 'MIN'),\n        max: getImmediateChildByName(axisMesh, 'MAX')\n      };\n\n      if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\n        loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\n      } else {\n        // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\n        Logger.Warn('Missing axis submesh under mesh with name: ' + axisMeshName + '(VALUE: ' + !!axisMeshInfo.value + ', MIN: ' + !!axisMeshInfo.min + ', MAX:' + !!axisMeshInfo.max + ')');\n      }\n    } // Pointing Ray\n\n\n    loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\n\n    if (!loadedMeshInfo.pointingPoseNode) {\n      Logger.Warn('Missing pointing pose mesh with name: ' + this._mapping.pointingPoseMeshName);\n    } else {\n      this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\n    }\n\n    return loadedMeshInfo; // Look through all children recursively. This will return null if no mesh exists with the given name.\n\n    function getChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name === name;\n      }, false)[0];\n    } // Look through only immediate children. This will return null if no mesh exists with the given name.\n\n\n    function getImmediateChildByName(node, name) {\n      return node.getChildren(function (n) {\n        return n.name == name;\n      }, true)[0];\n    }\n  };\n  /**\r\n   * Gets the ray of the controller in the direction the controller is pointing\r\n   * @param length the length the resulting ray should be\r\n   * @returns a ray in the direction the controller is pointing\r\n   */\n\n\n  WindowsMotionController.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n\n    var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\n\n    var origin = m.getTranslation();\n    var forward = new Vector3(0, 0, -1);\n    var forwardWorld = Vector3.TransformNormal(forward, m);\n    var direction = Vector3.Normalize(forwardWorld);\n    return new Ray(origin, direction, length);\n  };\n  /**\r\n  * Disposes of the controller\r\n  */\n\n\n  WindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onTrackpadChangedObservable.clear();\n    this.onTrackpadValuesChangedObservable.clear();\n  };\n  /**\r\n   * The base url used to load the left and right controller models\r\n   */\n\n\n  WindowsMotionController.MODEL_BASE_URL = 'https://controllers.babylonjs.com/microsoft/';\n  /**\r\n   * The name of the left controller model file\r\n   */\n\n  WindowsMotionController.MODEL_LEFT_FILENAME = 'left.glb';\n  /**\r\n   * The name of the right controller model file\r\n   */\n\n  WindowsMotionController.MODEL_RIGHT_FILENAME = 'right.glb';\n  /**\r\n   * The controller name prefix for this controller type\r\n   */\n\n  WindowsMotionController.GAMEPAD_ID_PREFIX = 'Spatial Controller (Spatial Interaction Source) ';\n  /**\r\n   * The controller id pattern for this controller type\r\n   */\n\n  WindowsMotionController.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\n  return WindowsMotionController;\n}(WebVRController);\n\nexport { WindowsMotionController };\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\n\nvar XRWindowsMotionController =\n/** @class */\nfunction (_super) {\n  __extends(XRWindowsMotionController, _super);\n  /**\r\n   * Construct a new XR-Based windows motion controller\r\n   *\r\n   * @param gamepadInfo the gamepad object from the browser\r\n   */\n\n\n  function XRWindowsMotionController(gamepadInfo) {\n    var _this = _super.call(this, gamepadInfo) || this;\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\n\n\n    _this._mapping = {\n      // Semantic button names\n      buttons: ['trigger', 'grip', 'trackpad', 'thumbstick', 'menu'],\n      // trigger, grip, trackpad, thumbstick, menu\n      // A mapping of the button name to glTF model node name\n      // that should be transformed by button value.\n      buttonMeshNames: {\n        'trigger': 'SELECT',\n        'menu': 'MENU',\n        'grip': 'GRASP',\n        'thumbstick': 'THUMBSTICK_PRESS',\n        'trackpad': 'TOUCHPAD_PRESS'\n      },\n      // This mapping is used to translate from the Motion Controller to Babylon semantics\n      buttonObservableNames: {\n        'trigger': 'onTriggerStateChangedObservable',\n        'menu': 'onSecondaryButtonStateChangedObservable',\n        'grip': 'onMainButtonStateChangedObservable',\n        'thumbstick': 'onThumbstickStateChangedObservable',\n        'trackpad': 'onTrackpadChangedObservable'\n      },\n      // A mapping of the axis name to glTF model node name\n      // that should be transformed by axis value.\n      // This array mirrors the browserGamepad.axes array, such that\n      // the mesh corresponding to axis 0 is in this array index 0.\n      axisMeshNames: ['TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_Y', 'THUMBSTICK_X', 'THUMBSTICK_Y'],\n      // upside down in webxr\n      pointingPoseMeshName: PoseEnabledController.POINTING_POSE\n    };\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\n\n    _this.thumbstickValues = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\n\n    _this.onThumbstickStateChangedObservable = new Observable();\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\n\n    _this.onThumbstickValuesChangedObservable = new Observable();\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\n\n    _this.onTrackpadChangedObservable = _this.onPadStateChangedObservable;\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\n\n    _this.onTrackpadValuesChangedObservable = _this.onPadValuesChangedObservable;\n    return _this;\n  }\n\n  Object.defineProperty(XRWindowsMotionController.prototype, \"onThumbstickButtonStateChangedObservable\", {\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\n    get: function () {\n      return this.onThumbstickStateChangedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * updating the thumbstick(!) and not the trackpad.\r\n   * This is named this way due to the difference between WebVR and XR and to avoid\r\n   * changing the parent class.\r\n   */\n\n  XRWindowsMotionController.prototype._updateTrackpad = function () {\n    if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\n      this.trackpad.x = this.browserGamepad[\"axes\"][2];\n      this.trackpad.y = this.browserGamepad[\"axes\"][3];\n      this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\n    }\n  };\n  /**\r\n   * Disposes the class with joy\r\n   */\n\n\n  XRWindowsMotionController.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onThumbstickStateChangedObservable.clear();\n    this.onThumbstickValuesChangedObservable.clear();\n  };\n\n  return XRWindowsMotionController;\n}(WindowsMotionController);\n\nexport { XRWindowsMotionController };\n\nPoseEnabledControllerHelper._ControllerFactories.push({\n  canCreate: function (gamepadInfo) {\n    return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\n  },\n  create: function (gamepadInfo) {\n    return new WindowsMotionController(gamepadInfo);\n  }\n});","map":{"version":3,"sources":["../../../../sourceES6/core/Gamepads/Controllers/windowsMotionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Node } from \"../../node\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { WebVRController } from \"./webVRController\";\r\nimport { GenericController } from \"./genericController\";\r\nimport { PoseEnabledController, PoseEnabledControllerType, ExtendedGamepadButton, PoseEnabledControllerHelper } from \"./poseEnabledController\";\r\nimport { StickValues, GamepadButtonChanges } from \"../../Gamepads/gamepad\";\r\n\r\n/**\r\n * Defines the LoadedMeshInfo object that describes information about the loaded webVR controller mesh\r\n */\r\nclass LoadedMeshInfo {\r\n    /**\r\n     * Root of the mesh\r\n     */\r\n    public rootNode: AbstractMesh;\r\n    /**\r\n     * Node of the mesh corresponding to the direction the ray should be cast from the controller\r\n     */\r\n    public pointingPoseNode: TransformNode;\r\n    /**\r\n     * Map of the button meshes contained in the controller\r\n     */\r\n    public buttonMeshes: { [id: string]: IButtonMeshInfo; } = {};\r\n    /**\r\n     * Map of the axis meshes contained in the controller\r\n     */\r\n    public axisMeshes: { [id: number]: IAxisMeshInfo; } = {};\r\n}\r\n\r\n/**\r\n * Defines the IMeshInfo object that describes information a webvr controller mesh\r\n */\r\ninterface IMeshInfo {\r\n    /**\r\n     * Index of the mesh inside the root mesh\r\n     */\r\n    index: number;\r\n    /**\r\n     * The mesh\r\n     */\r\n    value: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IButtonMeshInfo object that describes a button mesh\r\n */\r\ninterface IButtonMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be displayed when pressed\r\n     */\r\n    pressed: TransformNode;\r\n    /**\r\n     * The mesh that should be displayed when not pressed\r\n     */\r\n    unpressed: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the IAxisMeshInfo object that describes an axis mesh\r\n */\r\ninterface IAxisMeshInfo extends IMeshInfo {\r\n    /**\r\n     * The mesh that should be set when at its min\r\n     */\r\n    min: TransformNode;\r\n    /**\r\n     * The mesh that should be set when at its max\r\n     */\r\n    max: TransformNode;\r\n}\r\n\r\n/**\r\n * Defines the WindowsMotionController object that the state of the windows motion controller\r\n */\r\nexport class WindowsMotionController extends WebVRController {\r\n    /**\r\n     * The base url used to load the left and right controller models\r\n     */\r\n    public static MODEL_BASE_URL: string = 'https://controllers.babylonjs.com/microsoft/';\r\n    /**\r\n     * The name of the left controller model file\r\n     */\r\n    public static MODEL_LEFT_FILENAME: string = 'left.glb';\r\n    /**\r\n     * The name of the right controller model file\r\n     */\r\n    public static MODEL_RIGHT_FILENAME: string = 'right.glb';\r\n\r\n    /**\r\n     * The controller name prefix for this controller type\r\n     */\r\n    public static readonly GAMEPAD_ID_PREFIX: string = 'Spatial Controller (Spatial Interaction Source) ';\r\n    /**\r\n     * The controller id pattern for this controller type\r\n     */\r\n    private static readonly GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\r\n\r\n    private _loadedMeshInfo: Nullable<LoadedMeshInfo>;\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            'trigger': 'SELECT',\r\n            'menu': 'MENU',\r\n            'grip': 'GRASP',\r\n            'thumbstick': 'THUMBSTICK_PRESS',\r\n            'trackpad': 'TOUCHPAD_PRESS'\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            'trigger': 'onTriggerStateChangedObservable',\r\n            'menu': 'onSecondaryButtonStateChangedObservable',\r\n            'grip': 'onMainButtonStateChangedObservable',\r\n            'thumbstick': 'onPadStateChangedObservable',\r\n            'trackpad': 'onTrackpadChangedObservable'\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\r\n            'THUMBSTICK_X',\r\n            'THUMBSTICK_Y',\r\n            'TOUCHPAD_TOUCH_X',\r\n            'TOUCHPAD_TOUCH_Y'\r\n        ],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE\r\n    };\r\n\r\n    /**\r\n     * Fired when the trackpad on this controller is clicked\r\n     */\r\n    public onTrackpadChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the trackpad on this controller is modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = new Observable<StickValues>();\r\n    /**\r\n     * The current x and y values of this controller's trackpad\r\n     */\r\n    public trackpad: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Creates a new WindowsMotionController from a gamepad\r\n     * @param vrGamepad the gamepad that the controller should be created from\r\n     */\r\n    constructor(vrGamepad: any) {\r\n        super(vrGamepad);\r\n        this.controllerType = PoseEnabledControllerType.WINDOWS;\r\n        this._loadedMeshInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Fired when the trigger on this controller is modified\r\n     */\r\n    public get onTriggerButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTriggerStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the menu button on this controller is modified\r\n     */\r\n    public get onMenuButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onSecondaryButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the grip button on this controller is modified\r\n     */\r\n    public get onGripButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onMainButtonStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onPadStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public get onTouchpadButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onTrackpadChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public get onTouchpadValuesChangedObservable(): Observable<StickValues> {\r\n        return this.onTrackpadValuesChangedObservable;\r\n    }\r\n\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.trackpad.x || this.browserGamepad.axes[3] != this.trackpad.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_X')];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][this._mapping.axisMeshNames.indexOf('TOUCHPAD_TOUCH_Y')];\r\n            this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once per frame by the engine.\r\n     */\r\n    public update() {\r\n        super.update();\r\n        if (this.browserGamepad.axes) {\r\n            this._updateTrackpad();\r\n            // Only need to animate axes if there is a loaded mesh\r\n            if (this._loadedMeshInfo) {\r\n                for (let axis = 0; axis < this._mapping.axisMeshNames.length; axis++) {\r\n                    this._lerpAxisTransform(axis, this.browserGamepad.axes[axis]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called once for each button that changed state since the last frame\r\n     * @param buttonIdx Which button index changed\r\n     * @param state New state of the button\r\n     * @param changes Which properties on the state changed since last frame\r\n     */\r\n    protected _handleButtonChange(buttonIdx: number, state: ExtendedGamepadButton, changes: GamepadButtonChanges) {\r\n        let buttonName = this._mapping.buttons[buttonIdx];\r\n        if (!buttonName) {\r\n            return;\r\n        }\r\n\r\n        // Update the trackpad to ensure trackpad.x/y are accurate during button events between frames\r\n        this._updateTrackpad();\r\n\r\n        // Only emit events for buttons that we know how to map from index to name\r\n        let observable = (<any>this)[(<any>(this._mapping.buttonObservableNames))[buttonName]];\r\n        if (observable) {\r\n            observable.notifyObservers(state);\r\n        }\r\n\r\n        this._lerpButtonTransform(buttonName, state.value);\r\n    }\r\n\r\n    /**\r\n     * Moves the buttons on the controller mesh based on their current state\r\n     * @param buttonName the name of the button to move\r\n     * @param buttonValue the value of the button which determines the buttons new position\r\n     */\r\n    protected _lerpButtonTransform(buttonName: string, buttonValue: number) {\r\n\r\n        // If there is no loaded mesh, there is nothing to transform.\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        var meshInfo = this._loadedMeshInfo.buttonMeshes[buttonName];\r\n\r\n        if (!meshInfo || !meshInfo.unpressed.rotationQuaternion || !meshInfo.pressed.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        Quaternion.SlerpToRef(\r\n            meshInfo.unpressed.rotationQuaternion,\r\n            meshInfo.pressed.rotationQuaternion,\r\n            buttonValue,\r\n            meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(\r\n            meshInfo.unpressed.position,\r\n            meshInfo.pressed.position,\r\n            buttonValue,\r\n            meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Moves the axis on the controller mesh based on its current state\r\n     * @param axis the index of the axis\r\n     * @param axisValue the value of the axis which determines the meshes new position\r\n     * @hidden\r\n     */\r\n    protected _lerpAxisTransform(axis: number, axisValue: number) {\r\n        if (!this._loadedMeshInfo) {\r\n            return;\r\n        }\r\n\r\n        let meshInfo = this._loadedMeshInfo.axisMeshes[axis];\r\n        if (!meshInfo) {\r\n            return;\r\n        }\r\n\r\n        if (!meshInfo.min.rotationQuaternion || !meshInfo.max.rotationQuaternion || !meshInfo.value.rotationQuaternion) {\r\n            return;\r\n        }\r\n\r\n        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\r\n        let lerpValue = axisValue * 0.5 + 0.5;\r\n        Quaternion.SlerpToRef(\r\n            meshInfo.min.rotationQuaternion,\r\n            meshInfo.max.rotationQuaternion,\r\n            lerpValue,\r\n            meshInfo.value.rotationQuaternion);\r\n        Vector3.LerpToRef(\r\n            meshInfo.min.position,\r\n            meshInfo.max.position,\r\n            lerpValue,\r\n            meshInfo.value.position);\r\n    }\r\n\r\n    /**\r\n     * Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.\r\n     * @param scene scene in which to add meshes\r\n     * @param meshLoaded optional callback function that will be called if the mesh loads successfully.\r\n     */\r\n    public initControllerMesh(scene: Scene, meshLoaded?: (mesh: AbstractMesh) => void, forceDefault = false) {\r\n        let path: string;\r\n        let filename: string;\r\n\r\n        // Checking if GLB loader is present\r\n        if (SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\r\n            // Determine the device specific folder based on the ID suffix\r\n            let device = 'default';\r\n            if (this.id && !forceDefault) {\r\n                let match = this.id.match(WindowsMotionController.GAMEPAD_ID_PATTERN);\r\n                device = ((match && match[0]) || device);\r\n            }\r\n\r\n            // Hand\r\n            if (this.hand === 'left') {\r\n                filename = WindowsMotionController.MODEL_LEFT_FILENAME;\r\n            }\r\n            else { // Right is the default if no hand is specified\r\n                filename = WindowsMotionController.MODEL_RIGHT_FILENAME;\r\n            }\r\n\r\n            path = WindowsMotionController.MODEL_BASE_URL + device + '/';\r\n        } else {\r\n            Logger.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\");\r\n            path = GenericController.MODEL_BASE_URL;\r\n            filename = GenericController.MODEL_FILENAME;\r\n        }\r\n\r\n        SceneLoader.ImportMesh(\"\", path, filename, scene, (meshes: AbstractMesh[]) => {\r\n            // glTF files successfully loaded from the remote server, now process them to ensure they are in the right format.\r\n            this._loadedMeshInfo = this.processModel(scene, meshes);\r\n\r\n            if (!this._loadedMeshInfo) {\r\n                return;\r\n            }\r\n\r\n            this._defaultModel = this._loadedMeshInfo.rootNode;\r\n            this.attachToMesh(this._defaultModel);\r\n\r\n            if (meshLoaded) {\r\n                meshLoaded(this._defaultModel);\r\n            }\r\n        }, null, (scene: Scene, message: string) => {\r\n            Logger.Log(message);\r\n            Logger.Warn('Failed to retrieve controller model from the remote server: ' + path + filename);\r\n            if (!forceDefault) {\r\n                this.initControllerMesh(scene, meshLoaded, true);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that\r\n     * can be transformed by button presses and axes values, based on this._mapping.\r\n     *\r\n     * @param scene scene in which the meshes exist\r\n     * @param meshes list of meshes that make up the controller model to process\r\n     * @return structured view of the given meshes, with mapping of buttons and axes to meshes that can be transformed.\r\n     */\r\n    private processModel(scene: Scene, meshes: AbstractMesh[]): Nullable<LoadedMeshInfo> {\r\n        let loadedMeshInfo = null;\r\n\r\n        // Create a new mesh to contain the glTF hierarchy\r\n        let parentMesh = new Mesh(this.id + \" \" + this.hand, scene);\r\n\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        let childMesh: Nullable<AbstractMesh> = null;\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            let mesh = meshes[i];\r\n\r\n            if (!mesh.parent) {\r\n                // Exclude controller meshes from picking results\r\n                mesh.isPickable = false;\r\n\r\n                // Handle root node, attach to the new parentMesh\r\n                childMesh = mesh;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (childMesh) {\r\n            childMesh.setParent(parentMesh);\r\n\r\n            // Create our mesh info. Note that this method will always return non-null.\r\n            loadedMeshInfo = this.createMeshInfo(parentMesh);\r\n        } else {\r\n            Logger.Warn('Could not find root node in model file.');\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n    }\r\n\r\n    private createMeshInfo(rootNode: AbstractMesh): LoadedMeshInfo {\r\n        let loadedMeshInfo = new LoadedMeshInfo();\r\n        var i;\r\n        loadedMeshInfo.rootNode = rootNode;\r\n\r\n        // Reset the caches\r\n        loadedMeshInfo.buttonMeshes = {};\r\n        loadedMeshInfo.axisMeshes = {};\r\n\r\n        // Button Meshes\r\n        for (i = 0; i < this._mapping.buttons.length; i++) {\r\n            var buttonMeshName = (<any>this._mapping.buttonMeshNames)[this._mapping.buttons[i]];\r\n            if (!buttonMeshName) {\r\n                Logger.Log('Skipping unknown button at index: ' + i + ' with mapped name: ' + this._mapping.buttons[i]);\r\n                continue;\r\n            }\r\n\r\n            var buttonMesh = getChildByName(rootNode, buttonMeshName);\r\n            if (!buttonMesh) {\r\n                Logger.Warn('Missing button mesh with name: ' + buttonMeshName);\r\n                continue;\r\n            }\r\n\r\n            var buttonMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(buttonMesh, 'VALUE'),\r\n                pressed: getImmediateChildByName(buttonMesh, 'PRESSED'),\r\n                unpressed: getImmediateChildByName(buttonMesh, 'UNPRESSED')\r\n            };\r\n            if (buttonMeshInfo.value && buttonMeshInfo.pressed && buttonMeshInfo.unpressed) {\r\n                loadedMeshInfo.buttonMeshes[this._mapping.buttons[i]] = buttonMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\r\n                Logger.Warn('Missing button submesh under mesh with name: ' + buttonMeshName +\r\n                    '(VALUE: ' + !!buttonMeshInfo.value +\r\n                    ', PRESSED: ' + !!buttonMeshInfo.pressed +\r\n                    ', UNPRESSED:' + !!buttonMeshInfo.unpressed +\r\n                    ')');\r\n            }\r\n        }\r\n\r\n        // Axis Meshes\r\n        for (i = 0; i < this._mapping.axisMeshNames.length; i++) {\r\n            var axisMeshName = this._mapping.axisMeshNames[i];\r\n            if (!axisMeshName) {\r\n                Logger.Log('Skipping unknown axis at index: ' + i);\r\n                continue;\r\n            }\r\n\r\n            var axisMesh = getChildByName(rootNode, axisMeshName);\r\n            if (!axisMesh) {\r\n                Logger.Warn('Missing axis mesh with name: ' + axisMeshName);\r\n                continue;\r\n            }\r\n\r\n            var axisMeshInfo = {\r\n                index: i,\r\n                value: getImmediateChildByName(axisMesh, 'VALUE'),\r\n                min: getImmediateChildByName(axisMesh, 'MIN'),\r\n                max: getImmediateChildByName(axisMesh, 'MAX')\r\n            };\r\n            if (axisMeshInfo.value && axisMeshInfo.min && axisMeshInfo.max) {\r\n                loadedMeshInfo.axisMeshes[i] = axisMeshInfo;\r\n            } else {\r\n                // If we didn't find the mesh, it simply means thit axis won't have transforms applied as mapped axis values change.\r\n                Logger.Warn('Missing axis submesh under mesh with name: ' + axisMeshName +\r\n                    '(VALUE: ' + !!axisMeshInfo.value +\r\n                    ', MIN: ' + !!axisMeshInfo.min +\r\n                    ', MAX:' + !!axisMeshInfo.max +\r\n                    ')');\r\n            }\r\n        }\r\n\r\n        // Pointing Ray\r\n        loadedMeshInfo.pointingPoseNode = getChildByName(rootNode, this._mapping.pointingPoseMeshName);\r\n        if (!loadedMeshInfo.pointingPoseNode) {\r\n            Logger.Warn('Missing pointing pose mesh with name: ' + this._mapping.pointingPoseMeshName);\r\n        } else {\r\n            this._pointingPoseNode = loadedMeshInfo.pointingPoseNode;\r\n        }\r\n\r\n        return loadedMeshInfo;\r\n\r\n        // Look through all children recursively. This will return null if no mesh exists with the given name.\r\n        function getChildByName(node: Node, name: string) {\r\n            return <TransformNode>node.getChildren((n) => n.name === name, false)[0];\r\n        }\r\n        // Look through only immediate children. This will return null if no mesh exists with the given name.\r\n        function getImmediateChildByName(node: Node, name: string): TransformNode {\r\n            return <TransformNode>node.getChildren((n) => n.name == name, true)[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ray of the controller in the direction the controller is pointing\r\n     * @param length the length the resulting ray should be\r\n     * @returns a ray in the direction the controller is pointing\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (!(this._loadedMeshInfo && this._loadedMeshInfo.pointingPoseNode)) {\r\n            return super.getForwardRay(length);\r\n        }\r\n\r\n        var m = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix();\r\n        var origin = m.getTranslation();\r\n\r\n        var forward = new Vector3(0, 0, -1);\r\n        var forwardWorld = Vector3.TransformNormal(forward, m);\r\n\r\n        var direction = Vector3.Normalize(forwardWorld);\r\n\r\n        return new Ray(origin, direction, length);\r\n    }\r\n\r\n    /**\r\n    * Disposes of the controller\r\n    */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTrackpadChangedObservable.clear();\r\n        this.onTrackpadValuesChangedObservable.clear();\r\n    }\r\n}\r\n\r\n/**\r\n * This class represents a new windows motion controller in XR.\r\n */\r\nexport class XRWindowsMotionController extends WindowsMotionController {\r\n\r\n    /**\r\n     * Changing the original WIndowsMotionController mapping to fir the new mapping\r\n     */\r\n    protected readonly _mapping = {\r\n        // Semantic button names\r\n        buttons: ['trigger', 'grip', 'trackpad', 'thumbstick', 'menu'],\r\n        // trigger, grip, trackpad, thumbstick, menu\r\n\r\n        // A mapping of the button name to glTF model node name\r\n        // that should be transformed by button value.\r\n        buttonMeshNames: {\r\n            'trigger': 'SELECT',\r\n            'menu': 'MENU',\r\n            'grip': 'GRASP',\r\n            'thumbstick': 'THUMBSTICK_PRESS',\r\n            'trackpad': 'TOUCHPAD_PRESS'\r\n        },\r\n        // This mapping is used to translate from the Motion Controller to Babylon semantics\r\n        buttonObservableNames: {\r\n            'trigger': 'onTriggerStateChangedObservable',\r\n            'menu': 'onSecondaryButtonStateChangedObservable',\r\n            'grip': 'onMainButtonStateChangedObservable',\r\n            'thumbstick': 'onThumbstickStateChangedObservable',\r\n            'trackpad': 'onTrackpadChangedObservable'\r\n        },\r\n        // A mapping of the axis name to glTF model node name\r\n        // that should be transformed by axis value.\r\n        // This array mirrors the browserGamepad.axes array, such that\r\n        // the mesh corresponding to axis 0 is in this array index 0.\r\n        axisMeshNames: [\r\n            'TOUCHPAD_TOUCH_X',\r\n            'TOUCHPAD_TOUCH_Y',\r\n            'THUMBSTICK_X',\r\n            'THUMBSTICK_Y'\r\n        ],\r\n        // upside down in webxr\r\n        pointingPoseMeshName: PoseEnabledController.POINTING_POSE\r\n    };\r\n\r\n    /**\r\n     * Construct a new XR-Based windows motion controller\r\n     *\r\n     * @param gamepadInfo the gamepad object from the browser\r\n     */\r\n    constructor(gamepadInfo: any) {\r\n        super(gamepadInfo);\r\n    }\r\n\r\n    /**\r\n     * holds the thumbstick values (X,Y)\r\n     */\r\n    public thumbstickValues: StickValues = { x: 0, y: 0 };\r\n\r\n    /**\r\n     * Fired when the thumbstick on this controller is clicked\r\n     */\r\n    public onThumbstickStateChangedObservable = new Observable<ExtendedGamepadButton>();\r\n    /**\r\n     * Fired when the thumbstick on this controller is modified\r\n     */\r\n    public onThumbstickValuesChangedObservable = new Observable<StickValues>();\r\n\r\n    /**\r\n     * Fired when the touchpad button on this controller is modified\r\n     */\r\n    public onTrackpadChangedObservable = this.onPadStateChangedObservable;\r\n\r\n    /**\r\n     * Fired when the touchpad values on this controller are modified\r\n     */\r\n    public onTrackpadValuesChangedObservable = this.onPadValuesChangedObservable;\r\n\r\n    /**\r\n     * Fired when the thumbstick button on this controller is modified\r\n     * here to prevent breaking changes\r\n     */\r\n    public get onThumbstickButtonStateChangedObservable(): Observable<ExtendedGamepadButton> {\r\n        return this.onThumbstickStateChangedObservable;\r\n    }\r\n\r\n    /**\r\n     * updating the thumbstick(!) and not the trackpad.\r\n     * This is named this way due to the difference between WebVR and XR and to avoid\r\n     * changing the parent class.\r\n     */\r\n    protected _updateTrackpad() {\r\n        if (this.browserGamepad.axes && (this.browserGamepad.axes[2] != this.thumbstickValues.x || this.browserGamepad.axes[3] != this.thumbstickValues.y)) {\r\n            this.trackpad.x = this.browserGamepad[\"axes\"][2];\r\n            this.trackpad.y = this.browserGamepad[\"axes\"][3];\r\n            this.onThumbstickValuesChangedObservable.notifyObservers(this.trackpad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the class with joy\r\n     */\r\n    public dispose() {\r\n        super.dispose();\r\n        this.onThumbstickStateChangedObservable.clear();\r\n        this.onThumbstickValuesChangedObservable.clear();\r\n    }\r\n\r\n}\r\n\r\nPoseEnabledControllerHelper._ControllerFactories.push({\r\n    canCreate: (gamepadInfo) => {\r\n        return gamepadInfo.id.indexOf(WindowsMotionController.GAMEPAD_ID_PREFIX) === 0;\r\n    },\r\n    create: (gamepadInfo) => {\r\n        return new WindowsMotionController(gamepadInfo);\r\n    }\r\n});\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}