{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\nimport { ToLinearSpace } from '../../Maths/math.constants';\nimport { Color3 } from '../../Maths/math.color';\n\nvar FileFaceOrientation =\n/** @class */\nfunction () {\n  function FileFaceOrientation(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n    this.name = name;\n    this.worldAxisForNormal = worldAxisForNormal;\n    this.worldAxisForFileX = worldAxisForFileX;\n    this.worldAxisForFileY = worldAxisForFileY;\n  }\n\n  return FileFaceOrientation;\n}();\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\n\n\nvar CubeMapToSphericalPolynomialTools =\n/** @class */\nfunction () {\n  function CubeMapToSphericalPolynomialTools() {}\n  /**\r\n   * Converts a texture to the according Spherical Polynomial data.\r\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n   *\r\n   * @param texture The texture to extract the information from.\r\n   * @return The Spherical Polynomial data.\r\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial = function (texture) {\n    if (!texture.isCube) {\n      // Only supports cube Textures currently.\n      return null;\n    }\n\n    var size = texture.getSize().width;\n    var right = texture.readPixels(0);\n    var left = texture.readPixels(1);\n    var up;\n    var down;\n\n    if (texture.isRenderTarget) {\n      up = texture.readPixels(3);\n      down = texture.readPixels(2);\n    } else {\n      up = texture.readPixels(2);\n      down = texture.readPixels(3);\n    }\n\n    var front = texture.readPixels(4);\n    var back = texture.readPixels(5);\n    var gammaSpace = texture.gammaSpace; // Always read as RGBA.\n\n    var format = 5;\n    var type = 0;\n\n    if (texture.textureType == 1 || texture.textureType == 2) {\n      type = 1;\n    }\n\n    var cubeInfo = {\n      size: size,\n      right: right,\n      left: left,\n      up: up,\n      down: down,\n      front: front,\n      back: back,\n      format: format,\n      type: type,\n      gammaSpace: gammaSpace\n    };\n    return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);\n  };\n  /**\r\n   * Converts a cubemap to the according Spherical Polynomial data.\r\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n   *\r\n   * @param cubeInfo The Cube map to extract the information from.\r\n   * @return The Spherical Polynomial data.\r\n   */\n\n\n  CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial = function (cubeInfo) {\n    var sphericalHarmonics = new SphericalHarmonics();\n    var totalSolidAngle = 0.0; // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n\n    var du = 2.0 / cubeInfo.size;\n    var dv = du; // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n\n    var minUV = du * 0.5 - 1.0;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var fileFace = this.FileFaces[faceIndex];\n      var dataArray = cubeInfo[fileFace.name];\n      var v = minUV; // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n      // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n      // Because SP is still linear, so summation is fine in that basis.\n\n      var stride = cubeInfo.format === 5 ? 4 : 3;\n\n      for (var y = 0; y < cubeInfo.size; y++) {\n        var u = minUV;\n\n        for (var x = 0; x < cubeInfo.size; x++) {\n          // World direction (not normalised)\n          var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n          worldDirection.normalize();\n          var deltaSolidAngle = Math.pow(1.0 + u * u + v * v, -3.0 / 2.0);\n          var r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n          var g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n          var b = dataArray[y * cubeInfo.size * stride + x * stride + 2]; // Prevent NaN harmonics with extreme HDRI data.\n\n          if (isNaN(r)) {\n            r = 0;\n          }\n\n          if (isNaN(g)) {\n            g = 0;\n          }\n\n          if (isNaN(b)) {\n            b = 0;\n          } // Handle Integer types.\n\n\n          if (cubeInfo.type === 0) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n          } // Handle Gamma space textures.\n\n\n          if (cubeInfo.gammaSpace) {\n            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n          } // Prevent to explode in case of really high dynamic ranges.\n          // sh 3 would not be enough to accurately represent it.\n\n\n          var max = 4096;\n          r = Scalar.Clamp(r, 0, max);\n          g = Scalar.Clamp(g, 0, max);\n          b = Scalar.Clamp(b, 0, max);\n          var color = new Color3(r, g, b);\n          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n          totalSolidAngle += deltaSolidAngle;\n          u += du;\n        }\n\n        v += dv;\n      }\n    } // Solid angle for entire sphere is 4*pi\n\n\n    var sphereSolidAngle = 4.0 * Math.PI; // Adjust the solid angle to allow for how many faces we processed.\n\n    var facesProcessed = 6.0;\n    var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0; // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n    // This is needed because the numerical integration over the cube uses a\n    // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n    // and also to compensate for accumulative error due to float precision in the summation.\n\n    var correctionFactor = expectedSolidAngle / totalSolidAngle;\n    sphericalHarmonics.scaleInPlace(correctionFactor);\n    sphericalHarmonics.convertIncidentRadianceToIrradiance();\n    sphericalHarmonics.convertIrradianceToLambertianRadiance();\n    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n  };\n\n  CubeMapToSphericalPolynomialTools.FileFaces = [new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)) // -Z bottom\n  ];\n  return CubeMapToSphericalPolynomialTools;\n}();\n\nexport { CubeMapToSphericalPolynomialTools };","map":{"version":3,"sources":["../../../../sourceES6/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"../../types\";\r\n\r\nimport { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from '../../Maths/math.constants';\r\nimport { Color3 } from '../../Maths/math.color';\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n\r\n    private static FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))// -Z bottom\r\n    ];\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture) {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        var size = texture.getSize().width;\r\n        var right = texture.readPixels(0);\r\n        var left = texture.readPixels(1);\r\n\r\n        var up: Nullable<ArrayBufferView>;\r\n        var down: Nullable<ArrayBufferView>;\r\n        if (texture.isRenderTarget) {\r\n            up = texture.readPixels(3);\r\n            down = texture.readPixels(2);\r\n        }\r\n        else {\r\n            up = texture.readPixels(2);\r\n            down = texture.readPixels(3);\r\n        }\r\n\r\n        var front = texture.readPixels(4);\r\n        var back = texture.readPixels(5);\r\n\r\n        var gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        var format = 5;\r\n        var type = 0;\r\n        if (texture.textureType == 1 || texture.textureType == 2) {\r\n            type = 1;\r\n        }\r\n\r\n        var cubeInfo: CubeMapInfo = {\r\n            size,\r\n            right,\r\n            left,\r\n            up,\r\n            down,\r\n            front,\r\n            back,\r\n            format,\r\n            type,\r\n            gammaSpace,\r\n        };\r\n\r\n        return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @return The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        var sphericalHarmonics = new SphericalHarmonics();\r\n        var totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        var du = 2.0 / cubeInfo.size;\r\n        var dv = du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        var minUV = du * 0.5 - 1.0;\r\n\r\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            var fileFace = this.FileFaces[faceIndex];\r\n            var dataArray = (<any>cubeInfo)[fileFace.name];\r\n            var v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === 5 ? 4 : 3;\r\n            for (var y = 0; y < cubeInfo.size; y++) {\r\n                var u = minUV;\r\n\r\n                for (var x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    var worldDirection =\r\n                        fileFace.worldAxisForFileX.scale(u).add(\r\n                            fileFace.worldAxisForFileY.scale(v)).add(\r\n                                fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    var deltaSolidAngle = Math.pow(1.0 + u * u + v * v, -3.0 / 2.0);\r\n\r\n                    var r = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 0];\r\n                    var g = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 1];\r\n                    var b = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) { r = 0; }\r\n                    if (isNaN(g)) { g = 0; }\r\n                    if (isNaN(b)) { b = 0; }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === 0) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = 4096;\r\n                    r = Scalar.Clamp(r, 0, max);\r\n                    g = Scalar.Clamp(g, 0, max);\r\n                    b = Scalar.Clamp(b, 0, max);\r\n\r\n                    var color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        var sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        var facesProcessed = 6.0;\r\n        var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        var correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}