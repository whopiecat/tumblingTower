{"ast":null,"code":"import { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateSphere = function (options) {\n  var segments = options.segments || 32;\n  var diameterX = options.diameterX || options.diameter || 1;\n  var diameterY = options.diameterY || options.diameter || 1;\n  var diameterZ = options.diameterZ || options.diameter || 1;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n  var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n  var totalZRotationSteps = 2 + segments;\n  var totalYRotationSteps = 2 * totalZRotationSteps;\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n\n  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    var normalizedZ = zRotationStep / totalZRotationSteps;\n    var angleZ = normalizedZ * Math.PI * slice;\n\n    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      var normalizedY = yRotationStep / totalYRotationSteps;\n      var angleY = normalizedY * Math.PI * 2 * arc;\n      var rotationZ = Matrix.RotationZ(-angleZ);\n      var rotationY = Matrix.RotationY(angleY);\n      var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n      var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n      var vertex = complete.multiply(radius);\n      var normal = complete.divide(radius).normalize();\n      positions.push(vertex.x, vertex.y, vertex.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(normalizedY, normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      var verticesCount = positions.length / 3;\n\n      for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        if (dedupTopBottomIndices) {\n          if (zRotationStep > 1) {\n            indices.push(firstIndex);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 1);\n          }\n\n          if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n            indices.push(firstIndex + totalYRotationSteps + 1);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 2);\n          }\n        } else {\n          indices.push(firstIndex);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 2);\n        }\n      }\n    }\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\n  var options = {\n    segments: segments,\n    diameterX: diameter,\n    diameterY: diameter,\n    diameterZ: diameter,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return SphereBuilder.CreateSphere(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar SphereBuilder =\n/** @class */\nfunction () {\n  function SphereBuilder() {}\n  /**\r\n   * Creates a sphere mesh\r\n   * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n   * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n   * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n   * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n   * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the sphere mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n   */\n\n\n  SphereBuilder.CreateSphere = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateSphere(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n  };\n\n  return SphereBuilder;\n}();\n\nexport { SphereBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/sphereBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from '../../types';\r\n\r\nVertexData.CreateSphere = function(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, dedupTopBottomIndices?: boolean }): VertexData {\r\n    var segments: number = options.segments || 32;\r\n    var diameterX: number = options.diameterX || options.diameter || 1;\r\n    var diameterY: number = options.diameterY || options.diameter || 1;\r\n    var diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice: number = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            var rotationZ = Matrix.RotationZ(-angleZ);\r\n            var rotationY = Matrix.RotationY(angleY);\r\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push((firstIndex));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push((firstIndex + totalYRotationSteps + 1));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push((firstIndex + totalYRotationSteps + 2));\r\n                    }\r\n                }\r\n                else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class SphereBuilder {\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    public static CreateSphere(name: string, options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var sphere = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateSphere(options);\r\n\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n        return sphere;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}