{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Color4 } from '../Maths/math.color';\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Material } from \"../Materials/material\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/glowMapGeneration.fragment\";\nimport \"../Shaders/glowMapGeneration.vertex\";\nimport { _DevTools } from '../Misc/devTools';\nimport { EffectFallbacks } from '../Materials/effectFallbacks';\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or higlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\n\nvar EffectLayer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new effect Layer and references it in the scene.\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   */\n  function EffectLayer(\n  /** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\n\n    this.neutralColor = new Color4();\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\n\n    this.isEnabled = true;\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\n\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\n\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\n\n    this.onBeforeComposeObservable = new Observable();\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\n\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\n\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\n\n    this.onAfterComposeObservable = new Observable();\n    /**\r\n     * An event triggered when the efffect layer changes its size.\r\n     */\n\n    this.onSizeChangedObservable = new Observable();\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    EffectLayer._SceneComponentInitialization(this._scene);\n\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n\n    this._scene.effectLayers.push(this); // Generate Buffers\n\n\n    this._generateIndexBuffer();\n\n    this._generateVertexBuffer();\n  }\n\n  Object.defineProperty(EffectLayer.prototype, \"camera\", {\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\n    get: function () {\n      return this._effectLayerOptions.camera;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EffectLayer.prototype, \"renderingGroupId\", {\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\n    get: function () {\n      return this._effectLayerOptions.renderingGroupId;\n    },\n    set: function (renderingGroupId) {\n      this._effectLayerOptions.renderingGroupId = renderingGroupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the effect layer with the required options.\r\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n   */\n\n  EffectLayer.prototype._init = function (options) {\n    // Adapt options\n    this._effectLayerOptions = __assign({\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options);\n\n    this._setMainTextureSize();\n\n    this._createMainTexture();\n\n    this._createTextureAndPostProcesses();\n\n    this._mergeEffect = this._createMergeEffect();\n  };\n  /**\r\n   * Generates the index buffer of the full screen quad blending to the main canvas.\r\n   */\n\n\n  EffectLayer.prototype._generateIndexBuffer = function () {\n    // Indices\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\r\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n   */\n\n\n  EffectLayer.prototype._generateVertexBuffer = function () {\n    // VBO\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  };\n  /**\r\n   * Sets the main texture desired size which is the closest power of two\r\n   * of the engine canvas size.\r\n   */\n\n\n  EffectLayer.prototype._setMainTextureSize = function () {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  };\n  /**\r\n   * Creates the main texture for the effect layer.\r\n   */\n\n\n  EffectLayer.prototype._createMainTexture = function () {\n    var _this = this;\n\n    this._mainTexture = new RenderTargetTexture(\"HighlightLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, 0);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true; // Custom render function\n\n    this._mainTexture.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);\n\n      var index;\n\n      var engine = _this._scene.getEngine();\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          _this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        _this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        _this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      var previousAlphaMode = engine.getAlphaMode();\n\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        _this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n\n      engine.setAlphaMode(previousAlphaMode);\n    };\n\n    this._mainTexture.onClearObservable.add(function (engine) {\n      engine.clear(_this.neutralColor, true, true, true);\n    });\n\n    var boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\n\n    this._mainTexture.onBeforeBindObservable.add(function () {\n      _this._scene.getBoundingBoxRenderer().enabled = !_this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\n    });\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      _this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\n    });\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  EffectLayer.prototype._addCustomEffectDefines = function (defines) {// Nothing to add by default.\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify whether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  EffectLayer.prototype._isReady = function (subMesh, useInstances, emissiveTexture) {\n    var material = subMesh.getMaterial();\n\n    if (!material) {\n      return false;\n    }\n\n    if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var mesh = subMesh.getMesh();\n    var uv1 = false;\n    var uv2 = false; // Diffuse\n\n    if (material) {\n      var needAlphaTest = material.needAlphaTesting();\n      var diffuseTexture = material.getAlphaTestTexture();\n      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n      }\n\n      var opacityTexture = material.opacityTexture;\n\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    } // Emissive\n\n\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n    } // Vertex\n\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    } // Bones\n\n\n    var fallbacks = new EffectFallbacks();\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      var skeleton = mesh.skeleton;\n\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var manager = mesh.morphTargetManager;\n    var morphInfluencers = 0;\n\n    if (manager) {\n      if (manager.numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        morphInfluencers = manager.numInfluencers;\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n\n    this._addCustomEffectDefines(defines); // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\"], [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      });\n    }\n\n    return this._effectLayerMapGenerationEffect.isReady();\n  };\n  /**\r\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n   */\n\n\n  EffectLayer.prototype.render = function () {\n    var currentEffect = this._mergeEffect; // Check\n\n    if (!currentEffect.isReady()) {\n      return;\n    }\n\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n\n    var engine = this._scene.getEngine();\n\n    this.onBeforeComposeObservable.notifyObservers(this); // Render\n\n    engine.enableEffect(currentEffect);\n    engine.setState(false); // VBOs\n\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect); // Cache\n\n    var previousAlphaMode = engine.getAlphaMode(); // Go Blend.\n\n    engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode); // Blends the map on the main canvas.\n\n    this._internalRender(currentEffect); // Restore Alpha\n\n\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this); // Handle size changes.\n\n    var size = this._mainTexture.getSize();\n\n    this._setMainTextureSize();\n\n    if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n\n      this._disposeTextureAndPostProcesses();\n\n      this._createMainTexture();\n\n      this._createTextureAndPostProcesses();\n    }\n  };\n  /**\r\n   * Determine if a given mesh will be used in the current effect.\r\n   * @param mesh mesh to test\r\n   * @returns true if the mesh will be used\r\n   */\n\n\n  EffectLayer.prototype.hasMesh = function (mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the layer contains information to display, otherwise false.\r\n   * @returns true if the glow layer should be rendered\r\n   */\n\n\n  EffectLayer.prototype.shouldRender = function () {\n    return this.isEnabled && this._shouldRender;\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  EffectLayer.prototype._shouldRenderMesh = function (mesh) {\n    return true;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  EffectLayer.prototype._canRenderMesh = function (mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  EffectLayer.prototype._shouldRenderEmissiveTextureForMesh = function () {\n    return true;\n  };\n  /**\r\n   * Renders the submesh passed in parameter to the generation map.\r\n   */\n\n\n  EffectLayer.prototype._renderSubMesh = function (subMesh, enableAlphaMode) {\n    var _this = this;\n\n    var _a;\n\n    if (enableAlphaMode === void 0) {\n      enableAlphaMode = false;\n    }\n\n    if (!this.shouldRender()) {\n      return;\n    }\n\n    var material = subMesh.getMaterial();\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = subMesh.getReplacementMesh();\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = subMesh.getEffectiveMesh();\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n    if (!material) {\n      return;\n    } // Do not block in blend mode.\n\n\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    } // Culling\n\n\n    var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n\n    var mainDeterminant = renderingMesh._getWorldMatrixDeterminant();\n\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n\n    var reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse); // Managing instances\n\n    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n\n    if (batch.mustReturn) {\n      return;\n    } // Early Exit per mesh\n\n\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n\n    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      engine.enableEffect(this._effectLayerMapGenerationEffect);\n\n      renderingMesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);\n\n      this._effectLayerMapGenerationEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n      this._effectLayerMapGenerationEffect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n\n      this._effectLayerMapGenerationEffect.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n\n      var needAlphaTest = material.needAlphaTesting();\n      var diffuseTexture = material.getAlphaTestTexture();\n      var needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        this._effectLayerMapGenerationEffect.setTexture(\"diffuseSampler\", diffuseTexture);\n\n        var textureMatrix = diffuseTexture.getTextureMatrix();\n\n        if (textureMatrix) {\n          this._effectLayerMapGenerationEffect.setMatrix(\"diffuseMatrix\", textureMatrix);\n        }\n      }\n\n      var opacityTexture = material.opacityTexture;\n\n      if (opacityTexture) {\n        this._effectLayerMapGenerationEffect.setTexture(\"opacitySampler\", opacityTexture);\n\n        this._effectLayerMapGenerationEffect.setFloat(\"opacityIntensity\", opacityTexture.level);\n\n        var textureMatrix = opacityTexture.getTextureMatrix();\n\n        if (textureMatrix) {\n          this._effectLayerMapGenerationEffect.setMatrix(\"opacityMatrix\", textureMatrix);\n        }\n      } // Glow emissive only\n\n\n      if (this._emissiveTextureAndColor.texture) {\n        this._effectLayerMapGenerationEffect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n\n        this._effectLayerMapGenerationEffect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n      } // Bones\n\n\n      if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n        var skeleton = renderingMesh.skeleton;\n\n        if (skeleton.isUsingTextureForMatrices) {\n          var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n\n          if (!boneTexture) {\n            return;\n          }\n\n          this._effectLayerMapGenerationEffect.setTexture(\"boneSampler\", boneTexture);\n\n          this._effectLayerMapGenerationEffect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n        } else {\n          this._effectLayerMapGenerationEffect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n        }\n      } // Morph targets\n\n\n      MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effectLayerMapGenerationEffect); // Alpha mode\n\n      if (enableAlphaMode) {\n        engine.setAlphaMode(material.alphaMode);\n      } // Draw\n\n\n      renderingMesh._processRendering(effectiveMesh, subMesh, this._effectLayerMapGenerationEffect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n        return _this._effectLayerMapGenerationEffect.setMatrix(\"world\", world);\n      });\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  };\n  /**\r\n   * Defines whether the current material of the mesh should be use to render the effect.\r\n   * @param mesh defines the current mesh to render\r\n   */\n\n\n  EffectLayer.prototype._useMeshMaterial = function (mesh) {\n    return false;\n  };\n  /**\r\n   * Rebuild the required buffers.\r\n   * @hidden Internal use only.\r\n   */\n\n\n  EffectLayer.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._generateIndexBuffer();\n  };\n  /**\r\n   * Dispose only the render target textures and post process.\r\n   */\n\n\n  EffectLayer.prototype._disposeTextureAndPostProcesses = function () {\n    this._mainTexture.dispose();\n\n    for (var i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n\n    this._postProcesses = [];\n\n    for (var i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n\n    this._textures = [];\n  };\n  /**\r\n   * Dispose the highlight layer and free resources.\r\n   */\n\n\n  EffectLayer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    } // Clean textures and post processes\n\n\n    this._disposeTextureAndPostProcesses(); // Remove from scene\n\n\n    var index = this._scene.effectLayers.indexOf(this, 0);\n\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  EffectLayer.prototype.getClassName = function () {\n    return \"EffectLayer\";\n  };\n  /**\r\n   * Creates an effect layer from parsed effect layer data\r\n   * @param parsedEffectLayer defines effect layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the effect layer information\r\n   * @returns a parsed effect Layer\r\n   */\n\n\n  EffectLayer.Parse = function (parsedEffectLayer, scene, rootUrl) {\n    var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  };\n  /** @hidden */\n\n\n  EffectLayer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"EffectLayerSceneComponent\");\n  };\n\n  __decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n\n  __decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n\n  __decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n\n  __decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n\n  __decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);\n\n  return EffectLayer;\n}();\n\nexport { EffectLayer };","map":{"version":3,"sources":["../../../sourceES6/core/Layers/effectLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from '../Maths/math.color';\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { EffectFallbacks } from '../Materials/effectFallbacks';\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or higlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _cachedDefines: string;\r\n    private _effectLayerMapGenerationEffect: Effect;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeEffect: Effect;\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>, color: Color4 } = { texture: null, color: new Color4() };\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the efffect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"EffectLayerSceneComponent\");\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene: Scene) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or nood the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected abstract _internalRender(effect: Effect): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: 2,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n        this._mergeEffect = this._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        var vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        }\r\n        else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\"HighlightLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            0);\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            var index: number;\r\n\r\n            let engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n        this._mainTexture.onBeforeBindObservable.add(() => {\r\n            this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n        });\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        let material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (!material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\r\n            return false;\r\n        }\r\n\r\n        var defines: string[] = [];\r\n\r\n        var attribs = [VertexBuffer.PositionKind];\r\n\r\n        var mesh = subMesh.getMesh();\r\n        var uv1 = false;\r\n        var uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&\r\n                ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                    diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                }\r\n                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n            }\r\n\r\n            var opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                    opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                }\r\n                else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) &&\r\n                emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            }\r\n            else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            let skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? (skeleton.bones.length + 1) : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        var manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\",\r\n                    \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\",\r\n                    \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\"],\r\n                [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\"], join,\r\n                fallbacks, undefined, undefined, { maxSimultaneousMorphTargets: morphInfluencers });\r\n        }\r\n\r\n        return this._effectLayerMapGenerationEffect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        var currentEffect = this._mergeEffect;\r\n\r\n        // Check\r\n        if (!currentEffect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(currentEffect);\r\n        engine.setState(false);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Cache\r\n        var previousAlphaMode = engine.getAlphaMode();\r\n\r\n        // Go Blend.\r\n        engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n        // Blends the map on the main canvas.\r\n        this._internalRender(currentEffect);\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        var size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        var material = subMesh.getMaterial();\r\n        var ownerMesh = subMesh.getMesh();\r\n        var replacementMesh = subMesh.getReplacementMesh();\r\n        var renderingMesh = subMesh.getRenderingMesh();\r\n        var effectiveMesh = subMesh.getEffectiveMesh();\r\n        var scene = this._scene;\r\n        var engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = renderingMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = (sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation);\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse);\r\n\r\n        // Managing instances\r\n        var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, hardwareInstancedRendering, replacementMesh || undefined);\r\n        }\r\n        else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            engine.enableEffect(this._effectLayerMapGenerationEffect);\r\n            renderingMesh._bind(subMesh, this._effectLayerMapGenerationEffect, Material.TriangleFillMode);\r\n\r\n            this._effectLayerMapGenerationEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n            this._effectLayerMapGenerationEffect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n\r\n            this._effectLayerMapGenerationEffect.setFloat4(\"glowColor\",\r\n                this._emissiveTextureAndColor.color.r,\r\n                this._emissiveTextureAndColor.color.g,\r\n                this._emissiveTextureAndColor.color.b,\r\n                this._emissiveTextureAndColor.color.a);\r\n\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha &&\r\n                ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                if (textureMatrix) {\r\n                    this._effectLayerMapGenerationEffect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"opacitySampler\", opacityTexture);\r\n                this._effectLayerMapGenerationEffect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                const textureMatrix = opacityTexture.getTextureMatrix();\r\n                if (textureMatrix) {\r\n                    this._effectLayerMapGenerationEffect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                }\r\n            }\r\n\r\n            // Glow emissive only\r\n            if (this._emissiveTextureAndColor.texture) {\r\n                this._effectLayerMapGenerationEffect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                this._effectLayerMapGenerationEffect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n            }\r\n\r\n            // Bones\r\n            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                const skeleton = renderingMesh.skeleton;\r\n\r\n                if (skeleton.isUsingTextureForMatrices) {\r\n                    const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                    if (!boneTexture) {\r\n                        return;\r\n                    }\r\n\r\n                    this._effectLayerMapGenerationEffect.setTexture(\"boneSampler\", boneTexture);\r\n                    this._effectLayerMapGenerationEffect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                } else {\r\n                    this._effectLayerMapGenerationEffect.setMatrices(\"mBones\", skeleton.getTransformMatrices((renderingMesh)));\r\n                }\r\n            }\r\n\r\n            // Morph targets\r\n            MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effectLayerMapGenerationEffect);\r\n\r\n            // Alpha mode\r\n            if (enableAlphaMode) {\r\n                engine.setAlphaMode(material.alphaMode);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, this._effectLayerMapGenerationEffect, material.fillMode, batch, hardwareInstancedRendering,\r\n                (isInstance, world) => this._effectLayerMapGenerationEffect.setMatrix(\"world\", world));\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (var i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (var i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        var index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n      * Gets the class name of the effect layer\r\n      * @returns the string with the class name of the effect layer\r\n      */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        var effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}