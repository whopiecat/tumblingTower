{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SceneLoader } from \"../Loading/sceneLoader\";\nimport { Tools } from \"./tools\";\nimport { Observable } from \"./observable\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { CubeTexture } from \"../Materials/Textures/cubeTexture\";\nimport { HDRCubeTexture } from \"../Materials/Textures/hdrCubeTexture\";\nimport { EquiRectangularCubeTexture } from \"../Materials/Textures/equiRectangularCubeTexture\";\nimport { Logger } from \"../Misc/logger\";\n/**\r\n * Defines the list of states available for a task inside a AssetsManager\r\n */\n\nexport var AssetTaskState;\n\n(function (AssetTaskState) {\n  /**\r\n   * Initialization\r\n   */\n  AssetTaskState[AssetTaskState[\"INIT\"] = 0] = \"INIT\";\n  /**\r\n   * Running\r\n   */\n\n  AssetTaskState[AssetTaskState[\"RUNNING\"] = 1] = \"RUNNING\";\n  /**\r\n   * Done\r\n   */\n\n  AssetTaskState[AssetTaskState[\"DONE\"] = 2] = \"DONE\";\n  /**\r\n   * Error\r\n   */\n\n  AssetTaskState[AssetTaskState[\"ERROR\"] = 3] = \"ERROR\";\n})(AssetTaskState || (AssetTaskState = {}));\n/**\r\n * Define an abstract asset task used with a AssetsManager class to load assets into a scene\r\n */\n\n\nvar AbstractAssetTask =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new AssetsManager\r\n   * @param name defines the name of the task\r\n   */\n  function AbstractAssetTask(\n  /**\r\n   * Task name\r\n   */\n  name) {\n    this.name = name;\n    this._isCompleted = false;\n    this._taskState = AssetTaskState.INIT;\n  }\n\n  Object.defineProperty(AbstractAssetTask.prototype, \"isCompleted\", {\n    /**\r\n     * Get if the task is completed\r\n     */\n    get: function () {\n      return this._isCompleted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractAssetTask.prototype, \"taskState\", {\n    /**\r\n     * Gets the current state of the task\r\n     */\n    get: function () {\n      return this._taskState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractAssetTask.prototype, \"errorObject\", {\n    /**\r\n     * Gets the current error object (if task is in error)\r\n     */\n    get: function () {\n      return this._errorObject;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Internal only\r\n   * @hidden\r\n   */\n\n  AbstractAssetTask.prototype._setErrorObject = function (message, exception) {\n    if (this._errorObject) {\n      return;\n    }\n\n    this._errorObject = {\n      message: message,\n      exception: exception\n    };\n  };\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  AbstractAssetTask.prototype.run = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    this._taskState = AssetTaskState.RUNNING;\n    this.runTask(scene, function () {\n      _this.onDoneCallback(onSuccess, onError);\n    }, function (msg, exception) {\n      _this.onErrorCallback(onError, msg, exception);\n    });\n  };\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  AbstractAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    throw new Error(\"runTask is not implemented\");\n  };\n  /**\r\n   * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.\r\n   * This can be used with failed tasks that have the reason for failure fixed.\r\n   */\n\n\n  AbstractAssetTask.prototype.reset = function () {\n    this._taskState = AssetTaskState.INIT;\n  };\n\n  AbstractAssetTask.prototype.onErrorCallback = function (onError, message, exception) {\n    this._taskState = AssetTaskState.ERROR;\n    this._errorObject = {\n      message: message,\n      exception: exception\n    };\n\n    if (this.onError) {\n      this.onError(this, message, exception);\n    }\n\n    onError();\n  };\n\n  AbstractAssetTask.prototype.onDoneCallback = function (onSuccess, onError) {\n    try {\n      this._taskState = AssetTaskState.DONE;\n      this._isCompleted = true;\n\n      if (this.onSuccess) {\n        this.onSuccess(this);\n      }\n\n      onSuccess();\n    } catch (e) {\n      this.onErrorCallback(onError, \"Task is done, error executing success callback(s)\", e);\n    }\n  };\n\n  return AbstractAssetTask;\n}();\n\nexport { AbstractAssetTask };\n/**\r\n * Class used to share progress information about assets loading\r\n */\n\nvar AssetsProgressEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a AssetsProgressEvent\r\n   * @param remainingCount defines the number of remaining tasks to process\r\n   * @param totalCount defines the total number of tasks\r\n   * @param task defines the task that was just processed\r\n   */\n  function AssetsProgressEvent(remainingCount, totalCount, task) {\n    this.remainingCount = remainingCount;\n    this.totalCount = totalCount;\n    this.task = task;\n  }\n\n  return AssetsProgressEvent;\n}();\n\nexport { AssetsProgressEvent };\n/**\r\n * Define a task used by AssetsManager to load assets into a container\r\n */\n\nvar ContainerAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(ContainerAssetTask, _super);\n  /**\r\n   * Creates a new ContainerAssetTask\r\n   * @param name defines the name of the task\r\n   * @param meshesNames defines the list of mesh's names you want to load\r\n   * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\r\n   * @param sceneFilename defines the filename or File of the scene to load from\r\n   */\n\n\n  function ContainerAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the list of mesh's names you want to load\r\n   */\n  meshesNames,\n  /**\r\n   * Defines the root url to use as a base to load your meshes and associated resources\r\n   */\n  rootUrl,\n  /**\r\n   * Defines the filename or File of the scene to load from\r\n   */\n  sceneFilename) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.meshesNames = meshesNames;\n    _this.rootUrl = rootUrl;\n    _this.sceneFilename = sceneFilename;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  ContainerAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    SceneLoader.LoadAssetContainer(this.rootUrl, this.sceneFilename, scene, function (container) {\n      _this.loadedContainer = container;\n      _this.loadedMeshes = container.meshes;\n      _this.loadedParticleSystems = container.particleSystems;\n      _this.loadedSkeletons = container.skeletons;\n      _this.loadedAnimationGroups = container.animationGroups;\n      onSuccess();\n    }, null, function (scene, message, exception) {\n      onError(message, exception);\n    });\n  };\n\n  return ContainerAssetTask;\n}(AbstractAssetTask);\n\nexport { ContainerAssetTask };\n/**\r\n * Define a task used by AssetsManager to load meshes\r\n */\n\nvar MeshAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(MeshAssetTask, _super);\n  /**\r\n   * Creates a new MeshAssetTask\r\n   * @param name defines the name of the task\r\n   * @param meshesNames defines the list of mesh's names you want to load\r\n   * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\r\n   * @param sceneFilename defines the filename or File of the scene to load from\r\n   */\n\n\n  function MeshAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the list of mesh's names you want to load\r\n   */\n  meshesNames,\n  /**\r\n   * Defines the root url to use as a base to load your meshes and associated resources\r\n   */\n  rootUrl,\n  /**\r\n   * Defines the filename or File of the scene to load from\r\n   */\n  sceneFilename) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.meshesNames = meshesNames;\n    _this.rootUrl = rootUrl;\n    _this.sceneFilename = sceneFilename;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  MeshAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups) {\n      _this.loadedMeshes = meshes;\n      _this.loadedParticleSystems = particleSystems;\n      _this.loadedSkeletons = skeletons;\n      _this.loadedAnimationGroups = animationGroups;\n      onSuccess();\n    }, null, function (scene, message, exception) {\n      onError(message, exception);\n    });\n  };\n\n  return MeshAssetTask;\n}(AbstractAssetTask);\n\nexport { MeshAssetTask };\n/**\r\n * Define a task used by AssetsManager to load text content\r\n */\n\nvar TextFileAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(TextFileAssetTask, _super);\n  /**\r\n   * Creates a new TextFileAssetTask object\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the file to load\r\n   */\n\n\n  function TextFileAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the file to load\r\n   */\n  url) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  TextFileAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    scene._loadFile(this.url, function (data) {\n      _this.text = data;\n      onSuccess();\n    }, undefined, false, false, function (request, exception) {\n      if (request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    });\n  };\n\n  return TextFileAssetTask;\n}(AbstractAssetTask);\n\nexport { TextFileAssetTask };\n/**\r\n * Define a task used by AssetsManager to load binary data\r\n */\n\nvar BinaryFileAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(BinaryFileAssetTask, _super);\n  /**\r\n   * Creates a new BinaryFileAssetTask object\r\n   * @param name defines the name of the new task\r\n   * @param url defines the location of the file to load\r\n   */\n\n\n  function BinaryFileAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the file to load\r\n   */\n  url) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  BinaryFileAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    scene._loadFile(this.url, function (data) {\n      _this.data = data;\n      onSuccess();\n    }, undefined, true, true, function (request, exception) {\n      if (request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    });\n  };\n\n  return BinaryFileAssetTask;\n}(AbstractAssetTask);\n\nexport { BinaryFileAssetTask };\n/**\r\n * Define a task used by AssetsManager to load images\r\n */\n\nvar ImageAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(ImageAssetTask, _super);\n  /**\r\n   * Creates a new ImageAssetTask\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the image to load\r\n   */\n\n\n  function ImageAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the image to load\r\n   */\n  url) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  ImageAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var _this = this;\n\n    var img = new Image();\n    Tools.SetCorsBehavior(this.url, img);\n\n    img.onload = function () {\n      _this.image = img;\n      onSuccess();\n    };\n\n    img.onerror = function (err) {\n      onError(\"Error loading image\", err);\n    };\n\n    img.src = this.url;\n  };\n\n  return ImageAssetTask;\n}(AbstractAssetTask);\n\nexport { ImageAssetTask };\n/**\r\n * Define a task used by AssetsManager to load 2D textures\r\n */\n\nvar TextureAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(TextureAssetTask, _super);\n  /**\r\n   * Creates a new TextureAssetTask object\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the file to load\r\n   * @param noMipmap defines if mipmap should not be generated (default is false)\r\n   * @param invertY defines if texture must be inverted on Y axis (default is true)\r\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n   */\n\n\n  function TextureAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the file to load\r\n   */\n  url,\n  /**\r\n   * Defines if mipmap should not be generated (default is false)\r\n   */\n  noMipmap,\n  /**\r\n   * Defines if texture must be inverted on Y axis (default is true)\r\n   */\n  invertY,\n  /**\r\n   * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n   */\n  samplingMode) {\n    if (invertY === void 0) {\n      invertY = true;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    _this.noMipmap = noMipmap;\n    _this.invertY = invertY;\n    _this.samplingMode = samplingMode;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  TextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var onload = function () {\n      onSuccess();\n    };\n\n    var onerror = function (message, exception) {\n      onError(message, exception);\n    };\n\n    this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);\n  };\n\n  return TextureAssetTask;\n}(AbstractAssetTask);\n\nexport { TextureAssetTask };\n/**\r\n * Define a task used by AssetsManager to load cube textures\r\n */\n\nvar CubeTextureAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(CubeTextureAssetTask, _super);\n  /**\r\n   * Creates a new CubeTextureAssetTask\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\r\n   * @param extensions defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\r\n   * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n   * @param files defines the explicit list of files (undefined by default)\r\n   */\n\n\n  function CubeTextureAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\r\n   */\n  url,\n  /**\r\n   * Defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\r\n   */\n  extensions,\n  /**\r\n   * Defines if mipmaps should not be generated (default is false)\r\n   */\n  noMipmap,\n  /**\r\n   * Defines the explicit list of files (undefined by default)\r\n   */\n  files) {\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    _this.extensions = extensions;\n    _this.noMipmap = noMipmap;\n    _this.files = files;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  CubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var onload = function () {\n      onSuccess();\n    };\n\n    var onerror = function (message, exception) {\n      onError(message, exception);\n    };\n\n    this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror);\n  };\n\n  return CubeTextureAssetTask;\n}(AbstractAssetTask);\n\nexport { CubeTextureAssetTask };\n/**\r\n * Define a task used by AssetsManager to load HDR cube textures\r\n */\n\nvar HDRCubeTextureAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(HDRCubeTextureAssetTask, _super);\n  /**\r\n   * Creates a new HDRCubeTextureAssetTask object\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the file to load\r\n   * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.\r\n   * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n   * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\r\n   * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n   * @param reserved Internal use only\r\n   */\n\n\n  function HDRCubeTextureAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the file to load\r\n   */\n  url,\n  /**\r\n   * Defines the desired size (the more it increases the longer the generation will be)\r\n   */\n  size,\n  /**\r\n   * Defines if mipmaps should not be generated (default is false)\r\n   */\n  noMipmap,\n  /**\r\n   * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\r\n   */\n  generateHarmonics,\n  /**\r\n   * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n   */\n  gammaSpace,\n  /**\r\n   * Internal Use Only\r\n   */\n  reserved) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (generateHarmonics === void 0) {\n      generateHarmonics = true;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = false;\n    }\n\n    if (reserved === void 0) {\n      reserved = false;\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    _this.size = size;\n    _this.noMipmap = noMipmap;\n    _this.generateHarmonics = generateHarmonics;\n    _this.gammaSpace = gammaSpace;\n    _this.reserved = reserved;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  HDRCubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var onload = function () {\n      onSuccess();\n    };\n\n    var onerror = function (message, exception) {\n      onError(message, exception);\n    };\n\n    this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);\n  };\n\n  return HDRCubeTextureAssetTask;\n}(AbstractAssetTask);\n\nexport { HDRCubeTextureAssetTask };\n/**\r\n * Define a task used by AssetsManager to load Equirectangular cube textures\r\n */\n\nvar EquiRectangularCubeTextureAssetTask =\n/** @class */\nfunction (_super) {\n  __extends(EquiRectangularCubeTextureAssetTask, _super);\n  /**\r\n   * Creates a new EquiRectangularCubeTextureAssetTask object\r\n   * @param name defines the name of the task\r\n   * @param url defines the location of the file to load\r\n   * @param size defines the desired size (the more it increases the longer the generation will be)\r\n   * If the size is omitted this implies you are using a preprocessed cubemap.\r\n   * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n   * @param gammaSpace specifies if the texture will be used in gamma or linear space\r\n   * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\r\n   * (default is true)\r\n   */\n\n\n  function EquiRectangularCubeTextureAssetTask(\n  /**\r\n   * Defines the name of the task\r\n   */\n  name,\n  /**\r\n   * Defines the location of the file to load\r\n   */\n  url,\n  /**\r\n   * Defines the desired size (the more it increases the longer the generation will be)\r\n   */\n  size,\n  /**\r\n   * Defines if mipmaps should not be generated (default is false)\r\n   */\n  noMipmap,\n  /**\r\n   * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,\r\n   * but the standard material would require them in Gamma space) (default is true)\r\n   */\n  gammaSpace) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = true;\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this.name = name;\n    _this.url = url;\n    _this.size = size;\n    _this.noMipmap = noMipmap;\n    _this.gammaSpace = gammaSpace;\n    return _this;\n  }\n  /**\r\n   * Execute the current task\r\n   * @param scene defines the scene where you want your assets to be loaded\r\n   * @param onSuccess is a callback called when the task is successfully executed\r\n   * @param onError is a callback called if an error occurs\r\n   */\n\n\n  EquiRectangularCubeTextureAssetTask.prototype.runTask = function (scene, onSuccess, onError) {\n    var onload = function () {\n      onSuccess();\n    };\n\n    var onerror = function (message, exception) {\n      onError(message, exception);\n    };\n\n    this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);\n  };\n\n  return EquiRectangularCubeTextureAssetTask;\n}(AbstractAssetTask);\n\nexport { EquiRectangularCubeTextureAssetTask };\n/**\r\n * This class can be used to easily import assets into a scene\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_assetsmanager\r\n */\n\nvar AssetsManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new AssetsManager\r\n   * @param scene defines the scene to work on\r\n   */\n  function AssetsManager(scene) {\n    this._isLoading = false;\n    this._tasks = new Array();\n    this._waitingTasksCount = 0;\n    this._totalTasksCount = 0;\n    /**\r\n     * Observable called when all tasks are processed\r\n     */\n\n    this.onTaskSuccessObservable = new Observable();\n    /**\r\n     * Observable called when a task had an error\r\n     */\n\n    this.onTaskErrorObservable = new Observable();\n    /**\r\n     * Observable called when all tasks were executed\r\n     */\n\n    this.onTasksDoneObservable = new Observable();\n    /**\r\n     * Observable called when a task is done (whatever the result is)\r\n     */\n\n    this.onProgressObservable = new Observable();\n    /**\r\n     * Gets or sets a boolean defining if the AssetsManager should use the default loading screen\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\n\n    this.useDefaultLoadingScreen = true;\n    /**\r\n     * Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen\r\n     * when all assets have been downloaded.\r\n     * If set to false, you need to manually call in hideLoadingUI() once your scene is ready.\r\n     */\n\n    this.autoHideLoadingUI = true;\n    this._scene = scene;\n  }\n  /**\r\n   * Add a ContainerAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param meshesNames defines the name of meshes to load\r\n   * @param rootUrl defines the root url to use to locate files\r\n   * @param sceneFilename defines the filename of the scene file\r\n   * @returns a new ContainerAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addContainerTask = function (taskName, meshesNames, rootUrl, sceneFilename) {\n    var task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a MeshAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param meshesNames defines the name of meshes to load\r\n   * @param rootUrl defines the root url to use to locate files\r\n   * @param sceneFilename defines the filename of the scene file\r\n   * @returns a new MeshAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addMeshTask = function (taskName, meshesNames, rootUrl, sceneFilename) {\n    var task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a TextFileAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @returns a new TextFileAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addTextFileTask = function (taskName, url) {\n    var task = new TextFileAssetTask(taskName, url);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a BinaryFileAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @returns a new BinaryFileAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addBinaryFileTask = function (taskName, url) {\n    var task = new BinaryFileAssetTask(taskName, url);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a ImageAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @returns a new ImageAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addImageTask = function (taskName, url) {\n    var task = new ImageAssetTask(taskName, url);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a TextureAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n   * @param invertY defines if you want to invert Y axis of the loaded texture (false by default)\r\n   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n   * @returns a new TextureAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addTextureTask = function (taskName, url, noMipmap, invertY, samplingMode) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    var task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Add a CubeTextureAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @param extensions defines the extension to use to load the cube map (can be null)\r\n   * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n   * @param files defines the list of files to load (can be null)\r\n   * @returns a new CubeTextureAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addCubeTextureTask = function (taskName, url, extensions, noMipmap, files) {\n    var task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   *\r\n   * Add a HDRCubeTextureAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @param size defines the size you want for the cubemap (can be null)\r\n   * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n   * @param generateHarmonics defines if you want to automatically generate (true by default)\r\n   * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n   * @param reserved Internal use only\r\n   * @returns a new HDRCubeTextureAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addHDRCubeTextureTask = function (taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (generateHarmonics === void 0) {\n      generateHarmonics = true;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = false;\n    }\n\n    if (reserved === void 0) {\n      reserved = false;\n    }\n\n    var task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   *\r\n   * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks\r\n   * @param taskName defines the name of the new task\r\n   * @param url defines the url of the file to load\r\n   * @param size defines the size you want for the cubemap (can be null)\r\n   * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n   * @returns a new EquiRectangularCubeTextureAssetTask object\r\n   */\n\n\n  AssetsManager.prototype.addEquiRectangularCubeTextureAssetTask = function (taskName, url, size, noMipmap, gammaSpace) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = true;\n    }\n\n    var task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);\n\n    this._tasks.push(task);\n\n    return task;\n  };\n  /**\r\n   * Remove a task from the assets manager.\r\n   * @param task the task to remove\r\n   */\n\n\n  AssetsManager.prototype.removeTask = function (task) {\n    var index = this._tasks.indexOf(task);\n\n    if (index > -1) {\n      this._tasks.splice(index, 1);\n    }\n  };\n\n  AssetsManager.prototype._decreaseWaitingTasksCount = function (task) {\n    this._waitingTasksCount--;\n\n    try {\n      if (this.onProgress) {\n        this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);\n      }\n\n      this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));\n    } catch (e) {\n      Logger.Error(\"Error running progress callbacks.\");\n      console.log(e);\n    }\n\n    if (this._waitingTasksCount === 0) {\n      try {\n        var currentTasks = this._tasks.slice();\n\n        if (this.onFinish) {\n          // Calling onFinish with immutable array of tasks\n          this.onFinish(currentTasks);\n        } // Let's remove successfull tasks\n\n\n        for (var _i = 0, currentTasks_1 = currentTasks; _i < currentTasks_1.length; _i++) {\n          var task = currentTasks_1[_i];\n\n          if (task.taskState === AssetTaskState.DONE) {\n            var index = this._tasks.indexOf(task);\n\n            if (index > -1) {\n              this._tasks.splice(index, 1);\n            }\n          }\n        }\n\n        this.onTasksDoneObservable.notifyObservers(this._tasks);\n      } catch (e) {\n        Logger.Error(\"Error running tasks-done callbacks.\");\n        console.log(e);\n      }\n\n      this._isLoading = false;\n\n      if (this.autoHideLoadingUI) {\n        this._scene.getEngine().hideLoadingUI();\n      }\n    }\n  };\n\n  AssetsManager.prototype._runTask = function (task) {\n    var _this = this;\n\n    var done = function () {\n      try {\n        if (_this.onTaskSuccess) {\n          _this.onTaskSuccess(task);\n        }\n\n        _this.onTaskSuccessObservable.notifyObservers(task);\n\n        _this._decreaseWaitingTasksCount(task);\n      } catch (e) {\n        error(\"Error executing task success callbacks\", e);\n      }\n    };\n\n    var error = function (message, exception) {\n      task._setErrorObject(message, exception);\n\n      if (_this.onTaskError) {\n        _this.onTaskError(task);\n      }\n\n      _this.onTaskErrorObservable.notifyObservers(task);\n\n      _this._decreaseWaitingTasksCount(task);\n    };\n\n    task.run(this._scene, done, error);\n  };\n  /**\r\n   * Reset the AssetsManager and remove all tasks\r\n   * @return the current instance of the AssetsManager\r\n   */\n\n\n  AssetsManager.prototype.reset = function () {\n    this._isLoading = false;\n    this._tasks = new Array();\n    return this;\n  };\n  /**\r\n   * Start the loading process\r\n   * @return the current instance of the AssetsManager\r\n   */\n\n\n  AssetsManager.prototype.load = function () {\n    if (this._isLoading) {\n      return this;\n    }\n\n    this._isLoading = true;\n    this._waitingTasksCount = this._tasks.length;\n    this._totalTasksCount = this._tasks.length;\n\n    if (this._waitingTasksCount === 0) {\n      this._isLoading = false;\n\n      if (this.onFinish) {\n        this.onFinish(this._tasks);\n      }\n\n      this.onTasksDoneObservable.notifyObservers(this._tasks);\n      return this;\n    }\n\n    if (this.useDefaultLoadingScreen) {\n      this._scene.getEngine().displayLoadingUI();\n    }\n\n    for (var index = 0; index < this._tasks.length; index++) {\n      var task = this._tasks[index];\n\n      if (task.taskState === AssetTaskState.INIT) {\n        this._runTask(task);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Start the loading process as an async operation\r\n   * @return a promise returning the list of failed tasks\r\n   */\n\n\n  AssetsManager.prototype.loadAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this._isLoading) {\n        resolve();\n        return;\n      }\n\n      _this.onTasksDoneObservable.addOnce(function (remainingTasks) {\n        if (remainingTasks && remainingTasks.length) {\n          reject(remainingTasks);\n        } else {\n          resolve();\n        }\n      });\n\n      _this.load();\n    });\n  };\n\n  return AssetsManager;\n}();\n\nexport { AssetsManager };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/assetsManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { SceneLoader } from \"../Loading/sceneLoader\";\r\nimport { Tools } from \"./tools\";\r\nimport { Observable } from \"./observable\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport { HDRCubeTexture } from \"../Materials/Textures/hdrCubeTexture\";\r\nimport { EquiRectangularCubeTexture } from \"../Materials/Textures/equiRectangularCubeTexture\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { AnimationGroup } from '../Animations/animationGroup';\r\nimport { AssetContainer } from \"../assetContainer\";\r\n\r\n/**\r\n * Defines the list of states available for a task inside a AssetsManager\r\n */\r\nexport enum AssetTaskState {\r\n    /**\r\n     * Initialization\r\n     */\r\n    INIT,\r\n    /**\r\n     * Running\r\n     */\r\n    RUNNING,\r\n    /**\r\n     * Done\r\n     */\r\n    DONE,\r\n    /**\r\n     * Error\r\n     */\r\n    ERROR\r\n}\r\n\r\n/**\r\n * Define an abstract asset task used with a AssetsManager class to load assets into a scene\r\n */\r\nexport abstract class AbstractAssetTask {\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: any) => void;\r\n\r\n    /**\r\n     * Callback called when the task is not successful\r\n     */\r\n    public onError: (task: any, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new AssetsManager\r\n     * @param name defines the name of the task\r\n     */\r\n    constructor(\r\n            /**\r\n             * Task name\r\n             */public name: string) {\r\n    }\r\n\r\n    private _isCompleted = false;\r\n    private _taskState = AssetTaskState.INIT;\r\n    private _errorObject: { message?: string; exception?: any; };\r\n\r\n    /**\r\n     * Get if the task is completed\r\n     */\r\n    public get isCompleted(): boolean {\r\n        return this._isCompleted;\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of the task\r\n     */\r\n    public get taskState(): AssetTaskState {\r\n        return this._taskState;\r\n    }\r\n\r\n    /**\r\n     * Gets the current error object (if task is in error)\r\n     */\r\n    public get errorObject(): { message?: string; exception?: any; } {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Internal only\r\n     * @hidden\r\n     */\r\n    public _setErrorObject(message?: string, exception?: any) {\r\n        if (this._errorObject) {\r\n            return;\r\n        }\r\n\r\n        this._errorObject = {\r\n            message: message,\r\n            exception: exception\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public run(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        this._taskState = AssetTaskState.RUNNING;\r\n        this.runTask(scene, () => {\r\n            this.onDoneCallback(onSuccess, onError);\r\n        }, (msg, exception) => {\r\n            this.onErrorCallback(onError, msg, exception);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        throw new Error(\"runTask is not implemented\");\r\n    }\r\n\r\n    /**\r\n     * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.\r\n     * This can be used with failed tasks that have the reason for failure fixed.\r\n     */\r\n    public reset() {\r\n        this._taskState = AssetTaskState.INIT;\r\n    }\r\n\r\n    private onErrorCallback(onError: (message?: string, exception?: any) => void, message?: string, exception?: any) {\r\n        this._taskState = AssetTaskState.ERROR;\r\n\r\n        this._errorObject = {\r\n            message: message,\r\n            exception: exception\r\n        };\r\n\r\n        if (this.onError) {\r\n            this.onError(this, message, exception);\r\n        }\r\n\r\n        onError();\r\n    }\r\n\r\n    private onDoneCallback(onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        try {\r\n            this._taskState = AssetTaskState.DONE;\r\n            this._isCompleted = true;\r\n\r\n            if (this.onSuccess) {\r\n                this.onSuccess(this);\r\n            }\r\n\r\n            onSuccess();\r\n        } catch (e) {\r\n            this.onErrorCallback(onError, \"Task is done, error executing success callback(s)\", e);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Define the interface used by progress events raised during assets loading\r\n */\r\nexport interface IAssetsProgressEvent {\r\n    /**\r\n     * Defines the number of remaining tasks to process\r\n     */\r\n    remainingCount: number;\r\n    /**\r\n     * Defines the total number of tasks\r\n     */\r\n    totalCount: number;\r\n    /**\r\n     * Defines the task that was just processed\r\n     */\r\n    task: AbstractAssetTask;\r\n}\r\n\r\n/**\r\n * Class used to share progress information about assets loading\r\n */\r\nexport class AssetsProgressEvent implements IAssetsProgressEvent {\r\n    /**\r\n     * Defines the number of remaining tasks to process\r\n     */\r\n    public remainingCount: number;\r\n    /**\r\n     * Defines the total number of tasks\r\n     */\r\n    public totalCount: number;\r\n    /**\r\n     * Defines the task that was just processed\r\n     */\r\n    public task: AbstractAssetTask;\r\n\r\n    /**\r\n     * Creates a AssetsProgressEvent\r\n     * @param remainingCount defines the number of remaining tasks to process\r\n     * @param totalCount defines the total number of tasks\r\n     * @param task defines the task that was just processed\r\n     */\r\n    constructor(remainingCount: number, totalCount: number, task: AbstractAssetTask) {\r\n        this.remainingCount = remainingCount;\r\n        this.totalCount = totalCount;\r\n        this.task = task;\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load assets into a container\r\n */\r\nexport class ContainerAssetTask extends AbstractAssetTask {\r\n    /**\r\n     * Get the loaded asset container\r\n     */\r\n    public loadedContainer: AssetContainer;\r\n    /**\r\n     * Gets the list of loaded meshes\r\n     */\r\n    public loadedMeshes: Array<AbstractMesh>;\r\n    /**\r\n     * Gets the list of loaded particle systems\r\n     */\r\n    public loadedParticleSystems: Array<IParticleSystem>;\r\n    /**\r\n     * Gets the list of loaded skeletons\r\n     */\r\n    public loadedSkeletons: Array<Skeleton>;\r\n    /**\r\n     * Gets the list of loaded animation groups\r\n     */\r\n    public loadedAnimationGroups: Array<AnimationGroup>;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: ContainerAssetTask) => void;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: ContainerAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new ContainerAssetTask\r\n     * @param name defines the name of the task\r\n     * @param meshesNames defines the list of mesh's names you want to load\r\n     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\r\n     * @param sceneFilename defines the filename or File of the scene to load from\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the list of mesh's names you want to load\r\n         */\r\n        public meshesNames: any,\r\n        /**\r\n         * Defines the root url to use as a base to load your meshes and associated resources\r\n         */\r\n        public rootUrl: string,\r\n        /**\r\n         * Defines the filename or File of the scene to load from\r\n         */\r\n        public sceneFilename: string | File) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        SceneLoader.LoadAssetContainer(this.rootUrl, this.sceneFilename, scene,\r\n            (container: AssetContainer) => {\r\n                this.loadedContainer = container;\r\n                this.loadedMeshes = container.meshes;\r\n                this.loadedParticleSystems = container.particleSystems;\r\n                this.loadedSkeletons = container.skeletons;\r\n                this.loadedAnimationGroups = container.animationGroups;\r\n                onSuccess();\r\n            }, null, (scene, message, exception) => {\r\n                onError(message, exception);\r\n            }\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load meshes\r\n */\r\nexport class MeshAssetTask extends AbstractAssetTask {\r\n    /**\r\n     * Gets the list of loaded meshes\r\n     */\r\n    public loadedMeshes: Array<AbstractMesh>;\r\n    /**\r\n     * Gets the list of loaded particle systems\r\n     */\r\n    public loadedParticleSystems: Array<IParticleSystem>;\r\n    /**\r\n     * Gets the list of loaded skeletons\r\n     */\r\n    public loadedSkeletons: Array<Skeleton>;\r\n    /**\r\n     * Gets the list of loaded animation groups\r\n     */\r\n    public loadedAnimationGroups: Array<AnimationGroup>;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: MeshAssetTask) => void;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: MeshAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new MeshAssetTask\r\n     * @param name defines the name of the task\r\n     * @param meshesNames defines the list of mesh's names you want to load\r\n     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources\r\n     * @param sceneFilename defines the filename or File of the scene to load from\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the list of mesh's names you want to load\r\n         */\r\n        public meshesNames: any,\r\n        /**\r\n         * Defines the root url to use as a base to load your meshes and associated resources\r\n         */\r\n        public rootUrl: string,\r\n        /**\r\n         * Defines the filename or File of the scene to load from\r\n         */\r\n        public sceneFilename: string | File) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene,\r\n            (meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[]) => {\r\n                this.loadedMeshes = meshes;\r\n                this.loadedParticleSystems = particleSystems;\r\n                this.loadedSkeletons = skeletons;\r\n                this.loadedAnimationGroups = animationGroups;\r\n                onSuccess();\r\n            }, null, (scene, message, exception) => {\r\n                onError(message, exception);\r\n            }\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load text content\r\n */\r\nexport class TextFileAssetTask extends AbstractAssetTask {\r\n    /**\r\n     * Gets the loaded text string\r\n     */\r\n    public text: string;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: TextFileAssetTask) => void;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: TextFileAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new TextFileAssetTask object\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the file to load\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the file to load\r\n         */\r\n        public url: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        scene._loadFile(this.url, (data) => {\r\n            this.text = data as string;\r\n            onSuccess();\r\n        }, undefined, false, false, (request, exception) => {\r\n            if (request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load binary data\r\n */\r\nexport class BinaryFileAssetTask extends AbstractAssetTask {\r\n    /**\r\n     * Gets the lodaded data (as an array buffer)\r\n     */\r\n    public data: ArrayBuffer;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: BinaryFileAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: BinaryFileAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new BinaryFileAssetTask object\r\n     * @param name defines the name of the new task\r\n     * @param url defines the location of the file to load\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the file to load\r\n         */\r\n        public url: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        scene._loadFile(this.url, (data) => {\r\n            this.data = data as ArrayBuffer;\r\n            onSuccess();\r\n        }, undefined, true, true, (request, exception) => {\r\n            if (request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load images\r\n */\r\nexport class ImageAssetTask extends AbstractAssetTask {\r\n    /**\r\n     * Gets the loaded images\r\n     */\r\n    public image: HTMLImageElement;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: ImageAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: ImageAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new ImageAssetTask\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the image to load\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the image to load\r\n         */\r\n        public url: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n        var img = new Image();\r\n\r\n        Tools.SetCorsBehavior(this.url, img);\r\n\r\n        img.onload = () => {\r\n            this.image = img;\r\n            onSuccess();\r\n        };\r\n\r\n        img.onerror = (err: string | Event): any => {\r\n            onError(\"Error loading image\", err);\r\n        };\r\n\r\n        img.src = this.url;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the interface used by texture loading tasks\r\n */\r\nexport interface ITextureAssetTask<TEX extends BaseTexture> {\r\n    /**\r\n     * Gets the loaded texture\r\n     */\r\n    texture: TEX;\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load 2D textures\r\n */\r\nexport class TextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<Texture> {\r\n    /**\r\n     * Gets the loaded texture\r\n     */\r\n    public texture: Texture;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: TextureAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: TextureAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new TextureAssetTask object\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the file to load\r\n     * @param noMipmap defines if mipmap should not be generated (default is false)\r\n     * @param invertY defines if texture must be inverted on Y axis (default is true)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the file to load\r\n         */\r\n        public url: string,\r\n        /**\r\n         * Defines if mipmap should not be generated (default is false)\r\n         */\r\n        public noMipmap?: boolean,\r\n        /**\r\n         * Defines if texture must be inverted on Y axis (default is true)\r\n         */\r\n        public invertY: boolean = true,\r\n        /**\r\n         * Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n         */\r\n        public samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n\r\n        var onload = () => {\r\n            onSuccess();\r\n        };\r\n\r\n        var onerror = (message?: string, exception?: any) => {\r\n            onError(message, exception);\r\n        };\r\n\r\n        this.texture = new Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load cube textures\r\n */\r\nexport class CubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<CubeTexture> {\r\n    /**\r\n     * Gets the loaded texture\r\n     */\r\n    public texture: CubeTexture;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: CubeTextureAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: CubeTextureAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new CubeTextureAssetTask\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\r\n     * @param extensions defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\r\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n     * @param files defines the explicit list of files (undefined by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)\r\n         */\r\n        public url: string,\r\n        /**\r\n         * Defines the extensions to use to load files ([\"_px\", \"_py\", \"_pz\", \"_nx\", \"_ny\", \"_nz\"] by default)\r\n         */\r\n        public extensions?: string[],\r\n        /**\r\n         * Defines if mipmaps should not be generated (default is false)\r\n         */\r\n        public noMipmap?: boolean,\r\n        /**\r\n         * Defines the explicit list of files (undefined by default)\r\n         */\r\n        public files?: string[]) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n\r\n        var onload = () => {\r\n            onSuccess();\r\n        };\r\n\r\n        var onerror = (message?: string, exception?: any) => {\r\n            onError(message, exception);\r\n        };\r\n\r\n        this.texture = new CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror);\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load HDR cube textures\r\n */\r\nexport class HDRCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<HDRCubeTexture> {\r\n    /**\r\n     * Gets the loaded texture\r\n     */\r\n    public texture: HDRCubeTexture;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: HDRCubeTextureAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new HDRCubeTextureAssetTask object\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the file to load\r\n     * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.\r\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n     * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\r\n     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n     * @param reserved Internal use only\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the file to load\r\n         */\r\n        public url: string,\r\n        /**\r\n         * Defines the desired size (the more it increases the longer the generation will be)\r\n         */\r\n        public size: number,\r\n        /**\r\n         * Defines if mipmaps should not be generated (default is false)\r\n         */\r\n        public noMipmap = false,\r\n        /**\r\n         * Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)\r\n         */\r\n        public generateHarmonics = true,\r\n        /**\r\n         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n         */\r\n        public gammaSpace = false,\r\n        /**\r\n         * Internal Use Only\r\n         */\r\n        public reserved = false) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void) {\r\n\r\n        var onload = () => {\r\n            onSuccess();\r\n        };\r\n\r\n        var onerror = (message?: string, exception?: any) => {\r\n            onError(message, exception);\r\n        };\r\n\r\n        this.texture = new HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, onload, onerror);\r\n    }\r\n}\r\n\r\n/**\r\n * Define a task used by AssetsManager to load Equirectangular cube textures\r\n */\r\nexport class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<EquiRectangularCubeTexture> {\r\n    /**\r\n     * Gets the loaded texture\r\n     */\r\n    public texture: EquiRectangularCubeTexture;\r\n\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onSuccess: (task: EquiRectangularCubeTextureAssetTask) => void;\r\n    /**\r\n     * Callback called when the task is successful\r\n     */\r\n    public onError: (task: EquiRectangularCubeTextureAssetTask, message?: string, exception?: any) => void;\r\n\r\n    /**\r\n     * Creates a new EquiRectangularCubeTextureAssetTask object\r\n     * @param name defines the name of the task\r\n     * @param url defines the location of the file to load\r\n     * @param size defines the desired size (the more it increases the longer the generation will be)\r\n     * If the size is omitted this implies you are using a preprocessed cubemap.\r\n     * @param noMipmap defines if mipmaps should not be generated (default is false)\r\n     * @param gammaSpace specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\r\n     * (default is true)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the task\r\n         */\r\n        public name: string,\r\n        /**\r\n         * Defines the location of the file to load\r\n         */\r\n        public url: string,\r\n        /**\r\n         * Defines the desired size (the more it increases the longer the generation will be)\r\n         */\r\n        public size: number,\r\n        /**\r\n         * Defines if mipmaps should not be generated (default is false)\r\n         */\r\n        public noMipmap: boolean = false,\r\n        /**\r\n         * Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,\r\n         * but the standard material would require them in Gamma space) (default is true)\r\n         */\r\n        public gammaSpace: boolean = true) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Execute the current task\r\n     * @param scene defines the scene where you want your assets to be loaded\r\n     * @param onSuccess is a callback called when the task is successfully executed\r\n     * @param onError is a callback called if an error occurs\r\n     */\r\n    public runTask(scene: Scene, onSuccess: () => void, onError: (message?: string, exception?: any) => void): void {\r\n\r\n        const onload = () => {\r\n            onSuccess();\r\n        };\r\n\r\n        const onerror = (message?: string, exception?: any) => {\r\n            onError(message, exception);\r\n        };\r\n\r\n        this.texture = new EquiRectangularCubeTexture(this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror);\r\n    }\r\n}\r\n\r\n/**\r\n * This class can be used to easily import assets into a scene\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_assetsmanager\r\n */\r\nexport class AssetsManager {\r\n    private _scene: Scene;\r\n    private _isLoading = false;\r\n\r\n    protected _tasks = new Array<AbstractAssetTask>();\r\n    protected _waitingTasksCount = 0;\r\n    protected _totalTasksCount = 0;\r\n\r\n    /**\r\n     * Callback called when all tasks are processed\r\n     */\r\n    public onFinish: (tasks: AbstractAssetTask[]) => void;\r\n\r\n    /**\r\n     * Callback called when a task is successful\r\n     */\r\n    public onTaskSuccess: (task: AbstractAssetTask) => void;\r\n\r\n    /**\r\n     * Callback called when a task had an error\r\n     */\r\n    public onTaskError: (task: AbstractAssetTask) => void;\r\n\r\n    /**\r\n     * Callback called when a task is done (whatever the result is)\r\n     */\r\n    public onProgress: (remainingCount: number, totalCount: number, task: AbstractAssetTask) => void;\r\n\r\n    /**\r\n     * Observable called when all tasks are processed\r\n     */\r\n    public onTaskSuccessObservable = new Observable<AbstractAssetTask>();\r\n\r\n    /**\r\n     * Observable called when a task had an error\r\n     */\r\n    public onTaskErrorObservable = new Observable<AbstractAssetTask>();\r\n\r\n    /**\r\n     * Observable called when all tasks were executed\r\n     */\r\n    public onTasksDoneObservable = new Observable<AbstractAssetTask[]>();\r\n\r\n    /**\r\n     * Observable called when a task is done (whatever the result is)\r\n     */\r\n    public onProgressObservable = new Observable<IAssetsProgressEvent>();\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the AssetsManager should use the default loading screen\r\n     * @see https://doc.babylonjs.com/how_to/creating_a_custom_loading_screen\r\n     */\r\n    public useDefaultLoadingScreen = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen\r\n     * when all assets have been downloaded.\r\n     * If set to false, you need to manually call in hideLoadingUI() once your scene is ready.\r\n     */\r\n    public autoHideLoadingUI = true;\r\n\r\n    /**\r\n     * Creates a new AssetsManager\r\n     * @param scene defines the scene to work on\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Add a ContainerAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param meshesNames defines the name of meshes to load\r\n     * @param rootUrl defines the root url to use to locate files\r\n     * @param sceneFilename defines the filename of the scene file\r\n     * @returns a new ContainerAssetTask object\r\n     */\r\n    public addContainerTask(taskName: string, meshesNames: any, rootUrl: string, sceneFilename: string): ContainerAssetTask {\r\n        var task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a MeshAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param meshesNames defines the name of meshes to load\r\n     * @param rootUrl defines the root url to use to locate files\r\n     * @param sceneFilename defines the filename of the scene file\r\n     * @returns a new MeshAssetTask object\r\n     */\r\n    public addMeshTask(taskName: string, meshesNames: any, rootUrl: string, sceneFilename: string): MeshAssetTask {\r\n        var task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a TextFileAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @returns a new TextFileAssetTask object\r\n     */\r\n    public addTextFileTask(taskName: string, url: string): TextFileAssetTask {\r\n        var task = new TextFileAssetTask(taskName, url);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a BinaryFileAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @returns a new BinaryFileAssetTask object\r\n     */\r\n    public addBinaryFileTask(taskName: string, url: string): BinaryFileAssetTask {\r\n        var task = new BinaryFileAssetTask(taskName, url);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a ImageAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @returns a new ImageAssetTask object\r\n     */\r\n    public addImageTask(taskName: string, url: string): ImageAssetTask {\r\n        var task = new ImageAssetTask(taskName, url);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a TextureAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n     * @param invertY defines if you want to invert Y axis of the loaded texture (false by default)\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @returns a new TextureAssetTask object\r\n     */\r\n    public addTextureTask(taskName: string, url: string, noMipmap?: boolean, invertY?: boolean, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE): TextureAssetTask {\r\n        var task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Add a CubeTextureAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @param extensions defines the extension to use to load the cube map (can be null)\r\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n     * @param files defines the list of files to load (can be null)\r\n     * @returns a new CubeTextureAssetTask object\r\n     */\r\n    public addCubeTextureTask(taskName: string, url: string, extensions?: string[], noMipmap?: boolean, files?: string[]): CubeTextureAssetTask {\r\n        var task = new CubeTextureAssetTask(taskName, url, extensions, noMipmap, files);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Add a HDRCubeTextureAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @param size defines the size you want for the cubemap (can be null)\r\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n     * @param generateHarmonics defines if you want to automatically generate (true by default)\r\n     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)\r\n     * @param reserved Internal use only\r\n     * @returns a new HDRCubeTextureAssetTask object\r\n     */\r\n    public addHDRCubeTextureTask(taskName: string, url: string, size: number, noMipmap = false, generateHarmonics = true, gammaSpace = false, reserved = false): HDRCubeTextureAssetTask {\r\n        var task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, reserved);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks\r\n     * @param taskName defines the name of the new task\r\n     * @param url defines the url of the file to load\r\n     * @param size defines the size you want for the cubemap (can be null)\r\n     * @param noMipmap defines if the texture must not receive mipmaps (false by default)\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @returns a new EquiRectangularCubeTextureAssetTask object\r\n     */\r\n    public addEquiRectangularCubeTextureAssetTask(taskName: string, url: string, size: number, noMipmap = false, gammaSpace = true): EquiRectangularCubeTextureAssetTask {\r\n        const task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace);\r\n        this._tasks.push(task);\r\n\r\n        return task;\r\n    }\r\n\r\n    /**\r\n     * Remove a task from the assets manager.\r\n     * @param task the task to remove\r\n     */\r\n    public removeTask(task: AbstractAssetTask) {\r\n        let index = this._tasks.indexOf(task);\r\n\r\n        if (index > -1) {\r\n            this._tasks.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _decreaseWaitingTasksCount(task: AbstractAssetTask): void {\r\n        this._waitingTasksCount--;\r\n\r\n        try {\r\n            if (this.onProgress) {\r\n                this.onProgress(\r\n                    this._waitingTasksCount,\r\n                    this._totalTasksCount,\r\n                    task\r\n                );\r\n            }\r\n\r\n            this.onProgressObservable.notifyObservers(\r\n                new AssetsProgressEvent(\r\n                    this._waitingTasksCount,\r\n                    this._totalTasksCount,\r\n                    task\r\n                )\r\n            );\r\n        } catch (e) {\r\n            Logger.Error(\"Error running progress callbacks.\");\r\n            console.log(e);\r\n        }\r\n\r\n        if (this._waitingTasksCount === 0) {\r\n            try {\r\n\r\n                var currentTasks = this._tasks.slice();\r\n\r\n                if (this.onFinish) {\r\n                    // Calling onFinish with immutable array of tasks\r\n                    this.onFinish(currentTasks);\r\n                }\r\n\r\n                // Let's remove successfull tasks\r\n                for (var task of currentTasks) {\r\n                    if (task.taskState === AssetTaskState.DONE) {\r\n                        let index = this._tasks.indexOf(task);\r\n\r\n                        if (index > -1) {\r\n                            this._tasks.splice(index, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.onTasksDoneObservable.notifyObservers(this._tasks);\r\n            } catch (e) {\r\n                Logger.Error(\"Error running tasks-done callbacks.\");\r\n                console.log(e);\r\n            }\r\n            this._isLoading = false;\r\n            if (this.autoHideLoadingUI) {\r\n                this._scene.getEngine().hideLoadingUI();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _runTask(task: AbstractAssetTask): void {\r\n\r\n        let done = () => {\r\n            try {\r\n                if (this.onTaskSuccess) {\r\n                    this.onTaskSuccess(task);\r\n                }\r\n                this.onTaskSuccessObservable.notifyObservers(task);\r\n                this._decreaseWaitingTasksCount(task);\r\n            } catch (e) {\r\n                error(\"Error executing task success callbacks\", e);\r\n            }\r\n\r\n        };\r\n\r\n        let error = (message?: string, exception?: any) => {\r\n            task._setErrorObject(message, exception);\r\n\r\n            if (this.onTaskError) {\r\n                this.onTaskError(task);\r\n            }\r\n            this.onTaskErrorObservable.notifyObservers(task);\r\n            this._decreaseWaitingTasksCount(task);\r\n        };\r\n\r\n        task.run(this._scene, done, error);\r\n    }\r\n\r\n    /**\r\n     * Reset the AssetsManager and remove all tasks\r\n     * @return the current instance of the AssetsManager\r\n     */\r\n    public reset(): AssetsManager {\r\n        this._isLoading = false;\r\n        this._tasks = new Array<AbstractAssetTask>();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the loading process\r\n     * @return the current instance of the AssetsManager\r\n     */\r\n    public load(): AssetsManager {\r\n        if (this._isLoading) {\r\n            return this;\r\n        }\r\n        this._isLoading = true;\r\n        this._waitingTasksCount = this._tasks.length;\r\n        this._totalTasksCount = this._tasks.length;\r\n\r\n        if (this._waitingTasksCount === 0) {\r\n            this._isLoading = false;\r\n            if (this.onFinish) {\r\n                this.onFinish(this._tasks);\r\n            }\r\n            this.onTasksDoneObservable.notifyObservers(this._tasks);\r\n            return this;\r\n        }\r\n\r\n        if (this.useDefaultLoadingScreen) {\r\n            this._scene.getEngine().displayLoadingUI();\r\n        }\r\n\r\n        for (var index = 0; index < this._tasks.length; index++) {\r\n            var task = this._tasks[index];\r\n            if (task.taskState === AssetTaskState.INIT) {\r\n                this._runTask(task);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Start the loading process as an async operation\r\n     * @return a promise returning the list of failed tasks\r\n     */\r\n    public loadAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            if (this._isLoading) {\r\n                resolve();\r\n                return;\r\n            }\r\n            this.onTasksDoneObservable.addOnce((remainingTasks) => {\r\n                if (remainingTasks && remainingTasks.length) {\r\n                    reject(remainingTasks);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n\r\n            this.load();\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}