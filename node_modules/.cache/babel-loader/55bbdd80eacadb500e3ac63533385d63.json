{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\nimport \"../Meshes/Builders/sphereBuilder\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Axis } from \"../Maths/math\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\n\nvar TextureDome =\n/** @class */\nfunction (_super) {\n  __extends(TextureDome, _super);\n  /**\r\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n   * @param name Element's name, child elements will append suffixes for their own names.\r\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n   * @param options An object containing optional or exposed sub element properties\r\n   */\n\n\n  function TextureDome(name, textureUrlOrElement, options, scene, onError) {\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.onError = onError;\n    _this._halfDome = false;\n    _this._crossEye = false;\n    _this._useDirectMapping = false;\n    _this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\n\n    _this._onBeforeCameraRenderObserver = null;\n    /**\r\n     * Observable raised when an error occured while loading the 360 image\r\n     */\n\n    _this.onLoadErrorObservable = new Observable();\n    scene = _this.getScene(); // set defaults and manage values\n\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n\n    if (options.useDirectMapping === undefined) {\n      _this._useDirectMapping = true;\n    } else {\n      _this._useDirectMapping = options.useDirectMapping;\n    }\n\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n\n    _this._setReady(false);\n\n    _this._mesh = Mesh.CreateSphere(name + \"_mesh\", options.resolution, options.size, scene, false, Mesh.BACKSIDE); // configure material\n\n    var material = _this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n\n    var texture = _this._initTexture(textureUrlOrElement, scene, options);\n\n    _this.texture = texture; // configure mesh\n\n    _this._mesh.material = material;\n    _this._mesh.parent = _this; // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n\n    _this._halfDomeMask = SphereBuilder.CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n\n    _this._halfDomeMask.rotate(Axis.X, -Math.PI / 2); // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n\n\n    _this._halfDomeMask.parent = _this._mesh;\n    _this._halfDome = !!options.halfDomeMode; // enable or disable according to the settings\n\n    _this._halfDomeMask.setEnabled(_this._halfDome);\n\n    _this._crossEye = !!options.crossEyeMode; // create\n\n    _this._texture.anisotropicFilteringLevel = 1;\n\n    _this._texture.onLoadObservable.addOnce(function () {\n      _this._setReady(true);\n    }); // Initial rotation\n\n\n    if (options.faceForward && scene.activeCamera) {\n      var camera = scene.activeCamera;\n      var forward = Vector3.Forward();\n      var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      _this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n\n    _this._changeTextureMode(_this._textureMode);\n\n    return _this;\n  }\n\n  Object.defineProperty(TextureDome.prototype, \"texture\", {\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\n    get: function () {\n      return this._texture;\n    },\n\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\n    set: function (newTexture) {\n      if (this._texture === newTexture) {\n        return;\n      }\n\n      this._texture = newTexture;\n\n      if (this._useDirectMapping) {\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.diffuseTexture = this._texture;\n      } else {\n        this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._material.reflectionTexture = this._texture;\n      }\n\n      this._changeTextureMode(this._textureMode);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"mesh\", {\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\n    get: function () {\n      return this._mesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"fovMultiplier\", {\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\n    get: function () {\n      return this._material.fovMultiplier;\n    },\n    set: function (value) {\n      this._material.fovMultiplier = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"textureMode\", {\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\n    get: function () {\n      return this._textureMode;\n    },\n\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\n    set: function (value) {\n      if (this._textureMode === value) {\n        return;\n      }\n\n      this._changeTextureMode(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"halfDome\", {\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\n    get: function () {\n      return this._halfDome;\n    },\n\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\n    set: function (enabled) {\n      this._halfDome = enabled;\n\n      this._halfDomeMask.setEnabled(enabled);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"crossEye\", {\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\n    get: function () {\n      return this._crossEye;\n    },\n\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\n    set: function (enabled) {\n      this._crossEye = enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureDome.prototype, \"material\", {\n    /**\r\n     * The background material of this dome.\r\n     */\n    get: function () {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureDome.prototype._changeTextureMode = function (value) {\n    var _this = this;\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this._textureMode = value; // Default Setup and Reset.\n\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n\n        break;\n\n      case TextureDome.MODE_SIDEBYSIDE:\n        // in half-dome mode the uScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n        var rightOffset_1 = this._halfDome ? 0.0 : 0.5;\n        var leftOffset_1 = this._halfDome ? -0.5 : 0.0;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n          var isRightCamera = camera.isRightCamera;\n\n          if (_this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n\n          if (isRightCamera) {\n            _this._texture.uOffset = rightOffset_1;\n          } else {\n            _this._texture.uOffset = leftOffset_1;\n          }\n        });\n        break;\n\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(function (camera) {\n          var isRightCamera = camera.isRightCamera; // allow \"cross-eye\" if left and right were switched in this mode\n\n          if (_this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n\n          _this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  };\n  /**\r\n   * Releases resources associated with this node.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  TextureDome.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    this._texture.dispose();\n\n    this._mesh.dispose();\n\n    this._material.dispose();\n\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n\n    this.onLoadErrorObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Define the source as a Monoscopic panoramic 360/180.\r\n   */\n\n\n  TextureDome.MODE_MONOSCOPIC = 0;\n  /**\r\n   * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n   */\n\n  TextureDome.MODE_TOPBOTTOM = 1;\n  /**\r\n   * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n   */\n\n  TextureDome.MODE_SIDEBYSIDE = 2;\n  return TextureDome;\n}(TransformNode);\n\nexport { TextureDome };","map":{"version":3,"sources":["../../../sourceES6/core/Helpers/textureDome.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../scene\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\nimport \"../Meshes/Builders/sphereBuilder\";\nimport { Nullable } from \"../types\";\nimport { Observer, Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Axis } from \"../Maths/math\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\n\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\n\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\n    /**\n     * Define the source as a Monoscopic panoramic 360/180.\n     */\n    public static readonly MODE_MONOSCOPIC = 0;\n    /**\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n     */\n    public static readonly MODE_TOPBOTTOM = 1;\n    /**\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n     */\n    public static readonly MODE_SIDEBYSIDE = 2;\n\n    private _halfDome: boolean = false;\n    private _crossEye: boolean = false;\n\n    protected _useDirectMapping = false;\n\n    /**\n     * The texture being displayed on the sphere\n     */\n    protected _texture: T;\n\n    /**\n     * Gets the texture being displayed on the sphere\n     */\n    public get texture(): T {\n        return this._texture;\n    }\n\n    /**\n     * Sets the texture being displayed on the sphere\n     */\n    public set texture(newTexture: T) {\n        if (this._texture === newTexture) {\n            return;\n        }\n        this._texture = newTexture;\n        if (this._useDirectMapping) {\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._material.diffuseTexture = this._texture;\n        } else {\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._material.reflectionTexture = this._texture;\n        }\n        this._changeTextureMode(this._textureMode);\n    }\n\n    /**\n     * The skybox material\n     */\n    protected _material: BackgroundMaterial;\n\n    /**\n     * The surface used for the dome\n     */\n    protected _mesh: Mesh;\n    /**\n     * Gets the mesh used for the dome.\n     */\n    public get mesh(): Mesh {\n        return this._mesh;\n    }\n\n    /**\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\n     */\n    private _halfDomeMask: Mesh;\n\n    /**\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n     * Also see the options.resolution property.\n     */\n    public get fovMultiplier(): number {\n        return this._material.fovMultiplier;\n    }\n    public set fovMultiplier(value: number) {\n        this._material.fovMultiplier = value;\n    }\n\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Gets or set the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    public get textureMode(): number {\n        return this._textureMode;\n    }\n    /**\n     * Sets the current texture mode for the texture. It can be:\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n     */\n    public set textureMode(value: number) {\n        if (this._textureMode === value) {\n            return;\n        }\n\n        this._changeTextureMode(value);\n    }\n\n    /**\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n     */\n    public get halfDome(): boolean {\n        return this._halfDome;\n    }\n\n    /**\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n     */\n    public set halfDome(enabled: boolean) {\n        this._halfDome = enabled;\n        this._halfDomeMask.setEnabled(enabled);\n    }\n\n    /**\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n     */\n    public set crossEye(enabled: boolean) {\n        this._crossEye = enabled;\n    }\n\n    /**\n     * Is it a cross-eye texture?\n     */\n    public get crossEye(): boolean {\n        return this._crossEye;\n    }\n\n    /**\n     * The background material of this dome.\n     */\n    public get material(): BackgroundMaterial {\n        return this._material;\n    }\n\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\n    /**\n     * Observable raised when an error occured while loading the 360 image\n     */\n    public onLoadErrorObservable = new Observable<string>();\n\n    /**\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n     * @param name Element's name, child elements will append suffixes for their own names.\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n     * @param options An object containing optional or exposed sub element properties\n     */\n    constructor(\n        name: string,\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\n        options: {\n            resolution?: number;\n            clickToPlay?: boolean;\n            autoPlay?: boolean;\n            loop?: boolean;\n            size?: number;\n            poster?: string;\n            faceForward?: boolean;\n            useDirectMapping?: boolean;\n            halfDomeMode?: boolean;\n            crossEyeMode?: boolean;\n            generateMipMaps?: boolean;\n        },\n        scene: Scene,\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\n    ) {\n        super(name, scene);\n\n        scene = this.getScene();\n\n        // set defaults and manage values\n        name = name || \"textureDome\";\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\n        options.clickToPlay = Boolean(options.clickToPlay);\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n\n        if (options.useDirectMapping === undefined) {\n            this._useDirectMapping = true;\n        } else {\n            this._useDirectMapping = options.useDirectMapping;\n        }\n\n        if (options.faceForward === undefined) {\n            options.faceForward = true;\n        }\n\n        this._setReady(false);\n        this._mesh = Mesh.CreateSphere(name + \"_mesh\", options.resolution, options.size, scene, false, Mesh.BACKSIDE);\n        // configure material\n        let material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\n        material.useEquirectangularFOV = true;\n        material.fovMultiplier = 1.0;\n        material.opacityFresnel = false;\n\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\n        this.texture = texture;\n\n        // configure mesh\n        this._mesh.material = material;\n        this._mesh.parent = this;\n\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n        this._halfDomeMask = SphereBuilder.CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n        this._halfDomeMask.parent = this._mesh;\n        this._halfDome = !!options.halfDomeMode;\n        // enable or disable according to the settings\n        this._halfDomeMask.setEnabled(this._halfDome);\n        this._crossEye = !!options.crossEyeMode;\n\n        // create\n        this._texture.anisotropicFilteringLevel = 1;\n        this._texture.onLoadObservable.addOnce(() => {\n            this._setReady(true);\n        });\n\n        // Initial rotation\n        if (options.faceForward && scene.activeCamera) {\n            let camera = scene.activeCamera;\n\n            let forward = Vector3.Forward();\n            var direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n            direction.normalize();\n\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n        }\n\n        this._changeTextureMode(this._textureMode);\n    }\n\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\n\n    protected _changeTextureMode(value: number): void {\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        this._textureMode = value;\n\n        // Default Setup and Reset.\n        this._texture.uScale = 1;\n        this._texture.vScale = 1;\n        this._texture.uOffset = 0;\n        this._texture.vOffset = 0;\n        this._texture.vAng = 0;\n\n        switch (value) {\n            case TextureDome.MODE_MONOSCOPIC:\n                if (this._halfDome) {\n                    this._texture.uScale = 2;\n                    this._texture.uOffset = -1;\n                }\n                break;\n            case TextureDome.MODE_SIDEBYSIDE:\n                // in half-dome mode the uScale should be double of 360 texture\n                // Use 0.99999 to boost perf by not switching program\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\n                    let isRightCamera = camera.isRightCamera;\n                    if (this._crossEye) {\n                        isRightCamera = !isRightCamera;\n                    }\n                    if (isRightCamera) {\n                        this._texture.uOffset = rightOffset;\n                    } else {\n                        this._texture.uOffset = leftOffset;\n                    }\n                });\n                break;\n            case TextureDome.MODE_TOPBOTTOM:\n                // in half-dome mode the vScale should be double of 360 texture\n                // Use 0.99999 to boost perf by not switching program\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\n                    let isRightCamera = camera.isRightCamera;\n                    // allow \"cross-eye\" if left and right were switched in this mode\n                    if (this._crossEye) {\n                        isRightCamera = !isRightCamera;\n                    }\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n                });\n                break;\n        }\n    }\n\n    /**\n     * Releases resources associated with this node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\n        this._texture.dispose();\n        this._mesh.dispose();\n        this._material.dispose();\n\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        this.onLoadErrorObservable.clear();\n\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}