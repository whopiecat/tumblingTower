{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine\";\n\nThinEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // Force cache update\n\n\n  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;\n  this.bindIndexBuffer(indexBuffer);\n  var arrayBuffer;\n\n  if (indices instanceof Uint16Array || indices instanceof Uint32Array) {\n    arrayBuffer = indices;\n  } else {\n    arrayBuffer = indexBuffer.is32Bits ? new Uint32Array(indices) : new Uint16Array(indices);\n  }\n\n  this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.DYNAMIC_DRAW);\n\n  this._resetIndexBufferBinding();\n};\n\nThinEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, data, byteOffset, byteLength) {\n  this.bindArrayBuffer(vertexBuffer);\n\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n\n  var dataLength = data.length || data.byteLength;\n\n  if (byteLength === undefined || byteLength >= dataLength && byteOffset === 0) {\n    if (data instanceof Array) {\n      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));\n    } else {\n      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);\n    }\n  } else {\n    if (data instanceof Array) {\n      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));\n    } else {\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data, byteOffset, byteLength);\n      } else {\n        data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n      }\n\n      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\n    }\n  }\n\n  this._resetVertexBufferBinding();\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Extensions/engine.dynamicBuffer.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,QAA2B,0BAA3B;;AAyBA,UAAU,CAAC,SAAX,CAAqB,wBAArB,GAAgD,UAA2B,WAA3B,EAAoD,OAApD,EAA2E,MAA3E,EAA6F;AAAlB,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,CAAA;AAAkB,GAAA,CACzI;;;AACA,OAAK,mBAAL,CAAyB,KAAK,GAAL,CAAS,oBAAlC,IAA0D,IAA1D;AACA,OAAK,eAAL,CAAqB,WAArB;AACA,MAAI,WAAJ;;AAEA,MAAI,OAAO,YAAY,WAAnB,IAAkC,OAAO,YAAY,WAAzD,EAAsE;AAClE,IAAA,WAAW,GAAG,OAAd;AACH,GAFD,MAEO;AACH,IAAA,WAAW,GAAG,WAAW,CAAC,QAAZ,GAAuB,IAAI,WAAJ,CAAgB,OAAhB,CAAvB,GAAkD,IAAI,WAAJ,CAAgB,OAAhB,CAAhE;AACH;;AAED,OAAK,GAAL,CAAS,UAAT,CAAoB,KAAK,GAAL,CAAS,oBAA7B,EAAmD,WAAnD,EAAgE,KAAK,GAAL,CAAS,YAAzE;;AAEA,OAAK,wBAAL;AACH,CAfD;;AAiBA,UAAU,CAAC,SAAX,CAAqB,yBAArB,GAAiD,UAA2B,YAA3B,EAAqD,IAArD,EAAsE,UAAtE,EAA2F,UAA3F,EAA8G;AAC3J,OAAK,eAAL,CAAqB,YAArB;;AAEA,MAAI,UAAU,KAAK,SAAnB,EAA8B;AAC1B,IAAA,UAAU,GAAG,CAAb;AACH;;AAED,MAAM,UAAU,GAAI,IAAiB,CAAC,MAAlB,IAA6B,IAAoB,CAAC,UAAtE;;AAEA,MAAI,UAAU,KAAK,SAAf,IAA4B,UAAU,IAAI,UAAd,IAA4B,UAAU,KAAK,CAA3E,EAA8E;AAC1E,QAAI,IAAI,YAAY,KAApB,EAA2B;AACvB,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,GAAL,CAAS,YAAhC,EAA8C,UAA9C,EAA0D,IAAI,YAAJ,CAAiB,IAAjB,CAA1D;AACH,KAFD,MAEO;AACH,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,GAAL,CAAS,YAAhC,EAA8C,UAA9C,EAAuE,IAAvE;AACH;AACJ,GAND,MAMO;AACH,QAAI,IAAI,YAAY,KAApB,EAA2B;AACvB,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,GAAL,CAAS,YAAhC,EAA8C,CAA9C,EAAiD,IAAI,YAAJ,CAAiB,IAAjB,EAAuB,QAAvB,CAAgC,UAAhC,EAA4C,UAAU,GAAG,UAAzD,CAAjD;AACH,KAFD,MAEO;AACH,UAAI,IAAI,YAAY,WAApB,EAAiC;AAC7B,QAAA,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAf,EAAqB,UAArB,EAAiC,UAAjC,CAAP;AACH,OAFD,MAEO;AACH,QAAA,IAAI,GAAG,IAAI,UAAJ,CAAe,IAAI,CAAC,MAApB,EAA4B,IAAI,CAAC,UAAL,GAAkB,UAA9C,EAA0D,UAA1D,CAAP;AACH;;AAED,WAAK,GAAL,CAAS,aAAT,CAAuB,KAAK,GAAL,CAAS,YAAhC,EAA8C,CAA9C,EAA8D,IAA9D;AACH;AACJ;;AAED,OAAK,yBAAL;AACH,CA9BD","sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { DataBuffer } from '../../Meshes/dataBuffer';\r\nimport { IndicesArray, DataArray } from \"../../types\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Update a dynamic index buffer\r\n         * @param indexBuffer defines the target index buffer\r\n         * @param indices defines the data to update\r\n         * @param offset defines the offset in the target index buffer where update should start\r\n         */\r\n        updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset?: number): void;\r\n\r\n        /**\r\n         * Updates a dynamic vertex buffer.\r\n         * @param vertexBuffer the vertex buffer to update\r\n         * @param data the data used to update the vertex buffer\r\n         * @param byteOffset the byte offset of the data\r\n         * @param byteLength the byte length of the data\r\n         */\r\n        updateDynamicVertexBuffer(vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateDynamicIndexBuffer = function(this: ThinEngine, indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n    // Force cache update\r\n    this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;\r\n    this.bindIndexBuffer(indexBuffer);\r\n    var arrayBuffer;\r\n\r\n    if (indices instanceof Uint16Array || indices instanceof Uint32Array) {\r\n        arrayBuffer = indices;\r\n    } else {\r\n        arrayBuffer = indexBuffer.is32Bits ? new Uint32Array(indices) : new Uint16Array(indices);\r\n    }\r\n\r\n    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.DYNAMIC_DRAW);\r\n\r\n    this._resetIndexBufferBinding();\r\n};\r\n\r\nThinEngine.prototype.updateDynamicVertexBuffer = function(this: ThinEngine, vertexBuffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    this.bindArrayBuffer(vertexBuffer);\r\n\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    const dataLength = (data as number[]).length || (data as ArrayBuffer).byteLength;\r\n\r\n    if (byteLength === undefined || byteLength >= dataLength && byteOffset === 0) {\r\n        if (data instanceof Array) {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));\r\n        } else {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, <ArrayBuffer>data);\r\n        }\r\n    } else {\r\n        if (data instanceof Array) {\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));\r\n        } else {\r\n            if (data instanceof ArrayBuffer) {\r\n                data = new Uint8Array(data, byteOffset, byteLength);\r\n            } else {\r\n                data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            }\r\n\r\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, <ArrayBuffer>data);\r\n        }\r\n    }\r\n\r\n    this._resetVertexBufferBinding();\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}