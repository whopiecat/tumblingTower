{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\nimport { Logger } from \"./logger\";\nimport { Tools } from \"./tools\";\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\n\nvar ScreenshotTools =\n/** @class */\nfunction () {\n  function ScreenshotTools() {}\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback defines the callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   */\n\n\n  ScreenshotTools.CreateScreenshot = function (engine, camera, size, successCallback, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    var _a = ScreenshotTools._getScreenshotSize(engine, camera, size),\n        height = _a.height,\n        width = _a.width;\n\n    if (!(height && width)) {\n      Logger.Error(\"Invalid 'size' parameter !\");\n      return;\n    }\n\n    if (!Tools._ScreenshotCanvas) {\n      Tools._ScreenshotCanvas = document.createElement('canvas');\n    }\n\n    Tools._ScreenshotCanvas.width = width;\n    Tools._ScreenshotCanvas.height = height;\n\n    var renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\n\n    var ratio = engine.getRenderWidth() / engine.getRenderHeight();\n    var newWidth = width;\n    var newHeight = newWidth / ratio;\n\n    if (newHeight > height) {\n      newHeight = height;\n      newWidth = newHeight * ratio;\n    }\n\n    var offsetX = Math.max(0, width - newWidth) / 2;\n    var offsetY = Math.max(0, height - newHeight) / 2;\n    var renderingCanvas = engine.getRenderingCanvas();\n\n    if (renderContext && renderingCanvas) {\n      renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n    }\n\n    Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\n  };\n  /**\r\n   * Captures a screenshot of the current rendering\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine defines the rendering engine\r\n   * @param camera defines the source camera\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotAsync = function (engine, camera, size, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      ScreenshotTools.CreateScreenshot(engine, camera, size, function (data) {\n        if (typeof data !== \"undefined\") {\n          resolve(data);\n        } else {\n          reject(new Error(\"Data is undefined\"));\n        }\n      }, mimeType);\n    });\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param successCallback The callback receives a single parameter which contains the\r\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n   * src parameter of an <img> to display it\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotUsingRenderTarget = function (engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    if (renderSprites === void 0) {\n      renderSprites = false;\n    }\n\n    if (enableStencilBuffer === void 0) {\n      enableStencilBuffer = false;\n    }\n\n    var _a = ScreenshotTools._getScreenshotSize(engine, camera, size),\n        height = _a.height,\n        width = _a.width;\n\n    var targetTextureSize = {\n      width: width,\n      height: height\n    };\n\n    if (!(height && width)) {\n      Logger.Error(\"Invalid 'size' parameter !\");\n      return;\n    }\n\n    var renderCanvas = engine.getRenderingCanvas();\n\n    if (!renderCanvas) {\n      Logger.Error(\"No rendering canvas found !\");\n      return;\n    }\n\n    var originalSize = {\n      width: renderCanvas.width,\n      height: renderCanvas.height\n    };\n    engine.setSize(width, height);\n    var scene = camera.getScene();\n    var previousCamera = null;\n    var previousCameras = scene.activeCameras;\n\n    if (scene.activeCamera !== camera || scene.activeCameras && scene.activeCameras.length) {\n      previousCamera = scene.activeCamera;\n      scene.activeCamera = camera;\n    }\n\n    scene.render(); // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n\n    var texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer);\n    texture.renderList = null;\n    texture.samples = samples;\n    texture.renderSprites = renderSprites;\n    texture.onAfterRenderObservable.add(function () {\n      Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType, fileName);\n    });\n\n    var renderToTexture = function () {\n      scene.incrementRenderId();\n      scene.resetCachedMaterial();\n      texture.render(true);\n      texture.dispose();\n\n      if (previousCamera) {\n        scene.activeCamera = previousCamera;\n      }\n\n      scene.activeCameras = previousCameras;\n      engine.setSize(originalSize.width, originalSize.height);\n      camera.getProjectionMatrix(true); // Force cache refresh;\n    };\n\n    if (antialiasing) {\n      var fxaaPostProcess = new FxaaPostProcess('antialiasing', 1.0, scene.activeCamera);\n      texture.addPostProcess(fxaaPostProcess); // Async Shader Compilation can lead to none ready effects in synchronous code\n\n      if (!fxaaPostProcess.getEffect().isReady()) {\n        fxaaPostProcess.getEffect().onCompiled = function () {\n          renderToTexture();\n        };\n      } // The effect is ready we can render\n      else {\n          renderToTexture();\n        }\n    } else {\n      // No need to wait for extra resources to be ready\n      renderToTexture();\n    }\n  };\n  /**\r\n   * Generates an image screenshot from the specified camera.\r\n   * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n   * @param engine The engine to use for rendering\r\n   * @param camera The camera to use for rendering\r\n   * @param size This parameter can be set to a single number or to an object with the\r\n   * following (optional) properties: precision, width, height. If a single number is passed,\r\n   * it will be used for both width and height. If an object is passed, the screenshot size\r\n   * will be derived from the parameters. The precision property is a multiplier allowing\r\n   * rendering at a higher or lower resolution\r\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n   * Check your browser for supported MIME types\r\n   * @param samples Texture samples (default: 1)\r\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n   * @param fileName A name for for the downloaded file.\r\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n   * to the src parameter of an <img> to display it\r\n   */\n\n\n  ScreenshotTools.CreateScreenshotUsingRenderTargetAsync = function (engine, camera, size, mimeType, samples, antialiasing, fileName, renderSprites) {\n    if (mimeType === void 0) {\n      mimeType = \"image/png\";\n    }\n\n    if (samples === void 0) {\n      samples = 1;\n    }\n\n    if (antialiasing === void 0) {\n      antialiasing = false;\n    }\n\n    if (renderSprites === void 0) {\n      renderSprites = false;\n    }\n\n    return new Promise(function (resolve, reject) {\n      ScreenshotTools.CreateScreenshotUsingRenderTarget(engine, camera, size, function (data) {\n        if (typeof data !== \"undefined\") {\n          resolve(data);\n        } else {\n          reject(new Error(\"Data is undefined\"));\n        }\n      }, mimeType, samples, antialiasing, fileName, renderSprites);\n    });\n  };\n  /**\r\n   * Gets height and width for screenshot size\r\n   * @private\r\n   */\n\n\n  ScreenshotTools._getScreenshotSize = function (engine, camera, size) {\n    var height = 0;\n    var width = 0; //If a size value defined as object\n\n    if (typeof size === 'object') {\n      var precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n      : 1; //If a width and height values is specified\n\n      if (size.width && size.height) {\n        height = size.height * precision;\n        width = size.width * precision;\n      } //If passing only width, computing height to keep display canvas ratio.\n      else if (size.width && !size.height) {\n          width = size.width * precision;\n          height = Math.round(width / engine.getAspectRatio(camera));\n        } //If passing only height, computing width to keep display canvas ratio.\n        else if (size.height && !size.width) {\n            height = size.height * precision;\n            width = Math.round(height * engine.getAspectRatio(camera));\n          } else {\n            width = Math.round(engine.getRenderWidth() * precision);\n            height = Math.round(width / engine.getAspectRatio(camera));\n          }\n    } //Assuming here that \"size\" parameter is a number\n    else if (!isNaN(size)) {\n        height = size;\n        width = size;\n      } // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n    // to resolve this, we truncate the floats here to ensure the same size\n\n\n    if (width) {\n      width = Math.floor(width);\n    }\n\n    if (height) {\n      height = Math.floor(height);\n    }\n\n    return {\n      height: height | 0,\n      width: width | 0\n    };\n  };\n\n  return ScreenshotTools;\n}();\n\nexport { ScreenshotTools };\nTools.CreateScreenshot = ScreenshotTools.CreateScreenshot;\nTools.CreateScreenshotAsync = ScreenshotTools.CreateScreenshotAsync;\nTools.CreateScreenshotUsingRenderTarget = ScreenshotTools.CreateScreenshotUsingRenderTarget;\nTools.CreateScreenshotUsingRenderTargetAsync = ScreenshotTools.CreateScreenshotUsingRenderTargetAsync;","map":{"version":3,"sources":["../../../sourceES6/core/Misc/screenshotTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\n\r\nimport { Logger } from \"./logger\";\r\nimport { _TypeStore } from \"./typeStore\";\r\nimport { Tools } from \"./tools\";\r\nimport { IScreenshotSize } from './interfaces/screenshotSize';\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport class ScreenshotTools {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     */\r\n    public static CreateScreenshot(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType: string = \"image/png\"): void {\r\n        const { height, width } = ScreenshotTools._getScreenshotSize(engine, camera, size);\r\n\r\n        if (!(height && width)) {\r\n            Logger.Error(\"Invalid 'size' parameter !\");\r\n            return;\r\n        }\r\n\r\n        if (!Tools._ScreenshotCanvas) {\r\n            Tools._ScreenshotCanvas = document.createElement('canvas');\r\n        }\r\n\r\n        Tools._ScreenshotCanvas.width = width;\r\n        Tools._ScreenshotCanvas.height = height;\r\n\r\n        var renderContext = Tools._ScreenshotCanvas.getContext(\"2d\");\r\n\r\n        var ratio = engine.getRenderWidth() / engine.getRenderHeight();\r\n        var newWidth = width;\r\n        var newHeight = newWidth / ratio;\r\n        if (newHeight > height) {\r\n            newHeight = height;\r\n            newWidth = newHeight * ratio;\r\n        }\r\n\r\n        var offsetX = Math.max(0, width - newWidth) / 2;\r\n        var offsetY = Math.max(0, height - newHeight) / 2;\r\n\r\n        var renderingCanvas = engine.getRenderingCanvas();\r\n        if (renderContext && renderingCanvas) {\r\n            renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\r\n        }\r\n\r\n        Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\r\n    }\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    public static CreateScreenshotAsync(engine: Engine, camera: Camera, size: any, mimeType: string = \"image/png\"): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            ScreenshotTools.CreateScreenshot(engine, camera, size, (data) => {\r\n                if (typeof(data) !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            }, mimeType);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     */\r\n    public static CreateScreenshotUsingRenderTarget(engine: Engine, camera: Camera, size: IScreenshotSize | number, successCallback?: (data: string) => void, mimeType: string = \"image/png\", samples: number = 1, antialiasing: boolean = false, fileName?: string, renderSprites: boolean = false, enableStencilBuffer: boolean = false): void {\r\n        const { height, width } = ScreenshotTools._getScreenshotSize(engine, camera, size);\r\n        let targetTextureSize = { width, height };\r\n\r\n        if (!(height && width)) {\r\n            Logger.Error(\"Invalid 'size' parameter !\");\r\n            return;\r\n        }\r\n        var renderCanvas = engine.getRenderingCanvas();\r\n        if (!renderCanvas) {\r\n            Logger.Error(\"No rendering canvas found !\");\r\n            return;\r\n        }\r\n\r\n        var originalSize = { width: renderCanvas.width, height: renderCanvas.height };\r\n        engine.setSize(width, height);\r\n\r\n        var scene = camera.getScene();\r\n\r\n        var previousCamera: Nullable<Camera> = null;\r\n        var previousCameras = scene.activeCameras;\r\n        if (scene.activeCamera !== camera || scene.activeCameras && scene.activeCameras.length) {\r\n            previousCamera = scene.activeCamera;\r\n            scene.activeCamera = camera;\r\n        }\r\n\r\n        scene.render();\r\n\r\n        // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n        var texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer);\r\n        texture.renderList = null;\r\n        texture.samples = samples;\r\n        texture.renderSprites = renderSprites;\r\n        texture.onAfterRenderObservable.add(() => {\r\n            Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType, fileName);\r\n        });\r\n\r\n        const renderToTexture = () => {\r\n            scene.incrementRenderId();\r\n            scene.resetCachedMaterial();\r\n            texture.render(true);\r\n            texture.dispose();\r\n\r\n            if (previousCamera) {\r\n                scene.activeCamera = previousCamera;\r\n            }\r\n            scene.activeCameras = previousCameras;\r\n\r\n            engine.setSize(originalSize.width, originalSize.height);\r\n            camera.getProjectionMatrix(true); // Force cache refresh;\r\n        };\r\n\r\n        if (antialiasing) {\r\n            const fxaaPostProcess = new FxaaPostProcess('antialiasing', 1.0, scene.activeCamera);\r\n            texture.addPostProcess(fxaaPostProcess);\r\n            // Async Shader Compilation can lead to none ready effects in synchronous code\r\n            if (!fxaaPostProcess.getEffect().isReady()) {\r\n                fxaaPostProcess.getEffect().onCompiled = () => {\r\n                    renderToTexture();\r\n                };\r\n            }\r\n            // The effect is ready we can render\r\n            else {\r\n                renderToTexture();\r\n            }\r\n        }\r\n        else {\r\n            // No need to wait for extra resources to be ready\r\n            renderToTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/how_to/render_scene_on_a_png\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    public static CreateScreenshotUsingRenderTargetAsync(engine: Engine, camera: Camera, size: any, mimeType: string = \"image/png\", samples: number = 1, antialiasing: boolean = false, fileName?: string,  renderSprites: boolean = false): Promise<string> {\r\n        return new Promise((resolve, reject) => {\r\n            ScreenshotTools.CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {\r\n                if (typeof(data) !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            }, mimeType, samples, antialiasing, fileName, renderSprites);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets height and width for screenshot size\r\n     * @private\r\n     */\r\n    private static _getScreenshotSize(engine: Engine, camera: Camera, size: IScreenshotSize | number): {height: number, width: number} {\r\n        let height = 0;\r\n        let width = 0;\r\n\r\n        //If a size value defined as object\r\n        if (typeof(size) === 'object') {\r\n            const precision = size.precision\r\n              ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n              : 1;\r\n\r\n            //If a width and height values is specified\r\n            if (size.width && size.height) {\r\n                height = size.height * precision;\r\n                width = size.width * precision;\r\n            }\r\n            //If passing only width, computing height to keep display canvas ratio.\r\n            else if (size.width && !size.height) {\r\n                width = size.width * precision;\r\n                height = Math.round(width / engine.getAspectRatio(camera));\r\n            }\r\n            //If passing only height, computing width to keep display canvas ratio.\r\n            else if (size.height && !size.width) {\r\n                height = size.height * precision;\r\n                width = Math.round(height * engine.getAspectRatio(camera));\r\n            }\r\n            else {\r\n                width = Math.round(engine.getRenderWidth() * precision);\r\n                height = Math.round(width / engine.getAspectRatio(camera));\r\n            }\r\n        }\r\n        //Assuming here that \"size\" parameter is a number\r\n        else if (!isNaN(size)) {\r\n            height = size;\r\n            width = size;\r\n        }\r\n\r\n        // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n        // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n        // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n        // to resolve this, we truncate the floats here to ensure the same size\r\n        if (width) {\r\n            width = Math.floor(width);\r\n        }\r\n        if (height) {\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        return { height: height | 0, width: width | 0 };\r\n    }\r\n}\r\n\r\nTools.CreateScreenshot = ScreenshotTools.CreateScreenshot;\r\nTools.CreateScreenshotAsync = ScreenshotTools.CreateScreenshotAsync;\r\nTools.CreateScreenshotUsingRenderTarget = ScreenshotTools.CreateScreenshotUsingRenderTarget;\r\nTools.CreateScreenshotUsingRenderTargetAsync = ScreenshotTools.CreateScreenshotUsingRenderTargetAsync;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}