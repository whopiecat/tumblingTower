{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\nimport { Space, Axis } from '../Maths/math.axis';\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller\r\n */\n\nvar BoneLookController =\n/** @class */\nfunction () {\n  /**\r\n   * Create a BoneLookController\r\n   * @param mesh the mesh that the bone belongs to\r\n   * @param bone the bone that will be looking to the target\r\n   * @param target the target Vector3 to look at\r\n   * @param options optional settings:\r\n   * * maxYaw: the maximum angle the bone will yaw to\r\n   * * minYaw: the minimum angle the bone will yaw to\r\n   * * maxPitch: the maximum angle the bone will pitch to\r\n   * * minPitch: the minimum angle the bone will yaw to\r\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n   * * upAxis: the up axis of the coordinate system\r\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n   * * adjustRoll: used to make an adjustment to the roll of the bone\r\n   **/\n  function BoneLookController(mesh, bone, target, options) {\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\n    this.upAxis = Vector3.Up();\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\n\n    this.upAxisSpace = Space.LOCAL;\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\n\n    this.adjustYaw = 0;\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\n\n    this.adjustPitch = 0;\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\n\n    this.adjustRoll = 0;\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\n\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        var newYawAxis = Axis.Y;\n        var newPitchAxis = Axis.X;\n\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n\n        var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n\n        this._transformYawPitch.invert();\n      }\n    }\n\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n\n  Object.defineProperty(BoneLookController.prototype, \"minYaw\", {\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\n    get: function () {\n      return this._minYaw;\n    },\n    set: function (value) {\n      this._minYaw = value;\n      this._minYawSin = Math.sin(value);\n      this._minYawCos = Math.cos(value);\n\n      if (this._maxYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxYaw\", {\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\n    get: function () {\n      return this._maxYaw;\n    },\n    set: function (value) {\n      this._maxYaw = value;\n      this._maxYawSin = Math.sin(value);\n      this._maxYawCos = Math.cos(value);\n\n      if (this._minYaw != null) {\n        this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n        this._yawRange = this._maxYaw - this._minYaw;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"minPitch\", {\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\n    get: function () {\n      return this._minPitch;\n    },\n    set: function (value) {\n      this._minPitch = value;\n      this._minPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoneLookController.prototype, \"maxPitch\", {\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\n    get: function () {\n      return this._maxPitch;\n    },\n    set: function (value) {\n      this._maxPitch = value;\n      this._maxPitchTan = Math.tan(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n   */\n\n  BoneLookController.prototype.update = function () {\n    //skip the first frame when slerping so that the mesh rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n\n    var bone = this.bone;\n    var bonePos = BoneLookController._tmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    var target = this.target;\n    var _tmpMat1 = BoneLookController._tmpMats[0];\n    var _tmpMat2 = BoneLookController._tmpMats[1];\n    var mesh = this.mesh;\n    var parentBone = bone.getParent();\n    var upAxis = BoneLookController._tmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n\n    var checkYaw = false;\n    var checkPitch = false;\n\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n\n    if (checkYaw || checkPitch) {\n      var spaceMat = BoneLookController._tmpMats[2];\n      var spaceMatInv = BoneLookController._tmpMats[3];\n\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        var forwardAxis = BoneLookController._tmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n\n        var rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        var forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n\n      spaceMat.invertToRef(spaceMatInv);\n      var xzlen = null;\n\n      if (checkPitch) {\n        var localTarget = BoneLookController._tmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        var pitch = Math.atan2(localTarget.y, xzlen);\n        var newPitch = pitch;\n\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n\n      if (checkYaw) {\n        var localTarget = BoneLookController._tmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        var yaw = Math.atan2(localTarget.x, localTarget.z);\n        var newYaw = yaw;\n\n        if (yaw > this._maxYaw || yaw < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yaw > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (yaw < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          }\n        }\n\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          var boneFwd = BoneLookController._tmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n\n          var boneRotMat = BoneLookController._tmpMats[4];\n\n          this._boneQuat.toRotationMatrix(boneRotMat);\n\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n\n          var angBtwTar = this._getAngleBetween(boneYaw, yaw);\n\n          var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n\n            var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n\n            var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * .75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * .75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n\n    var zaxis = BoneLookController._tmpVecs[5];\n    var xaxis = BoneLookController._tmpVecs[6];\n    var yaxis = BoneLookController._tmpVecs[7];\n    var _tmpQuat = BoneLookController._tmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n  };\n\n  BoneLookController.prototype._getAngleDiff = function (ang1, ang2) {\n    var angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n\n    return angDiff;\n  };\n\n  BoneLookController.prototype._getAngleBetween = function (ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    var ab = 0;\n\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n\n    return ab;\n  };\n\n  BoneLookController.prototype._isAngleBetween = function (ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  BoneLookController._tmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\n  BoneLookController._tmpQuat = Quaternion.Identity();\n  BoneLookController._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return BoneLookController;\n}();\n\nexport { BoneLookController };","map":{"version":3,"sources":["../../../sourceES6/core/Bones/boneLookController.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Bone } from \"./bone\";\r\nimport { Space, Axis } from '../Maths/math.axis';\r\n\r\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller\r\n */\r\nexport class BoneLookController {\r\n\r\n    private static _tmpVecs: Vector3[] = ArrayTools.BuildArray(10, Vector3.Zero);\r\n    private static _tmpQuat = Quaternion.Identity();\r\n    private static _tmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * The target Vector3 that the bone will look at\r\n     */\r\n    public target: Vector3;\r\n\r\n    /**\r\n     * The mesh that the bone is attached to\r\n     */\r\n    public mesh: AbstractMesh;\r\n\r\n    /**\r\n     * The bone that will be looking to the target\r\n     */\r\n    public bone: Bone;\r\n\r\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\r\n    public upAxis: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\r\n    public upAxisSpace: Space = Space.LOCAL;\r\n\r\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\r\n    public adjustYaw = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\r\n    public adjustPitch = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\r\n    public adjustRoll = 0;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _minYaw: number;\r\n    private _maxYaw: number;\r\n    private _minPitch: number;\r\n    private _maxPitch: number;\r\n    private _minYawSin: number;\r\n    private _minYawCos: number;\r\n    private _maxYawSin: number;\r\n    private _maxYawCos: number;\r\n    private _midYawConstraint: number;\r\n    private _minPitchTan: number;\r\n    private _maxPitchTan: number;\r\n\r\n    private _boneQuat: Quaternion = Quaternion.Identity();\r\n    private _slerping = false;\r\n    private _transformYawPitch: Matrix;\r\n    private _transformYawPitchInv: Matrix;\r\n    private _firstFrameSkipped = false;\r\n    private _yawRange: number;\r\n    private _fowardAxis: Vector3 = Vector3.Forward();\r\n\r\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\r\n    get minYaw(): number {\r\n        return this._minYaw;\r\n    }\r\n\r\n    set minYaw(value: number) {\r\n        this._minYaw = value;\r\n        this._minYawSin = Math.sin(value);\r\n        this._minYawCos = Math.cos(value);\r\n        if (this._maxYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\r\n    get maxYaw(): number {\r\n        return this._maxYaw;\r\n    }\r\n\r\n    set maxYaw(value: number) {\r\n        this._maxYaw = value;\r\n        this._maxYawSin = Math.sin(value);\r\n        this._maxYawCos = Math.cos(value);\r\n        if (this._minYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\r\n    get minPitch(): number {\r\n        return this._minPitch;\r\n    }\r\n\r\n    set minPitch(value: number) {\r\n        this._minPitch = value;\r\n        this._minPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\r\n    get maxPitch(): number {\r\n        return this._maxPitch;\r\n    }\r\n\r\n    set maxPitch(value: number) {\r\n        this._maxPitch = value;\r\n        this._maxPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Create a BoneLookController\r\n     * @param mesh the mesh that the bone belongs to\r\n     * @param bone the bone that will be looking to the target\r\n     * @param target the target Vector3 to look at\r\n     * @param options optional settings:\r\n     * * maxYaw: the maximum angle the bone will yaw to\r\n     * * minYaw: the minimum angle the bone will yaw to\r\n     * * maxPitch: the maximum angle the bone will pitch to\r\n     * * minPitch: the minimum angle the bone will yaw to\r\n     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n     * * upAxis: the up axis of the coordinate system\r\n     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n     * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n     * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n     * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n     * * adjustRoll: used to make an adjustment to the roll of the bone\r\n     **/\r\n    constructor(mesh: AbstractMesh,\r\n        bone: Bone,\r\n        target: Vector3,\r\n        options?: {\r\n            maxYaw?: number,\r\n            minYaw?: number,\r\n            maxPitch?: number,\r\n            minPitch?: number,\r\n            slerpAmount?: number,\r\n            upAxis?: Vector3,\r\n            upAxisSpace?: Space,\r\n            yawAxis?: Vector3,\r\n            pitchAxis?: Vector3,\r\n            adjustYaw?: number,\r\n            adjustPitch?: number,\r\n            adjustRoll?: number,\r\n        }) {\r\n\r\n        this.mesh = mesh;\r\n        this.bone = bone;\r\n        this.target = target;\r\n\r\n        if (options) {\r\n\r\n            if (options.adjustYaw) {\r\n                this.adjustYaw = options.adjustYaw;\r\n            }\r\n\r\n            if (options.adjustPitch) {\r\n                this.adjustPitch = options.adjustPitch;\r\n            }\r\n\r\n            if (options.adjustRoll) {\r\n                this.adjustRoll = options.adjustRoll;\r\n            }\r\n\r\n            if (options.maxYaw != null) {\r\n                this.maxYaw = options.maxYaw;\r\n            } else {\r\n                this.maxYaw = Math.PI;\r\n            }\r\n\r\n            if (options.minYaw != null) {\r\n                this.minYaw = options.minYaw;\r\n            } else {\r\n                this.minYaw = -Math.PI;\r\n            }\r\n\r\n            if (options.maxPitch != null) {\r\n                this.maxPitch = options.maxPitch;\r\n            } else {\r\n                this.maxPitch = Math.PI;\r\n            }\r\n\r\n            if (options.minPitch != null) {\r\n                this.minPitch = options.minPitch;\r\n            } else {\r\n                this.minPitch = -Math.PI;\r\n            }\r\n\r\n            if (options.slerpAmount != null) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n\r\n            if (options.upAxis != null) {\r\n                this.upAxis = options.upAxis;\r\n            }\r\n\r\n            if (options.upAxisSpace != null) {\r\n                this.upAxisSpace = options.upAxisSpace;\r\n            }\r\n\r\n            if (options.yawAxis != null || options.pitchAxis != null) {\r\n\r\n                var newYawAxis = Axis.Y;\r\n                var newPitchAxis = Axis.X;\r\n\r\n                if (options.yawAxis != null) {\r\n                    newYawAxis = options.yawAxis.clone();\r\n                    newYawAxis.normalize();\r\n                }\r\n\r\n                if (options.pitchAxis != null) {\r\n                    newPitchAxis = options.pitchAxis.clone();\r\n                    newPitchAxis.normalize();\r\n                }\r\n\r\n                var newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\r\n\r\n                this._transformYawPitch = Matrix.Identity();\r\n                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\r\n\r\n                this._transformYawPitchInv = this._transformYawPitch.clone();\r\n                this._transformYawPitch.invert();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\r\n            this.upAxisSpace = Space.LOCAL;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n     */\r\n    public update(): void {\r\n\r\n        //skip the first frame when slerping so that the mesh rotation is correct\r\n        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\r\n            this._firstFrameSkipped = true;\r\n            return;\r\n        }\r\n\r\n        var bone = this.bone;\r\n        var bonePos = BoneLookController._tmpVecs[0];\r\n        bone.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        var target = this.target;\r\n        var _tmpMat1 = BoneLookController._tmpMats[0];\r\n        var _tmpMat2 = BoneLookController._tmpMats[1];\r\n\r\n        var mesh = this.mesh;\r\n        var parentBone = bone.getParent();\r\n\r\n        var upAxis = BoneLookController._tmpVecs[1];\r\n        upAxis.copyFrom(this.upAxis);\r\n\r\n        if (this.upAxisSpace == Space.BONE && parentBone) {\r\n            if (this._transformYawPitch) {\r\n                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\r\n            }\r\n            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\r\n        } else if (this.upAxisSpace == Space.LOCAL) {\r\n            mesh.getDirectionToRef(upAxis, upAxis);\r\n            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\r\n                upAxis.normalize();\r\n            }\r\n        }\r\n\r\n        var checkYaw = false;\r\n        var checkPitch = false;\r\n\r\n        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\r\n            checkYaw = true;\r\n        }\r\n        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\r\n            checkPitch = true;\r\n        }\r\n\r\n        if (checkYaw || checkPitch) {\r\n\r\n            var spaceMat = BoneLookController._tmpMats[2];\r\n            var spaceMatInv = BoneLookController._tmpMats[3];\r\n\r\n            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\r\n\r\n                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\r\n\r\n            } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\r\n\r\n                spaceMat.copyFrom(mesh.getWorldMatrix());\r\n\r\n            } else {\r\n\r\n                var forwardAxis = BoneLookController._tmpVecs[2];\r\n                forwardAxis.copyFrom(this._fowardAxis);\r\n\r\n                if (this._transformYawPitch) {\r\n                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\r\n                }\r\n\r\n                if (parentBone) {\r\n                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\r\n                } else {\r\n                    mesh.getDirectionToRef(forwardAxis, forwardAxis);\r\n                }\r\n\r\n                var rightAxis = Vector3.Cross(upAxis, forwardAxis);\r\n                rightAxis.normalize();\r\n                var forwardAxis = Vector3.Cross(rightAxis, upAxis);\r\n\r\n                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\r\n\r\n            }\r\n\r\n            spaceMat.invertToRef(spaceMatInv);\r\n\r\n            var xzlen: Nullable<number> = null;\r\n\r\n            if (checkPitch) {\r\n                var localTarget = BoneLookController._tmpVecs[3];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                var pitch = Math.atan2(localTarget.y, xzlen);\r\n                var newPitch = pitch;\r\n\r\n                if (pitch > this._maxPitch) {\r\n                    localTarget.y = this._maxPitchTan * xzlen;\r\n                    newPitch = this._maxPitch;\r\n                } else if (pitch < this._minPitch) {\r\n                    localTarget.y = this._minPitchTan * xzlen;\r\n                    newPitch = this._minPitch;\r\n                }\r\n\r\n                if (pitch != newPitch) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n\r\n            if (checkYaw) {\r\n                var localTarget = BoneLookController._tmpVecs[4];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                var yaw = Math.atan2(localTarget.x, localTarget.z);\r\n                var newYaw = yaw;\r\n\r\n                if (yaw > this._maxYaw || yaw < this._minYaw) {\r\n\r\n                    if (xzlen == null) {\r\n                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                    }\r\n\r\n                    if (this._yawRange > Math.PI) {\r\n                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    } else {\r\n                        if (yaw > this._maxYaw) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (yaw < this._minYaw) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._slerping && this._yawRange > Math.PI) {\r\n                    //are we going to be crossing into the min/max region?\r\n                    var boneFwd = BoneLookController._tmpVecs[8];\r\n                    boneFwd.copyFrom(Axis.Z);\r\n                    if (this._transformYawPitch) {\r\n                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\r\n                    }\r\n\r\n                    var boneRotMat = BoneLookController._tmpMats[4];\r\n                    this._boneQuat.toRotationMatrix(boneRotMat);\r\n                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\r\n\r\n                    var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\r\n                    var angBtwTar = this._getAngleBetween(boneYaw, yaw);\r\n                    var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\r\n\r\n                    if (angBtwTar > angBtwMidYaw) {\r\n\r\n                        if (xzlen == null) {\r\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                        }\r\n\r\n                        var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\r\n                        var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\r\n\r\n                        if (angBtwMin < angBtwMax) {\r\n                            newYaw = boneYaw + Math.PI * .75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        } else {\r\n                            newYaw = boneYaw - Math.PI * .75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (yaw != newYaw) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        var zaxis = BoneLookController._tmpVecs[5];\r\n        var xaxis = BoneLookController._tmpVecs[6];\r\n        var yaxis = BoneLookController._tmpVecs[7];\r\n        var _tmpQuat = BoneLookController._tmpQuat;\r\n\r\n        target.subtractToRef(bonePos, zaxis);\r\n        zaxis.normalize();\r\n        Vector3.CrossToRef(upAxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n        Vector3.CrossToRef(zaxis, xaxis, yaxis);\r\n        yaxis.normalize();\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\r\n\r\n        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\r\n            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\r\n            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\r\n        }\r\n\r\n        if (this.slerpAmount < 1) {\r\n            if (!this._slerping) {\r\n                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\r\n            }\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);\r\n            Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);\r\n\r\n            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\r\n            this._slerping = true;\r\n        } else {\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\r\n            this._slerping = false;\r\n        }\r\n\r\n    }\r\n\r\n    private _getAngleDiff(ang1: number, ang2: number): number {\r\n\r\n        var angDiff = ang2 - ang1;\r\n        angDiff %= Math.PI * 2;\r\n\r\n        if (angDiff > Math.PI) {\r\n            angDiff -= Math.PI * 2;\r\n        } else if (angDiff < -Math.PI) {\r\n            angDiff += Math.PI * 2;\r\n        }\r\n\r\n        return angDiff;\r\n    }\r\n\r\n    private _getAngleBetween(ang1: number, ang2: number): number {\r\n\r\n        ang1 %= (2 * Math.PI);\r\n        ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;\r\n\r\n        ang2 %= (2 * Math.PI);\r\n        ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;\r\n\r\n        var ab = 0;\r\n\r\n        if (ang1 < ang2) {\r\n            ab = ang2 - ang1;\r\n        } else {\r\n            ab = ang1 - ang2;\r\n        }\r\n\r\n        if (ab > Math.PI) {\r\n            ab = Math.PI * 2 - ab;\r\n        }\r\n\r\n        return ab;\r\n    }\r\n\r\n    private _isAngleBetween(ang: number, ang1: number, ang2: number): boolean {\r\n\r\n        ang %= (2 * Math.PI);\r\n        ang = (ang < 0) ? ang + (2 * Math.PI) : ang;\r\n        ang1 %= (2 * Math.PI);\r\n        ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;\r\n        ang2 %= (2 * Math.PI);\r\n        ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;\r\n\r\n        if (ang1 < ang2) {\r\n            if (ang > ang1 && ang < ang2) {\r\n                return true;\r\n            }\r\n        } else {\r\n            if (ang > ang2 && ang < ang1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}