{"ast":null,"code":"import { Engine } from \"../../../Engines/engine\";\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\nimport { Texture } from \"../texture\";\nimport { DynamicTexture } from \"../dynamicTexture\";\nimport { Vector2 } from \"../../../Maths/math.vector\";\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\nimport { TexturePackerFrame } from \"./frame\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Tools } from '../../../Misc/tools';\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\n\nvar TexturePacker =\n/** @class */\nfunction () {\n  /**\r\n  * Initializes a texture package series from an array of meshes or a single mesh.\r\n  * @param name The name of the package\r\n  * @param meshes The target meshes to compose the package from\r\n  * @param options The arguments that texture packer should follow while building.\r\n  * @param scene The scene which the textures are scoped to.\r\n  * @returns TexturePacker\r\n  */\n  function TexturePacker(name, meshes, options, scene) {\n    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\r\n     * Run through the options and set what ever defaults are needed that where not declared.\r\n     */\n\n    this.options = options;\n    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : ['ambientTexture', 'bumpTexture', 'diffuseTexture', 'emissiveTexture', 'lightmapTexture', 'opacityTexture', 'reflectionTexture', 'refractionTexture', 'specularTexture'];\n    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n    }\n\n    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n    this._expecting = 0;\n    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : 'black';\n    }\n\n    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio); //Make it an even padding Number.\n\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n\n    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n    }\n\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\r\n  * Starts the package process\r\n  * @param resolve The promises resolution function\r\n  * @returns TexturePacker\r\n  */\n\n\n  TexturePacker.prototype._createFrames = function (resolve) {\n    var _this = this;\n\n    var dtSize = this._calculateSize();\n\n    var dtUnits = new Vector2(1, 1).divide(dtSize);\n    var doneCount = 0;\n    var expecting = this._expecting;\n    var meshLength = this.meshes.length;\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n      var dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set', {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true, //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      var dtx = dt.getContext();\n      dtx.fillStyle = 'rgba(0,0,0,0)';\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n\n    var baseSize = this.options.frameSize || 256;\n    var padding = this._paddingValue;\n    var tcs = baseSize + 2 * padding;\n\n    var done = function () {\n      _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);\n    }; //Update the Textures\n\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var mat = m.material;\n\n      var _loop_1 = function (j) {\n        var tempTexture = new DynamicTexture('temp', tcs, this_1.scene, true);\n        var tcx = tempTexture.getContext();\n\n        var offset = this_1._getFrameOffset(i);\n\n        var updateDt = function () {\n          doneCount++;\n          tempTexture.update(false);\n          var iDat = tcx.getImageData(0, 0, tcs, tcs); //Update Set\n\n          var dt = _this.sets[setName];\n          var dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n\n        var setName = sKeys[j] || '_blank';\n\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = 'rgba(0,0,0,0)';\n\n          if (this_1.options.fillBlanks) {\n            tcx.fillStyle = this_1.options.customFillColor;\n          }\n\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          var setTexture = mat[setName];\n          var img_1 = new Image();\n\n          if (setTexture instanceof DynamicTexture) {\n            img_1.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img_1.src = setTexture.url;\n          }\n\n          Tools.SetCorsBehavior(img_1.src, img_1);\n\n          img_1.onload = function () {\n            tcx.fillStyle = 'rgba(0,0,0,0)';\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n\n            switch (_this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (var i_1 = 0; i_1 < 9; i_1++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[i_1], padding + baseSize * cellOffsets[i_1 + 1] - tcs, baseSize, baseSize);\n                }\n\n                break;\n              //Extend Mode\n\n              case 1:\n                for (var i_2 = 0; i_2 < padding; i_2++) {\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding * 2 - i_2, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);\n                  tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, padding * 2 - i_2 - tcs, baseSize, baseSize);\n                }\n\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n\n              case 2:\n                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      };\n\n      var this_1 = this; //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n\n      for (var j = 0; j < sKeys.length; j++) {\n        _loop_1(j);\n      }\n    }\n  };\n  /**\r\n  * Calculates the Size of the Channel Sets\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._calculateSize = function () {\n    var meshLength = this.meshes.length || 0;\n    var baseSize = this.options.frameSize || 0;\n    var padding = this._paddingValue || 0;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        var size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n        return new Vector2(size, size);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Calculates the UV data for the frames.\r\n  * @param baseSize the base frameSize\r\n  * @param padding the base frame padding\r\n  * @param dtSize size of the Dynamic Texture for that channel\r\n  * @param dtUnits is 1/dtSize\r\n  * @param update flag to update the input meshes\r\n  */\n\n\n  TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {\n    var meshLength = this.meshes.length;\n\n    for (var i = 0; i < meshLength; i++) {\n      var m = this.meshes[i];\n      var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      var pOffset = dtUnits.clone().scale(padding);\n\n      var frameOffset = this._getFrameOffset(i);\n\n      var offset = frameOffset.add(pOffset);\n      var frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame); //Update Output UVs\n\n      if (update) {\n        this._updateMeshUV(m, i);\n\n        this._updateTextureReferences(m);\n      }\n    }\n  };\n  /**\r\n  * Calculates the frames Offset.\r\n  * @param index of the frame\r\n  * @returns Vector2\r\n  */\n\n\n  TexturePacker.prototype._getFrameOffset = function (index) {\n    var meshLength = this.meshes.length;\n    var uvStep, yStep, xStep;\n\n    switch (this.options.layout) {\n      case 0:\n        //STRIP_LAYOUT\n        uvStep = 1 / meshLength;\n        return new Vector2(index * uvStep, 0);\n        break;\n\n      case 1:\n        //POWER2\n        var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n        yStep = Math.floor(index / sqrtCount);\n        xStep = index - yStep * sqrtCount;\n        uvStep = 1 / sqrtCount;\n        return new Vector2(xStep * uvStep, yStep * uvStep);\n        break;\n\n      case 2:\n        //COLNUM\n        var cols = this.options.colnum || 1;\n        var rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n        xStep = Math.floor(index / rowCnt);\n        yStep = index - xStep * rowCnt;\n        uvStep = new Vector2(1 / cols, 1 / rowCnt);\n        return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        break;\n    }\n\n    return Vector2.Zero();\n  };\n  /**\r\n  * Updates a Mesh to the frame data\r\n  * @param mesh that is the target\r\n  * @param frameID or the frame index\r\n  */\n\n\n  TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {\n    var frame = this.frames[frameID];\n    var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    var uvOut = [];\n    var toCount = 0;\n\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n\n    for (var i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  };\n  /**\r\n  * Updates a Meshes materials to use the texture packer channels\r\n  * @param m is the mesh to target\r\n  * @param force all channels on the packer to be set.\r\n  */\n\n\n  TexturePacker.prototype._updateTextureReferences = function (m, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    var mat = m.material;\n    var sKeys = Object.keys(this.sets);\n\n    var _dispose = function (_t) {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var setName = sKeys[i];\n\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n\n        mat[setName] = this.sets[setName];\n      }\n    }\n  };\n  /**\r\n  * Public method to set a Mesh to a frame\r\n  * @param m that is the target\r\n  * @param frameID or the frame index\r\n  * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n  */\n\n\n  TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {\n    if (updateMaterial === void 0) {\n      updateMaterial = false;\n    }\n\n    this._updateMeshUV(m, frameID);\n\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  };\n  /**\r\n  * Starts the async promise to compile the texture packer.\r\n  * @returns Promise<void>\r\n  */\n\n\n  TexturePacker.prototype.processAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n\n        var done_1 = 0;\n\n        var doneCheck_1 = function (mat) {\n          done_1++; //Check Status of all Textures on all meshes, till they are ready.\n\n          if (_this.options.map) {\n            for (var j = 0; j < _this.options.map.length; j++) {\n              var index = _this.options.map[j];\n              var t = mat[index];\n\n              if (t !== null) {\n                if (!_this.sets[_this.options.map[j]]) {\n                  _this.sets[_this.options.map[j]] = true;\n                }\n\n                _this._expecting++;\n              }\n            }\n\n            if (done_1 === _this.meshes.length) {\n              _this._createFrames(resolve);\n            }\n          }\n        };\n\n        var _loop_2 = function (i) {\n          var mesh = _this.meshes[i];\n          var material = mesh.material;\n\n          if (!material) {\n            done_1++;\n\n            if (done_1 === _this.meshes.length) {\n              return {\n                value: _this._createFrames(resolve)\n              };\n            }\n\n            return \"continue\";\n          }\n\n          material.forceCompilationAsync(mesh).then(function () {\n            doneCheck_1(material);\n          });\n        };\n\n        for (var i = 0; i < _this.meshes.length; i++) {\n          var state_1 = _loop_2(i);\n\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  };\n  /**\r\n  * Disposes all textures associated with this packer\r\n  */\n\n\n  TexturePacker.prototype.dispose = function () {\n    var sKeys = Object.keys(this.sets);\n\n    for (var i = 0; i < sKeys.length; i++) {\n      var channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  };\n  /**\r\n  * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n  * @param imageType is the image type to use.\r\n  * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n  */\n\n\n  TexturePacker.prototype.download = function (imageType, quality) {\n    var _this = this;\n\n    if (imageType === void 0) {\n      imageType = 'png';\n    }\n\n    if (quality === void 0) {\n      quality = 1;\n    }\n\n    setTimeout(function () {\n      var pack = {\n        name: _this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      var sKeys = Object.keys(_this.sets);\n      var oKeys = Object.keys(_this.options);\n\n      try {\n        for (var i = 0; i < sKeys.length; i++) {\n          var channel = sKeys[i];\n          var dt = _this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\n        }\n\n        for (var i = 0; i < oKeys.length; i++) {\n          var opt = oKeys[i];\n          pack.options[opt] = _this.options[opt];\n        }\n\n        for (var i = 0; i < _this.frames.length; i++) {\n          var _f = _this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n\n      var data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n\n      var _a = document.createElement('a');\n\n      _a.setAttribute(\"href\", data);\n\n      _a.setAttribute(\"download\", _this.name + \"_texurePackage.json\");\n\n      document.body.appendChild(_a);\n\n      _a.click();\n\n      _a.remove();\n    }, 0);\n  };\n  /**\r\n  * Public method to load a texturePacker JSON file.\r\n  * @param data of the JSON file in string format.\r\n  */\n\n\n  TexturePacker.prototype.updateFromJSON = function (data) {\n    try {\n      var parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n\n      var _options = Object.keys(parsedData.options);\n\n      for (var i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n\n      for (var i = 0; i < parsedData.frames.length; i += 4) {\n        var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n\n      var channels = Object.keys(parsedData.sets);\n\n      for (var i = 0; i < channels.length; i++) {\n        var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  };\n  /** Packer Layout Constant 0 */\n\n\n  TexturePacker.LAYOUT_STRIP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.LAYOUT_POWER2 = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.LAYOUT_COLNUM = 2;\n  /** Packer Layout Constant 0 */\n\n  TexturePacker.SUBUV_WRAP = 0;\n  /** Packer Layout Constant 1 */\n\n  TexturePacker.SUBUV_EXTEND = 1;\n  /** Packer Layout Constant 2 */\n\n  TexturePacker.SUBUV_COLOR = 2;\n  return TexturePacker;\n}();\n\nexport { TexturePacker };","map":{"version":3,"sources":["../../../../../sourceES6/core/Materials/Textures/Packer/packer.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,yBAAvB;AAEA,SAAS,YAAT,QAA6B,wBAA7B;AAGA,SAAS,OAAT,QAAwB,YAAxB;AACA,SAAS,cAAT,QAA+B,mBAA/B;AAEA,SAAS,OAAT,QAAwB,4BAAxB;AACA,SAAS,MAAT,EAAiB,MAAjB,QAA+B,2BAA/B;AACA,SAAS,kBAAT,QAAmC,SAAnC;AACA,SAAS,MAAT,QAAuB,sBAAvB;AACA,SAAS,KAAT,QAAsB,qBAAtB;AAqGA;;;;;AAIA,IAAA,aAAA;AAAA;AAAA,YAAA;AA2CI;;;;;;;;AAQA,WAAA,aAAA,CAAY,IAAZ,EAA0B,MAA1B,EAAkD,OAAlD,EAAkF,KAAlF,EAA8F;;;AAE1F,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,KAAL,GAAa,KAAb;AAEA;;;;AAGA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,OAAL,CAAa,GAAb,GAAgB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,GAAhB,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,CAC/B,gBAD+B,EAE/B,aAF+B,EAG/B,gBAH+B,EAI/B,iBAJ+B,EAK/B,iBAL+B,EAM/B,gBAN+B,EAO/B,mBAP+B,EAQ/B,mBAR+B,EAS/B,iBAT+B,CAAvC;AAYA,SAAK,OAAL,CAAa,KAAb,GAAkB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,KAAhB,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,EAArB,GAAyB,YAAY,CAAC,MAAxD;AACA,SAAK,OAAL,CAAa,MAAb,GAAmB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,MAAhB,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,EAAtB,GAA0B,YAAY,CAAC,MAA1D;AACA,SAAK,OAAL,CAAa,MAAb,GAAmB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,MAAhB,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,EAAtB,GAA0B,aAAa,CAAC,YAA3D;;AAEA,QAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,aAAa,CAAC,aAA1C,EAAyD;AACrD,WAAK,OAAL,CAAa,MAAb,GAAmB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,MAAhB,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,EAAtB,GAA0B,CAA7C;AACH;;AAED,SAAK,OAAL,CAAa,iBAAb,GAA8B,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,iBAAhB,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAqC,IAAnE;AACA,SAAK,OAAL,CAAa,cAAb,GAA2B,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,cAAhB,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,EAA9B,GAAkC,IAA7D;AACA,SAAK,UAAL,GAAkB,CAAlB;AAEA,SAAK,OAAL,CAAa,UAAb,GAAuB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,UAAhB,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,IAArD;;AAEA,QAAI,KAAK,OAAL,CAAa,UAAb,KAA4B,IAAhC,EAAsC;AAClC,WAAK,OAAL,CAAa,eAAb,GAA4B,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,eAAhB,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,EAA/B,GAAmC,OAA/D;AACH;;AAED,SAAK,OAAL,CAAa,SAAb,GAAsB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,SAAhB,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,GAAnD;AACA,SAAK,OAAL,CAAa,YAAb,GAAyB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,YAAhB,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,EAA5B,GAAgC,MAAzD;AAEA,SAAK,aAAL,GAAqB,IAAI,CAAC,IAAL,CAAU,KAAK,OAAL,CAAa,SAAb,GAAyB,KAAK,OAAL,CAAa,YAAhD,CAArB,CA3C0F,CA6C1F;;AACA,QAAI,KAAK,aAAL,GAAqB,CAArB,KAA2B,CAA/B,EAAkC;AAC9B,WAAK,aAAL;AACH;;AAED,SAAK,OAAL,CAAa,WAAb,GAAwB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,WAAhB,MAA2B,IAA3B,IAA2B,EAAA,KAAA,KAAA,CAA3B,GAA2B,EAA3B,GAA+B,aAAa,CAAC,UAArE;;AAEA,QAAI,KAAK,OAAL,CAAa,WAAb,KAA6B,aAAa,CAAC,WAA/C,EAA4D;AACxD,WAAK,OAAL,CAAa,YAAb,GAAyB,CAAA,EAAA,GAAG,KAAK,OAAL,CAAa,YAAhB,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,EAA5B,GAAgC,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,GAApB,CAAzD;AACH;;AAED,SAAK,IAAL,GAAY,EAAZ;AACA,SAAK,MAAL,GAAc,EAAd;AAEA,WAAO,IAAP;AACH;AAED;;;;;;;AAKQ,EAAA,aAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,OAAtB,EAAyC;AAAzC,QAAA,KAAA,GAAA,IAAA;;AAEI,QAAI,MAAM,GAAG,KAAK,cAAL,EAAb;;AACA,QAAI,OAAO,GAAI,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAD,CAAoB,MAApB,CAA2B,MAA3B,CAAd;AACA,QAAI,SAAS,GAAG,CAAhB;AACA,QAAI,SAAS,GAAG,KAAK,UAArB;AACA,QAAI,UAAU,GAAG,KAAK,MAAL,CAAY,MAA7B;AAEA,QAAI,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,IAAjB,CAAZ;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,UAAI,OAAO,GAAG,KAAK,CAAC,CAAD,CAAnB;AAEA,UAAI,EAAE,GAAG,IAAI,cAAJ,CAAmB,KAAK,IAAL,GAAY,eAAZ,GAA8B,OAA9B,GAAwC,KAA3D,EACD;AAAE,QAAA,KAAK,EAAE,MAAM,CAAC,CAAhB;AAAmB,QAAA,MAAM,EAAE,MAAM,CAAC;AAAlC,OADC,EAED,KAAK,KAFJ,EAGD,IAHC,EAGK;AACN,MAAA,OAAO,CAAC,sBAJP,EAKD,MAAM,CAAC,kBALN,CAAT;AAQA,UAAI,GAAG,GAAG,EAAE,CAAC,UAAH,EAAV;AACA,MAAA,GAAG,CAAC,SAAJ,GAAgB,eAAhB;AACA,MAAA,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,MAAM,CAAC,CAA1B,EAA6B,MAAM,CAAC,CAApC;AACA,MAAA,EAAE,CAAC,MAAH,CAAU,KAAV;AACC,WAAK,IAAL,CAAkB,OAAlB,IAA6B,EAA7B;AACJ;;AAED,QAAI,QAAQ,GAAG,KAAK,OAAL,CAAa,SAAb,IAA0B,GAAzC;AACA,QAAI,OAAO,GAAG,KAAK,aAAnB;AACA,QAAI,GAAG,GAAG,QAAQ,GAAI,IAAI,OAA1B;;AAEA,QAAM,IAAI,GAAG,YAAA;AACT,MAAA,KAAI,CAAC,sBAAL,CAA4B,QAA5B,EAAsC,OAAtC,EAA+C,MAA/C,EAAuD,OAAvD,EAAgE,KAAI,CAAC,OAAL,CAAa,iBAAb,IAAkC,KAAlG;AACH,KAFD,CA/BqC,CAmCrC;;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,UAAI,CAAC,GAAG,KAAK,MAAL,CAAY,CAAZ,CAAR;AACA,UAAI,GAAG,GAAG,CAAC,CAAC,QAAZ;;8BAOS,C,EAAC;AACN,YAAI,WAAW,GAAG,IAAI,cAAJ,CAAmB,MAAnB,EAA2B,GAA3B,EAAgC,MAAA,CAAK,KAArC,EAA4C,IAA5C,CAAlB;AACA,YAAI,GAAG,GAAG,WAAW,CAAC,UAAZ,EAAV;;AACA,YAAI,MAAM,GAAG,MAAA,CAAK,eAAL,CAAqB,CAArB,CAAb;;AAEA,YAAM,QAAQ,GAAG,YAAA;AACb,UAAA,SAAS;AACT,UAAA,WAAW,CAAC,MAAZ,CAAmB,KAAnB;AACA,cAAI,IAAI,GAAG,GAAG,CAAC,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,GAAvB,EAA4B,GAA5B,CAAX,CAHa,CAKb;;AACA,cAAI,EAAE,GAAI,KAAI,CAAC,IAAL,CAAkB,OAAlB,CAAV;AACA,cAAI,GAAG,GAAG,EAAE,CAAC,UAAH,EAAV;AACA,UAAA,GAAG,CAAC,YAAJ,CAAiB,IAAjB,EAAuB,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAzC,EAA4C,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA9D;AACA,UAAA,WAAW,CAAC,OAAZ;AACA,UAAA,EAAE,CAAC,MAAH,CAAU,KAAV;;AACA,cAAI,SAAS,IAAI,SAAjB,EAA4B;AACxB,YAAA,IAAI;AACJ,YAAA,OAAO;AACP;AACH;AACJ,SAhBD;;AAkBA,YAAI,OAAO,GAAG,KAAK,CAAC,CAAD,CAAL,IAAY,QAA1B;;AACA,YAAI,CAAC,GAAD,IAAS,GAAW,CAAC,OAAD,CAAX,KAAyB,IAAtC,EAA4C;AACxC,UAAA,GAAG,CAAC,SAAJ,GAAgB,eAAhB;;AAEA,cAAI,MAAA,CAAK,OAAL,CAAa,UAAjB,EAA6B;AACzB,YAAA,GAAG,CAAC,SAAJ,GAAiB,MAAA,CAAK,OAAL,CAAa,eAA9B;AACH;;AAED,UAAA,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,GAAnB,EAAwB,GAAxB;AAEA,UAAA,QAAQ;AAEX,SAXD,MAWO;AAEH,cAAI,UAAU,GAAI,GAAW,CAAC,OAAD,CAA7B;AACA,cAAI,KAAG,GAAG,IAAI,KAAJ,EAAV;;AAEA,cAAI,UAAU,YAAY,cAA1B,EAA0C;AACtC,YAAA,KAAG,CAAC,GAAJ,GAAU,UAAU,CAAC,UAAX,GAAwB,MAAxB,CAA+B,SAA/B,CAAyC,WAAzC,CAAV;AACH,WAFD,MAEO;AACH,YAAA,KAAG,CAAC,GAAJ,GAAU,UAAW,CAAC,GAAtB;AACH;;AACD,UAAA,KAAK,CAAC,eAAN,CAAsB,KAAG,CAAC,GAA1B,EAA+B,KAA/B;;AAEA,UAAA,KAAG,CAAC,MAAJ,GAAa,YAAA;AACT,YAAA,GAAG,CAAC,SAAJ,GAAgB,eAAhB;AACA,YAAA,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,GAAnB,EAAwB,GAAxB;AACA,YAAA,WAAW,CAAC,MAAZ,CAAmB,KAAnB;AAEA,YAAA,GAAG,CAAC,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAAC,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC;AACA,gBAAI,WAAW,GAAG,CAAE,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAAC,CAA3B,EAA8B,CAA9B,EAAiC,CAAC,CAAlC,EAAqC,CAArC,EAAwC,CAAC,CAAD,GAAK,CAA7C,EAAgD,CAAhD,EAAmD,CAAC,CAApD,EAAuD,CAAvD,EAA0D,CAAC,CAA3D,CAAlB;;AAEA,oBAAQ,KAAI,CAAC,OAAL,CAAa,WAArB;AACI;AACA,mBAAK,CAAL;AACI,qBAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,CAApB,EAAuB,GAAC,EAAxB,EAA4B;AACxB,kBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMK,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,GAAD,CANvC,EAOM,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,GAAC,GAAG,CAAL,CAApC,GAAgD,GAPpD,EAQI,QARJ,EASI,QATJ;AAWH;;AACL;AACA;;AACA,mBAAK,CAAL;AACI,qBAAK,IAAI,GAAC,GAAG,CAAb,EAAgB,GAAC,GAAG,OAApB,EAA6B,GAAC,EAA9B,EAAkC;AAC9B,kBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMI,GAAC,GAAI,QAAQ,GAAG,WAAW,CAAC,CAAD,CAN/B,EAOI,OAAO,GAAG,GAPd,EAQI,QARJ,EASI,QATJ;AAYA,kBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMK,OAAO,GAAG,CAAX,GAAgB,GANpB,EAOI,OAAO,GAAG,GAPd,EAQI,QARJ,EASI,QATJ;AAYA,kBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMI,OANJ,EAOI,GAAC,GAAG,GAPR,EAQI,QARJ,EASI,QATJ;AAYA,kBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMI,OANJ,EAOK,OAAO,GAAG,CAAX,GAAgB,GAAhB,GAAoB,GAPxB,EAQI,QARJ,EASI,QATJ;AAWH;;AAED,gBAAA,GAAG,CAAC,SAAJ,CACI,KADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,KAAG,CAAC,KAJR,EAKI,KAAG,CAAC,MALR,EAMK,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,CAAD,CANvC,EAOM,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,CAAD,CAApC,GAA4C,GAPhD,EAQI,QARJ,EASI,QATJ;AAYJ;AACA;;AACA,mBAAK,CAAL;AAEG,gBAAA,GAAG,CAAC,SAAJ,GAAgB,CAAC,KAAI,CAAC,OAAL,CAAa,YAAb,IAA6B,MAAM,CAAC,KAAP,EAA9B,EAA8C,WAA9C,EAAhB;AACA,gBAAA,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,GAAnB,EAAwB,CAAC,GAAzB;AACA,gBAAA,GAAG,CAAC,SAAJ,CAAc,OAAd,EAAuB,OAAvB,EAAgC,QAAhC,EAA0C,QAA1C;AACA,gBAAA,GAAG,CAAC,SAAJ,CACK,KADL,EAEK,CAFL,EAGK,CAHL,EAIK,KAAG,CAAC,KAJT,EAKK,KAAG,CAAC,MALT,EAMM,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,CAAD,CANxC,EAOO,OAAD,GAAa,QAAQ,GAAG,WAAW,CAAC,CAAD,CAApC,GAA4C,GAPjD,EAQK,QARL,EASK,QATL;AAYH;AApGJ;;AAuGA,YAAA,GAAG,CAAC,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,CAAhC;AAEA,YAAA,QAAQ;AACX,WAlHD;AAmHH;;;wBA3K4B,CAIjC;AACA;AACA;AACA;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAqC;gBAA5B,C;AAmKR;AACJ;AACJ,GAlNO;AAoNR;;;;;;AAIQ,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AAEI,QAAI,UAAU,GAAW,KAAK,MAAL,CAAY,MAAZ,IAAsB,CAA/C;AACA,QAAI,QAAQ,GAAY,KAAK,OAAL,CAAa,SAAb,IAA0B,CAAlD;AACA,QAAI,OAAO,GAAW,KAAK,aAAL,IAAsB,CAA5C;;AAEA,YAAQ,KAAK,OAAL,CAAa,MAArB;AACI,WAAK,CAAL;AACI;AACA,eAAO,IAAI,OAAJ,CACF,QAAQ,GAAG,UAAZ,GAA2B,IAAI,OAAJ,GAAc,UADtC,EAEF,QAAD,GAAc,IAAI,OAFf,CAAP;AAIJ;;AACA,WAAK,CAAL;AACI;AACA,YAAI,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,IAAL,CAAU,UAAV,CAAV,CAAZ,CAAhB;AACA,YAAI,IAAI,GAAI,QAAQ,GAAG,SAAZ,GAA0B,IAAI,OAAJ,GAAc,SAAnD;AACA,eAAO,IAAI,OAAJ,CAAY,IAAZ,EAAkB,IAAlB,CAAP;AACJ;;AACA,WAAK,CAAL;AACI;AACA,YAAI,IAAI,GAAG,KAAK,OAAL,CAAa,MAAb,IAAuB,CAAlC;AACA,YAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,UAAU,GAAG,IAAvB,CAAZ,CAAb;AACA,eAAO,IAAI,OAAJ,CACF,QAAQ,GAAG,IAAZ,GAAqB,IAAI,OAAJ,GAAc,IADhC,EAEF,QAAQ,GAAG,MAAZ,GAAuB,IAAI,OAAJ,GAAc,MAFlC,CAAP;AAIJ;AAtBJ;;AAyBA,WAAO,OAAO,CAAC,IAAR,EAAP;AACH,GAhCO;AAkCR;;;;;;;;;;AAQQ,EAAA,aAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,QAA/B,EAAiD,OAAjD,EAAkE,MAAlE,EAAmF,OAAnF,EAAqG,MAArG,EAAoH;AAChH,QAAI,UAAU,GAAG,KAAK,MAAL,CAAY,MAA7B;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,UAAI,CAAC,GAAG,KAAK,MAAL,CAAY,CAAZ,CAAR;AAEA,UAAI,KAAK,GAAG,IAAI,OAAJ,CACR,QAAQ,GAAG,MAAM,CAAC,CADV,EAER,QAAQ,GAAG,MAAM,CAAC,CAFV,CAAZ;AAKA,UAAI,OAAO,GAAY,OAAO,CAAC,KAAR,GAAgB,KAAhB,CAAsB,OAAtB,CAAvB;;AACA,UAAI,WAAW,GAAY,KAAK,eAAL,CAAqB,CAArB,CAA3B;;AACA,UAAI,MAAM,GAAY,WAAW,CAAC,GAAZ,CAAgB,OAAhB,CAAtB;AAEA,UAAI,KAAK,GAAuB,IAAI,kBAAJ,CAAuB,CAAvB,EAA0B,KAA1B,EAAiC,MAAjC,CAAhC;AAEA,WAAK,MAAL,CAAY,IAAZ,CACI,KADJ,EAdiC,CAkBjC;;AACA,UAAI,MAAJ,EAAY;AACR,aAAK,aAAL,CAAmB,CAAnB,EAAsB,CAAtB;;AACA,aAAK,wBAAL,CAA8B,CAA9B;AACH;AACJ;AACJ,GA3BO;AA6BR;;;;;;;AAKQ,EAAA,aAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,KAAxB,EAAqC;AAEjC,QAAI,UAAU,GAAG,KAAK,MAAL,CAAY,MAA7B;AACA,QAAI,MAAJ,EAAY,KAAZ,EAAmB,KAAnB;;AAEA,YAAQ,KAAK,OAAL,CAAa,MAArB;AACI,WAAK,CAAL;AACI;AACA,QAAA,MAAM,GAAG,IAAI,UAAb;AACA,eAAO,IAAI,OAAJ,CACH,KAAK,GAAG,MADL,EAEH,CAFG,CAAP;AAIJ;;AACA,WAAK,CAAL;AACI;AACA,YAAI,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,IAAL,CAAU,UAAV,CAAV,CAAZ,CAAhB;AACA,QAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,SAAnB,CAAR;AACA,QAAA,KAAK,GAAG,KAAK,GAAI,KAAK,GAAG,SAAzB;AACA,QAAA,MAAM,GAAG,IAAI,SAAb;AACA,eAAO,IAAI,OAAJ,CAAY,KAAK,GAAG,MAApB,EAA6B,KAAK,GAAG,MAArC,CAAP;AACJ;;AACA,WAAK,CAAL;AACI;AACA,YAAI,IAAI,GAAG,KAAK,OAAL,CAAa,MAAb,IAAuB,CAAlC;AACA,YAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,UAAU,GAAG,IAAvB,CAAZ,CAAb;AACA,QAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,MAAnB,CAAR;AACA,QAAA,KAAK,GAAG,KAAK,GAAI,KAAK,GAAG,MAAzB;AACA,QAAA,MAAM,GAAG,IAAI,OAAJ,CAAY,IAAI,IAAhB,EAAsB,IAAI,MAA1B,CAAT;AACA,eAAO,IAAI,OAAJ,CAAY,KAAK,GAAG,MAAM,CAAC,CAA3B,EAA+B,KAAK,GAAG,MAAM,CAAC,CAA9C,CAAP;AACJ;AAzBJ;;AA4BA,WAAO,OAAO,CAAC,IAAR,EAAP;AACH,GAlCO;AAoCR;;;;;;;AAKQ,EAAA,aAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,IAAtB,EAA0C,OAA1C,EAAyD;AACrD,QAAI,KAAK,GAAwB,KAAK,MAAL,CAAoB,OAApB,CAAjC;AACA,QAAI,IAAI,GAAG,IAAI,CAAC,eAAL,CAAqB,KAAK,OAAL,CAAa,KAAb,IAAsB,YAAY,CAAC,MAAxD,CAAX;AACA,QAAI,KAAK,GAAG,EAAZ;AACA,QAAI,OAAO,GAAG,CAAd;;AAEA,QAAI,IAAK,CAAC,MAAV,EAAkB;AACd,MAAA,OAAO,GAAG,IAAK,CAAC,MAAN,IAAgB,CAA1B;AACH;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAApB,EAA6B,CAAC,IAAI,CAAlC,EAAqC;AACjC,MAAA,KAAK,CAAC,IAAN,CACM,IAAY,CAAC,CAAD,CAAZ,GAAkB,KAAK,CAAC,KAAN,CAAY,CAAhC,GAAqC,KAAK,CAAC,MAAN,CAAa,CADtD,EAEM,IAAY,CAAC,CAAC,GAAG,CAAL,CAAZ,GAAsB,KAAK,CAAC,KAAN,CAAY,CAApC,GAAyC,KAAK,CAAC,MAAN,CAAa,CAF1D;AAIH;;AAED,IAAA,IAAI,CAAC,eAAL,CAAqB,KAAK,OAAL,CAAa,MAAb,IAAuB,YAAY,CAAC,MAAzD,EAAiE,KAAjE;AACH,GAlBO;AAoBR;;;;;;;AAKQ,EAAA,aAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,CAAjC,EAAkD,KAAlD,EAAwE;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAsB;;AACpE,QAAI,GAAG,GAAG,CAAC,CAAC,QAAZ;AACA,QAAI,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,IAAjB,CAAZ;;AAEA,QAAI,QAAQ,GAAG,UAAC,EAAD,EAAQ;AAClB,UAAK,EAAE,CAAC,OAAR,EAAkB;AACf,QAAA,EAAE,CAAC,OAAH;AACF;AACL,KAJD;;AAMA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,UAAI,OAAO,GAAG,KAAK,CAAC,CAAD,CAAnB;;AACA,UAAI,CAAC,KAAL,EAAY;AACR,YAAI,CAAC,GAAL,EAAU;AACN;AACH;;AACD,YAAK,GAAW,CAAC,OAAD,CAAX,KAAyB,IAA9B,EAAoC;AAChC,UAAA,QAAQ,CAAE,GAAW,CAAC,OAAD,CAAb,CAAR;;AACC,UAAA,GAAW,CAAC,OAAD,CAAX,GAAwB,KAAK,IAAL,CAAkB,OAAlB,CAAxB;AACJ;AACJ,OARD,MAQO;AACH,YAAK,GAAW,CAAC,OAAD,CAAX,KAAyB,IAA9B,EAAoC;AAChC,UAAA,QAAQ,CAAE,GAAW,CAAC,OAAD,CAAb,CAAR;AACH;;AACA,QAAA,GAAW,CAAC,OAAD,CAAX,GAAwB,KAAK,IAAL,CAAkB,OAAlB,CAAxB;AACJ;AACJ;AACJ,GA3BO;AA6BR;;;;;;;;AAMO,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAuC,OAAvC,EAAwD,cAAxD,EAAuF;AAA/B,QAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,cAAA,GAAA,KAAA;AAA+B;;AACnF,SAAK,aAAL,CAAmB,CAAnB,EAAsB,OAAtB;;AACA,QAAI,cAAJ,EAAoB;AAChB,WAAK,wBAAL,CAA8B,CAA9B,EAAiC,IAAjC;AACH;AACJ,GALM;AAOP;;;;;;AAIO,EAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACQ,WAAO,IAAI,OAAJ,CAAa,UAAC,OAAD,EAAU,MAAV,EAAgB;AAChC,UAAI;AACA,YAAI,KAAI,CAAC,MAAL,CAAY,MAAZ,KAAuB,CAA3B,EAA8B;AAC1B;AACA,UAAA,OAAO;AACP;AACH;;AACD,YAAI,MAAI,GAAG,CAAX;;AACA,YAAM,WAAS,GAAG,UAAC,GAAD,EAAc;AAC5B,UAAA,MAAI,GADwB,CAE5B;;AACA,cAAI,KAAI,CAAC,OAAL,CAAa,GAAjB,EAAsB;AAClB,iBAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,MAArC,EAA6C,CAAC,EAA9C,EAAkD;AAC9C,kBAAI,KAAK,GAAW,KAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,CAAjB,CAApB;AACA,kBAAI,CAAC,GAAgC,GAAW,CAAC,KAAD,CAAhD;;AAEA,kBAAI,CAAC,KAAK,IAAV,EAAgB;AACZ,oBAAI,CAAE,KAAI,CAAC,IAAL,CAAkB,KAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,CAAjB,CAAlB,CAAN,EAA8C;AACzC,kBAAA,KAAI,CAAC,IAAL,CAAkB,KAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,CAAjB,CAAlB,IAAyC,IAAzC;AACJ;;AAED,gBAAA,KAAI,CAAC,UAAL;AACH;AACJ;;AAED,gBAAI,MAAI,KAAK,KAAI,CAAC,MAAL,CAAY,MAAzB,EAAiC;AAC7B,cAAA,KAAI,CAAC,aAAL,CAAmB,OAAnB;AACH;AACJ;AACJ,SArBD;;gCAuBS,C,EAAC;AAEN,cAAI,IAAI,GAAG,KAAI,CAAC,MAAL,CAAY,CAAZ,CAAX;AACA,cAAI,QAAQ,GAAyB,IAAI,CAAC,QAA1C;;AAEA,cAAI,CAAC,QAAL,EAAe;AACX,YAAA,MAAI;;AACJ,gBAAI,MAAI,KAAK,KAAI,CAAC,MAAL,CAAY,MAAzB,EAAiC;;uBACtB,KAAI,CAAC,aAAL,CAAmB,OAAnB;;AACV;;;AAEJ;;AAED,UAAA,QAAQ,CAAC,qBAAT,CAA+B,IAA/B,EAAqC,IAArC,CAA0C,YAAA;AACtC,YAAA,WAAS,CAAE,QAAF,CAAT;AACH,WAFD;;;AAbJ,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAI,CAAC,MAAL,CAAY,MAAhC,EAAwC,CAAC,EAAzC,EAA2C;gCAAlC,C;;;AAgBR;AACJ,OA/CD,CA+CE,OAAO,CAAP,EAAU;AACR,eAAO,MAAM,CAAC,CAAD,CAAb;AACH;AACJ,KAnDM,CAAP;AAoDP,GArDM;AAuDP;;;;;AAGO,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,IAAjB,CAAZ;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,UAAI,OAAO,GAAG,KAAK,CAAC,CAAD,CAAnB;AACC,WAAK,IAAL,CAAkB,OAAlB,EAA2B,OAA3B;AACJ;AACJ,GANM;AAQP;;;;;;;AAKO,EAAA,aAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,SAAhB,EAA2C,OAA3C,EAA8D;AAA9D,QAAA,KAAA,GAAA,IAAA;;AAAgB,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,KAAA;AAAyB;;AAAE,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,CAAA;AAAmB;;AAC1D,IAAA,UAAU,CAAC,YAAA;AACP,UAAI,IAAI,GAAG;AACP,QAAA,IAAI,EAAG,KAAI,CAAC,IADL;AAEP,QAAA,IAAI,EAAG,EAFA;AAGP,QAAA,OAAO,EAAE,EAHF;AAIP,QAAA,MAAM,EAAG;AAJF,OAAX;AAOA,UAAI,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAI,CAAC,IAAjB,CAAZ;AACA,UAAI,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAAI,CAAC,OAAjB,CAAZ;;AACA,UAAI;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,cAAI,OAAO,GAAW,KAAK,CAAC,CAAD,CAA3B;AACA,cAAI,EAAE,GAAK,KAAI,CAAC,IAAL,CAAkB,OAAlB,CAAX;AACC,UAAA,IAAI,CAAC,IAAL,CAAkB,OAAlB,IAA6B,EAAE,CAAC,UAAH,GAAgB,MAAhB,CAAuB,SAAvB,CAAiC,WAAW,SAA5C,EAAuD,OAAvD,CAA7B;AACJ;;AACD,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,cAAI,GAAG,GAAW,KAAK,CAAC,CAAD,CAAvB;AACC,UAAA,IAAI,CAAC,OAAL,CAAqB,GAArB,IAA6B,KAAI,CAAC,OAAL,CAAqB,GAArB,CAA7B;AACJ;;AACD,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAI,CAAC,MAAL,CAAY,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AACzC,cAAI,EAAE,GAAG,KAAI,CAAC,MAAL,CAAY,CAAZ,CAAT;AACC,UAAA,IAAI,CAAC,MAAL,CAA8B,IAA9B,CAAmC,EAAE,CAAC,KAAH,CAAS,CAA5C,EAA+C,EAAE,CAAC,KAAH,CAAS,CAAxD,EAA2D,EAAE,CAAC,MAAH,CAAU,CAArE,EAAwE,EAAE,CAAC,MAAH,CAAU,CAAlF;AACJ;AAEJ,OAfD,CAeE,OAAO,GAAP,EAAY;AACV,QAAA,MAAM,CAAC,IAAP,CAAY,yBAAyB,GAArC;AACA;AACH;;AAED,UAAI,IAAI,GAAG,kCAAkC,kBAAkB,CAAC,IAAI,CAAC,SAAL,CAAe,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAAD,CAA/D;;AACA,UAAI,EAAE,GAAG,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAAT;;AACA,MAAA,EAAE,CAAC,YAAH,CAAgB,MAAhB,EAAwB,IAAxB;;AACA,MAAA,EAAE,CAAC,YAAH,CAAgB,UAAhB,EAA4B,KAAI,CAAC,IAAL,GAAY,qBAAxC;;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,EAA1B;;AACA,MAAA,EAAE,CAAC,KAAH;;AACA,MAAA,EAAE,CAAC,MAAH;AAEH,KAtCS,EAsCP,CAtCO,CAAV;AAuCH,GAxCM;AA0CP;;;;;;AAIO,EAAA,aAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,IAAtB,EAAkC;AAC9B,QAAI;AACA,UAAI,UAAU,GAAuB,IAAI,CAAC,KAAL,CAAW,IAAX,CAArC;AACA,WAAK,IAAL,GAAY,UAAU,CAAC,IAAvB;;AACA,UAAI,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,OAAvB,CAAf;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACrC,aAAK,OAAL,CAAqB,QAAQ,CAAC,CAAD,CAA7B,IAAqC,UAAU,CAAC,OAAX,CAA2B,QAAQ,CAAC,CAAD,CAAnC,CAArC;AACJ;;AAED,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAAX,CAAkB,MAAtC,EAA8C,CAAC,IAAI,CAAnD,EAAsD;AAClD,YAAI,KAAK,GAAuB,IAAI,kBAAJ,CAC5B,CAAC,GAAG,CADwB,EAE5B,IAAI,OAAJ,CAAY,UAAU,CAAC,MAAX,CAAkB,CAAlB,CAAZ,EAAkC,UAAU,CAAC,MAAX,CAAkB,CAAC,GAAG,CAAtB,CAAlC,CAF4B,EAG5B,IAAI,OAAJ,CAAY,UAAU,CAAC,MAAX,CAAkB,CAAC,GAAG,CAAtB,CAAZ,EAAsC,UAAU,CAAC,MAAX,CAAkB,CAAC,GAAG,CAAtB,CAAtC,CAH4B,CAAhC;AAKJ,aAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;AACC;;AAED,UAAI,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,UAAU,CAAC,IAAvB,CAAf;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACtC,YAAI,EAAE,GAAG,IAAI,OAAJ,CAAY,UAAU,CAAC,IAAX,CAAgB,QAAQ,CAAC,CAAD,CAAxB,CAAZ,EAA0C,KAAK,KAA/C,EAAsD,KAAtD,EAA6D,KAA7D,CAAT;;AACC,aAAK,IAAL,CAAkB,QAAQ,CAAC,CAAD,CAA1B,IAAiC,EAAjC;AACJ;AACJ,KAxBD,CAwBE,OAAO,GAAP,EAAY;AACV,MAAA,MAAM,CAAC,IAAP,CAAY,iCAAiC,GAA7C;AACH;AACJ,GA5BM;AA7nBP;;;AACuB,EAAA,aAAA,CAAA,YAAA,GAAe,CAAf;AACvB;;AACuB,EAAA,aAAA,CAAA,aAAA,GAAgB,CAAhB;AACvB;;AACuB,EAAA,aAAA,CAAA,aAAA,GAAgB,CAAhB;AAEvB;;AACuB,EAAA,aAAA,CAAA,UAAA,GAAa,CAAb;AACvB;;AACuB,EAAA,aAAA,CAAA,YAAA,GAAe,CAAf;AACvB;;AACuB,EAAA,aAAA,CAAA,WAAA,GAAc,CAAd;AA8oB3B,SAAA,aAAA;AAAC,CA5pBD,EAAA;;SAAa,a","sourcesContent":["import { Engine } from \"../../../Engines/engine\";\r\nimport { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { Material } from \"../../material\";\r\nimport { Texture } from \"../texture\";\r\nimport { DynamicTexture } from \"../dynamicTexture\";\r\nimport { Nullable } from \"../../../types\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\r\nimport { TexturePackerFrame } from \"./frame\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Tools } from '../../../Misc/tools';\r\n\r\n/**\r\n* Defines the basic options interface of a TexturePacker\r\n*/\r\nexport interface ITexturePackerOptions{\r\n\r\n    /**\r\n    * Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material\r\n    */\r\n    map?: string[];\r\n\r\n    /**\r\n    * the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind\r\n    */\r\n    uvsIn?: string;\r\n\r\n    /**\r\n    * the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind\r\n    */\r\n    uvsOut?: string;\r\n\r\n    /**\r\n    * number representing the layout style. Defaults to LAYOUT_STRIP\r\n    */\r\n    layout?: number;\r\n\r\n    /**\r\n    * number of columns if using custom column count layout(2).  This defaults to 4.\r\n    */\r\n    colnum?: number;\r\n\r\n    /**\r\n    * flag to update the input meshes to the new packed texture after compilation. Defaults to true.\r\n    */\r\n    updateInputMeshes?: boolean;\r\n\r\n    /**\r\n    * boolean flag to dispose all the source textures.  Defaults to true.\r\n    */\r\n    disposeSources?: boolean;\r\n\r\n    /**\r\n    * Fills the blank cells in a set to the customFillColor.  Defaults to true.\r\n    */\r\n    fillBlanks?: boolean;\r\n\r\n    /**\r\n    * string value representing the context fill style color.  Defaults to 'black'.\r\n    */\r\n    customFillColor?: string;\r\n\r\n    /**\r\n    * Width and Height Value of each Frame in the TexturePacker Sets\r\n    */\r\n    frameSize?: number;\r\n\r\n    /**\r\n    * Ratio of the value to add padding wise to each cell.  Defaults to 0.0115\r\n    */\r\n    paddingRatio?: number;\r\n\r\n    /**\r\n    * Number that declares the fill method for the padding gutter.\r\n    */\r\n    paddingMode?: number;\r\n\r\n    /**\r\n    * If in SUBUV_COLOR padding mode what color to use.\r\n    */\r\n    paddingColor?: Color3 | Color4;\r\n\r\n}\r\n\r\n/**\r\n* Defines the basic interface of a TexturePacker JSON File\r\n*/\r\nexport interface ITexturePackerJSON{\r\n\r\n    /**\r\n    * The frame ID\r\n    */\r\n    name: string;\r\n\r\n    /**\r\n    * The base64 channel data\r\n    */\r\n    sets: any;\r\n\r\n    /**\r\n    * The options of the Packer\r\n    */\r\n    options: ITexturePackerOptions;\r\n\r\n    /**\r\n    * The frame data of the Packer\r\n    */\r\n    frames: Array<number>;\r\n\r\n}\r\n\r\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\r\nexport class TexturePacker{\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly LAYOUT_STRIP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly LAYOUT_POWER2 = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly LAYOUT_COLNUM = 2;\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly SUBUV_WRAP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly SUBUV_EXTEND = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly SUBUV_COLOR = 2;\r\n\r\n    /** The Name of the Texture Package */\r\n    public name: string;\r\n\r\n    /** The scene scope of the TexturePacker */\r\n    public scene: Scene;\r\n\r\n    /** The Meshes to target */\r\n    public meshes: AbstractMesh[];\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ITexturePackerOptions;\r\n\r\n    /** The promise that is started upon initialization */\r\n    public promise: Nullable<Promise< TexturePacker | string >>;\r\n\r\n    /** The Container object for the channel sets that are generated */\r\n    public sets: object;\r\n\r\n    /** The Container array for the frames that are generated */\r\n    public frames: TexturePackerFrame[];\r\n\r\n    /** The expected number of textures the system is parsing. */\r\n    private _expecting: number;\r\n\r\n    /** The padding value from Math.ceil(frameSize * paddingRatio) */\r\n    private _paddingValue: number;\r\n\r\n    /**\r\n    * Initializes a texture package series from an array of meshes or a single mesh.\r\n    * @param name The name of the package\r\n    * @param meshes The target meshes to compose the package from\r\n    * @param options The arguments that texture packer should follow while building.\r\n    * @param scene The scene which the textures are scoped to.\r\n    * @returns TexturePacker\r\n    */\r\n    constructor(name: string, meshes: AbstractMesh[], options: ITexturePackerOptions, scene: Scene) {\r\n\r\n        this.name = name;\r\n        this.meshes = meshes;\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        this.options.map = this.options.map ?? [\r\n                'ambientTexture',\r\n                'bumpTexture',\r\n                'diffuseTexture',\r\n                'emissiveTexture',\r\n                'lightmapTexture',\r\n                'opacityTexture',\r\n                'reflectionTexture',\r\n                'refractionTexture',\r\n                'specularTexture'\r\n            ];\r\n\r\n        this.options.uvsIn = this.options.uvsIn ?? VertexBuffer.UVKind;\r\n        this.options.uvsOut = this.options.uvsOut ?? VertexBuffer.UVKind;\r\n        this.options.layout = this.options.layout ?? TexturePacker.LAYOUT_STRIP;\r\n\r\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\r\n            this.options.colnum = this.options.colnum ?? 8;\r\n        }\r\n\r\n        this.options.updateInputMeshes = this.options.updateInputMeshes ?? true;\r\n        this.options.disposeSources = this.options.disposeSources ?? true;\r\n        this._expecting = 0;\r\n\r\n        this.options.fillBlanks = this.options.fillBlanks ?? true;\r\n\r\n        if (this.options.fillBlanks === true) {\r\n            this.options.customFillColor = this.options.customFillColor ?? 'black';\r\n        }\r\n\r\n        this.options.frameSize = this.options.frameSize ?? 256;\r\n        this.options.paddingRatio = this.options.paddingRatio ?? 0.0115;\r\n\r\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\r\n\r\n        //Make it an even padding Number.\r\n        if (this._paddingValue % 2 !== 0) {\r\n            this._paddingValue++;\r\n        }\r\n\r\n        this.options.paddingMode = this.options.paddingMode ?? TexturePacker.SUBUV_WRAP;\r\n\r\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\r\n            this.options.paddingColor = this.options.paddingColor ?? new Color4(0, 0, 0, 1.0);\r\n        }\r\n\r\n        this.sets = {};\r\n        this.frames = [];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Starts the package process\r\n    * @param resolve The promises resolution function\r\n    * @returns TexturePacker\r\n    */\r\n    private _createFrames(resolve: () => void) {\r\n\r\n        let dtSize = this._calculateSize();\r\n        let dtUnits = (new Vector2(1, 1)).divide(dtSize);\r\n        let doneCount = 0;\r\n        let expecting = this._expecting;\r\n        let meshLength = this.meshes.length;\r\n\r\n        let sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let setName = sKeys[i];\r\n\r\n            let dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set',\r\n                    { width: dtSize.x, height: dtSize.y },\r\n                    this.scene,\r\n                    true, //Generate Mips\r\n                    Texture.TRILINEAR_SAMPLINGMODE,\r\n                    Engine.TEXTUREFORMAT_RGBA\r\n                );\r\n\r\n            let dtx = dt.getContext();\r\n            dtx.fillStyle = 'rgba(0,0,0,0)';\r\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y) ;\r\n            dt.update(false);\r\n            (this.sets as any)[setName] = dt;\r\n        }\r\n\r\n        let baseSize = this.options.frameSize || 256;\r\n        let padding = this._paddingValue;\r\n        let tcs = baseSize + (2 * padding);\r\n\r\n        const done = () => {\r\n            this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\r\n        };\r\n\r\n        //Update the Textures\r\n        for (let i = 0; i < meshLength; i++) {\r\n            let m = this.meshes[i];\r\n            let mat = m.material;\r\n\r\n            //Check if the material has the texture\r\n            //Create a temporary canvas the same size as 1 frame\r\n            //Then apply the texture to the center and the 8 offsets\r\n            //Copy the Context and place in the correct frame on the DT\r\n\r\n            for (let j = 0; j < sKeys.length; j++) {\r\n                let tempTexture = new DynamicTexture('temp', tcs, this.scene, true);\r\n                let tcx = tempTexture.getContext();\r\n                let offset = this._getFrameOffset(i);\r\n\r\n                const updateDt = () => {\r\n                    doneCount++;\r\n                    tempTexture.update(false);\r\n                    let iDat = tcx.getImageData(0, 0, tcs, tcs);\r\n\r\n                    //Update Set\r\n                    let dt = (this.sets as any)[setName];\r\n                    let dtx = dt.getContext();\r\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\r\n                    tempTexture.dispose();\r\n                    dt.update(false);\r\n                    if (doneCount == expecting) {\r\n                        done();\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                };\r\n\r\n                let setName = sKeys[j] || '_blank';\r\n                if (!mat || (mat as any)[setName] === null) {\r\n                    tcx.fillStyle = 'rgba(0,0,0,0)';\r\n\r\n                    if (this.options.fillBlanks) {\r\n                        tcx.fillStyle = (this.options.customFillColor as string);\r\n                    }\r\n\r\n                    tcx.fillRect(0, 0, tcs, tcs);\r\n\r\n                    updateDt();\r\n\r\n                } else {\r\n\r\n                    let setTexture = (mat as any)[setName];\r\n                    let img = new Image();\r\n\r\n                    if (setTexture instanceof DynamicTexture) {\r\n                        img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\r\n                    } else {\r\n                        img.src = setTexture!.url;\r\n                    }\r\n                    Tools.SetCorsBehavior(img.src, img);\r\n\r\n                    img.onload = () => {\r\n                        tcx.fillStyle = 'rgba(0,0,0,0)';\r\n                        tcx.fillRect(0, 0, tcs, tcs);\r\n                        tempTexture.update(false);\r\n\r\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\r\n                        let cellOffsets = [ 0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\r\n\r\n                        switch (this.options.paddingMode){\r\n                            //Wrap Mode\r\n                            case 0:\r\n                                for (let i = 0; i < 9; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        (padding) + (baseSize * cellOffsets[i]),\r\n                                        ((padding) + (baseSize * cellOffsets[i + 1])) - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n                            break;\r\n                            //Extend Mode\r\n                            case 1:\r\n                                for (let i = 0; i < padding; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        i + (baseSize * cellOffsets[0]),\r\n                                        padding - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        (padding * 2) - i,\r\n                                        padding - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding,\r\n                                        i - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding,\r\n                                        (padding * 2) - i - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n\r\n                                tcx.drawImage(\r\n                                    img,\r\n                                    0,\r\n                                    0,\r\n                                    img.width,\r\n                                    img.height,\r\n                                    (padding) + (baseSize * cellOffsets[0]),\r\n                                    ((padding) + (baseSize * cellOffsets[1])) - tcs,\r\n                                    baseSize,\r\n                                    baseSize\r\n                                );\r\n\r\n                            break;\r\n                            //Color Mode\r\n                            case 2:\r\n\r\n                               tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\r\n                               tcx.fillRect(0, 0, tcs, -tcs);\r\n                               tcx.clearRect(padding, padding, baseSize, baseSize);\r\n                               tcx.drawImage(\r\n                                    img,\r\n                                    0,\r\n                                    0,\r\n                                    img.width,\r\n                                    img.height,\r\n                                    (padding) + (baseSize * cellOffsets[0]),\r\n                                    ((padding) + (baseSize * cellOffsets[1])) - tcs,\r\n                                    baseSize,\r\n                                    baseSize\r\n                                );\r\n\r\n                            break;\r\n                        }\r\n\r\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n                        updateDt();\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Calculates the Size of the Channel Sets\r\n    * @returns Vector2\r\n    */\r\n    private _calculateSize(): Vector2 {\r\n\r\n        let meshLength: number = this.meshes.length || 0;\r\n        let baseSize: number =  this.options.frameSize || 0;\r\n        let padding: number = this._paddingValue || 0;\r\n\r\n        switch (this.options.layout){\r\n            case 0 :\r\n                //STRIP_LAYOUT\r\n                return new Vector2(\r\n                    (baseSize * meshLength) + (2 * padding * meshLength),\r\n                    (baseSize) + (2 * padding)\r\n                );\r\n            break;\r\n            case 1 :\r\n                //POWER2\r\n                let sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                let size = (baseSize * sqrtCount) + (2 * padding * sqrtCount);\r\n                return new Vector2(size, size);\r\n            break;\r\n            case 2 :\r\n                //COLNUM\r\n                let cols = this.options.colnum || 1;\r\n                let rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                return new Vector2(\r\n                    (baseSize * cols) + (2 * padding * cols),\r\n                    (baseSize * rowCnt) + (2 * padding * rowCnt)\r\n                );\r\n            break;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n    * Calculates the UV data for the frames.\r\n    * @param baseSize the base frameSize\r\n    * @param padding the base frame padding\r\n    * @param dtSize size of the Dynamic Texture for that channel\r\n    * @param dtUnits is 1/dtSize\r\n    * @param update flag to update the input meshes\r\n    */\r\n    private _calculateMeshUVFrames(baseSize: number, padding: number, dtSize: Vector2, dtUnits: Vector2, update: boolean) {\r\n        let meshLength = this.meshes.length;\r\n\r\n        for (let i = 0; i < meshLength; i++) {\r\n            let m = this.meshes[i];\r\n\r\n            let scale = new Vector2(\r\n                baseSize / dtSize.x,\r\n                baseSize / dtSize.y,\r\n            );\r\n\r\n            let pOffset: Vector2 = dtUnits.clone().scale(padding);\r\n            let frameOffset: Vector2 = this._getFrameOffset(i);\r\n            let offset: Vector2 = frameOffset.add(pOffset);\r\n\r\n            let frame: TexturePackerFrame = new TexturePackerFrame(i, scale, offset);\r\n\r\n            this.frames.push(\r\n                frame\r\n            );\r\n\r\n            //Update Output UVs\r\n            if (update) {\r\n                this._updateMeshUV(m, i);\r\n                this._updateTextureReferences(m);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Calculates the frames Offset.\r\n    * @param index of the frame\r\n    * @returns Vector2\r\n    */\r\n    private _getFrameOffset(index: number): Vector2 {\r\n\r\n        let meshLength = this.meshes.length;\r\n        let uvStep, yStep, xStep;\r\n\r\n        switch (this.options.layout){\r\n            case 0 :\r\n                //STRIP_LAYOUT\r\n                uvStep = 1 / meshLength;\r\n                return new Vector2(\r\n                    index * uvStep,\r\n                    0\r\n                );\r\n            break;\r\n            case 1 :\r\n                //POWER2\r\n                let sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                yStep = Math.floor(index / sqrtCount);\r\n                xStep = index - (yStep * sqrtCount);\r\n                uvStep = 1 / sqrtCount;\r\n                return new Vector2(xStep * uvStep , yStep * uvStep);\r\n            break;\r\n            case 2 :\r\n                //COLNUM\r\n                let cols = this.options.colnum || 1;\r\n                let rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                xStep = Math.floor(index / rowCnt);\r\n                yStep = index - (xStep * rowCnt);\r\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\r\n                return new Vector2(xStep * uvStep.x , yStep * uvStep.y);\r\n            break;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n    * Updates a Mesh to the frame data\r\n    * @param mesh that is the target\r\n    * @param frameID or the frame index\r\n    */\r\n    private _updateMeshUV(mesh: AbstractMesh, frameID: number): void {\r\n        let frame: TexturePackerFrame = (this.frames as any)[frameID];\r\n        let uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\r\n        let uvOut = [];\r\n        let toCount = 0;\r\n\r\n        if (uvIn!.length) {\r\n            toCount = uvIn!.length || 0;\r\n        }\r\n\r\n        for (let i = 0; i < toCount; i += 2) {\r\n            uvOut.push(\r\n                ((uvIn as any)[i] * frame.scale.x) + frame.offset.x,\r\n                ((uvIn as any)[i + 1] * frame.scale.y) + frame.offset.y\r\n            );\r\n        }\r\n\r\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\r\n    }\r\n\r\n    /**\r\n    * Updates a Meshes materials to use the texture packer channels\r\n    * @param m is the mesh to target\r\n    * @param force all channels on the packer to be set.\r\n    */\r\n    private _updateTextureReferences(m: AbstractMesh, force: boolean = false): void {\r\n        let mat = m.material;\r\n        let sKeys = Object.keys(this.sets);\r\n\r\n        let _dispose = (_t: any) => {\r\n             if ((_t.dispose)) {\r\n                _t.dispose();\r\n             }\r\n        };\r\n\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let setName = sKeys[i];\r\n            if (!force) {\r\n                if (!mat) {\r\n                    return;\r\n                }\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                    (mat as any)[setName] = (this.sets as any)[setName];\r\n                }\r\n            } else {\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                }\r\n                (mat as any)[setName] = (this.sets as any)[setName];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Public method to set a Mesh to a frame\r\n    * @param m that is the target\r\n    * @param frameID or the frame index\r\n    * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n    */\r\n    public setMeshToFrame(m: AbstractMesh, frameID: number, updateMaterial: boolean = false): void {\r\n        this._updateMeshUV(m, frameID);\r\n        if (updateMaterial) {\r\n            this._updateTextureReferences(m, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Starts the async promise to compile the texture packer.\r\n    * @returns Promise<void>\r\n    */\r\n    public processAsync(): Promise<void> {\r\n            return new Promise ((resolve, reject) => {\r\n                try {\r\n                    if (this.meshes.length === 0) {\r\n                        //Must be a JSON load!\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                    let done = 0;\r\n                    const doneCheck = (mat: Material) => {\r\n                        done++;\r\n                        //Check Status of all Textures on all meshes, till they are ready.\r\n                        if (this.options.map) {\r\n                            for (let j = 0; j < this.options.map.length; j++) {\r\n                                let index: string = this.options.map[j];\r\n                                let t: (Texture | DynamicTexture) = (mat as any)[index];\r\n\r\n                                if (t !== null) {\r\n                                    if (!(this.sets as any)[this.options.map[j]]) {\r\n                                        (this.sets as any)[this.options.map[j]] = true;\r\n                                    }\r\n\r\n                                    this._expecting++;\r\n                                }\r\n                            }\r\n\r\n                            if (done === this.meshes.length) {\r\n                                this._createFrames(resolve);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    for (let i = 0; i < this.meshes.length; i++) {\r\n\r\n                        let mesh = this.meshes[i];\r\n                        let material: Nullable< Material > = mesh.material;\r\n\r\n                        if (!material) {\r\n                            done++;\r\n                            if (done === this.meshes.length) {\r\n                                return this._createFrames(resolve);\r\n                            }\r\n                            continue;\r\n                        }\r\n\r\n                        material.forceCompilationAsync(mesh).then(() => {\r\n                            doneCheck((material as Material));\r\n                        });\r\n                    }\r\n                } catch (e) {\r\n                    return reject(e);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n    * Disposes all textures associated with this packer\r\n    */\r\n    public dispose(): void {\r\n        let sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let channel = sKeys[i];\r\n            (this.sets as any)[channel].dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n    * @param imageType is the image type to use.\r\n    * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n    */\r\n    public download(imageType: string = 'png', quality: number = 1): void {\r\n        setTimeout(() => {\r\n            let pack = {\r\n                name : this.name,\r\n                sets : {},\r\n                options: {},\r\n                frames : []\r\n            };\r\n\r\n            let sKeys = Object.keys(this.sets);\r\n            let oKeys = Object.keys(this.options);\r\n            try {\r\n                for (let i = 0; i < sKeys.length; i++) {\r\n                    let channel: string = sKeys[i];\r\n                    let dt =  (this.sets as any)[channel];\r\n                    (pack.sets as any)[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\r\n                }\r\n                for (let i = 0; i < oKeys.length; i++) {\r\n                    let opt: string = oKeys[i];\r\n                    (pack.options as any)[opt] = (this.options as any)[opt];\r\n                }\r\n                for (let i = 0; i < this.frames.length; i++) {\r\n                    let _f = this.frames[i];\r\n                    (pack.frames as Array<number>).push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\r\n                }\r\n\r\n            } catch (err) {\r\n                Logger.Warn(\"Unable to download: \" + err);\r\n                return;\r\n            }\r\n\r\n            let data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\r\n            let _a = document.createElement('a');\r\n            _a.setAttribute(\"href\", data);\r\n            _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\r\n            document.body.appendChild(_a);\r\n            _a.click();\r\n            _a.remove();\r\n\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n    * Public method to load a texturePacker JSON file.\r\n    * @param data of the JSON file in string format.\r\n    */\r\n    public updateFromJSON(data: string): void {\r\n        try {\r\n            let parsedData: ITexturePackerJSON = JSON.parse(data);\r\n            this.name = parsedData.name;\r\n            let _options = Object.keys(parsedData.options);\r\n\r\n            for (let i = 0; i < _options.length; i++) {\r\n                (this.options as any)[_options[i]] = (parsedData.options as any)[_options[i]];\r\n            }\r\n\r\n            for (let i = 0; i < parsedData.frames.length; i += 4) {\r\n                let frame: TexturePackerFrame = new TexturePackerFrame(\r\n                    i / 4,\r\n                    new Vector2(parsedData.frames[i], parsedData.frames[i + 1]),\r\n                    new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3])\r\n                );\r\n            this.frames.push(frame);\r\n            }\r\n\r\n            let channels = Object.keys(parsedData.sets);\r\n\r\n            for (let i = 0; i < channels.length; i++) {\r\n                let _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\r\n                (this.sets as any)[channels[i]] = _t;\r\n            }\r\n        } catch (err) {\r\n            Logger.Warn(\"Unable to update from JSON: \" + err);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}