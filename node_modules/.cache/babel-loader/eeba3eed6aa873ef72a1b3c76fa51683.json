{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { TargetCamera } from \"./targetCamera\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { FollowCameraInputsManager } from './followCameraInputsManager';\nNode.AddNodeConstructor(\"FollowCamera\", function (name, scene) {\n  return function () {\n    return new FollowCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", function (name, scene) {\n  return function () {\n    return new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n  };\n});\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\n\nvar FollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(FollowCamera, _super);\n  /**\r\n   * Instantiates the follow camera.\r\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n   * @param name Define the name of the camera in the scene\r\n   * @param position Define the position of the camera\r\n   * @param scene Define the scene the camera belong to\r\n   * @param lockedTarget Define the target of the camera\r\n   */\n\n\n  function FollowCamera(name, position, scene, lockedTarget) {\n    if (lockedTarget === void 0) {\n      lockedTarget = null;\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\n\n\n    _this.radius = 12;\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerRadiusLimit = null;\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperRadiusLimit = null;\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\n\n    _this.rotationOffset = 0;\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerRotationOffsetLimit = null;\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperRotationOffsetLimit = null;\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chaing a plane)\r\n     */\n\n    _this.heightOffset = 4;\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerHeightOffsetLimit = null;\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperHeightOffsetLimit = null;\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\n\n    _this.cameraAcceleration = 0.05;\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\n\n    _this.maxCameraSpeed = 20;\n    _this.lockedTarget = lockedTarget;\n    _this.inputs = new FollowCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouseWheel().addPointers();\n\n    return _this; // Uncomment the following line when the relevant handlers have been implemented.\n    // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n  }\n\n  FollowCamera.prototype._follow = function (cameraTarget) {\n    if (!cameraTarget) {\n      return;\n    }\n\n    var yRotation;\n\n    if (cameraTarget.rotationQuaternion) {\n      var rotMatrix = new Matrix();\n      cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);\n      yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n    } else {\n      yRotation = cameraTarget.rotation.y;\n    }\n\n    var radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n    var targetPosition = cameraTarget.getAbsolutePosition();\n    var targetX = targetPosition.x + Math.sin(radians) * this.radius;\n    var targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n    var dx = targetX - this.position.x;\n    var dy = targetPosition.y + this.heightOffset - this.position.y;\n    var dz = targetZ - this.position.z;\n    var vx = dx * this.cameraAcceleration * 2; //this is set to .05\n\n    var vy = dy * this.cameraAcceleration;\n    var vz = dz * this.cameraAcceleration * 2;\n\n    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n\n    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n    this.setTarget(targetPosition);\n  };\n  /**\r\n   * Attached controls to the current camera.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  FollowCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n\n    this._reset = function () {};\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FollowCamera.prototype.detachControl = function (ignored) {\n    this.inputs.detachElement();\n\n    if (this._reset) {\n      this._reset();\n    }\n  };\n  /** @hidden */\n\n\n  FollowCamera.prototype._checkInputs = function () {\n    this.inputs.checkInputs();\n\n    this._checkLimits();\n\n    _super.prototype._checkInputs.call(this);\n\n    if (this.lockedTarget) {\n      this._follow(this.lockedTarget);\n    }\n  };\n\n  FollowCamera.prototype._checkLimits = function () {\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n    }\n\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n    }\n\n    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n      this.heightOffset = this.lowerHeightOffsetLimit;\n    }\n\n    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n      this.heightOffset = this.upperHeightOffsetLimit;\n    }\n\n    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n      this.rotationOffset = this.lowerRotationOffsetLimit;\n    }\n\n    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n      this.rotationOffset = this.upperRotationOffsetLimit;\n    }\n  };\n  /**\r\n   * Gets the camera class name.\r\n   * @returns the class name\r\n   */\n\n\n  FollowCamera.prototype.getClassName = function () {\n    return \"FollowCamera\";\n  };\n\n  __decorate([serialize()], FollowCamera.prototype, \"radius\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"rotationOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"heightOffset\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n\n  __decorate([serialize()], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], FollowCamera.prototype, \"lockedTarget\", void 0);\n\n  return FollowCamera;\n}(TargetCamera);\n\nexport { FollowCamera };\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\n\nvar ArcFollowCamera =\n/** @class */\nfunction (_super) {\n  __extends(ArcFollowCamera, _super);\n  /**\r\n   * Instantiates a new ArcFollowCamera\r\n   * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n   * @param name Define the name of the camera\r\n   * @param alpha Define the rotation angle of the camera around the logitudinal axis\r\n   * @param beta Define the rotation angle of the camera around the elevation axis\r\n   * @param radius Define the radius of the camera from its target point\r\n   * @param target Define the target of the camera\r\n   * @param scene Define the scene the camera belongs to\r\n   */\n\n\n  function ArcFollowCamera(name,\n  /** The longitudinal angle of the camera */\n  alpha,\n  /** The latitudinal angle of the camera */\n  beta,\n  /** The radius of the camera from its target */\n  radius,\n  /** Define the camera target (the mesh it should follow) */\n  target, scene) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this.alpha = alpha;\n    _this.beta = beta;\n    _this.radius = radius;\n    _this._cartesianCoordinates = Vector3.Zero();\n    _this._meshTarget = target;\n\n    _this._follow();\n\n    return _this;\n  }\n\n  ArcFollowCamera.prototype._follow = function () {\n    if (!this._meshTarget) {\n      return;\n    }\n\n    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n\n    var targetPosition = this._meshTarget.getAbsolutePosition();\n\n    this.position = targetPosition.add(this._cartesianCoordinates);\n    this.setTarget(targetPosition);\n  };\n  /** @hidden */\n\n\n  ArcFollowCamera.prototype._checkInputs = function () {\n    _super.prototype._checkInputs.call(this);\n\n    this._follow();\n  };\n  /**\r\n   * Returns the class name of the object.\r\n   * It is mostly used internally for serialization purposes.\r\n   */\n\n\n  ArcFollowCamera.prototype.getClassName = function () {\n    return \"ArcFollowCamera\";\n  };\n\n  return ArcFollowCamera;\n}(TargetCamera);\n\nexport { ArcFollowCamera };","map":{"version":3,"sources":["../../../sourceES6/core/Cameras/followCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { FollowCameraInputsManager } from './followCameraInputsManager';\r\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\r\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\r\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\r\n});\r\n\r\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class FollowCamera extends TargetCamera {\r\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\r\n    @serialize()\r\n    public radius: number = 12;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\r\n    @serialize()\r\n    public rotationOffset: number = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chaing a plane)\r\n     */\r\n    @serialize()\r\n    public heightOffset: number = 4;\r\n\r\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\r\n    @serialize()\r\n    public cameraAcceleration: number = 0.05;\r\n\r\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\r\n    @serialize()\r\n    public maxCameraSpeed: number = 20;\r\n\r\n    /**\r\n     * Define the target of the camera.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the input associated with the camera.\r\n     */\r\n    public inputs: FollowCameraInputsManager;\r\n\r\n    /**\r\n     * Instantiates the follow camera.\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the position of the camera\r\n     * @param scene Define the scene the camera belong to\r\n     * @param lockedTarget Define the target of the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene: Scene, lockedTarget: Nullable<AbstractMesh> = null) {\r\n        super(name, position, scene);\r\n\r\n        this.lockedTarget = lockedTarget;\r\n        this.inputs = new FollowCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        // Uncomment the following line when the relevant handlers have been implemented.\r\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\r\n    }\r\n\r\n    private _follow(cameraTarget: AbstractMesh) {\r\n        if (!cameraTarget) {\r\n            return;\r\n        }\r\n\r\n        var yRotation;\r\n        if (cameraTarget.rotationQuaternion) {\r\n            var rotMatrix = new Matrix();\r\n            cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);\r\n            yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\r\n        } else {\r\n            yRotation = cameraTarget.rotation.y;\r\n        }\r\n        var radians = Tools.ToRadians(this.rotationOffset) + yRotation;\r\n        var targetPosition = cameraTarget.getAbsolutePosition();\r\n        var targetX: number = targetPosition.x + Math.sin(radians) * this.radius;\r\n\r\n        var targetZ: number = targetPosition.z + Math.cos(radians) * this.radius;\r\n        var dx: number = targetX - this.position.x;\r\n        var dy: number = (targetPosition.y + this.heightOffset) - this.position.y;\r\n        var dz: number = (targetZ) - this.position.z;\r\n        var vx: number = dx * this.cameraAcceleration * 2; //this is set to .05\r\n        var vy: number = dy * this.cameraAcceleration;\r\n        var vz: number = dz * this.cameraAcceleration * 2;\r\n\r\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\r\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\r\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\r\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored?: any): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        this._checkLimits();\r\n        super._checkInputs();\r\n        if (this.lockedTarget) {\r\n            this._follow(this.lockedTarget);\r\n        }\r\n    }\r\n\r\n    private _checkLimits() {\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n        }\r\n\r\n        if (this.lowerHeightOffsetLimit !== null &&\r\n            this.heightOffset < this.lowerHeightOffsetLimit) {\r\n            this.heightOffset = this.lowerHeightOffsetLimit;\r\n        }\r\n        if (this.upperHeightOffsetLimit !== null &&\r\n            this.heightOffset > this.upperHeightOffsetLimit) {\r\n            this.heightOffset = this.upperHeightOffsetLimit;\r\n        }\r\n\r\n        if (this.lowerRotationOffsetLimit !== null &&\r\n            this.rotationOffset < this.lowerRotationOffsetLimit) {\r\n            this.rotationOffset = this.lowerRotationOffsetLimit;\r\n        }\r\n        if (this.upperRotationOffsetLimit !== null &&\r\n            this.rotationOffset > this.upperRotationOffsetLimit) {\r\n            this.rotationOffset = this.upperRotationOffsetLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCamera\";\r\n    }\r\n}\r\n\r\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n */\r\nexport class ArcFollowCamera extends TargetCamera {\r\n\r\n    private _cartesianCoordinates: Vector3 = Vector3.Zero();\r\n\r\n        /** Define the camera target (the mesh it should follow) */\r\n    private _meshTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Instantiates a new ArcFollowCamera\r\n     * @see https://doc.babylonjs.com/features/cameras#follow-camera\r\n     * @param name Define the name of the camera\r\n     * @param alpha Define the rotation angle of the camera around the logitudinal axis\r\n     * @param beta Define the rotation angle of the camera around the elevation axis\r\n     * @param radius Define the radius of the camera from its target point\r\n     * @param target Define the target of the camera\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(name: string,\r\n        /** The longitudinal angle of the camera */\r\n        public alpha: number,\r\n        /** The latitudinal angle of the camera */\r\n        public beta: number,\r\n        /** The radius of the camera from its target */\r\n        public radius: number,\r\n        /** Define the camera target (the mesh it should follow) */\r\n        target: Nullable<AbstractMesh>,\r\n        scene: Scene) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this._meshTarget = target;\r\n        this._follow();\r\n    }\r\n\r\n    private _follow(): void {\r\n        if (!this._meshTarget) {\r\n            return;\r\n        }\r\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\r\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\r\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\r\n\r\n        var targetPosition = this._meshTarget.getAbsolutePosition();\r\n        this.position = targetPosition.add(this._cartesianCoordinates);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._follow();\r\n    }\r\n\r\n    /**\r\n     * Returns the class name of the object.\r\n     * It is mostly used internally for serialization purposes.\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcFollowCamera\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}