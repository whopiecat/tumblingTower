{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\n/**\r\n * Particle emitter emitting particles from a point.\r\n * It emits the particles randomly between 2 given directions.\r\n */\n\nvar PointParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance PointParticleEmitter\r\n   */\n  function PointParticleEmitter() {\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\n    this.direction1 = new Vector3(0, 1.0, 0);\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\n\n    this.direction2 = new Vector3(0, 1.0, 0);\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  PointParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  PointParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(0, 0, 0);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  PointParticleEmitter.prototype.clone = function () {\n    var newOne = new PointParticleEmitter();\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  PointParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setVector3(\"direction1\", this.direction1);\n    effect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  PointParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define POINTEMITTER\";\n  };\n  /**\r\n   * Returns the string \"PointParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  PointParticleEmitter.prototype.getClassName = function () {\n    return \"PointParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  PointParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  PointParticleEmitter.prototype.parse = function (serializationObject) {\n    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n  };\n\n  return PointParticleEmitter;\n}();\n\nexport { PointParticleEmitter };","map":{"version":3,"sources":["../../../../sourceES6/core/Particles/EmitterTypes/pointParticleEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { Particle } from \"../../Particles/particle\";\r\nimport { IParticleEmitterType } from \"./IParticleEmitterType\";\r\n/**\r\n * Particle emitter emitting particles from a point.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class PointParticleEmitter implements IParticleEmitterType {\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Creates a new instance PointParticleEmitter\r\n     */\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(0, 0, 0);\r\n            return;\r\n        }\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): PointParticleEmitter {\r\n        let newOne = new PointParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param effect defines the update shader\r\n     */\r\n    public applyToShader(effect: Effect): void {\r\n        effect.setVector3(\"direction1\", this.direction1);\r\n        effect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containng the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define POINTEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"PointParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}