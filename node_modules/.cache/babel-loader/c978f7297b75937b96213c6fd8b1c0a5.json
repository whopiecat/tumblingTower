{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { Tools } from \"../../Misc/tools\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\n\nvar BaseCameraPointersInput =\n/** @class */\nfunction () {\n  function BaseCameraPointersInput() {\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\n    this.buttons = [0, 1, 2];\n  }\n  /**\r\n   * Attach the input controls to a specific dom element to get the input from.\r\n   * @param element Defines the element the controls should be listened from\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  BaseCameraPointersInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var engine = this.camera.getEngine();\n    var element = engine.getInputElement();\n    var previousPinchSquaredDistance = 0;\n    var previousMultiTouchPanPosition = null;\n    this.pointA = null;\n    this.pointB = null;\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n\n    this._pointerInput = function (p, s) {\n      var evt = p.event;\n      var isTouch = evt.pointerType === \"touch\";\n\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n\n      if (p.type !== PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n        return;\n      }\n\n      var srcElement = evt.srcElement || evt.target;\n      _this._altKey = evt.altKey;\n      _this._ctrlKey = evt.ctrlKey;\n      _this._metaKey = evt.metaKey;\n      _this._shiftKey = evt.shiftKey;\n      _this._buttonsPressed = evt.buttons;\n\n      if (engine.isPointerLock) {\n        var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n        var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n\n        _this.onTouch(null, offsetX, offsetY);\n\n        _this.pointA = null;\n        _this.pointB = null;\n      } else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n        try {\n          srcElement.setPointerCapture(evt.pointerId);\n        } catch (e) {//Nothing to do with the error. Execution will continue.\n        }\n\n        if (_this.pointA === null) {\n          _this.pointA = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else if (_this.pointB === null) {\n          _this.pointB = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        }\n\n        _this.onButtonDown(evt);\n\n        if (!noPreventDefault) {\n          evt.preventDefault();\n          element && element.focus();\n        }\n      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n        _this.onDoubleTap(evt.pointerType);\n      } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n        try {\n          srcElement.releasePointerCapture(evt.pointerId);\n        } catch (e) {//Nothing to do with the error.\n        }\n\n        if (!isTouch) {\n          _this.pointB = null; // Mouse and pen are mono pointer\n        } //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n        //but emptying completely pointers collection is required to fix a bug on iPhone :\n        //when changing orientation while pinching camera,\n        //one pointer stay pressed forever if we don't release all pointers\n        //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n\n\n        if (engine._badOS) {\n          _this.pointA = _this.pointB = null;\n        } else {\n          //only remove the impacted pointer in case of multitouch allowing on most\n          //platforms switching from rotate to zoom and pan seamlessly.\n          if (_this.pointB && _this.pointA && _this.pointA.pointerId == evt.pointerId) {\n            _this.pointA = _this.pointB;\n            _this.pointB = null;\n          } else if (_this.pointA && _this.pointB && _this.pointB.pointerId == evt.pointerId) {\n            _this.pointB = null;\n          } else {\n            _this.pointA = _this.pointB = null;\n          }\n        }\n\n        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n          // Previous pinch data is populated but a button has been lifted\n          // so pinch has ended.\n          _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, 0, // pinchSquaredDistance\n          previousMultiTouchPanPosition, null // multiTouchPanPosition\n          );\n\n          previousPinchSquaredDistance = 0;\n          previousMultiTouchPanPosition = null;\n        }\n\n        _this.onButtonUp(evt);\n\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n      } else if (p.type === PointerEventTypes.POINTERMOVE) {\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        } // One button down\n\n\n        if (_this.pointA && _this.pointB === null) {\n          var offsetX = evt.clientX - _this.pointA.x;\n          var offsetY = evt.clientY - _this.pointA.y;\n\n          _this.onTouch(_this.pointA, offsetX, offsetY);\n\n          _this.pointA.x = evt.clientX;\n          _this.pointA.y = evt.clientY;\n        } // Two buttons down: pinch\n        else if (_this.pointA && _this.pointB) {\n            var ed = _this.pointA.pointerId === evt.pointerId ? _this.pointA : _this.pointB;\n            ed.x = evt.clientX;\n            ed.y = evt.clientY;\n            var distX = _this.pointA.x - _this.pointB.x;\n            var distY = _this.pointA.y - _this.pointB.y;\n            var pinchSquaredDistance = distX * distX + distY * distY;\n            var multiTouchPanPosition = {\n              x: (_this.pointA.x + _this.pointB.x) / 2,\n              y: (_this.pointA.y + _this.pointB.y) / 2,\n              pointerId: evt.pointerId,\n              type: p.type\n            };\n\n            _this.onMultiTouch(_this.pointA, _this.pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n\n            previousMultiTouchPanPosition = multiTouchPanPosition;\n            previousPinchSquaredDistance = pinchSquaredDistance;\n          }\n      }\n    };\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    this._onLostFocus = function () {\n      _this.pointA = _this.pointB = null;\n      previousPinchSquaredDistance = 0;\n      previousMultiTouchPanPosition = null;\n\n      _this.onLostFocus();\n    };\n\n    element && element.addEventListener(\"contextmenu\", this.onContextMenu.bind(this), false);\n    var hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n    if (hostWindow) {\n      Tools.RegisterTopRootEvents(hostWindow, [{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  BaseCameraPointersInput.prototype.detachControl = function (ignored) {\n    if (this._onLostFocus) {\n      var hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n      if (hostWindow) {\n        Tools.UnregisterTopRootEvents(hostWindow, [{\n          name: \"blur\",\n          handler: this._onLostFocus\n        }]);\n      }\n    }\n\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this._observer = null;\n\n      if (this.onContextMenu) {\n        var inputElement = this.camera.getScene().getEngine().getInputElement();\n        inputElement && inputElement.removeEventListener(\"contextmenu\", this.onContextMenu);\n      }\n\n      this._onLostFocus = null;\n    }\n\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n  };\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name\r\n   */\n\n\n  BaseCameraPointersInput.prototype.getClassName = function () {\n    return \"BaseCameraPointersInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input friendly name\r\n   */\n\n\n  BaseCameraPointersInput.prototype.getSimpleName = function () {\n    return \"pointers\";\n  };\n  /**\r\n   * Called on pointer POINTERDOUBLETAP event.\r\n   * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onDoubleTap = function (type) {};\n  /**\r\n   * Called on pointer POINTERMOVE event if only a single touch is active.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {};\n  /**\r\n   * Called on pointer POINTERMOVE event if multiple touches are active.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {};\n  /**\r\n   * Called on JS contextmenu event.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onContextMenu = function (evt) {\n    evt.preventDefault();\n  };\n  /**\r\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n   * press.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onButtonDown = function (evt) {};\n  /**\r\n   * Called each time a new POINTERUP event occurs. Ie, for each button\r\n   * release.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onButtonUp = function (evt) {};\n  /**\r\n   * Called when window becomes inactive.\r\n   * Override this method to provide functionality.\r\n   */\n\n\n  BaseCameraPointersInput.prototype.onLostFocus = function () {};\n\n  __decorate([serialize()], BaseCameraPointersInput.prototype, \"buttons\", void 0);\n\n  return BaseCameraPointersInput;\n}();\n\nexport { BaseCameraPointersInput };","map":{"version":3,"sources":["../../../../sourceES6/core/Cameras/Inputs/BaseCameraPointersInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { EventState, Observer } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { ICameraInput } from \"../../Cameras/cameraInputsManager\";\nimport { PointerInfo, PointerEventTypes, PointerTouch } from \"../../Events/pointerEvents\";\n\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\n    /**\n     * Defines the camera the input is attached to.\n     */\n    public abstract camera: Camera;\n\n    /**\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\n     */\n    protected _altKey: boolean;\n    protected _ctrlKey: boolean;\n    protected _metaKey: boolean;\n    protected _shiftKey: boolean;\n\n    /**\n     * Which mouse buttons were pressed at time of last mouse event.\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     */\n    protected _buttonsPressed: number;\n\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    @serialize()\n    public buttons = [0, 1, 2];\n\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param element Defines the element the controls should be listened from\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    public attachControl(noPreventDefault?: boolean): void {\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n        var engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        var previousPinchSquaredDistance = 0;\n        var previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\n\n        this.pointA = null;\n        this.pointB = null;\n\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n\n        this._pointerInput = (p, s) => {\n            var evt = <PointerEvent>p.event;\n            let isTouch = evt.pointerType === \"touch\";\n\n            if (engine.isInVRExclusivePointerMode) {\n                return;\n            }\n\n            if (p.type !== PointerEventTypes.POINTERMOVE &&\n                this.buttons.indexOf(evt.button) === -1) {\n                return;\n            }\n\n            let srcElement = <HTMLElement>(evt.srcElement || evt.target);\n\n            this._altKey = evt.altKey;\n            this._ctrlKey = evt.ctrlKey;\n            this._metaKey = evt.metaKey;\n            this._shiftKey = evt.shiftKey;\n            this._buttonsPressed = evt.buttons;\n\n            if (engine.isPointerLock) {\n                var offsetX = evt.movementX ||\n                              evt.mozMovementX ||\n                              evt.webkitMovementX ||\n                              evt.msMovementX ||\n                              0;\n                var offsetY = evt.movementY ||\n                              evt.mozMovementY ||\n                              evt.webkitMovementY ||\n                              evt.msMovementY ||\n                              0;\n\n                this.onTouch(null, offsetX, offsetY);\n                this.pointA = null;\n                this.pointB = null;\n            } else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n                try {\n                    srcElement.setPointerCapture(evt.pointerId);\n                } catch (e) {\n                    //Nothing to do with the error. Execution will continue.\n                }\n\n                if (this.pointA === null) {\n                    this.pointA = {x: evt.clientX,\n                              y: evt.clientY,\n                              pointerId: evt.pointerId,\n                              type: evt.pointerType };\n                } else if (this.pointB === null) {\n                    this.pointB = {x: evt.clientX,\n                              y: evt.clientY,\n                              pointerId: evt.pointerId,\n                              type: evt.pointerType };\n                }\n\n                this.onButtonDown(evt);\n\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                    element && element.focus();\n                }\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n                this.onDoubleTap(evt.pointerType);\n            } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n                try {\n                    srcElement.releasePointerCapture(evt.pointerId);\n                } catch (e) {\n                    //Nothing to do with the error.\n                }\n\n                if (!isTouch) {\n                    this.pointB = null; // Mouse and pen are mono pointer\n                }\n\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\n                //when changing orientation while pinching camera,\n                //one pointer stay pressed forever if we don't release all pointers\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n                if (engine._badOS) {\n                    this.pointA = this.pointB = null;\n                } else {\n                    //only remove the impacted pointer in case of multitouch allowing on most\n                    //platforms switching from rotate to zoom and pan seamlessly.\n                    if (this.pointB && this.pointA && this.pointA.pointerId == evt.pointerId) {\n                        this.pointA = this.pointB;\n                        this.pointB = null;\n                    } else if (this.pointA && this.pointB &&\n                               this.pointB.pointerId == evt.pointerId) {\n                        this.pointB = null;\n                    } else {\n                        this.pointA = this.pointB = null;\n                    }\n                }\n\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n                    // Previous pinch data is populated but a button has been lifted\n                    // so pinch has ended.\n                    this.onMultiTouch(\n                      this.pointA,\n                      this.pointB,\n                      previousPinchSquaredDistance,\n                      0,  // pinchSquaredDistance\n                      previousMultiTouchPanPosition,\n                      null  // multiTouchPanPosition\n                    );\n                  previousPinchSquaredDistance = 0;\n                  previousMultiTouchPanPosition = null;\n                }\n\n                this.onButtonUp(evt);\n\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n\n                // One button down\n                if (this.pointA && this.pointB === null) {\n                    var offsetX = evt.clientX - this.pointA.x;\n                    var offsetY = evt.clientY - this.pointA.y;\n                    this.onTouch(this.pointA, offsetX, offsetY);\n\n                    this.pointA.x = evt.clientX;\n                    this.pointA.y = evt.clientY;\n                }\n                // Two buttons down: pinch\n                else if (this.pointA && this.pointB) {\n                    var ed = (this.pointA.pointerId === evt.pointerId) ?\n                             this.pointA : this.pointB;\n                    ed.x = evt.clientX;\n                    ed.y = evt.clientY;\n                    var distX = this.pointA.x - this.pointB.x;\n                    var distY = this.pointA.y - this.pointB.y;\n                    var pinchSquaredDistance = (distX * distX) + (distY * distY);\n                    var multiTouchPanPosition = {x: (this.pointA.x + this.pointB.x) / 2,\n                                                 y: (this.pointA.y + this.pointB.y) / 2,\n                                                 pointerId: evt.pointerId,\n                                                 type: p.type};\n\n                    this.onMultiTouch(\n                      this.pointA,\n                      this.pointB,\n                      previousPinchSquaredDistance,\n                      pinchSquaredDistance,\n                      previousMultiTouchPanPosition,\n                      multiTouchPanPosition);\n\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\n                    previousPinchSquaredDistance = pinchSquaredDistance;\n                }\n            }\n        };\n\n        this._observer = this.camera.getScene().onPointerObservable.add(\n            this._pointerInput,\n            PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP |\n            PointerEventTypes.POINTERMOVE);\n\n        this._onLostFocus = () => {\n            this.pointA = this.pointB = null;\n            previousPinchSquaredDistance = 0;\n            previousMultiTouchPanPosition = null;\n            this.onLostFocus();\n        };\n\n        element && element.addEventListener(\"contextmenu\",\n            <EventListener>this.onContextMenu.bind(this), false);\n\n        let hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n        if (hostWindow) {\n            Tools.RegisterTopRootEvents(hostWindow, [\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n        }\n    }\n\n    /**\n     * Detach the current controls from the specified dom element.\n     */\n    public detachControl(): void;\n\n    /**\n     * Detach the current controls from the specified dom element.\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\n     */\n    public detachControl(ignored?: any): void {\n        if (this._onLostFocus) {\n            let hostWindow = this.camera.getScene().getEngine().getHostWindow();\n            if (hostWindow) {\n                Tools.UnregisterTopRootEvents(hostWindow, [\n                    { name: \"blur\", handler: this._onLostFocus }\n                ]);\n            }\n        }\n\n        if (this._observer) {\n            this.camera.getScene().onPointerObservable.remove(this._observer);\n            this._observer = null;\n\n            if (this.onContextMenu) {\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\n                inputElement && inputElement.removeEventListener(\"contextmenu\", <EventListener>this.onContextMenu);\n            }\n\n            this._onLostFocus = null;\n        }\n\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n    }\n\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    public getClassName(): string {\n        return \"BaseCameraPointersInput\";\n    }\n\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    public getSimpleName(): string {\n        return \"pointers\";\n    }\n\n    /**\n     * Called on pointer POINTERDOUBLETAP event.\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\n     */\n    protected onDoubleTap(type: string) {\n    }\n\n    /**\n     * Called on pointer POINTERMOVE event if only a single touch is active.\n     * Override this method to provide functionality.\n     */\n    protected onTouch(point: Nullable<PointerTouch>,\n                      offsetX: number,\n                      offsetY: number): void {\n    }\n\n    /**\n     * Called on pointer POINTERMOVE event if multiple touches are active.\n     * Override this method to provide functionality.\n     */\n    protected onMultiTouch(pointA: Nullable<PointerTouch>,\n                           pointB: Nullable<PointerTouch>,\n                           previousPinchSquaredDistance: number,\n                           pinchSquaredDistance: number,\n                           previousMultiTouchPanPosition: Nullable<PointerTouch>,\n                           multiTouchPanPosition: Nullable<PointerTouch>): void {\n    }\n\n    /**\n     * Called on JS contextmenu event.\n     * Override this method to provide functionality.\n     */\n    protected onContextMenu(evt: PointerEvent): void {\n        evt.preventDefault();\n    }\n\n    /**\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\n     * press.\n     * Override this method to provide functionality.\n     */\n    protected onButtonDown(evt: PointerEvent): void {\n    }\n\n    /**\n     * Called each time a new POINTERUP event occurs. Ie, for each button\n     * release.\n     * Override this method to provide functionality.\n     */\n    protected onButtonUp(evt: PointerEvent): void {\n    }\n\n    /**\n     * Called when window becomes inactive.\n     * Override this method to provide functionality.\n     */\n    protected onLostFocus(): void {\n    }\n\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\n    private _observer: Nullable<Observer<PointerInfo>>;\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\n    private pointA: Nullable<PointerTouch>;\n    private pointB: Nullable<PointerTouch>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}