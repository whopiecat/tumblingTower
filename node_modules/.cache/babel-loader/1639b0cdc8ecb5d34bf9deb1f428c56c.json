{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\nimport { BlurPostProcess } from \"./blurPostProcess\";\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { Texture } from \"../Materials/Textures/texture\";\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\n\nvar BloomEffect =\n/** @class */\nfunction (_super) {\n  __extends(BloomEffect, _super);\n  /**\r\n   * Creates a new instance of @see BloomEffect\r\n   * @param scene The scene the effect belongs to.\r\n   * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n   * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n   * @param bloomWeight The the strength of bloom.\r\n   * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n   */\n\n\n  function BloomEffect(scene, bloomScale, bloomWeight, bloomKernel, pipelineTextureType, blockCompilation) {\n    if (pipelineTextureType === void 0) {\n      pipelineTextureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), \"bloom\", function () {\n      return _this._effects;\n    }, true) || this;\n\n    _this.bloomScale = bloomScale;\n    /**\r\n     * @hidden Internal\r\n     */\n\n    _this._effects = [];\n    _this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurX.alwaysForcePOT = true;\n    _this._blurX.autoClear = false;\n    _this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    _this._blurY.alwaysForcePOT = true;\n    _this._blurY.autoClear = false;\n    _this.kernel = bloomKernel;\n    _this._effects = [_this._downscale, _this._blurX, _this._blurY];\n    _this._merge = new BloomMergePostProcess(\"bloomMerge\", _this._downscale, _this._blurY, bloomWeight, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    _this._merge.autoClear = false;\n\n    _this._effects.push(_this._merge);\n\n    return _this;\n  }\n\n  Object.defineProperty(BloomEffect.prototype, \"threshold\", {\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\n    get: function () {\n      return this._downscale.threshold;\n    },\n    set: function (value) {\n      this._downscale.threshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"weight\", {\n    /**\r\n     * The strength of the bloom.\r\n     */\n    get: function () {\n      return this._merge.weight;\n    },\n    set: function (value) {\n      this._merge.weight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BloomEffect.prototype, \"kernel\", {\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\n    get: function () {\n      return this._blurX.kernel / this.bloomScale;\n    },\n    set: function (value) {\n      this._blurX.kernel = value * this.bloomScale;\n      this._blurY.kernel = value * this.bloomScale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes each of the internal effects for a given camera.\r\n   * @param camera The camera to dispose the effect on.\r\n   */\n\n  BloomEffect.prototype.disposeEffects = function (camera) {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].dispose(camera);\n    }\n  };\n  /**\r\n   * @hidden Internal\r\n   */\n\n\n  BloomEffect.prototype._updateEffects = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].updateEffect();\n    }\n  };\n  /**\r\n   * Internal\r\n   * @returns if all the contained post processes are ready.\r\n   * @hidden\r\n   */\n\n\n  BloomEffect.prototype._isReady = function () {\n    for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      if (!this._effects[effectIndex].isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return BloomEffect;\n}(PostProcessRenderEffect);\n\nexport { BloomEffect };","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/bloomEffect.ts"],"names":[],"mappings":"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","sourcesContent":["import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Scene } from \"../scene\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class BloomEffect extends PostProcessRenderEffect {\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _downscale: ExtractHighlightsPostProcess;\r\n    private _blurX: BlurPostProcess;\r\n    private _blurY: BlurPostProcess;\r\n    private _merge: BloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._downscale.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._downscale.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._merge.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._merge.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._blurX.kernel / this.bloomScale;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._blurX.kernel = value * this.bloomScale;\r\n        this._blurY.kernel = value * this.bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomEffect\r\n     * @param scene The scene the effect belongs to.\r\n     * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n     * @param bloomWeight The the strength of bloom.\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(scene: Scene, private bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType = 0, blockCompilation = false) {\r\n        super(scene.getEngine(), \"bloom\", () => {\r\n            return this._effects;\r\n        }, true);\r\n        this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\r\n\r\n        this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\r\n        this._blurX.alwaysForcePOT = true;\r\n        this._blurX.autoClear = false;\r\n\r\n        this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\r\n        this._blurY.alwaysForcePOT = true;\r\n        this._blurY.autoClear = false;\r\n\r\n        this.kernel = bloomKernel;\r\n\r\n        this._effects = [this._downscale, this._blurX, this._blurY];\r\n\r\n        this._merge = new BloomMergePostProcess(\"bloomMerge\", this._downscale, this._blurY, bloomWeight, bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\r\n        this._merge.autoClear = false;\r\n        this._effects.push(this._merge);\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @hidden\r\n     */\r\n    public _isReady() {\r\n        for (var effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            if (!this._effects[effectIndex].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}