{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Epsilon } from '../Maths/math.constants';\n/**\r\n * Class used to store bounding box information\r\n */\n\nvar BoundingBox =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new bounding box\r\n   * @param min defines the minimum vector (in local space)\r\n   * @param max defines the maximum vector (in local space)\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n  function BoundingBox(min, max, worldMatrix) {\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\n\n    this.center = Vector3.Zero();\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\n\n    this.centerWorld = Vector3.Zero();\n    /**\r\n     * Gets the extend size in local space\r\n     */\n\n    this.extendSize = Vector3.Zero();\n    /**\r\n     * Gets the extend size in world space\r\n     */\n\n    this.extendSizeWorld = Vector3.Zero();\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\n\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\n\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\n\n    this.minimumWorld = Vector3.Zero();\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\n\n    this.maximumWorld = Vector3.Zero();\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\n\n    this.minimum = Vector3.Zero();\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\n\n    this.maximum = Vector3.Zero();\n    this.reConstruct(min, max, worldMatrix);\n  } // Methods\n\n  /**\r\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n   * @param min defines the new minimum vector (in local space)\r\n   * @param max defines the new maximum vector (in local space)\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n\n\n  BoundingBox.prototype.reConstruct = function (min, max, worldMatrix) {\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ); // OBB\n\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n\n    this._update(this._worldMatrix);\n  };\n  /**\r\n   * Scale the current bounding box by applying a scale factor\r\n   * @param factor defines the scale factor to apply\r\n   * @returns the current bounding box\r\n   */\n\n\n  BoundingBox.prototype.scale = function (factor) {\n    var tmpVectors = BoundingBox.TmpVector3;\n    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    var len = diff.length();\n    diff.normalizeFromLength(len);\n    var distance = len * factor;\n    var newRadius = diff.scaleInPlace(distance * 0.5);\n    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    var max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  };\n  /**\r\n   * Gets the world matrix of the bounding box\r\n   * @returns a matrix\r\n   */\n\n\n  BoundingBox.prototype.getWorldMatrix = function () {\n    return this._worldMatrix;\n  };\n  /** @hidden */\n\n\n  BoundingBox.prototype._update = function (world) {\n    var minWorld = this.minimumWorld;\n    var maxWorld = this.maximumWorld;\n    var directions = this.directions;\n    var vectorsWorld = this.vectorsWorld;\n    var vectors = this.vectors;\n\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n\n      for (var index = 0; index < 8; ++index) {\n        var v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      } // Extend\n\n\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n\n      for (var index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      } // Extend\n\n\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  };\n  /**\r\n   * Tests if the bounding box is intersecting the frustum planes\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.isInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\r\n   * Tests if the bounding box is entirely inside the frustum planes\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @returns true if there is an inclusion\r\n   */\n\n\n  BoundingBox.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  };\n  /**\r\n   * Tests if a point is inside the bounding box\r\n   * @param point defines the point to test\r\n   * @returns true if the point is inside the bounding box\r\n   */\n\n\n  BoundingBox.prototype.intersectsPoint = function (point) {\n    var min = this.minimumWorld;\n    var max = this.maximumWorld;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n    var pointX = point.x,\n        pointY = point.y,\n        pointZ = point.z;\n    var delta = -Epsilon;\n\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Tests if the bounding box intersects with a bounding sphere\r\n   * @param sphere defines the sphere to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.intersectsSphere = function (sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  };\n  /**\r\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n   * @param min defines the min vector to use\r\n   * @param max defines the max vector to use\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.prototype.intersectsMinMax = function (min, max) {\n    var myMin = this.minimumWorld;\n    var myMax = this.maximumWorld;\n    var myMinX = myMin.x,\n        myMinY = myMin.y,\n        myMinZ = myMin.z,\n        myMaxX = myMax.x,\n        myMaxY = myMax.y,\n        myMaxZ = myMax.z;\n    var minX = min.x,\n        minY = min.y,\n        minZ = min.z,\n        maxX = max.x,\n        maxY = max.y,\n        maxZ = max.z;\n\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n\n    return true;\n  }; // Statics\n\n  /**\r\n   * Tests if two bounding boxes are intersections\r\n   * @param box0 defines the first box to test\r\n   * @param box1 defines the second box to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.Intersects = function (box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  };\n  /**\r\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n   * @param minPoint defines the minimum vector of the bounding box\r\n   * @param maxPoint defines the maximum vector of the bounding box\r\n   * @param sphereCenter defines the sphere center\r\n   * @param sphereRadius defines the sphere radius\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  BoundingBox.IntersectsSphere = function (minPoint, maxPoint, sphereCenter, sphereRadius) {\n    var vector = BoundingBox.TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    var num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  };\n  /**\r\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @return true if there is an inclusion\r\n   */\n\n\n  BoundingBox.IsCompletelyInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n   * @param frustumPlanes defines the frustum planes to test\r\n   * @return true if there is an intersection\r\n   */\n\n\n  BoundingBox.IsInFrustum = function (boundingVectors, frustumPlanes) {\n    for (var p = 0; p < 6; ++p) {\n      var canReturnFalse = true;\n      var frustumPlane = frustumPlanes[p];\n\n      for (var i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  BoundingBox.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n  return BoundingBox;\n}();\n\nexport { BoundingBox };","map":{"version":3,"sources":["../../../sourceES6/core/Culling/boundingBox.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from '../Maths/math.constants';\r\nimport { Plane } from '../Maths/math.plane';\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in local space\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in world space\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _tag: number;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox.TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        }\r\n        else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\r\n        const pointX = point.x, pointY = point.y, pointZ = point.z;\r\n        var delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;\r\n        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox.TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        var num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return (num <= (sphereRadius * sphereRadius));\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @return true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (var p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (var i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @return true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (var p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (var i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}