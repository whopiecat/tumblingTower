{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\nimport { Quaternion } from \"../../Maths/math.vector\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\nimport { Material } from \"../../Materials/material\";\nimport { Engine } from \"../../Engines/engine\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Axis } from \"../../Maths/math.axis\";\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\n\nvar WebXRHand =\n/** @class */\nfunction () {\n  /**\r\n   * Construct a new hand object\r\n   * @param xrController the controller to which the hand correlates\r\n   * @param trackedMeshes the meshes to be used to track the hand joints\r\n   * @param _handMesh an optional hand mesh. if not provided, ours will be used\r\n   * @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used\r\n   * @param disableDefaultHandMesh should the default mesh creation be disabled\r\n   */\n  function WebXRHand(\n  /** the controller to which the hand correlates */\n  xrController,\n  /** the meshes to be used to track the hand joints */\n  trackedMeshes, _handMesh, _rigMapping, disableDefaultHandMesh) {\n    this.xrController = xrController;\n    this.trackedMeshes = trackedMeshes;\n    this._handMesh = _handMesh;\n    this._rigMapping = _rigMapping;\n    this._defaultHandMesh = false;\n    this._transformNodeMapping = [];\n    this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand);\n    this._scene = trackedMeshes[0].getScene();\n\n    if (this._handMesh && this._rigMapping) {\n      this._defaultHandMesh = false;\n    } else {\n      if (!disableDefaultHandMesh) {\n        this._generateDefaultHandMesh();\n      }\n    } // hide the motion controller, if available/loaded\n\n\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.setEnabled(false);\n      } else {\n        this.xrController.motionController.onModelLoadedObservable.add(function (controller) {\n          if (controller.rootMesh) {\n            controller.rootMesh.setEnabled(false);\n          }\n        });\n      }\n    }\n\n    this.xrController.onMotionControllerInitObservable.add(function (motionController) {\n      motionController.onModelLoadedObservable.add(function (controller) {\n        if (controller.rootMesh) {\n          controller.rootMesh.setEnabled(false);\n        }\n      });\n\n      if (motionController.rootMesh) {\n        motionController.rootMesh.setEnabled(false);\n      }\n    });\n  }\n  /**\r\n   * Populate the HandPartsDefinition object.\r\n   * This is called as a side effect since certain browsers don't have XRHand defined.\r\n   */\n\n\n  WebXRHand.prototype.generateHandPartsDefinition = function (hand) {\n    var _a;\n\n    return _a = {}, _a[\"wrist\"\n    /* WRIST */\n    ] = [hand.WRIST], _a[\"thumb\"\n    /* THUMB */\n    ] = [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP], _a[\"index\"\n    /* INDEX */\n    ] = [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP], _a[\"middle\"\n    /* MIDDLE */\n    ] = [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP], _a[\"ring\"\n    /* RING */\n    ] = [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP], _a[\"little\"\n    /* LITTLE */\n    ] = [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP], _a;\n  };\n  /**\r\n   * Update this hand from the latest xr frame\r\n   * @param xrFrame xrFrame to update from\r\n   * @param referenceSpace The current viewer reference space\r\n   * @param scaleFactor optional scale factor for the meshes\r\n   */\n\n\n  WebXRHand.prototype.updateFromXRFrame = function (xrFrame, referenceSpace, scaleFactor) {\n    var _this = this;\n\n    if (scaleFactor === void 0) {\n      scaleFactor = 2;\n    }\n\n    var hand = this.xrController.inputSource.hand;\n\n    if (!hand) {\n      return;\n    }\n\n    this.trackedMeshes.forEach(function (mesh, idx) {\n      var xrJoint = hand[idx];\n\n      if (xrJoint) {\n        var pose = xrFrame.getJointPose(xrJoint, referenceSpace);\n\n        if (!pose || !pose.transform) {\n          return;\n        } // get the transformation. can be done with matrix decomposition as well\n\n\n        var pos = pose.transform.position;\n        var orientation_1 = pose.transform.orientation;\n        mesh.position.set(pos.x, pos.y, pos.z);\n        mesh.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w); // left handed system conversion\n        // get the radius of the joint. In general it is static, but just in case it does change we update it on each frame.\n\n        var radius = (pose.radius || 0.008) * scaleFactor;\n        mesh.scaling.set(radius, radius, radius); // now check for the hand mesh\n\n        if (_this._handMesh && _this._rigMapping) {\n          if (_this._rigMapping[idx]) {\n            _this._transformNodeMapping[idx] = _this._transformNodeMapping[idx] || _this._scene.getTransformNodeByName(_this._rigMapping[idx]);\n\n            if (_this._transformNodeMapping[idx]) {\n              _this._transformNodeMapping[idx].position.copyFrom(mesh.position);\n\n              _this._transformNodeMapping[idx].rotationQuaternion.copyFrom(mesh.rotationQuaternion); // no scaling at the moment\n              // this._transformNodeMapping[idx].scaling.copyFrom(mesh.scaling).scaleInPlace(20);\n\n\n              mesh.isVisible = false;\n            }\n          }\n        }\n\n        if (!mesh.getScene().useRightHandedSystem) {\n          mesh.position.z *= -1;\n          mesh.rotationQuaternion.z *= -1;\n          mesh.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n  };\n  /**\r\n   * Get meshes of part of the hand\r\n   * @param part the part of hand to get\r\n   * @returns An array of meshes that correlate to the hand part requested\r\n   */\n\n\n  WebXRHand.prototype.getHandPartMeshes = function (part) {\n    var _this = this;\n\n    return this.handPartsDefinition[part].map(function (idx) {\n      return _this.trackedMeshes[idx];\n    });\n  };\n  /**\r\n   * Dispose this Hand object\r\n   */\n\n\n  WebXRHand.prototype.dispose = function () {\n    this.trackedMeshes.forEach(function (mesh) {\n      return mesh.dispose();\n    }); // dispose the hand mesh, if it is the default one\n\n    if (this._defaultHandMesh && this._handMesh) {\n      this._handMesh.dispose();\n    }\n  };\n\n  WebXRHand.prototype._generateDefaultHandMesh = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handedness_1, filename, loaded, handColors, handShader, handNodes, tm, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            handedness_1 = this.xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\n            filename = (handedness_1 === \"right\" ? \"r\" : \"l\") + \"_hand_\" + (this._scene.useRightHandedSystem ? \"r\" : \"l\") + \"hs.glb\";\n            return [4\n            /*yield*/\n            , SceneLoader.ImportMeshAsync(\"\", \"https://assets.babylonjs.com/meshes/HandMeshes/\", filename, this._scene)];\n\n          case 1:\n            loaded = _a.sent();\n            handColors = {\n              base: Color3.FromInts(116, 63, 203),\n              fresnel: Color3.FromInts(149, 102, 229),\n              fingerColor: Color3.FromInts(177, 130, 255),\n              tipFresnel: Color3.FromInts(220, 200, 255)\n            };\n            handShader = new NodeMaterial(\"leftHandShader\", this._scene, {\n              emitComments: false\n            });\n            return [4\n            /*yield*/\n            , handShader.loadAsync(\"https://patrickryanms.github.io/BabylonJStextures/Demos/xrHandMesh/handsShader.json\")];\n\n          case 2:\n            _a.sent(); // build node materials\n\n\n            handShader.build(false); // depth prepass and alpha mode\n\n            handShader.needDepthPrePass = true;\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n            handShader.alphaMode = Engine.ALPHA_COMBINE;\n            handNodes = {\n              base: handShader.getBlockByName(\"baseColor\"),\n              fresnel: handShader.getBlockByName(\"fresnelColor\"),\n              fingerColor: handShader.getBlockByName(\"fingerColor\"),\n              tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n            };\n            handNodes.base.value = handColors.base;\n            handNodes.fresnel.value = handColors.fresnel;\n            handNodes.fingerColor.value = handColors.fingerColor;\n            handNodes.tipFresnel.value = handColors.tipFresnel;\n            loaded.meshes[1].material = handShader;\n            this._defaultHandMesh = true;\n            this._handMesh = loaded.meshes[0];\n            this._rigMapping = [\"wrist_\", \"thumb_metacarpal_\", \"thumb_proxPhalanx_\", \"thumb_distPhalanx_\", \"thumb_tip_\", \"index_metacarpal_\", \"index_proxPhalanx_\", \"index_intPhalanx_\", \"index_distPhalanx_\", \"index_tip_\", \"middle_metacarpal_\", \"middle_proxPhalanx_\", \"middle_intPhalanx_\", \"middle_distPhalanx_\", \"middle_tip_\", \"ring_metacarpal_\", \"ring_proxPhalanx_\", \"ring_intPhalanx_\", \"ring_distPhalanx_\", \"ring_tip_\", \"little_metacarpal_\", \"little_proxPhalanx_\", \"little_intPhalanx_\", \"little_distPhalanx_\", \"little_tip_\"].map(function (joint) {\n              return \"\" + joint + (handedness_1 === \"right\" ? \"R\" : \"L\");\n            });\n            tm = this._scene.getTransformNodeByName(this._rigMapping[0]);\n\n            if (!tm) {\n              throw new Error(\"could not find the wrist node\");\n            } else {\n              tm.parent && tm.parent.rotate(Axis.Y, Math.PI);\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            Tools.Error(\"error loading hand mesh\");\n            console.log(e_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return WebXRHand;\n}();\n\nexport { WebXRHand };\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\n\nvar WebXRHandTracking =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHandTracking, _super);\n  /**\r\n   * Creates a new instance of the hit test feature\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param options options to use when constructing this feature\r\n   */\n\n\n  function WebXRHandTracking(_xrSessionManager,\n  /**\r\n   * options to use when constructing this feature\r\n   */\n  options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\n\n    _this.onHandAddedObservable = new Observable();\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\n\n    _this.onHandRemovedObservable = new Observable();\n    _this._hands = {};\n\n    _this._attachHand = function (xrController) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n      if (!xrController.inputSource.hand || _this._hands[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      var hand = xrController.inputSource.hand;\n      var trackedMeshes = [];\n      var originalMesh = ((_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || SphereBuilder.CreateSphere(\"jointParent\", {\n        diameter: 1\n      });\n      originalMesh.isVisible = !!((_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n\n      for (var i = 0; i < hand.length; ++i) {\n        var newInstance = originalMesh.createInstance(xrController.uniqueId + \"-handJoint-\" + i);\n\n        if ((_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n          var returnedMesh = _this.options.jointMeshes.onHandJointMeshGenerated(newInstance, i, xrController.uniqueId);\n\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n\n        newInstance.isPickable = false;\n\n        if ((_d = _this.options.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n          var props = _this.options.jointMeshes.physicsProps || {};\n          var type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({\n            mass: 0\n          }, props));\n        }\n\n        newInstance.rotationQuaternion = new Quaternion();\n\n        if ((_e = _this.options.jointMeshes) === null || _e === void 0 ? void 0 : _e.invisible) {\n          newInstance.isVisible = false;\n        }\n\n        trackedMeshes.push(newInstance);\n      }\n\n      var handedness = xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\n      var handMesh = ((_f = _this.options.jointMeshes) === null || _f === void 0 ? void 0 : _f.handMeshes) && ((_g = _this.options.jointMeshes) === null || _g === void 0 ? void 0 : _g.handMeshes[handedness]);\n      var rigMapping = ((_h = _this.options.jointMeshes) === null || _h === void 0 ? void 0 : _h.rigMapping) && ((_j = _this.options.jointMeshes) === null || _j === void 0 ? void 0 : _j.rigMapping[handedness]);\n      var webxrHand = new WebXRHand(xrController, trackedMeshes, handMesh, rigMapping, (_k = _this.options.jointMeshes) === null || _k === void 0 ? void 0 : _k.disableDefaultHandMesh); // get two new meshes\n\n      _this._hands[xrController.uniqueId] = {\n        handObject: webxrHand,\n        id: WebXRHandTracking._idCounter++\n      };\n\n      _this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n\n    _this.xrNativeFeatureName = \"hand-tracking\";\n    return _this;\n  }\n  /**\r\n   * Check if the needed objects are defined.\r\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n   */\n\n\n  WebXRHandTracking.prototype.isCompatible = function () {\n    return typeof XRHand !== \"undefined\";\n  };\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHandTracking.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    this.options.xrInput.controllers.forEach(this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachHand(controller.uniqueId);\n    });\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHandTracking.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._hands).forEach(function (controllerId) {\n      _this._detachHand(controllerId);\n    });\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRHandTracking.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHandAddedObservable.clear();\n  };\n  /**\r\n   * Get the hand object according to the controller id\r\n   * @param controllerId the controller id to which we want to get the hand\r\n   * @returns null if not found or the WebXRHand object if found\r\n   */\n\n\n  WebXRHandTracking.prototype.getHandByControllerId = function (controllerId) {\n    var _a;\n\n    return ((_a = this._hands[controllerId]) === null || _a === void 0 ? void 0 : _a.handObject) || null;\n  };\n  /**\r\n   * Get a hand object according to the requested handedness\r\n   * @param handedness the handedness to request\r\n   * @returns null if not found or the WebXRHand object if found\r\n   */\n\n\n  WebXRHandTracking.prototype.getHandByHandedness = function (handedness) {\n    var _this = this;\n\n    var handednesses = Object.keys(this._hands).map(function (key) {\n      return _this._hands[key].handObject.xrController.inputSource.handedness;\n    });\n    var found = handednesses.indexOf(handedness);\n\n    if (found !== -1) {\n      return this._hands[found].handObject;\n    }\n\n    return null;\n  };\n\n  WebXRHandTracking.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this; // iterate over the hands object\n\n\n    Object.keys(this._hands).forEach(function (id) {\n      var _a;\n\n      _this._hands[id].handObject.updateFromXRFrame(_xrFrame, _this._xrSessionManager.referenceSpace, (_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.scaleFactor);\n    });\n  };\n\n  WebXRHandTracking.prototype._detachHand = function (controllerId) {\n    if (this._hands[controllerId]) {\n      this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);\n\n      this._hands[controllerId].handObject.dispose();\n    }\n  };\n\n  WebXRHandTracking._idCounter = 0;\n  /**\r\n   * The module's name\r\n   */\n\n  WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRHandTracking.Version = 1;\n  return WebXRHandTracking;\n}(WebXRAbstractFeature);\n\nexport { WebXRHandTracking }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHandTracking(xrSessionManager, options);\n  };\n}, WebXRHandTracking.Version, false);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRHandTracking.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRInput } from \"../webXRInput\";\r\nimport { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport { WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { IDisposable, Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false)\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to a sphere.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius\r\n         */\r\n        sourceMesh?: Mesh;\r\n\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, controllerId: string) => Mesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible. Defaults to false\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Scale factor for all instances (defaults to 2)\r\n         */\r\n        scaleFactor?: number;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultHandMesh?: boolean;\r\n        /**\r\n         * a rigged hand-mesh that will be updated according to the XRHand data provided. This will override the default hand mesh\r\n         */\r\n        handMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        rigMapping?: {\r\n            right: string[];\r\n            left: string[];\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport const enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The THumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    private _scene: Scene;\r\n    private _defaultHandMesh: boolean = false;\r\n    private _transformNodeMapping: TransformNode[] = [];\r\n    /**\r\n     * Hand-parts definition (key is HandPart)\r\n     */\r\n    public handPartsDefinition: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Populate the HandPartsDefinition object.\r\n     * This is called as a side effect since certain browsers don't have XRHand defined.\r\n     */\r\n    private generateHandPartsDefinition(hand: XRHand) {\r\n        return {\r\n            [HandPart.WRIST]: [hand.WRIST],\r\n            [HandPart.THUMB]: [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP],\r\n            [HandPart.INDEX]: [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP],\r\n            [HandPart.MIDDLE]: [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP],\r\n            [HandPart.RING]: [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP],\r\n            [HandPart.LITTLE]: [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController the controller to which the hand correlates\r\n     * @param trackedMeshes the meshes to be used to track the hand joints\r\n     * @param _handMesh an optional hand mesh. if not provided, ours will be used\r\n     * @param _rigMapping an optional rig mapping for the hand mesh. if not provided, ours will be used\r\n     * @param disableDefaultHandMesh should the default mesh creation be disabled\r\n     */\r\n    constructor(\r\n        /** the controller to which the hand correlates */\r\n        public readonly xrController: WebXRInputSource,\r\n        /** the meshes to be used to track the hand joints */\r\n        public readonly trackedMeshes: AbstractMesh[],\r\n        private _handMesh?: AbstractMesh,\r\n        private _rigMapping?: string[],\r\n        disableDefaultHandMesh?: boolean\r\n    ) {\r\n        this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand!);\r\n        this._scene = trackedMeshes[0].getScene();\r\n        if (this._handMesh && this._rigMapping) {\r\n            this._defaultHandMesh = false;\r\n        } else {\r\n            if (!disableDefaultHandMesh) {\r\n                this._generateDefaultHandMesh();\r\n            }\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.setEnabled(false);\r\n            } else {\r\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\r\n                    if (controller.rootMesh) {\r\n                        controller.rootMesh.setEnabled(false);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController.onModelLoadedObservable.add((controller) => {\r\n                if (controller.rootMesh) {\r\n                    controller.rootMesh.setEnabled(false);\r\n                }\r\n            });\r\n            if (motionController.rootMesh) {\r\n                motionController.rootMesh.setEnabled(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame\r\n     * @param xrFrame xrFrame to update from\r\n     * @param referenceSpace The current viewer reference space\r\n     * @param scaleFactor optional scale factor for the meshes\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace, scaleFactor: number = 2) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n        this.trackedMeshes.forEach((mesh, idx) => {\r\n            const xrJoint = hand[idx];\r\n            if (xrJoint) {\r\n                let pose = xrFrame.getJointPose!(xrJoint, referenceSpace);\r\n                if (!pose || !pose.transform) {\r\n                    return;\r\n                }\r\n                // get the transformation. can be done with matrix decomposition as well\r\n                const pos = pose.transform.position;\r\n                const orientation = pose.transform.orientation;\r\n                mesh.position.set(pos.x, pos.y, pos.z);\r\n                mesh.rotationQuaternion!.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n                // left handed system conversion\r\n                // get the radius of the joint. In general it is static, but just in case it does change we update it on each frame.\r\n                const radius = (pose.radius || 0.008) * scaleFactor;\r\n                mesh.scaling.set(radius, radius, radius);\r\n\r\n                // now check for the hand mesh\r\n                if (this._handMesh && this._rigMapping) {\r\n                    if (this._rigMapping[idx]) {\r\n                        this._transformNodeMapping[idx] = this._transformNodeMapping[idx] || this._scene.getTransformNodeByName(this._rigMapping[idx]);\r\n                        if (this._transformNodeMapping[idx]) {\r\n                            this._transformNodeMapping[idx].position.copyFrom(mesh.position);\r\n                            this._transformNodeMapping[idx].rotationQuaternion!.copyFrom(mesh.rotationQuaternion!);\r\n                            // no scaling at the moment\r\n                            // this._transformNodeMapping[idx].scaling.copyFrom(mesh.scaling).scaleInPlace(20);\r\n                            mesh.isVisible = false;\r\n                        }\r\n                    }\r\n                }\r\n                if (!mesh.getScene().useRightHandedSystem) {\r\n                    mesh.position.z *= -1;\r\n                    mesh.rotationQuaternion!.z *= -1;\r\n                    mesh.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand\r\n     * @param part the part of hand to get\r\n     * @returns An array of meshes that correlate to the hand part requested\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return this.handPartsDefinition[part].map((idx) => this.trackedMeshes[idx]);\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     */\r\n    public dispose() {\r\n        this.trackedMeshes.forEach((mesh) => mesh.dispose());\r\n        // dispose the hand mesh, if it is the default one\r\n        if (this._defaultHandMesh && this._handMesh) {\r\n            this._handMesh.dispose();\r\n        }\r\n    }\r\n\r\n    private async _generateDefaultHandMesh() {\r\n        try {\r\n            const handedness = this.xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\r\n            const filename = `${handedness === \"right\" ? \"r\" : \"l\"}_hand_${this._scene.useRightHandedSystem ? \"r\" : \"l\"}hs.glb`;\r\n            const loaded = await SceneLoader.ImportMeshAsync(\"\", \"https://assets.babylonjs.com/meshes/HandMeshes/\", filename, this._scene);\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n            };\r\n\r\n            const handShader = new NodeMaterial(\"leftHandShader\", this._scene, { emitComments: false });\r\n            await handShader.loadAsync(\"https://patrickryanms.github.io/BabylonJStextures/Demos/xrHandMesh/handsShader.json\");\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Engine.ALPHA_COMBINE;\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n\r\n            loaded.meshes[1].material = handShader;\r\n\r\n            this._defaultHandMesh = true;\r\n            this._handMesh = loaded.meshes[0];\r\n            this._rigMapping = [\r\n                \"wrist_\",\r\n                \"thumb_metacarpal_\",\r\n                \"thumb_proxPhalanx_\",\r\n                \"thumb_distPhalanx_\",\r\n                \"thumb_tip_\",\r\n                \"index_metacarpal_\",\r\n                \"index_proxPhalanx_\",\r\n                \"index_intPhalanx_\",\r\n                \"index_distPhalanx_\",\r\n                \"index_tip_\",\r\n                \"middle_metacarpal_\",\r\n                \"middle_proxPhalanx_\",\r\n                \"middle_intPhalanx_\",\r\n                \"middle_distPhalanx_\",\r\n                \"middle_tip_\",\r\n                \"ring_metacarpal_\",\r\n                \"ring_proxPhalanx_\",\r\n                \"ring_intPhalanx_\",\r\n                \"ring_distPhalanx_\",\r\n                \"ring_tip_\",\r\n                \"little_metacarpal_\",\r\n                \"little_proxPhalanx_\",\r\n                \"little_intPhalanx_\",\r\n                \"little_distPhalanx_\",\r\n                \"little_tip_\",\r\n            ].map((joint) => `${joint}${handedness === \"right\" ? \"R\" : \"L\"}`);\r\n            // single change for left handed systems\r\n            const tm = this._scene.getTransformNodeByName(this._rigMapping[0]);\r\n            if (!tm) {\r\n                throw new Error(\"could not find the wrist node\");\r\n            } else {\r\n                tm.parent && (tm.parent as AbstractMesh).rotate(Axis.Y, Math.PI);\r\n            }\r\n        } catch (e) {\r\n            Tools.Error(\"error loading hand mesh\");\r\n            console.log(e);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    private static _idCounter = 0;\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    private _hands: {\r\n        [controllerId: string]: {\r\n            id: number;\r\n            handObject: WebXRHand;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * Creates a new instance of the hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n    }\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n        this.options.xrInput.controllers.forEach(this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachHand(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._hands).forEach((controllerId) => {\r\n            this._detachHand(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._hands[controllerId]?.handObject || null;\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        const handednesses = Object.keys(this._hands).map((key) => this._hands[key].handObject.xrController.inputSource.handedness);\r\n        const found = handednesses.indexOf(handedness);\r\n        if (found !== -1) {\r\n            return this._hands[found].handObject;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        // iterate over the hands object\r\n        Object.keys(this._hands).forEach((id) => {\r\n            this._hands[id].handObject.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace, this.options.jointMeshes?.scaleFactor);\r\n        });\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || this._hands[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const hand = xrController.inputSource.hand;\r\n        const trackedMeshes: AbstractMesh[] = [];\r\n        const originalMesh = this.options.jointMeshes?.sourceMesh || SphereBuilder.CreateSphere(\"jointParent\", { diameter: 1 });\r\n        originalMesh.isVisible = !!this.options.jointMeshes?.keepOriginalVisible;\r\n        for (let i = 0; i < hand.length; ++i) {\r\n            let newInstance: AbstractMesh = originalMesh.createInstance(`${xrController.uniqueId}-handJoint-${i}`);\r\n            if (this.options.jointMeshes?.onHandJointMeshGenerated) {\r\n                const returnedMesh = this.options.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, xrController.uniqueId);\r\n                if (returnedMesh) {\r\n                    if (returnedMesh !== newInstance) {\r\n                        newInstance.dispose();\r\n                        newInstance = returnedMesh;\r\n                    }\r\n                }\r\n            }\r\n            newInstance.isPickable = false;\r\n            if (this.options.jointMeshes?.enablePhysics) {\r\n                const props = this.options.jointMeshes.physicsProps || {};\r\n                const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n            }\r\n            newInstance.rotationQuaternion = new Quaternion();\r\n            if (this.options.jointMeshes?.invisible) {\r\n                newInstance.isVisible = false;\r\n            }\r\n            trackedMeshes.push(newInstance);\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness === \"right\" ? \"right\" : \"left\";\r\n        const handMesh = this.options.jointMeshes?.handMeshes && this.options.jointMeshes?.handMeshes[handedness];\r\n        const rigMapping = this.options.jointMeshes?.rigMapping && this.options.jointMeshes?.rigMapping[handedness];\r\n        const webxrHand = new WebXRHand(xrController, trackedMeshes, handMesh, rigMapping, this.options.jointMeshes?.disableDefaultHandMesh);\r\n\r\n        // get two new meshes\r\n        this._hands[xrController.uniqueId] = {\r\n            handObject: webxrHand,\r\n            id: WebXRHandTracking._idCounter++,\r\n        };\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHand(controllerId: string) {\r\n        if (this._hands[controllerId]) {\r\n            this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);\r\n            this._hands[controllerId].handObject.dispose();\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}