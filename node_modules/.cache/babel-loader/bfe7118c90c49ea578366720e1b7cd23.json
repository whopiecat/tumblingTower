{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { WebXRInputSource } from \"./webXRInputSource\";\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\n\nvar WebXRInput =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the WebXRInput\r\n   * @param xrSessionManager the xr session manager for this session\r\n   * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n   * @param options = initialization options for this xr input\r\n   */\n  function WebXRInput(\n  /**\r\n   * the xr session manager for this session\r\n   */\n  xrSessionManager,\n  /**\r\n   * the WebXR camera for this session. Mainly used for teleportation\r\n   */\n  xrCamera, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.xrSessionManager = xrSessionManager;\n    this.xrCamera = xrCamera;\n    this.options = options;\n    /**\r\n     * XR controllers being tracked\r\n     */\n\n    this.controllers = [];\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\n\n    this.onControllerAddedObservable = new Observable();\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\n\n    this.onControllerRemovedObservable = new Observable();\n\n    this._onInputSourcesChange = function (event) {\n      _this._addAndRemoveControllers(event.added, event.removed);\n    }; // Remove controllers when exiting XR\n\n\n    this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(function () {\n      _this._addAndRemoveControllers([], _this.controllers.map(function (c) {\n        return c.inputSource;\n      }));\n    });\n    this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add(function (session) {\n      session.addEventListener(\"inputsourceschange\", _this._onInputSourcesChange);\n    });\n    this._frameObserver = this.xrSessionManager.onXRFrameObservable.add(function (frame) {\n      // Update controller pose info\n      _this.controllers.forEach(function (controller) {\n        controller.updateFromXRFrame(frame, _this.xrSessionManager.referenceSpace);\n      });\n    });\n\n    if (this.options.customControllersRepositoryURL) {\n      WebXRMotionControllerManager.BaseRepositoryUrl = this.options.customControllersRepositoryURL;\n    }\n\n    WebXRMotionControllerManager.UseOnlineRepository = !this.options.disableOnlineControllerRepository;\n\n    if (WebXRMotionControllerManager.UseOnlineRepository) {\n      // pre-load the profiles list to load the controllers quicker afterwards\n      try {\n        WebXRMotionControllerManager.UpdateProfilesList().catch(function () {\n          WebXRMotionControllerManager.UseOnlineRepository = false;\n        });\n      } catch (e) {\n        WebXRMotionControllerManager.UseOnlineRepository = false;\n      }\n    }\n  }\n\n  WebXRInput.prototype._addAndRemoveControllers = function (addInputs, removeInputs) {\n    var _this = this; // Add controllers if they don't already exist\n\n\n    var sources = this.controllers.map(function (c) {\n      return c.inputSource;\n    });\n\n    for (var _i = 0, addInputs_1 = addInputs; _i < addInputs_1.length; _i++) {\n      var input = addInputs_1[_i];\n\n      if (sources.indexOf(input) === -1) {\n        var controller = new WebXRInputSource(this.xrSessionManager.scene, input, __assign(__assign({}, this.options.controllerOptions || {}), {\n          forceControllerProfile: this.options.forceInputProfile,\n          doNotLoadControllerMesh: this.options.doNotLoadControllerMeshes,\n          disableMotionControllerAnimation: this.options.disableControllerAnimation\n        }));\n        this.controllers.push(controller);\n        this.onControllerAddedObservable.notifyObservers(controller);\n      }\n    } // Remove and dispose of controllers to be disposed\n\n\n    var keepControllers = [];\n    var removedControllers = [];\n    this.controllers.forEach(function (c) {\n      if (removeInputs.indexOf(c.inputSource) === -1) {\n        keepControllers.push(c);\n      } else {\n        removedControllers.push(c);\n      }\n    });\n    this.controllers = keepControllers;\n    removedControllers.forEach(function (c) {\n      _this.onControllerRemovedObservable.notifyObservers(c);\n\n      c.dispose();\n    });\n  };\n  /**\r\n   * Disposes of the object\r\n   */\n\n\n  WebXRInput.prototype.dispose = function () {\n    this.controllers.forEach(function (c) {\n      c.dispose();\n    });\n    this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\n    this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\n    this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\n    this.onControllerAddedObservable.clear();\n    this.onControllerRemovedObservable.clear();\n  };\n\n  return WebXRInput;\n}();\n\nexport { WebXRInput };","map":{"version":3,"sources":["../../../sourceES6/core/XR/webXRInput.ts"],"names":[],"mappings":";AACA,SAAmB,UAAnB,QAAqC,oBAArC;AAEA,SAAS,gBAAT,QAA0D,oBAA1D;AAGA,SAAS,4BAAT,QAA6C,iDAA7C;AAwCA;;;;AAGA,IAAA,UAAA;AAAA;AAAA,YAAA;AAiBI;;;;;;AAMA,WAAA,UAAA;AACI;;;AAGO,EAAA,gBAJX;AAKI;;;AAGO,EAAA,QARX,EASqB,OATrB,EASqD;AATrD,QAAA,KAAA,GAAA,IAAA;;AASqB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAgC;;AAL1C,SAAA,gBAAA,GAAA,gBAAA;AAIA,SAAA,QAAA,GAAA,QAAA;AACU,SAAA,OAAA,GAAA,OAAA;AA/BrB;;;;AAGO,SAAA,WAAA,GAAuC,EAAvC;AAIP;;;;AAGO,SAAA,2BAAA,GAA8B,IAAI,UAAJ,EAA9B;AACP;;;;AAGO,SAAA,6BAAA,GAAgC,IAAI,UAAJ,EAAhC;;AAyDC,SAAA,qBAAA,GAAwB,UAAC,KAAD,EAAgC;AAC5D,MAAA,KAAI,CAAC,wBAAL,CAA8B,KAAK,CAAC,KAApC,EAA2C,KAAK,CAAC,OAAjD;AACH,KAFO,CAxC6C,CAEjD;;;AACA,SAAK,qBAAL,GAA6B,KAAK,gBAAL,CAAsB,gBAAtB,CAAuC,GAAvC,CAA2C,YAAA;AACpE,MAAA,KAAI,CAAC,wBAAL,CACI,EADJ,EAEI,KAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,UAAC,CAAD,EAAE;AACnB,eAAO,CAAC,CAAC,WAAT;AACH,OAFD,CAFJ;AAMH,KAP4B,CAA7B;AASA,SAAK,oBAAL,GAA4B,KAAK,gBAAL,CAAsB,eAAtB,CAAsC,GAAtC,CAA0C,UAAC,OAAD,EAAQ;AAC1E,MAAA,OAAO,CAAC,gBAAR,CAAyB,oBAAzB,EAA+C,KAAI,CAAC,qBAApD;AACH,KAF2B,CAA5B;AAIA,SAAK,cAAL,GAAsB,KAAK,gBAAL,CAAsB,mBAAtB,CAA0C,GAA1C,CAA8C,UAAC,KAAD,EAAM;AACtE;AACA,MAAA,KAAI,CAAC,WAAL,CAAiB,OAAjB,CAAyB,UAAC,UAAD,EAAW;AAChC,QAAA,UAAU,CAAC,iBAAX,CAA6B,KAA7B,EAAoC,KAAI,CAAC,gBAAL,CAAsB,cAA1D;AACH,OAFD;AAGH,KALqB,CAAtB;;AAOA,QAAI,KAAK,OAAL,CAAa,8BAAjB,EAAiD;AAC7C,MAAA,4BAA4B,CAAC,iBAA7B,GAAiD,KAAK,OAAL,CAAa,8BAA9D;AACH;;AAED,IAAA,4BAA4B,CAAC,mBAA7B,GAAmD,CAAC,KAAK,OAAL,CAAa,iCAAjE;;AACA,QAAI,4BAA4B,CAAC,mBAAjC,EAAsD;AAClD;AACA,UAAI;AACA,QAAA,4BAA4B,CAAC,kBAA7B,GAAkD,KAAlD,CAAwD,YAAA;AACpD,UAAA,4BAA4B,CAAC,mBAA7B,GAAmD,KAAnD;AACH,SAFD;AAGH,OAJD,CAIE,OAAO,CAAP,EAAU;AACR,QAAA,4BAA4B,CAAC,mBAA7B,GAAmD,KAAnD;AACH;AACJ;AACJ;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,SAAjC,EAAkE,YAAlE,EAAoG;AAApG,QAAA,KAAA,GAAA,IAAA,CAAoG,CAChG;;;AACA,QAAI,OAAO,GAAG,KAAK,WAAL,CAAiB,GAAjB,CAAqB,UAAC,CAAD,EAAE;AACjC,aAAO,CAAC,CAAC,WAAT;AACH,KAFa,CAAd;;AAGA,SAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,WAAA,GAAA,SAAlB,EAAkB,EAAA,GAAA,WAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAA6B;AAAxB,UAAI,KAAK,GAAA,WAAA,CAAA,EAAA,CAAT;;AACD,UAAI,OAAO,CAAC,OAAR,CAAgB,KAAhB,MAA2B,CAAC,CAAhC,EAAmC;AAC/B,YAAI,UAAU,GAAG,IAAI,gBAAJ,CAAqB,KAAK,gBAAL,CAAsB,KAA3C,EAAkD,KAAlD,EAAuD,QAAA,CAAA,QAAA,CAAA,EAAA,EAChE,KAAK,OAAL,CAAa,iBAAb,IAAkC,EAD8B,CAAA,EAC3B;AACzC,UAAA,sBAAsB,EAAE,KAAK,OAAL,CAAa,iBADI;AAEzC,UAAA,uBAAuB,EAAE,KAAK,OAAL,CAAa,yBAFG;AAGzC,UAAA,gCAAgC,EAAE,KAAK,OAAL,CAAa;AAHN,SAD2B,CAAvD,CAAjB;AAMA,aAAK,WAAL,CAAiB,IAAjB,CAAsB,UAAtB;AACA,aAAK,2BAAL,CAAiC,eAAjC,CAAiD,UAAjD;AACH;AACJ,KAhB+F,CAkBhG;;;AACA,QAAI,eAAe,GAA4B,EAA/C;AACA,QAAI,kBAAkB,GAA4B,EAAlD;AACA,SAAK,WAAL,CAAiB,OAAjB,CAAyB,UAAC,CAAD,EAAE;AACvB,UAAI,YAAY,CAAC,OAAb,CAAqB,CAAC,CAAC,WAAvB,MAAwC,CAAC,CAA7C,EAAgD;AAC5C,QAAA,eAAe,CAAC,IAAhB,CAAqB,CAArB;AACH,OAFD,MAEO;AACH,QAAA,kBAAkB,CAAC,IAAnB,CAAwB,CAAxB;AACH;AACJ,KAND;AAOA,SAAK,WAAL,GAAmB,eAAnB;AACA,IAAA,kBAAkB,CAAC,OAAnB,CAA2B,UAAC,CAAD,EAAE;AACzB,MAAA,KAAI,CAAC,6BAAL,CAAmC,eAAnC,CAAmD,CAAnD;;AACA,MAAA,CAAC,CAAC,OAAF;AACH,KAHD;AAIH,GAjCO;AAmCR;;;;;AAGO,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,SAAK,WAAL,CAAiB,OAAjB,CAAyB,UAAC,CAAD,EAAE;AACvB,MAAA,CAAC,CAAC,OAAF;AACH,KAFD;AAGA,SAAK,gBAAL,CAAsB,mBAAtB,CAA0C,MAA1C,CAAiD,KAAK,cAAtD;AACA,SAAK,gBAAL,CAAsB,eAAtB,CAAsC,MAAtC,CAA6C,KAAK,oBAAlD;AACA,SAAK,gBAAL,CAAsB,gBAAtB,CAAuC,MAAvC,CAA8C,KAAK,qBAAnD;AACA,SAAK,2BAAL,CAAiC,KAAjC;AACA,SAAK,6BAAL,CAAmC,KAAnC;AACH,GATM;;AAUX,SAAA,UAAA;AAAC,CA5HD,EAAA","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Observer, Observable } from \"../Misc/observable\";\r\nimport { IDisposable } from \"../scene\";\r\nimport { WebXRInputSource, IWebXRControllerOptions } from \"./webXRInputSource\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager\";\r\n\r\n/**\r\n * The schema for initialization options of the XR Input class\r\n */\r\nexport interface IWebXRInputOptions {\r\n    /**\r\n     * If set to true no model will be automatically loaded\r\n     */\r\n    doNotLoadControllerMeshes?: boolean;\r\n\r\n    /**\r\n     * If set, this profile will be used for all controllers loaded (for example \"microsoft-mixed-reality\")\r\n     * If not found, the xr input profile data will be used.\r\n     * Profiles are defined here - https://github.com/immersive-web/webxr-input-profiles/\r\n     */\r\n    forceInputProfile?: string;\r\n\r\n    /**\r\n     * Do not send a request to the controller repository to load the profile.\r\n     *\r\n     * Instead, use the controllers available in babylon itself.\r\n     */\r\n    disableOnlineControllerRepository?: boolean;\r\n\r\n    /**\r\n     * A custom URL for the controllers repository\r\n     */\r\n    customControllersRepositoryURL?: string;\r\n\r\n    /**\r\n     * Should the controller model's components not move according to the user input\r\n     */\r\n    disableControllerAnimation?: boolean;\r\n\r\n    /**\r\n     * Optional options to pass to the controller. Will be overridden by the Input options where applicable\r\n     */\r\n    controllerOptions?: IWebXRControllerOptions;\r\n}\r\n/**\r\n * XR input used to track XR inputs such as controllers/rays\r\n */\r\nexport class WebXRInput implements IDisposable {\r\n    /**\r\n     * XR controllers being tracked\r\n     */\r\n    public controllers: Array<WebXRInputSource> = [];\r\n    private _frameObserver: Nullable<Observer<any>>;\r\n    private _sessionEndedObserver: Nullable<Observer<any>>;\r\n    private _sessionInitObserver: Nullable<Observer<any>>;\r\n    /**\r\n     * Event when a controller has been connected/added\r\n     */\r\n    public onControllerAddedObservable = new Observable<WebXRInputSource>();\r\n    /**\r\n     * Event when a controller has been removed/disconnected\r\n     */\r\n    public onControllerRemovedObservable = new Observable<WebXRInputSource>();\r\n\r\n    /**\r\n     * Initializes the WebXRInput\r\n     * @param xrSessionManager the xr session manager for this session\r\n     * @param xrCamera the WebXR camera for this session. Mainly used for teleportation\r\n     * @param options = initialization options for this xr input\r\n     */\r\n    public constructor(\r\n        /**\r\n         * the xr session manager for this session\r\n         */\r\n        public xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * the WebXR camera for this session. Mainly used for teleportation\r\n         */\r\n        public xrCamera: WebXRCamera,\r\n        private readonly options: IWebXRInputOptions = {}\r\n    ) {\r\n        // Remove controllers when exiting XR\r\n        this._sessionEndedObserver = this.xrSessionManager.onXRSessionEnded.add(() => {\r\n            this._addAndRemoveControllers(\r\n                [],\r\n                this.controllers.map((c) => {\r\n                    return c.inputSource;\r\n                })\r\n            );\r\n        });\r\n\r\n        this._sessionInitObserver = this.xrSessionManager.onXRSessionInit.add((session) => {\r\n            session.addEventListener(\"inputsourceschange\", this._onInputSourcesChange);\r\n        });\r\n\r\n        this._frameObserver = this.xrSessionManager.onXRFrameObservable.add((frame) => {\r\n            // Update controller pose info\r\n            this.controllers.forEach((controller) => {\r\n                controller.updateFromXRFrame(frame, this.xrSessionManager.referenceSpace);\r\n            });\r\n        });\r\n\r\n        if (this.options.customControllersRepositoryURL) {\r\n            WebXRMotionControllerManager.BaseRepositoryUrl = this.options.customControllersRepositoryURL;\r\n        }\r\n\r\n        WebXRMotionControllerManager.UseOnlineRepository = !this.options.disableOnlineControllerRepository;\r\n        if (WebXRMotionControllerManager.UseOnlineRepository) {\r\n            // pre-load the profiles list to load the controllers quicker afterwards\r\n            try {\r\n                WebXRMotionControllerManager.UpdateProfilesList().catch(() => {\r\n                    WebXRMotionControllerManager.UseOnlineRepository = false;\r\n                });\r\n            } catch (e) {\r\n                WebXRMotionControllerManager.UseOnlineRepository = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onInputSourcesChange = (event: XRInputSourceChangeEvent) => {\r\n        this._addAndRemoveControllers(event.added, event.removed);\r\n    };\r\n\r\n    private _addAndRemoveControllers(addInputs: Array<XRInputSource>, removeInputs: Array<XRInputSource>) {\r\n        // Add controllers if they don't already exist\r\n        let sources = this.controllers.map((c) => {\r\n            return c.inputSource;\r\n        });\r\n        for (let input of addInputs) {\r\n            if (sources.indexOf(input) === -1) {\r\n                let controller = new WebXRInputSource(this.xrSessionManager.scene, input, {\r\n                    ...(this.options.controllerOptions || {}),\r\n                    forceControllerProfile: this.options.forceInputProfile,\r\n                    doNotLoadControllerMesh: this.options.doNotLoadControllerMeshes,\r\n                    disableMotionControllerAnimation: this.options.disableControllerAnimation,\r\n                });\r\n                this.controllers.push(controller);\r\n                this.onControllerAddedObservable.notifyObservers(controller);\r\n            }\r\n        }\r\n\r\n        // Remove and dispose of controllers to be disposed\r\n        let keepControllers: Array<WebXRInputSource> = [];\r\n        let removedControllers: Array<WebXRInputSource> = [];\r\n        this.controllers.forEach((c) => {\r\n            if (removeInputs.indexOf(c.inputSource) === -1) {\r\n                keepControllers.push(c);\r\n            } else {\r\n                removedControllers.push(c);\r\n            }\r\n        });\r\n        this.controllers = keepControllers;\r\n        removedControllers.forEach((c) => {\r\n            this.onControllerRemovedObservable.notifyObservers(c);\r\n            c.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the object\r\n     */\r\n    public dispose() {\r\n        this.controllers.forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver);\r\n        this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver);\r\n        this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver);\r\n        this.onControllerAddedObservable.clear();\r\n        this.onControllerRemovedObservable.clear();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}