{"ast":null,"code":"import { Mesh } from \"../../Meshes/mesh\";\nimport { Scene } from \"../../scene\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Ray } from \"../../Culling/ray\";\nimport { PivotTools } from '../../Misc/pivotTools';\nimport \"../../Meshes/Builders/planeBuilder\";\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events\r\n */\n\nvar PointerDragBehavior =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a pointer drag behavior that can be attached to a mesh\r\n   * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)\r\n   */\n  function PointerDragBehavior(options) {\n    this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;\n    /**\r\n     * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)\r\n     */\n\n    this.maxDragAngle = 0;\n    /**\r\n     * @hidden\r\n     */\n\n    this._useAlternatePickedPointAboveMaxDragAngle = false;\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\n\n    this.currentDraggingPointerID = -1;\n    /**\r\n     * If the behavior is currently in a dragging state\r\n     */\n\n    this.dragging = false;\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\n\n    this.dragDeltaRatio = 0.2;\n    /**\r\n     * If the drag plane orientation should be updated during the dragging (Default: true)\r\n     */\n\n    this.updateDragPlane = true; // Debug mode will display drag planes to help visualize behavior\n\n    this._debugMode = false;\n    this._moving = false;\n    /**\r\n     *  Fires each time the attached mesh is dragged with the pointer\r\n     *  * delta between last drag position and current drag position in world space\r\n     *  * dragDistance along the drag axis\r\n     *  * dragPlaneNormal normal of the current drag plane used during the drag\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     */\n\n    this.onDragObservable = new Observable();\n    /**\r\n     *  Fires each time a drag begins (eg. mouse down on mesh)\r\n     */\n\n    this.onDragStartObservable = new Observable();\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\n\n    this.onDragEndObservable = new Observable();\n    /**\r\n     *  If the attached mesh should be moved when dragged\r\n     */\n\n    this.moveAttached = true;\n    /**\r\n     *  If the drag behavior will react to drag events (Default: true)\r\n     */\n\n    this.enabled = true;\n    /**\r\n     * If pointer events should start and release the drag (Default: true)\r\n     */\n\n    this.startAndReleaseDragOnPointerEvents = true;\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\n\n    this.detachCameraControls = true;\n    /**\r\n     * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)\r\n     */\n\n    this.useObjectOrientationForDragging = true;\n    /**\r\n     * Predicate to determine if it is valid to move the object to a new position when it is moved\r\n     */\n\n    this.validateDrag = function (targetPosition) {\n      return true;\n    };\n\n    this._tmpVector = new Vector3(0, 0, 0);\n    this._alternatePickedPoint = new Vector3(0, 0, 0);\n    this._worldDragAxis = new Vector3(0, 0, 0);\n    this._targetPosition = new Vector3(0, 0, 0);\n    this._attachedToElement = false;\n    this._startDragRay = new Ray(new Vector3(), new Vector3());\n    this._lastPointerRay = {};\n    this._dragDelta = new Vector3(); // Variables to avoid instantiation in the below method\n\n    this._pointA = new Vector3(0, 0, 0);\n    this._pointC = new Vector3(0, 0, 0);\n    this._localAxis = new Vector3(0, 0, 0);\n    this._lookAt = new Vector3(0, 0, 0);\n    this._options = options ? options : {};\n    var optionCount = 0;\n\n    if (this._options.dragAxis) {\n      optionCount++;\n    }\n\n    if (this._options.dragPlaneNormal) {\n      optionCount++;\n    }\n\n    if (optionCount > 1) {\n      throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\n    }\n  }\n\n  Object.defineProperty(PointerDragBehavior.prototype, \"options\", {\n    /**\r\n     * Gets the options used by the behavior\r\n     */\n    get: function () {\n      return this._options;\n    },\n\n    /**\r\n     * Sets the options used by the behavior\r\n     */\n    set: function (options) {\n      this._options = options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointerDragBehavior.prototype, \"name\", {\n    /**\r\n     *  The name of the behavior\r\n     */\n    get: function () {\n      return \"PointerDrag\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *  Initializes the behavior\r\n   */\n\n  PointerDragBehavior.prototype.init = function () {};\n  /**\r\n   * Attaches the drag behavior the passed in mesh\r\n   * @param ownerNode The mesh that will be dragged around once attached\r\n   * @param predicate Predicate to use for pick filtering\r\n   */\n\n\n  PointerDragBehavior.prototype.attach = function (ownerNode, predicate) {\n    var _this = this;\n\n    this._scene = ownerNode.getScene();\n    this.attachedNode = ownerNode; // Initialize drag plane to not interfere with existing scene\n\n    if (!PointerDragBehavior._planeScene) {\n      if (this._debugMode) {\n        PointerDragBehavior._planeScene = this._scene;\n      } else {\n        PointerDragBehavior._planeScene = new Scene(this._scene.getEngine(), {\n          virtual: true\n        });\n\n        PointerDragBehavior._planeScene.detachControl();\n\n        this._scene.onDisposeObservable.addOnce(function () {\n          PointerDragBehavior._planeScene.dispose();\n\n          PointerDragBehavior._planeScene = null;\n        });\n      }\n    }\n\n    this._dragPlane = Mesh.CreatePlane(\"pointerDragPlane\", this._debugMode ? 1 : 10000, PointerDragBehavior._planeScene, false, Mesh.DOUBLESIDE); // State of the drag\n\n    this.lastDragPosition = new Vector3(0, 0, 0);\n    var pickPredicate = !!predicate ? predicate : function (m) {\n      return _this.attachedNode == m || m.isDescendantOf(_this.attachedNode);\n    };\n    this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo, eventState) {\n      if (!_this.enabled) {\n        return;\n      }\n\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (_this.startAndReleaseDragOnPointerEvents && !_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {\n          _this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);\n        }\n      } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {\n        if (_this.startAndReleaseDragOnPointerEvents && _this.currentDraggingPointerID == pointerInfo.event.pointerId) {\n          _this.releaseDrag();\n        }\n      } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\n        var pointerId = pointerInfo.event.pointerId; // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved\n\n        if (_this.currentDraggingPointerID === PointerDragBehavior._AnyMouseID && pointerId !== PointerDragBehavior._AnyMouseID) {\n          var evt = pointerInfo.event;\n          var isMouseEvent = evt.pointerType === \"mouse\" || !_this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\n\n          if (isMouseEvent) {\n            if (_this._lastPointerRay[_this.currentDraggingPointerID]) {\n              _this._lastPointerRay[pointerId] = _this._lastPointerRay[_this.currentDraggingPointerID];\n              delete _this._lastPointerRay[_this.currentDraggingPointerID];\n            }\n\n            _this.currentDraggingPointerID = pointerId;\n          }\n        } // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()\n\n\n        if (!_this._lastPointerRay[pointerId]) {\n          _this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());\n        }\n\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {\n          _this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);\n\n          _this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);\n\n          if (_this.currentDraggingPointerID == pointerId && _this.dragging) {\n            _this._moveDrag(pointerInfo.pickInfo.ray);\n          }\n        }\n      }\n    });\n    this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n      if (_this._moving && _this.moveAttached) {\n        PivotTools._RemoveAndStorePivotPoint(_this.attachedNode); // Slowly move mesh to avoid jitter\n\n\n        _this._targetPosition.subtractToRef(_this.attachedNode.absolutePosition, _this._tmpVector);\n\n        _this._tmpVector.scaleInPlace(_this.dragDeltaRatio);\n\n        _this.attachedNode.getAbsolutePosition().addToRef(_this._tmpVector, _this._tmpVector);\n\n        if (_this.validateDrag(_this._tmpVector)) {\n          _this.attachedNode.setAbsolutePosition(_this._tmpVector);\n        }\n\n        PivotTools._RestorePivotPoint(_this.attachedNode);\n      }\n    });\n  };\n  /**\r\n   * Force relase the drag action by code.\r\n   */\n\n\n  PointerDragBehavior.prototype.releaseDrag = function () {\n    if (this.dragging) {\n      this.dragging = false;\n      this.onDragEndObservable.notifyObservers({\n        dragPlanePoint: this.lastDragPosition,\n        pointerId: this.currentDraggingPointerID\n      });\n    }\n\n    this.currentDraggingPointerID = -1;\n    this._moving = false; // Reattach camera controls\n\n    if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {\n      if (this._scene.activeCamera.getClassName() === \"ArcRotateCamera\") {\n        var arcRotateCamera = this._scene.activeCamera;\n        arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);\n      } else {\n        this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);\n      }\n\n      this._attachedToElement = false;\n    }\n  };\n  /**\r\n   * Simulates the start of a pointer drag event on the behavior\r\n   * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)\r\n   * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)\r\n   * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)\r\n   */\n\n\n  PointerDragBehavior.prototype.startDrag = function (pointerId, fromRay, startPickedPoint) {\n    if (pointerId === void 0) {\n      pointerId = PointerDragBehavior._AnyMouseID;\n    }\n\n    this._startDrag(pointerId, fromRay, startPickedPoint);\n\n    var lastRay = this._lastPointerRay[pointerId];\n\n    if (pointerId === PointerDragBehavior._AnyMouseID) {\n      lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];\n    }\n\n    if (lastRay) {\n      // if there was a last pointer ray drag the object there\n      this._moveDrag(lastRay);\n    }\n  };\n\n  PointerDragBehavior.prototype._startDrag = function (pointerId, fromRay, startPickedPoint) {\n    if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {\n      return;\n    }\n\n    PivotTools._RemoveAndStorePivotPoint(this.attachedNode); // Create start ray from the camera to the object\n\n\n    if (fromRay) {\n      this._startDragRay.direction.copyFrom(fromRay.direction);\n\n      this._startDragRay.origin.copyFrom(fromRay.origin);\n    } else {\n      this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);\n\n      this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);\n\n      this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);\n    }\n\n    this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);\n\n    var pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);\n\n    if (pickedPoint) {\n      this.dragging = true;\n      this.currentDraggingPointerID = pointerId;\n      this.lastDragPosition.copyFrom(pickedPoint);\n      this.onDragStartObservable.notifyObservers({\n        dragPlanePoint: pickedPoint,\n        pointerId: this.currentDraggingPointerID\n      });\n\n      this._targetPosition.copyFrom(this.attachedNode.absolutePosition); // Detatch camera controls\n\n\n      if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {\n        if (this._scene.activeCamera.inputs.attachedToElement) {\n          this._scene.activeCamera.detachControl();\n\n          this._attachedToElement = true;\n        } else {\n          this._attachedToElement = false;\n        }\n      }\n    }\n\n    PivotTools._RestorePivotPoint(this.attachedNode);\n  };\n\n  PointerDragBehavior.prototype._moveDrag = function (ray) {\n    this._moving = true;\n\n    var pickedPoint = this._pickWithRayOnDragPlane(ray);\n\n    if (pickedPoint) {\n      if (this.updateDragPlane) {\n        this._updateDragPlanePosition(ray, pickedPoint);\n      }\n\n      var dragLength = 0; // depending on the drag mode option drag accordingly\n\n      if (this._options.dragAxis) {\n        // Convert local drag axis to world if useObjectOrientationForDragging\n        this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis); // Project delta drag from the drag plane onto the drag axis\n\n        pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);\n        dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);\n\n        this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);\n      } else {\n        dragLength = this._dragDelta.length();\n        pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);\n      }\n\n      this._targetPosition.addInPlace(this._dragDelta);\n\n      this.onDragObservable.notifyObservers({\n        dragDistance: dragLength,\n        delta: this._dragDelta,\n        dragPlanePoint: pickedPoint,\n        dragPlaneNormal: this._dragPlane.forward,\n        pointerId: this.currentDraggingPointerID\n      });\n      this.lastDragPosition.copyFrom(pickedPoint);\n    }\n  };\n\n  PointerDragBehavior.prototype._pickWithRayOnDragPlane = function (ray) {\n    var _this = this;\n\n    if (!ray) {\n      return null;\n    } // Calculate angle between plane normal and ray\n\n\n    var angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction)); // Correct if ray is casted from oposite side\n\n    if (angle > Math.PI / 2) {\n      angle = Math.PI - angle;\n    } // If the angle is too perpendicular to the plane pick another point on the plane where it is looking\n\n\n    if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {\n      if (this._useAlternatePickedPointAboveMaxDragAngle) {\n        // Invert ray direction along the towards object axis\n        this._tmpVector.copyFrom(ray.direction);\n\n        this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);\n\n        this._alternatePickedPoint.normalize();\n\n        this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));\n\n        this._tmpVector.addInPlace(this._alternatePickedPoint); // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point\n\n\n        var dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);\n\n        this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);\n\n        this._alternatePickedPoint.addInPlace(this._tmpVector);\n\n        this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);\n\n        return this._alternatePickedPoint;\n      } else {\n        return null;\n      }\n    }\n\n    var pickResult = PointerDragBehavior._planeScene.pickWithRay(ray, function (m) {\n      return m == _this._dragPlane;\n    });\n\n    if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {\n      return pickResult.pickedPoint;\n    } else {\n      return null;\n    }\n  }; // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera\n\n\n  PointerDragBehavior.prototype._updateDragPlanePosition = function (ray, dragPlanePosition) {\n    this._pointA.copyFrom(dragPlanePosition);\n\n    if (this._options.dragAxis) {\n      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis); // Calculate plane normal that is the cross product of local axis and (eye-dragPlanePosition)\n\n      ray.origin.subtractToRef(this._pointA, this._pointC);\n\n      this._pointC.normalize();\n\n      if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {\n        // the drag axis is colinear with the (eye to position) ray. The cross product will give jittered values.\n        // A new axis vector need to be computed\n        if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {\n          this._lookAt.copyFrom(Vector3.Right());\n        } else {\n          this._lookAt.copyFrom(Vector3.UpReadOnly);\n        }\n      } else {\n        Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt); // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendiculat to camera\n\n        Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);\n\n        this._lookAt.normalize();\n      }\n\n      this._dragPlane.position.copyFrom(this._pointA);\n\n      this._pointA.addToRef(this._lookAt, this._lookAt);\n\n      this._dragPlane.lookAt(this._lookAt);\n    } else if (this._options.dragPlaneNormal) {\n      this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);\n\n      this._dragPlane.position.copyFrom(this._pointA);\n\n      this._pointA.addToRef(this._localAxis, this._lookAt);\n\n      this._dragPlane.lookAt(this._lookAt);\n    } else {\n      this._dragPlane.position.copyFrom(this._pointA);\n\n      this._dragPlane.lookAt(ray.origin);\n    } // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)\n\n\n    this._dragPlane.position.copyFrom(this.attachedNode.absolutePosition);\n\n    this._dragPlane.computeWorldMatrix(true);\n  };\n  /**\r\n   *  Detaches the behavior from the mesh\r\n   */\n\n\n  PointerDragBehavior.prototype.detach = function () {\n    if (this._pointerObserver) {\n      this._scene.onPointerObservable.remove(this._pointerObserver);\n    }\n\n    if (this._beforeRenderObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n\n    this.releaseDrag();\n  };\n\n  PointerDragBehavior._AnyMouseID = -2;\n  return PointerDragBehavior;\n}();\n\nexport { PointerDragBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Meshes/pointerDragBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { PointerInfo, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PivotTools } from '../../Misc/pivotTools';\r\nimport { ArcRotateCamera } from '../../Cameras/arcRotateCamera';\r\nimport \"../../Meshes/Builders/planeBuilder\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events\r\n */\r\nexport class PointerDragBehavior implements Behavior<AbstractMesh> {\r\n    private static _AnyMouseID = -2;\r\n    /**\r\n     * Abstract mesh the behavior is set on\r\n     */\r\n    public attachedNode: AbstractMesh;\r\n    private _dragPlane: Mesh;\r\n    private _scene: Scene;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private static _planeScene: Scene;\r\n    private _useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;\r\n    /**\r\n     * The maximum tolerated angle between the drag plane and dragging pointer rays to trigger pointer events. Set to 0 to allow any angle (default: 0)\r\n     */\r\n    public maxDragAngle = 0;\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _useAlternatePickedPointAboveMaxDragAngle = false;\r\n    /**\r\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\r\n     */\r\n    public currentDraggingPointerID = -1;\r\n    /**\r\n     * The last position where the pointer hit the drag plane in world space\r\n     */\r\n    public lastDragPosition: Vector3;\r\n    /**\r\n     * If the behavior is currently in a dragging state\r\n     */\r\n    public dragging = false;\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n    /**\r\n     * If the drag plane orientation should be updated during the dragging (Default: true)\r\n     */\r\n    public updateDragPlane = true;\r\n    // Debug mode will display drag planes to help visualize behavior\r\n    private _debugMode = false;\r\n    private _moving = false;\r\n    /**\r\n     *  Fires each time the attached mesh is dragged with the pointer\r\n     *  * delta between last drag position and current drag position in world space\r\n     *  * dragDistance along the drag axis\r\n     *  * dragPlaneNormal normal of the current drag plane used during the drag\r\n     *  * dragPlanePoint in world space where the drag intersects the drag plane\r\n     */\r\n    public onDragObservable = new Observable<{ delta: Vector3, dragPlanePoint: Vector3, dragPlaneNormal: Vector3, dragDistance: number, pointerId: number }>();\r\n    /**\r\n     *  Fires each time a drag begins (eg. mouse down on mesh)\r\n     */\r\n    public onDragStartObservable = new Observable<{ dragPlanePoint: Vector3, pointerId: number }>();\r\n    /**\r\n     *  Fires each time a drag ends (eg. mouse release after drag)\r\n     */\r\n    public onDragEndObservable = new Observable<{ dragPlanePoint: Vector3, pointerId: number }>();\r\n    /**\r\n     *  If the attached mesh should be moved when dragged\r\n     */\r\n    public moveAttached = true;\r\n\r\n    /**\r\n     *  If the drag behavior will react to drag events (Default: true)\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * If pointer events should start and release the drag (Default: true)\r\n     */\r\n    public startAndReleaseDragOnPointerEvents = true;\r\n    /**\r\n     * If camera controls should be detached during the drag\r\n     */\r\n    public detachCameraControls = true;\r\n\r\n    /**\r\n     * If set, the drag plane/axis will be rotated based on the attached mesh's world rotation (Default: true)\r\n     */\r\n    public useObjectOrientationForDragging = true;\r\n\r\n    private _options: { dragAxis?: Vector3, dragPlaneNormal?: Vector3 };\r\n\r\n    /**\r\n     * Gets the options used by the behavior\r\n     */\r\n    public get options(): { dragAxis?: Vector3, dragPlaneNormal?: Vector3 } {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Sets the options used by the behavior\r\n     */\r\n    public set options(options: { dragAxis?: Vector3, dragPlaneNormal?: Vector3 }) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Creates a pointer drag behavior that can be attached to a mesh\r\n     * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)\r\n     */\r\n    constructor(options?: { dragAxis?: Vector3, dragPlaneNormal?: Vector3 }) {\r\n        this._options = options ? options : {};\r\n\r\n        var optionCount = 0;\r\n        if (this._options.dragAxis) {\r\n            optionCount++;\r\n        }\r\n        if (this._options.dragPlaneNormal) {\r\n            optionCount++;\r\n        }\r\n        if (optionCount > 1) {\r\n            throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Predicate to determine if it is valid to move the object to a new position when it is moved\r\n     */\r\n    public validateDrag = (targetPosition: Vector3) => { return true; };\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"PointerDrag\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() { }\r\n\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _alternatePickedPoint = new Vector3(0, 0, 0);\r\n    private _worldDragAxis = new Vector3(0, 0, 0);\r\n    private _targetPosition = new Vector3(0, 0, 0);\r\n    private _attachedToElement: boolean = false;\r\n    /**\r\n     * Attaches the drag behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     * @param predicate Predicate to use for pick filtering\r\n     */\r\n    public attach(ownerNode: AbstractMesh, predicate?: (m: AbstractMesh) => boolean): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        // Initialize drag plane to not interfere with existing scene\r\n        if (!PointerDragBehavior._planeScene) {\r\n            if (this._debugMode) {\r\n                PointerDragBehavior._planeScene = this._scene;\r\n            } else {\r\n                PointerDragBehavior._planeScene = new Scene(this._scene.getEngine(), { virtual: true });\r\n                PointerDragBehavior._planeScene.detachControl();\r\n                this._scene.onDisposeObservable.addOnce(() => {\r\n                    PointerDragBehavior._planeScene.dispose();\r\n                    (<any>PointerDragBehavior._planeScene) = null;\r\n                });\r\n            }\r\n        }\r\n        this._dragPlane = Mesh.CreatePlane(\"pointerDragPlane\", this._debugMode ? 1 : 10000, PointerDragBehavior._planeScene, false, Mesh.DOUBLESIDE);\r\n\r\n        // State of the drag\r\n        this.lastDragPosition = new Vector3(0, 0, 0);\r\n\r\n        var pickPredicate = !!predicate ? predicate : (m: AbstractMesh) => {\r\n            return this.attachedNode == m || m.isDescendantOf(this.attachedNode);\r\n        };\r\n\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo, eventState) => {\r\n            if (!this.enabled) {\r\n                return;\r\n            }\r\n\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n\r\n                if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {\r\n                    this._startDrag((<PointerEvent>pointerInfo.event).pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {\r\n                if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerID == (<PointerEvent>pointerInfo.event).pointerId) {\r\n                    this.releaseDrag();\r\n                }\r\n            } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\r\n                var pointerId = (<PointerEvent>pointerInfo.event).pointerId;\r\n\r\n                // If drag was started with anyMouseID specified, set pointerID to the next mouse that moved\r\n                if (this.currentDraggingPointerID === PointerDragBehavior._AnyMouseID && pointerId !== PointerDragBehavior._AnyMouseID) {\r\n                    const evt = <PointerEvent>pointerInfo.event;\r\n                    const isMouseEvent = evt.pointerType === \"mouse\" || (!this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent);\r\n                    if (isMouseEvent) {\r\n                        if (this._lastPointerRay[this.currentDraggingPointerID]) {\r\n                            this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerID];\r\n                            delete this._lastPointerRay[this.currentDraggingPointerID];\r\n                        }\r\n                        this.currentDraggingPointerID = pointerId;\r\n                    }\r\n                }\r\n\r\n                // Keep track of last pointer ray, this is used simulating the start of a drag in startDrag()\r\n                if (!this._lastPointerRay[pointerId]) {\r\n                    this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());\r\n                }\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {\r\n                    this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);\r\n                    this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);\r\n\r\n                    if (this.currentDraggingPointerID == pointerId && this.dragging) {\r\n                        this._moveDrag(pointerInfo.pickInfo.ray);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (this._moving && this.moveAttached) {\r\n                PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n                // Slowly move mesh to avoid jitter\r\n                this._targetPosition.subtractToRef((this.attachedNode).absolutePosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(this.dragDeltaRatio);\r\n                (this.attachedNode).getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);\r\n                if (this.validateDrag(this._tmpVector)) {\r\n                    (this.attachedNode).setAbsolutePosition(this._tmpVector);\r\n                }\r\n                PivotTools._RestorePivotPoint(this.attachedNode);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force relase the drag action by code.\r\n     */\r\n    public releaseDrag() {\r\n        if (this.dragging) {\r\n            this.dragging = false;\r\n            this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerID });\r\n        }\r\n\r\n        this.currentDraggingPointerID = -1;\r\n        this._moving = false;\r\n\r\n        // Reattach camera controls\r\n        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {\r\n            if (this._scene.activeCamera.getClassName() === \"ArcRotateCamera\") {\r\n                const arcRotateCamera = this._scene.activeCamera as ArcRotateCamera;\r\n                arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);\r\n            } else {\r\n                this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);\r\n            }\r\n            this._attachedToElement = false;\r\n        }\r\n    }\r\n\r\n    private _startDragRay = new Ray(new Vector3(), new Vector3());\r\n    private _lastPointerRay: { [key: number]: Ray } = {};\r\n    /**\r\n     * Simulates the start of a pointer drag event on the behavior\r\n     * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)\r\n     * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)\r\n     * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)\r\n     */\r\n    public startDrag(pointerId: number = PointerDragBehavior._AnyMouseID, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        this._startDrag(pointerId, fromRay, startPickedPoint);\r\n\r\n        var lastRay = this._lastPointerRay[pointerId];\r\n        if (pointerId === PointerDragBehavior._AnyMouseID) {\r\n            lastRay = this._lastPointerRay[<any>Object.keys(this._lastPointerRay)[0]];\r\n        }\r\n\r\n        if (lastRay) {\r\n            // if there was a last pointer ray drag the object there\r\n            this._moveDrag(lastRay);\r\n        }\r\n    }\r\n\r\n    protected _startDrag(pointerId: number, fromRay?: Ray, startPickedPoint?: Vector3) {\r\n        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {\r\n            return;\r\n        }\r\n\r\n        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);\r\n        // Create start ray from the camera to the object\r\n        if (fromRay) {\r\n            this._startDragRay.direction.copyFrom(fromRay.direction);\r\n            this._startDragRay.origin.copyFrom(fromRay.origin);\r\n        } else {\r\n            this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);\r\n            this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);\r\n            this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);\r\n        }\r\n\r\n        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);\r\n\r\n        var pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);\r\n        if (pickedPoint) {\r\n            this.dragging = true;\r\n            this.currentDraggingPointerID = pointerId;\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n            this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerID });\r\n            this._targetPosition.copyFrom((this.attachedNode).absolutePosition);\r\n\r\n            // Detatch camera controls\r\n            if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {\r\n                if (this._scene.activeCamera.inputs.attachedToElement) {\r\n                    this._scene.activeCamera.detachControl();\r\n                    this._attachedToElement = true;\r\n                } else {\r\n                    this._attachedToElement = false;\r\n                }\r\n            }\r\n        }\r\n        PivotTools._RestorePivotPoint(this.attachedNode);\r\n    }\r\n\r\n    private _dragDelta = new Vector3();\r\n    protected _moveDrag(ray: Ray) {\r\n        this._moving = true;\r\n        var pickedPoint = this._pickWithRayOnDragPlane(ray);\r\n\r\n        if (pickedPoint) {\r\n            if (this.updateDragPlane) {\r\n                this._updateDragPlanePosition(ray, pickedPoint);\r\n            }\r\n\r\n            var dragLength = 0;\r\n            // depending on the drag mode option drag accordingly\r\n            if (this._options.dragAxis) {\r\n                // Convert local drag axis to world if useObjectOrientationForDragging\r\n                this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);\r\n\r\n                // Project delta drag from the drag plane onto the drag axis\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);\r\n                dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);\r\n                this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);\r\n            } else {\r\n                dragLength = this._dragDelta.length();\r\n                pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);\r\n            }\r\n            this._targetPosition.addInPlace(this._dragDelta);\r\n            this.onDragObservable.notifyObservers({ dragDistance: dragLength, delta: this._dragDelta, dragPlanePoint: pickedPoint, dragPlaneNormal: this._dragPlane.forward, pointerId: this.currentDraggingPointerID });\r\n            this.lastDragPosition.copyFrom(pickedPoint);\r\n        }\r\n    }\r\n\r\n    private _pickWithRayOnDragPlane(ray: Nullable<Ray>) {\r\n        if (!ray) {\r\n            return null;\r\n        }\r\n\r\n        // Calculate angle between plane normal and ray\r\n        var angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));\r\n        // Correct if ray is casted from oposite side\r\n        if (angle > Math.PI / 2) {\r\n            angle = Math.PI - angle;\r\n        }\r\n\r\n        // If the angle is too perpendicular to the plane pick another point on the plane where it is looking\r\n        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {\r\n            if (this._useAlternatePickedPointAboveMaxDragAngle) {\r\n                // Invert ray direction along the towards object axis\r\n                this._tmpVector.copyFrom(ray.direction);\r\n                (this.attachedNode).absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.normalize();\r\n                this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));\r\n                this._tmpVector.addInPlace(this._alternatePickedPoint);\r\n\r\n                // Project resulting vector onto the drag plane and add it to the attached nodes absolute position to get a picked point\r\n                var dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);\r\n                this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);\r\n                this._alternatePickedPoint.addInPlace(this._tmpVector);\r\n                this._alternatePickedPoint.addInPlace((this.attachedNode).absolutePosition);\r\n                return this._alternatePickedPoint;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        var pickResult = PointerDragBehavior._planeScene.pickWithRay(ray, (m) => { return m == this._dragPlane; });\r\n        if (pickResult && pickResult.hit && pickResult.pickedMesh && pickResult.pickedPoint) {\r\n            return pickResult.pickedPoint;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Variables to avoid instantiation in the below method\r\n    private _pointA = new Vector3(0, 0, 0);\r\n    private _pointC = new Vector3(0, 0, 0);\r\n    private _localAxis = new Vector3(0, 0, 0);\r\n    private _lookAt = new Vector3(0, 0, 0);\r\n    // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera\r\n    private _updateDragPlanePosition(ray: Ray, dragPlanePosition: Vector3) {\r\n        this._pointA.copyFrom(dragPlanePosition);\r\n        if (this._options.dragAxis) {\r\n            this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);\r\n\r\n            // Calculate plane normal that is the cross product of local axis and (eye-dragPlanePosition)\r\n            ray.origin.subtractToRef(this._pointA, this._pointC);\r\n            this._pointC.normalize();\r\n            if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999)\r\n            {\r\n                // the drag axis is colinear with the (eye to position) ray. The cross product will give jittered values.\r\n                // A new axis vector need to be computed\r\n                if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999)\r\n                {\r\n                    this._lookAt.copyFrom(Vector3.Right());\r\n                } else {\r\n                    this._lookAt.copyFrom(Vector3.UpReadOnly);\r\n                }\r\n            } else {\r\n                Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);\r\n                // Get perpendicular line from previous result and drag axis to adjust lineB to be perpendiculat to camera\r\n                Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);\r\n                this._lookAt.normalize();\r\n            }\r\n\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._lookAt, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else if (this._options.dragPlaneNormal) {\r\n            this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._pointA.addToRef(this._localAxis, this._lookAt);\r\n            this._dragPlane.lookAt(this._lookAt);\r\n        } else {\r\n            this._dragPlane.position.copyFrom(this._pointA);\r\n            this._dragPlane.lookAt(ray.origin);\r\n        }\r\n        // Update the position of the drag plane so it doesn't get out of sync with the node (eg. when moving back and forth quickly)\r\n        this._dragPlane.position.copyFrom(this.attachedNode.absolutePosition);\r\n\r\n        this._dragPlane.computeWorldMatrix(true);\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        if (this._pointerObserver) {\r\n            this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._beforeRenderObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n        this.releaseDrag();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}