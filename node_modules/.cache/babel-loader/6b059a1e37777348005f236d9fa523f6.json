{"ast":null,"code":"import { Color4, Color3 } from \"../Maths/math\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Ray } from \"../Culling/ray\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\nimport { Scalar } from \"../Maths/math.scalar\";\n/** Defines the 4 color options */\n\nexport var PointColor;\n\n(function (PointColor) {\n  /** color value */\n  PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n  /** uv value */\n\n  PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n  /** random value */\n\n  PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n  /** stated value */\n\n  PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\n\n\nvar PointsCloudSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a PCS (Points Cloud System) object\r\n   * @param name (String) is the PCS name, this will be the underlying mesh name\r\n   * @param pointSize (number) is the size for each point\r\n   * @param scene (Scene) is the scene in which the PCS is added\r\n   * @param options defines the options of the PCS e.g.\r\n   * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n   */\n  function PointsCloudSystem(name, pointSize, scene, options) {\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\n    this.particles = new Array();\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\n\n    this.nbParticles = 0;\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\n\n    this.vars = {};\n    this._promises = [];\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._updatable = true;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._groups = new Array(); //start indices for each group of particles\n\n    this._groupCounter = 0;\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeBoundingBox = false;\n    this._isReady = false;\n    this.name = name;\n    this._size = pointSize;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n  }\n  /**\r\n   * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n   * If no points were added to the PCS, the returned mesh is just a single point.\r\n   * @returns a promise for the created mesh\r\n   */\n\n\n  PointsCloudSystem.prototype.buildMeshAsync = function () {\n    var _this = this;\n\n    return Promise.all(this._promises).then(function () {\n      _this._isReady = true;\n      return _this._buildMesh();\n    });\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PointsCloudSystem.prototype._buildMesh = function () {\n    if (this.nbParticles === 0) {\n      this.addPoints(1);\n    }\n\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    var vertexData = new VertexData();\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    var ec = 0; //emissive color value 0 for UVs, 1 for color\n\n    if (this._colors32.length > 0) {\n      ec = 1;\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    var mesh = new Mesh(this.name, this._scene);\n    vertexData.applyToMesh(mesh, this._updatable);\n    this.mesh = mesh; // free memory\n\n    this._positions = null;\n    this._uvs = null;\n    this._colors = null;\n\n    if (!this._updatable) {\n      this.particles.length = 0;\n    }\n\n    var mat = new StandardMaterial(\"point cloud material\", this._scene);\n    mat.emissiveColor = new Color3(ec, ec, ec);\n    mat.disableLighting = true;\n    mat.pointsCloud = true;\n    mat.pointSize = this._size;\n    mesh.material = mat;\n    return new Promise(function (resolve) {\n      return resolve(mesh);\n    });\n  }; // adds a new particle object in the particles array\n\n\n  PointsCloudSystem.prototype._addParticle = function (idx, group, groupId, idxInGroup) {\n    var cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n    this.particles.push(cp);\n    return cp;\n  };\n\n  PointsCloudSystem.prototype._randomUnitVector = function (particle) {\n    particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n    particle.color = new Color4(1, 1, 1, 1);\n  };\n\n  PointsCloudSystem.prototype._getColorIndicesForCoord = function (pointsGroup, x, y, width) {\n    var imageData = pointsGroup._groupImageData;\n    var color = y * (width * 4) + x * 4;\n    var colorIndices = [color, color + 1, color + 2, color + 3];\n    var redIndex = colorIndices[0];\n    var greenIndex = colorIndices[1];\n    var blueIndex = colorIndices[2];\n    var alphaIndex = colorIndices[3];\n    var redForCoord = imageData[redIndex];\n    var greenForCoord = imageData[greenIndex];\n    var blueForCoord = imageData[blueIndex];\n    var alphaForCoord = imageData[alphaIndex];\n    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n  };\n\n  PointsCloudSystem.prototype._setPointsColorOrUV = function (mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {\n    if (isVolume) {\n      mesh.updateFacetData();\n    }\n\n    var boundInfo = mesh.getBoundingInfo();\n    var diameter = 2 * boundInfo.boundingSphere.radius;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var place = Vector3.Zero();\n    mesh.computeWorldMatrix();\n    var meshMatrix = mesh.getWorldMatrix();\n\n    if (!meshMatrix.isIdentity()) {\n      for (var p = 0; p < meshPos.length / 3; p++) {\n        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n        meshPos[3 * p] = place.x;\n        meshPos[3 * p + 1] = place.y;\n        meshPos[3 * p + 2] = place.z;\n      }\n    }\n\n    var idxPoints = 0;\n    var index = 0;\n    var id0 = 0;\n    var id1 = 0;\n    var id2 = 0;\n    var v0X = 0;\n    var v0Y = 0;\n    var v0Z = 0;\n    var v1X = 0;\n    var v1Y = 0;\n    var v1Z = 0;\n    var v2X = 0;\n    var v2Y = 0;\n    var v2Z = 0;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var uv0X = 0;\n    var uv0Y = 0;\n    var uv1X = 0;\n    var uv1Y = 0;\n    var uv2X = 0;\n    var uv2Y = 0;\n    var uv0 = Vector2.Zero();\n    var uv1 = Vector2.Zero();\n    var uv2 = Vector2.Zero();\n    var uvec0 = Vector2.Zero();\n    var uvec1 = Vector2.Zero();\n    var col0X = 0;\n    var col0Y = 0;\n    var col0Z = 0;\n    var col0A = 0;\n    var col1X = 0;\n    var col1Y = 0;\n    var col1Z = 0;\n    var col1A = 0;\n    var col2X = 0;\n    var col2Y = 0;\n    var col2Z = 0;\n    var col2A = 0;\n    var col0 = Vector4.Zero();\n    var col1 = Vector4.Zero();\n    var col2 = Vector4.Zero();\n    var colvec0 = Vector4.Zero();\n    var colvec1 = Vector4.Zero();\n    var lamda = 0;\n    var mu = 0;\n    range = range ? range : 0;\n    var facetPoint;\n    var uvPoint;\n    var colPoint = new Vector4(0, 0, 0, 0);\n    var norm = Vector3.Zero();\n    var tang = Vector3.Zero();\n    var biNorm = Vector3.Zero();\n    var angle = 0;\n    var facetPlaneVec = Vector3.Zero();\n    var gap = 0;\n    var distance = 0;\n    var ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n    var pickInfo;\n    var direction = Vector3.Zero();\n\n    for (var index = 0; index < meshInd.length / 3; index++) {\n      id0 = meshInd[3 * index];\n      id1 = meshInd[3 * index + 1];\n      id2 = meshInd[3 * index + 2];\n      v0X = meshPos[3 * id0];\n      v0Y = meshPos[3 * id0 + 1];\n      v0Z = meshPos[3 * id0 + 2];\n      v1X = meshPos[3 * id1];\n      v1Y = meshPos[3 * id1 + 1];\n      v1Z = meshPos[3 * id1 + 2];\n      v2X = meshPos[3 * id2];\n      v2Y = meshPos[3 * id2 + 1];\n      v2Z = meshPos[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n\n      if (meshUV) {\n        uv0X = meshUV[2 * id0];\n        uv0Y = meshUV[2 * id0 + 1];\n        uv1X = meshUV[2 * id1];\n        uv1Y = meshUV[2 * id1 + 1];\n        uv2X = meshUV[2 * id2];\n        uv2Y = meshUV[2 * id2 + 1];\n        uv0.set(uv0X, uv0Y);\n        uv1.set(uv1X, uv1Y);\n        uv2.set(uv2X, uv2Y);\n        uv1.subtractToRef(uv0, uvec0);\n        uv2.subtractToRef(uv1, uvec1);\n      }\n\n      if (meshCol && colorFromTexture) {\n        col0X = meshCol[4 * id0];\n        col0Y = meshCol[4 * id0 + 1];\n        col0Z = meshCol[4 * id0 + 2];\n        col0A = meshCol[4 * id0 + 3];\n        col1X = meshCol[4 * id1];\n        col1Y = meshCol[4 * id1 + 1];\n        col1Z = meshCol[4 * id1 + 2];\n        col1A = meshCol[4 * id1 + 3];\n        col2X = meshCol[4 * id2];\n        col2Y = meshCol[4 * id2 + 1];\n        col2Z = meshCol[4 * id2 + 2];\n        col2A = meshCol[4 * id2 + 3];\n        col0.set(col0X, col0Y, col0Z, col0A);\n        col1.set(col1X, col1Y, col1Z, col1A);\n        col2.set(col2X, col2Y, col2Z, col2A);\n        col1.subtractToRef(col0, colvec0);\n        col2.subtractToRef(col1, colvec1);\n      }\n\n      var width;\n      var height;\n      var deltaS;\n      var deltaV;\n      var h;\n      var s;\n      var v;\n      var hsvCol;\n      var statedColor = new Color3(0, 0, 0);\n      var colPoint3 = new Color3(0, 0, 0);\n      var pointColors;\n      var particle;\n\n      for (var i = 0; i < pointsGroup._groupDensity[index]; i++) {\n        idxPoints = this.particles.length;\n\n        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n\n        particle = this.particles[idxPoints]; //form a point inside the facet v0, v1, v2;\n\n        lamda = Scalar.RandomRange(0, 1);\n        mu = Scalar.RandomRange(0, 1);\n        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n\n        if (isVolume) {\n          norm = mesh.getFacetNormal(index).normalize().scale(-1);\n          tang = vec0.clone().normalize();\n          biNorm = Vector3.Cross(norm, tang);\n          angle = Scalar.RandomRange(0, 2 * Math.PI);\n          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n          angle = Scalar.RandomRange(0.1, Math.PI / 2);\n          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n          ray.origin = facetPoint.add(direction.scale(0.00001));\n          ray.direction = direction;\n          ray.length = diameter;\n          pickInfo = ray.intersectsMesh(mesh);\n\n          if (pickInfo.hit) {\n            distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n            gap = Scalar.RandomRange(0, 1) * distance;\n            facetPoint.addInPlace(direction.scale(gap));\n          }\n        }\n\n        particle.position = facetPoint.clone();\n\n        this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n\n        if (colorFromTexture !== undefined) {\n          if (meshUV) {\n            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n\n            if (colorFromTexture) {\n              //Set particle color to texture color\n              if (hasTexture && pointsGroup._groupImageData !== null) {\n                width = pointsGroup._groupImgWidth;\n                height = pointsGroup._groupImgHeight;\n                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                particle.color = pointColors;\n\n                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n              } else {\n                if (meshCol) {\n                  //failure in texture and colors available\n                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                } else {\n                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n              }\n            } else {\n              //Set particle uv based on a mesh uv\n              particle.uv = uvPoint.clone();\n\n              this._uvs.push(particle.uv.x, particle.uv.y);\n            }\n          }\n        } else {\n          if (color) {\n            statedColor.set(color.r, color.g, color.b);\n            deltaS = Scalar.RandomRange(-range, range);\n            deltaV = Scalar.RandomRange(-range, range);\n            hsvCol = statedColor.toHSV();\n            h = hsvCol.r;\n            s = hsvCol.g + deltaS;\n            v = hsvCol.b + deltaV;\n\n            if (s < 0) {\n              s = 0;\n            }\n\n            if (s > 1) {\n              s = 1;\n            }\n\n            if (v < 0) {\n              v = 0;\n            }\n\n            if (v > 1) {\n              v = 1;\n            }\n\n            Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n          } else {\n            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n          }\n\n          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n\n          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n        }\n      }\n    }\n  }; // stores mesh texture in dynamic texture for color pixel retrieval\n  // when pointColor type is color for surface points\n\n\n  PointsCloudSystem.prototype._colorFromTexture = function (mesh, pointsGroup, isVolume) {\n    var _this = this;\n\n    if (mesh.material === null) {\n      Logger.Warn(mesh.name + \"has no material.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var mat = mesh.material;\n    var textureList = mat.getActiveTextures();\n\n    if (textureList.length === 0) {\n      Logger.Warn(mesh.name + \"has no useable texture.\");\n      pointsGroup._groupImageData = null;\n\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n\n      return;\n    }\n\n    var clone = mesh.clone();\n    clone.setEnabled(false);\n\n    this._promises.push(new Promise(function (resolve) {\n      BaseTexture.WhenAllReady(textureList, function () {\n        var n = pointsGroup._textureNb;\n\n        if (n < 0) {\n          n = 0;\n        }\n\n        if (n > textureList.length - 1) {\n          n = textureList.length - 1;\n        }\n\n        pointsGroup._groupImageData = textureList[n].readPixels();\n        pointsGroup._groupImgWidth = textureList[n].getSize().width;\n        pointsGroup._groupImgHeight = textureList[n].getSize().height;\n\n        _this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\n\n        clone.dispose();\n        return resolve();\n      });\n    }));\n  }; // calculates the point density per facet of a mesh for surface points\n\n\n  PointsCloudSystem.prototype._calculateDensity = function (nbPoints, positions, indices) {\n    var density = new Array();\n    var index;\n    var id0;\n    var id1;\n    var id2;\n    var v0X;\n    var v0Y;\n    var v0Z;\n    var v1X;\n    var v1Y;\n    var v1Z;\n    var v2X;\n    var v2Y;\n    var v2Z;\n    var vertex0 = Vector3.Zero();\n    var vertex1 = Vector3.Zero();\n    var vertex2 = Vector3.Zero();\n    var vec0 = Vector3.Zero();\n    var vec1 = Vector3.Zero();\n    var vec2 = Vector3.Zero();\n    var a; //length of side of triangle\n\n    var b; //length of side of triangle\n\n    var c; //length of side of triangle\n\n    var p; //perimeter of triangle\n\n    var area;\n    var areas = new Array();\n    var surfaceArea = 0;\n    var nbFacets = indices.length / 3; //surface area\n\n    for (var index = 0; index < nbFacets; index++) {\n      id0 = indices[3 * index];\n      id1 = indices[3 * index + 1];\n      id2 = indices[3 * index + 2];\n      v0X = positions[3 * id0];\n      v0Y = positions[3 * id0 + 1];\n      v0Z = positions[3 * id0 + 2];\n      v1X = positions[3 * id1];\n      v1Y = positions[3 * id1 + 1];\n      v1Z = positions[3 * id1 + 2];\n      v2X = positions[3 * id2];\n      v2Y = positions[3 * id2 + 1];\n      v2Z = positions[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      vertex2.subtractToRef(vertex0, vec2);\n      a = vec0.length();\n      b = vec1.length();\n      c = vec2.length();\n      p = (a + b + c) / 2;\n      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\n      surfaceArea += area;\n      areas[index] = area;\n    }\n\n    var pointCount = 0;\n\n    for (var index = 0; index < nbFacets; index++) {\n      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);\n      pointCount += density[index];\n    }\n\n    var diff = nbPoints - pointCount;\n    var pointsPerFacet = Math.floor(diff / nbFacets);\n    var extraPoints = diff % nbFacets;\n\n    if (pointsPerFacet > 0) {\n      density = density.map(function (x) {\n        return x + pointsPerFacet;\n      });\n    }\n\n    for (var index = 0; index < extraPoints; index++) {\n      density[index] += 1;\n    }\n\n    return density;\n  };\n  /**\r\n   * Adds points to the PCS in random positions within a unit sphere\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addPoints = function (nb, pointFunction) {\n    if (pointFunction === void 0) {\n      pointFunction = this._randomUnitVector;\n    }\n\n    var pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n    var cp; // particles\n\n    var idx = this.nbParticles;\n\n    for (var i = 0; i < nb; i++) {\n      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n\n      if (pointsGroup && pointsGroup._positionFunction) {\n        pointsGroup._positionFunction(cp, idx, i);\n      }\n\n      this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n\n      if (cp.color) {\n        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n      }\n\n      if (cp.uv) {\n        this._uvs.push(cp.uv.x, cp.uv.y);\n      }\n\n      idx++;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter;\n  };\n  /**\r\n   * Adds points to the PCS from the surface of the model shape\r\n   * @param mesh is any Mesh object that will be used as a surface model for the points\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addSurfacePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, false);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\r\n   * Adds points to the PCS inside the model shape\r\n   * @param mesh is any Mesh object that will be used as a surface model for the points\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n   * @returns the number of groups in the system\r\n   */\n\n\n  PointsCloudSystem.prototype.addVolumePoints = function (mesh, nb, colorWith, color, range) {\n    var colored = colorWith ? colorWith : PointColor.Random;\n\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n\n    this._groups.push(this._groupCounter);\n\n    var pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n\n        break;\n\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, true);\n\n        break;\n\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n\n        break;\n    }\n\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  };\n  /**\r\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n   *  This method calls `updateParticle()` for each particle of the SPS.\r\n   *  For an animated SPS, it is usually called within the render loop.\r\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n   * @returns the PCS.\r\n   */\n\n\n  PointsCloudSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || !this._isReady) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var uvs32 = this._uvs32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current index of the particle\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh._boundingInfo;\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n\n    var idx = 0; // particle index\n\n    var pindex = 0; //index in positions array\n\n    var cindex = 0; //index in color array\n\n    var uindex = 0; //index in uv array\n    // particle loop\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p];\n      idx = particle.idx;\n      pindex = 3 * idx;\n      cindex = 4 * idx;\n      uindex = 2 * idx; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleGlobalPosition = particle._globalPosition;\n\n      if (this._computeParticleRotation) {\n        particle.getRotationMatrix(rotMatrix);\n      }\n\n      var particleHasParent = particle.parentId !== null;\n\n      if (particleHasParent) {\n        var parent_1 = this.particles[particle.parentId];\n        var parentRotationMatrix = parent_1._rotationMatrix;\n        var parentGlobalPosition = parent_1._globalPosition;\n        var rotatedY_1 = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n        var rotatedX_1 = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n        var rotatedZ_1 = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX_1;\n        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY_1;\n        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ_1;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n        }\n      } else {\n        particleGlobalPosition.x = 0;\n        particleGlobalPosition.y = 0;\n        particleGlobalPosition.z = 0;\n\n        if (this._computeParticleRotation) {\n          var rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0];\n          particleRotationMatrix[1] = rotMatrixValues[1];\n          particleRotationMatrix[2] = rotMatrixValues[2];\n          particleRotationMatrix[3] = rotMatrixValues[4];\n          particleRotationMatrix[4] = rotMatrixValues[5];\n          particleRotationMatrix[5] = rotMatrixValues[6];\n          particleRotationMatrix[6] = rotMatrixValues[8];\n          particleRotationMatrix[7] = rotMatrixValues[9];\n          particleRotationMatrix[8] = rotMatrixValues[10];\n        }\n      }\n\n      var pivotBackTranslation = tempVectors[11];\n\n      if (particle.translateFromPivot) {\n        pivotBackTranslation.setAll(0.0);\n      } else {\n        pivotBackTranslation.copyFrom(particle.pivot);\n      } // positions\n\n\n      var tmpVertex = tempVectors[0];\n      tmpVertex.copyFrom(particle.position);\n      var vertexX = tmpVertex.x - particle.pivot.x;\n      var vertexY = tmpVertex.y - particle.pivot.y;\n      var vertexZ = tmpVertex.z - particle.pivot.z;\n      var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n      var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n      var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n      rotatedX += pivotBackTranslation.x;\n      rotatedY += pivotBackTranslation.y;\n      rotatedZ += pivotBackTranslation.z;\n      var px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n      var py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n      var pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n      if (this._computeBoundingBox) {\n        minimum.minimizeInPlaceFromFloats(px, py, pz);\n        maximum.maximizeInPlaceFromFloats(px, py, pz);\n      }\n\n      if (this._computeParticleColor && particle.color) {\n        var color = particle.color;\n        var colors32_1 = this._colors32;\n        colors32_1[cindex] = color.r;\n        colors32_1[cindex + 1] = color.g;\n        colors32_1[cindex + 2] = color.b;\n        colors32_1[cindex + 3] = color.a;\n      }\n\n      if (this._computeParticleTexture && particle.uv) {\n        var uv = particle.uv;\n        var uvs32_1 = this._uvs32;\n        uvs32_1[uindex] = uv.x;\n        uvs32_1[uindex + 1] = uv.y;\n      }\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n      }\n\n      if (this._computeParticleTexture) {\n        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n      }\n\n      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh._boundingInfo) {\n        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\r\n  * Disposes the PCS.\r\n  */\n\n\n  PointsCloudSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n  };\n  /**\r\n   * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n   * doc :\r\n   * @returns the PCS.\r\n   */\n\n\n  PointsCloudSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\r\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n   * @param size the size (float) of the visibility box\r\n   * note : this doesn't lock the PCS mesh bounding box.\r\n   * doc :\r\n   */\n\n\n  PointsCloudSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(PointsCloudSystem.prototype, \"isAlwaysVisible\", {\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\n    get: function () {\n      return this._alwaysVisible;\n    },\n\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\n    set: function (val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleRotation\", {\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\n    set: function (val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleColor\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    get: function () {\n      return this._computeParticleColor;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    set: function (val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeParticleTexture\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\n    get: function () {\n      return this._computeParticleTexture;\n    },\n    set: function (val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PointsCloudSystem.prototype, \"computeBoundingBox\", {\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\n    get: function () {\n      return this._computeBoundingBox;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\n    set: function (val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by users to fit their needs\n\n  /**\r\n   * This function does nothing. It may be overwritten to set all the particle first values.\r\n   * The PCS doesn't call this function, you may have to call it by your own.\r\n   * doc :\r\n   */\n\n  PointsCloudSystem.prototype.initParticles = function () {};\n  /**\r\n   * This function does nothing. It may be overwritten to recycle a particle\r\n   * The PCS doesn't call this function, you can to call it\r\n   * doc :\r\n   * @param particle The particle to recycle\r\n   * @returns the recycled particle\r\n   */\n\n\n  PointsCloudSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a particle : this function should  be overwritten by the user.\r\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n   * doc :\r\n   * @example : just set a particle position or velocity and recycle conditions\r\n   * @param particle The particle to update\r\n   * @returns the updated particle\r\n   */\n\n\n  PointsCloudSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  PointsCloudSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\r\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n   * This will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  PointsCloudSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return PointsCloudSystem;\n}();\n\nexport { PointsCloudSystem };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/pointsCloudSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Color3 } from \"../Maths/math\";\r\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\n/** Defines the 4 color options */\r\nexport enum PointColor {\r\n    /** color value */\r\n    Color = 2,\r\n    /** uv value */\r\n    UV = 1,\r\n    /** random value */\r\n    Random = 0,\r\n    /** stated value */\r\n    Stated = 3\r\n}\r\n\r\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\r\nexport class PointsCloudSystem implements IDisposable {\r\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: CloudPoint[] = new Array<CloudPoint>();\r\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The PCS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.\r\n     */\r\n    public mesh: Mesh;\r\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _size: number; //size of each point particle\r\n\r\n    private _scene: Scene;\r\n    private _promises: Array<Promise<any>> = [];\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray;           // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array;         // updated positions for the VBO\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _updatable: boolean = true;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _groups: number[] = new Array<number>();  //start indices for each group of particles\r\n    private _groupCounter: number = 0;\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _isReady: boolean = false;\r\n\r\n    /**\r\n     * Creates a PCS (Points Cloud System) object\r\n     * @param name (String) is the PCS name, this will be the underlying mesh name\r\n     * @param pointSize (number) is the size for each point\r\n     * @param scene (Scene) is the scene in which the PCS is added\r\n     * @param options defines the options of the PCS e.g.\r\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n     */\r\n    constructor(name: string, pointSize: number, scene: Scene, options?: { updatable?: boolean}) {\r\n        this.name = name;\r\n        this._size = pointSize;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n     * If no points were added to the PCS, the returned mesh is just a single point.\r\n     * @returns a promise for the created mesh\r\n     */\r\n    public buildMeshAsync(): Promise<Mesh> {\r\n        return Promise.all(this._promises).then(() => {\r\n            this._isReady = true;\r\n            return this._buildMesh();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    private _buildMesh(): Promise<Mesh> {\r\n        if (this.nbParticles === 0) {\r\n            this.addPoints(1);\r\n        }\r\n\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        var vertexData = new VertexData();\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        var ec = 0; //emissive color value 0 for UVs, 1 for color\r\n        if (this._colors32.length > 0) {\r\n            ec = 1;\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        var mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n\r\n        // free memory\r\n        (<any>this._positions) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        var mat = new StandardMaterial(\"point cloud material\", this._scene);\r\n        mat.emissiveColor = new Color3(ec, ec, ec);\r\n        mat.disableLighting = true;\r\n        mat.pointsCloud = true;\r\n        mat.pointSize = this._size;\r\n        mesh.material = mat;\r\n\r\n        return new Promise((resolve) => resolve(mesh));\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, group: PointsGroup, groupId: number, idxInGroup: number): CloudPoint {\r\n        var cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\r\n        this.particles.push(cp);\r\n        return cp;\r\n    }\r\n\r\n    private _randomUnitVector(particle: CloudPoint): void {\r\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\r\n        particle.color = new Color4(1, 1, 1, 1);\r\n    }\r\n\r\n    private _getColorIndicesForCoord(pointsGroup: PointsGroup, x: number, y: number, width: number): Color4 {\r\n        var imageData = <Uint8Array>pointsGroup._groupImageData;\r\n        var color = y * (width * 4) + x * 4;\r\n        var colorIndices = [color, color + 1, color + 2, color + 3];\r\n        var redIndex = colorIndices[0];\r\n        var greenIndex = colorIndices[1];\r\n        var blueIndex = colorIndices[2];\r\n        var alphaIndex = colorIndices[3];\r\n        var redForCoord = imageData[redIndex];\r\n        var greenForCoord = imageData[greenIndex];\r\n        var blueForCoord = imageData[blueIndex];\r\n        var alphaForCoord = imageData[alphaIndex];\r\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\r\n    }\r\n\r\n    private _setPointsColorOrUV(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean, colorFromTexture?: boolean, hasTexture?: boolean, color?: Color4, range?: number) {\r\n        if (isVolume) {\r\n            mesh.updateFacetData();\r\n        }\r\n\r\n        var boundInfo = mesh.getBoundingInfo();\r\n        var diameter = 2 * boundInfo.boundingSphere.radius;\r\n\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n        var meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        var meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        var place = Vector3.Zero();\r\n        mesh.computeWorldMatrix();\r\n        var meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        if (!meshMatrix.isIdentity()) {\r\n            for (var p = 0; p < meshPos.length / 3; p++) {\r\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\r\n                meshPos[3 * p] = place.x;\r\n                meshPos[3 * p + 1] = place.y;\r\n                meshPos[3 * p + 2] = place.z;\r\n            }\r\n        }\r\n\r\n        var idxPoints: number = 0;\r\n\r\n        var index:  number = 0;\r\n        var id0:  number = 0;\r\n        var id1:  number = 0;\r\n        var id2:  number = 0;\r\n        var v0X:  number = 0;\r\n        var v0Y:  number = 0;\r\n        var v0Z:  number = 0;\r\n        var v1X:  number = 0;\r\n        var v1Y:  number = 0;\r\n        var v1Z:  number = 0;\r\n        var v2X:  number = 0;\r\n        var v2Y:  number = 0;\r\n        var v2Z:  number = 0;\r\n        var vertex0 = Vector3.Zero();\r\n        var vertex1 = Vector3.Zero();\r\n        var vertex2 = Vector3.Zero();\r\n        var vec0 = Vector3.Zero();\r\n        var vec1 = Vector3.Zero();\r\n\r\n        var uv0X:  number = 0;\r\n        var uv0Y:  number = 0;\r\n        var uv1X:  number = 0;\r\n        var uv1Y:  number = 0;\r\n        var uv2X:  number = 0;\r\n        var uv2Y:  number = 0;\r\n        var uv0 = Vector2.Zero();\r\n        var uv1 = Vector2.Zero();\r\n        var uv2 = Vector2.Zero();\r\n        var uvec0 = Vector2.Zero();\r\n        var uvec1 = Vector2.Zero();\r\n\r\n        var col0X:  number = 0;\r\n        var col0Y:  number = 0;\r\n        var col0Z:  number = 0;\r\n        var col0A:  number = 0;\r\n        var col1X:  number = 0;\r\n        var col1Y:  number = 0;\r\n        var col1Z:  number = 0;\r\n        var col1A:  number = 0;\r\n        var col2X:  number = 0;\r\n        var col2Y:  number = 0;\r\n        var col2Z:  number = 0;\r\n        var col2A:  number = 0;\r\n        var col0 = Vector4.Zero();\r\n        var col1 = Vector4.Zero();\r\n        var col2 = Vector4.Zero();\r\n        var colvec0 = Vector4.Zero();\r\n        var colvec1 = Vector4.Zero();\r\n\r\n        var lamda:  number = 0;\r\n        var mu:  number = 0;\r\n        range = range ? range : 0;\r\n\r\n        var facetPoint: Vector3;\r\n        var uvPoint: Vector2;\r\n        var colPoint: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        var norm = Vector3.Zero();\r\n        var tang = Vector3.Zero();\r\n        var biNorm = Vector3.Zero();\r\n        var angle = 0;\r\n        var facetPlaneVec = Vector3.Zero();\r\n\r\n        var gap = 0;\r\n        var distance = 0;\r\n        var ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\r\n        var pickInfo: PickingInfo;\r\n        var direction = Vector3.Zero();\r\n\r\n        for (var index = 0; index < meshInd.length / 3; index++) {\r\n            id0 = meshInd[3 * index];\r\n            id1 = meshInd[3 * index + 1];\r\n            id2 = meshInd[3 * index + 2];\r\n            v0X = meshPos[3 * id0];\r\n            v0Y = meshPos[3 * id0 + 1];\r\n            v0Z = meshPos[3 * id0 + 2];\r\n            v1X = meshPos[3 * id1];\r\n            v1Y = meshPos[3 * id1 + 1];\r\n            v1Z = meshPos[3 * id1 + 2];\r\n            v2X = meshPos[3 * id2];\r\n            v2Y = meshPos[3 * id2 + 1];\r\n            v2Z = meshPos[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n\r\n            if (meshUV) {\r\n                uv0X = meshUV[2 * id0];\r\n                uv0Y = meshUV[2 * id0 + 1];\r\n                uv1X = meshUV[2 * id1];\r\n                uv1Y = meshUV[2 * id1 + 1];\r\n                uv2X = meshUV[2 * id2];\r\n                uv2Y = meshUV[2 * id2 + 1];\r\n                uv0.set(uv0X, uv0Y);\r\n                uv1.set(uv1X, uv1Y);\r\n                uv2.set(uv2X, uv2Y);\r\n                uv1.subtractToRef(uv0, uvec0);\r\n                uv2.subtractToRef(uv1, uvec1);\r\n            }\r\n\r\n            if (meshCol && colorFromTexture) {\r\n                col0X = meshCol[4 * id0];\r\n                col0Y = meshCol[4 * id0 + 1];\r\n                col0Z = meshCol[4 * id0 + 2];\r\n                col0A = meshCol[4 * id0 + 3];\r\n                col1X = meshCol[4 * id1];\r\n                col1Y = meshCol[4 * id1 + 1];\r\n                col1Z = meshCol[4 * id1 + 2];\r\n                col1A = meshCol[4 * id1 + 3];\r\n                col2X = meshCol[4 * id2];\r\n                col2Y = meshCol[4 * id2 + 1];\r\n                col2Z = meshCol[4 * id2 + 2];\r\n                col2A = meshCol[4 * id2 + 3];\r\n                col0.set(col0X, col0Y, col0Z, col0A);\r\n                col1.set(col1X, col1Y, col1Z, col1A);\r\n                col2.set(col2X, col2Y, col2Z, col2A);\r\n                col1.subtractToRef(col0, colvec0);\r\n                col2.subtractToRef(col1, colvec1);\r\n            }\r\n\r\n            var width: number;\r\n            var height: number;\r\n            var deltaS: number;\r\n            var deltaV: number;\r\n            var h: number;\r\n            var s: number;\r\n            var v: number;\r\n            var hsvCol: Color3;\r\n            var statedColor: Color3 = new Color3(0, 0, 0);\r\n            var colPoint3: Color3 = new Color3(0, 0, 0);\r\n            var pointColors: Color4;\r\n            var particle: CloudPoint;\r\n\r\n            for (var i = 0; i < pointsGroup._groupDensity[index]; i++) {\r\n                idxPoints = this.particles.length;\r\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\r\n                particle = this.particles[idxPoints];\r\n                //form a point inside the facet v0, v1, v2;\r\n                lamda = Scalar.RandomRange(0, 1);\r\n                mu = Scalar.RandomRange(0, 1);\r\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\r\n                if (isVolume) {\r\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\r\n                    tang = vec0.clone().normalize();\r\n                    biNorm = Vector3.Cross(norm, tang);\r\n                    angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\r\n                    angle = Scalar.RandomRange(0.1, Math.PI / 2);\r\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\r\n\r\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\r\n                    ray.direction = direction;\r\n                    ray.length = diameter;\r\n                    pickInfo = ray.intersectsMesh(mesh);\r\n                    if (pickInfo.hit) {\r\n                        distance = pickInfo.pickedPoint!.subtract(facetPoint).length();\r\n                        gap = Scalar.RandomRange(0, 1) * distance;\r\n                        facetPoint.addInPlace(direction.scale(gap));\r\n                    }\r\n                }\r\n                particle.position = facetPoint.clone();\r\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\r\n                if (colorFromTexture !== undefined) {\r\n                    if (meshUV) {\r\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\r\n                        if (colorFromTexture) { //Set particle color to texture color\r\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\r\n                                width = pointsGroup._groupImgWidth;\r\n                                height = pointsGroup._groupImgHeight;\r\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\r\n                                particle.color = pointColors;\r\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\r\n                            }\r\n                            else {\r\n                                if (meshCol) { //failure in texture and colors available\r\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                                else {\r\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                            }\r\n                        }\r\n                        else { //Set particle uv based on a mesh uv\r\n                            particle.uv = uvPoint.clone();\r\n                            this._uvs.push(particle.uv.x, particle.uv.y);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (color) {\r\n                        statedColor.set(color.r, color.g, color.b);\r\n                        deltaS = Scalar.RandomRange(-range, range);\r\n                        deltaV = Scalar.RandomRange(-range, range);\r\n                        hsvCol = statedColor.toHSV();\r\n                        h = hsvCol.r;\r\n                        s = hsvCol.g + deltaS;\r\n                        v = hsvCol.b + deltaV;\r\n                        if (s < 0) {\r\n                            s = 0;\r\n                        }\r\n                        if (s > 1) {\r\n                            s = 1;\r\n                        }\r\n                        if (v < 0) {\r\n                            v = 0;\r\n                        }\r\n                        if (v > 1) {\r\n                            v = 1;\r\n                        }\r\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\r\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\r\n                    }\r\n                    else {\r\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                    }\r\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stores mesh texture in dynamic texture for color pixel retrieval\r\n    // when pointColor type is color for surface points\r\n    private _colorFromTexture(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean): void {\r\n        if (mesh.material === null) {\r\n            Logger.Warn(mesh.name + \"has no material.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        var mat = mesh.material;\r\n        let textureList: BaseTexture[] = mat.getActiveTextures();\r\n        if (textureList.length === 0) {\r\n            Logger.Warn(mesh.name + \"has no useable texture.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        var clone = <Mesh>mesh.clone();\r\n        clone.setEnabled(false);\r\n        this._promises.push(new Promise((resolve) => {\r\n            BaseTexture.WhenAllReady(textureList, () => {\r\n                let n = pointsGroup._textureNb;\r\n                if (n < 0) {\r\n                    n = 0;\r\n                }\r\n                if (n > textureList.length - 1) {\r\n                    n =  textureList.length - 1;\r\n                }\r\n                pointsGroup._groupImageData = textureList[n].readPixels();\r\n                pointsGroup._groupImgWidth = textureList[n].getSize().width;\r\n                pointsGroup._groupImgHeight = textureList[n].getSize().height;\r\n                this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\r\n                clone.dispose();\r\n                return resolve();\r\n            });\r\n        }));\r\n    }\r\n\r\n    // calculates the point density per facet of a mesh for surface points\r\n    private _calculateDensity(nbPoints: number, positions: FloatArray, indices: FloatArray): number[] {\r\n        var density: number[] = new Array<number>();\r\n        var index: number;\r\n        var id0: number;\r\n        var id1: number;\r\n        var id2: number;\r\n        var v0X: number;\r\n        var v0Y: number;\r\n        var v0Z: number;\r\n        var v1X: number;\r\n        var v1Y: number;\r\n        var v1Z: number;\r\n        var v2X: number;\r\n        var v2Y: number;\r\n        var v2Z: number;\r\n        var vertex0 = Vector3.Zero();\r\n        var vertex1 = Vector3.Zero();\r\n        var vertex2 = Vector3.Zero();\r\n        var vec0 = Vector3.Zero();\r\n        var vec1 = Vector3.Zero();\r\n        var vec2 = Vector3.Zero();\r\n\r\n        var a: number; //length of side of triangle\r\n        var b: number; //length of side of triangle\r\n        var c: number; //length of side of triangle\r\n        var p: number; //perimeter of triangle\r\n        var area: number;\r\n        var areas: number[] = new Array<number>();\r\n        var surfaceArea: number = 0;\r\n\r\n        var nbFacets = indices.length / 3;\r\n\r\n        //surface area\r\n        for (var index = 0; index < nbFacets; index++) {\r\n            id0 = indices[3 * index];\r\n            id1 = indices[3 * index + 1];\r\n            id2 = indices[3 * index + 2];\r\n            v0X = positions[3 * id0];\r\n            v0Y = positions[3 * id0 + 1];\r\n            v0Z = positions[3 * id0 + 2];\r\n            v1X = positions[3 * id1];\r\n            v1Y = positions[3 * id1 + 1];\r\n            v1Z = positions[3 * id1 + 2];\r\n            v2X = positions[3 * id2];\r\n            v2Y = positions[3 * id2 + 1];\r\n            v2Z = positions[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n            vertex2.subtractToRef(vertex0, vec2);\r\n            a = vec0.length();\r\n            b = vec1.length();\r\n            c = vec2.length();\r\n            p = (a + b + c) / 2;\r\n            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\r\n            surfaceArea += area;\r\n            areas[index] = area;\r\n        }\r\n        var pointCount: number = 0;\r\n        for (var index = 0; index < nbFacets; index++) {\r\n            density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);\r\n            pointCount += density[index];\r\n        }\r\n\r\n        var diff: number = nbPoints - pointCount;\r\n        var pointsPerFacet: number = Math.floor(diff / nbFacets);\r\n        var extraPoints: number = diff % nbFacets;\r\n\r\n        if (pointsPerFacet > 0) {\r\n            density = density.map((x) => x + pointsPerFacet);\r\n        }\r\n\r\n        for (var index = 0; index < extraPoints; index++) {\r\n            density[index] += 1;\r\n        }\r\n\r\n        return density;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS in random positions within a unit sphere\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addPoints(nb: number, pointFunction: any = this._randomUnitVector): number {\r\n        var pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\r\n        var cp: CloudPoint;\r\n\r\n        // particles\r\n        var idx = this.nbParticles;\r\n        for (var i = 0; i < nb; i++) {\r\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\r\n            if (pointsGroup && pointsGroup._positionFunction) {\r\n                pointsGroup._positionFunction(cp, idx, i);\r\n            }\r\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\r\n            if (cp.color) {\r\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\r\n            }\r\n            if (cp.uv) {\r\n                this._uvs.push(cp.uv.x, cp.uv.y);\r\n            }\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS from the surface of the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        var colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) ||  colored < 0 || colored > 3) {\r\n            colored = PointColor.Random ;\r\n        }\r\n\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        var pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        }\r\n        else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS inside the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        var colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) ||  colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        var pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        }\r\n        else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\r\n            break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the PCS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): PointsCloudSystem {\r\n        if (!this._updatable  || !this._isReady) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const uvs32 = this._uvs32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        var idx = 0;            // current index of the particle\r\n\r\n        if (this.mesh.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = (end >= this.nbParticles) ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) { // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh._boundingInfo;\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        var idx = 0; // particle index\r\n        var pindex = 0; //index in positions array\r\n        var cindex = 0; //index in color array\r\n        var uindex = 0; //index in uv array\r\n\r\n        // particle loop\r\n        for (var p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n            idx = particle.idx;\r\n            pindex = 3 * idx;\r\n            cindex = 4 * idx;\r\n            uindex = 2 * idx;\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            if (this._computeParticleRotation) {\r\n                particle.getRotationMatrix(rotMatrix);\r\n            }\r\n\r\n            const particleHasParent = (particle.parentId !== null);\r\n            if (particleHasParent) {\r\n                const parent = this.particles[particle.parentId!];\r\n                const parentRotationMatrix = parent._rotationMatrix;\r\n                const parentGlobalPosition = parent._globalPosition;\r\n\r\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                }\r\n            }\r\n            else {\r\n                particleGlobalPosition.x = 0;\r\n                particleGlobalPosition.y = 0;\r\n                particleGlobalPosition.z = 0;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0];\r\n                    particleRotationMatrix[1] = rotMatrixValues[1];\r\n                    particleRotationMatrix[2] = rotMatrixValues[2];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4];\r\n                    particleRotationMatrix[4] = rotMatrixValues[5];\r\n                    particleRotationMatrix[5] = rotMatrixValues[6];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8];\r\n                    particleRotationMatrix[7] = rotMatrixValues[9];\r\n                    particleRotationMatrix[8] = rotMatrixValues[10];\r\n                }\r\n            }\r\n\r\n            const pivotBackTranslation = tempVectors[11];\r\n            if (particle.translateFromPivot) {\r\n                pivotBackTranslation.setAll(0.0);\r\n            }\r\n            else {\r\n                pivotBackTranslation.copyFrom(particle.pivot);\r\n            }\r\n\r\n            // positions\r\n            const tmpVertex = tempVectors[0];\r\n            tmpVertex.copyFrom(particle.position);\r\n            const vertexX = tmpVertex.x - particle.pivot.x;\r\n            const vertexY = tmpVertex.y - particle.pivot.y;\r\n            const vertexZ = tmpVertex.z - particle.pivot.z;\r\n\r\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n            rotatedX += pivotBackTranslation.x;\r\n            rotatedY += pivotBackTranslation.y;\r\n            rotatedZ += pivotBackTranslation.z;\r\n\r\n            const px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n            const py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n            const pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n\r\n            if (this._computeBoundingBox) {\r\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n            }\r\n\r\n            if (this._computeParticleColor && particle.color) {\r\n                const color = particle.color;\r\n                const colors32 = this._colors32;\r\n                colors32[cindex] = color.r;\r\n                colors32[cindex + 1] = color.g;\r\n                colors32[cindex + 2] = color.b;\r\n                colors32[cindex + 3] = color.a;\r\n            }\r\n            if (this._computeParticleTexture && particle.uv) {\r\n                const uv = particle.uv;\r\n                const uvs32 = this._uvs32;\r\n                uvs32[uindex] = uv.x;\r\n                uvs32[uindex + 1] = uv.y;\r\n            }\r\n\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (update) {\r\n            if (this._computeParticleColor) {\r\n                mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n            }\r\n            if (this._computeParticleTexture) {\r\n                mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n            }\r\n            mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n        }\r\n\r\n        if (this._computeBoundingBox) {\r\n            if (mesh._boundingInfo) {\r\n                mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n            else {\r\n                mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Disposes the PCS.\r\n    */\r\n    public dispose(): void {\r\n        this.mesh.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc :\r\n     * @returns the PCS.\r\n     */\r\n    public refreshVisibleSize(): PointsCloudSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the PCS mesh bounding box.\r\n     * doc :\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        var vis = size / 2;\r\n        this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by users to fit their needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The PCS doesn't call this function, you may have to call it by your own.\r\n     * doc :\r\n     */\r\n    public initParticles(): void {\r\n    }\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle\r\n     * The PCS doesn't call this function, you can to call it\r\n     * doc :\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc :\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}