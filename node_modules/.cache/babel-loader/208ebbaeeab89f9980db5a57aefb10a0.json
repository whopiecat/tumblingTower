{"ast":null,"code":"import { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\n\nvar HDRTools =\n/** @class */\nfunction () {\n  function HDRTools() {}\n\n  HDRTools.Ldexp = function (mantissa, exponent) {\n    if (exponent > 1023) {\n      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n\n    if (exponent < -1074) {\n      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n\n    return mantissa * Math.pow(2, exponent);\n  };\n\n  HDRTools.Rgbe2float = function (float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n      /*nonzero pixel*/\n      exponent = this.Ldexp(1.0, exponent - (128 + 8));\n      float32array[index + 0] = red * exponent;\n      float32array[index + 1] = green * exponent;\n      float32array[index + 2] = blue * exponent;\n    } else {\n      float32array[index + 0] = 0;\n      float32array[index + 1] = 0;\n      float32array[index + 2] = 0;\n    }\n  };\n\n  HDRTools.readStringLine = function (uint8array, startIndex) {\n    var line = \"\";\n    var character = \"\";\n\n    for (var i = startIndex; i < uint8array.length - startIndex; i++) {\n      character = String.fromCharCode(uint8array[i]);\n\n      if (character == \"\\n\") {\n        break;\n      }\n\n      line += character;\n    }\n\n    return line;\n  };\n  /**\r\n   * Reads header information from an RGBE texture stored in a native array.\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param uint8array The binary file stored in  native array.\r\n   * @return The header information.\r\n   */\n\n\n  HDRTools.RGBE_ReadHeader = function (uint8array) {\n    var height = 0;\n    var width = 0;\n    var line = this.readStringLine(uint8array, 0);\n\n    if (line[0] != '#' || line[1] != '?') {\n      throw \"Bad HDR Format.\";\n    }\n\n    var endOfHeader = false;\n    var findFormat = false;\n    var lineIndex = 0;\n\n    do {\n      lineIndex += line.length + 1;\n      line = this.readStringLine(uint8array, lineIndex);\n\n      if (line == \"FORMAT=32-bit_rle_rgbe\") {\n        findFormat = true;\n      } else if (line.length == 0) {\n        endOfHeader = true;\n      }\n    } while (!endOfHeader);\n\n    if (!findFormat) {\n      throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n\n    lineIndex += line.length + 1;\n    line = this.readStringLine(uint8array, lineIndex);\n    var sizeRegexp = /^\\-Y (.*) \\+X (.*)$/g;\n    var match = sizeRegexp.exec(line); // TODO. Support +Y and -X if needed.\n\n    if (!match || match.length < 3) {\n      throw \"HDR Bad header format, no size\";\n    }\n\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n\n    if (width < 8 || width > 0x7fff) {\n      throw \"HDR Bad header format, unsupported size\";\n    }\n\n    lineIndex += line.length + 1;\n    return {\n      height: height,\n      width: width,\n      dataPosition: lineIndex\n    };\n  };\n  /**\r\n   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n   * This RGBE texture needs to store the information as a panorama.\r\n   *\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param buffer The binary file stored in an array buffer.\r\n   * @param size The expected size of the extracted cubemap.\r\n   * @return The Cube Map information.\r\n   */\n\n\n  HDRTools.GetCubeMapTextureData = function (buffer, size) {\n    var uint8array = new Uint8Array(buffer);\n    var hdrInfo = this.RGBE_ReadHeader(uint8array);\n    var data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n    var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n    return cubeMapData;\n  };\n  /**\r\n   * Returns the pixels data extracted from an RGBE texture.\r\n   * This pixels will be stored left to right up to down in the R G B order in one array.\r\n   *\r\n   * More information on this format are available here:\r\n   * https://en.wikipedia.org/wiki/RGBE_image_format\r\n   *\r\n   * @param uint8array The binary file stored in an array buffer.\r\n   * @param hdrInfo The header information of the file.\r\n   * @return The pixels data in RGB right to left up to down order.\r\n   */\n\n\n  HDRTools.RGBE_ReadPixels = function (uint8array, hdrInfo) {\n    return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\n  };\n\n  HDRTools.RGBE_ReadPixels_RLE = function (uint8array, hdrInfo) {\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, count;\n    var dataIndex = hdrInfo.dataPosition;\n    var index = 0,\n        endIndex = 0,\n        i = 0;\n    var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n\n    var scanLineArray = new Uint8Array(scanLineArrayBuffer); // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      a = uint8array[dataIndex++];\n      b = uint8array[dataIndex++];\n      c = uint8array[dataIndex++];\n      d = uint8array[dataIndex++];\n\n      if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n        return this.RGBE_ReadPixels_NOT_RLE(uint8array, hdrInfo);\n      }\n\n      if ((c << 8 | d) != scanline_width) {\n        throw \"HDR Bad header format, wrong scan line width\";\n      }\n\n      index = 0; // read each of the four channels for the scanline into the buffer\n\n      for (i = 0; i < 4; i++) {\n        endIndex = (i + 1) * scanline_width;\n\n        while (index < endIndex) {\n          a = uint8array[dataIndex++];\n          b = uint8array[dataIndex++];\n\n          if (a > 128) {\n            // a run of the same value\n            count = a - 128;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (run)\";\n            }\n\n            while (count-- > 0) {\n              scanLineArray[index++] = b;\n            }\n          } else {\n            // a non-run\n            count = a;\n\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (non-run)\";\n            }\n\n            scanLineArray[index++] = b;\n\n            if (--count > 0) {\n              for (var j = 0; j < count; j++) {\n                scanLineArray[index++] = uint8array[dataIndex++];\n              }\n            }\n          }\n        }\n      } // now convert data from buffer into floats\n\n\n      for (i = 0; i < scanline_width; i++) {\n        a = scanLineArray[i];\n        b = scanLineArray[i + scanline_width];\n        c = scanLineArray[i + 2 * scanline_width];\n        d = scanLineArray[i + 3 * scanline_width];\n        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  HDRTools.RGBE_ReadPixels_NOT_RLE = function (uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    var num_scanlines = hdrInfo.height;\n    var scanline_width = hdrInfo.width;\n    var a, b, c, d, i;\n    var dataIndex = hdrInfo.dataPosition; // 3 channels of 4 bytes per pixel in float.\n\n    var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    var resultArray = new Float32Array(resultBuffer); // read in each successive scanline\n\n    while (num_scanlines > 0) {\n      for (i = 0; i < hdrInfo.width; i++) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n\n      num_scanlines--;\n    }\n\n    return resultArray;\n  };\n\n  return HDRTools;\n}();\n\nexport { HDRTools };","map":{"version":3,"sources":["../../../../sourceES6/core/Misc/HighDynamicRange/hdr.ts"],"names":[],"mappings":"AAAA,SAAsB,sBAAtB,QAAoD,qBAApD;AAsBA;;;;AAGA,IAAA,QAAA;AAAA;AAAA,YAAA;AAAA,WAAA,QAAA,GAAA,CAyQC;;AAvQkB,EAAA,QAAA,CAAA,KAAA,GAAf,UAAqB,QAArB,EAAuC,QAAvC,EAAuD;AACnD,QAAI,QAAQ,GAAG,IAAf,EAAqB;AACjB,aAAO,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAZ,CAAX,GAA+B,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,QAAQ,GAAG,IAAvB,CAAtC;AACH;;AAED,QAAI,QAAQ,GAAG,CAAC,IAAhB,EAAsB;AAClB,aAAO,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,CAAC,IAAb,CAAX,GAAgC,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,QAAQ,GAAG,IAAvB,CAAvC;AACH;;AAED,WAAO,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,QAAZ,CAAlB;AACH,GAVc;;AAYA,EAAA,QAAA,CAAA,UAAA,GAAf,UAA0B,YAA1B,EACI,GADJ,EACiB,KADjB,EACgC,IADhC,EAC8C,QAD9C,EAEI,KAFJ,EAEiB;AACb,QAAI,QAAQ,GAAG,CAAf,EAAkB;AAAI;AAClB,MAAA,QAAQ,GAAG,KAAK,KAAL,CAAW,GAAX,EAAgB,QAAQ,IAAI,MAAM,CAAV,CAAxB,CAAX;AAEA,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,GAAG,GAAG,QAAhC;AACA,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,KAAK,GAAG,QAAlC;AACA,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,IAAI,GAAG,QAAjC;AACH,KAND,MAOK;AACD,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,CAA1B;AACA,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,CAA1B;AACA,MAAA,YAAY,CAAC,KAAK,GAAG,CAAT,CAAZ,GAA0B,CAA1B;AACH;AACJ,GAfc;;AAiBA,EAAA,QAAA,CAAA,cAAA,GAAf,UAA8B,UAA9B,EAAsD,UAAtD,EAAwE;AACpE,QAAI,IAAI,GAAG,EAAX;AACA,QAAI,SAAS,GAAG,EAAhB;;AAEA,SAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,GAAG,UAAU,CAAC,MAAX,GAAoB,UAAjD,EAA6D,CAAC,EAA9D,EAAkE;AAC9D,MAAA,SAAS,GAAG,MAAM,CAAC,YAAP,CAAoB,UAAU,CAAC,CAAD,CAA9B,CAAZ;;AAEA,UAAI,SAAS,IAAI,IAAjB,EAAuB;AACnB;AACH;;AAED,MAAA,IAAI,IAAI,SAAR;AACH;;AAED,WAAO,IAAP;AACH,GAfc;AAiBf;;;;;;;;;;AAQc,EAAA,QAAA,CAAA,eAAA,GAAd,UAA8B,UAA9B,EAAoD;AAChD,QAAI,MAAM,GAAW,CAArB;AACA,QAAI,KAAK,GAAW,CAApB;AAEA,QAAI,IAAI,GAAG,KAAK,cAAL,CAAoB,UAApB,EAAgC,CAAhC,CAAX;;AACA,QAAI,IAAI,CAAC,CAAD,CAAJ,IAAW,GAAX,IAAkB,IAAI,CAAC,CAAD,CAAJ,IAAW,GAAjC,EAAsC;AAClC,YAAM,iBAAN;AACH;;AAED,QAAI,WAAW,GAAG,KAAlB;AACA,QAAI,UAAU,GAAG,KAAjB;AACA,QAAI,SAAS,GAAW,CAAxB;;AAEA,OAAG;AACC,MAAA,SAAS,IAAK,IAAI,CAAC,MAAL,GAAc,CAA5B;AACA,MAAA,IAAI,GAAG,KAAK,cAAL,CAAoB,UAApB,EAAgC,SAAhC,CAAP;;AAEA,UAAI,IAAI,IAAI,wBAAZ,EAAsC;AAClC,QAAA,UAAU,GAAG,IAAb;AACH,OAFD,MAGK,IAAI,IAAI,CAAC,MAAL,IAAe,CAAnB,EAAsB;AACvB,QAAA,WAAW,GAAG,IAAd;AACH;AACJ,KAVD,QAUS,CAAC,WAVV;;AAYA,QAAI,CAAC,UAAL,EAAiB;AACb,YAAM,2CAAN;AACH;;AAED,IAAA,SAAS,IAAK,IAAI,CAAC,MAAL,GAAc,CAA5B;AACA,IAAA,IAAI,GAAG,KAAK,cAAL,CAAoB,UAApB,EAAgC,SAAhC,CAAP;AAEA,QAAI,UAAU,GAAG,sBAAjB;AACA,QAAI,KAAK,GAAG,UAAU,CAAC,IAAX,CAAgB,IAAhB,CAAZ,CAjCgD,CAmChD;;AACA,QAAI,CAAC,KAAD,IAAU,KAAK,CAAC,MAAN,GAAe,CAA7B,EAAgC;AAC5B,YAAM,gCAAN;AACH;;AACD,IAAA,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAD,CAAN,CAAhB;AACA,IAAA,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAD,CAAN,CAAjB;;AAEA,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,GAAG,MAAzB,EAAiC;AAC7B,YAAM,yCAAN;AACH;;AAED,IAAA,SAAS,IAAK,IAAI,CAAC,MAAL,GAAc,CAA5B;AAEA,WAAO;AACH,MAAA,MAAM,EAAE,MADL;AAEH,MAAA,KAAK,EAAE,KAFJ;AAGH,MAAA,YAAY,EAAE;AAHX,KAAP;AAKH,GArDa;AAuDd;;;;;;;;;;;;;AAWc,EAAA,QAAA,CAAA,qBAAA,GAAd,UAAoC,MAApC,EAAyD,IAAzD,EAAqE;AACjE,QAAI,UAAU,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAjB;AACA,QAAI,OAAO,GAAG,KAAK,eAAL,CAAqB,UAArB,CAAd;AACA,QAAI,IAAI,GAAG,KAAK,eAAL,CAAqB,UAArB,EAAiC,OAAjC,CAAX;AAEA,QAAI,WAAW,GAAG,sBAAsB,CAAC,wBAAvB,CAAgD,IAAhD,EAAsD,OAAO,CAAC,KAA9D,EAAqE,OAAO,CAAC,MAA7E,EAAqF,IAArF,CAAlB;AAEA,WAAO,WAAP;AACH,GARa;AAUd;;;;;;;;;;;;;AAWc,EAAA,QAAA,CAAA,eAAA,GAAd,UAA8B,UAA9B,EAAsD,OAAtD,EAAsE;AAClE,WAAO,KAAK,mBAAL,CAAyB,UAAzB,EAAqC,OAArC,CAAP;AACH,GAFa;;AAIC,EAAA,QAAA,CAAA,mBAAA,GAAf,UAAmC,UAAnC,EAA2D,OAA3D,EAA2E;AACvE,QAAI,aAAa,GAAG,OAAO,CAAC,MAA5B;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,KAA7B;AAEA,QAAI,CAAJ,EAAe,CAAf,EAA0B,CAA1B,EAAqC,CAArC,EAAgD,KAAhD;AACA,QAAI,SAAS,GAAG,OAAO,CAAC,YAAxB;AACA,QAAI,KAAK,GAAG,CAAZ;AAAA,QAAe,QAAQ,GAAG,CAA1B;AAAA,QAA6B,CAAC,GAAG,CAAjC;AAEA,QAAI,mBAAmB,GAAG,IAAI,WAAJ,CAAgB,cAAc,GAAG,CAAjC,CAA1B,CARuE,CAQR;;AAC/D,QAAI,aAAa,GAAG,IAAI,UAAJ,CAAe,mBAAf,CAApB,CATuE,CAWvE;;AACA,QAAI,YAAY,GAAG,IAAI,WAAJ,CAAgB,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,MAAxB,GAAiC,CAAjC,GAAqC,CAArD,CAAnB;AACA,QAAI,WAAW,GAAG,IAAI,YAAJ,CAAiB,YAAjB,CAAlB,CAbuE,CAevE;;AACA,WAAO,aAAa,GAAG,CAAvB,EAA0B;AACtB,MAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,MAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,MAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,MAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;;AAEA,UAAI,CAAC,IAAI,CAAL,IAAU,CAAC,IAAI,CAAf,IAAqB,CAAC,GAAG,IAAzB,IAAkC,OAAO,CAAC,KAAR,GAAgB,CAAlD,IAAuD,OAAO,CAAC,KAAR,GAAgB,KAA3E,EAAkF;AAC9E,eAAO,KAAK,uBAAL,CAA6B,UAA7B,EAAyC,OAAzC,CAAP;AACH;;AAED,UAAI,CAAE,CAAC,IAAI,CAAN,GAAW,CAAZ,KAAkB,cAAtB,EAAsC;AAClC,cAAM,8CAAN;AACH;;AAED,MAAA,KAAK,GAAG,CAAR,CAdsB,CAgBtB;;AACA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,CAAhB,EAAmB,CAAC,EAApB,EAAwB;AACpB,QAAA,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAL,IAAU,cAArB;;AAEA,eAAO,KAAK,GAAG,QAAf,EAAyB;AACrB,UAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,UAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;;AAEA,cAAI,CAAC,GAAG,GAAR,EAAa;AACT;AACA,YAAA,KAAK,GAAG,CAAC,GAAG,GAAZ;;AACA,gBAAK,KAAK,IAAI,CAAV,IAAiB,KAAK,GAAG,QAAQ,GAAG,KAAxC,EAAgD;AAC5C,oBAAM,yCAAN;AACH;;AAED,mBAAO,KAAK,KAAK,CAAjB,EAAoB;AAChB,cAAA,aAAa,CAAC,KAAK,EAAN,CAAb,GAAyB,CAAzB;AACH;AACJ,WAVD,MAWK;AACD;AACA,YAAA,KAAK,GAAG,CAAR;;AACA,gBAAK,KAAK,IAAI,CAAV,IAAiB,KAAK,GAAG,QAAQ,GAAG,KAAxC,EAAgD;AAC5C,oBAAM,6CAAN;AACH;;AAED,YAAA,aAAa,CAAC,KAAK,EAAN,CAAb,GAAyB,CAAzB;;AACA,gBAAI,EAAE,KAAF,GAAU,CAAd,EAAiB;AACb,mBAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC5B,gBAAA,aAAa,CAAC,KAAK,EAAN,CAAb,GAAyB,UAAU,CAAC,SAAS,EAAV,CAAnC;AACH;AACJ;AACJ;AACJ;AACJ,OAlDqB,CAoDtB;;;AACA,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,cAAhB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,QAAA,CAAC,GAAG,aAAa,CAAC,CAAD,CAAjB;AACA,QAAA,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,cAAL,CAAjB;AACA,QAAA,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,IAAI,cAAT,CAAjB;AACA,QAAA,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,IAAI,cAAT,CAAjB;AAEA,aAAK,UAAL,CAAgB,WAAhB,EACI,CADJ,EACO,CADP,EACU,CADV,EACa,CADb,EAEI,CAAC,OAAO,CAAC,MAAR,GAAiB,aAAlB,IAAmC,cAAnC,GAAoD,CAApD,GAAwD,CAAC,GAAG,CAFhE;AAGH;;AAED,MAAA,aAAa;AAChB;;AAED,WAAO,WAAP;AACH,GApFc;;AAsFA,EAAA,QAAA,CAAA,uBAAA,GAAf,UAAuC,UAAvC,EAA+D,OAA/D,EAA+E;AAC3E;AACA;AAEA,QAAI,aAAa,GAAG,OAAO,CAAC,MAA5B;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,KAA7B;AAEA,QAAI,CAAJ,EAAe,CAAf,EAA0B,CAA1B,EAAqC,CAArC,EAAgD,CAAhD;AACA,QAAI,SAAS,GAAG,OAAO,CAAC,YAAxB,CAR2E,CAU3E;;AACA,QAAI,YAAY,GAAG,IAAI,WAAJ,CAAgB,OAAO,CAAC,KAAR,GAAgB,OAAO,CAAC,MAAxB,GAAiC,CAAjC,GAAqC,CAArD,CAAnB;AACA,QAAI,WAAW,GAAG,IAAI,YAAJ,CAAiB,YAAjB,CAAlB,CAZ2E,CAc3E;;AACA,WAAO,aAAa,GAAG,CAAvB,EAA0B;AACtB,WAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAO,CAAC,KAAxB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,QAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,QAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,QAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AACA,QAAA,CAAC,GAAG,UAAU,CAAC,SAAS,EAAV,CAAd;AAEA,aAAK,UAAL,CAAgB,WAAhB,EACI,CADJ,EACO,CADP,EACU,CADV,EACa,CADb,EAEI,CAAC,OAAO,CAAC,MAAR,GAAiB,aAAlB,IAAmC,cAAnC,GAAoD,CAApD,GAAwD,CAAC,GAAG,CAFhE;AAGH;;AAED,MAAA,aAAa;AAChB;;AAED,WAAO,WAAP;AACH,GA/Bc;;AAgCnB,SAAA,QAAA;AAAC,CAzQD,EAAA","sourcesContent":["import { CubeMapInfo, PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n\r\n    private static Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static Rgbe2float(float32array: Float32Array,\r\n        red: number, green: number, blue: number, exponent: number,\r\n        index: number) {\r\n        if (exponent > 0) {   /*nonzero pixel*/\r\n            exponent = this.Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        }\r\n        else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static readStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        var line = \"\";\r\n        var character = \"\";\r\n\r\n        for (var i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @return The header information.\r\n     */\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        var height: number = 0;\r\n        var width: number = 0;\r\n\r\n        var line = this.readStringLine(uint8array, 0);\r\n        if (line[0] != '#' || line[1] != '?') {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        var endOfHeader = false;\r\n        var findFormat = false;\r\n        var lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += (line.length + 1);\r\n            line = this.readStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            }\r\n            else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += (line.length + 1);\r\n        line = this.readStringLine(uint8array, lineIndex);\r\n\r\n        var sizeRegexp = /^\\-Y (.*) \\+X (.*)$/g;\r\n        var match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += (line.length + 1);\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @return The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo {\r\n        var uint8array = new Uint8Array(buffer);\r\n        var hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        var data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @return The pixels data in RGB right to left up to down order.\r\n     */\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static RGBE_ReadPixels_RLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        var num_scanlines = hdrInfo.height;\r\n        var scanline_width = hdrInfo.width;\r\n\r\n        var a: number, b: number, c: number, d: number, count: number;\r\n        var dataIndex = hdrInfo.dataPosition;\r\n        var index = 0, endIndex = 0, i = 0;\r\n\r\n        var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        var scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        var resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || (c & 0x80) || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this.RGBE_ReadPixels_NOT_RLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if ((count == 0) || (count > endIndex - index)) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if ((count == 0) || (count > endIndex - index)) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (var j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this.Rgbe2float(resultArray,\r\n                    a, b, c, d,\r\n                    (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static RGBE_ReadPixels_NOT_RLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        var num_scanlines = hdrInfo.height;\r\n        var scanline_width = hdrInfo.width;\r\n\r\n        var a: number, b: number, c: number, d: number, i: number;\r\n        var dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        var resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this.Rgbe2float(resultArray,\r\n                    a, b, c, d,\r\n                    (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}