{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { Gizmo } from \"./gizmo\";\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\n/**\r\n * Gizmo that enables rotating a mesh along 3 axis\r\n */\n\nvar RotationGizmo =\n/** @class */\nfunction (_super) {\n  __extends(RotationGizmo, _super);\n  /**\r\n   * Creates a RotationGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function RotationGizmo(gizmoLayer, tessellation, useEulerRotation, thickness, gizmoManager) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (tessellation === void 0) {\n      tessellation = 32;\n    }\n\n    if (useEulerRotation === void 0) {\n      useEulerRotation = false;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n    /** Fires an event when any of it's sub gizmos are dragged */\n\n\n    _this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n\n    _this.onDragEndObservable = new Observable();\n    _this._observables = [];\n    /** Node Caching for quick lookup */\n\n    _this._gizmoAxisCache = new Map();\n    _this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness);\n    _this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness);\n    _this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, tessellation, _this, useEulerRotation, thickness); // Relay drag events\n\n    [_this.xGizmo, _this.yGizmo, _this.zGizmo].forEach(function (gizmo) {\n      gizmo.dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(function () {\n        _this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    _this.attachedMesh = null;\n    _this.attachedNode = null;\n\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(_this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, _this._gizmoAxisCache);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(RotationGizmo.prototype, \"attachedMesh\", {\n    get: function () {\n      return this._meshAttached;\n    },\n    set: function (mesh) {\n      this._meshAttached = mesh;\n      this._nodeAttached = mesh;\n\n      this._checkBillboardTransform();\n\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedMesh = mesh;\n        } else {\n          gizmo.attachedMesh = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"attachedNode\", {\n    get: function () {\n      return this._nodeAttached;\n    },\n    set: function (node) {\n      this._meshAttached = null;\n      this._nodeAttached = node;\n\n      this._checkBillboardTransform();\n\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        if (gizmo.isEnabled) {\n          gizmo.attachedNode = node;\n        } else {\n          gizmo.attachedNode = null;\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RotationGizmo.prototype._checkBillboardTransform = function () {\n    if (this._nodeAttached && this._nodeAttached.billboardMode) {\n      console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\n    }\n  };\n\n  Object.defineProperty(RotationGizmo.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\n    get: function () {\n      var hovered = false;\n      [this.xGizmo, this.yGizmo, this.zGizmo].forEach(function (gizmo) {\n        hovered = hovered || gizmo.isHovered;\n      });\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function () {\n      return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n    },\n    set: function (value) {\n      if (this.xGizmo) {\n        this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"snapDistance\", {\n    get: function () {\n      return this.xGizmo.snapDistance;\n    },\n\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\n    set: function (value) {\n      if (this.xGizmo) {\n        this.xGizmo.snapDistance = value;\n        this.yGizmo.snapDistance = value;\n        this.zGizmo.snapDistance = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RotationGizmo.prototype, \"scaleRatio\", {\n    get: function () {\n      return this.xGizmo.scaleRatio;\n    },\n\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n    set: function (value) {\n      if (this.xGizmo) {\n        this.xGizmo.scaleRatio = value;\n        this.yGizmo.scaleRatio = value;\n        this.zGizmo.scaleRatio = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n   * @param mesh Axis gizmo mesh\r\n   * @param cache Gizmo axis definition used for reactive gizmo UI\r\n   */\n\n  RotationGizmo.prototype.addToAxisCache = function (mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  RotationGizmo.prototype.dispose = function () {\n    var _this = this;\n\n    this.xGizmo.dispose();\n    this.yGizmo.dispose();\n    this.zGizmo.dispose();\n    this.onDragStartObservable.clear();\n    this.onDragEndObservable.clear();\n\n    this._observables.forEach(function (obs) {\n      _this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n  };\n  /**\r\n   * CustomMeshes are not supported by this gizmo\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   */\n\n\n  RotationGizmo.prototype.setCustomMesh = function (mesh) {\n    Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n  };\n\n  return RotationGizmo;\n}(Gizmo);\n\nexport { RotationGizmo };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/rotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Gizmo, GizmoAxisCache } from \"./gizmo\";\r\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Node } from \"../node\";\r\nimport { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { GizmoManager } from './gizmoManager';\r\n/**\r\n * Gizmo that enables rotating a mesh along 3 axis\r\n */\r\nexport class RotationGizmo extends Gizmo {\r\n    /**\r\n     * Internal gizmo used for interactions on the x axis\r\n     */\r\n    public xGizmo: PlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the y axis\r\n     */\r\n    public yGizmo: PlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the z axis\r\n     */\r\n    public zGizmo: PlaneRotationGizmo;\r\n\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    public onDragStartObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    public onDragEndObservable = new Observable();\r\n\r\n    private _meshAttached: Nullable<AbstractMesh>;\r\n    private _nodeAttached: Nullable<Node>;\r\n    private _observables: Observer<PointerInfo>[] = [];\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n\r\n    public get attachedMesh() {\r\n        return this._meshAttached;\r\n    }\r\n    public set attachedMesh(mesh: Nullable<AbstractMesh>) {\r\n        this._meshAttached = mesh;\r\n        this._nodeAttached = mesh;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedMesh = mesh;\r\n            }\r\n            else {\r\n                gizmo.attachedMesh = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get attachedNode() {\r\n        return this._nodeAttached;\r\n    }\r\n    public set attachedNode(node: Nullable<Node>) {\r\n        this._meshAttached = null;\r\n        this._nodeAttached = node;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedNode = node;\r\n            }\r\n            else {\r\n                gizmo.attachedNode = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _checkBillboardTransform() {\r\n        if (this._nodeAttached && (<TransformNode>this._nodeAttached).billboardMode) {\r\n            console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        var hovered = false;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            hovered = hovered || gizmo.isHovered;\r\n        });\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Creates a RotationGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness: number = 1, gizmoManager?: GizmoManager) {\r\n        super(gizmoLayer);\r\n        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n\r\n        // Relay drag events\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\r\n                this.onDragEndObservable.notifyObservers({});\r\n            });\r\n        });\r\n\r\n        this.attachedMesh = null;\r\n        this.attachedNode = null;\r\n\r\n        if (gizmoManager) {\r\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\r\n        } else {\r\n            // Only subscribe to pointer event if gizmoManager isnt\r\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\r\n        }\r\n    }\r\n\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public set snapDistance(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.snapDistance = value;\r\n            this.yGizmo.snapDistance = value;\r\n            this.zGizmo.snapDistance = value;\r\n        }\r\n    }\r\n    public get snapDistance() {\r\n        return this.xGizmo.snapDistance;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.scaleRatio = value;\r\n            this.yGizmo.scaleRatio = value;\r\n            this.zGizmo.scaleRatio = value;\r\n        }\r\n    }\r\n    public get scaleRatio() {\r\n        return this.xGizmo.scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(mesh: Mesh, cache: GizmoAxisCache) {\r\n        this._gizmoAxisCache.set(mesh, cache);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.xGizmo.dispose();\r\n        this.yGizmo.dispose();\r\n        this.zGizmo.dispose();\r\n        this.onDragStartObservable.clear();\r\n        this.onDragEndObservable.clear();\r\n        this._observables.forEach((obs) => {\r\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}