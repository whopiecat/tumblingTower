{"ast":null,"code":"import { Scene } from \"../../scene\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\nimport { Ray } from \"../../Culling/ray\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { Octree } from \"./octree\";\n\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  if (!this._selectionOctree) {\n    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n  }\n\n  var worldExtends = this.getWorldExtends(); // Update octree\n\n  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n\n  return this._selectionOctree;\n};\n\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n  get: function () {\n    return this._selectionOctree;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n */\n\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity, maxDepth) {\n  if (maxCapacity === void 0) {\n    maxCapacity = 64;\n  }\n\n  if (maxDepth === void 0) {\n    maxDepth = 2;\n  }\n\n  var scene = this.getScene();\n\n  var component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n\n  if (!component) {\n    component = new OctreeSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n\n  if (!this._submeshesOctree) {\n    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n  }\n\n  this.computeWorldMatrix(true);\n  var boundingInfo = this.getBoundingInfo(); // Update octree\n\n  var bbox = boundingInfo.boundingBox;\n\n  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n\n  return this._submeshesOctree;\n};\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\n\n\nvar OctreeSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function OctreeSceneComponent(scene) {\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_OCTREE;\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\n\n    this.checksIsEnabled = true;\n    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n    this.scene = scene;\n    this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\n    this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\n    this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\n    this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  OctreeSceneComponent.prototype.register = function () {\n    var _this = this;\n\n    this.scene.onMeshRemovedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        var index = sceneOctree.dynamicContent.indexOf(mesh);\n\n        if (index !== -1) {\n          sceneOctree.dynamicContent.splice(index, 1);\n        }\n      }\n    });\n    this.scene.onMeshImportedObservable.add(function (mesh) {\n      var sceneOctree = _this.scene.selectionOctree;\n\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        sceneOctree.addMesh(mesh);\n      }\n    });\n  };\n  /**\r\n   * Return the list of active meshes\r\n   * @returns the list of active meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveMeshCandidates = function () {\n    if (this.scene._selectionOctree) {\n      var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);\n\n      return selection;\n    }\n\n    return this.scene._getDefaultMeshCandidates();\n  };\n  /**\r\n   * Return the list of active sub meshes\r\n   * @param mesh The mesh to get the candidates sub meshes from\r\n   * @returns the list of active sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getActiveSubMeshCandidates = function (mesh) {\n    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n      var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Return the list of sub meshes intersecting with a given local ray\r\n   * @param mesh defines the mesh to find the submesh for\r\n   * @param localRay defines the ray in local space\r\n   * @returns the list of intersecting sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getIntersectingSubMeshCandidates = function (mesh, localRay) {\n    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n\n      var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Return the list of sub meshes colliding with a collider\r\n   * @param mesh defines the mesh to find the submesh for\r\n   * @param collider defines the collider to evaluate the collision against\r\n   * @returns the list of colliding sub meshes\r\n   */\n\n\n  OctreeSceneComponent.prototype.getCollidingSubMeshCandidates = function (mesh, collider) {\n    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n      var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n\n      var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n\n      return intersections;\n    }\n\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  OctreeSceneComponent.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  OctreeSceneComponent.prototype.dispose = function () {// Nothing to do here.\n  };\n\n  return OctreeSceneComponent;\n}();\n\nexport { OctreeSceneComponent };","map":{"version":3,"sources":["../../../../sourceES6/core/Culling/Octrees/octreeSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { ISmartArrayLike } from \"../../Misc/smartArray\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\n\r\nimport { Octree } from \"./octree\";\r\n\r\ndeclare type Collider = import(\"../../Collisions/collider\").Collider;\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * @hidden\r\n         * Backing Filed\r\n         */\r\n        _selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Gets the octree used to boost mesh selection (picking)\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         */\r\n        selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Creates or updates the octree used to boost selection (picking)\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         * @param maxCapacity defines the maximum capacity per leaf\r\n         * @param maxDepth defines the maximum depth of the octree\r\n         * @returns an octree of AbstractMesh\r\n         */\r\n        createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;\r\n    }\r\n}\r\n\r\nScene.prototype.createOrUpdateSelectionOctree = function(maxCapacity = 64, maxDepth = 2): Octree<AbstractMesh> {\r\n    let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    if (!this._selectionOctree) {\r\n        this._selectionOctree = new Octree<AbstractMesh>(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    var worldExtends = this.getWorldExtends();\r\n\r\n    // Update octree\r\n    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\r\n\r\n    return this._selectionOctree;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\r\n    get: function(this: Scene) {\r\n        return this._selectionOctree;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * @hidden\r\n         * Backing Field\r\n         */\r\n        _submeshesOctree: Octree<SubMesh>;\r\n\r\n        /**\r\n         * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n         * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n         * @param maxCapacity defines the maximum size of each block (64 by default)\r\n         * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n         * @returns the new octree\r\n         * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n         * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n         */\r\n        createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;\r\n    }\r\n}\r\n\r\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees\r\n */\r\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function(maxCapacity = 64, maxDepth = 2): Octree<SubMesh> {\r\n    const scene = this.getScene();\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n\r\n    if (!this._submeshesOctree) {\r\n        this._submeshesOctree = new Octree<SubMesh>(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    this.computeWorldMatrix(true);\r\n\r\n    let boundingInfo = this.getBoundingInfo();\r\n\r\n    // Update octree\r\n    var bbox = boundingInfo.boundingBox;\r\n    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\r\n\r\n    return this._submeshesOctree;\r\n};\r\n\r\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\r\nexport class OctreeSceneComponent {\r\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_OCTREE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\r\n    public readonly checksIsEnabled = true;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n\r\n        this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this);\r\n\r\n        this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this);\r\n        this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this);\r\n        this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene.onMeshRemovedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                var index = sceneOctree.dynamicContent.indexOf(mesh);\r\n\r\n                if (index !== -1) {\r\n                    sceneOctree.dynamicContent.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.onMeshImportedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                sceneOctree.addMesh(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the list of active meshes\r\n     * @returns the list of active meshes\r\n     */\r\n    public getActiveMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        if (this.scene._selectionOctree) {\r\n            var selection = this.scene._selectionOctree.select(this.scene.frustumPlanes);\r\n            return selection;\r\n        }\r\n        return this.scene._getDefaultMeshCandidates();\r\n    }\r\n\r\n    /**\r\n     * Return the list of active sub meshes\r\n     * @param mesh The mesh to get the candidates sub meshes from\r\n     * @returns the list of active sub meshes\r\n     */\r\n    public getActiveSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\r\n            var intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    private _tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\r\n    /**\r\n     * Return the list of sub meshes intersecting with a given local ray\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param localRay defines the ray in local space\r\n     * @returns the list of intersecting sub meshes\r\n     */\r\n    public getIntersectingSubMeshCandidates(mesh: AbstractMesh, localRay: Ray): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\r\n            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\r\n            var intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Return the list of sub meshes colliding with a collider\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param collider defines the collider to evaluate the collision against\r\n     * @returns the list of colliding sub meshes\r\n     */\r\n    public getCollidingSubMeshCandidates(mesh: AbstractMesh, collider: Collider): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\r\n            var radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\r\n            var intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}