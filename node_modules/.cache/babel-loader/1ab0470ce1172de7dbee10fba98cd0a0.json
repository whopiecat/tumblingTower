{"ast":null,"code":"import { Animation } from \"./animation\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Observable } from \"../Misc/observable\";\nimport { Scene } from \"../scene\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\nimport { PrecisionDate } from '../Misc/precisionDate';\nimport { Bone } from '../Bones/bone';\n/**\r\n * Class used to store an actual running animation\r\n */\n\nvar Animatable =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Animatable\r\n   * @param scene defines the hosting scene\r\n   * @param target defines the target object\r\n   * @param fromFrame defines the starting frame number (default is 0)\r\n   * @param toFrame defines the ending frame number (default is 100)\r\n   * @param loopAnimation defines if the animation must loop (default is false)\r\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n   * @param animations defines a group of animation to add to the new Animatable\r\n   * @param onAnimationLoop defines a callback to call when animation loops\r\n   * @param isAdditive defines whether the animation should be evaluated additively\r\n   */\n  function Animatable(scene,\n  /** defines the target object */\n  target,\n  /** defines the starting frame number (default is 0) */\n  fromFrame,\n  /** defines the ending frame number (default is 100) */\n  toFrame,\n  /** defines if the animation must loop (default is false)  */\n  loopAnimation, speedRatio,\n  /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations,\n  /** defines a callback to call when animation loops */\n  onAnimationLoop,\n  /** defines whether the animation should be evaluated additively */\n  isAdditive) {\n    if (fromFrame === void 0) {\n      fromFrame = 0;\n    }\n\n    if (toFrame === void 0) {\n      toFrame = 100;\n    }\n\n    if (loopAnimation === void 0) {\n      loopAnimation = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1.0;\n    }\n\n    if (isAdditive === void 0) {\n      isAdditive = false;\n    }\n\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\n\n    this.disposeOnEnd = true;\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\n\n    this.animationStarted = false;\n    /**\r\n     * Observer raised when the animation ends\r\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\r\n     * Observer raised when the animation loops\r\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n\n    this._speedRatio = speedRatio;\n\n    scene._activeAnimatables.push(this);\n  }\n\n  Object.defineProperty(Animatable.prototype, \"syncRoot\", {\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\n    get: function () {\n      return this._syncRoot;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"masterFrame\", {\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\n    get: function () {\n      if (this._runtimeAnimations.length === 0) {\n        return 0;\n      }\n\n      return this._runtimeAnimations[0].currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"weight\", {\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\n    get: function () {\n      return this._weight;\n    },\n    set: function (value) {\n      if (value === -1) {\n        // -1 is ok and means no weight\n        this._weight = -1;\n        return;\n      } // Else weight must be in [0, 1] range\n\n\n      this._weight = Math.min(Math.max(value, 0), 1.0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animatable.prototype, \"speedRatio\", {\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\n    get: function () {\n      return this._speedRatio;\n    },\n    set: function (value) {\n      for (var index = 0; index < this._runtimeAnimations.length; index++) {\n        var animation = this._runtimeAnimations[index];\n\n        animation._prepareForSpeedRatioChange(value);\n      }\n\n      this._speedRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Synchronize and normalize current Animatable with a source Animatable\r\n   * This is useful when using animation weights and when animations are not of the same length\r\n   * @param root defines the root Animatable to synchronize with\r\n   * @returns the current Animatable\r\n   */\n\n  Animatable.prototype.syncWith = function (root) {\n    this._syncRoot = root;\n\n    if (root) {\n      // Make sure this animatable will animate after the root\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Gets the list of runtime animations\r\n   * @returns an array of RuntimeAnimation\r\n   */\n\n\n  Animatable.prototype.getAnimations = function () {\n    return this._runtimeAnimations;\n  };\n  /**\r\n   * Adds more animations to the current animatable\r\n   * @param target defines the target of the animations\r\n   * @param animations defines the new animations to add\r\n   */\n\n\n  Animatable.prototype.appendAnimations = function (target, animations) {\n    var _this = this;\n\n    for (var index = 0; index < animations.length; index++) {\n      var animation = animations[index];\n      var newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n\n      newRuntimeAnimation._onLoop = function () {\n        _this.onAnimationLoopObservable.notifyObservers(_this);\n\n        if (_this.onAnimationLoop) {\n          _this.onAnimationLoop();\n        }\n      };\n\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  };\n  /**\r\n   * Gets the source animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the source animation for the given property\r\n   */\n\n\n  Animatable.prototype.getAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the runtime animation for a specific property\r\n   * @param property defines the propertyu to look for\r\n   * @returns null or the runtime animation for the given property\r\n   */\n\n\n  Animatable.prototype.getRuntimeAnimationByTargetProperty = function (property) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Resets the animatable to its original state\r\n   */\n\n\n  Animatable.prototype.reset = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  };\n  /**\r\n   * Allows the animatable to blend with current running animations\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   * @param blendingSpeed defines the blending speed to use\r\n   */\n\n\n  Animatable.prototype.enableBlending = function (blendingSpeed) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  };\n  /**\r\n   * Disable animation blending\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   */\n\n\n  Animatable.prototype.disableBlending = function () {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  };\n  /**\r\n   * Jump directly to a given frame\r\n   * @param frame defines the frame to jump to\r\n   */\n\n\n  Animatable.prototype.goToFrame = function (frame) {\n    var runtimeAnimations = this._runtimeAnimations;\n\n    if (runtimeAnimations[0]) {\n      var fps = runtimeAnimations[0].animation.framePerSecond;\n      var currentFrame = runtimeAnimations[0].currentFrame;\n      var delay = this.speedRatio === 0 ? 0 : (frame - currentFrame) / fps * 1000 / this.speedRatio;\n\n      if (this._localDelayOffset === null) {\n        this._localDelayOffset = 0;\n      }\n\n      this._localDelayOffset -= delay;\n    }\n\n    for (var index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n  };\n  /**\r\n   * Pause the animation\r\n   */\n\n\n  Animatable.prototype.pause = function () {\n    if (this._paused) {\n      return;\n    }\n\n    this._paused = true;\n  };\n  /**\r\n   * Restart the animation\r\n   */\n\n\n  Animatable.prototype.restart = function () {\n    this._paused = false;\n  };\n\n  Animatable.prototype._raiseOnAnimationEnd = function () {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n\n    this.onAnimationEndObservable.notifyObservers(this);\n  };\n  /**\r\n   * Stop and delete the current animation\r\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n   */\n\n\n  Animatable.prototype.stop = function (animationName, targetMask) {\n    if (animationName || targetMask) {\n      var idx = this._scene._activeAnimatables.indexOf(this);\n\n      if (idx > -1) {\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\n          var runtimeAnimation = runtimeAnimations[index];\n\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n\n        if (runtimeAnimations.length == 0) {\n          this._scene._activeAnimatables.splice(idx, 1);\n\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      var index = this._scene._activeAnimatables.indexOf(this);\n\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n\n        var runtimeAnimations = this._runtimeAnimations;\n\n        for (var index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n\n        this._raiseOnAnimationEnd();\n      }\n    }\n  };\n  /**\r\n   * Wait asynchronously for the animation to end\r\n   * @returns a promise which will be fullfilled when the animation ends\r\n   */\n\n\n  Animatable.prototype.waitAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.onAnimationEndObservable.add(function () {\n        resolve(_this);\n      }, undefined, undefined, _this, true);\n    });\n  };\n  /** @hidden */\n\n\n  Animatable.prototype._animate = function (delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n\n      return true;\n    }\n\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n\n    if (this._weight === 0) {\n      // We consider that an animation with a weight === 0 is \"actively\" paused\n      return true;\n    } // Animating\n\n\n    var running = false;\n    var runtimeAnimations = this._runtimeAnimations;\n    var index;\n\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      var animation = runtimeAnimations[index];\n      var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n\n    this.animationStarted = running;\n\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n\n        this._scene._activeAnimatables.splice(index, 1); // Dispose all runtime animations\n\n\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n\n      this._raiseOnAnimationEnd();\n\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n\n    return running;\n  };\n\n  return Animatable;\n}();\n\nexport { Animatable };\n\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  } // Getting time\n\n\n  var now = PrecisionDate.Now;\n\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n\n    this._animationTimeLast = now;\n  }\n\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  var animatables = this._activeAnimatables;\n\n  if (animatables.length === 0) {\n    return;\n  }\n\n  this._animationTime += this.deltaTime;\n  var animationTime = this._animationTime;\n\n  for (var index = 0; index < animatables.length; index++) {\n    var animatable = animatables[index];\n\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  } // Late animation bindings\n\n\n  this._processLateAnimationBindings();\n};\n\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight, loop, speedRatio, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive) {\n  if (weight === void 0) {\n    weight = 1.0;\n  }\n\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\n\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n\n  var shouldRunTargetAnimations = targetMask ? targetMask(target) : true; // Local animations\n\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  } // Children animations\n\n\n  if (target.getAnimatables) {\n    var animatables = target.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n\n  animatable.reset();\n  return animatable;\n};\n\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop, isAdditive) {\n  if (speedRatio === void 0) {\n    speedRatio = 1.0;\n  }\n\n  if (stopCurrent === void 0) {\n    stopCurrent = true;\n  }\n\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n\n  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n    var child = children_1[_i];\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n\n  var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\n\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive) {\n  if (isAdditive === void 0) {\n    isAdditive = false;\n  }\n\n  var children = target.getDescendants(directDescendantsOnly);\n  var result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n\n  for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\n    var child = children_2[_i];\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n\n  return result;\n};\n\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n\n  return null;\n};\n\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  var result = [];\n\n  for (var index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n\n  return result;\n};\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\n\n\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  var animatables = this.getAllAnimatablesByTarget(target);\n\n  for (var _i = 0, animatables_1 = animatables; _i < animatables_1.length; _i++) {\n    var animatable = animatables_1[_i];\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\n\n\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (var i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop();\n    }\n\n    this._activeAnimatables = [];\n  }\n\n  for (var _i = 0, _a = this.animationGroups; _i < _a.length; _i++) {\n    var group = _a[_i];\n    group.stop();\n  }\n};\n\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  var target = runtimeAnimation.target;\n\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\n\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n\n  var normalizer = 1.0;\n  var finalPosition = TmpVectors.Vector3[0];\n  var finalScaling = TmpVectors.Vector3[1];\n  var finalQuaternion = TmpVectors.Quaternion[0];\n  var startIndex = 0;\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var scale = 1;\n  var skipOverride = false;\n\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1; // We need to normalize the weights\n\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } // Add up the override animations\n\n\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n\n    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n\n      var scale = runtimeAnimation.weight / normalizer;\n      var currentPosition = TmpVectors.Vector3[2];\n      var currentScaling = TmpVectors.Vector3[3];\n      var currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_1 = 0; animIndex_1 < holder.additiveAnimations.length; animIndex_1++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_1];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    var currentPosition = TmpVectors.Vector3[2];\n    var currentScaling = TmpVectors.Vector3[3];\n    var currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n\n  var workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\n\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n\n  var originalAnimation = holder.animations[0];\n  var originalValue = holder.originalValue;\n  var cumulativeQuaternion = refQuaternion;\n\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    var normalizer = 1.0;\n    var quaternions = void 0;\n    var weights = void 0;\n\n    if (holder.totalWeight < 1.0) {\n      var scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n\n    for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      var runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    } // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n\n\n    var cumulativeAmount = 0;\n\n    for (var index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  } // Add up the additive animations\n\n\n  for (var animIndex_2 = 0; animIndex_2 < holder.additiveAnimations.length; animIndex_2++) {\n    var runtimeAnimation = holder.additiveAnimations[animIndex_2];\n\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n\n  return cumulativeQuaternion;\n};\n\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n\n  for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    var target = this._registeredForLateAnimationBindings.data[index];\n\n    for (var path in target._lateAnimationHolders) {\n      var holder = target._lateAnimationHolders[path];\n      var originalAnimation = holder.animations[0];\n      var originalValue = holder.originalValue;\n      var matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n\n      var finalValue = target[path];\n\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        var quaternionMode = originalValue.w !== undefined;\n\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          var startIndex = 0;\n          var normalizer = 1.0;\n\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            var scale_1 = originalAnimation.weight / normalizer;\n\n            if (scale_1 !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale_1);\n              } else {\n                finalValue = originalAnimation.currentValue * scale_1;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n\n            startIndex = 1;\n          } // Add up the override animations\n\n\n          for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            var runtimeAnimation = holder.animations[animIndex];\n            var scale = runtimeAnimation.weight / normalizer;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          } // Add up the additive animations\n\n\n          for (var animIndex_3 = 0; animIndex_3 < holder.additiveAnimations.length; animIndex_3++) {\n            var runtimeAnimation = holder.additiveAnimations[animIndex_3];\n            var scale = runtimeAnimation.weight;\n\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n\n      target[path] = finalValue;\n    }\n\n    target._lateAnimationHolders = {};\n  }\n\n  this._registeredForLateAnimationBindings.reset();\n};\n\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\n  if (rescaleAsRequired === void 0) {\n    rescaleAsRequired = false;\n  }\n\n  if (skelDimensionsRatio === void 0) {\n    skelDimensionsRatio = null;\n  } // all animation may be coming from a library skeleton, so may need to create animation\n\n\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  } // get animation info / verify there is such a range from the source bone\n\n\n  var sourceRange = source.animations[0].getRange(rangeName);\n\n  if (!sourceRange) {\n    return false;\n  }\n\n  var from = sourceRange.from;\n  var to = sourceRange.to;\n  var sourceKeys = source.animations[0].getKeys(); // rescaling prep\n\n  var sourceBoneLength = source.length;\n  var sourceParent = source.getParent();\n  var parent = this.getParent();\n  var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  var destKeys = this.animations[0].getKeys(); // loop vars declaration\n\n  var orig;\n  var origTranslation;\n  var mat;\n\n  for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone(); // scale based on parent ratio, when bone has parent\n\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio)); // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio)); // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":{"version":3,"sources":["../../../sourceES6/core/Animations/animatable.ts"],"names":[],"mappings":"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","sourcesContent":["import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\nimport { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from '../Maths/math.vector';\r\nimport { PrecisionDate } from '../Misc/precisionDate';\r\nimport { Bone } from '../Bones/bone';\r\nimport { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) { // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (var index = 0; index < this._runtimeAnimations.length; index++) {\r\n            var animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    constructor(scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Animatable): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            let index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (var index = 0; index < animations.length; index++) {\r\n            var animation = animations[index];\r\n\r\n            let newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the propertyu to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            var fps = runtimeAnimations[0].animation.framePerSecond;\r\n            var currentFrame = runtimeAnimations[0].currentFrame;\r\n            var delay = this.speedRatio === 0 ? 0 : ((frame - currentFrame) / fps * 1000) / this.speedRatio;\r\n            if (this._localDelayOffset === null) {\r\n                this._localDelayOffset = 0;\r\n            }\r\n            this._localDelayOffset -= delay;\r\n        }\r\n\r\n        for (var index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        if (animationName || targetMask) {\r\n            var idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (var index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n\r\n        } else {\r\n\r\n            var index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                var runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (var index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fullfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onAnimationEndObservable.add(() => {\r\n                resolve(this);\r\n            }, undefined, undefined, this, true);\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._weight === 0) { // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        // Animating\r\n        var running = false;\r\n        var runtimeAnimations = this._runtimeAnimations;\r\n        var index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            var animation = runtimeAnimations[index];\r\n            var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame,\r\n                this.toFrame, this.loopAnimation, this._speedRatio, this._weight\r\n            );\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindingsForMatrices(holder: {\r\n            totalWeight: number,\r\n            totalAdditiveWeight: number,\r\n            animations: RuntimeAnimation[],\r\n            additiveAnimations: RuntimeAnimation[],\r\n            originalValue: Matrix\r\n        }): any;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindingsForQuaternions(holder: {\r\n            totalWeight: number,\r\n            totalAdditiveWeight: number,\r\n            animations: RuntimeAnimation[],\r\n            additiveAnimations: RuntimeAnimation[],\r\n            originalValue: Quaternion\r\n        }, refQuaternion: Quaternion): Quaternion;\r\n\r\n        /** @hidden */\r\n        _processLateAnimationBindings(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(target: any, from: number, to: number, weight: number, loop?: boolean, speedRatio?: number,\r\n            onAnimationEnd?: () => void, animatable?: Animatable, targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(target: any, from: number, to: number, loop?: boolean, speedRatio?: number,\r\n            onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(target: any, directDescendantsOnly: boolean, from: number, to: number, loop?: boolean, speedRatio?: number,\r\n            onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(target: any, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(target: Node, directDescendantsOnly: boolean, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive?: boolean): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n        * Stops and removes all animations that have been applied to the scene\r\n        */\r\n        stopAllAnimations(): void;\r\n\r\n        /**\r\n         * Gets the current delta time used by animation engine\r\n         */\r\n        deltaTime: number;\r\n    }\r\n}\r\n\r\nScene.prototype._animate = function(): void {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n\r\n    // Getting time\r\n    var now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n\r\n    const animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n\r\n    this._animationTime += this.deltaTime;\r\n    const animationTime = this._animationTime;\r\n\r\n    for (let index = 0; index < animatables.length; index++) {\r\n        let animatable = animatables[index];\r\n\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\n\r\nScene.prototype.beginWeightedAnimation = function(target: any, from: number, to: number, weight = 1.0, loop?: boolean, speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void, animatable?: Animatable, targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive = false): Animatable {\r\n\r\n    let returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n\r\n    return returnedAnimatable;\r\n};\r\n\r\nScene.prototype.beginAnimation = function(target: any, from: number, to: number, loop?: boolean, speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent = true,\r\n    targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive = false): Animatable {\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n\r\n    const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        var animatables = target.getAnimatables();\r\n        for (var index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n\r\n    animatable.reset();\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginHierarchyAnimation = function(target: any, directDescendantsOnly: boolean, from: number, to: number, loop?: boolean, speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void, animatable?: Animatable, stopCurrent = true,\r\n    targetMask?: (target: any) => boolean, onAnimationLoop?: () => void, isAdditive = false): Animatable[] {\r\n\r\n    let children = target.getDescendants(directDescendantsOnly);\r\n\r\n    let result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (var child of children) {\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.beginDirectAnimation = function(target: any, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive = false): Animatable {\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    var animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginDirectHierarchyAnimation = function(target: Node, directDescendantsOnly: boolean, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void, onAnimationLoop?: () => void, isAdditive = false): Animatable[] {\r\n    let children = target.getDescendants(directDescendantsOnly);\r\n\r\n    let result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (var child of children) {\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.getAnimatableByTarget = function(target: any): Nullable<Animatable> {\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.getAllAnimatablesByTarget = function(target: any): Array<Animatable> {\r\n    let result = [];\r\n    for (var index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function(target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n    var animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n    for (var animatable of animatables) {\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function(): void {\r\n    if (this._activeAnimatables) {\r\n        for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables = [];\r\n    }\r\n\r\n    for (var group of this.animationGroups) {\r\n        group.stop();\r\n    }\r\n};\r\n\r\nScene.prototype._registerTargetForLateAnimationBinding = function(runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    let target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForMatrices = function(holder: {\r\n    totalWeight: number,\r\n    totalAdditiveWeight: number,\r\n    animations: RuntimeAnimation[],\r\n    additiveAnimations: RuntimeAnimation[],\r\n    originalValue: Matrix\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    let finalPosition = TmpVectors.Vector3[0];\r\n    let finalScaling = TmpVectors.Vector3[1];\r\n    let finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    let originalAnimation = holder.animations[0];\r\n    let originalValue = holder.originalValue;\r\n\r\n    var scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            var runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            var scale = runtimeAnimation.weight / normalizer;\r\n            let currentPosition = TmpVectors.Vector3[2];\r\n            let currentScaling = TmpVectors.Vector3[3];\r\n            let currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        var runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        let currentPosition = TmpVectors.Vector3[2];\r\n        let currentScaling = TmpVectors.Vector3[3];\r\n        let currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n\r\n    }\r\n\r\n    let workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function(holder: {\r\n    totalWeight: number,\r\n    totalAdditiveWeight: number,\r\n    animations: RuntimeAnimation[],\r\n    additiveAnimations: RuntimeAnimation[],\r\n    originalValue: Quaternion\r\n}, refQuaternion: Quaternion): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    let originalAnimation = holder.animations[0];\r\n    let originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            let scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) { // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (var animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            let runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (var index = 0; index < quaternions.length;) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        let runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindings = function(): void {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (var index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        var target = this._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (var path in target._lateAnimationHolders) {\r\n            var holder = target._lateAnimationHolders[path];\r\n            let originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            let originalValue = holder.originalValue;\r\n\r\n            let matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                let quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        let scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (var animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        var runtimeAnimation = holder.animations[animIndex];\r\n                        var scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        var runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        var scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\nBone.prototype.copyAnimationRange = function(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired = false, skelDimensionsRatio: Nullable<Vector3> = null): boolean {\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n\r\n    // get animation info / verify there is such a range from the source bone\r\n    var sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    var from = sourceRange.from;\r\n    var to = sourceRange.to;\r\n    var sourceKeys = source.animations[0].getKeys();\r\n\r\n    // rescaling prep\r\n    var sourceBoneLength = source.length;\r\n    var sourceParent = source.getParent();\r\n    var parent = this.getParent();\r\n    var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    var parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n    var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n    var destKeys = this.animations[0].getKeys();\r\n\r\n    // loop vars declaration\r\n    var orig: { frame: number, value: Matrix };\r\n    var origTranslation: Vector3;\r\n    var mat: Matrix;\r\n\r\n    for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                } else {\r\n                    mat = orig.value;\r\n                }\r\n            } else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}