{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { BoundingBox } from \"./boundingBox\";\nimport { BoundingSphere } from \"./boundingSphere\";\nvar _result0 = {\n  min: 0,\n  max: 0\n};\nvar _result1 = {\n  min: 0,\n  max: 0\n};\n\nvar computeBoxExtents = function (axis, box, result) {\n  var p = Vector3.Dot(box.centerWorld, axis);\n  var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n  var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n  var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n  var r = r0 + r1 + r2;\n  result.min = p - r;\n  result.max = p + r;\n};\n\nvar axisOverlap = function (axis, box0, box1) {\n  computeBoxExtents(axis, box0, _result0);\n  computeBoxExtents(axis, box1, _result1);\n  return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\r\n * Info for a bounding data of a mesh\r\n */\n\n\nvar BoundingInfo =\n/** @class */\nfunction () {\n  /**\r\n   * Constructs bounding info\r\n   * @param minimum min vector of the bounding box/sphere\r\n   * @param maximum max vector of the bounding box/sphere\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n  function BoundingInfo(minimum, maximum, worldMatrix) {\n    this._isLocked = false;\n    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\n    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\n  }\n  /**\r\n   * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n   * @param min defines the new minimum vector (in local space)\r\n   * @param max defines the new maximum vector (in local space)\r\n   * @param worldMatrix defines the new world matrix\r\n   */\n\n\n  BoundingInfo.prototype.reConstruct = function (min, max, worldMatrix) {\n    this.boundingBox.reConstruct(min, max, worldMatrix);\n    this.boundingSphere.reConstruct(min, max, worldMatrix);\n  };\n\n  Object.defineProperty(BoundingInfo.prototype, \"minimum\", {\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\n    get: function () {\n      return this.boundingBox.minimum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoundingInfo.prototype, \"maximum\", {\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\n    get: function () {\n      return this.boundingBox.maximum;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BoundingInfo.prototype, \"isLocked\", {\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\n    get: function () {\n      return this._isLocked;\n    },\n    set: function (value) {\n      this._isLocked = value;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Updates the bounding sphere and box\r\n   * @param world world matrix to be used to update\r\n   */\n\n  BoundingInfo.prototype.update = function (world) {\n    if (this._isLocked) {\n      return;\n    }\n\n    this.boundingBox._update(world);\n\n    this.boundingSphere._update(world);\n  };\n  /**\r\n   * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n   * @param center New center of the bounding info\r\n   * @param extend New extend of the bounding info\r\n   * @returns the current bounding info\r\n   */\n\n\n  BoundingInfo.prototype.centerOn = function (center, extend) {\n    var minimum = BoundingInfo.TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n    var maximum = BoundingInfo.TmpVector3[1].copyFrom(center).addInPlace(extend);\n    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  };\n  /**\r\n   * Scale the current bounding info by applying a scale factor\r\n   * @param factor defines the scale factor to apply\r\n   * @returns the current bounding info\r\n   */\n\n\n  BoundingInfo.prototype.scale = function (factor) {\n    this.boundingBox.scale(factor);\n    this.boundingSphere.scale(factor);\n    return this;\n  };\n  /**\r\n   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n   * @returns true if the bounding info is in the frustum planes\r\n   */\n\n\n  BoundingInfo.prototype.isInFrustum = function (frustumPlanes, strategy) {\n    if (strategy === void 0) {\n      strategy = 0;\n    }\n\n    var inclusionTest = strategy === 2 || strategy === 3;\n\n    if (inclusionTest) {\n      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n        return true;\n      }\n    }\n\n    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n\n    var bSphereOnlyTest = strategy === 1 || strategy === 3;\n\n    if (bSphereOnlyTest) {\n      return true;\n    }\n\n    return this.boundingBox.isInFrustum(frustumPlanes);\n  };\n\n  Object.defineProperty(BoundingInfo.prototype, \"diagonalLength\", {\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\n    get: function () {\n      var boundingBox = this.boundingBox;\n      var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo.TmpVector3[0]);\n      return diag.length();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Checks if a cullable object (mesh...) is in the camera frustum\r\n   * Unlike isInFrustum this cheks the full bounding box\r\n   * @param frustumPlanes Camera near/planes\r\n   * @returns true if the object is in frustum otherwise false\r\n   */\n\n  BoundingInfo.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n  };\n  /** @hidden */\n\n\n  BoundingInfo.prototype._checkCollision = function (collider) {\n    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n  };\n  /**\r\n   * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n   * @param point the point to check intersection with\r\n   * @returns if the point intersects\r\n   */\n\n\n  BoundingInfo.prototype.intersectsPoint = function (point) {\n    if (!this.boundingSphere.centerWorld) {\n      return false;\n    }\n\n    if (!this.boundingSphere.intersectsPoint(point)) {\n      return false;\n    }\n\n    if (!this.boundingBox.intersectsPoint(point)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n   * @param boundingInfo the bounding info to check intersection with\r\n   * @param precise if the intersection should be done using OBB\r\n   * @returns if the bounding info intersects\r\n   */\n\n\n  BoundingInfo.prototype.intersects = function (boundingInfo, precise) {\n    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n      return false;\n    }\n\n    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n      return false;\n    }\n\n    if (!precise) {\n      return true;\n    }\n\n    var box0 = this.boundingBox;\n    var box1 = boundingInfo.boundingBox;\n\n    if (!axisOverlap(box0.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  BoundingInfo.TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\n  return BoundingInfo;\n}();\n\nexport { BoundingInfo };","map":{"version":3,"sources":["../../../sourceES6/core/Culling/boundingInfo.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\n\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport { Plane } from '../Maths/math.plane';\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number, max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/babylon101/materials#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this cheks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n\r\n        const minimum = BoundingInfo.TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo.TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = 0): boolean {\r\n        let inclusionTest = (strategy === 2 || strategy === 3);\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        let bSphereOnlyTest = (strategy === 1 || strategy === 3);\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo.TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this cheks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /** @hidden */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        var box0 = this.boundingBox;\r\n        var box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) { return false; }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) { return false; }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) { return false; }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) { return false; }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) { return false; }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) { return false; }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) { return false; }\r\n\r\n        return true;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}