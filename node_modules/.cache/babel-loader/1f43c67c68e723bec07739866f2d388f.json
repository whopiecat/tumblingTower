{"ast":null,"code":"import { SceneSerializer } from './sceneSerializer';\nimport { Mesh } from '../Meshes/mesh';\nimport { Light } from '../Lights/light';\nimport { Camera } from '../Cameras/camera';\nimport { Skeleton } from '../Bones/skeleton';\nimport { Material } from '../Materials/material';\nimport { MultiMaterial } from '../Materials/multiMaterial';\nimport { TransformNode } from '../Meshes/transformNode';\nimport { ParticleSystem } from '../Particles/particleSystem';\nimport { MorphTargetManager } from '../Morph/morphTargetManager';\nimport { ShadowGenerator } from '../Lights/Shadows/shadowGenerator';\nimport { PostProcess } from '../PostProcesses/postProcess';\n/**\r\n * Class used to record delta files between 2 scene states\r\n */\n\nvar SceneRecorder =\n/** @class */\nfunction () {\n  function SceneRecorder() {\n    this._trackedScene = null;\n  }\n  /**\r\n   * Track a given scene. This means the current scene state will be considered the original state\r\n   * @param scene defines the scene to track\r\n   */\n\n\n  SceneRecorder.prototype.track = function (scene) {\n    this._trackedScene = scene;\n    this._savedJSON = SceneSerializer.Serialize(scene);\n  };\n  /**\r\n   * Get the delta between current state and original state\r\n   * @returns a string containing the delta\r\n   */\n\n\n  SceneRecorder.prototype.getDelta = function () {\n    if (!this._trackedScene) {\n      return null;\n    }\n\n    var newJSON = SceneSerializer.Serialize(this._trackedScene);\n    var deltaJSON = {};\n\n    for (var node in newJSON) {\n      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n    }\n\n    return deltaJSON;\n  };\n\n  SceneRecorder.prototype._compareArray = function (key, original, current, deltaJSON) {\n    if (original.length === 0 && current.length === 0) {\n      return true;\n    } // Numbers?\n\n\n    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\n      if (original.length !== current.length) {\n        return false;\n      }\n\n      if (original.length === 0) {\n        return true;\n      }\n\n      for (var index = 0; index < original.length; index++) {\n        if (original[index] !== current[index]) {\n          deltaJSON[key] = current;\n          return false;\n        }\n      }\n\n      return true;\n    } // let's use uniqueId to find similar objects\n\n\n    var originalUniqueIds = [];\n\n    var _loop_1 = function () {\n      var originalObject = original[index];\n      var originalUniqueId = originalObject.uniqueId;\n      originalUniqueIds.push(originalUniqueId); // Look for that object in current state\n\n      var currentObjects = current.filter(function (c) {\n        return c.uniqueId === originalUniqueId;\n      });\n\n      if (currentObjects.length) {\n        // We have a candidate\n        var currentObject = currentObjects[0];\n        var newObject = {};\n\n        if (!this_1._compareObjects(originalObject, currentObject, newObject)) {\n          if (!deltaJSON[key]) {\n            deltaJSON[key] = [];\n          }\n\n          newObject.__state = {\n            id: currentObject.id || currentObject.name\n          };\n          deltaJSON[key].push(newObject);\n        }\n      } else {\n        // We need to delete\n        var newObject = {\n          __state: {\n            deleteId: originalObject.id || originalObject.name\n          }\n        };\n        deltaJSON[key].push(newObject);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < original.length; index++) {\n      _loop_1();\n    } // Checking for new objects\n\n\n    for (var index = 0; index < current.length; index++) {\n      var currentObject = current[index];\n      var currentUniqueId = currentObject.uniqueId; // Object was added\n\n      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n\n        deltaJSON[key].push(currentObject);\n      }\n    }\n\n    return true;\n  };\n\n  SceneRecorder.prototype._compareObjects = function (originalObjet, currentObject, deltaJSON) {\n    var aDifferenceWasFound = false;\n\n    for (var prop in originalObjet) {\n      if (!originalObjet.hasOwnProperty(prop)) {\n        continue;\n      }\n\n      var originalValue = originalObjet[prop];\n      var currentValue = currentObject[prop];\n      var diffFound = false;\n\n      if (Array.isArray(originalValue)) {\n        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == '[object String]') {\n        diffFound = originalValue !== currentValue;\n      }\n\n      if (diffFound) {\n        aDifferenceWasFound = true;\n        deltaJSON[prop] = currentValue;\n      }\n    }\n\n    return !aDifferenceWasFound;\n  };\n\n  SceneRecorder.prototype._compareCollections = function (key, original, current, deltaJSON) {\n    // Same ?\n    if (original === current) {\n      return;\n    }\n\n    if (original && current) {\n      // Array?\n      if (Array.isArray(original) && Array.isArray(current)) {\n        if (this._compareArray(key, original, current, deltaJSON)) {\n          return;\n        }\n      } else if (typeof original === \"object\" && typeof current === \"object\") {\n        // Object\n        var newObject = {};\n\n        if (!this._compareObjects(original, current, newObject)) {\n          deltaJSON[key] = newObject;\n        }\n\n        return;\n      }\n    }\n  };\n\n  SceneRecorder.GetShadowGeneratorById = function (scene, id) {\n    var generators = scene.lights.map(function (l) {\n      return l.getShadowGenerator();\n    });\n\n    for (var _i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\n      var generator = generators_1[_i];\n\n      if (generator && generator.id === id) {\n        return generator;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Apply a given delta to a given scene\r\n   * @param deltaJSON defines the JSON containing the delta\r\n   * @param scene defines the scene to apply the delta to\r\n   */\n\n\n  SceneRecorder.ApplyDelta = function (deltaJSON, scene) {\n    var _this = this;\n\n    if (typeof deltaJSON === 'string') {\n      deltaJSON = JSON.parse(deltaJSON);\n    } // Scene\n\n\n    var anyScene = scene;\n\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = anyScene[prop];\n\n      if (Array.isArray(property) || prop === \"shadowGenerators\") {\n        // Restore array\n        switch (prop) {\n          case \"cameras\":\n            this._ApplyDeltaForEntity(source, scene, scene.getCameraByID.bind(scene), function (data) {\n              return Camera.Parse(data, scene);\n            });\n\n            break;\n\n          case \"lights\":\n            this._ApplyDeltaForEntity(source, scene, scene.getLightByID.bind(scene), function (data) {\n              return Light.Parse(data, scene);\n            });\n\n            break;\n\n          case \"shadowGenerators\":\n            this._ApplyDeltaForEntity(source, scene, function (id) {\n              return _this.GetShadowGeneratorById(scene, id);\n            }, function (data) {\n              return ShadowGenerator.Parse(data, scene);\n            });\n\n            break;\n\n          case \"meshes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMeshByID.bind(scene), function (data) {\n              return Mesh.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"skeletons\":\n            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), function (data) {\n              return Skeleton.Parse(data, scene);\n            });\n\n            break;\n\n          case \"materials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function (data) {\n              return Material.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"multiMaterials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), function (data) {\n              return MultiMaterial.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"transformNodes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeByID.bind(scene), function (data) {\n              return TransformNode.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"particleSystems\":\n            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemByID.bind(scene), function (data) {\n              return ParticleSystem.Parse(data, scene, \"\");\n            });\n\n            break;\n\n          case \"morphTargetManagers\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), function (data) {\n              return MorphTargetManager.Parse(data, scene);\n            });\n\n            break;\n\n          case \"postProcesses\":\n            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), function (data) {\n              return PostProcess.Parse(data, scene, \"\");\n            });\n\n            break;\n        }\n      } else if (!isNaN(property)) {\n        anyScene[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyPropertiesToEntity = function (deltaJSON, entity) {\n    for (var prop in deltaJSON) {\n      var source = deltaJSON[prop];\n      var property = entity[prop];\n\n      if (property === undefined) {\n        continue;\n      }\n\n      if (!isNaN(property) || Array.isArray(property)) {\n        entity[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  };\n\n  SceneRecorder._ApplyDeltaForEntity = function (sources, scene, finder, addNew) {\n    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n      var source = sources_1[_i]; // Update\n\n      if (source.__state && source.__state.id !== undefined) {\n        var targetEntity = finder(source.__state.id);\n\n        if (targetEntity) {\n          this._ApplyPropertiesToEntity(source, targetEntity);\n        }\n      } else if (source.__state && source.__state.deleteId !== undefined) {\n        var target = finder(source.__state.deleteId);\n        target === null || target === void 0 ? void 0 : target.dispose();\n      } else {\n        // New\n        addNew(source);\n      }\n    }\n  };\n\n  return SceneRecorder;\n}();\n\nexport { SceneRecorder };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/sceneRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from '../scene';\r\nimport { Nullable } from '../types';\r\nimport { SceneSerializer } from './sceneSerializer';\r\nimport { Mesh } from '../Meshes/mesh';\r\nimport { Light } from '../Lights/light';\r\nimport { Camera } from '../Cameras/camera';\r\nimport { Skeleton } from '../Bones/skeleton';\r\nimport { Material } from '../Materials/material';\r\nimport { MultiMaterial } from '../Materials/multiMaterial';\r\nimport { TransformNode } from '../Meshes/transformNode';\r\nimport { ParticleSystem } from '../Particles/particleSystem';\r\nimport { MorphTargetManager } from '../Morph/morphTargetManager';\r\nimport { ShadowGenerator } from '../Lights/Shadows/shadowGenerator';\r\nimport { PostProcess } from '../PostProcesses/postProcess';\r\n\r\n/**\r\n * Class used to record delta files between 2 scene states\r\n */\r\nexport class SceneRecorder {\r\n    private _trackedScene: Nullable<Scene> = null;\r\n    private _savedJSON: any;\r\n\r\n    /**\r\n     * Track a given scene. This means the current scene state will be considered the original state\r\n     * @param scene defines the scene to track\r\n     */\r\n    public track(scene: Scene) {\r\n        this._trackedScene = scene;\r\n\r\n        this._savedJSON = SceneSerializer.Serialize(scene);\r\n    }\r\n\r\n    /**\r\n     * Get the delta between current state and original state\r\n     * @returns a string containing the delta\r\n     */\r\n    public getDelta() {\r\n        if (!this._trackedScene) {\r\n            return null;\r\n        }\r\n\r\n        let newJSON = SceneSerializer.Serialize(this._trackedScene);\r\n        let deltaJSON: any = {};\r\n\r\n        for (var node in newJSON) {\r\n            this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\r\n        }\r\n\r\n        return deltaJSON;\r\n    }\r\n\r\n    private _compareArray(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        if (original.length === 0 && current.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        // Numbers?\r\n        if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\r\n            if (original.length !== current.length) {\r\n                return false;\r\n            }\r\n\r\n            if (original.length === 0) {\r\n                return true;\r\n            }\r\n            for (var index = 0; index < original.length; index++) {\r\n                if (original[index] !== current[index]) {\r\n                    deltaJSON[key] = current;\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        // let's use uniqueId to find similar objects\r\n        let originalUniqueIds: number[] = [];\r\n        for (var index = 0; index < original.length; index++) {\r\n            let originalObject = original[index];\r\n            let originalUniqueId = originalObject.uniqueId;\r\n\r\n            originalUniqueIds.push(originalUniqueId);\r\n            // Look for that object in current state\r\n            let currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);\r\n            if (currentObjects.length) { // We have a candidate\r\n                let currentObject = currentObjects[0];\r\n\r\n                let newObject: any = {};\r\n                if (!this._compareObjects(originalObject, currentObject, newObject)) {\r\n                    if (!deltaJSON[key]) {\r\n                        deltaJSON[key] = [];\r\n                    }\r\n                    newObject.__state = {\r\n                        id: currentObject.id || currentObject.name\r\n                    };\r\n                    deltaJSON[key].push(newObject);\r\n                }\r\n            } else {\r\n                // We need to delete\r\n                let newObject: any = {\r\n                    __state: {\r\n                        deleteId: originalObject.id || originalObject.name\r\n                    }\r\n                };\r\n                deltaJSON[key].push(newObject);\r\n            }\r\n        }\r\n\r\n        // Checking for new objects\r\n        for (var index = 0; index < current.length; index++) {\r\n            let currentObject = current[index];\r\n            let currentUniqueId = currentObject.uniqueId;\r\n\r\n            // Object was added\r\n            if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\r\n                if (!deltaJSON[key]) {\r\n                    deltaJSON[key] = [];\r\n                }\r\n\r\n                deltaJSON[key].push(currentObject);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _compareObjects(originalObjet: any, currentObject: any, deltaJSON: any) {\r\n        let aDifferenceWasFound = false;\r\n\r\n        for (var prop in originalObjet) {\r\n            if (!originalObjet.hasOwnProperty(prop)) {\r\n                continue;\r\n            }\r\n            var originalValue = originalObjet[prop];\r\n            var currentValue = currentObject[prop];\r\n            var diffFound = false;\r\n\r\n            if (Array.isArray(originalValue)) {\r\n                diffFound = (JSON.stringify(originalValue) !== JSON.stringify(currentValue));\r\n            } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == '[object String]') {\r\n                diffFound = (originalValue !== currentValue);\r\n            }\r\n\r\n            if (diffFound) {\r\n                aDifferenceWasFound = true;\r\n                deltaJSON[prop] = currentValue;\r\n            }\r\n        }\r\n\r\n        return !aDifferenceWasFound;\r\n    }\r\n\r\n    private _compareCollections(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        // Same ?\r\n        if (original === current) {\r\n            return;\r\n        }\r\n\r\n        if (original && current) {\r\n            // Array?\r\n            if (Array.isArray(original) && Array.isArray(current)) {\r\n                if (this._compareArray(key, original, current, deltaJSON)) {\r\n                    return;\r\n                }\r\n            } else if (typeof original === \"object\" && typeof current === \"object\") { // Object\r\n                let newObject = {};\r\n                if (!this._compareObjects(original, current, newObject)) {\r\n                    deltaJSON[key] = newObject;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static GetShadowGeneratorById(scene: Scene, id: string) {\r\n        var generators = scene.lights.map((l) => l.getShadowGenerator());\r\n\r\n        for (var generator of generators) {\r\n            if (generator && generator.id === id) {\r\n                return generator;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply a given delta to a given scene\r\n     * @param deltaJSON defines the JSON containing the delta\r\n     * @param scene defines the scene to apply the delta to\r\n     */\r\n    public static ApplyDelta(deltaJSON: any | string, scene: Scene) {\r\n\r\n        if (typeof deltaJSON === 'string') {\r\n            deltaJSON = JSON.parse(deltaJSON);\r\n        }\r\n\r\n        // Scene\r\n        let anyScene = scene as any;\r\n        for (var prop in deltaJSON) {\r\n            var source = deltaJSON[prop];\r\n            var property = anyScene[prop];\r\n\r\n            if (Array.isArray(property) || prop === \"shadowGenerators\") { // Restore array\r\n                switch (prop) {\r\n                    case \"cameras\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getCameraByID.bind(scene), (data) => Camera.Parse(data, scene));\r\n                        break;\r\n                    case \"lights\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getLightByID.bind(scene), (data) => Light.Parse(data, scene));\r\n                        break;\r\n                    case \"shadowGenerators\":\r\n                        this._ApplyDeltaForEntity(source, scene, (id) => this.GetShadowGeneratorById(scene, id), (data) => ShadowGenerator.Parse(data, scene));\r\n                        break;\r\n                    case \"meshes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMeshByID.bind(scene), (data) => Mesh.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"skeletons\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));\r\n                        break;\r\n                    case \"materials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), (data) => Material.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"multiMaterials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialByID.bind(scene), (data) => MultiMaterial.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"transformNodes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeByID.bind(scene), (data) => TransformNode.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"particleSystems\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemByID.bind(scene), (data) => ParticleSystem.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"morphTargetManagers\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));\r\n                        break;\r\n                    case \"postProcesses\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, \"\"));\r\n                        break;\r\n                }\r\n            } else if (!isNaN(property)) {\r\n                anyScene[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyPropertiesToEntity(deltaJSON: any, entity: any) {\r\n        for (var prop in deltaJSON) {\r\n            var source = deltaJSON[prop];\r\n            var property = entity[prop];\r\n\r\n            if (property === undefined) {\r\n                continue;\r\n            }\r\n\r\n            if (!isNaN(property) || Array.isArray(property)) {\r\n                entity[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyDeltaForEntity(sources: any[], scene: Scene, finder: (id: string) => any, addNew: (data: any) => void) {\r\n        for (var source of sources) {\r\n\r\n            // Update\r\n            if (source.__state && source.__state.id !== undefined) {\r\n                let targetEntity = finder(source.__state.id);\r\n\r\n                if (targetEntity) {\r\n                    this._ApplyPropertiesToEntity(source, targetEntity);\r\n                }\r\n            } else if (source.__state && source.__state.deleteId !== undefined) {\r\n                let target = finder(source.__state.deleteId);\r\n                target?.dispose();\r\n            } else {\r\n                // New\r\n                addNew(source);\r\n            }\r\n\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}