{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { EngineStore } from \"../../../Engines/engineStore\";\nimport { ProceduralTexture } from \"./proceduralTexture\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport \"../../../Shaders/noise.fragment\";\n/**\r\n * Class used to generate noise procedural textures\r\n */\n\nvar NoiseProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(NoiseProceduralTexture, _super);\n  /**\r\n   * Creates a new NoiseProceduralTexture\r\n   * @param name defines the name fo the texture\r\n   * @param size defines the size of the texture (default is 256)\r\n   * @param scene defines the hosting scene\r\n   * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\r\n   * @param generateMipMaps defines if mipmaps must be generated (true by default)\r\n   */\n\n\n  function NoiseProceduralTexture(name, size, scene, fallbackTexture, generateMipMaps) {\n    if (size === void 0) {\n      size = 256;\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    var _this = _super.call(this, name, size, \"noise\", scene, fallbackTexture, generateMipMaps) || this;\n    /** Gets or sets the start time (default is 0) */\n\n\n    _this.time = 0.0;\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n\n    _this.brightness = 0.2;\n    /** Defines the number of octaves to process */\n\n    _this.octaves = 3;\n    /** Defines the level of persistence (0.8 by default) */\n\n    _this.persistence = 0.8;\n    /** Gets or sets animation speed factor (default is 1) */\n\n    _this.animationSpeedFactor = 1;\n    _this.autoClear = false;\n\n    _this._updateShaderUniforms();\n\n    return _this;\n  }\n\n  NoiseProceduralTexture.prototype._updateShaderUniforms = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n    this.setFloat(\"brightness\", this.brightness);\n    this.setFloat(\"persistence\", this.persistence);\n    this.setFloat(\"timeScale\", this.time);\n  };\n\n  NoiseProceduralTexture.prototype._getDefines = function () {\n    return \"#define OCTAVES \" + (this.octaves | 0);\n  };\n  /** Generate the current state of the procedural texture */\n\n\n  NoiseProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    this._updateShaderUniforms();\n\n    _super.prototype.render.call(this, useCameraPostProcess);\n  };\n  /**\r\n   * Serializes this noise procedural texture\r\n   * @returns a serialized noise procedural texture object\r\n   */\n\n\n  NoiseProceduralTexture.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n    serializationObject.brightness = this.brightness;\n    serializationObject.octaves = this.octaves;\n    serializationObject.persistence = this.persistence;\n    serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n    serializationObject.size = this.getSize().width;\n    serializationObject.generateMipMaps = this._generateMipMaps;\n    serializationObject.time = this.time;\n    return serializationObject;\n  };\n  /**\r\n   * Clone the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  NoiseProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode; // Noise Specifics\n\n    newTexture.brightness = this.brightness;\n    newTexture.octaves = this.octaves;\n    newTexture.persistence = this.persistence;\n    newTexture.animationSpeedFactor = this.animationSpeedFactor;\n    newTexture.time = this.time;\n    return newTexture;\n  };\n  /**\r\n   * Creates a NoiseProceduralTexture from parsed noise procedural texture data\r\n   * @param parsedTexture defines parsed texture data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing noise procedural texture information\r\n   * @returns a parsed NoiseProceduralTexture\r\n   */\n\n\n  NoiseProceduralTexture.Parse = function (parsedTexture, scene) {\n    var _a;\n\n    var texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n    texture.brightness = parsedTexture.brightness;\n    texture.octaves = parsedTexture.octaves;\n    texture.persistence = parsedTexture.persistence;\n    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;\n    return texture;\n  };\n\n  return NoiseProceduralTexture;\n}(ProceduralTexture);\n\nexport { NoiseProceduralTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.NoiseProceduralTexture\"] = NoiseProceduralTexture;","map":{"version":3,"sources":["../../../../../sourceES6/core/Materials/Textures/Procedurals/noiseProceduralTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../../types\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\nimport { _TypeStore } from '../../../Misc/typeStore';\r\n\r\nimport \"../../../Shaders/noise.fragment\";\r\n\r\n/**\r\n * Class used to generate noise procedural textures\r\n */\r\nexport class NoiseProceduralTexture extends ProceduralTexture {\r\n\r\n    /** Gets or sets the start time (default is 0) */\r\n    public time: number = 0.0;\r\n\r\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\r\n    public brightness = 0.2;\r\n\r\n    /** Defines the number of octaves to process */\r\n    public octaves = 3;\r\n\r\n    /** Defines the level of persistence (0.8 by default) */\r\n    public persistence = 0.8;\r\n\r\n    /** Gets or sets animation speed factor (default is 1) */\r\n    public animationSpeedFactor = 1;\r\n\r\n    /**\r\n     * Creates a new NoiseProceduralTexture\r\n     * @param name defines the name fo the texture\r\n     * @param size defines the size of the texture (default is 256)\r\n     * @param scene defines the hosting scene\r\n     * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\r\n     * @param generateMipMaps defines if mipmaps must be generated (true by default)\r\n     */\r\n    constructor(name: string, size: number = 256, scene: Nullable<Scene> = EngineStore.LastCreatedScene, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\r\n        this.autoClear = false;\r\n        this._updateShaderUniforms();\r\n    }\r\n\r\n    private _updateShaderUniforms() {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\r\n\r\n        this.setFloat(\"brightness\", this.brightness);\r\n        this.setFloat(\"persistence\", this.persistence);\r\n        this.setFloat(\"timeScale\", this.time);\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"#define OCTAVES \" + (this.octaves | 0);\r\n    }\r\n\r\n    /** Generate the current state of the procedural texture */\r\n    public render(useCameraPostProcess?: boolean) {\r\n        this._updateShaderUniforms();\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    /**\r\n     * Serializes this noise procedural texture\r\n     * @returns a serialized noise procedural texture object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\r\n\r\n        serializationObject.brightness = this.brightness;\r\n        serializationObject.octaves = this.octaves;\r\n        serializationObject.persistence = this.persistence;\r\n        serializationObject.animationSpeedFactor = this.animationSpeedFactor;\r\n        serializationObject.size = this.getSize().width;\r\n        serializationObject.generateMipMaps = this._generateMipMaps;\r\n        serializationObject.time = this.time;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): NoiseProceduralTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        // Noise Specifics\r\n        newTexture.brightness = this.brightness;\r\n        newTexture.octaves = this.octaves;\r\n        newTexture.persistence = this.persistence;\r\n        newTexture.animationSpeedFactor = this.animationSpeedFactor;\r\n        newTexture.time = this.time;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a NoiseProceduralTexture from parsed noise procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing noise procedural texture information\r\n     * @returns a parsed NoiseProceduralTexture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): NoiseProceduralTexture {\r\n        var texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\r\n\r\n        texture.brightness = parsedTexture.brightness;\r\n        texture.octaves = parsedTexture.octaves;\r\n        texture.persistence = parsedTexture.persistence;\r\n        texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\r\n        texture.time = parsedTexture.time ?? 0;\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.NoiseProceduralTexture\"] = NoiseProceduralTexture;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}