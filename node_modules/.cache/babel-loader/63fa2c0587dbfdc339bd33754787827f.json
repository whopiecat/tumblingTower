{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../../Misc/decorators\";\nimport { Observable } from \"../../../Misc/observable\";\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\nimport { Material } from \"../../../Materials/material\";\nimport { Texture } from \"../../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\nimport \"../../../Engines/Extensions/engine.renderTarget\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\nimport \"../../../Shaders/procedural.vertex\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport { EngineStore } from '../../../Engines/engineStore';\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\n\nvar ProceduralTexture =\n/** @class */\nfunction (_super) {\n  __extends(ProceduralTexture, _super);\n  /**\r\n   * Instantiates a new procedural texture.\r\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n   * This is the base class of any Procedural texture and contains most of the shareable code.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n   * @param name  Define the name of the texture\r\n   * @param size Define the size of the texture to create\r\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n   * @param scene Define the scene the texture belongs to\r\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n   * @param generateMipMaps Define if the texture should creates mip maps or not\r\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n   * @param textureType The FBO internal texture type\r\n   */\n\n\n  function ProceduralTexture(name, size, fragment, scene, fallbackTexture, generateMipMaps, isCube, textureType) {\n    if (fallbackTexture === void 0) {\n      fallbackTexture = null;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (isCube === void 0) {\n      isCube = false;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\n\n\n    _this.isEnabled = true;\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\n\n    _this.autoClear = true;\n    /**\r\n     * Event raised when the texture is generated\r\n     */\n\n    _this.onGeneratedObservable = new Observable();\n    /**\r\n     * Event raised before the texture is generated\r\n     */\n\n    _this.onBeforeGenerationObservable = new Observable();\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\n\n    _this.nodeMaterialSource = null;\n    /** @hidden */\n\n    _this._textures = {};\n    _this._currentRefreshId = -1;\n    _this._frameId = -1;\n    _this._refreshRate = 1;\n    _this._vertexBuffers = {};\n    _this._uniforms = new Array();\n    _this._samplers = new Array();\n    _this._floats = {};\n    _this._ints = {};\n    _this._floatsArrays = {};\n    _this._colors3 = {};\n    _this._colors4 = {};\n    _this._vectors2 = {};\n    _this._vectors3 = {};\n    _this._matrices = {};\n    _this._fallbackTextureUsed = false;\n    _this._cachedDefines = \"\";\n    _this._contentUpdateId = -1;\n    scene = _this.getScene() || EngineStore.LastCreatedScene;\n\n    var component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n\n      scene._addComponent(component);\n    }\n\n    scene.proceduralTextures.push(_this);\n    _this._fullEngine = scene.getEngine();\n    _this.name = name;\n    _this.isRenderTarget = true;\n    _this._size = size;\n    _this._generateMipMaps = generateMipMaps;\n\n    _this.setFragment(fragment);\n\n    _this._fallbackTexture = fallbackTexture;\n\n    if (isCube) {\n      _this._texture = _this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n\n      _this.setFloat(\"face\", 0);\n    } else {\n      _this._texture = _this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType\n      });\n    } // VBO\n\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    _this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(_this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n\n    _this._createIndexBuffer();\n\n    return _this;\n  }\n  /**\r\n   * The effect that is created when initializing the post process.\r\n   * @returns The created effect corresponding the the postprocess.\r\n   */\n\n\n  ProceduralTexture.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n   * @returns an ArrayBufferView (Uint8Array or Float32Array)\r\n   */\n\n\n  ProceduralTexture.prototype.getContent = function () {\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n\n    this._contentData = this.readPixels(0, 0, this._contentData);\n    this._contentUpdateId = this._frameId;\n    return this._contentData;\n  };\n\n  ProceduralTexture.prototype._createIndexBuffer = function () {\n    var engine = this._fullEngine; // Indices\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  };\n  /** @hidden */\n\n\n  ProceduralTexture.prototype._rebuild = function () {\n    var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vb) {\n      vb._rebuild();\n    }\n\n    this._createIndexBuffer();\n\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  };\n  /**\r\n   * Resets the texture in order to recreate its associated resources.\r\n   * This can be called in case of context loss\r\n   */\n\n\n  ProceduralTexture.prototype.reset = function () {\n    if (this._effect === undefined) {\n      return;\n    }\n\n    this._effect.dispose();\n  };\n\n  ProceduralTexture.prototype._getDefines = function () {\n    return \"\";\n  };\n  /**\r\n   * Is the texture ready to be used ? (rendered at least once)\r\n   * @returns true if ready, otherwise, false.\r\n   */\n\n\n  ProceduralTexture.prototype.isReady = function () {\n    var _this = this;\n\n    var engine = this._fullEngine;\n    var shaders;\n\n    if (this.nodeMaterialSource) {\n      return this._effect.isReady();\n    }\n\n    if (!this._fragment) {\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n\n    var defines = this._getDefines();\n\n    if (this._effect && defines === this._cachedDefines && this._effect.isReady()) {\n      return true;\n    }\n\n    if (this._fragment.fragmentElement !== undefined) {\n      shaders = {\n        vertex: \"procedural\",\n        fragmentElement: this._fragment.fragmentElement\n      };\n    } else {\n      shaders = {\n        vertex: \"procedural\",\n        fragment: this._fragment\n      };\n    }\n\n    this._cachedDefines = defines;\n    this._effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, function () {\n      _this.releaseInternalTexture();\n\n      if (_this._fallbackTexture) {\n        _this._texture = _this._fallbackTexture._texture;\n\n        if (_this._texture) {\n          _this._texture.incrementReferences();\n        }\n      }\n\n      _this._fallbackTextureUsed = true;\n    });\n    return this._effect.isReady();\n  };\n  /**\r\n   * Resets the refresh counter of the texture and start bak from scratch.\r\n   * Could be useful to regenerate the texture if it is setup to render only once.\r\n   */\n\n\n  ProceduralTexture.prototype.resetRefreshCounter = function () {\n    this._currentRefreshId = -1;\n  };\n  /**\r\n   * Set the fragment shader to use in order to render the texture.\r\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n   */\n\n\n  ProceduralTexture.prototype.setFragment = function (fragment) {\n    this._fragment = fragment;\n  };\n\n  Object.defineProperty(ProceduralTexture.prototype, \"refreshRate\", {\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\n    get: function () {\n      return this._refreshRate;\n    },\n    set: function (value) {\n      this._refreshRate = value;\n      this.resetRefreshCounter();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  ProceduralTexture.prototype._shouldRender = function () {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n\n      return false;\n    }\n\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n\n    this._currentRefreshId++;\n    return false;\n  };\n  /**\r\n   * Get the size the texture is rendering at.\r\n   * @returns the size (on cube texture it is always squared)\r\n   */\n\n\n  ProceduralTexture.prototype.getRenderSize = function () {\n    return this._size;\n  };\n  /**\r\n   * Resize the texture to new value.\r\n   * @param size Define the new size the texture should have\r\n   * @param generateMipMaps Define whether the new texture should create mip maps\r\n   */\n\n\n  ProceduralTexture.prototype.resize = function (size, generateMipMaps) {\n    if (this._fallbackTextureUsed) {\n      return;\n    }\n\n    this.releaseInternalTexture();\n    this._texture = this._fullEngine.createRenderTargetTexture(size, generateMipMaps); // Update properties\n\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  };\n\n  ProceduralTexture.prototype._checkUniform = function (uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  };\n  /**\r\n   * Set a texture in the shader program used to render.\r\n   * @param name Define the name of the uniform samplers as defined in the shader\r\n   * @param texture Define the texture to bind to this sampler\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setTexture = function (name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n\n    this._textures[name] = texture;\n    return this;\n  };\n  /**\r\n   * Set a float in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setFloat = function (name, value) {\n    this._checkUniform(name);\n\n    this._floats[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a int in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setInt = function (name, value) {\n    this._checkUniform(name);\n\n    this._ints[name] = value;\n    return this;\n  };\n  /**\r\n   * Set an array of floats in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setFloats = function (name, value) {\n    this._checkUniform(name);\n\n    this._floatsArrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Color3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setColor3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Color4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setColor4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec2 in the shader from a Vector2.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setVector2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Vector3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setVector3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat4 in the shader from a MAtrix.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the texture itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ProceduralTexture.prototype.setMatrix = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices[name] = value;\n    return this;\n  };\n  /**\r\n   * Render the texture to its associated render target.\r\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n   */\n\n\n  ProceduralTexture.prototype.render = function (useCameraPostProcess) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = this._fullEngine; // Render\n\n    engine.enableEffect(this._effect);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (var name in this._textures) {\n        this._effect.setTexture(name, this._textures[name]);\n      } // Float\n\n\n      for (name in this._ints) {\n        this._effect.setInt(name, this._ints[name]);\n      } // Float\n\n\n      for (name in this._floats) {\n        this._effect.setFloat(name, this._floats[name]);\n      } // Floats\n\n\n      for (name in this._floatsArrays) {\n        this._effect.setArray(name, this._floatsArrays[name]);\n      } // Color3\n\n\n      for (name in this._colors3) {\n        this._effect.setColor3(name, this._colors3[name]);\n      } // Color4\n\n\n      for (name in this._colors4) {\n        var color = this._colors4[name];\n\n        this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      } // Vector2\n\n\n      for (name in this._vectors2) {\n        this._effect.setVector2(name, this._vectors2[name]);\n      } // Vector3\n\n\n      for (name in this._vectors3) {\n        this._effect.setVector3(name, this._vectors3[name]);\n      } // Matrix\n\n\n      for (name in this._matrices) {\n        this._effect.setMatrix(name, this._matrices[name]);\n      }\n    }\n\n    if (!this._texture) {\n      return;\n    }\n\n    if (this.isCube) {\n      for (var face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._texture, face, undefined, undefined, true); // VBOs\n\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n\n        this._effect.setFloat(\"face\", face); // Clear\n\n\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        } // Draw order\n\n\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6); // Mipmaps\n\n        if (face === 5) {\n          engine.generateMipMapsForCubemap(this._texture);\n        }\n      }\n    } else {\n      engine.bindFramebuffer(this._texture, 0, undefined, undefined, true); // VBOs\n\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect); // Clear\n\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      } // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Unbind\n\n\n    engine.unBindFramebuffer(this._texture, this.isCube);\n\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n\n    this.onGeneratedObservable.notifyObservers(this);\n  };\n  /**\r\n   * Clone the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  ProceduralTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /**\r\n   * Dispose the texture and release its asoociated resources.\r\n   */\n\n\n  ProceduralTexture.prototype.dispose = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var index = scene.proceduralTextures.indexOf(this);\n\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n\n  __decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\n\n  return ProceduralTexture;\n}(Texture);\n\nexport { ProceduralTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.ProceduralTexture\"] = ProceduralTexture;","map":{"version":3,"sources":["../../../../../sourceES6/core/Materials/Textures/Procedurals/proceduralTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport { Nullable } from \"../../../types\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color4, Color3 } from '../../../Maths/math.color';\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport { DataBuffer } from '../../../Meshes/dataBuffer';\r\nimport { _TypeStore } from '../../../Misc/typeStore';\r\nimport { NodeMaterial } from '../../Node/nodeMaterial';\r\nimport { RenderTargetTextureSize } from '../../../Engines/Extensions/engine.renderTarget';\r\nimport { EngineStore } from '../../../Engines/engineStore';\r\n\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /** @hidden */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    /** @hidden **/\r\n    public _effect: Effect;\r\n\r\n    /** @hidden */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    /** @hidden */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    @serialize()\r\n    private _size: RenderTargetTextureSize;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: Engine;\r\n\r\n    private _cachedDefines = \"\";\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(name: string, size: RenderTargetTextureSize, fragment: any, scene: Nullable<Scene>, fallbackTexture: Nullable<Texture> = null, generateMipMaps = true, isCube = false, textureType = 0) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        if (isCube) {\r\n            this._texture = this._fullEngine.createRenderTargetCubeTexture(size as number, { generateMipMaps: generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false, type: textureType });\r\n            this.setFloat(\"face\", 0);\r\n        }\r\n        else {\r\n            this._texture = this._fullEngine.createRenderTargetTexture(size, { generateMipMaps: generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false, type: textureType });\r\n        }\r\n\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<ArrayBufferView> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        this._contentData = this.readPixels(0, 0, this._contentData);\r\n        this._contentUpdateId = this._frameId;\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        var engine = this._fullEngine;\r\n\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss\r\n     */\r\n    public reset(): void {\r\n        if (this._effect === undefined) {\r\n            return;\r\n        }\r\n        this._effect.dispose();\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        var engine = this._fullEngine;\r\n        var shaders;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._effect.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        let defines = this._getDefines();\r\n        if (this._effect && defines === this._cachedDefines && this._effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        }\r\n        else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        this._cachedDefines = defines;\r\n\r\n        this._effect = engine.createEffect(shaders,\r\n            [VertexBuffer.PositionKind],\r\n            this._uniforms,\r\n            this._samplers,\r\n            defines, undefined, undefined, () => {\r\n                this.releaseInternalTexture();\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) { // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): RenderTargetTextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: number, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed) {\r\n            return;\r\n        }\r\n\r\n        this.releaseInternalTexture();\r\n        this._texture = this._fullEngine.createRenderTargetTexture(size, generateMipMaps);\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._effect);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (var name in this._textures) {\r\n                this._effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._ints) {\r\n                this._effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                this._effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                this._effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                this._effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                var color = this._colors4[name];\r\n                this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                this._effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                this._effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                this._effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        if (this.isCube) {\r\n            for (var face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._texture, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\r\n\r\n                this._effect.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n                // Mipmaps\r\n                if (face === 5) {\r\n                    engine.generateMipMapsForCubemap(this._texture);\r\n                }\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._texture, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind\r\n        engine.unBindFramebuffer(this._texture, this.isCube);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its asoociated resources.\r\n     */\r\n    public dispose(): void {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ProceduralTexture\"] = ProceduralTexture;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}