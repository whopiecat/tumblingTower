{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"./texture\";\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * Class used to store 3D textures containing user data\r\n */\n\nvar RawTexture3D =\n/** @class */\nfunction (_super) {\n  __extends(RawTexture3D, _super);\n  /**\r\n   * Create a new RawTexture3D\r\n   * @param data defines the data of the texture\r\n   * @param width defines the width of the texture\r\n   * @param height defines the height of the texture\r\n   * @param depth defines the depth of the texture\r\n   * @param format defines the texture format to use\r\n   * @param scene defines the hosting scene\r\n   * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n   * @param invertY defines if texture must be stored with Y axis inverted\r\n   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n   * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n   */\n\n\n  function RawTexture3D(data, width, height, depth,\n  /** Gets or sets the texture format to use */\n  format, scene, generateMipMaps, invertY, samplingMode, textureType) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n\n    _this.format = format;\n    _this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType);\n    _this.is3D = true;\n    return _this;\n  }\n  /**\r\n   * Update the texture with new data\r\n   * @param data defines the data to store in the texture\r\n   */\n\n\n  RawTexture3D.prototype.update = function (data) {\n    if (!this._texture) {\n      return;\n    }\n\n    this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  };\n\n  return RawTexture3D;\n}(Texture);\n\nexport { RawTexture3D };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/rawTexture3D.ts"],"names":[],"mappings":";AACA,SAAS,OAAT,QAAwB,WAAxB;AAEA,OAAO,4CAAP;AACA;;;;AAGA,IAAA,YAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAkC,EAAA,SAAA,CAAA,YAAA,EAAA,MAAA,CAAA;AAC9B;;;;;;;;;;;;;;;AAaA,WAAA,YAAA,CAAY,IAAZ,EAAmC,KAAnC,EAAkD,MAAlD,EAAkE,KAAlE;AACI;AACO,EAAA,MAFX,EAE2B,KAF3B,EAGI,eAHJ,EAII,OAJJ,EAKI,YALJ,EAMI,WANJ,EAMmB;AAHf,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,IAAA;AAA+B;;AAC/B,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,KAAA;AAAwB;;AACxB,QAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,YAAA,GAAuB,OAAO,CAAC,sBAA/B;AAAqD;;AACrD,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,CAAA;AAAe;;AANnB,QAAA,KAAA,GAOI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,KAAZ,EAAmB,CAAC,eAApB,EAAqC,OAArC,KAA6C,IAPjD;;AAEW,IAAA,KAAA,CAAA,MAAA,GAAA,MAAA;AAOP,IAAA,KAAI,CAAC,QAAL,GAAgB,KAAK,CAAC,SAAN,GAAkB,kBAAlB,CACZ,IADY,EAEZ,KAFY,EAGZ,MAHY,EAIZ,KAJY,EAKZ,MALY,EAMZ,eANY,EAOZ,OAPY,EAQZ,YARY,EASZ,IATY,EAUZ,WAVY,CAAhB;AAaA,IAAA,KAAI,CAAC,IAAL,GAAY,IAAZ;;AACH;AAED;;;;;;AAIO,EAAA,YAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAAmC;AAC/B,QAAI,CAAC,KAAK,QAAV,EAAoB;AAChB;AACH;;AACD,SAAK,UAAL,GAAmB,kBAAnB,CAAsC,KAAK,QAA3C,EAAqD,IAArD,EAA2D,KAAK,QAAL,CAAc,MAAzE,EAAiF,KAAK,QAAL,CAAe,OAAhG,EAAyG,IAAzG,EAA+G,KAAK,QAAL,CAAc,IAA7H;AACH,GALM;;AAMX,SAAA,YAAA;AAAC,CAjDD,CAAkC,OAAlC,CAAA","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Texture } from \"./texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n/**\r\n * Class used to store 3D textures containing user data\r\n */\r\nexport class RawTexture3D extends Texture {\r\n    /**\r\n     * Create a new RawTexture3D\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the depth of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     */\r\n    constructor(data: ArrayBufferView, width: number, height: number, depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number, scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = 0) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture3D(\r\n            data,\r\n            width,\r\n            height,\r\n            depth,\r\n            format,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            null,\r\n            textureType\r\n        );\r\n\r\n        this.is3D = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture3D(this._texture, data, this._texture.format, this._texture!.invertY, null, this._texture.type);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}