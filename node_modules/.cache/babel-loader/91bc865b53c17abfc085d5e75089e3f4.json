{"ast":null,"code":"import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Mesh } from \"../Meshes/mesh\";\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Material } from '../Materials/material';\nimport { ShaderMaterial } from '../Materials/shaderMaterial';\nimport { DynamicTexture } from '../Materials/Textures/dynamicTexture';\nimport { VertexBuffer } from '../Meshes/buffer';\nimport { Effect } from '../Materials/effect';\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\nimport { ShapeBuilder } from '../Meshes/Builders/shapeBuilder';\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\n\nvar SkeletonViewer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SkeletonViewer\r\n   * @param skeleton defines the skeleton to render\r\n   * @param mesh defines the mesh attached to the skeleton\r\n   * @param scene defines the hosting scene\r\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n   * @param renderingGroupId defines the rendering group id to use with the viewer\r\n   * @param options All of the extra constructor options for the SkeletonViewer\r\n   */\n  function SkeletonViewer(\n  /** defines the skeleton to render */\n  skeleton,\n  /** defines the mesh attached to the skeleton */\n  mesh,\n  /** The Scene scope*/\n  scene,\n  /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices,\n  /** defines the rendering group id to use with the viewer */\n  renderingGroupId,\n  /** is the options for the viewer */\n  options) {\n    if (autoUpdateBonesMatrices === void 0) {\n      autoUpdateBonesMatrices = true;\n    }\n\n    if (renderingGroupId === void 0) {\n      renderingGroupId = 3;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n\n    this._isEnabled = false;\n    /** SkeletonViewer render observable. */\n\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false; //Defaults\n\n    options.pauseAnimations = (_a = options.pauseAnimations) !== null && _a !== void 0 ? _a : true;\n    options.returnToRest = (_c = options.returnToRest) !== null && _c !== void 0 ? _c : false;\n    options.displayMode = (_d = options.displayMode) !== null && _d !== void 0 ? _d : SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = (_e = options.displayOptions) !== null && _e !== void 0 ? _e : {};\n    options.displayOptions.midStep = (_f = options.displayOptions.midStep) !== null && _f !== void 0 ? _f : 0.235;\n    options.displayOptions.midStepFactor = (_g = options.displayOptions.midStepFactor) !== null && _g !== void 0 ? _g : 0.155;\n    options.displayOptions.sphereBaseSize = (_h = options.displayOptions.sphereBaseSize) !== null && _h !== void 0 ? _h : 0.15;\n    options.displayOptions.sphereScaleUnit = (_j = options.displayOptions.sphereScaleUnit) !== null && _j !== void 0 ? _j : 2;\n    options.displayOptions.sphereFactor = (_k = options.displayOptions.sphereFactor) !== null && _k !== void 0 ? _k : 0.865;\n    options.displayOptions.spurFollowsChild = (_l = options.displayOptions.spurFollowsChild) !== null && _l !== void 0 ? _l : false;\n    options.displayOptions.showLocalAxes = (_m = options.displayOptions.showLocalAxes) !== null && _m !== void 0 ? _m : false;\n    options.displayOptions.localAxesSize = (_o = options.displayOptions.localAxesSize) !== null && _o !== void 0 ? _o : 0.075;\n    options.computeBonesUsingShaders = (_p = options.computeBonesUsingShaders) !== null && _p !== void 0 ? _p : true;\n    options.useAllBones = (_q = options.useAllBones) !== null && _q !== void 0 ? _q : true;\n    var initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    this._boneIndices = new Set();\n\n    if (!options.useAllBones) {\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (var i = 0; i < initialMeshBoneIndices.length; ++i) {\n          var index = initialMeshBoneIndices[i],\n              weight = initialMeshBoneWeights[i];\n\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n\n\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    var displayMode = this.options.displayMode || 0;\n\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n\n    this.displayMode = displayMode; //Prep the Systems\n\n    this.update();\n\n    this._bindObs();\n  }\n  /** public static method to create a BoneWeight Shader\r\n   * @param options The constructor options\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns The created ShaderMaterial\r\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n   */\n\n\n  SkeletonViewer.CreateBoneWeightShader = function (options, scene) {\n    var _a, _c, _d, _e, _f, _g;\n\n    var skeleton = options.skeleton;\n    var colorBase = (_a = options.colorBase) !== null && _a !== void 0 ? _a : Color3.Black();\n    var colorZero = (_c = options.colorZero) !== null && _c !== void 0 ? _c : Color3.Blue();\n    var colorQuarter = (_d = options.colorQuarter) !== null && _d !== void 0 ? _d : Color3.Green();\n    var colorHalf = (_e = options.colorHalf) !== null && _e !== void 0 ? _e : Color3.Yellow();\n    var colorFull = (_f = options.colorFull) !== null && _f !== void 0 ? _f : Color3.Red();\n    var targetBoneIndex = (_g = options.targetBoneIndex) !== null && _g !== void 0 ? _g : 0;\n    Effect.ShadersStore['boneWeights:' + skeleton.name + \"VertexShader\"] = \"precision highp float;\\n\\n        attribute vec3 position;\\n        attribute vec2 uv;\\n\\n        uniform mat4 view;\\n        uniform mat4 projection;\\n        uniform mat4 worldViewProjection;\\n\\n        #include<bonesDeclaration>\\n        #if NUM_BONE_INFLUENCERS == 0\\n            attribute vec4 matricesIndices;\\n            attribute vec4 matricesWeights;\\n        #endif\\n\\n        #include<instancesDeclaration>\\n\\n        varying vec3 vColor;\\n\\n        uniform vec3 colorBase;\\n        uniform vec3 colorZero;\\n        uniform vec3 colorQuarter;\\n        uniform vec3 colorHalf;\\n        uniform vec3 colorFull;\\n\\n        uniform float targetBoneIndex;\\n\\n        void main() {\\n            vec3 positionUpdated = position;\\n\\n            #include<instancesVertex>\\n            #include<bonesVertex>\\n\\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n            vec3 color = colorBase;\\n            float totalWeight = 0.;\\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\\n                totalWeight += matricesWeights[0];\\n            }\\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\\n                totalWeight += matricesWeights[1];\\n            }\\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\\n                totalWeight += matricesWeights[2];\\n            }\\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\\n                totalWeight += matricesWeights[3];\\n            }\\n\\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\\n            vColor = color;\\n\\n        gl_Position = projection * view * worldPos;\\n        }\";\n    Effect.ShadersStore['boneWeights:' + skeleton.name + \"FragmentShader\"] = \"\\n            precision highp float;\\n            varying vec3 vPosition;\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4(vColor, 1.0);\\n                gl_FragColor = color;\\n            }\\n        \";\n    var shader = new ShaderMaterial('boneWeight:' + skeleton.name, scene, {\n      vertex: 'boneWeights:' + skeleton.name,\n      fragment: 'boneWeights:' + skeleton.name\n    }, {\n      attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection', 'colorBase', 'colorZero', 'colorQuarter', 'colorHalf', 'colorFull', 'targetBoneIndex']\n    });\n    shader.setColor3('colorBase', colorBase);\n    shader.setColor3('colorZero', colorZero);\n    shader.setColor3('colorQuarter', colorQuarter);\n    shader.setColor3('colorHalf', colorHalf);\n    shader.setColor3('colorFull', colorFull);\n    shader.setFloat('targetBoneIndex', targetBoneIndex);\n\n    shader.getClassName = function () {\n      return \"BoneWeightShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** public static method to create a BoneWeight Shader\r\n   * @param options The constructor options\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns The created ShaderMaterial\r\n   */\n\n\n  SkeletonViewer.CreateSkeletonMapShader = function (options, scene) {\n    var _a;\n\n    var skeleton = options.skeleton;\n    var colorMap = (_a = options.colorMap) !== null && _a !== void 0 ? _a : [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(.59, 0.18, 1.00),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    var bufferWidth = skeleton.bones.length + 1;\n\n    var colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n\n    var shader = new ShaderMaterial('boneWeights:' + skeleton.name, scene, {\n      vertexSource: \"precision highp float;\\n\\n            attribute vec3 position;\\n            attribute vec2 uv;\\n\\n            uniform mat4 view;\\n            uniform mat4 projection;\\n            uniform mat4 worldViewProjection;\\n            uniform float colorMap[\" + skeleton.bones.length * 4 + \"];\\n\\n            #include<bonesDeclaration>\\n            #if NUM_BONE_INFLUENCERS == 0\\n                attribute vec4 matricesIndices;\\n                attribute vec4 matricesWeights;\\n            #endif\\n            #include<instancesDeclaration>\\n\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec3 positionUpdated = position;\\n\\n                #include<instancesVertex>\\n                #include<bonesVertex>\\n\\n                vec3 color = vec3(0.);\\n                bool first = true;\\n\\n                for (int i = 0; i < 4; i++) {\\n                    int boneIdx = int(matricesIndices[i]);\\n                    float boneWgt = matricesWeights[i];\\n\\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\\n\\n                    if (boneWgt > 0.) {\\n                        if (first) {\\n                            first = false;\\n                            color = c;\\n                        } else {\\n                            color = mix(color, c, boneWgt);\\n                        }\\n                    }\\n                }\\n\\n                vColor = color;\\n\\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\\n\\n                gl_Position = projection * view * worldPos;\\n            }\",\n      fragmentSource: \"\\n            precision highp float;\\n            varying vec3 vColor;\\n\\n            void main() {\\n                vec4 color = vec4( vColor, 1.0 );\\n                gl_FragColor = color;\\n            }\\n            \"\n    }, {\n      attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection', 'colorMap']\n    });\n    shader.setFloats('colorMap', colorMapBuffer);\n\n    shader.getClassName = function () {\n      return \"SkeletonMapShader\";\n    };\n\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  };\n  /** private static method to create a BoneWeight Shader\r\n   * @param size The size of the buffer to create (usually the bone count)\r\n   * @param colorMap The gradient data to generate\r\n   * @param scene The scene that the shader is scoped to\r\n   * @returns an Array of floats from the color gradient values\r\n   */\n\n\n  SkeletonViewer._CreateBoneMapColorBuffer = function (size, colorMap, scene) {\n    var tempGrad = new DynamicTexture('temp', {\n      width: size,\n      height: 1\n    }, scene, false);\n    var ctx = tempGrad.getContext();\n    var grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(function (stop) {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    var buffer = [];\n    var data = ctx.getImageData(0, 0, size, 1).data;\n    var rUnit = 1 / 255;\n\n    for (var i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n\n    tempGrad.dispose();\n    return buffer;\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"scene\", {\n    /** Gets the Scene. */\n    get: function () {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"utilityLayer\", {\n    /** Gets the utilityLayer. */\n    get: function () {\n      return this._utilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"isReady\", {\n    /** Checks Ready Status. */\n    get: function () {\n      return this._ready;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"ready\", {\n    /** Sets Ready Status. */\n    set: function (value) {\n      this._ready = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"debugMesh\", {\n    /** Gets the debugMesh */\n    get: function () {\n      return this._debugMesh;\n    },\n\n    /** Sets the debugMesh */\n    set: function (value) {\n      this._debugMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SkeletonViewer.prototype, \"displayMode\", {\n    /** Gets the displayMode */\n    get: function () {\n      return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n    },\n\n    /** Sets the displayMode */\n    set: function (value) {\n      if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n        value = SkeletonViewer.DISPLAY_LINES;\n      }\n\n      this.options.displayMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** The Dynamic bindings for the update functions */\n\n  SkeletonViewer.prototype._bindObs = function () {\n    var _this = this;\n\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(function () {\n            _this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  };\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n\n\n  SkeletonViewer.prototype.update = function () {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n\n          break;\n        }\n\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n\n          break;\n        }\n    }\n\n    this._buildLocalAxes();\n  };\n\n  Object.defineProperty(SkeletonViewer.prototype, \"isEnabled\", {\n    get: function () {\n      return this._isEnabled;\n    },\n\n    /** Gets or sets a boolean indicating if the viewer is enabled */\n    set: function (value) {\n      if (this.isEnabled === value) {\n        return;\n      }\n\n      this._isEnabled = value;\n\n      if (this.debugMesh) {\n        this.debugMesh.setEnabled(value);\n      }\n\n      if (value && !this._obs) {\n        this._bindObs();\n      } else if (!value && this._obs) {\n        this.scene.onBeforeRenderObservable.remove(this._obs);\n        this._obs = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (z === void 0) {\n      z = 0;\n    }\n\n    var tmat = TmpVectors.Matrix[0];\n    var parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n\n    if (x !== 0 || y !== 0 || z !== 0) {\n      var tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\n    }\n\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {\n    var len = bones.length;\n    var mesh = this.mesh._effectiveMesh;\n    var meshPos = mesh.position;\n    var idx = 0;\n\n    for (var i = 0; i < len; i++) {\n      var bone = bones[i];\n      var points = this._debugLines[idx];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n\n      this._getBonePosition(points[0], bone, meshMat);\n\n      this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  };\n\n  SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones) {\n    var len = bones.length;\n    var boneNum = 0;\n    var mesh = this.mesh._effectiveMesh;\n    var meshPos = mesh.position;\n\n    for (var i = len - 1; i >= 0; i--) {\n      var childBone = bones[i];\n      var parentBone = childBone.getParent();\n\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var points = this._debugLines[boneNum];\n\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n\n      childBone.getAbsolutePositionToRef(mesh, points[0]);\n      parentBone.getAbsolutePositionToRef(mesh, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n  };\n  /** function to revert the mesh and scene back to the initial state. */\n\n\n  SkeletonViewer.prototype._revert = function (animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  };\n  /** function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy. */\n\n\n  SkeletonViewer.prototype._getAbsoluteBindPoseToRef = function (bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n\n    bone.getBindPose().multiplyToRef(matrix, matrix);\n    return;\n  };\n  /** function to build and bind sphere joint points and spur bone representations. */\n\n\n  SkeletonViewer.prototype._buildSpheresAndSpurs = function (spheresOnly) {\n    var _a, _c;\n\n    if (spheresOnly === void 0) {\n      spheresOnly = true;\n    }\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this._ready = false;\n    var utilityLayerScene = (_a = this.utilityLayer) === null || _a === void 0 ? void 0 : _a.utilityLayerScene;\n    var bones = this.skeleton.bones;\n    var spheres = [];\n    var spurs = [];\n    var animationState = this.scene.animationsEnabled;\n\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteTransforms();\n      }\n\n      var longestBoneLength_1 = Number.NEGATIVE_INFINITY;\n      var displayOptions_1 = this.options.displayOptions || {};\n\n      var _loop_1 = function (i) {\n        var bone = bones[i];\n\n        if (bone._index === -1 || !this_1._boneIndices.has(bone.getIndex()) && !this_1.options.useAllBones) {\n          return \"continue\";\n        }\n\n        var boneAbsoluteBindPoseTransform = new Matrix();\n\n        this_1._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n        var anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        bone.children.forEach(function (bc, i) {\n          var childAbsoluteBindPoseTransform = new Matrix();\n          bc.getBindPose().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n          var childPoint = new Vector3();\n          childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n          var distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n\n          if (distanceFromParent > longestBoneLength_1) {\n            longestBoneLength_1 = distanceFromParent;\n          }\n\n          if (spheresOnly) {\n            return;\n          }\n\n          var dir = childPoint.clone().subtract(anchorPoint.clone());\n          var h = dir.length();\n          var up = dir.normalize().scale(h);\n          var midStep = displayOptions_1.midStep || 0.165;\n          var midStepFactor = displayOptions_1.midStepFactor || 0.215;\n          var up0 = up.scale(midStep);\n          var spur = ShapeBuilder.ExtrudeShapeCustom('skeletonViewer', {\n            shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n            path: [Vector3.Zero(), up0, up],\n            scaleFunction: function (i) {\n              switch (i) {\n                case 0:\n                case 2:\n                  return 0;\n\n                case 1:\n                  return h * midStepFactor;\n              }\n\n              return 0;\n            },\n            sideOrientation: Mesh.DEFAULTSIDE,\n            updatable: false\n          }, utilityLayerScene);\n          var numVertices = spur.getTotalVertices();\n          var mwk = [],\n              mik = [];\n\n          for (var i_1 = 0; i_1 < numVertices; i_1++) {\n            mwk.push(1, 0, 0, 0); // Select verts at end of spur (ie vert 10 to 14) and bind to child\n            // bone if spurFollowsChild is enabled.\n\n            if (displayOptions_1.spurFollowsChild && i_1 > 9) {\n              mik.push(bc.getIndex(), 0, 0, 0);\n            } else {\n              mik.push(bone.getIndex(), 0, 0, 0);\n            }\n          }\n\n          spur.position = anchorPoint.clone();\n          spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n          spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n          spur.convertToFlatShadedMesh();\n          spurs.push(spur);\n        });\n        var sphereBaseSize = displayOptions_1.sphereBaseSize || 0.2;\n        var sphere = SphereBuilder.CreateSphere('skeletonViewer', {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        var numVertices = sphere.getTotalVertices();\n        var mwk = [],\n            mik = [];\n\n        for (var i_2 = 0; i_2 < numVertices; i_2++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < bones.length; i++) {\n        _loop_1(i);\n      }\n\n      var sphereScaleUnit = displayOptions_1.sphereScaleUnit || 2;\n      var sphereFactor = displayOptions_1.sphereFactor || 0.85;\n      var meshes = [];\n\n      for (var i = 0; i < spheres.length; i++) {\n        var _d = spheres[i],\n            sphere = _d[0],\n            bone = _d[1];\n        var scale = 1 / (sphereScaleUnit / longestBoneLength_1);\n        var _stepsOut = 0;\n        var _b = bone;\n\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = (_c = this.options.computeBonesUsingShaders) !== null && _c !== void 0 ? _c : true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n\n      var light = this.utilityLayer._getSharedGizmoLight();\n\n      light.intensity = 0.7;\n\n      this._revert(animationState);\n\n      this.ready = true;\n    } catch (err) {\n      console.error(err);\n\n      this._revert(animationState);\n\n      this.dispose();\n    }\n  };\n\n  SkeletonViewer.prototype._buildLocalAxes = function () {\n    var _a;\n\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n\n    this._localAxes = null;\n    var displayOptions = this.options.displayOptions || {};\n\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n    var size = displayOptions.localAxesSize || 0.075;\n    var lines = [];\n    var colors = [];\n    var red = new Color4(1, 0, 0, 1);\n    var green = new Color4(0, 1, 0, 1);\n    var blue = new Color4(0, 0, 1, 1);\n    var mwk = [];\n    var mik = [];\n    var vertsPerBone = 6;\n\n    for (var i in this.skeleton.bones) {\n      var bone = this.skeleton.bones[i];\n\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n\n      var boneAbsoluteBindPoseTransform = new Matrix();\n      var boneOrigin = new Vector3();\n\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n\n      boneAbsoluteBindPoseTransform.decompose(undefined, undefined, boneOrigin);\n      var m = bone.getBindPose().getRotationMatrix();\n      var boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      var boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      var boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      var axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      var axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      var axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      var linePoints = [axisX, axisY, axisZ];\n      var lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push.apply(lines, linePoints);\n      colors.push.apply(colors, lineColors);\n\n      for (var j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n\n    this._localAxes = LinesBuilder.CreateLineSystem('localAxes', {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = (_a = this.options.computeBonesUsingShaders) !== null && _a !== void 0 ? _a : true;\n  };\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n\n\n  SkeletonViewer.prototype._displayLinesUpdate = function () {\n    if (!this._utilityLayer) {\n      return;\n    }\n\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteTransforms();\n    }\n\n    var mesh = this.mesh._effectiveMesh;\n\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());\n    }\n\n    var targetScene = this._utilityLayer.utilityLayerScene;\n\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = LinesBuilder.CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        LinesBuilder.CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n\n      this._debugMesh.position.copyFrom(this.mesh.position);\n\n      this._debugMesh.color = this.color;\n    }\n  };\n  /** Changes the displayMode of the skeleton viewer\r\n   * @param mode The displayMode numerical value\r\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayMode = function (mode) {\n    var wasEnabled = this.isEnabled ? true : false;\n\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n\n        this._debugMesh = null;\n        this.ready = false;\n      }\n\n      this.displayMode = mode;\n      this.update();\n\n      this._bindObs();\n\n      this.isEnabled = wasEnabled;\n    }\n  };\n  /** Sets a display option of the skeleton viewer\r\n   *\r\n   * | Option           | Type    | Default | Description |\r\n   * | ---------------- | ------- | ------- | ----------- |\r\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n   *\r\n   * @param option String of the option name\r\n   * @param value The numerical option value\r\n   */\n\n\n  SkeletonViewer.prototype.changeDisplayOptions = function (option, value) {\n    var wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n      this.ready = false;\n    }\n\n    this.update();\n\n    this._bindObs();\n\n    this.isEnabled = wasEnabled;\n  };\n  /** Release associated resources */\n\n\n  SkeletonViewer.prototype.dispose = function () {\n    this.isEnabled = false;\n\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n\n      this._debugMesh = null;\n    }\n\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n\n      this._utilityLayer = null;\n    }\n\n    this.ready = false;\n  };\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\n\n\n  SkeletonViewer.DISPLAY_LINES = 0;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\n\n  SkeletonViewer.DISPLAY_SPHERES = 1;\n  /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\n\n  SkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;\n  return SkeletonViewer;\n}();\n\nexport { SkeletonViewer };","map":{"version":3,"sources":["../../../sourceES6/core/Debug/skeletonViewer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Material } from '../Materials/material';\r\nimport { ShaderMaterial } from '../Materials/shaderMaterial';\r\nimport { DynamicTexture } from '../Materials/Textures/dynamicTexture';\r\nimport { VertexBuffer } from '../Meshes/buffer';\r\nimport { Effect } from '../Materials/effect';\r\n\r\nimport { ISkeletonViewerOptions, IBoneWeightShaderOptions, ISkeletonMapShaderOptions, ISkeletonMapShaderColorMapKnot } from './ISkeletonViewer';\r\nimport { Observer } from '../Misc/observable';\r\n\r\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\r\nimport { ShapeBuilder } from '../Meshes/Builders/shapeBuilder';\r\n\r\n/**\r\n * Class used to render a debug view of a given skeleton\r\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\r\n */\r\nexport class SkeletonViewer {\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\r\n    public static readonly DISPLAY_LINES = 0;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\r\n    public static readonly DISPLAY_SPHERES = 1;\r\n    /** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\r\n    public static readonly DISPLAY_SPHERE_AND_SPURS = 2;\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     * @see http://www.babylonjs-playground.com/#1BZJVJ#395\r\n     */\r\n    static CreateBoneWeightShader(options: IBoneWeightShaderOptions, scene: Scene): ShaderMaterial {\r\n\r\n        let skeleton: Skeleton = options.skeleton;\r\n        let colorBase: Color3 = options.colorBase ?? Color3.Black();\r\n        let colorZero: Color3 = options.colorZero ?? Color3.Blue();\r\n        let colorQuarter: Color3 = options.colorQuarter ?? Color3.Green();\r\n        let colorHalf: Color3 = options.colorHalf ?? Color3.Yellow();\r\n        let colorFull: Color3 = options.colorFull ?? Color3.Red();\r\n        let targetBoneIndex: number = options.targetBoneIndex ?? 0;\r\n\r\n        Effect.ShadersStore['boneWeights:' + skeleton.name + \"VertexShader\"] =\r\n        `precision highp float;\r\n\r\n        attribute vec3 position;\r\n        attribute vec2 uv;\r\n\r\n        uniform mat4 view;\r\n        uniform mat4 projection;\r\n        uniform mat4 worldViewProjection;\r\n\r\n        #include<bonesDeclaration>\r\n        #if NUM_BONE_INFLUENCERS == 0\r\n            attribute vec4 matricesIndices;\r\n            attribute vec4 matricesWeights;\r\n        #endif\r\n\r\n        #include<instancesDeclaration>\r\n\r\n        varying vec3 vColor;\r\n\r\n        uniform vec3 colorBase;\r\n        uniform vec3 colorZero;\r\n        uniform vec3 colorQuarter;\r\n        uniform vec3 colorHalf;\r\n        uniform vec3 colorFull;\r\n\r\n        uniform float targetBoneIndex;\r\n\r\n        void main() {\r\n            vec3 positionUpdated = position;\r\n\r\n            #include<instancesVertex>\r\n            #include<bonesVertex>\r\n\r\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n            vec3 color = colorBase;\r\n            float totalWeight = 0.;\r\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\r\n                totalWeight += matricesWeights[0];\r\n            }\r\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\r\n                totalWeight += matricesWeights[1];\r\n            }\r\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\r\n                totalWeight += matricesWeights[2];\r\n            }\r\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\r\n                totalWeight += matricesWeights[3];\r\n            }\r\n\r\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\r\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\r\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\r\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\r\n            vColor = color;\r\n\r\n        gl_Position = projection * view * worldPos;\r\n        }`;\r\n        Effect.ShadersStore['boneWeights:' + skeleton.name + \"FragmentShader\"] =\r\n        `\r\n            precision highp float;\r\n            varying vec3 vPosition;\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4(vColor, 1.0);\r\n                gl_FragColor = color;\r\n            }\r\n        `;\r\n        let shader: ShaderMaterial = new ShaderMaterial('boneWeight:' + skeleton.name, scene,\r\n        {\r\n            vertex: 'boneWeights:' + skeleton.name,\r\n            fragment: 'boneWeights:' + skeleton.name\r\n        },\r\n        {\r\n            attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\r\n            uniforms: [\r\n                'world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection',\r\n                'colorBase', 'colorZero', 'colorQuarter', 'colorHalf', 'colorFull', 'targetBoneIndex'\r\n            ]\r\n        });\r\n\r\n        shader.setColor3('colorBase', colorBase);\r\n        shader.setColor3('colorZero', colorZero);\r\n        shader.setColor3('colorQuarter', colorQuarter);\r\n        shader.setColor3('colorHalf', colorHalf);\r\n        shader.setColor3('colorFull', colorFull);\r\n        shader.setFloat('targetBoneIndex', targetBoneIndex);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"BoneWeightShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** public static method to create a BoneWeight Shader\r\n     * @param options The constructor options\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns The created ShaderMaterial\r\n     */\r\n    static CreateSkeletonMapShader(options: ISkeletonMapShaderOptions, scene: Scene) {\r\n\r\n        let skeleton: Skeleton = options.skeleton;\r\n        let colorMap: ISkeletonMapShaderColorMapKnot[] = options.colorMap ?? [\r\n            {\r\n                color: new Color3(1, 0.38, 0.18),\r\n                location : 0\r\n            },\r\n            {\r\n                color: new Color3(.59, 0.18, 1.00),\r\n                location : 0.2\r\n            },\r\n            {\r\n                color: new Color3(0.59, 1, 0.18),\r\n                location : 0.4\r\n            },\r\n            {\r\n               color: new Color3(1, 0.87, 0.17),\r\n                location : 0.6\r\n            },\r\n            {\r\n                color: new Color3(1, 0.17, 0.42),\r\n                location : 0.8\r\n            },\r\n            {\r\n                color: new Color3(0.17, 0.68, 1.0),\r\n                location : 1.0\r\n            }\r\n        ];\r\n\r\n        let bufferWidth: number = skeleton.bones.length + 1;\r\n        let colorMapBuffer: number[] = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\r\n        let shader = new ShaderMaterial('boneWeights:' + skeleton.name, scene,\r\n        {\r\n            vertexSource:\r\n            `precision highp float;\r\n\r\n            attribute vec3 position;\r\n            attribute vec2 uv;\r\n\r\n            uniform mat4 view;\r\n            uniform mat4 projection;\r\n            uniform mat4 worldViewProjection;\r\n            uniform float colorMap[` + ((skeleton.bones.length) * 4) + `];\r\n\r\n            #include<bonesDeclaration>\r\n            #if NUM_BONE_INFLUENCERS == 0\r\n                attribute vec4 matricesIndices;\r\n                attribute vec4 matricesWeights;\r\n            #endif\r\n            #include<instancesDeclaration>\r\n\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec3 positionUpdated = position;\r\n\r\n                #include<instancesVertex>\r\n                #include<bonesVertex>\r\n\r\n                vec3 color = vec3(0.);\r\n                bool first = true;\r\n\r\n                for (int i = 0; i < 4; i++) {\r\n                    int boneIdx = int(matricesIndices[i]);\r\n                    float boneWgt = matricesWeights[i];\r\n\r\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\r\n\r\n                    if (boneWgt > 0.) {\r\n                        if (first) {\r\n                            first = false;\r\n                            color = c;\r\n                        } else {\r\n                            color = mix(color, c, boneWgt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vColor = color;\r\n\r\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\r\n\r\n                gl_Position = projection * view * worldPos;\r\n            }`,\r\n            fragmentSource:\r\n            `\r\n            precision highp float;\r\n            varying vec3 vColor;\r\n\r\n            void main() {\r\n                vec4 color = vec4( vColor, 1.0 );\r\n                gl_FragColor = color;\r\n            }\r\n            `\r\n        },\r\n        {\r\n            attributes: ['position', 'normal', 'matricesIndices', 'matricesWeights'],\r\n            uniforms: [\r\n                'world', 'worldView', 'worldViewProjection', 'view', 'projection', 'viewProjection',\r\n                'colorMap'\r\n            ]\r\n        });\r\n\r\n        shader.setFloats('colorMap', colorMapBuffer);\r\n\r\n        shader.getClassName = (): string => {\r\n            return \"SkeletonMapShader\";\r\n        };\r\n\r\n        shader.transparencyMode = Material.MATERIAL_OPAQUE;\r\n\r\n        return shader;\r\n    }\r\n\r\n    /** private static method to create a BoneWeight Shader\r\n     * @param size The size of the buffer to create (usually the bone count)\r\n     * @param colorMap The gradient data to generate\r\n     * @param scene The scene that the shader is scoped to\r\n     * @returns an Array of floats from the color gradient values\r\n     */\r\n    private static _CreateBoneMapColorBuffer(size: number, colorMap: ISkeletonMapShaderColorMapKnot[], scene: Scene) {\r\n        let tempGrad = new DynamicTexture('temp', {width: size, height: 1}, scene, false);\r\n        let ctx = tempGrad.getContext();\r\n        let grad = ctx.createLinearGradient(0, 0, size, 0);\r\n\r\n        colorMap.forEach((stop) => {\r\n            grad.addColorStop(stop.location, stop.color.toHexString());\r\n        });\r\n\r\n        ctx.fillStyle = grad;\r\n        ctx.fillRect(0, 0, size, 1);\r\n        tempGrad.update();\r\n        let buffer: number[] = [];\r\n        let data: Uint8ClampedArray = ctx.getImageData(0, 0, size, 1).data;\r\n        let rUnit = 1 / 255;\r\n        for (let i = 0; i < data.length; i++) {\r\n            buffer.push(data[i] * rUnit);\r\n        }\r\n        tempGrad.dispose();\r\n        return buffer;\r\n    }\r\n\r\n    /** If SkeletonViewer scene scope. */\r\n    private _scene : Scene;\r\n\r\n    /** Gets or sets the color used to render the skeleton */\r\n    public color: Color3 = Color3.White();\r\n\r\n    /** Array of the points of the skeleton fo the line view. */\r\n    private _debugLines = new Array<Array<Vector3>>();\r\n\r\n    /** The SkeletonViewers Mesh. */\r\n    private _debugMesh: Nullable<LinesMesh>;\r\n\r\n    /** The local axes Meshes. */\r\n    private _localAxes: Nullable<LinesMesh> = null;\r\n\r\n    /** If SkeletonViewer is enabled. */\r\n    private _isEnabled = false;\r\n\r\n    /** If SkeletonViewer is ready. */\r\n    private _ready : boolean;\r\n\r\n    /** SkeletonViewer render observable. */\r\n    private _obs: Nullable<Observer<Scene>> = null;\r\n\r\n     /** The Utility Layer to render the gizmos in. */\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _boneIndices: Set<number>;\r\n\r\n    /** Gets the Scene. */\r\n    get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n    /** Gets the utilityLayer. */\r\n    get utilityLayer(): Nullable<UtilityLayerRenderer> {\r\n        return this._utilityLayer;\r\n    }\r\n    /** Checks Ready Status. */\r\n    get isReady(): Boolean {\r\n        return this._ready;\r\n    }\r\n    /** Sets Ready Status. */\r\n    set ready(value: boolean) {\r\n        this._ready = value;\r\n    }\r\n    /** Gets the debugMesh */\r\n    get debugMesh(): Nullable<AbstractMesh> | Nullable<LinesMesh> {\r\n        return this._debugMesh;\r\n    }\r\n    /** Sets the debugMesh */\r\n    set debugMesh(value: Nullable<AbstractMesh> | Nullable<LinesMesh>) {\r\n         this._debugMesh = (value as any);\r\n    }\r\n    /** Gets the displayMode */\r\n    get displayMode(): number {\r\n        return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\r\n    }\r\n    /** Sets the displayMode */\r\n    set displayMode(value: number) {\r\n        if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            value = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.options.displayMode = value;\r\n    }\r\n    /**\r\n     * Creates a new SkeletonViewer\r\n     * @param skeleton defines the skeleton to render\r\n     * @param mesh defines the mesh attached to the skeleton\r\n     * @param scene defines the hosting scene\r\n     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\r\n     * @param renderingGroupId defines the rendering group id to use with the viewer\r\n     * @param options All of the extra constructor options for the SkeletonViewer\r\n     */\r\n    constructor(\r\n        /** defines the skeleton to render */\r\n        public skeleton: Skeleton,\r\n        /** defines the mesh attached to the skeleton */\r\n        public mesh: AbstractMesh,\r\n        /** The Scene scope*/\r\n        scene: Scene,\r\n        /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\r\n        public autoUpdateBonesMatrices: boolean = true,\r\n        /** defines the rendering group id to use with the viewer */\r\n        public renderingGroupId: number = 3,\r\n        /** is the options for the viewer */\r\n        public options: Partial<ISkeletonViewerOptions> = {}\r\n        ) {\r\n\r\n        this._scene = scene;\r\n        this._ready = false;\r\n\r\n        //Defaults\r\n        options.pauseAnimations = options.pauseAnimations ?? true;\r\n        options.returnToRest = options.returnToRest ?? false;\r\n        options.displayMode = options.displayMode ?? SkeletonViewer.DISPLAY_LINES;\r\n        options.displayOptions = options.displayOptions ?? {};\r\n        options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;\r\n        options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;\r\n        options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;\r\n        options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;\r\n        options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;\r\n        options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;\r\n        options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;\r\n        options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;\r\n        options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;\r\n        options.useAllBones = options.useAllBones ?? true;\r\n\r\n        const initialMeshBoneIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const initialMeshBoneWeights = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n        this._boneIndices = new Set();\r\n\r\n        if (!options.useAllBones) {\r\n            if (initialMeshBoneIndices && initialMeshBoneWeights) {\r\n                for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\r\n                    const index = initialMeshBoneIndices[i], weight = initialMeshBoneWeights[i];\r\n                    if (weight !== 0) {\r\n                        this._boneIndices.add(index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /* Create Utility Layer */\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n\r\n        let displayMode = this.options.displayMode || 0;\r\n        if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\r\n            displayMode = SkeletonViewer.DISPLAY_LINES;\r\n        }\r\n        this.displayMode = displayMode;\r\n        //Prep the Systems\r\n        this.update();\r\n        this._bindObs();\r\n    }\r\n\r\n    /** The Dynamic bindings for the update functions */\r\n    private _bindObs(): void {\r\n        switch (this.displayMode){\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                    this._obs = this.scene.onBeforeRenderObservable.add(() => {\r\n                        this._displayLinesUpdate();\r\n                    });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used to manually update. */\r\n    public update(): void {\r\n        switch (this.displayMode){\r\n            case SkeletonViewer.DISPLAY_LINES: {\r\n                this._displayLinesUpdate();\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERES: {\r\n                this._buildSpheresAndSpurs(true);\r\n                break;\r\n            }\r\n            case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {\r\n                this._buildSpheresAndSpurs(false);\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._buildLocalAxes();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the viewer is enabled */\r\n    public set isEnabled(value: boolean) {\r\n        if (this.isEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._isEnabled = value;\r\n\r\n        if (this.debugMesh) {\r\n            this.debugMesh.setEnabled(value);\r\n        }\r\n\r\n        if (value && !this._obs) {\r\n            this._bindObs();\r\n        } else if (!value && this._obs) {\r\n            this.scene.onBeforeRenderObservable.remove(this._obs);\r\n            this._obs = null;\r\n        }\r\n    }\r\n\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    private _getBonePosition(position: Vector3, bone: Bone, meshMat: Matrix, x = 0, y = 0, z = 0): void {\r\n        var tmat = TmpVectors.Matrix[0];\r\n        var parentBone = bone.getParent();\r\n        tmat.copyFrom(bone.getLocalMatrix());\r\n\r\n        if (x !== 0 || y !== 0 || z !== 0) {\r\n            var tmat2 = TmpVectors.Matrix[1];\r\n            Matrix.IdentityToRef(tmat2);\r\n            tmat2.setTranslationFromFloats(x, y, z);\r\n            tmat2.multiplyToRef(tmat, tmat);\r\n        }\r\n\r\n        if (parentBone) {\r\n            tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\r\n        }\r\n\r\n        tmat.multiplyToRef(meshMat, tmat);\r\n\r\n        position.x = tmat.m[12];\r\n        position.y = tmat.m[13];\r\n        position.z = tmat.m[14];\r\n    }\r\n\r\n    private _getLinesForBonesWithLength(bones: Bone[], meshMat: Matrix): void {\r\n        var len = bones.length;\r\n\r\n        let mesh = this.mesh._effectiveMesh;\r\n        var meshPos = mesh.position;\r\n        let idx = 0;\r\n        for (var i = 0; i < len; i++) {\r\n            var bone = bones[i];\r\n            var points = this._debugLines[idx];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[idx] = points;\r\n            }\r\n            this._getBonePosition(points[0], bone, meshMat);\r\n            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    private _getLinesForBonesNoLength(bones: Bone[]): void {\r\n        var len = bones.length;\r\n        var boneNum = 0;\r\n\r\n        let mesh = this.mesh._effectiveMesh;\r\n        var meshPos = mesh.position;\r\n        for (var i = len - 1; i >= 0; i--) {\r\n            var childBone = bones[i];\r\n            var parentBone = childBone.getParent();\r\n            if (!parentBone || (!this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n            var points = this._debugLines[boneNum];\r\n            if (!points) {\r\n                points = [Vector3.Zero(), Vector3.Zero()];\r\n                this._debugLines[boneNum] = points;\r\n            }\r\n            childBone.getAbsolutePositionToRef(mesh, points[0]);\r\n            parentBone.getAbsolutePositionToRef(mesh, points[1]);\r\n            points[0].subtractInPlace(meshPos);\r\n            points[1].subtractInPlace(meshPos);\r\n            boneNum++;\r\n        }\r\n    }\r\n\r\n    /** function to revert the mesh and scene back to the initial state. */\r\n    private _revert(animationState: boolean): void {\r\n        if (this.options.pauseAnimations) {\r\n            this.scene.animationsEnabled = animationState;\r\n            this.utilityLayer!.utilityLayerScene!.animationsEnabled = animationState;\r\n        }\r\n    }\r\n\r\n    /** function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy. */\r\n    private _getAbsoluteBindPoseToRef(bone: Nullable<Bone>, matrix: Matrix) {\r\n        if (bone === null || bone._index === -1) {\r\n            matrix.copyFrom(Matrix.Identity());\r\n            return;\r\n        }\r\n\r\n        this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\r\n        bone.getBindPose().multiplyToRef(matrix, matrix);\r\n        return;\r\n    }\r\n\r\n    /** function to build and bind sphere joint points and spur bone representations. */\r\n    private _buildSpheresAndSpurs(spheresOnly = true): void {\r\n\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n\r\n        this._ready = false;\r\n        let utilityLayerScene = this.utilityLayer?.utilityLayerScene!;\r\n        let bones: Bone[] = this.skeleton.bones;\r\n        let spheres: Array<[Mesh, Bone]> = [];\r\n        let spurs: Mesh[] = [];\r\n\r\n        const animationState = this.scene.animationsEnabled;\r\n\r\n        try {\r\n            if (this.options.pauseAnimations) {\r\n                this.scene.animationsEnabled = false;\r\n                utilityLayerScene.animationsEnabled = false;\r\n            }\r\n\r\n            if (this.options.returnToRest) {\r\n                this.skeleton.returnToRest();\r\n            }\r\n\r\n            if (this.autoUpdateBonesMatrices) {\r\n                this.skeleton.computeAbsoluteTransforms();\r\n            }\r\n\r\n            let longestBoneLength = Number.NEGATIVE_INFINITY;\r\n            let displayOptions = this.options.displayOptions || {};\r\n\r\n            for (let i = 0; i < bones.length; i++) {\r\n                let bone = bones[i];\r\n\r\n                if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                    continue;\r\n                }\r\n\r\n                let boneAbsoluteBindPoseTransform = new Matrix();\r\n                this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n\r\n                let anchorPoint = new Vector3();\r\n\r\n                boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\r\n\r\n                bone.children.forEach((bc, i) => {\r\n                    let childAbsoluteBindPoseTransform : Matrix = new Matrix();\r\n                    bc.getBindPose().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\r\n                    let childPoint = new Vector3();\r\n                    childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\r\n                    let distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\r\n                    if (distanceFromParent > longestBoneLength) {\r\n                        longestBoneLength = distanceFromParent;\r\n                    }\r\n                    if (spheresOnly) {\r\n                        return;\r\n                    }\r\n\r\n                    let dir = childPoint.clone().subtract(anchorPoint.clone());\r\n                    let h = dir.length();\r\n                    let up = dir.normalize().scale(h);\r\n\r\n                    let midStep = displayOptions.midStep || 0.165;\r\n                    let midStepFactor = displayOptions.midStepFactor || 0.215;\r\n\r\n                    let up0 = up.scale(midStep);\r\n\r\n                    let spur = ShapeBuilder.ExtrudeShapeCustom('skeletonViewer',\r\n                    {\r\n                        shape:  [\r\n                                    new Vector3(1, -1,  0),\r\n                                    new Vector3(1,  1,  0),\r\n                                    new Vector3(-1,  1,  0),\r\n                                    new Vector3(-1, -1,  0),\r\n                                    new Vector3(1, -1,  0)\r\n                                ],\r\n                        path:   [ Vector3.Zero(), up0, up ],\r\n                        scaleFunction:\r\n                                (i: number) => {\r\n                                    switch (i){\r\n                                        case 0:\r\n                                        case 2:\r\n                                        return 0;\r\n                                        case 1:\r\n                                        return h * midStepFactor;\r\n                                    }\r\n                                    return 0;\r\n                                },\r\n                        sideOrientation: Mesh.DEFAULTSIDE,\r\n                        updatable: false\r\n                    },  utilityLayerScene);\r\n\r\n                    let numVertices = spur.getTotalVertices();\r\n                    let mwk: number[] = [], mik: number[] = [];\r\n\r\n                    for (let i = 0; i < numVertices; i++) {\r\n                        mwk.push(1, 0, 0, 0);\r\n\r\n                        // Select verts at end of spur (ie vert 10 to 14) and bind to child\r\n                        // bone if spurFollowsChild is enabled.\r\n                        if (displayOptions.spurFollowsChild && i > 9) {\r\n                            mik.push(bc.getIndex(), 0, 0, 0);\r\n                        }\r\n                        else {\r\n                            mik.push(bone.getIndex(), 0, 0, 0);\r\n                        }\r\n                    }\r\n\r\n                    spur.position = anchorPoint.clone();\r\n\r\n                    spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                    spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n                    spur.convertToFlatShadedMesh();\r\n\r\n                    spurs.push(spur);\r\n                });\r\n\r\n                let sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\r\n\r\n                let sphere = SphereBuilder.CreateSphere('skeletonViewer', {\r\n                    segments: 6,\r\n                    diameter: sphereBaseSize,\r\n                    updatable: true\r\n                }, utilityLayerScene);\r\n\r\n                const numVertices = sphere.getTotalVertices();\r\n\r\n                let mwk: number[] = [], mik: number[] = [];\r\n\r\n                for (let i = 0; i < numVertices; i++) {\r\n                    mwk.push(1, 0, 0, 0);\r\n                    mik.push(bone.getIndex(), 0, 0, 0);\r\n                }\r\n\r\n                sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n                sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n\r\n                sphere.position = anchorPoint.clone();\r\n                spheres.push([sphere, bone]);\r\n            }\r\n\r\n            let sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\r\n            let sphereFactor = displayOptions.sphereFactor || 0.85;\r\n\r\n            const meshes = [];\r\n            for (let i = 0; i < spheres.length; i++) {\r\n                let [sphere, bone] = spheres[i];\r\n                let scale = 1 / (sphereScaleUnit / longestBoneLength);\r\n\r\n                let _stepsOut = 0;\r\n                let _b = bone;\r\n\r\n                while ((_b.getParent()) && (_b.getParent() as Bone).getIndex() !== -1) {\r\n                    _stepsOut++;\r\n                    _b = (_b.getParent() as Bone);\r\n                }\r\n                sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\r\n                meshes.push(sphere);\r\n            }\r\n\r\n            this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\r\n            if (this.debugMesh) {\r\n                this.debugMesh.renderingGroupId = this.renderingGroupId;\r\n                this.debugMesh.skeleton = this.skeleton;\r\n                this.debugMesh.parent = this.mesh;\r\n                this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n                this.debugMesh.alwaysSelectAsActiveMesh = true;\r\n            }\r\n\r\n            const light = this.utilityLayer!._getSharedGizmoLight();\r\n            light.intensity = 0.7;\r\n\r\n            this._revert(animationState);\r\n            this.ready = true;\r\n        } catch (err) {\r\n            console.error(err);\r\n            this._revert(animationState);\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    private _buildLocalAxes(): void {\r\n        if (this._localAxes) {\r\n            this._localAxes.dispose();\r\n        }\r\n\r\n        this._localAxes = null;\r\n\r\n        let displayOptions = this.options.displayOptions || {};\r\n\r\n        if (!displayOptions.showLocalAxes) {\r\n            return;\r\n        }\r\n\r\n        const targetScene = this._utilityLayer!.utilityLayerScene;\r\n        const size = displayOptions.localAxesSize || 0.075;\r\n        let lines = [];\r\n        let colors = [];\r\n        let red = new Color4(1, 0, 0, 1);\r\n        let green = new Color4(0, 1, 0, 1);\r\n        let blue = new Color4(0, 0, 1, 1);\r\n\r\n        let mwk: number[] = [];\r\n        let mik: number[] = [];\r\n        const vertsPerBone = 6;\r\n\r\n        for (let i in this.skeleton.bones) {\r\n            let bone = this.skeleton.bones[i];\r\n\r\n            if (bone._index === -1 || (!this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones)) {\r\n                continue;\r\n            }\r\n\r\n            let boneAbsoluteBindPoseTransform = new Matrix();\r\n            let boneOrigin = new Vector3();\r\n\r\n            this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\r\n            boneAbsoluteBindPoseTransform.decompose(undefined, undefined, boneOrigin);\r\n\r\n            let m = bone.getBindPose().getRotationMatrix();\r\n\r\n            let boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\r\n            let boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\r\n            let boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\r\n\r\n            let axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\r\n            let axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\r\n            let axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\r\n\r\n            let linePoints = [axisX, axisY, axisZ];\r\n            let lineColors = [[red, red], [green, green], [blue, blue]];\r\n\r\n            lines.push(...linePoints);\r\n            colors.push(...lineColors);\r\n\r\n            for (let j = 0; j < vertsPerBone; j++) {\r\n                mwk.push(1, 0, 0, 0);\r\n                mik.push(bone.getIndex(), 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        this._localAxes = LinesBuilder.CreateLineSystem('localAxes', { lines: lines, colors: colors, updatable: true }, targetScene);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\r\n        this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\r\n        this._localAxes.skeleton = this.skeleton;\r\n        this._localAxes.renderingGroupId = this.renderingGroupId;\r\n        this._localAxes.parent = this.mesh;\r\n        this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\r\n    }\r\n\r\n    /** Update the viewer to sync with current skeleton state, only used for the line display. */\r\n    private  _displayLinesUpdate(): void {\r\n        if (!this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        if (this.autoUpdateBonesMatrices) {\r\n            this.skeleton.computeAbsoluteTransforms();\r\n        }\r\n\r\n        let mesh = this.mesh._effectiveMesh;\r\n\r\n        if (this.skeleton.bones[0].length === undefined) {\r\n            this._getLinesForBonesNoLength(this.skeleton.bones);\r\n        } else {\r\n            this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());\r\n        }\r\n\r\n        const targetScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        if (targetScene) {\r\n            if (!this._debugMesh) {\r\n                this._debugMesh = LinesBuilder.CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: null }, targetScene);\r\n                this._debugMesh.renderingGroupId = this.renderingGroupId;\r\n            } else {\r\n                LinesBuilder.CreateLineSystem(\"\", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);\r\n            }\r\n            this._debugMesh.position.copyFrom(this.mesh.position);\r\n            this._debugMesh.color = this.color;\r\n        }\r\n    }\r\n    /** Changes the displayMode of the skeleton viewer\r\n     * @param mode The displayMode numerical value\r\n     */\r\n    public changeDisplayMode(mode: number): void {\r\n        let wasEnabled = (this.isEnabled) ? true : false;\r\n        if (this.displayMode !== mode) {\r\n            this.isEnabled = false;\r\n            if (this._debugMesh) {\r\n                this._debugMesh.dispose();\r\n                this._debugMesh = null;\r\n                this.ready = false;\r\n            }\r\n            this.displayMode = mode;\r\n\r\n            this.update();\r\n            this._bindObs();\r\n            this.isEnabled = wasEnabled;\r\n        }\r\n    }\r\n\r\n    /** Sets a display option of the skeleton viewer\r\n     *\r\n     * | Option           | Type    | Default | Description |\r\n     * | ---------------- | ------- | ------- | ----------- |\r\n     * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\r\n     * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\r\n     * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\r\n     * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\r\n     *\r\n     * @param option String of the option name\r\n     * @param value The numerical option value\r\n     */\r\n    public changeDisplayOptions(option: string, value: number): void {\r\n        let wasEnabled = (this.isEnabled) ? true : false;\r\n        (this.options.displayOptions as any)[option] = value;\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n            this.ready = false;\r\n        }\r\n        this.update();\r\n        this._bindObs();\r\n        this.isEnabled = wasEnabled;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        this.isEnabled = false;\r\n        if (this._debugMesh) {\r\n            this._debugMesh.dispose();\r\n            this._debugMesh = null;\r\n        }\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n\r\n        this.ready = false;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}