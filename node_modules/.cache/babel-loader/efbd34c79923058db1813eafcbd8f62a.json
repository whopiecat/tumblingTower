{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport \"../../Engines/Extensions/engine.multiRender\";\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\n\nvar MultiRenderTarget =\n/** @class */\nfunction (_super) {\n  __extends(MultiRenderTarget, _super);\n  /**\r\n   * Instantiate a new multi render target texture.\r\n   * A multi render target, like a render target provides the ability to render to a texture.\r\n   * Unlike the render target, it can render to several draw buffers in one draw.\r\n   * This is specially interesting in deferred rendering or for any effects requiring more than\r\n   * just one color from a single pass.\r\n   * @param name Define the name of the texture\r\n   * @param size Define the size of the buffers to render to\r\n   * @param count Define the number of target we are rendering into\r\n   * @param scene Define the scene the texture belongs to\r\n   * @param options Define the options used to create the multi render target\r\n   */\n\n\n  function MultiRenderTarget(name, size, count, scene, options) {\n    var _this = this;\n\n    var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;\n\n    if (!_this.isSupported) {\n      _this.dispose();\n\n      return;\n    }\n\n    var types = [];\n    var samplingModes = [];\n\n    _this._initTypes(count, types, samplingModes, options);\n\n    var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    _this._size = size;\n    _this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      types: types,\n      textureCount: count\n    };\n    _this._count = count;\n\n    _this._createInternalTextures();\n\n    _this._createTextures();\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"isSupported\", {\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\n    get: function () {\n      return this._getEngine().webGLVersion > 1 || this._getEngine().getCaps().drawBuffersExtension;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"textures\", {\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\n    get: function () {\n      return this._textures;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"count\", {\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\n    get: function () {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"depthTexture\", {\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\n    get: function () {\n      return this._textures[this._textures.length - 1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapU\", {\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\n    set: function (wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapU = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MultiRenderTarget.prototype, \"wrapV\", {\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\n    set: function (wrap) {\n      if (this._textures) {\n        for (var i = 0; i < this._textures.length; i++) {\n          this._textures[i].wrapV = wrap;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MultiRenderTarget.prototype._initTypes = function (count, types, samplingModes, options) {\n    for (var i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  MultiRenderTarget.prototype._rebuild = function (forceFullRebuild) {\n    if (forceFullRebuild === void 0) {\n      forceFullRebuild = false;\n    }\n\n    this.releaseInternalTextures();\n\n    this._createInternalTextures();\n\n    if (forceFullRebuild) {\n      this._createTextures();\n    }\n\n    for (var i = 0; i < this._internalTextures.length; i++) {\n      var texture = this._textures[i];\n      texture._texture = this._internalTextures[i];\n    } // Keeps references to frame buffer and stencil/depth buffer\n\n\n    this._texture = this._internalTextures[0];\n\n    if (this.samples !== 1) {\n      this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, this.samples);\n    }\n  };\n\n  MultiRenderTarget.prototype._createInternalTextures = function () {\n    this._internalTextures = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);\n  };\n\n  MultiRenderTarget.prototype._createTextures = function () {\n    this._textures = [];\n\n    for (var i = 0; i < this._internalTextures.length; i++) {\n      var texture = new Texture(null, this.getScene());\n      texture._texture = this._internalTextures[i];\n\n      this._textures.push(texture);\n    } // Keeps references to frame buffer and stencil/depth buffer\n\n\n    this._texture = this._internalTextures[0];\n  };\n  /**\r\n   * Replaces a texture within the MRT.\r\n   * @param texture The new texture to insert in the MRT\r\n   * @param index The index of the texture to replace\r\n   */\n\n\n  MultiRenderTarget.prototype.replaceTexture = function (texture, index) {\n    if (texture._texture) {\n      this._textures[index] = texture;\n      this._internalTextures[index] = texture._texture;\n    }\n  };\n\n  Object.defineProperty(MultiRenderTarget.prototype, \"samples\", {\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\n    get: function () {\n      return this._samples;\n    },\n    set: function (value) {\n      if (this._samples === value) {\n        return;\n      }\n\n      this._samples = this._getEngine().updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resize all the textures in the multi render target.\r\n   * Be careful as it will recreate all the data in the new texture.\r\n   * @param size Define the new size\r\n   */\n\n  MultiRenderTarget.prototype.resize = function (size) {\n    this._size = size;\n\n    this._rebuild();\n  };\n  /**\r\n   * Changes the number of render targets in this MRT\r\n   * Be careful as it will recreate all the data in the new texture.\r\n   * @param count new texture count\r\n   * @param options Specifies texture types and sampling modes for new textures\r\n   */\n\n\n  MultiRenderTarget.prototype.updateCount = function (count, options) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    var types = [];\n    var samplingModes = [];\n\n    this._initTypes(count, types, samplingModes, options);\n\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n\n    this._rebuild(true);\n  };\n\n  MultiRenderTarget.prototype.unbindFrameBuffer = function (engine, faceIndex) {\n    var _this = this;\n\n    engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function () {\n      _this.onAfterRenderObservable.notifyObservers(faceIndex);\n    });\n  };\n  /**\r\n   * Dispose the render targets and their associated resources\r\n   */\n\n\n  MultiRenderTarget.prototype.dispose = function () {\n    this.releaseInternalTextures();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Release all the underlying texture used as draw buffers.\r\n   */\n\n\n  MultiRenderTarget.prototype.releaseInternalTextures = function () {\n    if (!this._internalTextures) {\n      return;\n    }\n\n    for (var i = this._internalTextures.length - 1; i >= 0; i--) {\n      if (this._internalTextures[i] !== undefined) {\n        this._internalTextures[i].dispose();\n\n        this._internalTextures.splice(i, 1);\n      }\n    }\n  };\n\n  return MultiRenderTarget;\n}(RenderTargetTexture);\n\nexport { MultiRenderTarget };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/multiRenderTarget.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n\r\n    private _internalTextures: InternalTexture[];\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._getEngine()!.webGLVersion > 1 || this._getEngine()!.getCaps().drawBuffersExtension;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     */\r\n    constructor(name: string, size: any, count: number, scene: Scene, options?: IMultiRenderTargetOptions) {\r\n        var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        var types: number[] = [];\r\n        var samplingModes: number[] = [];\r\n        this._initTypes(count, types, samplingModes, options);\r\n\r\n        var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._size = size;\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            types: types,\r\n            textureCount: count\r\n        };\r\n\r\n        this._count = count;\r\n\r\n        this._createInternalTextures();\r\n        this._createTextures();\r\n    }\r\n\r\n    private _initTypes(count: number, types: number[], samplingModes: number[], options?: IMultiRenderTargetOptions) {\r\n        for (var i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : 0);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(forceFullRebuild: boolean = false): void {\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._createTextures();\r\n        }\r\n\r\n        for (var i = 0; i < this._internalTextures.length; i++) {\r\n            var texture = this._textures[i];\r\n            texture._texture = this._internalTextures[i];\r\n        }\r\n\r\n        // Keeps references to frame buffer and stencil/depth buffer\r\n        this._texture = this._internalTextures[0];\r\n\r\n        if (this.samples !== 1) {\r\n            this._getEngine()!.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, this.samples);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._internalTextures = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);\r\n    }\r\n\r\n    private _createTextures(): void {\r\n        this._textures = [];\r\n        for (var i = 0; i < this._internalTextures.length; i++) {\r\n            var texture = new Texture(null, this.getScene());\r\n            texture._texture = this._internalTextures[i];\r\n            this._textures.push(texture);\r\n        }\r\n\r\n        // Keeps references to frame buffer and stencil/depth buffer\r\n        this._texture = this._internalTextures[0];\r\n    }\r\n\r\n    /**\r\n     * Replaces a texture within the MRT.\r\n     * @param texture The new texture to insert in the MRT\r\n     * @param index The index of the texture to replace\r\n     */\r\n    public replaceTexture(texture: Texture, index: number) {\r\n        if (texture._texture) {\r\n            this._textures[index] = texture;\r\n            this._internalTextures[index] = texture._texture;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._samples === value) {\r\n            return;\r\n        }\r\n\r\n        this._samples = this._getEngine()!.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._size = size;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n\r\n        this._initTypes(count, types, samplingModes, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._rebuild(true);\r\n    }\r\n\r\n    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.releaseInternalTextures();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        if (!this._internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (var i = this._internalTextures.length - 1; i >= 0; i--) {\r\n            if (this._internalTextures[i] !== undefined) {\r\n                this._internalTextures[i].dispose();\r\n                this._internalTextures.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}