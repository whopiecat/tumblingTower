{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/how_to/dynamictexture\r\n */\n\nvar DynamicTexture =\n/** @class */\nfunction (_super) {\n  __extends(DynamicTexture, _super);\n  /**\r\n   * Creates a DynamicTexture\r\n   * @param name defines the name of the texture\r\n   * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n   * @param scene defines the scene where you want the texture\r\n   * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n   */\n\n\n  function DynamicTexture(name, options, scene, generateMipMaps, samplingMode, format, invertY) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format) || this;\n\n    _this.name = name;\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    _this._generateMipMaps = generateMipMaps;\n\n    var engine = _this._getEngine();\n\n    if (!engine) {\n      return _this;\n    }\n\n    if (options.getContext) {\n      _this._canvas = options;\n      _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n    } else {\n      _this._canvas = CanvasGenerator.CreateCanvas(1, 1);\n\n      if (options.width || options.width === 0) {\n        _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n      } else {\n        _this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n      }\n    }\n\n    var textureSize = _this.getSize();\n\n    _this._canvas.width = textureSize.width;\n    _this._canvas.height = textureSize.height;\n    _this._context = _this._canvas.getContext(\"2d\");\n    return _this;\n  }\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"DynamicTexture\"\r\n   */\n\n\n  DynamicTexture.prototype.getClassName = function () {\n    return \"DynamicTexture\";\n  };\n\n  Object.defineProperty(DynamicTexture.prototype, \"canRescale\", {\n    /**\r\n     * Gets the current state of canRescale\r\n     */\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DynamicTexture.prototype._recreate = function (textureSize) {\n    this._canvas.width = textureSize.width;\n    this._canvas.height = textureSize.height;\n    this.releaseInternalTexture();\n    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n  };\n  /**\r\n   * Scales the texture\r\n   * @param ratio the scale factor to apply to both width and height\r\n   */\n\n\n  DynamicTexture.prototype.scale = function (ratio) {\n    var textureSize = this.getSize();\n    textureSize.width *= ratio;\n    textureSize.height *= ratio;\n\n    this._recreate(textureSize);\n  };\n  /**\r\n   * Resizes the texture\r\n   * @param width the new width\r\n   * @param height the new height\r\n   */\n\n\n  DynamicTexture.prototype.scaleTo = function (width, height) {\n    var textureSize = this.getSize();\n    textureSize.width = width;\n    textureSize.height = height;\n\n    this._recreate(textureSize);\n  };\n  /**\r\n   * Gets the context of the canvas used by the texture\r\n   * @returns the canvas context of the dynamic texture\r\n   */\n\n\n  DynamicTexture.prototype.getContext = function () {\n    return this._context;\n  };\n  /**\r\n   * Clears the texture\r\n   */\n\n\n  DynamicTexture.prototype.clear = function () {\n    var size = this.getSize();\n\n    this._context.fillRect(0, 0, size.width, size.height);\n  };\n  /**\r\n   * Updates the texture\r\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n   */\n\n\n  DynamicTexture.prototype.update = function (invertY, premulAlpha) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n\n    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined);\n  };\n  /**\r\n   * Draws text onto the texture\r\n   * @param text defines the text to be drawn\r\n   * @param x defines the placement of the text from the left\r\n   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n   * @param font defines the font to be used with font-style, font-size, font-name\r\n   * @param color defines the color used for the text\r\n   * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n   * @param update defines whether texture is immediately update (default is true)\r\n   */\n\n\n  DynamicTexture.prototype.drawText = function (text, x, y, font, color, clearColor, invertY, update) {\n    if (update === void 0) {\n      update = true;\n    }\n\n    var size = this.getSize();\n\n    if (clearColor) {\n      this._context.fillStyle = clearColor;\n\n      this._context.fillRect(0, 0, size.width, size.height);\n    }\n\n    this._context.font = font;\n\n    if (x === null || x === undefined) {\n      var textSize = this._context.measureText(text);\n\n      x = (size.width - textSize.width) / 2;\n    }\n\n    if (y === null || y === undefined) {\n      var fontSize = parseInt(font.replace(/\\D/g, ''));\n      y = size.height / 2 + fontSize / 3.65;\n    }\n\n    this._context.fillStyle = color || \"\";\n\n    this._context.fillText(text, x, y);\n\n    if (update) {\n      this.update(invertY);\n    }\n  };\n  /**\r\n   * Clones the texture\r\n   * @returns the clone of the texture.\r\n   */\n\n\n  DynamicTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var textureSize = this.getSize();\n    var newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // Dynamic Texture\n\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    return newTexture;\n  };\n  /**\r\n   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n   * @returns a serialized dynamic texture object\r\n   */\n\n\n  DynamicTexture.prototype.serialize = function () {\n    var scene = this.getScene();\n\n    if (scene && !scene.isReady()) {\n      Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this._IsCanvasElement(this._canvas)) {\n      serializationObject.base64String = this._canvas.toDataURL();\n    }\n\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    return serializationObject;\n  };\n\n  DynamicTexture.prototype._IsCanvasElement = function (canvas) {\n    return canvas.toDataURL !== undefined;\n  };\n  /** @hidden */\n\n\n  DynamicTexture.prototype._rebuild = function () {\n    this.update();\n  };\n\n  return DynamicTexture;\n}(Texture);\n\nexport { DynamicTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/dynamicTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/how_to/dynamictexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    private _context: CanvasRenderingContext2D;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(name: string, options: any, scene: Nullable<Scene> = null, generateMipMaps: boolean, samplingMode: number = 3, format: number = 5, invertY?: boolean) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = CanvasGenerator.CreateCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        var textureSize = this.getSize();\r\n\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n        this._context = <CanvasRenderingContext2D>this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        var textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        var textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): CanvasRenderingContext2D {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        var size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false): void {\r\n        this._getEngine()!.updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined);\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(text: string, x: number | null | undefined, y: number | null | undefined, font: string, color: string | null, clearColor: string, invertY?: boolean, update = true) {\r\n        var size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            var textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            var fontSize = parseInt((font.replace(/\\D/g, '')));\r\n            y = (size.height / 2) + (fontSize / 3.65);\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        var textureSize = this.getSize();\r\n        var newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (this._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = (this._canvas as HTMLCanvasElement).toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}