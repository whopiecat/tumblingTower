{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Matrix, Vector2 } from \"../Maths/math.vector\";\nimport { PostProcess } from \"./postProcess\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\nimport \"../Animations/animatable\";\nimport '../Rendering/geometryBufferRendererSceneComponent';\nimport \"../Shaders/motionBlur.fragment\";\nimport { serialize, SerializationHelper } from '../Misc/decorators';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\n\nvar MotionBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(MotionBlurPostProcess, _super);\n  /**\r\n   * Creates a new instance MotionBlurPostProcess\r\n   * @param name The name of the effect.\r\n   * @param scene The scene containing the objects to blur according to their velocity.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass.\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n   */\n\n\n  function MotionBlurPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = true;\n    }\n\n    var _this = _super.call(this, name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\"], [\"velocitySampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation) || this;\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\n\n\n    _this.motionStrength = 1;\n    _this._motionBlurSamples = 32;\n    _this._isObjectBased = true;\n    _this._forceGeometryBuffer = false;\n    _this._geometryBufferRenderer = null;\n    _this._prePassRenderer = null;\n    _this._invViewProjection = null;\n    _this._previousViewProjection = null;\n    _this._forceGeometryBuffer = forceGeometryBuffer; // Set up assets\n\n    if (_this._forceGeometryBuffer) {\n      _this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n\n      if (_this._geometryBufferRenderer) {\n        _this._geometryBufferRenderer.enableVelocity = true;\n      }\n    } else {\n      _this._prePassRenderer = scene.enablePrePassRenderer();\n\n      if (_this._prePassRenderer) {\n        _this._prePassRenderer.markAsDirty();\n\n        _this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n\n    _this._applyMode();\n\n    return _this;\n  }\n\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"motionBlurSamples\", {\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\n    get: function () {\n      return this._motionBlurSamples;\n    },\n\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\n    set: function (samples) {\n      this._motionBlurSamples = samples;\n\n      this._updateEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MotionBlurPostProcess.prototype, \"isObjectBased\", {\n    /**\r\n     * Gets wether or not the motion blur post-process is in object based mode.\r\n     */\n    get: function () {\n      return this._isObjectBased;\n    },\n\n    /**\r\n     * Sets wether or not the motion blur post-process is in object based mode.\r\n     */\n    set: function (value) {\n      if (this._isObjectBased === value) {\n        return;\n      }\n\n      this._isObjectBased = value;\n\n      this._applyMode();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"MotionBlurPostProcess\" string\r\n   */\n\n  MotionBlurPostProcess.prototype.getClassName = function () {\n    return \"MotionBlurPostProcess\";\n  };\n  /**\r\n   * Excludes the given skinned mesh from computing bones velocities.\r\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.excludeSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      list.push(skinnedMesh);\n    }\n  };\n  /**\r\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.removeExcludedSkinnedMesh = function (skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      var list = void 0;\n\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n\n      var index = list.indexOf(skinnedMesh);\n\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  };\n  /**\r\n   * Disposes the post process.\r\n   * @param camera The camera to dispose the post process on.\r\n   */\n\n\n  MotionBlurPostProcess.prototype.dispose = function (camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\r\n   * Called on the mode changed (object based or screen based).\r\n   */\n\n\n  MotionBlurPostProcess.prototype._applyMode = function () {\n    var _this = this;\n\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n\n    this._updateEffect();\n\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyObjectBased(effect);\n      };\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = Matrix.Identity();\n\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n\n      this.onApply = function (effect) {\n        return _this._onApplyScreenBased(effect);\n      };\n    }\n  };\n  /**\r\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyObjectBased = function (effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      var velocityIndex = this._prePassRenderer.getIndex(2);\n\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.prePassRT.textures[velocityIndex]);\n    }\n  };\n  /**\r\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n   */\n\n\n  MotionBlurPostProcess.prototype._onApplyScreenBased = function (effect) {\n    var viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());\n\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection = viewProjection;\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n\n    if (this._geometryBufferRenderer) {\n      var depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE);\n\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      var depthIndex = this._prePassRenderer.getIndex(5);\n\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.prePassRT.textures[depthIndex]);\n    }\n  };\n  /**\r\n   * Called on the effect must be updated (changed mode, samples count, etc.).\r\n   */\n\n\n  MotionBlurPostProcess.prototype._updateEffect = function () {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      var defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  };\n  /** @hidden */\n\n\n  MotionBlurPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n\n  __decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\n\n  return MotionBlurPostProcess;\n}(PostProcess);\n\nexport { MotionBlurPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.MotionBlurPostProcess\"] = MotionBlurPostProcess;","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/motionBlurPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PostProcess, PostProcessOptions } from \"./postProcess\";\r\n\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport '../Rendering/geometryBufferRendererSceneComponent';\r\nimport \"../Shaders/motionBlur.fragment\";\r\nimport { serialize, SerializationHelper } from '../Misc/decorators';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n        this._updateEffect();\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n\r\n    /**\r\n     * Gets wether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets wether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this._isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _isObjectBased: boolean = true;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private _geometryBufferRenderer: Nullable<GeometryBufferRenderer> = null;\r\n    private _prePassRenderer: Nullable<PrePassRenderer> = null;\r\n\r\n    private _invViewProjection: Nullable<Matrix> = null;\r\n    private _previousViewProjection: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType: number = 0, blockCompilation = false, forceGeometryBuffer = true) {\r\n        super(name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\"], [\"velocitySampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation);\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = true;\r\n            }\r\n        } else {\r\n            this._prePassRenderer = scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode(): void {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return this.updateEffect();\r\n        }\r\n\r\n        this._updateEffect();\r\n\r\n        this._invViewProjection = null;\r\n        this._previousViewProjection = null;\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = 2;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            this._invViewProjection = Matrix.Identity();\r\n            this._previousViewProjection = Matrix.Identity();\r\n\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = 5;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(2);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.prePassRT.textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        const viewProjection = this._scene.getProjectionMatrix().multiply(this._scene.getViewMatrix());\r\n\r\n        viewProjection.invertToRef(this._invViewProjection!);\r\n        effect.setMatrix(\"inverseViewProjection\", this._invViewProjection!);\r\n\r\n        effect.setMatrix(\"prevViewProjection\", this._previousViewProjection!);\r\n        this._previousViewProjection = viewProjection;\r\n\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(5);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.prePassRT.textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect must be updated (changed mode, samples count, etc.).\r\n     */\r\n    private _updateEffect(): void {\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            const defines: string[] = [\r\n                \"#define GEOMETRY_SUPPORTED\",\r\n                \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1),\r\n                this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"\r\n            ];\r\n\r\n            this.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(() => {\r\n            return new MotionBlurPostProcess(\r\n                parsedPostProcess.name, scene, parsedPostProcess.options,\r\n                targetCamera, parsedPostProcess.renderTargetSamplingMode,\r\n                scene.getEngine(), parsedPostProcess.reusable,\r\n                parsedPostProcess.textureType, false);\r\n        }, parsedPostProcess, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.MotionBlurPostProcess\"] = MotionBlurPostProcess;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}