{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color3, TmpColors } from \"../Maths/math.color\";\nimport { Node } from \"../node\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\n\nvar Light =\n/** @class */\nfunction (_super) {\n  __extends(Light, _super);\n  /**\r\n   * Creates a Light object in the scene.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The firendly name of the light\r\n   * @param scene The scene the light belongs too\r\n   */\n\n\n  function Light(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\n\n\n    _this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is note affecting PBR materials.\r\n     */\n\n    _this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\r\n     * Defines the falloff type for this light. This lets overrriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\n\n    _this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\n\n    _this.intensity = 1.0;\n    _this._range = Number.MAX_VALUE;\n    _this._inverseSquaredRange = 0;\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\n\n    _this._photometricScale = 1.0;\n    _this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    _this._radius = 0.00001;\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\n\n    _this.renderPriority = 0;\n    _this._shadowEnabled = true;\n    _this._excludeWithLayerMask = 0;\n    _this._includeOnlyWithLayerMask = 0;\n    _this._lightmapMode = 0;\n    /**\r\n     * @hidden Internal use only.\r\n     */\n\n    _this._excludedMeshesIds = new Array();\n    /**\r\n     * @hidden Internal use only.\r\n     */\n\n    _this._includedOnlyMeshesIds = new Array();\n    /** @hidden */\n\n    _this._isLight = true;\n\n    _this.getScene().addLight(_this);\n\n    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine());\n\n    _this._buildUniformLayout();\n\n    _this.includedOnlyMeshes = new Array();\n    _this.excludedMeshes = new Array();\n\n    _this._resyncMeshes();\n\n    return _this;\n  }\n\n  Object.defineProperty(Light.prototype, \"range\", {\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\n    get: function () {\n      return this._range;\n    },\n\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\n    set: function (value) {\n      this._range = value;\n      this._inverseSquaredRange = 1.0 / (this.range * this.range);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"intensityMode\", {\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\n    get: function () {\n      return this._intensityMode;\n    },\n\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\n    set: function (value) {\n      this._intensityMode = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"radius\", {\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\n    get: function () {\n      return this._radius;\n    },\n\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\n    set: function (value) {\n      this._radius = value;\n\n      this._computePhotometricScale();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"shadowEnabled\", {\n    /**\r\n     * Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\n    get: function () {\n      return this._shadowEnabled;\n    },\n\n    /**\r\n     * Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\n    set: function (value) {\n      if (this._shadowEnabled === value) {\n        return;\n      }\n\n      this._shadowEnabled = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includedOnlyMeshes\", {\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\n    get: function () {\n      return this._includedOnlyMeshes;\n    },\n\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\n    set: function (value) {\n      this._includedOnlyMeshes = value;\n\n      this._hookArrayForIncludedOnly(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludedMeshes\", {\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\n    get: function () {\n      return this._excludedMeshes;\n    },\n\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\n    set: function (value) {\n      this._excludedMeshes = value;\n\n      this._hookArrayForExcluded(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"excludeWithLayerMask\", {\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\n    get: function () {\n      return this._excludeWithLayerMask;\n    },\n\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\n    set: function (value) {\n      this._excludeWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"includeOnlyWithLayerMask\", {\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\n    get: function () {\n      return this._includeOnlyWithLayerMask;\n    },\n\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\n    set: function (value) {\n      this._includeOnlyWithLayerMask = value;\n\n      this._resyncMeshes();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Light.prototype, \"lightmapMode\", {\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\n    get: function () {\n      return this._lightmapMode;\n    },\n\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\n    set: function (value) {\n      if (this._lightmapMode === value) {\n        return;\n      }\n\n      this._lightmapMode = value;\n\n      this._markMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the passed Effect \"effect\" with the Light textures.\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The light\r\n   */\n\n  Light.prototype.transferTexturesToEffect = function (effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param lightIndex Light index\r\n   * @param scene The scene where the light belongs to\r\n   * @param effect The effect we are binding the data to\r\n   * @param useSpecular Defines if specular is supported\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  Light.prototype._bindLight = function (lightIndex, scene, effect, useSpecular, rebuildInParallel) {\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    var iAsString = lightIndex.toString();\n    var needUpdate = false;\n\n    if (rebuildInParallel && this._uniformBuffer._alreadyBound) {\n      return;\n    }\n\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n\n    if (this._renderId !== scene.getRenderId() || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      var scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n\n      needUpdate = true;\n    } // Textures might still need to be rebound.\n\n\n    this.transferTexturesToEffect(effect, iAsString); // Shadows\n\n    if (scene.shadowsEnabled && this.shadowEnabled) {\n      var shadowGenerator = this.getShadowGenerator();\n\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    }\n  };\n  /**\r\n   * Returns the string \"Light\".\r\n   * @returns the class name\r\n   */\n\n\n  Light.prototype.getClassName = function () {\n    return \"Light\";\n  };\n  /**\r\n   * Converts the light information to a readable string for debug purpose.\r\n   * @param fullDetails Supports for multiple levels of logging within scene loading\r\n   * @returns the human readable light info\r\n   */\n\n\n  Light.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n\n    if (this.animations) {\n      for (var i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n\n    if (fullDetails) {}\n\n    return ret;\n  };\n  /** @hidden */\n\n\n  Light.prototype._syncParentEnabledState = function () {\n    _super.prototype._syncParentEnabledState.call(this);\n\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  };\n  /**\r\n   * Set the enabled state of this node.\r\n   * @param value - the new enabled state\r\n   */\n\n\n  Light.prototype.setEnabled = function (value) {\n    _super.prototype.setEnabled.call(this, value);\n\n    this._resyncMeshes();\n  };\n  /**\r\n   * Returns the Light associated shadow generator if any.\r\n   * @return the associated shadow generator.\r\n   */\n\n\n  Light.prototype.getShadowGenerator = function () {\n    return this._shadowGenerator;\n  };\n  /**\r\n   * Returns a Vector3, the absolute light position in the World.\r\n   * @returns the world space position of the light\r\n   */\n\n\n  Light.prototype.getAbsolutePosition = function () {\n    return Vector3.Zero();\n  };\n  /**\r\n   * Specifies if the light will affect the passed mesh.\r\n   * @param mesh The mesh to test against the light\r\n   * @return true the mesh is affected otherwise, false.\r\n   */\n\n\n  Light.prototype.canAffectMesh = function (mesh) {\n    if (!mesh) {\n      return true;\n    }\n\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Sort function to order lights for rendering.\r\n   * @param a First Light object to compare to second.\r\n   * @param b Second Light object to compare first.\r\n   * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\r\n   */\n\n\n  Light.CompareLightsPriority = function (a, b) {\n    //shadow-casting lights have priority over non-shadow-casting lights\n    //the renderPrioirty is a secondary sort criterion\n    if (a.shadowEnabled !== b.shadowEnabled) {\n      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n    }\n\n    return b.renderPriority - a.renderPriority;\n  };\n  /**\r\n   * Releases resources associated with this node.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  Light.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    if (this._shadowGenerator) {\n      this._shadowGenerator.dispose();\n\n      this._shadowGenerator = null;\n    } // Animations\n\n\n    this.getScene().stopAnimation(this); // Remove from meshes\n\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._removeLightSource(this, true);\n    }\n\n    this._uniformBuffer.dispose(); // Remove from scene\n\n\n    this.getScene().removeLight(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Returns the light type ID (integer).\r\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  Light.prototype.getTypeID = function () {\n    return 0;\n  };\n  /**\r\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n   * @returns the scaled intensity in intensity mode unit\r\n   */\n\n\n  Light.prototype.getScaledIntensity = function () {\n    return this._photometricScale * this.intensity;\n  };\n  /**\r\n   * Returns a new Light object, named \"name\", from the current one.\r\n   * @param name The name of the cloned light\r\n   * @param newParent The parent of this light, if it has one\r\n   * @returns the new created light\r\n   */\n\n\n  Light.prototype.clone = function (name, newParent) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n\n    if (!constructor) {\n      return null;\n    }\n\n    var clonedLight = SerializationHelper.Clone(constructor, this);\n\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n\n    clonedLight.setEnabled(this.isEnabled());\n    return clonedLight;\n  };\n  /**\r\n   * Serializes the current light into a Serialization object.\r\n   * @returns the serialized object.\r\n   */\n\n\n  Light.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this); // Type\n\n    serializationObject.type = this.getTypeID(); // Parent\n\n    if (this.parent) {\n      serializationObject.parentId = this.parent.id;\n    } // Inclusion / exclusions\n\n\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(function (mesh) {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(function (mesh) {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    return serializationObject;\n  };\n  /**\r\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n   * This new light is named \"name\" and added to the passed scene.\r\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n   * @param name The friendly name of the light\r\n   * @param scene The scene the new light will belong to\r\n   * @returns the constructor function\r\n   */\n\n\n  Light.GetConstructorFromName = function (type, name, scene) {\n    var constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n\n    if (constructorFunc) {\n      return constructorFunc;\n    } // Default to no light for none present once.\n\n\n    return null;\n  };\n  /**\r\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n   * @param parsedLight The JSON representation of the light\r\n   * @param scene The scene to create the parsed light in\r\n   * @returns the created light after parsing\r\n   */\n\n\n  Light.Parse = function (parsedLight, scene) {\n    var constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n\n    if (!constructor) {\n      return null;\n    }\n\n    var light = SerializationHelper.Parse(constructor, parsedLight, scene); // Inclusion / exclusions\n\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    } // Parent\n\n\n    if (parsedLight.parentId) {\n      light._waitingParentId = parsedLight.parentId;\n    } // Falloff\n\n\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    } // Lightmaps\n\n\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    } // Animations\n\n\n    if (parsedLight.animations) {\n      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        var parsedAnimation = parsedLight.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    }\n\n    return light;\n  };\n\n  Light.prototype._hookArrayForExcluded = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {\n        var item = items_1[_a];\n\n        item._resyncLightSource(_this);\n      }\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      for (var _i = 0, deleted_1 = deleted; _i < deleted_1.length; _i++) {\n        var item = deleted_1[_i];\n\n        item._resyncLightSource(_this);\n      }\n\n      return deleted;\n    };\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var item = array_1[_i];\n\n      item._resyncLightSource(this);\n    }\n  };\n\n  Light.prototype._hookArrayForIncludedOnly = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._resyncMeshes();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._resyncMeshes();\n\n      return deleted;\n    };\n\n    this._resyncMeshes();\n  };\n\n  Light.prototype._resyncMeshes = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._resyncLightSource(this);\n    }\n  };\n  /**\r\n   * Forces the meshes to update their light related information in their rendering used effects\r\n   * @hidden Internal Use Only\r\n   */\n\n\n  Light.prototype._markMeshesAsLightDirty = function () {\n    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  };\n  /**\r\n   * Recomputes the cached photometric scale if needed.\r\n   */\n\n\n  Light.prototype._computePhotometricScale = function () {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  };\n  /**\r\n   * Returns the Photometric Scale according to the light type and intensity mode.\r\n   */\n\n\n  Light.prototype._getPhotometricScale = function () {\n    var photometricScale = 0.0;\n    var lightTypeID = this.getTypeID(); //get photometric mode\n\n    var photometricMode = this.intensityMode;\n\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    } //compute photometric scale\n\n\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n\n          case Light.INTENSITYMODE_LUMINANCE:\n            // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n            // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n            var apexAngleRadians = this.radius; // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n\n            apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n            var solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n            photometricScale = solidAngle;\n            break;\n        }\n\n        break;\n\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemisperic light.\n        photometricScale = 1.0;\n        break;\n    }\n\n    return photometricScale;\n  };\n  /**\r\n   * Reorder the light in the scene according to their defined priority.\r\n   * @hidden Internal Use Only\r\n   */\n\n\n  Light.prototype._reorderLightsInScene = function () {\n    var scene = this.getScene();\n\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n\n    this.getScene().sortLightsByPriority();\n  };\n  /**\r\n   * Falloff Default: light is falling off following the material specification:\r\n   * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n   */\n\n\n  Light.FALLOFF_DEFAULT = 0;\n  /**\r\n   * Falloff Physical: light is falling off following the inverse squared distance law.\r\n   */\n\n  Light.FALLOFF_PHYSICAL = 1;\n  /**\r\n   * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n   * to enhance interoperability with other engines.\r\n   */\n\n  Light.FALLOFF_GLTF = 2;\n  /**\r\n   * Falloff Standard: light is falling off like in the standard material\r\n   * to enhance interoperability with other materials.\r\n   */\n\n  Light.FALLOFF_STANDARD = 3; //lightmapMode Consts\n\n  /**\r\n   * If every light affecting the material is in this lightmapMode,\r\n   * material.lightmapTexture adds or multiplies\r\n   * (depends on material.useLightmapAsShadowmap)\r\n   * after every other light calculations.\r\n   */\n\n  Light.LIGHTMAP_DEFAULT = 0;\n  /**\r\n   * material.lightmapTexture as only diffuse lighting from this light\r\n   * adds only specular lighting from this light\r\n   * adds dynamic shadows\r\n   */\n\n  Light.LIGHTMAP_SPECULAR = 1;\n  /**\r\n   * material.lightmapTexture as only lighting\r\n   * no light calculation from this light\r\n   * only adds dynamic shadows from this light\r\n   */\n\n  Light.LIGHTMAP_SHADOWSONLY = 2; // Intensity Mode Consts\n\n  /**\r\n   * Each light type uses the default quantity according to its type:\r\n   *      point/spot lights use luminous intensity\r\n   *      directional lights use illuminance\r\n   */\n\n  Light.INTENSITYMODE_AUTOMATIC = 0;\n  /**\r\n   * lumen (lm)\r\n   */\n\n  Light.INTENSITYMODE_LUMINOUSPOWER = 1;\n  /**\r\n   * candela (lm/sr)\r\n   */\n\n  Light.INTENSITYMODE_LUMINOUSINTENSITY = 2;\n  /**\r\n   * lux (lm/m^2)\r\n   */\n\n  Light.INTENSITYMODE_ILLUMINANCE = 3;\n  /**\r\n   * nit (cd/m^2)\r\n   */\n\n  Light.INTENSITYMODE_LUMINANCE = 4; // Light types ids const.\n\n  /**\r\n   * Light type const id of the point light.\r\n   */\n\n  Light.LIGHTTYPEID_POINTLIGHT = 0;\n  /**\r\n   * Light type const id of the directional light.\r\n   */\n\n  Light.LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n  /**\r\n   * Light type const id of the spot light.\r\n   */\n\n  Light.LIGHTTYPEID_SPOTLIGHT = 2;\n  /**\r\n   * Light type const id of the hemispheric light.\r\n   */\n\n  Light.LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n\n  __decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n\n  __decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"intensity\", void 0);\n\n  __decorate([serialize()], Light.prototype, \"range\", null);\n\n  __decorate([serialize()], Light.prototype, \"intensityMode\", null);\n\n  __decorate([serialize()], Light.prototype, \"radius\", null);\n\n  __decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n\n  __decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n\n  __decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n\n  __decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n\n  __decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n\n  __decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);\n\n  return Light;\n}(Node);\n\nexport { Light };","map":{"version":3,"sources":["../../../sourceES6/core/Lights/light.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node {\r\n\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = 0;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = 1;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = 2;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = 3;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = 0;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = 1;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = 2;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = 0;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = 1;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = 2;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = 3;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = 4;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = 0;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = 1;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = 2;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = 3;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is note affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overrriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generator associted to the light.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _shadowGenerator: Nullable<IShadowGenerator>;\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light unifom buffer.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _renderId: number;\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The firendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine());\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel = false): void {\r\n        let iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        if (rebuildInParallel && this._uniformBuffer._alreadyBound) {\r\n            return;\r\n        }\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n\r\n            let scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled) {\r\n            var shadowGenerator = this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + ([\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"])[this.getTypeID()];\r\n        if (this.animations) {\r\n            for (var i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        if (fullDetails) {\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @return the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return this._shadowGenerator;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @return true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sort function to order lights for rendering.\r\n     * @param a First Light object to compare to second.\r\n     * @param b Second Light object to compare first.\r\n     * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\r\n     */\r\n    public static CompareLightsPriority(a: Light, b: Light): number {\r\n        //shadow-casting lights have priority over non-shadow-casting lights\r\n        //the renderPrioirty is a secondary sort criterion\r\n        if (a.shadowEnabled !== b.shadowEnabled) {\r\n            return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\r\n        }\r\n        return b.renderPriority - a.renderPriority;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.dispose();\r\n            this._shadowGenerator = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from meshes\r\n        for (var mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        let constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        let clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.id;\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        let constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        let constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        var light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                var parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            for (var item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (var item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (var item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (var mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (var mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        let lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        let solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemisperic light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        var scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}