{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from \"../Maths/math.color\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nNode.AddNodeConstructor(\"Light_Type_3\", function (name, scene) {\n  return function () {\n    return new HemisphericLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\n\nvar HemisphericLight =\n/** @class */\nfunction (_super) {\n  __extends(HemisphericLight, _super);\n  /**\r\n   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n   * The HemisphericLight can't cast shadows.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The friendly name of the light\r\n   * @param direction The direction of the light reflection\r\n   * @param scene The scene the light belongs to\r\n   */\n\n\n  function HemisphericLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\n\n\n    _this.groundColor = new Color3(0.0, 0.0, 0.0);\n    _this.direction = direction || Vector3.Up();\n    return _this;\n  }\n\n  HemisphericLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightGround\", 3);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\r\n   * Returns the string \"HemisphericLight\".\r\n   * @return The class name\r\n   */\n\n\n  HemisphericLight.prototype.getClassName = function () {\n    return \"HemisphericLight\";\n  };\n  /**\r\n   * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n   * Returns the updated direction.\r\n   * @param target The target the direction should point to\r\n   * @return The computed direction\r\n   */\n\n\n  HemisphericLight.prototype.setDirectionToTarget = function (target) {\n    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n    return this.direction;\n  };\n  /**\r\n   * Returns the shadow generator associated to the light.\r\n   * @returns Always null for hemispheric lights because it does not support shadows.\r\n   */\n\n\n  HemisphericLight.prototype.getShadowGenerator = function () {\n    return null;\n  };\n  /**\r\n   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The hemispheric light\r\n   */\n\n\n  HemisphericLight.prototype.transferToEffect = function (effect, lightIndex) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n\n    this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n\n    return this;\n  };\n\n  HemisphericLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    var normalizeDirection = Vector3.Normalize(this.direction);\n    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n    return this;\n  };\n  /**\r\n   * Computes the world matrix of the node\r\n   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n   * @param useWasUpdatedFlag defines a reserved property\r\n   * @returns the world matrix\r\n   */\n\n\n  HemisphericLight.prototype.computeWorldMatrix = function () {\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n\n    return this._worldMatrix;\n  };\n  /**\r\n   * Returns the integer 3.\r\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  HemisphericLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n  };\n  /**\r\n   * Prepares the list of defines specific to the light type.\r\n   * @param defines the list of defines\r\n   * @param lightIndex defines the index of the light for the effect\r\n   */\n\n\n  HemisphericLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"HEMILIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serializeAsColor3()], HemisphericLight.prototype, \"groundColor\", void 0);\n\n  __decorate([serializeAsVector3()], HemisphericLight.prototype, \"direction\", void 0);\n\n  return HemisphericLight;\n}(Light);\n\nexport { HemisphericLight };","map":{"version":3,"sources":["../../../sourceES6/core/Lights/hemisphericLight.ts"],"names":[],"mappings":"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","sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @return The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): HemisphericLight {\r\n        var normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\",\r\n            normalizeDirection.x,\r\n            normalizeDirection.y,\r\n            normalizeDirection.z,\r\n            0.0,\r\n            lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        var normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @param useWasUpdatedFlag defines a reserved property\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}