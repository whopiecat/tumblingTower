{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\r\n */\n\nvar WebXRSessionManager =\n/** @class */\nfunction () {\n  /**\r\n   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n   * @param scene The scene which the session should be created for\r\n   */\n  function WebXRSessionManager(\n  /** The scene which the session should be created for */\n  scene) {\n    this.scene = scene;\n    this._sessionEnded = false;\n    this.baseLayer = null;\n    /** WebXR timestamp updated every frame */\n\n    this.currentTimestamp = -1;\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\n\n    this.defaultHeightCompensation = 1.7;\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\n\n    this.onXRFrameObservable = new Observable();\n    /**\r\n     * Fires when the reference space changed\r\n     */\n\n    this.onXRReferenceSpaceChanged = new Observable();\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\n\n    this.onXRSessionEnded = new Observable();\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\n\n    this.onXRSessionInit = new Observable();\n  }\n\n  Object.defineProperty(WebXRSessionManager.prototype, \"referenceSpace\", {\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\n    get: function () {\n      return this._referenceSpace;\n    },\n\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\n    set: function (newReferenceSpace) {\n      this._referenceSpace = newReferenceSpace;\n      this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the session manager\r\n   */\n\n  WebXRSessionManager.prototype.dispose = function () {\n    // disposing without leaving XR? Exit XR first\n    if (!this._sessionEnded) {\n      this.exitXRAsync();\n    }\n\n    this.onXRFrameObservable.clear();\n    this.onXRSessionEnded.clear();\n    this.onXRReferenceSpaceChanged.clear();\n    this.onXRSessionInit.clear();\n  };\n  /**\r\n   * Stops the xrSession and restores the render loop\r\n   * @returns Promise which resolves after it exits XR\r\n   */\n\n\n  WebXRSessionManager.prototype.exitXRAsync = function () {\n    if (this.session && !this._sessionEnded) {\n      this._sessionEnded = true;\n      return this.session.end().catch(function (e) {\n        Logger.Warn(\"Could not end XR session.\");\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Gets the correct render target texture to be rendered this frame for this eye\r\n   * @param eye the eye for which to get the render target\r\n   * @returns the render target for the specified eye\r\n   */\n\n\n  WebXRSessionManager.prototype.getRenderTargetTextureForEye = function (eye) {\n    return this._rttProvider.getRenderTargetForEye(eye);\n  };\n  /**\r\n   * Creates a WebXRRenderTarget object for the XR session\r\n   * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web\r\n   * @param options optional options to provide when creating a new render target\r\n   * @returns a WebXR render target to which the session can render\r\n   */\n\n\n  WebXRSessionManager.prototype.getWebXRRenderTarget = function (options) {\n    var engine = this.scene.getEngine();\n\n    if (this._xrNavigator.xr.native) {\n      return this._xrNavigator.xr.getWebXRRenderTarget(engine);\n    } else {\n      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\n      options.canvasElement = engine.getRenderingCanvas() || undefined;\n      return new WebXRManagedOutputCanvas(this, options);\n    }\n  };\n  /**\r\n   * Initializes the manager\r\n   * After initialization enterXR can be called to start an XR session\r\n   * @returns Promise which resolves after it is initialized\r\n   */\n\n\n  WebXRSessionManager.prototype.initializeAsync = function () {\n    // Check if the browser supports webXR\n    this._xrNavigator = navigator;\n\n    if (!this._xrNavigator.xr) {\n      return Promise.reject(\"WebXR not available\");\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * Initializes an xr session\r\n   * @param xrSessionMode mode to initialize\r\n   * @param xrSessionInit defines optional and required values to pass to the session builder\r\n   * @returns a promise which will resolve once the session has been initialized\r\n   */\n\n\n  WebXRSessionManager.prototype.initializeSessionAsync = function (xrSessionMode, xrSessionInit) {\n    var _this = this;\n\n    if (xrSessionMode === void 0) {\n      xrSessionMode = \"immersive-vr\";\n    }\n\n    if (xrSessionInit === void 0) {\n      xrSessionInit = {};\n    }\n\n    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(function (session) {\n      _this.session = session;\n\n      _this.onXRSessionInit.notifyObservers(session);\n\n      _this._sessionEnded = false; // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\n\n      _this.session.addEventListener(\"end\", function () {\n        var engine = _this.scene.getEngine();\n\n        _this._sessionEnded = true; // Remove render target texture and notify frame observers\n\n        _this._rttProvider = null; // make sure dimensions object is restored\n\n        engine.framebufferDimensionsObject = null; // Restore frame buffer to avoid clear on xr framebuffer after session end\n\n        engine.restoreDefaultFramebuffer(); // Need to restart render loop as after the session is ended the last request for new frame will never call callback\n\n        engine.customAnimationFrameRequester = null;\n\n        _this.onXRSessionEnded.notifyObservers(null);\n\n        engine._renderLoop();\n      }, {\n        once: true\n      });\n\n      return _this.session;\n    });\n  };\n  /**\r\n   * Checks if a session would be supported for the creation options specified\r\n   * @param sessionMode session mode to check if supported eg. immersive-vr\r\n   * @returns A Promise that resolves to true if supported and false if not\r\n   */\n\n\n  WebXRSessionManager.prototype.isSessionSupportedAsync = function (sessionMode) {\n    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\n  };\n  /**\r\n   * Resets the reference space to the one started the session\r\n   */\n\n\n  WebXRSessionManager.prototype.resetReferenceSpace = function () {\n    this.referenceSpace = this.baseReferenceSpace;\n  };\n  /**\r\n   * Starts rendering to the xr layer\r\n   */\n\n\n  WebXRSessionManager.prototype.runXRRenderLoop = function () {\n    var _this = this;\n\n    var engine = this.scene.getEngine(); // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\n\n    engine.customAnimationFrameRequester = {\n      requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\n      renderFunction: function (timestamp, xrFrame) {\n        if (_this._sessionEnded) {\n          return;\n        } // Store the XR frame and timestamp in the session manager\n\n\n        _this.currentFrame = xrFrame;\n        _this.currentTimestamp = timestamp;\n\n        if (xrFrame) {\n          engine.framebufferDimensionsObject = _this.baseLayer;\n\n          _this.onXRFrameObservable.notifyObservers(xrFrame);\n\n          engine._renderLoop();\n\n          engine.framebufferDimensionsObject = null;\n        }\n      }\n    };\n\n    if (this._xrNavigator.xr.native) {\n      this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, this._createRenderTargetTexture.bind(this));\n    } else {\n      // Create render target texture from xr's webgl render target\n      var rtt_1 = this._createRenderTargetTexture(this.baseLayer.framebufferWidth, this.baseLayer.framebufferHeight, this.baseLayer.framebuffer);\n\n      this._rttProvider = {\n        getRenderTargetForEye: function () {\n          return rtt_1;\n        }\n      };\n      engine.framebufferDimensionsObject = this.baseLayer;\n    } // Stop window's animation frame and trigger sessions animation frame\n\n\n    if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\n      window.cancelAnimationFrame(engine._frameHandler);\n    }\n\n    engine._renderLoop();\n  };\n  /**\r\n   * Sets the reference space on the xr session\r\n   * @param referenceSpaceType space to set\r\n   * @returns a promise that will resolve once the reference space has been set\r\n   */\n\n\n  WebXRSessionManager.prototype.setReferenceSpaceTypeAsync = function (referenceSpaceType) {\n    var _this = this;\n\n    if (referenceSpaceType === void 0) {\n      referenceSpaceType = \"local-floor\";\n    }\n\n    return this.session.requestReferenceSpace(referenceSpaceType).then(function (referenceSpace) {\n      return referenceSpace;\n    }, function (rejectionReason) {\n      Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\n      Logger.Error(rejectionReason);\n      Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (referenceSpace) {\n        var heightCompensation = new XRRigidTransform({\n          x: 0,\n          y: -_this.defaultHeightCompensation,\n          z: 0\n        });\n        return referenceSpace.getOffsetReferenceSpace(heightCompensation);\n      }, function (rejectionReason) {\n        Logger.Error(rejectionReason);\n        throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\n      });\n    }).then(function (referenceSpace) {\n      // create viewer reference space before setting the first reference space\n      return _this.session.requestReferenceSpace(\"viewer\").then(function (viewerReferenceSpace) {\n        _this.viewerReferenceSpace = viewerReferenceSpace;\n        return referenceSpace;\n      });\n    }).then(function (referenceSpace) {\n      // initialize the base and offset (currently the same)\n      _this.referenceSpace = _this.baseReferenceSpace = referenceSpace;\n      return _this.referenceSpace;\n    });\n  };\n  /**\r\n   * Updates the render state of the session\r\n   * @param state state to set\r\n   * @returns a promise that resolves once the render state has been updated\r\n   */\n\n\n  WebXRSessionManager.prototype.updateRenderStateAsync = function (state) {\n    if (state.baseLayer) {\n      this.baseLayer = state.baseLayer;\n    }\n\n    return this.session.updateRenderState(state);\n  };\n  /**\r\n   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n   * @param sessionMode defines the session to test\r\n   * @returns a promise with boolean as final value\r\n   */\n\n\n  WebXRSessionManager.IsSessionSupportedAsync = function (sessionMode) {\n    if (!navigator.xr) {\n      return Promise.resolve(false);\n    } // When the specs are final, remove supportsSession!\n\n\n    var functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;\n\n    if (!functionToUse) {\n      return Promise.resolve(false);\n    } else {\n      return functionToUse.call(navigator.xr, sessionMode).then(function (result) {\n        var returnValue = typeof result === \"undefined\" ? true : result;\n        return Promise.resolve(returnValue);\n      }).catch(function (e) {\n        Logger.Warn(e);\n        return Promise.resolve(false);\n      });\n    }\n  };\n\n  WebXRSessionManager.prototype._createRenderTargetTexture = function (width, height, framebuffer) {\n    if (framebuffer === void 0) {\n      framebuffer = null;\n    } // Create internal texture\n\n\n    var internalTexture = new InternalTexture(this.scene.getEngine(), InternalTextureSource.Unknown, true);\n    internalTexture.width = width;\n    internalTexture.height = height;\n    internalTexture._framebuffer = framebuffer; // Create render target texture from the internal texture\n\n    var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", {\n      width: width,\n      height: height\n    }, this.scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n    renderTargetTexture._texture = internalTexture;\n    return renderTargetTexture;\n  };\n\n  return WebXRSessionManager;\n}();\n\nexport { WebXRSessionManager };","map":{"version":3,"sources":["../../../sourceES6/core/XR/webXRSessionManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { IDisposable, Scene } from \"../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\n\r\ninterface IRenderTargetProvider {\r\n    getRenderTargetForEye(eye: XREye): RenderTargetTexture;\r\n}\r\n\r\n/**\r\n * Manages an XRSession to work with Babylon's engine\r\n * @see https://doc.babylonjs.com/how_to/webxr_session_manager\r\n */\r\nexport class WebXRSessionManager implements IDisposable {\r\n    private _referenceSpace: XRReferenceSpace;\r\n    private _rttProvider: Nullable<IRenderTargetProvider>;\r\n    private _sessionEnded: boolean = false;\r\n    private _xrNavigator: any;\r\n    private baseLayer: Nullable<XRWebGLLayer> = null;\r\n\r\n    /**\r\n     * The base reference space from which the session started. good if you want to reset your\r\n     * reference space\r\n     */\r\n    public baseReferenceSpace: XRReferenceSpace;\r\n    /**\r\n     * Current XR frame\r\n     */\r\n    public currentFrame: Nullable<XRFrame>;\r\n    /** WebXR timestamp updated every frame */\r\n    public currentTimestamp: number = -1;\r\n    /**\r\n     * Used just in case of a failure to initialize an immersive session.\r\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\r\n     */\r\n    public defaultHeightCompensation = 1.7;\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<XRFrame> = new Observable<XRFrame>();\r\n    /**\r\n     * Fires when the reference space changed\r\n     */\r\n    public onXRReferenceSpaceChanged: Observable<XRReferenceSpace> = new Observable();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionInit: Observable<XRSession> = new Observable<XRSession>();\r\n    /**\r\n     * Underlying xr session\r\n     */\r\n    public session: XRSession;\r\n    /**\r\n     * The viewer (head position) reference space. This can be used to get the XR world coordinates\r\n     * or get the offset the player is currently at.\r\n     */\r\n    public viewerReferenceSpace: XRReferenceSpace;\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(\r\n        /** The scene which the session should be created for */\r\n        public scene: Scene\r\n    ) {}\r\n\r\n    /**\r\n     * The current reference space used in this session. This reference space can constantly change!\r\n     * It is mainly used to offset the camera's position.\r\n     */\r\n    public get referenceSpace(): XRReferenceSpace {\r\n        return this._referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Set a new reference space and triggers the observable\r\n     */\r\n    public set referenceSpace(newReferenceSpace: XRReferenceSpace) {\r\n        this._referenceSpace = newReferenceSpace;\r\n        this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     */\r\n    public dispose() {\r\n        // disposing without leaving XR? Exit XR first\r\n        if (!this._sessionEnded) {\r\n            this.exitXRAsync();\r\n        }\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n        this.onXRReferenceSpaceChanged.clear();\r\n        this.onXRSessionInit.clear();\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the render loop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        if (this.session && !this._sessionEnded) {\r\n            this._sessionEnded = true;\r\n            return this.session.end().catch((e) => {\r\n                Logger.Warn(\"Could not end XR session.\");\r\n            });\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Gets the correct render target texture to be rendered this frame for this eye\r\n     * @param eye the eye for which to get the render target\r\n     * @returns the render target for the specified eye\r\n     */\r\n    public getRenderTargetTextureForEye(eye: XREye): RenderTargetTexture {\r\n        return this._rttProvider!.getRenderTargetForEye(eye);\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRRenderTarget object for the XR session\r\n     * @param onStateChangedObservable optional, mechanism for enabling/disabling XR rendering canvas, used only on Web\r\n     * @param options optional options to provide when creating a new render target\r\n     * @returns a WebXR render target to which the session can render\r\n     */\r\n    public getWebXRRenderTarget(options?: WebXRManagedOutputCanvasOptions): WebXRRenderTarget {\r\n        const engine = this.scene.getEngine();\r\n        if (this._xrNavigator.xr.native) {\r\n            return this._xrNavigator.xr.getWebXRRenderTarget(engine);\r\n        } else {\r\n            options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\r\n            options.canvasElement = engine.getRenderingCanvas() || undefined;\r\n            return new WebXRManagedOutputCanvas(this, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"WebXR not available\");\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Initializes an xr session\r\n     * @param xrSessionMode mode to initialize\r\n     * @param xrSessionInit defines optional and required values to pass to the session builder\r\n     * @returns a promise which will resolve once the session has been initialized\r\n     */\r\n    public initializeSessionAsync(xrSessionMode: XRSessionMode = \"immersive-vr\", xrSessionInit: XRSessionInit = {}): Promise<XRSession> {\r\n        return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then((session: XRSession) => {\r\n            this.session = session;\r\n            this.onXRSessionInit.notifyObservers(session);\r\n            this._sessionEnded = false;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this.session.addEventListener(\r\n                \"end\",\r\n                () => {\r\n                    const engine = this.scene.getEngine();\r\n                    this._sessionEnded = true;\r\n                    // Remove render target texture and notify frame observers\r\n                    this._rttProvider = null;\r\n                    // make sure dimensions object is restored\r\n                    engine.framebufferDimensionsObject = null;\r\n\r\n                    // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                    engine.restoreDefaultFramebuffer();\r\n\r\n                    // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                    engine.customAnimationFrameRequester = null;\r\n                    this.onXRSessionEnded.notifyObservers(null);\r\n                    engine._renderLoop();\r\n                },\r\n                { once: true }\r\n            );\r\n            return this.session;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param sessionMode session mode to check if supported eg. immersive-vr\r\n     * @returns A Promise that resolves to true if supported and false if not\r\n     */\r\n    public isSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\r\n    }\r\n\r\n    /**\r\n     * Resets the reference space to the one started the session\r\n     */\r\n    public resetReferenceSpace() {\r\n        this.referenceSpace = this.baseReferenceSpace;\r\n    }\r\n\r\n    /**\r\n     * Starts rendering to the xr layer\r\n     */\r\n    public runXRRenderLoop() {\r\n        const engine = this.scene.getEngine();\r\n        // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n        engine.customAnimationFrameRequester = {\r\n            requestAnimationFrame: this.session.requestAnimationFrame.bind(this.session),\r\n            renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                if (this._sessionEnded) {\r\n                    return;\r\n                }\r\n                // Store the XR frame and timestamp in the session manager\r\n                this.currentFrame = xrFrame;\r\n                this.currentTimestamp = timestamp;\r\n                if (xrFrame) {\r\n                    engine.framebufferDimensionsObject = this.baseLayer!;\r\n                    this.onXRFrameObservable.notifyObservers(xrFrame);\r\n                    engine._renderLoop();\r\n                    engine.framebufferDimensionsObject = null;\r\n                }\r\n            },\r\n        };\r\n\r\n        if (this._xrNavigator.xr.native) {\r\n            this._rttProvider = this._xrNavigator.xr.getNativeRenderTargetProvider(this.session, this._createRenderTargetTexture.bind(this));\r\n        } else {\r\n            // Create render target texture from xr's webgl render target\r\n            const rtt = this._createRenderTargetTexture(this.baseLayer!.framebufferWidth, this.baseLayer!.framebufferHeight, this.baseLayer!.framebuffer);\r\n            this._rttProvider = { getRenderTargetForEye: () => rtt };\r\n            engine.framebufferDimensionsObject = this.baseLayer;\r\n        }\r\n\r\n        // Stop window's animation frame and trigger sessions animation frame\r\n        if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame(engine._frameHandler);\r\n        }\r\n        engine._renderLoop();\r\n    }\r\n\r\n    /**\r\n     * Sets the reference space on the xr session\r\n     * @param referenceSpaceType space to set\r\n     * @returns a promise that will resolve once the reference space has been set\r\n     */\r\n    public setReferenceSpaceTypeAsync(referenceSpaceType: XRReferenceSpaceType = \"local-floor\"): Promise<XRReferenceSpace> {\r\n        return this.session\r\n            .requestReferenceSpace(referenceSpaceType)\r\n            .then(\r\n                (referenceSpace) => {\r\n                    return referenceSpace as XRReferenceSpace;\r\n                },\r\n                (rejectionReason) => {\r\n                    Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\r\n                    Logger.Error(rejectionReason);\r\n                    Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\r\n\r\n                    return this.session.requestReferenceSpace(\"viewer\").then(\r\n                        (referenceSpace) => {\r\n                            const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });\r\n                            return (referenceSpace as XRReferenceSpace).getOffsetReferenceSpace(heightCompensation);\r\n                        },\r\n                        (rejectionReason) => {\r\n                            Logger.Error(rejectionReason);\r\n                            throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\r\n                        }\r\n                    );\r\n                }\r\n            )\r\n            .then((referenceSpace) => {\r\n                // create viewer reference space before setting the first reference space\r\n                return this.session.requestReferenceSpace(\"viewer\").then((viewerReferenceSpace) => {\r\n                    this.viewerReferenceSpace = viewerReferenceSpace as XRReferenceSpace;\r\n                    return referenceSpace;\r\n                });\r\n            })\r\n            .then((referenceSpace) => {\r\n                // initialize the base and offset (currently the same)\r\n                this.referenceSpace = this.baseReferenceSpace = referenceSpace;\r\n                return this.referenceSpace;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the render state of the session\r\n     * @param state state to set\r\n     * @returns a promise that resolves once the render state has been updated\r\n     */\r\n    public updateRenderStateAsync(state: XRRenderState) {\r\n        if (state.baseLayer) {\r\n            this.baseLayer = state.baseLayer;\r\n        }\r\n        return this.session.updateRenderState(state);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\r\n     * @param sessionMode defines the session to test\r\n     * @returns a promise with boolean as final value\r\n     */\r\n    public static IsSessionSupportedAsync(sessionMode: XRSessionMode): Promise<boolean> {\r\n        if (!(navigator as any).xr) {\r\n            return Promise.resolve(false);\r\n        }\r\n        // When the specs are final, remove supportsSession!\r\n        const functionToUse = (navigator as any).xr.isSessionSupported || (navigator as any).xr.supportsSession;\r\n        if (!functionToUse) {\r\n            return Promise.resolve(false);\r\n        } else {\r\n            return functionToUse\r\n                .call((navigator as any).xr, sessionMode)\r\n                .then((result: boolean) => {\r\n                    const returnValue = typeof result === \"undefined\" ? true : result;\r\n                    return Promise.resolve(returnValue);\r\n                })\r\n                .catch((e: any) => {\r\n                    Logger.Warn(e);\r\n                    return Promise.resolve(false);\r\n                });\r\n        }\r\n    }\r\n\r\n    private _createRenderTargetTexture(width: number, height: number, framebuffer: Nullable<WebGLFramebuffer> = null) {\r\n        // Create internal texture\r\n        var internalTexture = new InternalTexture(this.scene.getEngine(), InternalTextureSource.Unknown, true);\r\n        internalTexture.width = width;\r\n        internalTexture.height = height;\r\n        internalTexture._framebuffer = framebuffer;\r\n\r\n        // Create render target texture from the internal texture\r\n        var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", { width: width, height: height }, this.scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n        renderTargetTexture._texture = internalTexture;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}