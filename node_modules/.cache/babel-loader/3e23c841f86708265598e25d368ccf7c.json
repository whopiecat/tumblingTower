{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\n\nvar PanoramaToCubeMapTools =\n/** @class */\nfunction () {\n  function PanoramaToCubeMapTools() {}\n  /**\r\n   * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).\r\n   *\r\n   * @param float32Array The source data.\r\n   * @param inputWidth The width of the input panorama.\r\n   * @param inputHeight The height of the input panorama.\r\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n   * @return The cubemap data\r\n   */\n\n\n  PanoramaToCubeMapTools.ConvertPanoramaToCubemap = function (float32Array, inputWidth, inputHeight, size) {\n    if (!float32Array) {\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n\n    var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n    var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n    var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n    var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n    var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n    var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  };\n\n  PanoramaToCubeMapTools.CreateCubemapTexture = function (texSize, faceData, float32Array, inputWidth, inputHeight) {\n    var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    var textureArray = new Float32Array(buffer);\n    var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n    var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n    var dy = 1 / texSize;\n    var fy = 0;\n\n    for (var y = 0; y < texSize; y++) {\n      var xv1 = faceData[0];\n      var xv2 = faceData[2];\n\n      for (var x = 0; x < texSize; x++) {\n        var v = xv2.subtract(xv1).scale(fy).add(xv1);\n        v.normalize();\n        var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight); // 3 channels per pixels\n\n        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\n        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\n        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\n        xv1 = xv1.add(rotDX1);\n        xv2 = xv2.add(rotDX2);\n      }\n\n      fy += dy;\n    }\n\n    return textureArray;\n  };\n\n  PanoramaToCubeMapTools.CalcProjectionSpherical = function (vDir, float32Array, inputWidth, inputHeight) {\n    var theta = Math.atan2(vDir.z, vDir.x);\n    var phi = Math.acos(vDir.y);\n\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n\n    var dx = theta / Math.PI;\n    var dy = phi / Math.PI; // recenter.\n\n    dx = dx * 0.5 + 0.5;\n    var px = Math.round(dx * inputWidth);\n\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n\n    var py = Math.round(dy * inputHeight);\n\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n\n    var inputY = inputHeight - py - 1;\n    var r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    var g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    var b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  };\n\n  PanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\n  PanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\n  PanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n  return PanoramaToCubeMapTools;\n}();\n\nexport { PanoramaToCubeMapTools };","map":{"version":3,"sources":["../../../../sourceES6/core/Misc/HighDynamicRange/panoramaToCubemap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\n\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n\r\n    private static FACE_LEFT = [\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, -1.0)\r\n    ];\r\n    private static FACE_RIGHT = [\r\n        new Vector3(1.0, -1.0, 1.0),\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, 1.0)\r\n    ];\r\n    private static FACE_FRONT = [\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, 1.0),\r\n        new Vector3(1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, 1.0)\r\n    ];\r\n    private static FACE_BACK = [\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, -1.0)\r\n    ];\r\n    private static FACE_DOWN = [\r\n        new Vector3(1.0, 1.0, -1.0),\r\n        new Vector3(1.0, 1.0, 1.0),\r\n        new Vector3(-1.0, 1.0, -1.0),\r\n        new Vector3(-1.0, 1.0, 1.0),\r\n    ];\r\n    private static FACE_UP = [\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, -1.0, 1.0),\r\n        new Vector3(1.0, -1.0, -1.0),\r\n        new Vector3(1.0, -1.0, 1.0),\r\n    ];\r\n\r\n    /**\r\n     * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @return The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\r\n        var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\r\n        var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\r\n        var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\r\n        var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\r\n        var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: 1,\r\n            format: 4,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number) {\r\n        var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        var textureArray = new Float32Array(buffer);\r\n\r\n        var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\r\n        var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\r\n\r\n        var dy = 1 / texSize;\r\n        var fy = 0;\r\n\r\n        for (var y = 0; y < texSize; y++) {\r\n            var xv1 = faceData[0];\r\n            var xv2 = faceData[2];\r\n\r\n            for (var x = 0; x < texSize; x++) {\r\n                var v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                v.normalize();\r\n\r\n                var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                // 3 channels per pixels\r\n                textureArray[y * texSize * 3 + (x * 3) + 0] = color.r;\r\n                textureArray[y * texSize * 3 + (x * 3) + 1] = color.g;\r\n                textureArray[y * texSize * 3 + (x * 3) + 2] = color.b;\r\n\r\n                xv1 = xv1.add(rotDX1);\r\n                xv2 = xv2.add(rotDX2);\r\n            }\r\n\r\n            fy += dy;\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        var theta = Math.atan2(vDir.z, vDir.x);\r\n        var phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) { theta += 2 * Math.PI; }\r\n        while (theta > Math.PI) { theta -= 2 * Math.PI; }\r\n\r\n        var dx = theta / Math.PI;\r\n        var dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        var px = Math.round(dx * inputWidth);\r\n        if (px < 0) { px = 0; }\r\n        else if (px >= inputWidth) { px = inputWidth - 1; }\r\n\r\n        var py = Math.round(dy * inputHeight);\r\n        if (py < 0) { py = 0; }\r\n        else if (py >= inputHeight) { py = inputHeight - 1; }\r\n\r\n        var inputY = (inputHeight - py - 1);\r\n        var r = float32Array[inputY * inputWidth * 3 + (px * 3) + 0];\r\n        var g = float32Array[inputY * inputWidth * 3 + (px * 3) + 1];\r\n        var b = float32Array[inputY * inputWidth * 3 + (px * 3) + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b\r\n        };\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}