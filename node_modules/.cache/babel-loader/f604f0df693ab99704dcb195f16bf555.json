{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { DeepCopier } from \"../../Misc/deepCopier\";\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\n\nvar SphereParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n  * Creates a new instance SphereParticleEmitter\r\n  * @param radius the radius of the emission sphere (1 by default)\r\n  * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n  * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n  */\n  function SphereParticleEmitter(\n  /**\r\n   * The radius of the emission sphere.\r\n   */\n  radius,\n  /**\r\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n   */\n  radiusRange,\n  /**\r\n   * How much to randomize the particle direction [0-1].\r\n   */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (radiusRange === void 0) {\n      radiusRange = 1;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  SphereParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  SphereParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    var v = Scalar.RandomRange(0, 1.0);\n    var phi = Scalar.RandomRange(0, 2 * Math.PI);\n    var theta = Math.acos(2 * v - 1);\n    var randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    var randY = randRadius * Math.cos(theta);\n    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  SphereParticleEmitter.prototype.clone = function () {\n    var newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  SphereParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat(\"radius\", this.radius);\n    effect.setFloat(\"radiusRange\", this.radiusRange);\n    effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  SphereParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define SPHEREEMITTER\";\n  };\n  /**\r\n   * Returns the string \"SphereParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  SphereParticleEmitter.prototype.getClassName = function () {\n    return \"SphereParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  SphereParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  SphereParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  };\n\n  return SphereParticleEmitter;\n}();\n\nexport { SphereParticleEmitter };\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\n\nvar SphereDirectedParticleEmitter =\n/** @class */\nfunction (_super) {\n  __extends(SphereDirectedParticleEmitter, _super);\n  /**\r\n   * Creates a new instance SphereDirectedParticleEmitter\r\n   * @param radius the radius of the emission sphere (1 by default)\r\n   * @param direction1 the min limit of the emission direction (up vector by default)\r\n   * @param direction2 the max limit of the emission direction (up vector by default)\r\n   */\n\n\n  function SphereDirectedParticleEmitter(radius,\n  /**\r\n   * The min limit of the emission direction.\r\n   */\n  direction1,\n  /**\r\n   * The max limit of the emission direction.\r\n   */\n  direction2) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (direction1 === void 0) {\n      direction1 = new Vector3(0, 1, 0);\n    }\n\n    if (direction2 === void 0) {\n      direction2 = new Vector3(0, 1, 0);\n    }\n\n    var _this = _super.call(this, radius) || this;\n\n    _this.direction1 = direction1;\n    _this.direction2 = direction2;\n    return _this;\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle) {\n    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.clone = function () {\n    var newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat(\"radius\", this.radius);\n    effect.setFloat(\"radiusRange\", this.radiusRange);\n    effect.setVector3(\"direction1\", this.direction1);\n    effect.setVector3(\"direction2\", this.direction2);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n  };\n  /**\r\n   * Returns the string \"SphereDirectedParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.getClassName = function () {\n    return \"SphereDirectedParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  SphereDirectedParticleEmitter.prototype.parse = function (serializationObject) {\n    _super.prototype.parse.call(this, serializationObject);\n\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  };\n\n  return SphereDirectedParticleEmitter;\n}(SphereParticleEmitter);\n\nexport { SphereDirectedParticleEmitter };","map":{"version":3,"sources":["../../../../sourceES6/core/Particles/EmitterTypes/sphereParticleEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { Particle } from \"../../Particles/particle\";\r\nimport { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\r\nexport class SphereParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n    * Creates a new instance SphereParticleEmitter\r\n    * @param radius the radius of the emission sphere (1 by default)\r\n    * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n    * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n    */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission sphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0) {\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        var randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        var randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        var randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        var v = Scalar.RandomRange(0, 1.0);\r\n        var phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        var theta = Math.acos(2 * v - 1);\r\n        var randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        var randY = randRadius * Math.cos(theta);\r\n        var randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereParticleEmitter {\r\n        let newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param effect defines the update shader\r\n     */\r\n    public applyToShader(effect: Effect): void {\r\n        effect.setFloat(\"radius\", this.radius);\r\n        effect.setFloat(\"radiusRange\", this.radiusRange);\r\n        effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containng the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\r\n\r\n    /**\r\n     * Creates a new instance SphereDirectedParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(radius = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)) {\r\n        super(radius);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle): void {\r\n        var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereDirectedParticleEmitter {\r\n        let newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param effect defines the update shader\r\n     */\r\n    public applyToShader(effect: Effect): void {\r\n        effect.setFloat(\"radius\", this.radius);\r\n        effect.setFloat(\"radiusRange\", this.radiusRange);\r\n        effect.setVector3(\"direction1\", this.direction1);\r\n        effect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containng the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}