{"ast":null,"code":"import { Tools } from \"../../Misc/tools\";\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\n\nvar PostProcessRenderEffect =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a post process render effect.\r\n   * A post process can be used to apply a shader to a texture after it is rendered.\r\n   * @param engine The engine the effect is tied to\r\n   * @param name The name of the effect\r\n   * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n   * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n   */\n  function PostProcessRenderEffect(engine, name, getPostProcesses, singleInstance) {\n    this._name = name;\n    this._singleInstance = singleInstance || true;\n    this._getPostProcesses = getPostProcesses;\n    this._cameras = {};\n    this._indicesForCamera = {};\n    this._postProcesses = {};\n  }\n\n  Object.defineProperty(PostProcessRenderEffect.prototype, \"isSupported\", {\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\n    get: function () {\n      for (var index in this._postProcesses) {\n        if (this._postProcesses.hasOwnProperty(index)) {\n          var pps = this._postProcesses[index];\n\n          for (var ppIndex = 0; ppIndex < pps.length; ppIndex++) {\n            if (!pps[ppIndex].isSupported) {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Updates the current state of the effect\r\n   * @hidden\r\n   */\n\n  PostProcessRenderEffect.prototype._update = function () {};\n  /**\r\n   * Attaches the effect on cameras\r\n   * @param cameras The camera to attach to.\r\n   * @hidden\r\n   */\n\n\n  PostProcessRenderEffect.prototype._attachCameras = function (cameras) {\n    var _this = this;\n\n    var cameraKey;\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n\n      if (!camera) {\n        continue;\n      }\n\n      var cameraName = camera.name;\n\n      if (this._singleInstance) {\n        cameraKey = 0;\n      } else {\n        cameraKey = cameraName;\n      }\n\n      if (!this._postProcesses[cameraKey]) {\n        var postProcess = this._getPostProcesses();\n\n        if (postProcess) {\n          this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\n        }\n      }\n\n      if (!this._indicesForCamera[cameraName]) {\n        this._indicesForCamera[cameraName] = [];\n      }\n\n      this._postProcesses[cameraKey].forEach(function (postProcess) {\n        var index = camera.attachPostProcess(postProcess);\n\n        _this._indicesForCamera[cameraName].push(index);\n      });\n\n      if (!this._cameras[cameraName]) {\n        this._cameras[cameraName] = camera;\n      }\n    }\n  };\n  /**\r\n   * Detatches the effect on cameras\r\n   * @param cameras The camera to detatch from.\r\n   * @hidden\r\n   */\n\n\n  PostProcessRenderEffect.prototype._detachCameras = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n      var postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\n\n      if (postProcesses) {\n        postProcesses.forEach(function (postProcess) {\n          camera.detachPostProcess(postProcess);\n        });\n      }\n\n      if (this._cameras[cameraName]) {\n        this._cameras[cameraName] = null;\n      }\n    }\n  };\n  /**\r\n   * Enables the effect on given cameras\r\n   * @param cameras The camera to enable.\r\n   * @hidden\r\n   */\n\n\n  PostProcessRenderEffect.prototype._enable = function (cameras) {\n    var _this = this;\n\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n\n      for (var j = 0; j < this._indicesForCamera[cameraName].length; j++) {\n        if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {\n          this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function (postProcess) {\n            cams[i].attachPostProcess(postProcess, _this._indicesForCamera[cameraName][j]);\n          });\n        }\n      }\n    }\n  };\n  /**\r\n   * Disables the effect on the given cameras\r\n   * @param cameras The camera to disable.\r\n   * @hidden\r\n   */\n\n\n  PostProcessRenderEffect.prototype._disable = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n      var cameraName = camera.name;\n\n      this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(function (postProcess) {\n        camera.detachPostProcess(postProcess);\n      });\n    }\n  };\n  /**\r\n   * Gets a list of the post processes contained in the effect.\r\n   * @param camera The camera to get the post processes on.\r\n   * @returns The list of the post processes in the effect.\r\n   */\n\n\n  PostProcessRenderEffect.prototype.getPostProcesses = function (camera) {\n    if (this._singleInstance) {\n      return this._postProcesses[0];\n    } else {\n      if (!camera) {\n        return null;\n      }\n\n      return this._postProcesses[camera.name];\n    }\n  };\n\n  return PostProcessRenderEffect;\n}();\n\nexport { PostProcessRenderEffect };","map":{"version":3,"sources":["../../../../sourceES6/core/PostProcesses/RenderPipeline/postProcessRenderEffect.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Engine } from \"../../Engines/engine\";\r\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\r\nexport class PostProcessRenderEffect {\r\n    private _postProcesses: { [Key: string]: Array<PostProcess> };\r\n    private _getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>;\r\n\r\n    private _singleInstance: boolean;\r\n\r\n    private _cameras: { [key: string]: Nullable<Camera> };\r\n    private _indicesForCamera: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Name of the effect\r\n     * @hidden\r\n     */\r\n    public _name: string;\r\n\r\n    /**\r\n     * Instantiates a post process render effect.\r\n     * A post process can be used to apply a shader to a texture after it is rendered.\r\n     * @param engine The engine the effect is tied to\r\n     * @param name The name of the effect\r\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n     */\r\n    constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean) {\r\n        this._name = name;\r\n        this._singleInstance = singleInstance || true;\r\n\r\n        this._getPostProcesses = getPostProcesses;\r\n\r\n        this._cameras = {};\r\n        this._indicesForCamera = {};\r\n\r\n        this._postProcesses = {};\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (var index in this._postProcesses) {\r\n            if (this._postProcesses.hasOwnProperty(index)) {\r\n                let pps = this._postProcesses[index];\r\n                for (var ppIndex = 0; ppIndex < pps.length; ppIndex++) {\r\n                    if (!pps[ppIndex].isSupported) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Updates the current state of the effect\r\n     * @hidden\r\n     */\r\n    public _update(): void {\r\n    }\r\n\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: Camera): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @hidden\r\n     */\r\n    public _attachCameras(cameras: any): void {\r\n        var cameraKey;\r\n\r\n        var cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < cams.length; i++) {\r\n            var camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            var cameraName = camera.name;\r\n\r\n            if (this._singleInstance) {\r\n                cameraKey = 0;\r\n            }\r\n            else {\r\n                cameraKey = cameraName;\r\n            }\r\n\r\n            if (!this._postProcesses[cameraKey]) {\r\n                var postProcess = this._getPostProcesses();\r\n                if (postProcess) {\r\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\r\n                }\r\n            }\r\n\r\n            if (!this._indicesForCamera[cameraName]) {\r\n                this._indicesForCamera[cameraName] = [];\r\n            }\r\n\r\n            this._postProcesses[cameraKey].forEach((postProcess: PostProcess) => {\r\n                var index = camera.attachPostProcess(postProcess);\r\n\r\n                this._indicesForCamera[cameraName].push(index);\r\n            });\r\n\r\n            if (!this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detatch from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /**\r\n     * Detatches the effect on cameras\r\n     * @param cameras The camera to detatch from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Detatches the effect on cameras\r\n     * @param cameras The camera to detatch from.\r\n     * @hidden\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        var cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < cams.length; i++) {\r\n            var camera: Camera = cams[i];\r\n            var cameraName: string = camera.name;\r\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n\r\n            if (postProcesses) {\r\n                postProcesses.forEach((postProcess: PostProcess) => {\r\n                    camera.detachPostProcess(postProcess);\r\n                });\r\n            }\r\n\r\n            if (this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: Camera): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @hidden\r\n     */\r\n    public _enable(cameras: any): void {\r\n        var cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < cams.length; i++) {\r\n            var camera = cams[i];\r\n            var cameraName = camera.name;\r\n\r\n            for (var j = 0; j < this._indicesForCamera[cameraName].length; j++) {\r\n                if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {\r\n                    this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                        cams![i].attachPostProcess(postProcess, this._indicesForCamera[cameraName][j]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: Camera): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @hidden\r\n     */\r\n    public _disable(cameras: any): void {\r\n        var cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < cams.length; i++) {\r\n            var camera = cams[i];\r\n            var cameraName = camera.name;\r\n            this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                camera.detachPostProcess(postProcess);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of the post processes contained in the effect.\r\n     * @param camera The camera to get the post processes on.\r\n     * @returns The list of the post processes in the effect.\r\n     */\r\n    public getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>> {\r\n        if (this._singleInstance) {\r\n            return this._postProcesses[0];\r\n        }\r\n        else {\r\n            if (!camera) {\r\n                return null;\r\n            }\r\n            return this._postProcesses[camera.name];\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}