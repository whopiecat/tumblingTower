{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\nimport { Color3 } from '../../Maths/math.color';\nimport { MaterialFlags } from \"../materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\nimport { Scalar } from \"../../Maths/math.scalar\";\n/**\r\n * Define the code related to the sub surface parameters of the pbr material.\r\n */\n\nvar PBRSubSurfaceConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of sub surface configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   * @param markScenePrePassDirty Callback to flag the scene as prepass dirty\r\n   * @param scene The scene\r\n   */\n  function PBRSubSurfaceConfiguration(markAllSubMeshesAsTexturesDirty, markScenePrePassDirty, scene) {\n    this._isRefractionEnabled = false;\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\n\n    this.isRefractionEnabled = false;\n    this._isTranslucencyEnabled = false;\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\n\n    this.isTranslucencyEnabled = false;\n    this._isScatteringEnabled = false;\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\n\n    this.isScatteringEnabled = false;\n    this._scatteringDiffusionProfileIndex = 0;\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitionning between diffuse and refraction.\r\n     */\n\n    this.refractionIntensity = 1;\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is addded to the diffuse part of the material.\r\n     */\n\n    this.translucencyIntensity = 1;\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\n\n    this.useAlbedoToTintRefraction = false;\n    this._thicknessTexture = null;\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\n\n    this.thicknessTexture = null;\n    this._refractionTexture = null;\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\n\n    this.refractionTexture = null;\n    this._indexOfRefraction = 1.5;\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\n\n    this.indexOfRefraction = 1.5;\n    this._volumeIndexOfRefraction = -1.0;\n    this._invertRefractionY = false;\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\n\n    this.invertRefractionY = false;\n    this._linkRefractionWithTransparency = false;\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\n\n    this.linkRefractionWithTransparency = false;\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\n\n    this.minimumThickness = 0;\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\n\n    this.maximumThickness = 1;\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\n\n    this.tintColor = Color3.White();\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\n\n    this.tintColorAtDistance = 1;\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\n\n    this.diffusionDistance = Color3.White();\n    this._useMaskFromThicknessTexture = false;\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * * the green channel is the translucency intensity.\r\n     * * the blue channel is the scattering intensity.\r\n     * * the alpha channel is the refraction intensity.\r\n     */\n\n    this.useMaskFromThicknessTexture = false;\n    this._useMaskFromThicknessTextureGltf = false;\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture. This variation\r\n     * matches the channel-packing that is used by glTF.\r\n     * * the red channel is the transmission/translucency intensity.\r\n     * * the green channel is the thickness.\r\n     */\n\n    this.useMaskFromThicknessTextureGltf = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n    this._internalMarkScenePrePassDirty = markScenePrePassDirty;\n    this._scene = scene;\n  }\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"scatteringDiffusionProfile\", {\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\n    get: function () {\n      if (!this._scene.subSurfaceConfiguration) {\n        return null;\n      }\n\n      return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n    },\n    set: function (c) {\n      if (!this._scene.enableSubSurfaceForPrePass()) {\n        // Not supported\n        return;\n      } // addDiffusionProfile automatically checks for doubles\n\n\n      if (c) {\n        this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", {\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\n    get: function () {\n      if (this._volumeIndexOfRefraction >= 1.0) {\n        return this._volumeIndexOfRefraction;\n      }\n\n      return this._indexOfRefraction;\n    },\n    set: function (value) {\n      if (value >= 1.0) {\n        this._volumeIndexOfRefraction = value;\n      } else {\n        this._volumeIndexOfRefraction = -1.0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  PBRSubSurfaceConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /** @hidden */\n\n\n  PBRSubSurfaceConfiguration.prototype._markScenePrePassDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n\n    this._internalMarkScenePrePassDirty();\n  };\n  /**\r\n   * Gets wehter the submesh is ready to be used or not.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        var refractionTexture = this._getRefractionTexture(scene);\n\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene to the material belongs to.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.prepareDefines = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = false;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n\n      if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled) {\n        defines.SUBSURFACE = true;\n\n        if (defines._areTexturesDirty) {\n          if (scene.texturesEnabled) {\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n              MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n            }\n          }\n        }\n\n        defines.SS_MASK_FROM_THICKNESS_TEXTURE = this._useMaskFromThicknessTexture;\n        defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = this._useMaskFromThicknessTextureGltf;\n      }\n\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          var refractionTexture = this._getRefractionTexture(scene);\n\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param engine defines the engine the material belongs to.\r\n   * @param isFrozen defines whether the material is frozen or not.\r\n   * @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.\r\n   * @param realTimeFiltering defines whether the textures should be filtered on the fly.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, engine, isFrozen, lodBasedMicrosurface, realTimeFiltering) {\n    var refractionTexture = this._getRefractionTexture(scene);\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n\n      uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness, this.maximumThickness - this.minimumThickness);\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n        var depth = 1.0;\n\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n\n        var width = refractionTexture.getSize().width;\n        var refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\n\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n      }\n\n      if (this.isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, this.tintColorAtDistance);\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  };\n  /**\r\n   * Unbinds the material from the mesh.\r\n   * @param activeEffect defines the effect that should be unbound from.\r\n   * @returns true if unbound, otherwise false\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.unbind = function (activeEffect) {\n    if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      activeEffect.setTexture(\"refractionSampler\", null);\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns the texture used for refraction or null if none is used.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype._getRefractionTexture = function (scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(PBRSubSurfaceConfiguration.prototype, \"disableAlphaBlending\", {\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\n    get: function () {\n      return this.isRefractionEnabled && this._linkRefractionWithTransparency;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Fills the list of render target textures.\r\n   * @param renderTargets the list of render targets to update\r\n   */\n\n  PBRSubSurfaceConfiguration.prototype.fillRenderTargetTextures = function (renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.hasTexture = function (texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Gets a boolean indicating that current material needs to register RTT\r\n   * @returns true if this uses a render target otherwise false.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.hasRenderTargetTextures = function () {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRSubSurfaceConfiguration\"\r\n  */\n\n\n  PBRSubSurfaceConfiguration.prototype.getClassName = function () {\n    return \"PBRSubSurfaceConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vDiffusionDistance\", \"vTintColor\", \"vSubSurfaceIntensity\", \"vRefractionMicrosurfaceInfos\", \"vRefractionFilteringInfo\", \"vRefractionInfos\", \"vThicknessInfos\", \"vThicknessParam\", \"refractionMatrix\", \"thicknessMatrix\", \"scatteringDiffusionProfile\");\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3);\n    uniformBuffer.addUniform(\"vRefractionFilteringInfo\", 2);\n    uniformBuffer.addUniform(\"vRefractionInfos\", 4);\n    uniformBuffer.addUniform(\"refractionMatrix\", 16);\n    uniformBuffer.addUniform(\"vThicknessInfos\", 2);\n    uniformBuffer.addUniform(\"thicknessMatrix\", 16);\n    uniformBuffer.addUniform(\"vThicknessParam\", 2);\n    uniformBuffer.addUniform(\"vDiffusionDistance\", 3);\n    uniformBuffer.addUniform(\"vTintColor\", 4);\n    uniformBuffer.addUniform(\"vSubSurfaceIntensity\", 3);\n    uniformBuffer.addUniform(\"scatteringDiffusionProfile\", 1);\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param configuration define the config where to copy the info\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.copyTo = function (configuration) {\n    SerializationHelper.Clone(function () {\n      return configuration;\n    }, this);\n  };\n  /**\r\n   * Serializes this Sub Surface configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRSubSurfaceConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n\n  __decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n\n  __decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTextureGltf\", void 0);\n\n  return PBRSubSurfaceConfiguration;\n}();\n\nexport { PBRSubSurfaceConfiguration };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/PBR/pbrSubSurfaceConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { IAnimatable } from '../../Animations/animatable.interface';\r\nimport { SerializationHelper, serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\n\r\ndeclare type Engine = import(\"../../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialSubSurfaceDefines {\r\n    SUBSURFACE: boolean;\r\n\r\n    SS_REFRACTION: boolean;\r\n    SS_TRANSLUCENCY: boolean;\r\n    SS_SCATTERING: boolean;\r\n\r\n    SS_THICKNESSANDMASK_TEXTURE: boolean;\r\n    SS_THICKNESSANDMASK_TEXTUREDIRECTUV: number;\r\n\r\n    SS_REFRACTIONMAP_3D: boolean;\r\n    SS_REFRACTIONMAP_OPPOSITEZ: boolean;\r\n    SS_LODINREFRACTIONALPHA: boolean;\r\n    SS_GAMMAREFRACTION: boolean;\r\n    SS_RGBDREFRACTION: boolean;\r\n    SS_LINEARSPECULARREFRACTION: boolean;\r\n    SS_LINKREFRACTIONTOTRANSPARENCY: boolean;\r\n    SS_ALBEDOFORREFRACTIONTINT: boolean;\r\n\r\n    SS_MASK_FROM_THICKNESS_TEXTURE: boolean;\r\n    SS_MASK_FROM_THICKNESS_TEXTURE_GLTF: boolean;\r\n\r\n    /** @hidden */\r\n    _areTexturesDirty: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the sub surface parameters of the pbr material.\r\n */\r\nexport class PBRSubSurfaceConfiguration {\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile() : Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitionning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is addded to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    private _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting aginst not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * * the green channel is the translucency intensity.\r\n     * * the blue channel is the scattering intensity.\r\n     * * the alpha channel is the refraction intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _scene: Scene;\r\n    private _useMaskFromThicknessTextureGltf = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture. This variation\r\n     * matches the channel-packing that is used by glTF.\r\n     * * the red channel is the transmission/translucency intensity.\r\n     * * the green channel is the thickness.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTextureGltf: boolean = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @hidden */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new istance of sub surface configuration.\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     * @param markScenePrePassDirty Callback to flag the scene as prepass dirty\r\n     * @param scene The scene\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void, markScenePrePassDirty: () => void, scene: Scene) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n        this._internalMarkScenePrePassDirty = markScenePrePassDirty;\r\n        this._scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Gets wehter the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                var refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = false;\r\n\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n\r\n            if (this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled) {\r\n                defines.SUBSURFACE = true;\r\n\r\n                if (defines._areTexturesDirty) {\r\n                    if (scene.texturesEnabled) {\r\n                        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                        }\r\n                    }\r\n                }\r\n\r\n                defines.SS_MASK_FROM_THICKNESS_TEXTURE = this._useMaskFromThicknessTexture;\r\n                defines.SS_MASK_FROM_THICKNESS_TEXTURE_GLTF = this._useMaskFromThicknessTextureGltf;\r\n            }\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    var refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     * @param lodBasedMicrosurface defines whether the material relies on lod based microsurface or not.\r\n     * @param realTimeFiltering defines whether the textures should be filtered on the fly.\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, isFrozen: boolean, lodBasedMicrosurface: boolean, realTimeFiltering: boolean): void {\r\n        var refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness, this.maximumThickness - this.minimumThickness);\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\r\n\r\n                var depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                var width = refractionTexture.getSize().width;\r\n                var refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset);\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n            }\r\n\r\n            if (this.isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r,\r\n                this.tintColor.g,\r\n                this.tintColor.b,\r\n                this.tintColorAtDistance);\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                }\r\n                else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh.\r\n     * @param activeEffect defines the effect that should be unbound from.\r\n     * @returns true if unbound, otherwise false\r\n     */\r\n    public unbind(activeEffect: Effect): boolean {\r\n        if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            activeEffect.setTexture(\"refractionSampler\", null);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this.isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name of the texture useful for serialization or dynamic coding.\r\n    * @returns \"PBRSubSurfaceConfiguration\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public static AddFallbacks(defines: IMaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\r\n            \"vDiffusionDistance\", \"vTintColor\", \"vSubSurfaceIntensity\",\r\n            \"vRefractionMicrosurfaceInfos\", \"vRefractionFilteringInfo\",\r\n            \"vRefractionInfos\", \"vThicknessInfos\", \"vThicknessParam\",\r\n            \"refractionMatrix\", \"thicknessMatrix\", \"scatteringDiffusionProfile\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\",\r\n            \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3);\r\n        uniformBuffer.addUniform(\"vRefractionFilteringInfo\", 2);\r\n        uniformBuffer.addUniform(\"vRefractionInfos\", 4);\r\n        uniformBuffer.addUniform(\"refractionMatrix\", 16);\r\n        uniformBuffer.addUniform(\"vThicknessInfos\", 2);\r\n        uniformBuffer.addUniform(\"thicknessMatrix\", 16);\r\n        uniformBuffer.addUniform(\"vThicknessParam\", 2);\r\n        uniformBuffer.addUniform(\"vDiffusionDistance\", 3);\r\n        uniformBuffer.addUniform(\"vTintColor\", 4);\r\n        uniformBuffer.addUniform(\"vSubSurfaceIntensity\", 3);\r\n        uniformBuffer.addUniform(\"scatteringDiffusionProfile\", 1);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param configuration define the config where to copy the info\r\n     */\r\n    public copyTo(configuration: PBRSubSurfaceConfiguration): void {\r\n        SerializationHelper.Clone(() => configuration, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this Sub Surface configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}