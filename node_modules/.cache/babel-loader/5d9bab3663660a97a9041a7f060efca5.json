{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { Color4 } from '../Maths/math.color';\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { PBRMaterial } from '../Materials/PBR/pbrMaterial';\nimport { _DevTools } from '../Misc/devTools';\nimport { Material } from '../Materials/material';\nimport \"../Shaders/geometry.fragment\";\nimport \"../Shaders/geometry.vertex\";\n/**\r\n * This renderer is helpfull to fill one of the render target with a geometry buffer.\r\n */\n\nvar GeometryBufferRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new G Buffer for the scene\r\n   * @param scene The scene the buffer belongs to\r\n   * @param ratio How big is the buffer related to the main canvas.\r\n   */\n  function GeometryBufferRenderer(scene, ratio) {\n    if (ratio === void 0) {\n      ratio = 1;\n    }\n    /**\r\n     * Dictionary used to store the previous transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\n\n\n    this._previousTransformationMatrices = {};\n    /**\r\n     * Dictionary used to store the previous bones transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\n\n    this._previousBonesTransformationMatrices = {};\n    /**\r\n     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\r\n     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\r\n     */\n\n    this.excludedSkinnedMeshesFromVelocity = [];\n    /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n\n    this.renderTransparentMeshes = true;\n    this._resizeObserver = null;\n    this._enablePosition = false;\n    this._enableVelocity = false;\n    this._enableReflectivity = false;\n    this._positionIndex = -1;\n    this._velocityIndex = -1;\n    this._reflectivityIndex = -1;\n    this._depthNormalIndex = -1;\n    this._linkedWithPrePass = false;\n    this._scene = scene;\n    this._ratio = ratio;\n\n    GeometryBufferRenderer._SceneComponentInitialization(this._scene); // Render target\n\n\n    this._createRenderTargets();\n  }\n  /**\r\n   * @hidden\r\n   * Sets up internal structures to share outputs with PrePassRenderer\r\n   * This method should only be called by the PrePassRenderer itself\r\n   */\n\n\n  GeometryBufferRenderer.prototype._linkPrePassRenderer = function (prePassRenderer) {\n    this._linkedWithPrePass = true;\n    this._prePassRenderer = prePassRenderer;\n\n    if (this._multiRenderTarget) {\n      // prevents clearing of the RT since it's done by prepass\n      this._multiRenderTarget.onClearObservable.clear();\n\n      this._multiRenderTarget.onClearObservable.add(function (engine) {// pass\n      });\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\r\n   * This method should only be called by the PrePassRenderer itself\r\n   */\n\n\n  GeometryBufferRenderer.prototype._unlinkPrePassRenderer = function () {\n    this._linkedWithPrePass = false;\n\n    this._createRenderTargets();\n  };\n  /**\r\n   * @hidden\r\n   * Resets the geometry buffer layout\r\n   */\n\n\n  GeometryBufferRenderer.prototype._resetLayout = function () {\n    this._enablePosition = false;\n    this._enableReflectivity = false;\n    this._enableVelocity = false;\n    this._attachments = [];\n  };\n  /**\r\n   * @hidden\r\n   * Replaces a texture in the geometry buffer renderer\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._forceTextureType = function (geometryBufferType, index) {\n    if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n      this._positionIndex = index;\n      this._enablePosition = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n      this._velocityIndex = index;\n      this._enableVelocity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n      this._reflectivityIndex = index;\n      this._enableReflectivity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE) {\n      this._depthNormalIndex = index;\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Sets texture attachments\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._setAttachments = function (attachments) {\n    this._attachments = attachments;\n  };\n  /**\r\n   * @hidden\r\n   * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\r\n   * Useful when linking textures of the prepass renderer\r\n   */\n\n\n  GeometryBufferRenderer.prototype._linkInternalTexture = function (internalTexture) {\n    this._multiRenderTarget._texture = internalTexture;\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"renderList\", {\n    /**\r\n     * Gets the render list (meshes to be rendered) used in the G buffer.\r\n     */\n    get: function () {\n      return this._multiRenderTarget.renderList;\n    },\n\n    /**\r\n     * Set the render list (meshes to be rendered) used in the G buffer.\r\n     */\n    set: function (meshes) {\n      this._multiRenderTarget.renderList = meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"isSupported\", {\n    /**\r\n     * Gets wether or not G buffer are supported by the running hardware.\r\n     * This requires draw buffer supports\r\n     */\n    get: function () {\n      return this._multiRenderTarget.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the index of the given texture type in the G-Buffer textures array\r\n   * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\r\n   * @returns the index of the given texture type in the G-Buffer textures array\r\n   */\n\n  GeometryBufferRenderer.prototype.getTextureIndex = function (textureType) {\n    switch (textureType) {\n      case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n        return this._positionIndex;\n\n      case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n        return this._velocityIndex;\n\n      case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n        return this._reflectivityIndex;\n\n      default:\n        return -1;\n    }\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enablePosition\", {\n    /**\r\n     * Gets a boolean indicating if objects positions are enabled for the G buffer.\r\n     */\n    get: function () {\n      return this._enablePosition;\n    },\n\n    /**\r\n     * Sets whether or not objects positions are enabled for the G buffer.\r\n     */\n    set: function (enable) {\n      this._enablePosition = enable; // PrePass handles index and texture links\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enableVelocity\", {\n    /**\r\n     * Gets a boolean indicating if objects velocities are enabled for the G buffer.\r\n     */\n    get: function () {\n      return this._enableVelocity;\n    },\n\n    /**\r\n     * Sets wether or not objects velocities are enabled for the G buffer.\r\n     */\n    set: function (enable) {\n      this._enableVelocity = enable;\n\n      if (!enable) {\n        this._previousTransformationMatrices = {};\n      }\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"enableReflectivity\", {\n    /**\r\n     * Gets a boolean indicating if objects roughness are enabled in the G buffer.\r\n     */\n    get: function () {\n      return this._enableReflectivity;\n    },\n\n    /**\r\n     * Sets wether or not objects roughness are enabled for the G buffer.\r\n     */\n    set: function (enable) {\n      this._enableReflectivity = enable;\n\n      if (!this._linkedWithPrePass) {\n        this.dispose();\n\n        this._createRenderTargets();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"scene\", {\n    /**\r\n     * Gets the scene associated with the buffer.\r\n     */\n    get: function () {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"ratio\", {\n    /**\r\n     * Gets the ratio used by the buffer during its creation.\r\n     * How big is the buffer related to the main canvas.\r\n     */\n    get: function () {\n      return this._ratio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Checks wether everything is ready to render a submesh to the G buffer.\r\n   * @param subMesh the submesh to check readiness for\r\n   * @param useInstances is the mesh drawn using instance or not\r\n   * @returns true if ready otherwise false\r\n   */\n\n  GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n\n    if (material && material.disableDepthWrite) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    var mesh = subMesh.getMesh(); // Alpha test\n\n    if (material) {\n      var needUv = false;\n\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n        needUv = true;\n      }\n\n      if (material.bumpTexture && StandardMaterial.BumpTextureEnabled) {\n        defines.push(\"#define BUMP\");\n        defines.push(\"#define BUMPDIRECTUV 0\");\n        needUv = true;\n      }\n\n      if (this._enableReflectivity) {\n        if (material instanceof StandardMaterial && material.specularTexture) {\n          defines.push(\"#define HAS_SPECULAR\");\n          needUv = true;\n        } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\n          defines.push(\"#define HAS_REFLECTIVITY\");\n          needUv = true;\n        }\n      }\n\n      if (needUv) {\n        defines.push(\"#define NEED_UV\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      }\n    } // PrePass\n\n\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define PREPASS\");\n\n      if (this._depthNormalIndex !== -1) {\n        defines.push(\"#define DEPTHNORMAL_INDEX \" + this._depthNormalIndex);\n        defines.push(\"#define PREPASS_DEPTHNORMAL\");\n      }\n    } // Buffers\n\n\n    if (this._enablePosition) {\n      defines.push(\"#define POSITION\");\n      defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n    }\n\n    if (this._enableVelocity) {\n      defines.push(\"#define VELOCITY\");\n      defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n\n      if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n        defines.push(\"#define BONES_VELOCITY_ENABLED\");\n      }\n    }\n\n    if (this._enableReflectivity) {\n      defines.push(\"#define REFLECTIVITY\");\n      defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Setup textures count\n\n\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachments.length);\n    } else {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this._scene.getEngine().createEffect(\"geometry\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\", \"previousWorld\", \"previousViewProjection\", \"mPreviousBones\", \"morphTargetInfluences\", \"bumpMatrix\", \"reflectivityMatrix\", \"vTangentSpaceParams\", \"vBumpInfos\"], [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\"], join, undefined, undefined, undefined, {\n        buffersCount: this._multiRenderTarget.textures.length - 1,\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n  /**\r\n   * Gets the current underlying G Buffer.\r\n   * @returns the buffer\r\n   */\n\n\n  GeometryBufferRenderer.prototype.getGBuffer = function () {\n    return this._multiRenderTarget;\n  };\n\n  Object.defineProperty(GeometryBufferRenderer.prototype, \"samples\", {\n    /**\r\n     * Gets the number of samples used to render the buffer (anti aliasing).\r\n     */\n    get: function () {\n      return this._multiRenderTarget.samples;\n    },\n\n    /**\r\n     * Sets the number of samples used to render the buffer (anti aliasing).\r\n     */\n    set: function (value) {\n      this._multiRenderTarget.samples = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes the renderer and frees up associated resources.\r\n   */\n\n  GeometryBufferRenderer.prototype.dispose = function () {\n    if (this._resizeObserver) {\n      var engine = this._scene.getEngine();\n\n      engine.onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n\n    this.getGBuffer().dispose();\n  };\n\n  GeometryBufferRenderer.prototype._assignRenderTargetIndices = function () {\n    var count = 2;\n\n    if (this._enablePosition) {\n      this._positionIndex = count;\n      count++;\n    }\n\n    if (this._enableVelocity) {\n      this._velocityIndex = count;\n      count++;\n    }\n\n    if (this._enableReflectivity) {\n      this._reflectivityIndex = count;\n      count++;\n    }\n\n    return count;\n  };\n\n  GeometryBufferRenderer.prototype._createRenderTargets = function () {\n    var _this = this;\n\n    var engine = this._scene.getEngine();\n\n    var count = this._assignRenderTargetIndices();\n\n    this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", {\n      width: engine.getRenderWidth() * this._ratio,\n      height: engine.getRenderHeight() * this._ratio\n    }, count, this._scene, {\n      generateMipMaps: false,\n      generateDepthTexture: true,\n      defaultType: 1\n    });\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.refreshRate = 1;\n    this._multiRenderTarget.renderParticles = false;\n    this._multiRenderTarget.renderList = null; // set default depth value to 1.0 (far away)\n\n    this._multiRenderTarget.onClearObservable.add(function (engine) {\n      engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);\n    });\n\n    this._resizeObserver = engine.onResizeObservable.add(function () {\n      if (_this._multiRenderTarget) {\n        _this._multiRenderTarget.resize({\n          width: engine.getRenderWidth() * _this._ratio,\n          height: engine.getRenderHeight() * _this._ratio\n        });\n      }\n    }); // Custom render function\n\n    var renderSubMesh = function (subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n      var scene = _this._scene;\n      var engine = scene.getEngine();\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        return;\n      }\n\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false; // Velocity\n\n      if (_this._enableVelocity && !_this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n          world: Matrix.Identity(),\n          viewProjection: scene.getTransformMatrix()\n        };\n\n        if (renderingMesh.skeleton) {\n          var bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n          _this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n        }\n      } // Managing instances\n\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      var world = effectiveMesh.getWorldMatrix();\n\n      if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n        engine.enableEffect(_this._effect);\n\n        renderingMesh._bind(subMesh, _this._effect, material.fillMode);\n\n        _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        _this._effect.setMatrix(\"view\", scene.getViewMatrix());\n\n        if (material) {\n          var sideOrientation;\n          var instanceDataStorage = effectiveMesh._instanceDataStorage;\n\n          if (!instanceDataStorage.isFrozen && (material.backFaceCulling || material.overrideMaterialSideOrientation !== null)) {\n            var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n\n            sideOrientation = material.overrideMaterialSideOrientation;\n\n            if (sideOrientation == null) {\n              sideOrientation = material.sideOrientation;\n            }\n\n            if (mainDeterminant < 0) {\n              sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n            }\n          } else {\n            sideOrientation = instanceDataStorage.sideOrientation;\n          }\n\n          material._preBind(_this._effect, sideOrientation); // Alpha test\n\n\n          if (material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n\n            if (alphaTexture) {\n              _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n              _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bump\n\n\n          if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n            _this._effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\n\n            _this._effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\n\n            _this._effect.setTexture(\"bumpSampler\", material.bumpTexture);\n\n            _this._effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n          } // Roughness\n\n\n          if (_this._enableReflectivity) {\n            if (material instanceof StandardMaterial && material.specularTexture) {\n              _this._effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n\n              _this._effect.setTexture(\"reflectivitySampler\", material.specularTexture);\n            } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\n              _this._effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n\n              _this._effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n            }\n          }\n        } // Bones\n\n\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          _this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n\n          if (_this._enableVelocity) {\n            _this._effect.setMatrices(\"mPreviousBones\", _this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n          }\n        } // Morph targets\n\n\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect); // Velocity\n\n        if (_this._enableVelocity) {\n          _this._effect.setMatrix(\"previousWorld\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n\n          _this._effect.setMatrix(\"previousViewProjection\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, w) {\n          return _this._effect.setMatrix(\"world\", w);\n        });\n      } // Velocity\n\n\n      if (_this._enableVelocity) {\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n        _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();\n\n        if (renderingMesh.skeleton) {\n          _this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), _this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n        }\n      }\n    };\n\n    this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var index;\n\n      if (_this._linkedWithPrePass) {\n        if (!_this._prePassRenderer.enabled) {\n          return;\n        }\n\n        _this._scene.getEngine().bindAttachments(_this._attachments);\n      }\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (_this.renderTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      }\n    };\n  }; // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  GeometryBufferRenderer.prototype._copyBonesTransformationMatrices = function (source, target) {\n    for (var i = 0; i < source.length; i++) {\n      target[i] = source[i];\n    }\n\n    return target;\n  };\n  /**\r\n   * Constant used to retrieve the depth + normal texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_INDEX)\r\n   */\n\n\n  GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE = 0;\n  /**\r\n   * Constant used to retrieve the position texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\r\n   */\n\n  GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 1;\n  /**\r\n   * Constant used to retrieve the velocity texture index in the G-Buffer textures array\r\n   * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\r\n   */\n\n  GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 2;\n  /**\r\n   * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\r\n   * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\r\n   */\n\n  GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 3;\n  /** @hidden */\n\n  GeometryBufferRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"GeometryBufferRendererSceneComponent\");\n  };\n\n  return GeometryBufferRenderer;\n}();\n\nexport { GeometryBufferRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/geometryBufferRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Color4 } from '../Maths/math.color';\r\nimport { StandardMaterial } from '../Materials/standardMaterial';\r\nimport { PBRMaterial } from '../Materials/PBR/pbrMaterial';\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { Observer } from '../Misc/observable';\r\nimport { Engine } from '../Engines/engine';\r\nimport { Nullable } from '../types';\r\nimport { Material } from '../Materials/material';\r\n\r\nimport \"../Shaders/geometry.fragment\";\r\nimport \"../Shaders/geometry.vertex\";\r\n\r\n/** @hidden */\r\ninterface ISavedTransformationMatrix {\r\n    world: Matrix;\r\n    viewProjection: Matrix;\r\n}\r\n\r\n/**\r\n * This renderer is helpfull to fill one of the render target with a geometry buffer.\r\n */\r\nexport class GeometryBufferRenderer {\r\n    /**\r\n     * Constant used to retrieve the depth + normal texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_INDEX)\r\n     */\r\n    public static readonly DEPTHNORMAL_TEXTURE_TYPE = 0;\r\n    /**\r\n     * Constant used to retrieve the position texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\r\n     */\r\n    public static readonly POSITION_TEXTURE_TYPE = 1;\r\n    /**\r\n     * Constant used to retrieve the velocity texture index in the G-Buffer textures array\r\n     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\r\n     */\r\n    public static readonly VELOCITY_TEXTURE_TYPE = 2;\r\n    /**\r\n     * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\r\n     * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\r\n     */\r\n    public static readonly REFLECTIVITY_TEXTURE_TYPE = 3;\r\n\r\n    /**\r\n     * Dictionary used to store the previous transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\r\n    public _previousTransformationMatrices: { [index: number]: ISavedTransformationMatrix } = {};\r\n    /**\r\n     * Dictionary used to store the previous bones transformation matrices of each rendered mesh\r\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\r\n     * @hidden\r\n     */\r\n    public _previousBonesTransformationMatrices: { [index: number]: Float32Array } = {};\r\n    /**\r\n     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\r\n     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\r\n     */\r\n    public excludedSkinnedMeshesFromVelocity: AbstractMesh[] = [];\r\n\r\n    /** Gets or sets a boolean indicating if transparent meshes should be rendered */\r\n    public renderTransparentMeshes = true;\r\n\r\n    private _scene: Scene;\r\n    private _resizeObserver: Nullable<Observer<Engine>> = null;\r\n    private _multiRenderTarget: MultiRenderTarget;\r\n    private _ratio: number;\r\n    private _enablePosition: boolean = false;\r\n    private _enableVelocity: boolean = false;\r\n    private _enableReflectivity: boolean = false;\r\n\r\n    private _positionIndex: number = -1;\r\n    private _velocityIndex: number = -1;\r\n    private _reflectivityIndex: number = -1;\r\n    private _depthNormalIndex: number = -1;\r\n\r\n    private _linkedWithPrePass: boolean = false;\r\n    private _prePassRenderer: PrePassRenderer;\r\n    private _attachments: number[];\r\n\r\n    protected _effect: Effect;\r\n    protected _cachedDefines: string;\r\n\r\n    /**\r\n     * @hidden\r\n     * Sets up internal structures to share outputs with PrePassRenderer\r\n     * This method should only be called by the PrePassRenderer itself\r\n     */\r\n    public _linkPrePassRenderer(prePassRenderer: PrePassRenderer) {\r\n        this._linkedWithPrePass = true;\r\n        this._prePassRenderer = prePassRenderer;\r\n\r\n        if (this._multiRenderTarget) {\r\n            // prevents clearing of the RT since it's done by prepass\r\n            this._multiRenderTarget.onClearObservable.clear();\r\n            this._multiRenderTarget.onClearObservable.add((engine) => {\r\n                // pass\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\r\n     * This method should only be called by the PrePassRenderer itself\r\n     */\r\n    public _unlinkPrePassRenderer() {\r\n        this._linkedWithPrePass = false;\r\n        this._createRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Resets the geometry buffer layout\r\n     */\r\n    public _resetLayout() {\r\n        this._enablePosition = false;\r\n        this._enableReflectivity = false;\r\n        this._enableVelocity = false;\r\n        this._attachments = [];\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Replaces a texture in the geometry buffer renderer\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _forceTextureType(geometryBufferType: number, index: number) {\r\n        if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\r\n            this._positionIndex = index;\r\n            this._enablePosition = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\r\n            this._velocityIndex = index;\r\n            this._enableVelocity = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\r\n            this._reflectivityIndex = index;\r\n            this._enableReflectivity = true;\r\n        } else if (geometryBufferType === GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE) {\r\n            this._depthNormalIndex = index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Sets texture attachments\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _setAttachments(attachments: number[]) {\r\n        this._attachments = attachments;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\r\n     * Useful when linking textures of the prepass renderer\r\n     */\r\n    public _linkInternalTexture(internalTexture: InternalTexture) {\r\n        this._multiRenderTarget._texture = internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the render list (meshes to be rendered) used in the G buffer.\r\n     */\r\n    public get renderList() {\r\n        return this._multiRenderTarget.renderList;\r\n    }\r\n\r\n    /**\r\n     * Set the render list (meshes to be rendered) used in the G buffer.\r\n     */\r\n    public set renderList(meshes: Nullable<AbstractMesh[]>) {\r\n        this._multiRenderTarget.renderList = meshes;\r\n    }\r\n\r\n    /**\r\n     * Gets wether or not G buffer are supported by the running hardware.\r\n     * This requires draw buffer supports\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._multiRenderTarget.isSupported;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given texture type in the G-Buffer textures array\r\n     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\r\n     * @returns the index of the given texture type in the G-Buffer textures array\r\n     */\r\n    public getTextureIndex(textureType: number): number {\r\n        switch (textureType) {\r\n            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE: return this._positionIndex;\r\n            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE: return this._velocityIndex;\r\n            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE: return this._reflectivityIndex;\r\n            default: return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects positions are enabled for the G buffer.\r\n     */\r\n    public get enablePosition(): boolean {\r\n        return this._enablePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not objects positions are enabled for the G buffer.\r\n     */\r\n    public set enablePosition(enable: boolean) {\r\n        this._enablePosition = enable;\r\n\r\n        // PrePass handles index and texture links\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects velocities are enabled for the G buffer.\r\n     */\r\n    public get enableVelocity(): boolean {\r\n        return this._enableVelocity;\r\n    }\r\n\r\n    /**\r\n     * Sets wether or not objects velocities are enabled for the G buffer.\r\n     */\r\n    public set enableVelocity(enable: boolean) {\r\n        this._enableVelocity = enable;\r\n\r\n        if (!enable) {\r\n            this._previousTransformationMatrices = {};\r\n        }\r\n\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if objects roughness are enabled in the G buffer.\r\n     */\r\n    public get enableReflectivity(): boolean {\r\n        return this._enableReflectivity;\r\n    }\r\n\r\n    /**\r\n     * Sets wether or not objects roughness are enabled for the G buffer.\r\n     */\r\n    public set enableReflectivity(enable: boolean) {\r\n        this._enableReflectivity = enable;\r\n\r\n        if (!this._linkedWithPrePass) {\r\n            this.dispose();\r\n            this._createRenderTargets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the scene associated with the buffer.\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used by the buffer during its creation.\r\n     * How big is the buffer related to the main canvas.\r\n     */\r\n    public get ratio(): number {\r\n        return this._ratio;\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"GeometryBufferRendererSceneComponent\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new G Buffer for the scene\r\n     * @param scene The scene the buffer belongs to\r\n     * @param ratio How big is the buffer related to the main canvas.\r\n     */\r\n    constructor(scene: Scene, ratio: number = 1) {\r\n        this._scene = scene;\r\n        this._ratio = ratio;\r\n\r\n        GeometryBufferRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        // Render target\r\n        this._createRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Checks wether everything is ready to render a submesh to the G buffer.\r\n     * @param subMesh the submesh to check readiness for\r\n     * @param useInstances is the mesh drawn using instance or not\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        var material = <any> subMesh.getMaterial();\r\n\r\n        if (material && material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        var defines = [];\r\n        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n        var mesh = subMesh.getMesh();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            let needUv = false;\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n                needUv = true;\r\n            }\r\n\r\n            if (material.bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                defines.push(\"#define BUMP\");\r\n                defines.push(\"#define BUMPDIRECTUV 0\");\r\n                needUv = true;\r\n            }\r\n\r\n            if (this._enableReflectivity) {\r\n                if (material instanceof StandardMaterial && material.specularTexture) {\r\n                    defines.push(\"#define HAS_SPECULAR\");\r\n                    needUv = true;\r\n                } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\r\n                    defines.push(\"#define HAS_REFLECTIVITY\");\r\n                    needUv = true;\r\n                }\r\n            }\r\n\r\n            if (needUv) {\r\n                defines.push(\"#define NEED_UV\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    attribs.push(VertexBuffer.UVKind);\r\n                    defines.push(\"#define UV1\");\r\n                }\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                    attribs.push(VertexBuffer.UV2Kind);\r\n                    defines.push(\"#define UV2\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // PrePass\r\n        if (this._linkedWithPrePass) {\r\n            defines.push(\"#define PREPASS\");\r\n            if (this._depthNormalIndex !== -1) {\r\n                defines.push(\"#define DEPTHNORMAL_INDEX \" + this._depthNormalIndex);\r\n                defines.push(\"#define PREPASS_DEPTHNORMAL\");\r\n            }\r\n        }\r\n\r\n        // Buffers\r\n        if (this._enablePosition) {\r\n            defines.push(\"#define POSITION\");\r\n            defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\r\n        }\r\n\r\n        if (this._enableVelocity) {\r\n            defines.push(\"#define VELOCITY\");\r\n            defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\r\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\r\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\r\n            }\r\n        }\r\n\r\n        if (this._enableReflectivity) {\r\n            defines.push(\"#define REFLECTIVITY\");\r\n            defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Setup textures count\r\n        if (this._linkedWithPrePass) {\r\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachments.length);\r\n        } else {\r\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\r\n        }\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effect = this._scene.getEngine().createEffect(\"geometry\",\r\n                attribs,\r\n                [\r\n                    \"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\", \"previousWorld\", \"previousViewProjection\", \"mPreviousBones\",\r\n                    \"morphTargetInfluences\", \"bumpMatrix\", \"reflectivityMatrix\", \"vTangentSpaceParams\", \"vBumpInfos\"\r\n                ],\r\n                [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\"], join,\r\n                undefined, undefined, undefined,\r\n                { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers });\r\n        }\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying G Buffer.\r\n     * @returns the buffer\r\n     */\r\n    public getGBuffer(): MultiRenderTarget {\r\n        return this._multiRenderTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples used to render the buffer (anti aliasing).\r\n     */\r\n    public get samples(): number {\r\n        return this._multiRenderTarget.samples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples used to render the buffer (anti aliasing).\r\n     */\r\n    public set samples(value: number) {\r\n        this._multiRenderTarget.samples = value;\r\n    }\r\n\r\n    /**\r\n     * Disposes the renderer and frees up associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._resizeObserver) {\r\n            const engine = this._scene.getEngine();\r\n            engine.onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n        this.getGBuffer().dispose();\r\n    }\r\n\r\n    private _assignRenderTargetIndices() : number {\r\n        let count = 2;\r\n\r\n        if (this._enablePosition) {\r\n            this._positionIndex = count;\r\n            count++;\r\n        }\r\n\r\n        if (this._enableVelocity) {\r\n            this._velocityIndex = count;\r\n            count++;\r\n        }\r\n\r\n        if (this._enableReflectivity) {\r\n            this._reflectivityIndex = count;\r\n            count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    protected _createRenderTargets(): void {\r\n        var engine = this._scene.getEngine();\r\n        var count = this._assignRenderTargetIndices();\r\n\r\n        this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\",\r\n            { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene,\r\n            { generateMipMaps: false, generateDepthTexture: true, defaultType: 1 });\r\n        if (!this.isSupported) {\r\n            return;\r\n        }\r\n        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._multiRenderTarget.refreshRate = 1;\r\n        this._multiRenderTarget.renderParticles = false;\r\n        this._multiRenderTarget.renderList = null;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._multiRenderTarget.onClearObservable.add((engine) => {\r\n            engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);\r\n        });\r\n\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            if (this._multiRenderTarget) {\r\n                this._multiRenderTarget.resize({ width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio });\r\n            }\r\n        });\r\n\r\n        // Custom render function\r\n        var renderSubMesh = (subMesh: SubMesh): void => {\r\n            var renderingMesh = subMesh.getRenderingMesh();\r\n            var effectiveMesh = subMesh.getEffectiveMesh();\r\n            var scene = this._scene;\r\n            var engine = scene.getEngine();\r\n            let material = <any> subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            // Velocity\r\n            if (this._enableVelocity && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\r\n                    world: Matrix.Identity(),\r\n                    viewProjection: scene.getTransformMatrix()\r\n                };\r\n\r\n                if (renderingMesh.skeleton) {\r\n                    const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\r\n                    this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\r\n                }\r\n            }\r\n\r\n            // Managing instances\r\n            var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n            var world = effectiveMesh.getWorldMatrix();\r\n\r\n            if (this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                engine.enableEffect(this._effect);\r\n                renderingMesh._bind(subMesh, this._effect, material.fillMode);\r\n\r\n                this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                this._effect.setMatrix(\"view\", scene.getViewMatrix());\r\n\r\n                if (material) {\r\n                    var sideOrientation: Nullable<number>;\r\n                    let instanceDataStorage = (effectiveMesh as Mesh)._instanceDataStorage;\r\n\r\n                    if (!instanceDataStorage.isFrozen &&\r\n                        (material.backFaceCulling || material.overrideMaterialSideOrientation !== null)) {\r\n                        let mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n                        sideOrientation = material.overrideMaterialSideOrientation;\r\n                        if (sideOrientation == null) {\r\n                            sideOrientation = material.sideOrientation;\r\n                        }\r\n                        if (mainDeterminant < 0) {\r\n                            sideOrientation = (sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation);\r\n                        }\r\n                    } else {\r\n                        sideOrientation = instanceDataStorage.sideOrientation;\r\n                    }\r\n\r\n                    material._preBind(this._effect, sideOrientation);\r\n\r\n                    // Alpha test\r\n                    if (material.needAlphaTesting()) {\r\n                        var alphaTexture = material.getAlphaTestTexture();\r\n                        if (alphaTexture) {\r\n                            this._effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bump\r\n                    if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        this._effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\r\n                        this._effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\r\n                        this._effect.setTexture(\"bumpSampler\", material.bumpTexture);\r\n                        this._effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\r\n                    }\r\n\r\n                    // Roughness\r\n                    if (this._enableReflectivity) {\r\n                        if (material instanceof StandardMaterial && material.specularTexture) {\r\n                            this._effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\r\n                            this._effect.setTexture(\"reflectivitySampler\", material.specularTexture);\r\n                        } else if (material instanceof PBRMaterial && material.reflectivityTexture) {\r\n                            this._effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\r\n                            this._effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    if (this._enableVelocity) {\r\n                        this._effect.setMatrices(\"mPreviousBones\", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);\r\n\r\n                // Velocity\r\n                if (this._enableVelocity) {\r\n                    this._effect.setMatrix(\"previousWorld\", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\r\n                    this._effect.setMatrix(\"previousViewProjection\", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering,\r\n                    (isInstance, w) => this._effect.setMatrix(\"world\", w));\r\n            }\r\n\r\n            // Velocity\r\n            if (this._enableVelocity) {\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\r\n                this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();\r\n                if (renderingMesh.skeleton) {\r\n                    this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void => {\r\n            var index;\r\n\r\n            if (this._linkedWithPrePass) {\r\n                if (!this._prePassRenderer.enabled) {\r\n                    return;\r\n                }\r\n                this._scene.getEngine().bindAttachments(this._attachments);\r\n            }\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.renderTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    private _copyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n        for (let i = 0; i < source.length; i++) {\r\n            target[i] = source[i];\r\n        }\r\n\r\n        return target;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}