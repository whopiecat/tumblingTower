{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { RibbonBuilder } from \"./ribbonBuilder\";\nimport { Path3D } from '../../Maths/math.path';\n\nMesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    shape: shape,\n    path: path,\n    scale: scale,\n    rotation: rotation,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ShapeBuilder.ExtrudeShape(name, options, scene);\n};\n\nMesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    shape: shape,\n    path: path,\n    scaleFunction: scaleFunction,\n    rotationFunction: rotationFunction,\n    ribbonCloseArray: ribbonCloseArray,\n    ribbonClosePath: ribbonClosePath,\n    cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n    sideOrientation: sideOrientation,\n    instance: instance,\n    updatable: updatable\n  };\n  return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar ShapeBuilder =\n/** @class */\nfunction () {\n  function ShapeBuilder() {}\n  /**\r\n   * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n   * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n   * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n   * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n   * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n   * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the extruded shape mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n   */\n\n\n  ShapeBuilder.ExtrudeShape = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var shape = options.shape;\n    var scale = options.scale || 1;\n    var rotation = options.rotation || 0;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var instance = options.instance || null;\n    var invertUV = options.invertUV || false;\n    return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\n  };\n  /**\r\n   * Creates an custom extruded shape mesh.\r\n   * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n   * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n   * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n   * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n   * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n   * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n   * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n   * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n   * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n   * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the custom extruded shape mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n   */\n\n\n  ShapeBuilder.ExtrudeShapeCustom = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var shape = options.shape;\n\n    var scaleFunction = options.scaleFunction || function () {\n      return 1;\n    };\n\n    var rotationFunction = options.rotationFunction || function () {\n      return 0;\n    };\n\n    var ribbonCloseArray = options.ribbonCloseArray || false;\n    var ribbonClosePath = options.ribbonClosePath || false;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var instance = options.instance;\n    var invertUV = options.invertUV || false;\n    return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\n  };\n\n  ShapeBuilder._ExtrudeShapeGeneric = function (name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\n    // extrusion geometry\n    var extrusionPathArray = function (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\n      var tangents = path3D.getTangents();\n      var normals = path3D.getNormals();\n      var binormals = path3D.getBinormals();\n      var distances = path3D.getDistances();\n      var angle = 0;\n\n      var returnScale = function () {\n        return scale !== null ? scale : 1;\n      };\n\n      var returnRotation = function () {\n        return rotation !== null ? rotation : 0;\n      };\n\n      var rotate = custom && rotateFunction ? rotateFunction : returnRotation;\n      var scl = custom && scaleFunction ? scaleFunction : returnScale;\n      var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n      var rotationMatrix = TmpVectors.Matrix[0];\n\n      for (var i = 0; i < curve.length; i++) {\n        var shapePath = new Array();\n        var angleStep = rotate(i, distances[i]);\n        var scaleRatio = scl(i, distances[i]);\n\n        for (var p = 0; p < shape.length; p++) {\n          Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n          var planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\n          var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\n          Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n          rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n          shapePath[p] = rotated;\n        }\n\n        shapePaths[index] = shapePath;\n        angle += angleStep;\n        index++;\n      } // cap\n\n\n      var capPath = function (shapePath) {\n        var pointCap = Array();\n        var barycenter = Vector3.Zero();\n        var i;\n\n        for (i = 0; i < shapePath.length; i++) {\n          barycenter.addInPlace(shapePath[i]);\n        }\n\n        barycenter.scaleInPlace(1.0 / shapePath.length);\n\n        for (i = 0; i < shapePath.length; i++) {\n          pointCap.push(barycenter);\n        }\n\n        return pointCap;\n      };\n\n      switch (cap) {\n        case Mesh.NO_CAP:\n          break;\n\n        case Mesh.CAP_START:\n          shapePaths[0] = capPath(shapePaths[2]);\n          shapePaths[1] = shapePaths[2];\n          break;\n\n        case Mesh.CAP_END:\n          shapePaths[index] = shapePaths[index - 1];\n          shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n          break;\n\n        case Mesh.CAP_ALL:\n          shapePaths[0] = capPath(shapePaths[2]);\n          shapePaths[1] = shapePaths[2];\n          shapePaths[index] = shapePaths[index - 1];\n          shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n          break;\n\n        default:\n          break;\n      }\n\n      return shapePaths;\n    };\n\n    var path3D;\n    var pathArray;\n\n    if (instance) {\n      // instance update\n      var storage = instance._creationDataStorage;\n      path3D = storage.path3D.update(curve);\n      pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\n      instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\n      return instance;\n    } // extruded shape creation\n\n\n    path3D = new Path3D(curve);\n    var newShapePaths = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\n    var extrudedGeneric = RibbonBuilder.CreateRibbon(name, {\n      pathArray: pathArray,\n      closeArray: rbCA,\n      closePath: rbCP,\n      updatable: updtbl,\n      sideOrientation: side,\n      invertUV: invertUV,\n      frontUVs: frontUVs || undefined,\n      backUVs: backUVs || undefined\n    }, scene);\n    extrudedGeneric._creationDataStorage.pathArray = pathArray;\n    extrudedGeneric._creationDataStorage.path3D = path3D;\n    extrudedGeneric._creationDataStorage.cap = cap;\n    return extrudedGeneric;\n  };\n\n  return ShapeBuilder;\n}();\n\nexport { ShapeBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/shapeBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from '../../Maths/math.path';\r\n\r\nMesh.ExtrudeShape = (name: string, shape: Vector3[], path: Vector3[], scale: number, rotation: number, cap: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShape(name, options, scene);\r\n};\r\n\r\nMesh.ExtrudeShapeCustom = (name: string, shape: Vector3[], path: Vector3[], scaleFunction: Function, rotationFunction: Function, ribbonCloseArray: boolean, ribbonClosePath: boolean, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n\r\n    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class ShapeBuilder {\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShape(name: string, options: { shape: Vector3[], path: Vector3[], scale?: number, rotation?: number, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scale = options.scale || 1;\r\n        var rotation = options.rotation || 0;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance || null;\r\n        var invertUV = options.invertUV || false;\r\n\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    public static ExtrudeShapeCustom(name: string, options: { shape: Vector3[], path: Vector3[], scaleFunction?: any, rotationFunction?: any, ribbonCloseArray?: boolean, ribbonClosePath?: boolean, cap?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scaleFunction = options.scaleFunction || (() => { return 1; });\r\n        var rotationFunction = options.rotationFunction || (() => { return 0; });\r\n        var ribbonCloseArray = options.ribbonCloseArray || false;\r\n        var ribbonClosePath = options.ribbonClosePath || false;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || Mesh.NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    }\r\n\r\n    private static _ExtrudeShapeGeneric(name: string, shape: Vector3[], curve: Vector3[], scale: Nullable<number>, rotation: Nullable<number>, scaleFunction: Nullable<{ (i: number, distance: number): number; }>,\r\n        rotateFunction: Nullable<{ (i: number, distance: number): number; }>, rbCA: boolean, rbCP: boolean, cap: number, custom: boolean,\r\n        scene: Nullable<Scene>, updtbl: boolean, side: number, instance: Nullable<Mesh>, invertUV: boolean, frontUVs: Nullable<Vector4>, backUVs: Nullable<Vector4>): Mesh {\r\n        // extrusion geometry\r\n        var extrusionPathArray = (shape: Vector3[], curve: Vector3[], path3D: Path3D, shapePaths: Vector3[][], scale: Nullable<number>, rotation: Nullable<number>,\r\n            scaleFunction: Nullable<{ (i: number, distance: number): number; }>, rotateFunction: Nullable<{ (i: number, distance: number): number; }>, cap: number, custom: boolean) => {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var binormals = path3D.getBinormals();\r\n            var distances = path3D.getDistances();\r\n\r\n            var angle = 0;\r\n            var returnScale: { (i: number, distance: number): number; } = () => { return scale !== null ? scale : 1; };\r\n            var returnRotation: { (i: number, distance: number): number; } = () => { return rotation !== null ? rotation : 0; };\r\n            var rotate: { (i: number, distance: number): number; } = custom && rotateFunction ? rotateFunction : returnRotation;\r\n            var scl: { (i: number, distance: number): number; } = custom && scaleFunction ? scaleFunction : returnScale;\r\n            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;\r\n            var rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n\r\n            for (var i = 0; i < curve.length; i++) {\r\n                var shapePath = new Array<Vector3>();\r\n                var angleStep = rotate(i, distances[i]);\r\n                var scaleRatio = scl(i, distances[i]);\r\n                for (var p = 0; p < shape.length; p++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                    var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));\r\n                    var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                    shapePath[p] = rotated;\r\n                }\r\n                shapePaths[index] = shapePath;\r\n                angle += angleStep;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = (shapePath: Vector3[]) => {\r\n                var pointCap = Array<Vector3>();\r\n                var barycenter = Vector3.Zero();\r\n                var i: number;\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    barycenter.addInPlace(shapePath[i]);\r\n                }\r\n                barycenter.scaleInPlace(1.0 / shapePath.length);\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    pointCap.push(barycenter);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return shapePaths;\r\n        };\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // instance update\r\n            let storage = instance._creationDataStorage!;\r\n            path3D = storage.path3D.update(curve);\r\n            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n            instance = Mesh.CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\r\n\r\n            return instance;\r\n        }\r\n        // extruded shape creation\r\n        path3D = <any>new Path3D(curve);\r\n        var newShapePaths = new Array<Array<Vector3>>();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n        var extrudedGeneric = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);\r\n        extrudedGeneric._creationDataStorage!.pathArray = pathArray;\r\n        extrudedGeneric._creationDataStorage!.path3D = path3D;\r\n        extrudedGeneric._creationDataStorage!.cap = cap;\r\n\r\n        return extrudedGeneric;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}