{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { InputBlock } from '../Input/inputBlock';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\nimport { CubeTexture } from '../../../Textures/cubeTexture';\nimport { Texture } from '../../../Textures/texture';\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\n\nvar ReflectionTextureBaseBlock =\n/** @class */\nfunction (_super) {\n  __extends(ReflectionTextureBaseBlock, _super);\n  /**\r\n   * Create a new ReflectionTextureBaseBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function ReflectionTextureBaseBlock(name) {\n    return _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.getClassName = function () {\n    return \"ReflectionTextureBaseBlock\";\n  };\n\n  ReflectionTextureBaseBlock.prototype._getTexture = function () {\n    return this.texture;\n  };\n\n  ReflectionTextureBaseBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.world.isConnected) {\n      var worldInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.World;\n      });\n\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n\n      worldInput.output.connectTo(this.world);\n    }\n\n    if (this.view && !this.view.isConnected) {\n      var viewInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.View;\n      });\n\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n\n      viewInput.output.connectTo(this.view);\n    }\n  };\n\n  ReflectionTextureBaseBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    var texture = this._getTexture();\n\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  };\n\n  ReflectionTextureBaseBlock.prototype.isReady = function () {\n    var texture = this._getTexture();\n\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ReflectionTextureBaseBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    var texture = this._getTexture();\n\n    if (!mesh || !texture) {\n      return;\n    }\n\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n  };\n  /**\r\n   * Gets the code to inject in the vertex shader\r\n   * @param state current state of the node material building\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleVertexSide = function (state) {\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n\n    var code = \"\";\n    var worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\n\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += worldPosVaryingName + \" = \" + this.worldPosition.associatedVariableName + \";\\r\\n\";\n    }\n\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n\n    if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += \"#ifdef \" + this._defineSkyboxName + \"\\r\\n\";\n      code += this._positionUVWName + \" = \" + this.position.associatedVariableName + \".xyz;\\r\\n\";\n      code += \"#endif\\r\\n\";\n    }\n\n    if (state._emitVaryingFromString(this._directionWName, \"vec3\", \"defined(\" + this._defineEquirectangularFixedName + \") || defined(\" + this._defineMirroredEquirectangularFixedName + \")\")) {\n      code += \"#if defined(\" + this._defineEquirectangularFixedName + \") || defined(\" + this._defineMirroredEquirectangularFixedName + \")\\r\\n\";\n      code += this._directionWName + \" = normalize(vec3(\" + this.world.associatedVariableName + \" * vec4(\" + this.position.associatedVariableName + \".xyz, 0.0)));\\r\\n\";\n      code += \"#endif\\r\\n\";\n    }\n\n    return code;\n  };\n  /**\r\n   * Handles the inits for the fragment code path\r\n   * @param state node material build state\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideInits = function (state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this); // Samplers\n\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += \"#ifdef \" + this._define3DName + \"\\r\\n\";\n    state._samplerDeclaration += \"uniform samplerCube \" + this._cubeSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#else\\r\\n\";\n    state._samplerDeclaration += \"uniform sampler2D \" + this._2DSamplerName + \";\\r\\n\";\n    state._samplerDeclaration += \"#endif\\r\\n\"; // Fragment\n\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    var comments = \"//\" + this.name;\n\n    state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n  };\n  /**\r\n   * Generates the reflection coords code for the fragment code path\r\n   * @param worldNormalVarName name of the world normal variable\r\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionCoords = function (worldNormalVarName, worldPos, onlyReflectionVector) {\n    if (onlyReflectionVector === void 0) {\n      onlyReflectionVector = false;\n    }\n\n    if (!worldPos) {\n      worldPos = \"v_\" + this.worldPosition.associatedVariableName;\n    }\n\n    var reflectionMatrix = this._reflectionMatrixName;\n    var direction = \"normalize(\" + this._directionWName + \")\";\n    var positionUVW = \"\" + this._positionUVWName;\n    var vEyePosition = \"\" + this.cameraPosition.associatedVariableName;\n    var view = \"\" + this.view.associatedVariableName;\n    worldNormalVarName += \".xyz\";\n    var code = \"\\n            #ifdef \" + this._defineMirroredEquirectangularFixedName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeMirroredFixedEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + direction + \");\\n            #endif\\n\\n            #ifdef \" + this._defineEquirectangularFixedName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeFixedEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + direction + \");\\n            #endif\\n\\n            #ifdef \" + this._defineEquirectangularName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeEquirectangularCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineSphericalName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeSphericalCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + view + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._definePlanarName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computePlanarCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineCubicName + \"\\n                #ifdef \" + this._defineLocalCubicName + \"\\n                    vec3 \" + this._reflectionVectorName + \" = computeCubicLocalCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \", vReflectionSize, vReflectionPosition);\\n                #else\\n                vec3 \" + this._reflectionVectorName + \" = computeCubicCoords(\" + worldPos + \", \" + worldNormalVarName + \", \" + vEyePosition + \".xyz, \" + reflectionMatrix + \");\\n                #endif\\n            #endif\\n\\n            #ifdef \" + this._defineProjectionName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeProjectionCoords(\" + worldPos + \", \" + view + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineSkyboxName + \"\\n                vec3 \" + this._reflectionVectorName + \" = computeSkyBoxCoords(\" + positionUVW + \", \" + reflectionMatrix + \");\\n            #endif\\n\\n            #ifdef \" + this._defineExplicitName + \"\\n                vec3 \" + this._reflectionVectorName + \" = vec3(0, 0, 0);\\n            #endif\\n\\n            #ifdef \" + this._defineOppositeZ + \"\\n                \" + this._reflectionVectorName + \".z *= -1.0;\\n            #endif\\r\\n\";\n\n    if (!onlyReflectionVector) {\n      code += \"\\n                #ifdef \" + this._define3DName + \"\\n                    vec3 \" + this._reflectionCoordsName + \" = \" + this._reflectionVectorName + \";\\n                #else\\n                    vec2 \" + this._reflectionCoordsName + \" = \" + this._reflectionVectorName + \".xy;\\n                    #ifdef \" + this._defineProjectionName + \"\\n                        \" + this._reflectionCoordsName + \" /= \" + this._reflectionVectorName + \".z;\\n                    #endif\\n                    \" + this._reflectionCoordsName + \".y = 1.0 - \" + this._reflectionCoordsName + \".y;\\n                #endif\\r\\n\";\n    }\n\n    return code;\n  };\n  /**\r\n   * Generates the reflection color code for the fragment code path\r\n   * @param lodVarName name of the lod variable\r\n   * @param swizzleLookupTexture swizzle to use for the final color variable\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.handleFragmentSideCodeReflectionColor = function (lodVarName, swizzleLookupTexture) {\n    if (swizzleLookupTexture === void 0) {\n      swizzleLookupTexture = \".rgb\";\n    }\n\n    var colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    var code = colorType + \" \" + this._reflectionColorName + \";\\n            #ifdef \" + this._define3DName + \"\\r\\n\";\n\n    if (lodVarName) {\n      code += this._reflectionColorName + \" = textureCubeLodEXT(\" + this._cubeSamplerName + \", \" + this._reflectionVectorName + \", \" + lodVarName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    } else {\n      code += this._reflectionColorName + \" = textureCube(\" + this._cubeSamplerName + \", \" + this._reflectionVectorName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    }\n\n    code += \"\\n            #else\\r\\n\";\n\n    if (lodVarName) {\n      code += this._reflectionColorName + \" = texture2DLodEXT(\" + this._2DSamplerName + \", \" + this._reflectionCoordsName + \", \" + lodVarName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    } else {\n      code += this._reflectionColorName + \" = texture2D(\" + this._2DSamplerName + \", \" + this._reflectionCoordsName + \")\" + swizzleLookupTexture + \";\\r\\n\";\n    }\n\n    code += \"#endif\\r\\n\";\n    return code;\n  };\n  /**\r\n   * Generates the code corresponding to the connected output points\r\n   * @param state node material build state\r\n   * @param varName name of the variable to output\r\n   * @returns the shader code\r\n   */\n\n\n  ReflectionTextureBaseBlock.prototype.writeOutputs = function (state, varName) {\n    var code = \"\";\n\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (output.hasEndpoints) {\n          code += this._declareOutput(output, state) + \" = \" + varName + \".\" + output.name + \";\\r\\n\";\n        }\n      }\n    }\n\n    return code;\n  };\n\n  ReflectionTextureBaseBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    return this;\n  };\n\n  ReflectionTextureBaseBlock.prototype._dumpPropertiesCode = function () {\n    if (!this.texture) {\n      return \"\";\n    }\n\n    var codeString;\n\n    if (this.texture.isCube) {\n      codeString = this._codeVariableName + \".texture = new BABYLON.CubeTexture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n    } else {\n      codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\");\\r\\n\";\n    }\n\n    codeString += this._codeVariableName + \".texture.coordinatesMode = \" + this.texture.coordinatesMode + \";\\r\\n\";\n    return codeString;\n  };\n\n  ReflectionTextureBaseBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ReflectionTextureBaseBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n  };\n\n  return ReflectionTextureBaseBlock;\n}(NodeMaterialBlock);\n\nexport { ReflectionTextureBaseBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.ReflectionTextureBaseBlock\"] = ReflectionTextureBaseBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { BaseTexture } from '../../../Textures/baseTexture';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { Effect } from '../../../effect';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { Nullable } from '../../../../types';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { Scene } from '../../../../scene';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\r\n\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from '../../../Textures/cubeTexture';\r\nimport { Texture } from '../../../Textures/texture';\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @hidden */\r\n    public _define3DName: string;\r\n    /** @hidden */\r\n    public _defineCubicName: string;\r\n    /** @hidden */\r\n    public _defineExplicitName: string;\r\n    /** @hidden */\r\n    public _defineProjectionName: string;\r\n    /** @hidden */\r\n    public _defineLocalCubicName: string;\r\n    /** @hidden */\r\n    public _defineSphericalName: string;\r\n    /** @hidden */\r\n    public _definePlanarName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularName: string;\r\n    /** @hidden */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @hidden */\r\n    public _defineSkyboxName: string;\r\n    /** @hidden */\r\n    public _defineOppositeZ: string;\r\n    /** @hidden */\r\n    public _cubeSamplerName: string;\r\n    /** @hidden */\r\n    public _2DSamplerName: string;\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @hidden */\r\n    public _reflectionCoordsName: string;\r\n    /** @hidden */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        let worldPosVaryingName = \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\r\n            code += `${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\r\n            code += `${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        let comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [\r\n                { search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }\r\n            ]\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false): string {\r\n        if (!worldPos) {\r\n            worldPos = `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        let reflectionMatrix = this._reflectionMatrixName;\r\n        let direction = `normalize(${this._directionWName})`;\r\n        let positionUVW = `${this._positionUVWName}`;\r\n        let vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        let view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, vReflectionSize, vReflectionPosition);\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\r\n\r\n            #ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\r\\n`;\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : (swizzleLookupTexture.length - 1));\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `#endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (var output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        if (!this.texture) {\r\n            return \"\";\r\n        }\r\n\r\n        let codeString: string;\r\n\r\n        if (this.texture.isCube) {\r\n            codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\r\\n`;\r\n        } else {\r\n            codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\r\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        if (this.texture) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ReflectionTextureBaseBlock\"] = ReflectionTextureBaseBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}