{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\n/**\r\n * A list of the currently available features without referencing them\r\n */\n\nvar WebXRFeatureName =\n/** @class */\nfunction () {\n  function WebXRFeatureName() {}\n  /**\r\n   * The name of the anchor system feature\r\n   */\n\n\n  WebXRFeatureName.ANCHOR_SYSTEM = \"xr-anchor-system\";\n  /**\r\n   * The name of the background remover feature\r\n   */\n\n  WebXRFeatureName.BACKGROUND_REMOVER = \"xr-background-remover\";\n  /**\r\n   * The name of the hit test feature\r\n   */\n\n  WebXRFeatureName.HIT_TEST = \"xr-hit-test\";\n  /**\r\n   * physics impostors for xr controllers feature\r\n   */\n\n  WebXRFeatureName.PHYSICS_CONTROLLERS = \"xr-physics-controller\";\n  /**\r\n   * The name of the plane detection feature\r\n   */\n\n  WebXRFeatureName.PLANE_DETECTION = \"xr-plane-detection\";\n  /**\r\n   * The name of the pointer selection feature\r\n   */\n\n  WebXRFeatureName.POINTER_SELECTION = \"xr-controller-pointer-selection\";\n  /**\r\n   * The name of the teleportation feature\r\n   */\n\n  WebXRFeatureName.TELEPORTATION = \"xr-controller-teleportation\";\n  /**\r\n   * The name of the feature points feature.\r\n   */\n\n  WebXRFeatureName.FEATURE_POINTS = \"xr-feature-points\";\n  /**\r\n   * The name of the hand tracking feature.\r\n   */\n\n  WebXRFeatureName.HAND_TRACKING = \"xr-hand-tracking\";\n  return WebXRFeatureName;\n}();\n\nexport { WebXRFeatureName };\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\n\nvar WebXRFeaturesManager =\n/** @class */\nfunction () {\n  /**\r\n   * constructs a new features manages.\r\n   *\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   */\n  function WebXRFeaturesManager(_xrSessionManager) {\n    var _this = this;\n\n    this._xrSessionManager = _xrSessionManager;\n    this._features = {}; // when session starts / initialized - attach\n\n    this._xrSessionManager.onXRSessionInit.add(function () {\n      _this.getEnabledFeatures().forEach(function (featureName) {\n        var feature = _this._features[featureName];\n\n        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\n          _this.attachFeature(featureName);\n        }\n      });\n    }); // when session ends - detach\n\n\n    this._xrSessionManager.onXRSessionEnded.add(function () {\n      _this.getEnabledFeatures().forEach(function (featureName) {\n        var feature = _this._features[featureName];\n\n        if (feature.enabled && feature.featureImplementation.attached) {\n          // detach, but don't disable!\n          _this.detachFeature(featureName);\n        }\n      });\n    });\n  }\n  /**\r\n   * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n   * Mainly used internally.\r\n   *\r\n   * @param featureName the name of the feature to register\r\n   * @param constructorFunction the function used to construct the module\r\n   * @param version the (babylon) version of the module\r\n   * @param stable is that a stable version of this module\r\n   */\n\n\n  WebXRFeaturesManager.AddWebXRFeature = function (featureName, constructorFunction, version, stable) {\n    if (version === void 0) {\n      version = 1;\n    }\n\n    if (stable === void 0) {\n      stable = false;\n    }\n\n    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || {\n      latest: version\n    };\n\n    if (version > this._AvailableFeatures[featureName].latest) {\n      this._AvailableFeatures[featureName].latest = version;\n    }\n\n    if (stable) {\n      this._AvailableFeatures[featureName].stable = version;\n    }\n\n    this._AvailableFeatures[featureName][version] = constructorFunction;\n  };\n  /**\r\n   * Returns a constructor of a specific feature.\r\n   *\r\n   * @param featureName the name of the feature to construct\r\n   * @param version the version of the feature to load\r\n   * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n   * @param options optional options provided to the module.\r\n   * @returns a function that, when called, will return a new instance of this feature\r\n   */\n\n\n  WebXRFeaturesManager.ConstructFeature = function (featureName, version, xrSessionManager, options) {\n    if (version === void 0) {\n      version = 1;\n    }\n\n    var constructorFunction = this._AvailableFeatures[featureName][version];\n\n    if (!constructorFunction) {\n      // throw an error? return nothing?\n      throw new Error(\"feature not found\");\n    }\n\n    return constructorFunction(xrSessionManager, options);\n  };\n  /**\r\n   * Can be used to return the list of features currently registered\r\n   *\r\n   * @returns an Array of available features\r\n   */\n\n\n  WebXRFeaturesManager.GetAvailableFeatures = function () {\n    return Object.keys(this._AvailableFeatures);\n  };\n  /**\r\n   * Gets the versions available for a specific feature\r\n   * @param featureName the name of the feature\r\n   * @returns an array with the available versions\r\n   */\n\n\n  WebXRFeaturesManager.GetAvailableVersions = function (featureName) {\n    return Object.keys(this._AvailableFeatures[featureName]);\n  };\n  /**\r\n   * Return the latest unstable version of this feature\r\n   * @param featureName the name of the feature to search\r\n   * @returns the version number. if not found will return -1\r\n   */\n\n\n  WebXRFeaturesManager.GetLatestVersionOfFeature = function (featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;\n  };\n  /**\r\n   * Return the latest stable version of this feature\r\n   * @param featureName the name of the feature to search\r\n   * @returns the version number. if not found will return -1\r\n   */\n\n\n  WebXRFeaturesManager.GetStableVersionOfFeature = function (featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;\n  };\n  /**\r\n   * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n   * Can be used during a session to start a feature\r\n   * @param featureName the name of feature to attach\r\n   */\n\n\n  WebXRFeaturesManager.prototype.attachFeature = function (featureName) {\n    var feature = this._features[featureName];\n\n    if (feature && feature.enabled && !feature.featureImplementation.attached) {\n      feature.featureImplementation.attach();\n    }\n  };\n  /**\r\n   * Can be used inside a session or when the session ends to detach a specific feature\r\n   * @param featureName the name of the feature to detach\r\n   */\n\n\n  WebXRFeaturesManager.prototype.detachFeature = function (featureName) {\n    var feature = this._features[featureName];\n\n    if (feature && feature.featureImplementation.attached) {\n      feature.featureImplementation.detach();\n    }\n  };\n  /**\r\n   * Used to disable an already-enabled feature\r\n   * The feature will be disposed and will be recreated once enabled.\r\n   * @param featureName the feature to disable\r\n   * @returns true if disable was successful\r\n   */\n\n\n  WebXRFeaturesManager.prototype.disableFeature = function (featureName) {\n    var name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    var feature = this._features[name];\n\n    if (feature && feature.enabled) {\n      feature.enabled = false;\n      this.detachFeature(name);\n      feature.featureImplementation.dispose();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * dispose this features manager\r\n   */\n\n\n  WebXRFeaturesManager.prototype.dispose = function () {\n    var _this = this;\n\n    this.getEnabledFeatures().forEach(function (feature) {\n      _this.disableFeature(feature);\n\n      _this._features[feature].featureImplementation.dispose();\n    });\n  };\n  /**\r\n   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n   *\r\n   * @param featureName the name of the feature to load or the class of the feature\r\n   * @param version optional version to load. if not provided the latest version will be enabled\r\n   * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n   * @returns a new constructed feature or throws an error if feature not found.\r\n   */\n\n\n  WebXRFeaturesManager.prototype.enableFeature = function (featureName, version, moduleOptions, attachIfPossible, required) {\n    var _this = this;\n\n    if (version === void 0) {\n      version = \"latest\";\n    }\n\n    if (moduleOptions === void 0) {\n      moduleOptions = {};\n    }\n\n    if (attachIfPossible === void 0) {\n      attachIfPossible = true;\n    }\n\n    if (required === void 0) {\n      required = true;\n    }\n\n    var name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    var versionToLoad = 0;\n\n    if (typeof version === \"string\") {\n      if (!version) {\n        throw new Error(\"Error in provided version - \" + name + \" (\" + version + \")\");\n      }\n\n      if (version === \"stable\") {\n        versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\n      } else if (version === \"latest\") {\n        versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\n      } else {\n        // try loading the number the string represents\n        versionToLoad = +version;\n      }\n\n      if (versionToLoad === -1 || isNaN(versionToLoad)) {\n        throw new Error(\"feature not found - \" + name + \" (\" + version + \")\");\n      }\n    } else {\n      versionToLoad = version;\n    } // check if already initialized\n\n\n    var feature = this._features[name];\n    var constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\n\n    if (!constructFunction) {\n      // report error?\n      throw new Error(\"feature not found - \" + name);\n    }\n    /* If the feature is already enabled, detach and dispose it, and create a new one */\n\n\n    if (feature) {\n      this.disableFeature(name);\n    }\n\n    var constructed = constructFunction();\n\n    if (constructed.dependsOn) {\n      var dependentsFound = constructed.dependsOn.every(function (featureName) {\n        return !!_this._features[featureName];\n      });\n\n      if (!dependentsFound) {\n        throw new Error(\"Dependant features missing. Make sure the following features are enabled - \" + constructed.dependsOn.join(\", \"));\n      }\n    }\n\n    if (constructed.isCompatible()) {\n      this._features[name] = {\n        featureImplementation: constructed,\n        enabled: true,\n        version: versionToLoad,\n        required: required\n      };\n\n      if (attachIfPossible) {\n        // if session started already, request and enable\n        if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\n          // enable feature\n          this.attachFeature(name);\n        }\n      } else {\n        // disable auto-attach when session starts\n        this._features[name].featureImplementation.disableAutoAttach = true;\n      }\n\n      return this._features[name].featureImplementation;\n    } else {\n      if (required) {\n        throw new Error(\"required feature not compatible\");\n      } else {\n        Tools.Warn(\"Feature \" + name + \" not compatible with the current environment/browser and was not enabled.\");\n        return constructed;\n      }\n    }\n  };\n  /**\r\n   * get the implementation of an enabled feature.\r\n   * @param featureName the name of the feature to load\r\n   * @returns the feature class, if found\r\n   */\n\n\n  WebXRFeaturesManager.prototype.getEnabledFeature = function (featureName) {\n    return this._features[featureName] && this._features[featureName].featureImplementation;\n  };\n  /**\r\n   * Get the list of enabled features\r\n   * @returns an array of enabled features\r\n   */\n\n\n  WebXRFeaturesManager.prototype.getEnabledFeatures = function () {\n    return Object.keys(this._features);\n  };\n  /**\r\n   * This function will exten the session creation configuration object with enabled features.\r\n   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n   * according to the defined \"required\" variable, provided during enableFeature call\r\n   * @param xrSessionInit the xr Session init object to extend\r\n   *\r\n   * @returns an extended XRSessionInit object\r\n   */\n\n\n  WebXRFeaturesManager.prototype.extendXRSessionInitObject = function (xrSessionInit) {\n    var _this = this;\n\n    var enabledFeatures = this.getEnabledFeatures();\n    enabledFeatures.forEach(function (featureName) {\n      var feature = _this._features[featureName];\n      var nativeName = feature.featureImplementation.xrNativeFeatureName;\n\n      if (nativeName) {\n        if (feature.required) {\n          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\n\n          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.requiredFeatures.push(nativeName);\n          }\n        } else {\n          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\n\n          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.optionalFeatures.push(nativeName);\n          }\n        }\n      }\n    });\n    return xrSessionInit;\n  };\n\n  WebXRFeaturesManager._AvailableFeatures = {};\n  return WebXRFeaturesManager;\n}();\n\nexport { WebXRFeaturesManager };","map":{"version":3,"sources":["../../../sourceES6/core/XR/webXRFeaturesManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { IDisposable } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\n/**\r\n * Defining the interface required for a (webxr) feature\r\n */\r\nexport interface IWebXRFeature extends IDisposable {\r\n    /**\r\n     * Is this feature attached\r\n     */\r\n    attached: boolean;\r\n    /**\r\n     * Should auto-attach be disabled?\r\n     */\r\n    disableAutoAttach: boolean;\r\n\r\n    /**\r\n     * Attach the feature to the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @param force should attachment be forced (even when already attached)\r\n     * @returns true if successful.\r\n     */\r\n    attach(force?: boolean): boolean;\r\n    /**\r\n     * Detach the feature from the session\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    detach(): boolean;\r\n\r\n    /**\r\n     * This function will be executed during before enabling the feature and can be used to not-allow enabling it.\r\n     * Note that at this point the session has NOT started, so this is purely checking if the browser supports it\r\n     *\r\n     * @returns whether or not the feature is compatible in this environment\r\n     */\r\n    isCompatible(): boolean;\r\n\r\n    /**\r\n     * Was this feature disposed;\r\n     */\r\n    isDisposed: boolean;\r\n\r\n    /**\r\n     * The name of the native xr feature name, if applicable (like anchor, hit-test, or hand-tracking)\r\n     */\r\n    xrNativeFeatureName?: string;\r\n\r\n    /**\r\n     * A list of (Babylon WebXR) features this feature depends on\r\n     */\r\n    dependsOn?: string[];\r\n}\r\n\r\n/**\r\n * A list of the currently available features without referencing them\r\n */\r\nexport class WebXRFeatureName {\r\n    /**\r\n     * The name of the anchor system feature\r\n     */\r\n    public static readonly ANCHOR_SYSTEM = \"xr-anchor-system\";\r\n    /**\r\n     * The name of the background remover feature\r\n     */\r\n    public static readonly BACKGROUND_REMOVER = \"xr-background-remover\";\r\n    /**\r\n     * The name of the hit test feature\r\n     */\r\n    public static readonly HIT_TEST = \"xr-hit-test\";\r\n    /**\r\n     * physics impostors for xr controllers feature\r\n     */\r\n    public static readonly PHYSICS_CONTROLLERS = \"xr-physics-controller\";\r\n    /**\r\n     * The name of the plane detection feature\r\n     */\r\n    public static readonly PLANE_DETECTION = \"xr-plane-detection\";\r\n    /**\r\n     * The name of the pointer selection feature\r\n     */\r\n    public static readonly POINTER_SELECTION = \"xr-controller-pointer-selection\";\r\n    /**\r\n     * The name of the teleportation feature\r\n     */\r\n    public static readonly TELEPORTATION = \"xr-controller-teleportation\";\r\n    /**\r\n     * The name of the feature points feature.\r\n     */\r\n    public static readonly FEATURE_POINTS = \"xr-feature-points\";\r\n    /**\r\n     * The name of the hand tracking feature.\r\n     */\r\n    public static readonly HAND_TRACKING = \"xr-hand-tracking\";\r\n}\r\n\r\n/**\r\n * Defining the constructor of a feature. Used to register the modules.\r\n */\r\nexport type WebXRFeatureConstructor = (xrSessionManager: WebXRSessionManager, options?: any) => () => IWebXRFeature;\r\n\r\n/**\r\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\r\n * It is mainly used in AR sessions.\r\n *\r\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\r\n */\r\nexport class WebXRFeaturesManager implements IDisposable {\r\n    private static readonly _AvailableFeatures: {\r\n        [name: string]: {\r\n            stable: number;\r\n            latest: number;\r\n            [version: number]: WebXRFeatureConstructor;\r\n        };\r\n    } = {};\r\n\r\n    private _features: {\r\n        [name: string]: {\r\n            featureImplementation: IWebXRFeature;\r\n            version: number;\r\n            enabled: boolean;\r\n            required: boolean;\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * constructs a new features manages.\r\n     *\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     */\r\n    constructor(private _xrSessionManager: WebXRSessionManager) {\r\n        // when session starts / initialized - attach\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\r\n                    this.attachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n\r\n        // when session ends - detach\r\n        this._xrSessionManager.onXRSessionEnded.add(() => {\r\n            this.getEnabledFeatures().forEach((featureName) => {\r\n                const feature = this._features[featureName];\r\n                if (feature.enabled && feature.featureImplementation.attached) {\r\n                    // detach, but don't disable!\r\n                    this.detachFeature(featureName);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to register a module. After calling this function a developer can use this feature in the scene.\r\n     * Mainly used internally.\r\n     *\r\n     * @param featureName the name of the feature to register\r\n     * @param constructorFunction the function used to construct the module\r\n     * @param version the (babylon) version of the module\r\n     * @param stable is that a stable version of this module\r\n     */\r\n    public static AddWebXRFeature(featureName: string, constructorFunction: WebXRFeatureConstructor, version: number = 1, stable: boolean = false) {\r\n        this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || { latest: version };\r\n        if (version > this._AvailableFeatures[featureName].latest) {\r\n            this._AvailableFeatures[featureName].latest = version;\r\n        }\r\n        if (stable) {\r\n            this._AvailableFeatures[featureName].stable = version;\r\n        }\r\n        this._AvailableFeatures[featureName][version] = constructorFunction;\r\n    }\r\n\r\n    /**\r\n     * Returns a constructor of a specific feature.\r\n     *\r\n     * @param featureName the name of the feature to construct\r\n     * @param version the version of the feature to load\r\n     * @param xrSessionManager the xrSessionManager. Used to construct the module\r\n     * @param options optional options provided to the module.\r\n     * @returns a function that, when called, will return a new instance of this feature\r\n     */\r\n    public static ConstructFeature(featureName: string, version: number = 1, xrSessionManager: WebXRSessionManager, options?: any): () => IWebXRFeature {\r\n        const constructorFunction = this._AvailableFeatures[featureName][version];\r\n        if (!constructorFunction) {\r\n            // throw an error? return nothing?\r\n            throw new Error(\"feature not found\");\r\n        }\r\n\r\n        return constructorFunction(xrSessionManager, options);\r\n    }\r\n\r\n    /**\r\n     * Can be used to return the list of features currently registered\r\n     *\r\n     * @returns an Array of available features\r\n     */\r\n    public static GetAvailableFeatures() {\r\n        return Object.keys(this._AvailableFeatures);\r\n    }\r\n\r\n    /**\r\n     * Gets the versions available for a specific feature\r\n     * @param featureName the name of the feature\r\n     * @returns an array with the available versions\r\n     */\r\n    public static GetAvailableVersions(featureName: string) {\r\n        return Object.keys(this._AvailableFeatures[featureName]);\r\n    }\r\n\r\n    /**\r\n     * Return the latest unstable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetLatestVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest) || -1;\r\n    }\r\n\r\n    /**\r\n     * Return the latest stable version of this feature\r\n     * @param featureName the name of the feature to search\r\n     * @returns the version number. if not found will return -1\r\n     */\r\n    public static GetStableVersionOfFeature(featureName: string): number {\r\n        return (this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable) || -1;\r\n    }\r\n\r\n    /**\r\n     * Attach a feature to the current session. Mainly used when session started to start the feature effect.\r\n     * Can be used during a session to start a feature\r\n     * @param featureName the name of feature to attach\r\n     */\r\n    public attachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.enabled && !feature.featureImplementation.attached) {\r\n            feature.featureImplementation.attach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used inside a session or when the session ends to detach a specific feature\r\n     * @param featureName the name of the feature to detach\r\n     */\r\n    public detachFeature(featureName: string) {\r\n        const feature = this._features[featureName];\r\n        if (feature && feature.featureImplementation.attached) {\r\n            feature.featureImplementation.detach();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used to disable an already-enabled feature\r\n     * The feature will be disposed and will be recreated once enabled.\r\n     * @param featureName the feature to disable\r\n     * @returns true if disable was successful\r\n     */\r\n    public disableFeature(featureName: string | { Name: string }): boolean {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        const feature = this._features[name];\r\n        if (feature && feature.enabled) {\r\n            feature.enabled = false;\r\n            this.detachFeature(name);\r\n            feature.featureImplementation.dispose();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * dispose this features manager\r\n     */\r\n    public dispose(): void {\r\n        this.getEnabledFeatures().forEach((feature) => {\r\n            this.disableFeature(feature);\r\n            this._features[feature].featureImplementation.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\r\n     * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\r\n     *\r\n     * @param featureName the name of the feature to load or the class of the feature\r\n     * @param version optional version to load. if not provided the latest version will be enabled\r\n     * @param moduleOptions options provided to the module. Ses the module documentation / constructor\r\n     * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\r\n     * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\r\n     * @returns a new constructed feature or throws an error if feature not found.\r\n     */\r\n    public enableFeature(featureName: string | { Name: string }, version: number | string = \"latest\", moduleOptions: any = {}, attachIfPossible: boolean = true, required: boolean = true): IWebXRFeature {\r\n        const name = typeof featureName === \"string\" ? featureName : featureName.Name;\r\n        let versionToLoad = 0;\r\n        if (typeof version === \"string\") {\r\n            if (!version) {\r\n                throw new Error(`Error in provided version - ${name} (${version})`);\r\n            }\r\n            if (version === \"stable\") {\r\n                versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\r\n            } else if (version === \"latest\") {\r\n                versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\r\n            } else {\r\n                // try loading the number the string represents\r\n                versionToLoad = +version;\r\n            }\r\n            if (versionToLoad === -1 || isNaN(versionToLoad)) {\r\n                throw new Error(`feature not found - ${name} (${version})`);\r\n            }\r\n        } else {\r\n            versionToLoad = version;\r\n        }\r\n        // check if already initialized\r\n        const feature = this._features[name];\r\n        const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\r\n        if (!constructFunction) {\r\n            // report error?\r\n            throw new Error(`feature not found - ${name}`);\r\n        }\r\n\r\n        /* If the feature is already enabled, detach and dispose it, and create a new one */\r\n        if (feature) {\r\n            this.disableFeature(name);\r\n        }\r\n\r\n        const constructed = constructFunction();\r\n        if (constructed.dependsOn) {\r\n            const dependentsFound = constructed.dependsOn.every((featureName) => !!this._features[featureName]);\r\n            if (!dependentsFound) {\r\n                throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\r\n            }\r\n        }\r\n        if (constructed.isCompatible()) {\r\n            this._features[name] = {\r\n                featureImplementation: constructed,\r\n                enabled: true,\r\n                version: versionToLoad,\r\n                required,\r\n            };\r\n\r\n            if (attachIfPossible) {\r\n                // if session started already, request and enable\r\n                if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\r\n                    // enable feature\r\n                    this.attachFeature(name);\r\n                }\r\n            } else {\r\n                // disable auto-attach when session starts\r\n                this._features[name].featureImplementation.disableAutoAttach = true;\r\n            }\r\n\r\n            return this._features[name].featureImplementation;\r\n        } else {\r\n            if (required) {\r\n                throw new Error(\"required feature not compatible\");\r\n            } else {\r\n                Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\r\n                return constructed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the implementation of an enabled feature.\r\n     * @param featureName the name of the feature to load\r\n     * @returns the feature class, if found\r\n     */\r\n    public getEnabledFeature(featureName: string): IWebXRFeature {\r\n        return this._features[featureName] && this._features[featureName].featureImplementation;\r\n    }\r\n\r\n    /**\r\n     * Get the list of enabled features\r\n     * @returns an array of enabled features\r\n     */\r\n    public getEnabledFeatures() {\r\n        return Object.keys(this._features);\r\n    }\r\n\r\n    /**\r\n     * This function will exten the session creation configuration object with enabled features.\r\n     * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\r\n     * according to the defined \"required\" variable, provided during enableFeature call\r\n     * @param xrSessionInit the xr Session init object to extend\r\n     *\r\n     * @returns an extended XRSessionInit object\r\n     */\r\n    public extendXRSessionInitObject(xrSessionInit: XRSessionInit): XRSessionInit {\r\n        const enabledFeatures = this.getEnabledFeatures();\r\n        enabledFeatures.forEach((featureName) => {\r\n            const feature = this._features[featureName];\r\n            const nativeName = feature.featureImplementation.xrNativeFeatureName;\r\n            if (nativeName) {\r\n                if (feature.required) {\r\n                    xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\r\n                    if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.requiredFeatures.push(nativeName);\r\n                    }\r\n                } else {\r\n                    xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\r\n                    if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\r\n                        xrSessionInit.optionalFeatures.push(nativeName);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return xrSessionInit;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}