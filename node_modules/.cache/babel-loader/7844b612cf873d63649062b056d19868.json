{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateTorusKnot = function (options) {\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var radius = options.radius || 2;\n  var tube = options.tube || 0.5;\n  var radialSegments = options.radialSegments || 32;\n  var tubularSegments = options.tubularSegments || 32;\n  var p = options.p || 2;\n  var q = options.q || 3;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // Helper\n\n  var getPos = function (angle) {\n    var cu = Math.cos(angle);\n    var su = Math.sin(angle);\n    var quOverP = q / p * angle;\n    var cs = Math.cos(quOverP);\n    var tx = radius * (2 + cs) * 0.5 * cu;\n    var ty = radius * (2 + cs) * su * 0.5;\n    var tz = radius * Math.sin(quOverP) * 0.5;\n    return new Vector3(tx, ty, tz);\n  }; // Vertices\n\n\n  var i;\n  var j;\n\n  for (i = 0; i <= radialSegments; i++) {\n    var modI = i % radialSegments;\n    var u = modI / radialSegments * 2 * p * Math.PI;\n    var p1 = getPos(u);\n    var p2 = getPos(u + 0.01);\n    var tang = p2.subtract(p1);\n    var n = p2.add(p1);\n    var bitan = Vector3.Cross(tang, n);\n    n = Vector3.Cross(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n\n    for (j = 0; j < tubularSegments; j++) {\n      var modJ = j % tubularSegments;\n      var v = modJ / tubularSegments * 2 * Math.PI;\n      var cx = -tube * Math.cos(v);\n      var cy = tube * Math.sin(v);\n      positions.push(p1.x + cx * n.x + cy * bitan.x);\n      positions.push(p1.y + cx * n.y + cy * bitan.y);\n      positions.push(p1.z + cx * n.z + cy * bitan.z);\n      uvs.push(i / radialSegments);\n      uvs.push(j / tubularSegments);\n    }\n  }\n\n  for (i = 0; i < radialSegments; i++) {\n    for (j = 0; j < tubularSegments; j++) {\n      var jNext = (j + 1) % tubularSegments;\n      var a = i * tubularSegments + j;\n      var b = (i + 1) * tubularSegments + j;\n      var c = (i + 1) * tubularSegments + jNext;\n      var d = i * tubularSegments + jNext;\n      indices.push(d);\n      indices.push(b);\n      indices.push(a);\n      indices.push(d);\n      indices.push(c);\n      indices.push(b);\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\n  var options = {\n    radius: radius,\n    tube: tube,\n    radialSegments: radialSegments,\n    tubularSegments: tubularSegments,\n    p: p,\n    q: q,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return TorusKnotBuilder.CreateTorusKnot(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TorusKnotBuilder =\n/** @class */\nfunction () {\n  function TorusKnotBuilder() {}\n  /**\r\n   * Creates a torus knot mesh\r\n   * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n   * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n   * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n   * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the torus knot mesh\r\n   * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n   */\n\n\n  TorusKnotBuilder.CreateTorusKnot = function (name, options, scene) {\n    var torusKnot = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateTorusKnot(options);\n    vertexData.applyToMesh(torusKnot, options.updatable);\n    return torusKnot;\n  };\n\n  return TorusKnotBuilder;\n}();\n\nexport { TorusKnotBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/torusKnotBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\n\r\nVertexData.CreateTorusKnot = function(options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n\r\n    var radius = options.radius || 2;\r\n    var tube = options.tube || 0.5;\r\n    var radialSegments = options.radialSegments || 32;\r\n    var tubularSegments = options.tubularSegments || 32;\r\n    var p = options.p || 2;\r\n    var q = options.q || 3;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    var getPos = (angle: number) => {\r\n\r\n        var cu = Math.cos(angle);\r\n        var su = Math.sin(angle);\r\n        var quOverP = q / p * angle;\r\n        var cs = Math.cos(quOverP);\r\n\r\n        var tx = radius * (2 + cs) * 0.5 * cu;\r\n        var ty = radius * (2 + cs) * su * 0.5;\r\n        var tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    var i: number;\r\n    var j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        var modI = i % radialSegments;\r\n        var u = modI / radialSegments * 2 * p * Math.PI;\r\n        var p1 = getPos(u);\r\n        var p2 = getPos(u + 0.01);\r\n        var tang = p2.subtract(p1);\r\n        var n = p2.add(p1);\r\n\r\n        var bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var modJ = j % tubularSegments;\r\n            var v = modJ / tubularSegments * 2 * Math.PI;\r\n            var cx = -tube * Math.cos(v);\r\n            var cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var jNext = (j + 1) % tubularSegments;\r\n            var a = i * tubularSegments + j;\r\n            var b = (i + 1) * tubularSegments + j;\r\n            var c = (i + 1) * tubularSegments + jNext;\r\n            var d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d); indices.push(b); indices.push(a);\r\n            indices.push(d); indices.push(c); indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateTorusKnot = (name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        radius: radius,\r\n        tube: tube,\r\n        radialSegments: radialSegments,\r\n        tubularSegments: tubularSegments,\r\n        p: p,\r\n        q: q,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return TorusKnotBuilder.CreateTorusKnot(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TorusKnotBuilder {\r\n    /**\r\n     * Creates a torus knot mesh\r\n     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus knot mesh\r\n     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n     */\r\n    public static CreateTorusKnot(name: string, options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: any): Mesh {\r\n        var torusKnot = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateTorusKnot(options);\r\n\r\n        vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n        return torusKnot;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}