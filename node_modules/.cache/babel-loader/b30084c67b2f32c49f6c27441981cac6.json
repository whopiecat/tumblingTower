{"ast":null,"code":"import { Engine } from \"../Engines/engine\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Effect } from \"../Materials/effect\";\nimport \"../Meshes/Builders/planeBuilder\";\nimport \"../Shaders/spriteMap.fragment\";\nimport \"../Shaders/spriteMap.vertex\";\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\n\nvar SpriteMap =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SpriteMap\r\n   * @param name defines the SpriteMaps Name\r\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n   * @param spriteSheet is the Texture that the Sprites are on.\r\n   * @param options a basic deployment configuration\r\n   * @param scene The Scene that the map is deployed on\r\n   */\n  function SpriteMap(name, atlasJSON, spriteSheet, options, scene) {\n    var _this = this;\n\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\r\n    * Run through the options and set what ever defaults are needed that where not declared.\r\n    */\n\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n\n    for (var i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n\n    this._animationMap = this._createTileAnimationBuffer(null);\n    var defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n\n    defines.push(\"#define MAX_ANIMATION_FRAMES \" + options.maxAnimationFrames + \".0\");\n    var shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    var layerSampleString;\n\n    if (this._scene.getEngine().webGLVersion === 1) {\n      layerSampleString = \"\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"if (\" + i + \" == i) { frameID = texture2D(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x; }\";\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n\n      for (var i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n\n      layerSampleString += \"}\";\n    }\n\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines: defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n\n    this._material.setVector2(\"stageSize\", options.stageSize);\n\n    this._material.setVector2(\"outputSize\", options.outputSize);\n\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    var tickSave = 0;\n\n    var bindSpriteTexture = function () {\n      if (_this.spriteSheet && _this.spriteSheet.isReady()) {\n        if (_this.spriteSheet._texture) {\n          _this._material.setVector2(\"spriteMapSize\", new Vector2(_this.spriteSheet._texture.baseWidth || 1, _this.spriteSheet._texture.baseHeight || 1));\n\n          return;\n        }\n      }\n\n      if (tickSave < 100) {\n        setTimeout(function () {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n\n    bindSpriteTexture();\n\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n\n    this._material.setTexture(\"frameMap\", this._frameMap);\n\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n\n    this._material.setFloat(\"time\", this._time);\n\n    this._output = Mesh.CreatePlane(name + \":output\", 1, scene, true);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n\n    var obfunction = function () {\n      _this._time += _this._scene.getEngine().getDeltaTime();\n\n      _this._material.setFloat(\"time\", _this._time);\n    };\n\n    this._scene.onBeforeRenderObservable.add(obfunction);\n\n    this._output.material = this._material;\n  }\n\n  Object.defineProperty(SpriteMap.prototype, \"spriteCount\", {\n    /** Returns the Number of Sprites in the System */\n    get: function () {\n      return this.sprites.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"position\", {\n    /** Returns the Position of Output Plane*/\n    get: function () {\n      return this._output.position;\n    },\n\n    /** Returns the Position of Output Plane*/\n    set: function (v) {\n      this._output.position = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"rotation\", {\n    /** Returns the Rotation of Output Plane*/\n    get: function () {\n      return this._output.rotation;\n    },\n\n    /** Returns the Rotation of Output Plane*/\n    set: function (v) {\n      this._output.rotation = v;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteMap.prototype, \"animationMap\", {\n    /** Sets the AnimationMap*/\n    get: function () {\n      return this._animationMap;\n    },\n\n    /** Sets the AnimationMap*/\n    set: function (v) {\n      var buffer = v._texture._bufferView;\n\n      var am = this._createTileAnimationBuffer(buffer);\n\n      this._animationMap.dispose();\n\n      this._animationMap = am;\n\n      this._material.setTexture(\"animationMap\", this._animationMap);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Returns tileID location\r\n  * @returns Vector2 the cell position ID\r\n  */\n\n  SpriteMap.prototype.getTileID = function () {\n    var p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  };\n  /**\r\n  * Gets the UV location of the mouse over the SpriteMap.\r\n  * @returns Vector2 the UV position of the mouse interaction\r\n  */\n\n\n  SpriteMap.prototype.getMousePosition = function () {\n    var out = this._output;\n\n    var pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, function (mesh) {\n      if (mesh !== out) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n\n    var coords = pickinfo.getTextureCoordinates();\n\n    if (coords) {\n      return coords;\n    }\n\n    return new Vector2(-1, -1);\n  };\n  /**\r\n  * Creates the \"frame\" texture Buffer\r\n  * -------------------------------------\r\n  * Structure of frames\r\n  *  \"filename\": \"Falling-Water-2.png\",\r\n  * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n  * \"rotated\": true,\r\n  * \"trimmed\": true,\r\n  * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n  * \"sourceSize\": {\"w\":32,\"h\":32}\r\n  * @returns RawTexture of the frameMap\r\n  */\n\n\n  SpriteMap.prototype._createFrameBuffer = function () {\n    var data = new Array(); //Do two Passes\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n\n      data.push(0, 0, 0, 0); //spriteSourceSize\n\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    } //Second Pass\n\n\n    for (var i = 0; i < this.spriteCount; i++) {\n      var f = this.sprites[i][\"frame\"];\n      var sss = this.sprites[i][\"spriteSourceSize\"];\n      var ss = this.sprites[i][\"sourceSize\"];\n      var r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      var t_1 = this.sprites[i][\"trimmed\"] ? 1 : 0; //frame\n\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h; //spriteSourceSize\n\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h; //sourceSize, rotated, trimmed\n\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t_1;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Creates the tileMap texture Buffer\r\n  * @param buffer normally and array of numbers, or a false to generate from scratch\r\n  * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n  * @returns RawTexture of the tileMap\r\n  */\n\n\n  SpriteMap.prototype._createTileBuffer = function (buffer, _layer) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    var data = new Array();\n\n    var _ty = this.options.stageSize.y || 0;\n\n    var _tx = this.options.stageSize.x || 0;\n\n    if (!buffer) {\n      var bt = this.options.baseTile;\n\n      if (_layer != 0) {\n        bt = 0;\n      }\n\n      for (var y = 0; y < _ty; y++) {\n        for (var x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n\n    var floatArray = new Float32Array(data);\n    var t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Modifies the data of the tileMaps\r\n  * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n  * @param pos is the iVector2 Coordinates of the Tile\r\n  * @param tile The SpriteIndex of the new Tile\r\n  */\n\n\n  SpriteMap.prototype.changeTiles = function (_layer, pos, tile) {\n    if (_layer === void 0) {\n      _layer = 0;\n    }\n\n    if (tile === void 0) {\n      tile = 0;\n    }\n\n    var buffer;\n    buffer = this._tileMaps[_layer]._texture._bufferView;\n\n    if (buffer === null) {\n      return;\n    }\n\n    var p = new Array();\n\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n\n    var _tx = this.options.stageSize.x || 0;\n\n    for (var i = 0; i < p.length; i++) {\n      var _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      var id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n\n    var t = this._createTileBuffer(buffer);\n\n    this._tileMaps[_layer].dispose();\n\n    this._tileMaps[_layer] = t;\n\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  };\n  /**\r\n  * Creates the animationMap texture Buffer\r\n  * @param buffer normally and array of numbers, or a false to generate from scratch\r\n  * @returns RawTexture of the animationMap\r\n  */\n\n\n  SpriteMap.prototype._createTileAnimationBuffer = function (buffer) {\n    var data = new Array();\n    var floatArray;\n\n    if (!buffer) {\n      for (var i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        var count = 1;\n\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n\n    var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  };\n  /**\r\n  * Modifies the data of the animationMap\r\n  * @param cellID is the Index of the Sprite\r\n  * @param _frame is the target Animation frame\r\n  * @param toCell is the Target Index of the next frame of the animation\r\n  * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n  * @param speed is a global scalar of the time variable on the map.\r\n  */\n\n\n  SpriteMap.prototype.addAnimationToTile = function (cellID, _frame, toCell, time, speed) {\n    if (cellID === void 0) {\n      cellID = 0;\n    }\n\n    if (_frame === void 0) {\n      _frame = 0;\n    }\n\n    if (toCell === void 0) {\n      toCell = 0;\n    }\n\n    if (time === void 0) {\n      time = 0;\n    }\n\n    if (speed === void 0) {\n      speed = 1;\n    }\n\n    var buffer = this._animationMap._texture._bufferView;\n    var id = cellID * 4 + this.spriteCount * 4 * _frame;\n\n    if (!buffer) {\n      return;\n    }\n\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n\n    var t = this._createTileAnimationBuffer(buffer);\n\n    this._animationMap.dispose();\n\n    this._animationMap = t;\n\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  };\n  /**\r\n  * Exports the .tilemaps file\r\n  */\n\n\n  SpriteMap.prototype.saveTileMaps = function () {\n    var maps = \"\";\n\n    for (var i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n\n    var hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  };\n  /**\r\n  * Imports the .tilemaps file\r\n  * @param url of the .tilemaps file\r\n  */\n\n\n  SpriteMap.prototype.loadTileMaps = function (url) {\n    var _this = this;\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n\n    var _lc = this.options.layerCount || 0;\n\n    xhr.onload = function () {\n      var data = xhr.response.split(\"\\n\\r\");\n\n      for (var i = 0; i < _lc; i++) {\n        var d = data[i].split(\",\").map(Number);\n\n        var t = _this._createTileBuffer(d);\n\n        _this._tileMaps[i].dispose();\n\n        _this._tileMaps[i] = t;\n      }\n\n      _this._material.setTextureArray(\"tileMap\", _this._tileMaps);\n    };\n\n    xhr.send();\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteMap.prototype.dispose = function () {\n    this._output.dispose();\n\n    this._material.dispose();\n\n    this._animationMap.dispose();\n\n    this._tileMaps.forEach(function (tm) {\n      tm.dispose();\n    });\n\n    this._frameMap.dispose();\n  };\n\n  return SpriteMap;\n}();\n\nexport { SpriteMap };","map":{"version":3,"sources":["../../../sourceES6/core/Sprites/spriteMap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { ISpriteJSONSprite, ISpriteJSONAtlas } from \"./ISprites\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Meshes/Builders/planeBuilder\";\r\nimport \"../Shaders/spriteMap.fragment\";\r\nimport \"../Shaders/spriteMap.vertex\";\r\n\r\n/**\r\n * Defines the basic options interface of a SpriteMap\r\n */\r\nexport interface ISpriteMapOptions{\r\n\r\n    /**\r\n\t * Vector2 of the number of cells in the grid.\r\n\t */\r\n    stageSize?: Vector2;\r\n\r\n    /**\r\n\t * Vector2 of the size of the output plane in World Units.\r\n\t */\r\n    outputSize?: Vector2;\r\n\r\n    /**\r\n\t * Vector3 of the position of the output plane in World Units.\r\n\t */\r\n    outputPosition?: Vector3;\r\n\r\n    /**\r\n\t * Vector3 of the rotation of the output plane.\r\n\t */\r\n    outputRotation?: Vector3;\r\n\r\n    /**\r\n\t * number of layers that the system will reserve in resources.\r\n\t */\r\n    layerCount?: number;\r\n\r\n    /**\r\n\t * number of max animation frames a single cell will reserve in resources.\r\n\t */\r\n    maxAnimationFrames?: number;\r\n\r\n    /**\r\n\t * number cell index of the base tile when the system compiles.\r\n\t */\r\n    baseTile?: number;\r\n\r\n    /**\r\n\t* boolean flip the sprite after its been repositioned by the framing data.\r\n\t*/\r\n    flipU?: boolean;\r\n\r\n    /**\r\n\t * Vector3 scalar of the global RGB values of the SpriteMap.\r\n\t */\r\n    colorMultiply?: Vector3;\r\n\r\n}\r\n\r\n/**\r\n * Defines the IDisposable interface in order to be cleanable from resources.\r\n */\r\nexport interface ISpriteMap extends IDisposable {\r\n\r\n    /**\r\n\t * String name of the SpriteMap.\r\n\t */\r\n    name: string;\r\n\r\n    /**\r\n\t * The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.\r\n\t */\r\n    atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /**\r\n\t * Texture of the SpriteMap.\r\n\t */\r\n    spriteSheet: Texture;\r\n\r\n    /**\r\n\t * The parameters to initialize the SpriteMap with.\r\n\t */\r\n    options: ISpriteMapOptions;\r\n\r\n}\r\n\r\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\r\nexport class SpriteMap implements ISpriteMap {\r\n\r\n    /** The Name of the spriteMap */\r\n    public name: string;\r\n\r\n    /** The JSON file with the frame and meta data */\r\n    public atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /** The systems Sprite Sheet Texture */\r\n    public spriteSheet: Texture;\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ISpriteMapOptions;\r\n\r\n    /** Public Sprite Storage array, parsed from atlasJSON */\r\n    public sprites: Array<ISpriteJSONSprite>;\r\n\r\n    /** Returns the Number of Sprites in the System */\r\n    public get spriteCount(): number {\r\n        return this.sprites.length;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public get position(): Vector3 {\r\n        return this._output.position;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public set position(v: Vector3) {\r\n        this._output.position = v;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public get rotation(): Vector3 {\r\n        return this._output.rotation;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public set rotation(v: Vector3) {\r\n        this._output.rotation = v;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public get animationMap() {\r\n        return this._animationMap;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public set animationMap(v: RawTexture) {\r\n        let buffer = v!._texture!._bufferView;\r\n        let am = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = am;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /** Scene that the SpriteMap was created in */\r\n    private _scene: Scene;\r\n\r\n    /** Texture Buffer of Float32 that holds tile frame data*/\r\n    private _frameMap: RawTexture;\r\n\r\n    /** Texture Buffers of Float32 that holds tileMap data*/\r\n    private _tileMaps: RawTexture[];\r\n\r\n    /** Texture Buffer of Float32 that holds Animation Data*/\r\n    private _animationMap: RawTexture;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _material: ShaderMaterial;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _output: Mesh;\r\n\r\n    /** Systems Time Ticker*/\r\n    private _time: number;\r\n\r\n    /**\r\n     * Creates a new SpriteMap\r\n     * @param name defines the SpriteMaps Name\r\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n     * @param spriteSheet is the Texture that the Sprites are on.\r\n     * @param options a basic deployment configuration\r\n     * @param scene The Scene that the map is deployed on\r\n     */\r\n    constructor(name : string, atlasJSON: ISpriteJSONAtlas, spriteSheet: Texture, options: ISpriteMapOptions, scene : Scene) {\r\n\r\n        this.name = name;\r\n        this.sprites = [];\r\n        this.atlasJSON = atlasJSON;\r\n        this.sprites = this.atlasJSON[\"frames\"];\r\n        this.spriteSheet = spriteSheet;\r\n\r\n        /**\r\n        * Run through the options and set what ever defaults are needed that where not declared.\r\n        */\r\n        this.options = options;\r\n        options.stageSize = options.stageSize || new Vector2(1, 1);\r\n        options.outputSize = options.outputSize || options.stageSize;\r\n        options.outputPosition = options.outputPosition || Vector3.Zero();\r\n        options.outputRotation = options.outputRotation || Vector3.Zero();\r\n        options.layerCount = options.layerCount || 1;\r\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\r\n        options.baseTile = options.baseTile || 0;\r\n        options.flipU = options.flipU || false;\r\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\r\n\r\n        this._scene = scene;\r\n\r\n        this._frameMap = this._createFrameBuffer();\r\n\r\n        this._tileMaps = new Array();\r\n        for (let i = 0; i < options.layerCount; i++) {\r\n            this._tileMaps.push(this._createTileBuffer(null, i));\r\n        }\r\n\r\n        this._animationMap = this._createTileAnimationBuffer(null);\r\n\r\n        let defines = [];\r\n        defines.push(\"#define LAYERS \" + options.layerCount);\r\n\r\n        if (options.flipU) {\r\n            defines.push(\"#define FLIPU\");\r\n        }\r\n\r\n        defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\r\n\r\n        let shaderString: string = Effect.ShadersStore[\"spriteMapPixelShader\"];\r\n\r\n        let layerSampleString: string;\r\n        if (this._scene.getEngine().webGLVersion === 1) {\r\n            layerSampleString = \"\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\r\n            }\r\n        }\r\n        else {\r\n            layerSampleString = \"switch(i) {\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\r\n                layerSampleString += \"break;\";\r\n            }\r\n            layerSampleString += \"}\";\r\n        }\r\n\r\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\",  layerSampleString);\r\n\r\n        this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\r\n            vertex: \"spriteMap\",\r\n            fragment: \"spriteMap\" + this.name,\r\n        }, {\r\n            defines,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\r\n                \"worldViewProjection\",\r\n                \"time\",\r\n                \"stageSize\",\r\n                \"outputSize\",\r\n                \"spriteMapSize\",\r\n                \"spriteCount\",\r\n                \"time\",\r\n                \"colorMul\",\r\n                \"mousePosition\",\r\n                \"curTile\",\r\n                \"flipU\"\r\n            ],\r\n            samplers: [\r\n            \"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"\r\n            ],\r\n            needAlphaBlending: true\r\n        });\r\n\r\n        this._time = 0;\r\n\r\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\r\n        this._material.setVector2(\"stageSize\", options.stageSize);\r\n        this._material.setVector2(\"outputSize\", options.outputSize);\r\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\r\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n\r\n        let tickSave = 0;\r\n\r\n        const bindSpriteTexture = () => {\r\n            if ((this.spriteSheet) && this.spriteSheet.isReady()) {\r\n                if (this.spriteSheet._texture) {\r\n                    this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\r\n                    return;\r\n                }\r\n            }\r\n            if (tickSave < 100) {\r\n                setTimeout(() => {tickSave++; bindSpriteTexture(); }, 100);\r\n            }\r\n        };\r\n\r\n        bindSpriteTexture();\r\n\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n        this._material.setTexture(\"frameMap\", this._frameMap);\r\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n        this._material.setFloat(\"time\", this._time);\r\n\r\n        this._output = Mesh.CreatePlane(name + \":output\", 1, scene, true);\r\n        this._output.scaling.x = options.outputSize.x;\r\n        this._output.scaling.y = options.outputSize.y;\r\n        this.position = options.outputPosition;\r\n        this.rotation = options.outputRotation;\r\n\r\n        let obfunction = () => {\r\n            this._time += this._scene.getEngine().getDeltaTime();\r\n            this._material.setFloat(\"time\", this._time);\r\n        };\r\n\r\n        this._scene.onBeforeRenderObservable.add(obfunction);\r\n        this._output.material = this._material;\r\n    }\r\n\r\n    /**\r\n    * Returns tileID location\r\n    * @returns Vector2 the cell position ID\r\n    */\r\n    public getTileID(): Vector2 {\r\n        let p = this.getMousePosition();\r\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\r\n        p.x = Math.floor(p.x);\r\n        p.y = Math.floor(p.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n    * Gets the UV location of the mouse over the SpriteMap.\r\n    * @returns Vector2 the UV position of the mouse interaction\r\n    */\r\n    public getMousePosition(): Vector2 {\r\n        let out = this._output;\r\n        var pickinfo: Nullable<PickingInfo> = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {\r\n            if (mesh !== out) {\r\n                return false;\r\n            }\r\n          return true;\r\n        });\r\n\r\n        if (((!pickinfo) || !pickinfo.hit) || !pickinfo.getTextureCoordinates) {\r\n            return new Vector2(-1, -1);\r\n        }\r\n\r\n        let coords = pickinfo.getTextureCoordinates();\r\n        if (coords) {\r\n            return coords;\r\n        }\r\n\r\n        return \tnew Vector2(-1, -1);\r\n    }\r\n\r\n    /**\r\n    * Creates the \"frame\" texture Buffer\r\n    * -------------------------------------\r\n    * Structure of frames\r\n    *  \"filename\": \"Falling-Water-2.png\",\r\n    * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n    * \"rotated\": true,\r\n    * \"trimmed\": true,\r\n    * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n    * \"sourceSize\": {\"w\":32,\"h\":32}\r\n    * @returns RawTexture of the frameMap\r\n    */\r\n    private _createFrameBuffer(): RawTexture {\r\n        let data = new Array();\r\n        //Do two Passes\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            data.push(0, 0, 0, 0); //frame\r\n            data.push(0, 0, 0, 0); //spriteSourceSize\r\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\r\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\r\n        }\r\n        //Second Pass\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            let f = this.sprites[i][\"frame\"];\r\n            let sss = this.sprites[i][\"spriteSourceSize\"];\r\n            let ss = this.sprites[i][\"sourceSize\"];\r\n            let r = (this.sprites[i][\"rotated\"]) ? 1 : 0;\r\n            let t = (this.sprites[i][\"trimmed\"]) ? 1 : 0;\r\n\r\n            //frame\r\n            data[i * 4] = f.x;\r\n            data[i * 4 + 1] = f.y;\r\n            data[i * 4 + 2] = f.w;\r\n            data[i * 4 + 3] = f.h;\r\n            //spriteSourceSize\r\n            data[i * 4 + (this.spriteCount * 4)] = sss.x;\r\n            data[i * 4 + 1 + (this.spriteCount * 4)] = sss.y;\r\n            data[i * 4 + 3 + (this.spriteCount * 4)] = sss.h;\r\n            //sourceSize, rotated, trimmed\r\n            data[i * 4 + (this.spriteCount * 8)] = ss.w;\r\n            data[i * 4 + 1 + (this.spriteCount * 8)] = ss.h;\r\n            data[i * 4 + 2 + (this.spriteCount * 8)] = r;\r\n            data[i * 4 + 3 + (this.spriteCount * 8)] = t ;\r\n        }\r\n\r\n        let floatArray = new Float32Array(data);\r\n\r\n        let t = RawTexture.CreateRGBATexture(\r\n        floatArray,\r\n        this.spriteCount,\r\n        4,\r\n        this._scene,\r\n        false,\r\n        false,\r\n        Texture.NEAREST_NEAREST,\r\n        Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n    * Creates the tileMap texture Buffer\r\n    * @param buffer normally and array of numbers, or a false to generate from scratch\r\n    * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n    * @returns RawTexture of the tileMap\r\n    */\r\n    private _createTileBuffer(buffer: any, _layer: number = 0): RawTexture {\r\n\r\n        let data = new Array();\r\n        let _ty = (this.options.stageSize!.y) || 0;\r\n        let _tx = (this.options.stageSize!.x) || 0;\r\n\r\n        if (!buffer) {\r\n            let bt = this.options.baseTile;\r\n            if (_layer != 0) {\r\n                bt = 0;\r\n            }\r\n\r\n            for (let y = 0; y < _ty; y++) {\r\n                for (let x = 0; x < _tx * 4; x += 4) {\r\n                    data.push(bt, 0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            data = buffer;\r\n        }\r\n\r\n        let floatArray = new Float32Array(data);\r\n        let t = RawTexture.CreateRGBATexture(\r\n        floatArray,\r\n        _tx,\r\n        _ty,\r\n        this._scene,\r\n        false,\r\n        false,\r\n        Texture.NEAREST_NEAREST,\r\n        Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n    * Modifies the data of the tileMaps\r\n    * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n    * @param pos is the iVector2 Coordinates of the Tile\r\n    * @param tile The SpriteIndex of the new Tile\r\n    */\r\n    public changeTiles(_layer: number = 0, pos: Vector2 | Vector2[] , tile: number = 0): void {\r\n\r\n        let buffer: Nullable<ArrayBufferView>;\r\n        buffer = this._tileMaps[_layer]!._texture!._bufferView;\r\n        if (buffer === null) {\r\n            return;\r\n        }\r\n\r\n        let p = new Array();\r\n        if (pos instanceof Vector2) {\r\n            p.push(pos);\r\n        } else {\r\n            p = pos;\r\n        }\r\n\r\n        let _tx = (this.options.stageSize!.x) || 0;\r\n\r\n        for (let i = 0; i < p.length; i++) {\r\n            let _p = p[i];\r\n            _p.x = Math.floor(_p.x);\r\n            _p.y = Math.floor(_p.y);\r\n            let id: number = (_p.x * 4) + (_p.y * (_tx * 4));\r\n            (buffer as any)[id] = tile;\r\n        }\r\n\r\n        let t = this._createTileBuffer(buffer);\r\n        this._tileMaps[_layer].dispose();\r\n        this._tileMaps[_layer] = t;\r\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n    }\r\n\r\n    /**\r\n    * Creates the animationMap texture Buffer\r\n    * @param buffer normally and array of numbers, or a false to generate from scratch\r\n    * @returns RawTexture of the animationMap\r\n    */\r\n    private _createTileAnimationBuffer(buffer: Nullable<ArrayBufferView>): RawTexture {\r\n        let data = new Array();\r\n        let floatArray;\r\n        if (!buffer) {\r\n            for (let i = 0; i < this.spriteCount; i++) {\r\n                data.push(0, 0, 0, 0);\r\n                let count = 1;\r\n                while (count < (this.options.maxAnimationFrames || 4)) {\r\n                    data.push(0, 0, 0, 0);\r\n                    count++;\r\n                }\r\n            }\r\n            floatArray = new Float32Array(data);\r\n        } else {\r\n            floatArray = buffer;\r\n        }\r\n\r\n        let t = RawTexture.CreateRGBATexture(\r\n        floatArray,\r\n        this.spriteCount,\r\n        (this.options.maxAnimationFrames || 4),\r\n        this._scene,\r\n        false,\r\n        false,\r\n        Texture.NEAREST_NEAREST,\r\n        Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n    * Modifies the data of the animationMap\r\n    * @param cellID is the Index of the Sprite\r\n    * @param _frame is the target Animation frame\r\n    * @param toCell is the Target Index of the next frame of the animation\r\n    * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n    * @param speed is a global scalar of the time variable on the map.\r\n    */\r\n    public addAnimationToTile(cellID: number = 0, _frame: number = 0, toCell: number = 0, time: number = 0, speed: number = 1): void {\r\n        let buffer: any = this._animationMap!._texture!._bufferView;\r\n        let id: number = (cellID * 4) + (this.spriteCount * 4 * _frame);\r\n        if (!buffer) {\r\n            return;\r\n        }\r\n        buffer[id] = toCell;\r\n        buffer[id + 1 ] = time;\r\n        buffer[id + 2 ] = speed;\r\n        let t = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = t;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /**\r\n    * Exports the .tilemaps file\r\n    */\r\n    public saveTileMaps(): void {\r\n        let maps = \"\";\r\n        for (var i = 0; i < this._tileMaps.length; i++) {\r\n            if (i > 0) {maps += \"\\n\\r\"; }\r\n\r\n            maps += this._tileMaps[i]!._texture!._bufferView!.toString();\r\n        }\r\n        var hiddenElement = document.createElement(\"a\");\r\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\r\n        hiddenElement.target = \"_blank\";\r\n        hiddenElement.download = this.name + \".tilemaps\";\r\n        hiddenElement.click();\r\n        hiddenElement.remove();\r\n    }\r\n\r\n    /**\r\n    * Imports the .tilemaps file\r\n    * @param url of the .tilemaps file\r\n    */\r\n    public loadTileMaps(url : string) : void {\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", url);\r\n\r\n        let _lc =  this.options!.layerCount || 0;\r\n\r\n        xhr.onload = () =>\r\n        {\r\n            let data = xhr.response.split(\"\\n\\r\");\r\n            for (let i = 0; i < _lc; i++) {\r\n                let d = (data[i].split(\",\")).map(Number);\r\n                let t = this._createTileBuffer(d);\r\n                this._tileMaps[i].dispose();\r\n                this._tileMaps[i] = t;\r\n            }\r\n            this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._output.dispose();\r\n        this._material.dispose();\r\n        this._animationMap.dispose();\r\n        this._tileMaps.forEach((tm) => {\r\n            tm.dispose();\r\n        });\r\n        this._frameMap.dispose();\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}