{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SmartArray } from \"../Misc/smartArray\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport \"../Shaders/postprocess.vertex\";\nimport { Engine } from '../Engines/engine';\nimport \"../Engines/Extensions/engine.renderTarget\";\nimport { serialize, serializeAsColor4, SerializationHelper } from '../Misc/decorators';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\n\nvar PostProcess =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance PostProcess\r\n   * @param name The name of the PostProcess.\r\n   * @param fragmentUrl The url of the fragment shader to be used.\r\n   * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n   * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n   * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n   */\n  function PostProcess(name, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (vertexUrl === void 0) {\n      vertexUrl = \"postprocess\";\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n    /**\r\n    * Width of the texture to apply the post process on\r\n    */\n\n\n    this.width = -1;\n    /**\r\n    * Height of the texture to apply the post process on\r\n    */\n\n    this.height = -1;\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\n\n    this.nodeMaterialSource = null;\n    /**\r\n    * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n    * @hidden\r\n    */\n\n    this._outputTexture = null;\n    /**\r\n    * If the buffer needs to be cleared before applying the post process. (default: true)\r\n    * Should be set to false if shader will overwrite all previous pixels.\r\n    */\n\n    this.autoClear = true;\n    /**\r\n    * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n    */\n\n    this.alphaMode = 0;\n    /**\r\n    * Animations to be used for the post processing\r\n    */\n\n    this.animations = new Array();\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\n\n    this.enablePixelPerfectMode = false;\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\n\n    this.forceFullscreenViewport = true;\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\n\n    this.scaleMode = 1;\n    /**\r\n    * Force textures to be a power of two (default: false)\r\n    */\n\n    this.alwaysForcePOT = false;\n    this._samples = 1;\n    /**\r\n    * Modify the scale of the post process to be the same as the viewport (default: false)\r\n    */\n\n    this.adaptScaleToCurrentViewport = false;\n    this._reusable = false;\n    /**\r\n    * Smart array of input and output textures for the post process.\r\n    * @hidden\r\n    */\n\n    this._textures = new SmartArray(2);\n    /**\r\n    * The index in _textures that corresponds to the output texture.\r\n    * @hidden\r\n    */\n\n    this._currentRenderTextureInd = 0;\n    this._scaleRatio = new Vector2(1, 1);\n    this._texelSize = Vector2.Zero(); // Events\n\n    /**\r\n    * An event triggered when the postprocess is activated.\r\n    */\n\n    this.onActivateObservable = new Observable();\n    /**\r\n    * An event triggered when the postprocess changes its size.\r\n    */\n\n    this.onSizeChangedObservable = new Observable();\n    /**\r\n    * An event triggered when the postprocess applies its effect.\r\n    */\n\n    this.onApplyObservable = new Observable();\n    /**\r\n    * An event triggered before rendering the postprocess\r\n    */\n\n    this.onBeforeRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the postprocess\r\n    */\n\n    this.onAfterRenderObservable = new Observable();\n    this.name = name;\n\n    if (camera != null) {\n      this._camera = camera;\n      this._scene = camera.getScene();\n      camera.attachPostProcess(this);\n      this._engine = this._scene.getEngine();\n\n      this._scene.postProcesses.push(this);\n\n      this.uniqueId = this._scene.getUniqueId();\n    } else if (engine) {\n      this._engine = engine;\n\n      this._engine.postProcesses.push(this);\n    }\n\n    this._options = options;\n    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\n    this._reusable = reusable || false;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._samplers = samplers || [];\n\n    this._samplers.push(\"textureSampler\");\n\n    this._fragmentUrl = fragmentUrl;\n    this._vertexUrl = vertexUrl;\n    this._parameters = parameters || [];\n\n    this._parameters.push(\"scale\");\n\n    this._indexParameters = indexParameters;\n\n    if (!blockCompilation) {\n      this.updateEffect(defines);\n    }\n  }\n\n  Object.defineProperty(PostProcess.prototype, \"samples\", {\n    /**\r\n    * Number of sample textures (default: 1)\r\n    */\n    get: function () {\n      return this._samples;\n    },\n    set: function (n) {\n      var _this = this;\n\n      this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this._samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);\n        }\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the fragment url or shader name used in the post process.\r\n   * @returns the fragment url or name in the shader store.\r\n   */\n\n  PostProcess.prototype.getEffectName = function () {\n    return this._fragmentUrl;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"onActivate\", {\n    /**\r\n    * A function that is added to the onActivateObservable\r\n    */\n    set: function (callback) {\n      if (this._onActivateObserver) {\n        this.onActivateObservable.remove(this._onActivateObserver);\n      }\n\n      if (callback) {\n        this._onActivateObserver = this.onActivateObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onSizeChanged\", {\n    /**\r\n    * A function that is added to the onSizeChangedObservable\r\n    */\n    set: function (callback) {\n      if (this._onSizeChangedObserver) {\n        this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n      }\n\n      this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onApply\", {\n    /**\r\n    * A function that is added to the onApplyObservable\r\n    */\n    set: function (callback) {\n      if (this._onApplyObserver) {\n        this.onApplyObservable.remove(this._onApplyObserver);\n      }\n\n      this._onApplyObserver = this.onApplyObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onBeforeRender\", {\n    /**\r\n    * A function that is added to the onBeforeRenderObservable\r\n    */\n    set: function (callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"onAfterRender\", {\n    /**\r\n    * A function that is added to the onAfterRenderObservable\r\n    */\n    set: function (callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"inputTexture\", {\n    /**\r\n    * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n    * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n    */\n    get: function () {\n      return this._textures.data[this._currentRenderTextureInd];\n    },\n    set: function (value) {\n      this._forcedOutputTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n  * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n  * the only way to unset it is to use this function to restore its internal state\r\n  */\n\n  PostProcess.prototype.restoreDefaultInputTexture = function () {\n    this._forcedOutputTexture = null;\n  };\n  /**\r\n  * Gets the camera which post process is applied to.\r\n  * @returns The camera the post process is applied to.\r\n  */\n\n\n  PostProcess.prototype.getCamera = function () {\n    return this._camera;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"texelSize\", {\n    /**\r\n    * Gets the texel size of the postprocess.\r\n    * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n    */\n    get: function () {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.texelSize;\n      }\n\n      if (this._forcedOutputTexture) {\n        this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\n      }\n\n      return this._texelSize;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"PostProcess\" string\r\n   */\n\n  PostProcess.prototype.getClassName = function () {\n    return \"PostProcess\";\n  };\n  /**\r\n   * Gets the engine which this post process belongs to.\r\n   * @returns The engine the post process was enabled with.\r\n   */\n\n\n  PostProcess.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * The effect that is created when initializing the post process.\r\n   * @returns The created effect corresponding the the postprocess.\r\n   */\n\n\n  PostProcess.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n   * @param postProcess The post process to share the output with.\r\n   * @returns This post process.\r\n   */\n\n\n  PostProcess.prototype.shareOutputWith = function (postProcess) {\n    this._disposeTextures();\n\n    this._shareOutputWithPostProcess = postProcess;\n    return this;\n  };\n  /**\r\n   * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n   * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n   */\n\n\n  PostProcess.prototype.useOwnOutput = function () {\n    if (this._textures.length == 0) {\n      this._textures = new SmartArray(2);\n    }\n\n    this._shareOutputWithPostProcess = null;\n  };\n  /**\r\n   * Updates the effect with the current post process compile time values and recompiles the shader.\r\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n   * @param onCompiled Called when the shader has been compiled.\r\n   * @param onError Called if there is an error when compiling a shader.\r\n   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n   */\n\n\n  PostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (uniforms === void 0) {\n      uniforms = null;\n    }\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    this._effect = this._engine.createEffect({\n      vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl,\n      fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl\n    }, [\"position\"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : \"\", undefined, onCompiled, onError, indexParameters || this._indexParameters);\n  };\n  /**\r\n   * The post process is reusable if it can be used multiple times within one frame.\r\n   * @returns If the post process is reusable\r\n   */\n\n\n  PostProcess.prototype.isReusable = function () {\n    return this._reusable;\n  };\n  /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n\n\n  PostProcess.prototype.markTextureDirty = function () {\n    this.width = -1;\n  };\n  /**\r\n   * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n   * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n   * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n   * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n   * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n   * @returns The target texture that was bound to be written to.\r\n   */\n\n\n  PostProcess.prototype.activate = function (camera, sourceTexture, forceDepthStencil) {\n    var _this = this;\n\n    if (sourceTexture === void 0) {\n      sourceTexture = null;\n    }\n\n    camera = camera || this._camera;\n    var scene = camera.getScene();\n    var engine = scene.getEngine();\n    var maxSize = engine.getCaps().maxTextureSize;\n    var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;\n    var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0; // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\n\n    var webVRCamera = camera.parent;\n\n    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\n      requiredWidth /= 2;\n    }\n\n    var desiredWidth = this._options.width || requiredWidth;\n    var desiredHeight = this._options.height || requiredHeight;\n    var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;\n\n    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n      if (this.adaptScaleToCurrentViewport) {\n        var currentViewport = engine.currentViewport;\n\n        if (currentViewport) {\n          desiredWidth *= currentViewport.width;\n          desiredHeight *= currentViewport.height;\n        }\n      }\n\n      if (needMipMaps || this.alwaysForcePOT) {\n        if (!this._options.width) {\n          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\n        }\n\n        if (!this._options.height) {\n          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\n        }\n      }\n\n      if (this.width !== desiredWidth || this.height !== desiredHeight) {\n        if (this._textures.length > 0) {\n          for (var i = 0; i < this._textures.length; i++) {\n            this._engine._releaseTexture(this._textures.data[i]);\n          }\n\n          this._textures.reset();\n        }\n\n        this.width = desiredWidth;\n        this.height = desiredHeight;\n        var textureSize = {\n          width: this.width,\n          height: this.height\n        };\n        var textureOptions = {\n          generateMipMaps: needMipMaps,\n          generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,\n          generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,\n          samplingMode: this.renderTargetSamplingMode,\n          type: this._textureType,\n          format: this._textureFormat\n        };\n\n        this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n\n        if (this._reusable) {\n          this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n        }\n\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n\n        this.onSizeChangedObservable.notifyObservers(this);\n      }\n\n      this._textures.forEach(function (texture) {\n        if (texture.samples !== _this.samples) {\n          _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);\n        }\n      });\n    }\n\n    var target;\n\n    if (this._shareOutputWithPostProcess) {\n      target = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      target = this._forcedOutputTexture;\n      this.width = this._forcedOutputTexture.width;\n      this.height = this._forcedOutputTexture.height;\n    } else {\n      target = this.inputTexture;\n    } // Bind the input of this post process to be used as the output of the previous post process.\n\n\n    if (this.enablePixelPerfectMode) {\n      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n\n      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\n    } else {\n      this._scaleRatio.copyFromFloats(1, 1);\n\n      this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\n    }\n\n    this.onActivateObservable.notifyObservers(camera); // Clear\n\n    if (this.autoClear && this.alphaMode === 0) {\n      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\n    }\n\n    if (this._reusable) {\n      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n    }\n\n    return target;\n  };\n\n  Object.defineProperty(PostProcess.prototype, \"isSupported\", {\n    /**\r\n     * If the post process is supported.\r\n     */\n    get: function () {\n      return this._effect.isSupported;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcess.prototype, \"aspectRatio\", {\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\n    get: function () {\n      if (this._shareOutputWithPostProcess) {\n        return this._shareOutputWithPostProcess.aspectRatio;\n      }\n\n      if (this._forcedOutputTexture) {\n        return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\n      }\n\n      return this.width / this.height;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get a value indicating if the post-process is ready to be used\r\n   * @returns true if the post-process is ready (shader is compiled)\r\n   */\n\n  PostProcess.prototype.isReady = function () {\n    return this._effect && this._effect.isReady();\n  };\n  /**\r\n   * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n   * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n   */\n\n\n  PostProcess.prototype.apply = function () {\n    // Check\n    if (!this._effect || !this._effect.isReady()) {\n      return null;\n    } // States\n\n\n    this._engine.enableEffect(this._effect);\n\n    this._engine.setState(false);\n\n    this._engine.setDepthBuffer(false);\n\n    this._engine.setDepthWrite(false); // Alpha\n\n\n    this._engine.setAlphaMode(this.alphaMode);\n\n    if (this.alphaConstants) {\n      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n    } // Bind the output texture of the preivous post process as the input to this post process.\n\n\n    var source;\n\n    if (this._shareOutputWithPostProcess) {\n      source = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      source = this._forcedOutputTexture;\n    } else {\n      source = this.inputTexture;\n    }\n\n    this._effect._bindTexture(\"textureSampler\", source); // Parameters\n\n\n    this._effect.setVector2(\"scale\", this._scaleRatio);\n\n    this.onApplyObservable.notifyObservers(this._effect);\n    return this._effect;\n  };\n\n  PostProcess.prototype._disposeTextures = function () {\n    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n      return;\n    }\n\n    if (this._textures.length > 0) {\n      for (var i = 0; i < this._textures.length; i++) {\n        this._engine._releaseTexture(this._textures.data[i]);\n      }\n    }\n\n    this._textures.dispose();\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  PostProcess.prototype.setPrePassRenderer = function (prePassRenderer) {\n    if (this._prePassEffectConfiguration) {\n      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n      this._prePassEffectConfiguration.enabled = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Disposes the post process.\r\n   * @param camera The camera to dispose the post process on.\r\n   */\n\n\n  PostProcess.prototype.dispose = function (camera) {\n    camera = camera || this._camera;\n\n    this._disposeTextures();\n\n    var index;\n\n    if (this._scene) {\n      index = this._scene.postProcesses.indexOf(this);\n\n      if (index !== -1) {\n        this._scene.postProcesses.splice(index, 1);\n      }\n    }\n\n    index = this._engine.postProcesses.indexOf(this);\n\n    if (index !== -1) {\n      this._engine.postProcesses.splice(index, 1);\n    }\n\n    if (!camera) {\n      return;\n    }\n\n    camera.detachPostProcess(this);\n    index = camera._postProcesses.indexOf(this);\n\n    if (index === 0 && camera._postProcesses.length > 0) {\n      var firstPostProcess = this._camera._getFirstPostProcess();\n\n      if (firstPostProcess) {\n        firstPostProcess.markTextureDirty();\n      }\n    }\n\n    this.onActivateObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onApplyObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onSizeChangedObservable.clear();\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @returns the JSON object\r\n   */\n\n\n  PostProcess.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.cameraId = this.getCamera().id;\n    serializationObject.reusable = this._reusable;\n    serializationObject.options = this._options;\n    serializationObject.textureType = this._textureType;\n    return serializationObject;\n  };\n  /**\r\n   * Creates a material from parsed material data\r\n   * @param parsedPostProcess defines parsed post process data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures\r\n   * @returns a new post process\r\n   */\n\n\n  PostProcess.Parse = function (parsedPostProcess, scene, rootUrl) {\n    var postProcessType = _TypeStore.GetClass(parsedPostProcess.customType);\n\n    if (!postProcessType || !postProcessType._Parse) {\n      return null;\n    }\n\n    var camera = scene.getCameraByID(parsedPostProcess.cameraId);\n\n    if (!camera) {\n      return null;\n    }\n\n    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\n  };\n\n  __decorate([serialize()], PostProcess.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"name\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"width\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"height\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"renderTargetSamplingMode\", void 0);\n\n  __decorate([serializeAsColor4()], PostProcess.prototype, \"clearColor\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"autoClear\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alphaConstants\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"enablePixelPerfectMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"forceFullscreenViewport\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"scaleMode\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"alwaysForcePOT\", void 0);\n\n  __decorate([serialize(\"samples\")], PostProcess.prototype, \"_samples\", void 0);\n\n  __decorate([serialize()], PostProcess.prototype, \"adaptScaleToCurrentViewport\", void 0);\n\n  return PostProcess;\n}();\n\nexport { PostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.PostProcess\"] = PostProcess;","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/postProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/postprocess.vertex\";\r\nimport { IInspectable } from '../Misc/iInspectable';\r\nimport { Engine } from '../Engines/engine';\r\nimport { Color4 } from '../Maths/math.color';\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { NodeMaterial } from '../Materials/Node/nodeMaterial';\r\nimport { serialize, serializeAsColor4, SerializationHelper } from '../Misc/decorators';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type WebVRFreeCamera = import(\"../Cameras/VR/webVRCamera\").WebVRFreeCamera;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type PrePassRenderer = import(\"../Rendering/prePassRenderer\").PrePassRenderer;\r\ndeclare type PrePassEffectConfiguration = import(\"../Rendering/prePassEffectConfiguration\").PrePassEffectConfiguration;\r\n\r\n/**\r\n * Size options for a post process\r\n */\r\nexport type PostProcessOptions = { width: number, height: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\r\nexport class PostProcess {\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** Name of the PostProcess. */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n    * Width of the texture to apply the post process on\r\n    */\r\n    @serialize()\r\n    public width = -1;\r\n\r\n    /**\r\n    * Height of the texture to apply the post process on\r\n    */\r\n    @serialize()\r\n    public height = -1;\r\n\r\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n    * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n    * @hidden\r\n    */\r\n    public _outputTexture: Nullable<InternalTexture> = null;\r\n    /**\r\n    * Sampling mode used by the shader\r\n    * See https://doc.babylonjs.com/classes/3.1/texture\r\n    */\r\n    @serialize()\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n    * Clear color to use when screen clearing\r\n    */\r\n    @serializeAsColor4()\r\n    public clearColor: Color4;\r\n    /**\r\n    * If the buffer needs to be cleared before applying the post process. (default: true)\r\n    * Should be set to false if shader will overwrite all previous pixels.\r\n    */\r\n    @serialize()\r\n    public autoClear = true;\r\n    /**\r\n    * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n    */\r\n    @serialize()\r\n    public alphaMode = 0;\r\n    /**\r\n    * Sets the setAlphaBlendConstants of the babylon engine\r\n    */\r\n    @serialize()\r\n    public alphaConstants: Color4;\r\n    /**\r\n    * Animations to be used for the post processing\r\n    */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    @serialize()\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    @serialize()\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    @serialize()\r\n    public scaleMode = 1;\r\n    /**\r\n    * Force textures to be a power of two (default: false)\r\n    */\r\n    @serialize()\r\n    public alwaysForcePOT = false;\r\n\r\n    @serialize(\"samples\")\r\n    private _samples = 1;\r\n\r\n    /**\r\n    * Number of sample textures (default: 1)\r\n    */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\r\n\r\n        this._textures.forEach((texture) => {\r\n            if (texture.samples !== this._samples) {\r\n                this._engine.updateRenderTargetTextureSampleCount(texture, this._samples);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Modify the scale of the post process to be the same as the viewport (default: false)\r\n    */\r\n    @serialize()\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    protected _scene: Scene;\r\n    private _engine: Engine;\r\n\r\n    private _options: number | PostProcessOptions;\r\n    private _reusable = false;\r\n    private _textureType: number;\r\n    private _textureFormat: number;\r\n    /**\r\n    * Smart array of input and output textures for the post process.\r\n    * @hidden\r\n    */\r\n    public _textures = new SmartArray<InternalTexture>(2);\r\n    /**\r\n    * The index in _textures that corresponds to the output texture.\r\n    * @hidden\r\n    */\r\n    public _currentRenderTextureInd = 0;\r\n    private _effect: Effect;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n    private _forcedOutputTexture: Nullable<InternalTexture>;\r\n\r\n    /**\r\n    * Prepass configuration in case this post process needs a texture from prepass\r\n    * @hidden\r\n    */\r\n    public _prePassEffectConfiguration: PrePassEffectConfiguration;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n    * An event triggered when the postprocess is activated.\r\n    */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n    * A function that is added to the onActivateObservable\r\n    */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the postprocess changes its size.\r\n    */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n    * A function that is added to the onSizeChangedObservable\r\n    */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the postprocess applies its effect.\r\n    */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onApplyObservable\r\n    */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the postprocess\r\n    */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onBeforeRenderObservable\r\n    */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the postprocess\r\n    */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onAfterRenderObservable\r\n    */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n    * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n    */\r\n    public get inputTexture(): InternalTexture {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: InternalTexture) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n    * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n    * the only way to unset it is to use this function to restore its internal state\r\n    */\r\n    public restoreDefaultInputTexture() {\r\n        this._forcedOutputTexture = null;\r\n    }\r\n\r\n    /**\r\n    * Gets the camera which post process is applied to.\r\n    * @returns The camera the post process is applied to.\r\n    */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n    * Gets the texel size of the postprocess.\r\n    * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n    */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string, parameters: Nullable<string[]>, samplers: Nullable<string[]>, options: number | PostProcessOptions, camera: Nullable<Camera>,\r\n        samplingMode: number = 1, engine?: Engine, reusable?: boolean, defines: Nullable<string> = null, textureType: number = 0, vertexUrl: string = \"postprocess\",\r\n        indexParameters?: any, blockCompilation = false, textureFormat = 5) {\r\n\r\n                this.name = name;\r\n            if (camera != null) {\r\n                this._camera = camera;\r\n                this._scene = camera.getScene();\r\n                camera.attachPostProcess(this);\r\n                this._engine = this._scene.getEngine();\r\n\r\n                this._scene.postProcesses.push(this);\r\n                this.uniqueId = this._scene.getUniqueId();\r\n            }\r\n            else if (engine) {\r\n                this._engine = engine;\r\n                this._engine.postProcesses.push(this);\r\n            }\r\n            this._options = options;\r\n            this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\r\n            this._reusable = reusable || false;\r\n            this._textureType = textureType;\r\n            this._textureFormat = textureFormat;\r\n\r\n            this._samplers = samplers || [];\r\n            this._samplers.push(\"textureSampler\");\r\n\r\n            this._fragmentUrl = fragmentUrl;\r\n            this._vertexUrl = vertexUrl;\r\n            this._parameters = parameters || [];\r\n\r\n            this._parameters.push(\"scale\");\r\n\r\n            this._indexParameters = indexParameters;\r\n\r\n            if (!blockCompilation) {\r\n                this.updateEffect(defines);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effect;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<InternalTexture>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n     */\r\n    public updateEffect(defines: Nullable<string> = null, uniforms: Nullable<string[]> = null, samplers: Nullable<string[]> = null, indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, vertexUrl?: string, fragmentUrl?: string) {\r\n        this._effect = this._engine.createEffect({ vertex: vertexUrl ?? this._vertexUrl, fragment: fragmentUrl ?? this._fragmentUrl },\r\n            [\"position\"],\r\n            uniforms || this._parameters,\r\n            samplers || this._samplers,\r\n            defines !== null ? defines : \"\",\r\n            undefined,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters || this._indexParameters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The target texture that was bound to be written to.\r\n     */\r\n    public activate(camera: Nullable<Camera>, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): InternalTexture {\r\n        camera = camera || this._camera;\r\n\r\n        var scene = camera.getScene();\r\n        var engine = scene.getEngine();\r\n        var maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        var requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        var requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\r\n        var webVRCamera = (<WebVRFreeCamera>camera.parent);\r\n        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\r\n            requiredWidth /= 2;\r\n        }\r\n\r\n        var desiredWidth = ((<PostProcessOptions>this._options).width || requiredWidth);\r\n        var desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        const needMipMaps =\r\n            this.renderTargetSamplingMode !== 7 &&\r\n            this.renderTargetSamplingMode !== 1 &&\r\n            this.renderTargetSamplingMode !== 2;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                let currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (needMipMaps || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight) {\r\n                if (this._textures.length > 0) {\r\n                    for (var i = 0; i < this._textures.length; i++) {\r\n                        this._engine._releaseTexture(this._textures.data[i]);\r\n                    }\r\n                    this._textures.reset();\r\n                }\r\n                this.width = desiredWidth;\r\n                this.height = desiredHeight;\r\n\r\n                let textureSize = { width: this.width, height: this.height };\r\n                let textureOptions = {\r\n                    generateMipMaps: needMipMaps,\r\n                    generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,\r\n                    generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,\r\n                    samplingMode: this.renderTargetSamplingMode,\r\n                    type: this._textureType,\r\n                    format: this._textureFormat\r\n                };\r\n\r\n                this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\r\n\r\n                if (this._reusable) {\r\n                    this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\r\n                }\r\n\r\n                this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n                this.onSizeChangedObservable.notifyObservers(this);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n        }\r\n\r\n        var target: InternalTexture;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        }\r\n        else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this.onActivateObservable.notifyObservers(camera);\r\n\r\n        // Clear\r\n        if (this.autoClear && this.alphaMode === 0) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._effect.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._effect && this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._effect || !this._effect.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._effect);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        this._engine.setAlphaMode(this.alphaMode);\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        var source: InternalTexture;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n        this._effect._bindTexture(\"textureSampler\", source);\r\n\r\n        // Parameters\r\n        this._effect.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._effect);\r\n\r\n        return this._effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._textures.length > 0) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._engine._releaseTexture(this._textures.data[i]);\r\n            }\r\n        }\r\n        this._textures.dispose();\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        if (this._prePassEffectConfiguration) {\r\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n            this._prePassEffectConfiguration.enabled = true;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        this._disposeTextures();\r\n\r\n        let index;\r\n        if (this._scene) {\r\n            index = this._scene.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._scene.postProcesses.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        index = this._engine.postProcesses.indexOf(this);\r\n        if (index !== -1) {\r\n            this._engine.postProcesses.splice(index, 1);\r\n        }\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            var firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.cameraId = this.getCamera().id;\r\n        serializationObject.reusable = this._reusable;\r\n        serializationObject.options = this._options;\r\n        serializationObject.textureType = this._textureType;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedPostProcess defines parsed post process data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new post process\r\n     */\r\n    public static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        var postProcessType = _TypeStore.GetClass(parsedPostProcess.customType);\r\n\r\n        if (!postProcessType || !postProcessType._Parse) {\r\n            return null;\r\n        }\r\n\r\n        var camera = scene.getCameraByID(parsedPostProcess.cameraId);\r\n\r\n        if (!camera) {\r\n            return null;\r\n        }\r\n\r\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.PostProcess\"] = PostProcess;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}