{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Material } from \"../Materials/material\";\nimport { Tags } from \"../Misc/tags\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\n\nvar MultiMaterial =\n/** @class */\nfunction (_super) {\n  __extends(MultiMaterial, _super);\n  /**\r\n   * Instantiates a new Multi Material\r\n   * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n   * separate meshes. This can be use to improve performances.\r\n   * @see https://doc.babylonjs.com/how_to/multi_materials\r\n   * @param name Define the name in the scene\r\n   * @param scene Define the scene the material belongs to\r\n   */\n\n\n  function MultiMaterial(name, scene) {\n    var _this = _super.call(this, name, scene, true) || this;\n\n    scene.multiMaterials.push(_this);\n    _this.subMaterials = new Array();\n    _this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\n\n    return _this;\n  }\n\n  Object.defineProperty(MultiMaterial.prototype, \"subMaterials\", {\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\n    get: function () {\n      return this._subMaterials;\n    },\n    set: function (value) {\n      this._subMaterials = value;\n\n      this._hookArray(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Function used to align with Node.getChildren()\r\n   * @returns the list of Materials used within the multi material\r\n   */\n\n  MultiMaterial.prototype.getChildren = function () {\n    return this.subMaterials;\n  };\n\n  MultiMaterial.prototype._hookArray = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var result = oldPush.apply(array, items);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      _this._markAllSubMeshesAsTexturesDirty();\n\n      return deleted;\n    };\n  };\n  /**\r\n   * Get one of the submaterial by its index in the submaterials array\r\n   * @param index The index to look the sub material at\r\n   * @returns The Material if the index has been defined\r\n   */\n\n\n  MultiMaterial.prototype.getSubMaterial = function (index) {\n    if (index < 0 || index >= this.subMaterials.length) {\n      return this.getScene().defaultMaterial;\n    }\n\n    return this.subMaterials[index];\n  };\n  /**\r\n   * Get the list of active textures for the whole sub materials list.\r\n   * @returns All the textures that will be used during the rendering\r\n   */\n\n\n  MultiMaterial.prototype.getActiveTextures = function () {\n    var _a;\n\n    return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function (subMaterial) {\n      if (subMaterial) {\n        return subMaterial.getActiveTextures();\n      } else {\n        return [];\n      }\n    }));\n  };\n  /**\r\n   * Specifies if any sub-materials of this multi-material use a given texture.\r\n   * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n   * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n   */\n\n\n  MultiMaterial.prototype.hasTexture = function (texture) {\n    var _a;\n\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    for (var i = 0; i < this.subMaterials.length; i++) {\n      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n   * Mainly use in serialization.\r\n   * @returns the class name\r\n   */\n\n\n  MultiMaterial.prototype.getClassName = function () {\n    return \"MultiMaterial\";\n  };\n  /**\r\n   * Checks if the material is ready to render the requested sub mesh\r\n   * @param mesh Define the mesh the submesh belongs to\r\n   * @param subMesh Define the sub mesh to look readyness for\r\n   * @param useInstances Define whether or not the material is used with instances\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  MultiMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = this.subMaterials[index];\n\n      if (subMaterial) {\n        if (subMaterial._storeEffectOnSubMeshes) {\n          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\n            return false;\n          }\n\n          continue;\n        }\n\n        if (!subMaterial.isReady(mesh)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Clones the current material and its related sub materials\r\n   * @param name Define the name of the newly cloned material\r\n   * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n   * @returns the cloned material\r\n   */\n\n\n  MultiMaterial.prototype.clone = function (name, cloneChildren) {\n    var newMultiMaterial = new MultiMaterial(name, this.getScene());\n\n    for (var index = 0; index < this.subMaterials.length; index++) {\n      var subMaterial = null;\n      var current = this.subMaterials[index];\n\n      if (cloneChildren && current) {\n        subMaterial = current.clone(name + \"-\" + current.name);\n      } else {\n        subMaterial = this.subMaterials[index];\n      }\n\n      newMultiMaterial.subMaterials.push(subMaterial);\n    }\n\n    return newMultiMaterial;\n  };\n  /**\r\n   * Serializes the materials into a JSON representation.\r\n   * @returns the JSON representation\r\n   */\n\n\n  MultiMaterial.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    serializationObject.materials = [];\n\n    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n      var subMat = this.subMaterials[matIndex];\n\n      if (subMat) {\n        serializationObject.materials.push(subMat.id);\n      } else {\n        serializationObject.materials.push(null);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Dispose the material and release its associated resources\r\n   * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n   * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n   * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n   */\n\n\n  MultiMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    if (forceDisposeChildren) {\n      for (var index = 0; index < this.subMaterials.length; index++) {\n        var subMaterial = this.subMaterials[index];\n\n        if (subMaterial) {\n          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\n        }\n      }\n    }\n\n    var index = scene.multiMaterials.indexOf(this);\n\n    if (index >= 0) {\n      scene.multiMaterials.splice(index, 1);\n    }\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n  };\n  /**\r\n   * Creates a MultiMaterial from parsed MultiMaterial data.\r\n   * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n   * @param scene defines the hosting scene\r\n   * @returns a new MultiMaterial\r\n   */\n\n\n  MultiMaterial.ParseMultiMaterial = function (parsedMultiMaterial, scene) {\n    var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\n    multiMaterial.id = parsedMultiMaterial.id;\n\n    if (Tags) {\n      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n    }\n\n    for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\n      var subMatId = parsedMultiMaterial.materials[matIndex];\n\n      if (subMatId) {\n        // If the same multimaterial is loaded twice, the 2nd multimaterial needs to reference the latest material by that id which\n        // is why this lookup should use getLastMaterialByID instead of getMaterialByID\n        multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));\n      } else {\n        multiMaterial.subMaterials.push(null);\n      }\n    }\n\n    return multiMaterial;\n  };\n\n  return MultiMaterial;\n}(Material);\n\nexport { MultiMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.MultiMaterial\"] = MultiMaterial;","map":{"version":3,"sources":["../../../sourceES6/core/Materials/multiMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/how_to/multi_materials\r\n */\r\nexport class MultiMaterial extends Material {\r\n    private _subMaterials: Nullable<Material>[];\r\n\r\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\r\n    public get subMaterials(): Nullable<Material>[] {\r\n        return this._subMaterials;\r\n    }\r\n\r\n    public set subMaterials(value: Nullable<Material>[]) {\r\n        this._subMaterials = value;\r\n        this._hookArray(value);\r\n    }\r\n\r\n    /**\r\n     * Function used to align with Node.getChildren()\r\n     * @returns the list of Materials used within the multi material\r\n     */\r\n    public getChildren(): Nullable<Material>[] {\r\n        return this.subMaterials;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Multi Material\r\n     * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n     * separate meshes. This can be use to improve performances.\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     * @param name Define the name in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene, true);\r\n\r\n        scene.multiMaterials.push(this);\r\n\r\n        this.subMaterials = new Array<Material>();\r\n\r\n        this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\r\n    }\r\n\r\n    private _hookArray(array: Nullable<Material>[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: Nullable<Material>[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get one of the submaterial by its index in the submaterials array\r\n     * @param index The index to look the sub material at\r\n     * @returns The Material if the index has been defined\r\n     */\r\n    public getSubMaterial(index: number): Nullable<Material> {\r\n        if (index < 0 || index >= this.subMaterials.length) {\r\n            return this.getScene().defaultMaterial;\r\n        }\r\n\r\n        return this.subMaterials[index];\r\n    }\r\n\r\n    /**\r\n     * Get the list of active textures for the whole sub materials list.\r\n     * @returns All the textures that will be used during the rendering\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        return super.getActiveTextures().concat(...this.subMaterials.map((subMaterial) => {\r\n            if (subMaterial) {\r\n                return subMaterial.getActiveTextures();\r\n            } else {\r\n                return [];\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Specifies if any sub-materials of this multi-material use a given texture.\r\n     * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n     * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < this.subMaterials.length; i++) {\r\n            if (this.subMaterials[i]?.hasTexture(texture)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MultiMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested sub mesh\r\n     * @param mesh Define the mesh the submesh belongs to\r\n     * @param subMesh Define the sub mesh to look readyness for\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial = this.subMaterials[index];\r\n            if (subMaterial) {\r\n                if (subMaterial._storeEffectOnSubMeshes) {\r\n                    if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!subMaterial.isReady(mesh)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones the current material and its related sub materials\r\n     * @param name Define the name of the newly cloned material\r\n     * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneChildren?: boolean): MultiMaterial {\r\n        var newMultiMaterial = new MultiMaterial(name, this.getScene());\r\n\r\n        for (var index = 0; index < this.subMaterials.length; index++) {\r\n            var subMaterial: Nullable<Material> = null;\r\n            let current = this.subMaterials[index];\r\n            if (cloneChildren && current) {\r\n                subMaterial = current.clone(name + \"-\" + current.name);\r\n            } else {\r\n                subMaterial = this.subMaterials[index];\r\n            }\r\n            newMultiMaterial.subMaterials.push(subMaterial);\r\n        }\r\n\r\n        return newMultiMaterial;\r\n    }\r\n\r\n    /**\r\n     * Serializes the materials into a JSON representation.\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.materials = [];\r\n\r\n        for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\r\n            var subMat = this.subMaterials[matIndex];\r\n\r\n            if (subMat) {\r\n                serializationObject.materials.push(subMat.id);\r\n            } else {\r\n                serializationObject.materials.push(null);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and release its associated resources\r\n     * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n     * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, forceDisposeChildren?: boolean): void {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (forceDisposeChildren) {\r\n            for (var index = 0; index < this.subMaterials.length; index++) {\r\n                var subMaterial = this.subMaterials[index];\r\n                if (subMaterial) {\r\n                    subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\r\n                }\r\n            }\r\n        }\r\n\r\n        var index = scene.multiMaterials.indexOf(this);\r\n        if (index >= 0) {\r\n            scene.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Creates a MultiMaterial from parsed MultiMaterial data.\r\n     * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MultiMaterial\r\n     */\r\n    public static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial {\r\n        var multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\r\n\r\n        multiMaterial.id = parsedMultiMaterial.id;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\r\n        }\r\n\r\n        for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\r\n            var subMatId = parsedMultiMaterial.materials[matIndex];\r\n\r\n            if (subMatId) {\r\n                // If the same multimaterial is loaded twice, the 2nd multimaterial needs to reference the latest material by that id which\r\n                // is why this lookup should use getLastMaterialByID instead of getMaterialByID\r\n                multiMaterial.subMaterials.push(scene.getLastMaterialByID(subMatId));\r\n            } else {\r\n                multiMaterial.subMaterials.push(null);\r\n            }\r\n        }\r\n\r\n        return multiMaterial;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.MultiMaterial\"] = MultiMaterial;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}