{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/linesBuilder\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n/**\r\n * Single plane rotation gizmo\r\n */\n\nvar PlaneRotationGizmo =\n/** @class */\nfunction (_super) {\n  __extends(PlaneRotationGizmo, _super);\n  /**\r\n   * Creates a PlaneRotationGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\r\n   * @param color The color of the gizmo\r\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n   * @param thickness display gizmo axis thickness\r\n   */\n\n\n  function PlaneRotationGizmo(planeNormal, color, gizmoLayer, tessellation, parent, useEulerRotation, thickness) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (tessellation === void 0) {\n      tessellation = 32;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (useEulerRotation === void 0) {\n      useEulerRotation = false;\n    }\n\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._pointerObserver = null;\n    /**\r\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\r\n     */\n\n    _this.snapDistance = 0;\n    /**\r\n     * Event that fires each time the gizmo snaps to a new location.\r\n     * * snapDistance is the the change in distance\r\n     */\n\n    _this.onSnapObservable = new Observable();\n    _this._isEnabled = true;\n    _this._parent = null;\n    _this._dragging = false;\n    _this._parent = parent; // Create Material\n\n    _this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._coloredMaterial.diffuseColor = color;\n    _this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    _this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._hoverMaterial.diffuseColor = Color3.Yellow();\n    _this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this._disableMaterial.diffuseColor = Color3.Gray();\n    _this._disableMaterial.alpha = 0.4; // Build mesh on root node\n\n    _this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n\n    var _b = _this._createGizmoMesh(_this._gizmoMesh, thickness, tessellation),\n        rotationMesh = _b.rotationMesh,\n        collider = _b.collider; // Setup Rotation Circle\n\n\n    var rotationCirclePaths = [];\n    _this._rotationCircle = _this.setupRotationCircle(rotationCirclePaths, _this._gizmoMesh);\n\n    _this._gizmoMesh.lookAt(_this._rootMesh.position.add(planeNormal));\n\n    _this._rootMesh.addChild(_this._gizmoMesh);\n\n    _this._gizmoMesh.scaling.scaleInPlace(1 / 3); // Add drag behavior to handle events when the gizmo is dragged\n\n\n    _this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: planeNormal\n    });\n    _this.dragBehavior.moveAttached = false;\n    _this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;\n    _this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n\n    _this._rootMesh.addBehavior(_this.dragBehavior); // Closures for drag logic\n\n\n    var dragDistance = 0;\n    var lastDragPosition = new Vector3();\n    var dragPlanePoint = new Vector3();\n    var rotationMatrix = new Matrix();\n    var planeNormalTowardsCamera = new Vector3();\n    var localPlaneNormalTowardsCamera = new Vector3();\n\n    _this.dragBehavior.onDragStartObservable.add(function (e) {\n      if (_this.attachedNode) {\n        lastDragPosition.copyFrom(e.dragPlanePoint); // This is for instantiation location of rotation circle\n\n        var forward = new Vector3(0, 0, 1);\n\n        var direction = _this._rotationCircle.getDirection(forward);\n\n        direction.normalize(); // Remove Rotation Circle from parent mesh before drag interaction\n\n        _this._gizmoMesh.removeChild(_this._rotationCircle);\n\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n        dragPlanePoint = e.dragPlanePoint;\n\n        var origin_1 = _this._rotationCircle.getAbsolutePosition().clone();\n\n        var originalRotationPoint = _this._rotationCircle.getAbsolutePosition().clone().addInPlace(direction);\n\n        var dragStartPoint = e.dragPlanePoint;\n        var angle = Vector3.GetAngleBetweenVectors(originalRotationPoint.subtract(origin_1), dragStartPoint.subtract(origin_1), _this._rotationCircle.up);\n\n        _this._rotationCircle.addRotation(0, angle, 0);\n\n        _this._dragging = true;\n      }\n    });\n\n    _this.dragBehavior.onDragEndObservable.add(function () {\n      dragDistance = 0;\n\n      _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n\n      _this._gizmoMesh.addChild(_this._rotationCircle); // Add rotation circle back to parent mesh after drag behavior\n\n\n      _this._dragging = false;\n    });\n\n    var tmpSnapEvent = {\n      snapDistance: 0\n    };\n    var currentSnapDragDistance = 0;\n    var tmpMatrix = new Matrix();\n    var amountToRotate = new Quaternion();\n\n    _this.dragBehavior.onDragObservable.add(function (event) {\n      if (_this.attachedNode) {\n        // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n        var nodeScale = new Vector3(1, 1, 1);\n        var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n        var nodeTranslation = new Vector3(0, 0, 0);\n\n        _this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n        var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n        var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n        var cross = Vector3.Cross(newVector, originalVector);\n        var dot = Vector3.Dot(newVector, originalVector);\n        var angle = Math.atan2(cross.length(), dot);\n        planeNormalTowardsCamera.copyFrom(planeNormal);\n        localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          nodeQuaternion.toRotationMatrix(rotationMatrix);\n          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n        } // Flip up vector depending on which side the camera is on\n\n\n        var cameraFlipped = false;\n\n        if (gizmoLayer.utilityLayerScene.activeCamera) {\n          var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation);\n\n          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n            planeNormalTowardsCamera.scaleInPlace(-1);\n            localPlaneNormalTowardsCamera.scaleInPlace(-1);\n            cameraFlipped = true;\n          }\n        }\n\n        var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n\n        if (halfCircleSide) {\n          angle = -angle;\n        } // Snapping logic\n\n\n        var snapped = false;\n\n        if (_this.snapDistance != 0) {\n          currentSnapDragDistance += angle;\n\n          if (Math.abs(currentSnapDragDistance) > _this.snapDistance) {\n            var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / _this.snapDistance);\n\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n\n            currentSnapDragDistance = currentSnapDragDistance % _this.snapDistance;\n            angle = _this.snapDistance * dragSteps;\n            snapped = true;\n          } else {\n            angle = 0;\n          }\n        }\n\n        dragDistance += cameraFlipped ? -angle : angle;\n\n        _this.updateRotationCircle(_this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint); // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n\n\n        var quaternionCoefficient = Math.sin(angle / 2);\n        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2)); // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n\n        if (tmpMatrix.determinant() > 0) {\n          var tmpVector = new Vector3();\n          amountToRotate.toEulerAnglesToRef(tmpVector);\n          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n        }\n\n        if (_this.updateGizmoRotationToMatchAttachedMesh) {\n          // Rotate selected mesh quaternion over fixed axis\n          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n        } else {\n          // Rotate selected mesh quaternion over rotated axis\n          amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n        } // recompose matrix\n\n\n        _this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n        lastDragPosition.copyFrom(event.dragPlanePoint);\n\n        if (snapped) {\n          tmpSnapEvent.snapDistance = angle;\n\n          _this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n\n        _this._matrixChanged();\n      }\n    });\n\n    var light = gizmoLayer._getSharedGizmoLight();\n\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(_this._rootMesh.getChildMeshes(false));\n    var cache = {\n      colliderMeshes: [collider],\n      gizmoMeshes: [rotationMesh],\n      material: _this._coloredMaterial,\n      hoverMaterial: _this._hoverMaterial,\n      disableMaterial: _this._disableMaterial,\n      active: false\n    };\n    (_a = _this._parent) === null || _a === void 0 ? void 0 : _a.addToAxisCache(_this._gizmoMesh, cache);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a;\n\n      if (_this._customMeshSet) {\n        return;\n      }\n\n      _this._isHovered = !!(cache.colliderMeshes.indexOf((_a = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) != -1);\n\n      if (!_this._parent) {\n        var material = _this._isHovered || _this._dragging ? _this._hoverMaterial : _this._coloredMaterial;\n        cache.gizmoMeshes.forEach(function (m) {\n          m.material = material;\n\n          if (m.color) {\n            m.color = material.diffuseColor;\n          }\n        });\n      }\n    });\n    return _this;\n  }\n  /** Create Geometry for Gizmo */\n\n\n  PlaneRotationGizmo.prototype._createGizmoMesh = function (parentMesh, thickness, tessellation) {\n    var collider = Mesh.CreateTorus(\"ignore\", 0.6, 0.03 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n    collider.visibility = 0;\n    var rotationMesh = Mesh.CreateTorus(\"\", 0.6, 0.005 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n    rotationMesh.material = this._coloredMaterial; // Position arrow pointing in its drag axis\n\n    rotationMesh.rotation.x = Math.PI / 2;\n    collider.rotation.x = Math.PI / 2;\n    parentMesh.addChild(rotationMesh);\n    parentMesh.addChild(collider);\n    return {\n      rotationMesh: rotationMesh,\n      collider: collider\n    };\n  };\n\n  PlaneRotationGizmo.prototype._attachedNodeChanged = function (value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  };\n\n  PlaneRotationGizmo.prototype.setupRotationCircle = function (paths, parentMesh) {\n    var fillRadians = 0;\n    var step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n\n    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n      var path = [];\n\n      for (var i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n        if (i < fillRadians) {\n          var x = PlaneRotationGizmo._CircleConstants.radius * Math.sin(i) * Math.cos(p);\n          var z = PlaneRotationGizmo._CircleConstants.radius * Math.cos(i) * Math.cos(p);\n          var y = 0;\n          path.push(new Vector3(x, y, z));\n        } else {\n          path.push(new Vector3(0, 0, 0));\n        }\n      }\n\n      paths.push(path);\n    }\n\n    var mat = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    mat.diffuseColor = Color3.Yellow();\n    mat.backFaceCulling = false;\n    var mesh = Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, true);\n    mesh.material = mat;\n    mesh.material.alpha = .25;\n    mesh.rotation.x = Math.PI / 2;\n    parentMesh.addChild(mesh);\n    return mesh;\n  };\n\n  PlaneRotationGizmo.prototype.updateRotationPath = function (pathArr, newFill) {\n    // To update the Ribbon, you have to mutate the pathArray in-place\n    var step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n    var tessellationCounter = 0;\n\n    for (var p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n      var path = pathArr[tessellationCounter];\n\n      if (path) {\n        var radianCounter = 0;\n\n        for (var i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n          if (path[radianCounter]) {\n            if (i < Math.abs(newFill)) {\n              var absI = newFill > 0 ? i : i * -1;\n              var absP = newFill > 0 ? p : p * -1;\n              path[radianCounter].set(PlaneRotationGizmo._CircleConstants.radius * Math.sin(absI) * Math.cos(absP), 0, PlaneRotationGizmo._CircleConstants.radius * Math.cos(absI) * Math.cos(absP));\n            } else {\n              path[radianCounter].set(0, 0, 0);\n            }\n          }\n\n          radianCounter++;\n        }\n      }\n\n      tessellationCounter++;\n    }\n  };\n\n  PlaneRotationGizmo.prototype.updateRotationCircle = function (mesh, paths, newFill, dragPlanePoint) {\n    this.updateRotationPath(paths, newFill);\n    Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, undefined, undefined, mesh.geometry ? mesh : undefined);\n  };\n\n  Object.defineProperty(PlaneRotationGizmo.prototype, \"isEnabled\", {\n    get: function () {\n      return this._isEnabled;\n    },\n\n    /**\r\n         * If the gizmo is enabled\r\n         */\n    set: function (value) {\n      this._isEnabled = value;\n\n      if (!value) {\n        this.attachedMesh = null;\n      } else {\n        if (this._parent) {\n          this.attachedMesh = this._parent.attachedMesh;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n  PlaneRotationGizmo.prototype.dispose = function () {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n\n    if (this._rotationCircle) {\n      this._rotationCircle.dispose();\n    }\n\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(function (matl) {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n\n    _super.prototype.dispose.call(this);\n  };\n\n  PlaneRotationGizmo._CircleConstants = {\n    radius: 0.3,\n    pi2: Math.PI * 2,\n    tessellation: 70,\n    rotationCircleRange: 4\n  };\n  return PlaneRotationGizmo;\n}(Gizmo);\n\nexport { PlaneRotationGizmo };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/planeRotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\nimport { Nullable } from \"../types\";\nimport { PointerInfo } from \"../Events/pointerEvents\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/linesBuilder\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { LinesMesh } from '../Meshes/linesMesh';\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Node } from \"../node\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo, GizmoAxisCache } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { RotationGizmo } from \"./rotationGizmo\";\n\n/**\n * Single plane rotation gizmo\n */\nexport class PlaneRotationGizmo extends Gizmo {\n    /**\n     * Drag behavior responsible for the gizmos dragging interactions\n     */\n    public dragBehavior: PointerDragBehavior;\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\n\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n    public snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\n\n    private _isEnabled: boolean = true;\n    private _parent: Nullable<RotationGizmo> = null;\n    private _coloredMaterial: StandardMaterial;\n    private _hoverMaterial: StandardMaterial;\n    private _disableMaterial: StandardMaterial;\n    private _gizmoMesh: Mesh;\n    private _rotationCircle: Mesh;\n    private _dragging: boolean = false;\n\n    private static _CircleConstants = {\n        radius: 0.3,\n        pi2: Math.PI * 2,\n        tessellation: 70,\n        rotationCircleRange: 4\n    };\n\n    /**\n     * Creates a PlaneRotationGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n     * @param color The color of the gizmo\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\n     * @param thickness display gizmo axis thickness\n     */\n    constructor(planeNormal: Vector3, color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent: Nullable<RotationGizmo> = null, useEulerRotation = false, thickness: number = 1) {\n        super(gizmoLayer);\n        this._parent = parent;\n        // Create Material\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = color;\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\n\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = Color3.Gray();\n        this._disableMaterial.alpha = 0.4;\n\n        // Build mesh on root node\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\n\n        // Setup Rotation Circle\n        const rotationCirclePaths: any[] = [];\n        this._rotationCircle = this.setupRotationCircle(rotationCirclePaths, this._gizmoMesh);\n\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\n        this._rootMesh.addChild(this._gizmoMesh);\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n        // Add drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\n        this.dragBehavior.moveAttached = false;\n        this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n        this._rootMesh.addBehavior(this.dragBehavior);\n\n        // Closures for drag logic\n        let dragDistance = 0;\n        const lastDragPosition = new Vector3();\n        let dragPlanePoint = new Vector3();\n        const rotationMatrix = new Matrix();\n        const planeNormalTowardsCamera = new Vector3();\n        let localPlaneNormalTowardsCamera = new Vector3();\n\n        this.dragBehavior.onDragStartObservable.add((e) => {\n            if (this.attachedNode) {\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n\n                // This is for instantiation location of rotation circle\n                const forward = new Vector3(0, 0, 1);\n                const direction = this._rotationCircle.getDirection(forward);\n                direction.normalize();\n\n                // Remove Rotation Circle from parent mesh before drag interaction\n                this._gizmoMesh.removeChild(this._rotationCircle);\n\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n                dragPlanePoint = e.dragPlanePoint;\n                const origin = this._rotationCircle.getAbsolutePosition().clone();\n                const originalRotationPoint = this._rotationCircle.getAbsolutePosition().clone().addInPlace(direction);\n                const dragStartPoint = e.dragPlanePoint;\n                const angle = Vector3.GetAngleBetweenVectors(originalRotationPoint.subtract(origin), dragStartPoint.subtract(origin), this._rotationCircle.up);\n\n                this._rotationCircle.addRotation(0, angle, 0);\n                this._dragging = true;\n            }\n        });\n\n        this.dragBehavior.onDragEndObservable.add(() => {\n            dragDistance = 0;\n            this.updateRotationCircle(this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n            this._gizmoMesh.addChild(this._rotationCircle);    // Add rotation circle back to parent mesh after drag behavior\n            this._dragging = false;\n        });\n\n        var tmpSnapEvent = { snapDistance: 0 };\n        var currentSnapDragDistance = 0;\n        var tmpMatrix = new Matrix();\n        var amountToRotate = new Quaternion();\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedNode) {\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n                var nodeScale = new Vector3(1, 1, 1);\n                var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n                var nodeTranslation = new Vector3(0, 0, 0);\n                this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n                var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n                var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n                var cross = Vector3.Cross(newVector, originalVector);\n                var dot = Vector3.Dot(newVector, originalVector);\n                var angle = Math.atan2(cross.length(), dot);\n                planeNormalTowardsCamera.copyFrom(planeNormal);\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    nodeQuaternion.toRotationMatrix(rotationMatrix);\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n                }\n                // Flip up vector depending on which side the camera is on\n                let cameraFlipped = false;\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\n                    var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation);\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n                        planeNormalTowardsCamera.scaleInPlace(-1);\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\n                        cameraFlipped = true;\n                    }\n                }\n                var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n                if (halfCircleSide) { angle = -angle; }\n\n                // Snapping logic\n                var snapped = false;\n                if (this.snapDistance != 0) {\n                    currentSnapDragDistance += angle;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        if (currentSnapDragDistance < 0) {\n                            dragSteps *= -1;\n                        }\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        angle = this.snapDistance * dragSteps;\n                        snapped = true;\n                    } else {\n                        angle = 0;\n                    }\n                }\n\n                dragDistance += cameraFlipped ? -angle : angle;\n                this.updateRotationCircle(this._rotationCircle, rotationCirclePaths, dragDistance, dragPlanePoint);\n\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n                var quaternionCoefficient = Math.sin(angle / 2);\n                amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));\n\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n                if (tmpMatrix.determinant() > 0) {\n                    var tmpVector = new Vector3();\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n                }\n\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    // Rotate selected mesh quaternion over fixed axis\n                    nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n                } else {\n                    // Rotate selected mesh quaternion over rotated axis\n                    amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n                }\n\n                // recompose matrix\n                this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n                lastDragPosition.copyFrom(event.dragPlanePoint);\n                if (snapped) {\n                    tmpSnapEvent.snapDistance = angle;\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                }\n\n                this._matrixChanged();\n            }\n        });\n\n        var light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n\n        const cache: GizmoAxisCache = {\n            colliderMeshes: [ collider ],\n            gizmoMeshes: [ rotationMesh ],\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false\n        };\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\n\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\n            if (!this._parent) {\n                var material = this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial;\n                cache.gizmoMeshes.forEach((m: Mesh) => {\n                    m.material = material;\n                    if ((<LinesMesh>m).color) {\n                        (<LinesMesh>m).color = material.diffuseColor;\n                    }\n                });\n            }\n        });\n    }\n\n    /** Create Geometry for Gizmo */\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, tessellation: number) {\n        let collider = Mesh.CreateTorus(\"ignore\", 0.6, 0.03 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n        collider.visibility = 0;\n        let rotationMesh = Mesh.CreateTorus(\"\", 0.6, 0.005 * thickness, tessellation, this.gizmoLayer.utilityLayerScene);\n        rotationMesh.material = this._coloredMaterial;\n\n        // Position arrow pointing in its drag axis\n        rotationMesh.rotation.x = Math.PI / 2;\n        collider.rotation.x = Math.PI / 2;\n\n        parentMesh.addChild(rotationMesh);\n        parentMesh.addChild(collider);\n        return { rotationMesh, collider };\n    }\n\n    protected _attachedNodeChanged(value: Nullable<Node>) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n\n    private setupRotationCircle(paths: Vector3[][], parentMesh: AbstractMesh): Mesh {\n        const fillRadians = 0;\n        const step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n        for (let p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n            const path: Vector3[] = [];\n            for (let i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n                if (i < fillRadians) {\n                    const x = PlaneRotationGizmo._CircleConstants.radius * Math.sin(i) * Math.cos(p);\n                    const z = PlaneRotationGizmo._CircleConstants.radius * Math.cos(i) * Math.cos(p);\n                    const y = 0;\n                    path.push(new Vector3(x, y, z));\n                } else {\n                    path.push(new Vector3(0, 0, 0));\n                }\n            }\n\n            paths.push(path);\n        }\n\n        const mat = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n        mat.diffuseColor = Color3.Yellow();\n        mat.backFaceCulling = false;\n        const mesh = Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, true);\n        mesh.material = mat;\n        mesh.material.alpha = .25;\n        mesh.rotation.x = Math.PI / 2;\n        parentMesh.addChild(mesh);\n        return mesh;\n    }\n\n    private updateRotationPath(pathArr: Vector3[][], newFill: number): void {\n        // To update the Ribbon, you have to mutate the pathArray in-place\n        const step = PlaneRotationGizmo._CircleConstants.pi2 / PlaneRotationGizmo._CircleConstants.tessellation;\n        let tessellationCounter = 0;\n        for (let p = -Math.PI / 2; p < Math.PI / 2 - 1.5; p += step / 2) {\n            const path = pathArr[tessellationCounter];\n            if (path) {\n                let radianCounter = 0;\n                for (let i = 0; i < PlaneRotationGizmo._CircleConstants.pi2 * PlaneRotationGizmo._CircleConstants.rotationCircleRange + 0.01; i += step) {\n                    if (path[radianCounter]) {\n                        if (i < Math.abs(newFill)) {\n                            const absI = (newFill > 0) ? i : i * -1;\n                            const absP = (newFill > 0) ? p : p * -1;\n                            path[radianCounter].set(\n                                PlaneRotationGizmo._CircleConstants.radius * Math.sin(absI) * Math.cos(absP),\n                                0,\n                                PlaneRotationGizmo._CircleConstants.radius * Math.cos(absI) * Math.cos(absP)\n                            );\n                        } else {\n                            path[radianCounter].set(0, 0, 0);\n                        }\n                    }\n\n                    radianCounter++;\n                }\n            }\n\n            tessellationCounter ++;\n        }\n    }\n\n    private updateRotationCircle(mesh: Mesh, paths: any[], newFill: number, dragPlanePoint: Vector3): void {\n        this.updateRotationPath(paths, newFill);\n        Mesh.CreateRibbon(\"rotationCircle\", paths, false, false, 0, this.gizmoLayer.utilityLayerScene, undefined, undefined, mesh.geometry ? mesh : undefined);\n    }\n\n    /**\n         * If the gizmo is enabled\n         */\n    public set isEnabled(value: boolean) {\n        this._isEnabled = value;\n        if (!value) {\n            this.attachedMesh = null;\n        }\n        else {\n            if (this._parent) {\n                this.attachedMesh = this._parent.attachedMesh;\n            }\n        }\n    }\n    public get isEnabled(): boolean {\n        return this._isEnabled;\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    public dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        if (this._gizmoMesh) {\n            this._gizmoMesh.dispose();\n        }\n        if (this._rotationCircle) {\n            this._rotationCircle.dispose();\n        }\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n        super.dispose();\n    }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}