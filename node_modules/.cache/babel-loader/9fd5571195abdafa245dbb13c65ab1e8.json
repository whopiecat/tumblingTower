{"ast":null,"code":"import { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\nimport { Animation } from \"../../Animations/animation\";\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\n\nvar FramingBehavior =\n/** @class */\nfunction () {\n  function FramingBehavior() {\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\n\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity; // Framing control\n\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n\n  Object.defineProperty(FramingBehavior.prototype, \"name\", {\n    /**\r\n     * Gets the name of the behavior.\r\n     */\n    get: function () {\n      return \"Framing\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"mode\", {\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\n    get: function () {\n      return this._mode;\n    },\n\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\n    set: function (mode) {\n      this._mode = mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"radiusScale\", {\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\n    get: function () {\n      return this._radiusScale;\n    },\n\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\n    set: function (radius) {\n      this._radiusScale = radius;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"positionScale\", {\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\n    get: function () {\n      return this._positionScale;\n    },\n\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\n    set: function (scale) {\n      this._positionScale = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"defaultElevation\", {\n    /**\r\n    * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\n    get: function () {\n      return this._defaultElevation;\n    },\n\n    /**\r\n    * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\n    set: function (elevation) {\n      this._defaultElevation = elevation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnTime\", {\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\n    get: function () {\n      return this._elevationReturnTime;\n    },\n\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\n    set: function (speed) {\n      this._elevationReturnTime = speed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"elevationReturnWaitTime\", {\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\n    get: function () {\n      return this._elevationReturnWaitTime;\n    },\n\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\n    set: function (time) {\n      this._elevationReturnWaitTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"zoomStopsAnimation\", {\n    /**\r\n    * Gets the flag that indicates if user zooming should stop animation.\r\n    */\n    get: function () {\n      return this._zoomStopsAnimation;\n    },\n\n    /**\r\n    * Sets the flag that indicates if user zooming should stop animation.\r\n    */\n    set: function (flag) {\n      this._zoomStopsAnimation = flag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FramingBehavior.prototype, \"framingTime\", {\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n    */\n    get: function () {\n      return this._framingTime;\n    },\n\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n    */\n    set: function (time) {\n      this._framingTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the behavior.\r\n   */\n\n  FramingBehavior.prototype.init = function () {// Do notihng\n  };\n  /**\r\n   * Attaches the behavior to its arc rotate camera.\r\n   * @param camera Defines the camera to attach the behavior to\r\n   */\n\n\n  FramingBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n\n    var scene = this._attachedCamera.getScene();\n\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        _this._isPointerDown = true;\n        return;\n      }\n\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        _this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(function (mesh) {\n      if (mesh) {\n        _this.zoomOnMesh(mesh);\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      _this._applyUserInteraction(); // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n\n\n      _this._maintainCameraAboveGround();\n    });\n  };\n  /**\r\n   * Detaches the behavior from its current arc rotate camera.\r\n   */\n\n\n  FramingBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    var scene = this._attachedCamera.getScene();\n\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n\n    this._attachedCamera = null;\n  };\n  /**\r\n   * Targets the given mesh and updates zoom level accordingly.\r\n   * @param mesh  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMesh = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the given mesh with its children and updates zoom level accordingly.\r\n   * @param mesh  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshHierarchy = function (mesh, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    mesh.computeWorldMatrix(true);\n    var boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the given meshes with their children and updates zoom level accordingly.\r\n   * @param meshes  The mesh to target.\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnMeshesHierarchy = function (meshes, focusOnOriginXZ, onAnimationEnd) {\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  };\n  /**\r\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n   * @param minimumWorld Determines the smaller position of the bounding box extend\r\n   * @param maximumWorld Determines the bigger position of the bounding box extend\r\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n   */\n\n\n  FramingBehavior.prototype.zoomOnBoundingInfo = function (minimumWorld, maximumWorld, focusOnOriginXZ, onAnimationEnd) {\n    var _this = this;\n\n    if (focusOnOriginXZ === void 0) {\n      focusOnOriginXZ = false;\n    }\n\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    var zoomTarget;\n\n    if (!this._attachedCamera) {\n      return;\n    } // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n\n\n    var bottom = minimumWorld.y;\n    var top = maximumWorld.y;\n    var zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    var radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      var centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n\n    this._betaIsAnimating = true;\n    var animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    } // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n\n\n    var radius = 0;\n\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      var position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    } // Set sensibilities\n\n\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      var extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    } // transition to new radius\n\n\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {\n      _this.stopAllAnimations();\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      if (_this._attachedCamera && _this._attachedCamera.useInputToRestoreState) {\n        _this._attachedCamera.storeState();\n      }\n    });\n\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  };\n  /**\r\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n   * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary\r\n   *\t\t\t  frustum width.\r\n   * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n   *\t\t to fully enclose the mesh in the viewing frustum.\r\n   */\n\n\n  FramingBehavior.prototype._calculateLowerRadiusFromModelBoundingSphere = function (minimumWorld, maximumWorld) {\n    var size = maximumWorld.subtract(minimumWorld);\n    var boxVectorGlobalDiagonal = size.length();\n\n    var frustumSlope = this._getFrustumSlope(); // Formula for setting distance\n    // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\n\n\n    var radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5; // Horizon distance\n\n    var radius = radiusWithoutFraming * this._radiusScale;\n    var distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\n    var distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\n    var distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return 0;\n    }\n\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    } // Don't exceed the upper radius limit\n\n\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n\n    return distance;\n  };\n  /**\r\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n   * is automatically returned to its default position (expected to be above ground plane).\r\n   */\n\n\n  FramingBehavior.prototype._maintainCameraAboveGround = function () {\n    var _this = this;\n\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n\n    var timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    var defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    var limitBeta = Math.PI * 0.5; // Bring the camera back up if below the ground plane\n\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true; //Transition to new position\n\n      this.stopAllAnimations();\n\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n\n      var animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {\n        _this._clearAnimationLocks();\n\n        _this.stopAllAnimations();\n      });\n\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  };\n  /**\r\n   * Returns the frustum slope based on the canvas ratio and camera FOV\r\n   * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n   */\n\n\n  FramingBehavior.prototype._getFrustumSlope = function () {\n    // Calculate the viewport ratio\n    // Aspect Ratio is Height/Width.\n    var camera = this._attachedCamera;\n\n    if (!camera) {\n      return Vector2.Zero();\n    }\n\n    var engine = camera.getScene().getEngine();\n    var aspectRatio = engine.getAspectRatio(camera); // Camera FOV is the vertical field of view (top-bottom) in radians.\n    // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\n\n    var frustumSlopeY = Math.tan(camera.fov / 2); // Slope of the frustum left/right planes in view space, relative to the forward vector.\n    // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\n    // along the forward vector.\n\n    var frustumSlopeX = frustumSlopeY * aspectRatio;\n    return new Vector2(frustumSlopeX, frustumSlopeY);\n  };\n  /**\r\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n   */\n\n\n  FramingBehavior.prototype._clearAnimationLocks = function () {\n    this._betaIsAnimating = false;\n  };\n  /**\r\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n   */\n\n\n  FramingBehavior.prototype._applyUserInteraction = function () {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n\n      this._clearAnimationLocks();\n    }\n  };\n  /**\r\n   * Stops and removes all animations that have been applied to the camera\r\n   */\n\n\n  FramingBehavior.prototype.stopAllAnimations = function () {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n\n        this._animatables[0].stop();\n      }\n\n      this._animatables.shift();\n    }\n  };\n\n  Object.defineProperty(FramingBehavior.prototype, \"isUserIsMoving\", {\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\n    get: function () {\n      if (!this._attachedCamera) {\n        return false;\n      }\n\n      return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * The easing function used by animations\r\n   */\n\n  FramingBehavior.EasingFunction = new ExponentialEase();\n  /**\r\n   * The easing mode used by animations\r\n   */\n\n  FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT; // Statics\n\n  /**\r\n   * The camera can move all the way towards the mesh.\r\n   */\n\n  FramingBehavior.IgnoreBoundsSizeMode = 0;\n  /**\r\n   * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n   */\n\n  FramingBehavior.FitFrustumSidesMode = 1;\n  return FramingBehavior;\n}();\n\nexport { FramingBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Cameras/framingBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Nullable } from \"../../types\";\r\nimport { PointerInfoPre, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n    * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n    * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n    * behaviour is triggered, in radians.\r\n    */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n    * Sets the flag that indicates if user zooming should stop animation.\r\n    */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n    * Gets the flag that indicates if user zooming should stop animation.\r\n    */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n    */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n    */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do notihng\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        let scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh);\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        let scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        let boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        let boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        let min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            let boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        let bottom = minimumWorld.y;\r\n        let top = maximumWorld.y;\r\n        let zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        let radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            let centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            let position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(),\r\n            60, this._radiusTransition, this._framingTime, () => {\r\n                this.stopAllAnimations();\r\n                if (onAnimationEnd) {\r\n                    onAnimationEnd();\r\n                }\r\n\r\n                if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                    this._attachedCamera.storeState();\r\n                }\r\n            });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param mesh The mesh on which to base the calculation. mesh boundingInfo used to estimate necessary\r\n     *\t\t\t  frustum width.\r\n     * @return The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        let size = maximumWorld.subtract(minimumWorld);\r\n        let boxVectorGlobalDiagonal = size.length();\r\n        let frustumSlope: Vector2 = this._getFrustumSlope();\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        let radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        let radius = radiusWithoutFraming * this._radiusScale;\r\n        let distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\r\n        let distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\r\n        let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n        let camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        let timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        let defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        let limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            let animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60,\r\n                this._betaTransition, this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                });\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the frustum slope based on the canvas ratio and camera FOV\r\n     * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n     */\r\n    private _getFrustumSlope(): Vector2 {\r\n        // Calculate the viewport ratio\r\n        // Aspect Ratio is Height/Width.\r\n        let camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        let engine = camera.getScene().getEngine();\r\n        var aspectRatio = engine.getAspectRatio(camera);\r\n\r\n        // Camera FOV is the vertical field of view (top-bottom) in radians.\r\n        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\r\n        var frustumSlopeY = Math.tan(camera.fov / 2);\r\n\r\n        // Slope of the frustum left/right planes in view space, relative to the forward vector.\r\n        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\r\n        // along the forward vector.\r\n        var frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        return new Vector2(frustumSlopeX, frustumSlopeY);\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}