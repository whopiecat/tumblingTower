{"ast":null,"code":"import { Scalar } from \"../Maths/math.scalar\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { Logger } from \"../Misc/logger\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\nimport { BaseTexture } from '../Materials/Textures/baseTexture';\nimport \"../Engines/Extensions/engine.cubeTexture\";\nimport { ThinEngine } from '../Engines/thinEngine'; // Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\nvar DDS_MAGIC = 0x20534444;\nvar //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000; //DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\n\nvar DDSCAPS2_CUBEMAP = 0x200; // DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\n\nvar //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4,\n    DDPF_RGB = 0x40,\n    //DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\n\nfunction FourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\n\nfunction Int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}\n\nvar FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nvar FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nvar FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nvar FOURCC_DX10 = FourCCToInt32(\"DX10\");\nvar FOURCC_D3DFMT_R16G16B16A16F = 113;\nvar FOURCC_D3DFMT_R32G32B32A32F = 116;\nvar DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nvar DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nvar DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nvar headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\n\nvar off_magic = 0;\nvar off_size = 1;\nvar off_flags = 2;\nvar off_height = 3;\nvar off_width = 4;\nvar off_mipmapCount = 7;\nvar off_pfFlags = 20;\nvar off_pfFourCC = 21;\nvar off_RGBbpp = 22;\nvar off_RMask = 23;\nvar off_GMask = 24;\nvar off_BMask = 25;\nvar off_AMask = 26; // var off_caps1 = 27;\n\nvar off_caps2 = 28; // var off_caps3 = 29;\n// var off_caps4 = 30;\n\nvar off_dxgiFormat = 32;\n/**\r\n * Class used to provide DDS decompression tools\r\n */\n\nvar DDSTools =\n/** @class */\nfunction () {\n  function DDSTools() {}\n  /**\r\n   * Gets DDS information from an array buffer\r\n   * @param data defines the array buffer view to read data from\r\n   * @returns the DDS information\r\n   */\n\n\n  DDSTools.GetDDSInfo = function (data) {\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n    var mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var fourCC = header[off_pfFourCC];\n    var dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n    var textureType = 0;\n\n    switch (fourCC) {\n      case FOURCC_D3DFMT_R16G16B16A16F:\n        textureType = 2;\n        break;\n\n      case FOURCC_D3DFMT_R32G32B32A32F:\n        textureType = 1;\n        break;\n\n      case FOURCC_DX10:\n        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n          textureType = 2;\n          break;\n        }\n\n        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n          textureType = 1;\n          break;\n        }\n\n    }\n\n    return {\n      width: header[off_width],\n      height: header[off_height],\n      mipmapCount: mipmapCount,\n      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n      dxgiFormat: dxgiFormat,\n      textureType: textureType\n    };\n  };\n\n  DDSTools._ToHalfFloat = function (value) {\n    if (!DDSTools._FloatView) {\n      DDSTools._FloatView = new Float32Array(1);\n      DDSTools._Int32View = new Int32Array(DDSTools._FloatView.buffer);\n    }\n\n    DDSTools._FloatView[0] = value;\n    var x = DDSTools._Int32View[0];\n    var bits = x >> 16 & 0x8000;\n    /* Get the sign */\n\n    var m = x >> 12 & 0x07ff;\n    /* Keep one extra bit for rounding */\n\n    var e = x >> 23 & 0xff;\n    /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n    * half, return signed zero. */\n\n    if (e < 103) {\n      return bits;\n    }\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n      * not Inf, so make sure we set one mantissa bit too. */\n\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n    /* If exponent underflows but not too much, return a denormal */\n\n\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n      * to 1, which is OK. */\n\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n\n    bits |= e - 112 << 10 | m >> 1;\n    bits += m & 1;\n    return bits;\n  };\n\n  DDSTools._FromHalfFloat = function (value) {\n    var s = (value & 0x8000) >> 15;\n    var e = (value & 0x7C00) >> 10;\n    var f = value & 0x03FF;\n\n    if (e === 0) {\n      return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    } else if (e == 0x1F) {\n      return f ? NaN : (s ? -1 : 1) * Infinity;\n    }\n\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n  };\n\n  DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Float32Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = DDSTools._FromHalfFloat(srcData[srcPos]);\n        destArray[index + 1] = DDSTools._FromHalfFloat(srcData[srcPos + 1]);\n        destArray[index + 2] = DDSTools._FromHalfFloat(srcData[srcPos + 2]);\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = DDSTools._FromHalfFloat(srcData[srcPos + 3]);\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Uint16Array(dataLength);\n      var srcData = new Uint16Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = DDSTools._ToHalfFloat(lod);\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      var destArray = new Float32Array(dataLength);\n      var srcData = new Float32Array(arrayBuffer, dataOffset);\n      var index = 0;\n\n      for (var y = 0; y < height; y++) {\n        for (var x = 0; x < width; x++) {\n          var srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = lod;\n          index += 4;\n        }\n      }\n\n      return destArray;\n    }\n\n    return new Float32Array(arrayBuffer, dataOffset, dataLength);\n  };\n\n  DDSTools._GetFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Float32Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    var destArray = new Uint8Array(dataLength);\n    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos])) * 255;\n        destArray[index + 1] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 1])) * 255;\n        destArray[index + 2] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 2])) * 255;\n\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 3])) * 255;\n        }\n\n        index += 4;\n      }\n    }\n\n    return destArray;\n  };\n\n  DDSTools._GetRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 4;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        byteArray[index + 3] = srcData[srcPos + aOffset];\n        index += 4;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._ExtractLongWordOrder = function (value) {\n    if (value === 0 || value === 255 || value === -16777216) {\n      return 0;\n    }\n\n    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n  };\n\n  DDSTools._GetRGBArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = (x + y * width) * 3;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        index += 3;\n      }\n    }\n\n    return byteArray;\n  };\n\n  DDSTools._GetLuminanceArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n    var byteArray = new Uint8Array(dataLength);\n    var srcData = new Uint8Array(arrayBuffer, dataOffset);\n    var index = 0;\n\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var srcPos = x + y * width;\n        byteArray[index] = srcData[srcPos];\n        index++;\n      }\n    }\n\n    return byteArray;\n  };\n  /**\r\n   * Uploads DDS Levels to a Babylon Texture\r\n   * @hidden\r\n   */\n\n\n  DDSTools.UploadDDSLevels = function (engine, texture, data, info, loadMipmaps, faces, lodIndex, currentFace) {\n    if (lodIndex === void 0) {\n      lodIndex = -1;\n    }\n\n    var sphericalPolynomialFaces = null;\n\n    if (info.sphericalPolynomial) {\n      sphericalPolynomialFaces = new Array();\n    }\n\n    var ext = engine.getCaps().s3tc;\n    var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    var fourCC,\n        width,\n        height,\n        dataLength = 0,\n        dataOffset;\n    var byteArray, mipmapCount, mip;\n    var internalCompressedFormat = 0;\n    var blockBytes = 1;\n\n    if (header[off_magic] !== DDS_MAGIC) {\n      Logger.Error(\"Invalid magic number in DDS header\");\n      return;\n    }\n\n    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n      Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n      return;\n    }\n\n    if (info.isCompressed && !ext) {\n      Logger.Error(\"Compressed textures are not supported on this platform.\");\n      return;\n    }\n\n    var bpp = header[off_RGBbpp];\n    dataOffset = header[off_size] + 4;\n    var computeFormats = false;\n\n    if (info.isFourCC) {\n      fourCC = header[off_pfFourCC];\n\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          break;\n\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          break;\n\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          internalCompressedFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n          break;\n\n        case FOURCC_D3DFMT_R16G16B16A16F:\n          computeFormats = true;\n          break;\n\n        case FOURCC_D3DFMT_R32G32B32A32F:\n          computeFormats = true;\n          break;\n\n        case FOURCC_DX10:\n          // There is an additionnal header so dataOffset need to be changed\n          dataOffset += 5 * 4; // 5 uints\n\n          var supported = false;\n\n          switch (info.dxgiFormat) {\n            case DXGI_FORMAT_R16G16B16A16_FLOAT:\n            case DXGI_FORMAT_R32G32B32A32_FLOAT:\n              computeFormats = true;\n              supported = true;\n              break;\n\n            case DXGI_FORMAT_B8G8R8X8_UNORM:\n              info.isRGB = true;\n              info.isFourCC = false;\n              bpp = 32;\n              supported = true;\n              break;\n          }\n\n          if (supported) {\n            break;\n          }\n\n        default:\n          console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n          return;\n      }\n    }\n\n    var rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n\n    var gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n\n    var bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n\n    var aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n\n    if (computeFormats) {\n      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n    }\n\n    mipmapCount = 1;\n\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n\n    var startFace = currentFace || 0;\n\n    for (var face = startFace; face < faces; face++) {\n      width = header[off_width];\n      height = header[off_height];\n\n      for (mip = 0; mip < mipmapCount; ++mip) {\n        if (lodIndex === -1 || lodIndex === mip) {\n          // In case of fixed LOD, if the lod has just been uploaded, early exit.\n          var i = lodIndex === -1 ? mip : 0;\n\n          if (!info.isCompressed && info.isFourCC) {\n            texture.format = 5;\n            dataLength = width * height * 4;\n            var floatArray = null;\n\n            if (engine._badOS || engine._badDesktopOS || !engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat) {\n              // Required because iOS has many issues with float and half float generation\n              if (bpp === 128) {\n                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              } else if (bpp === 64) {\n                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              }\n\n              texture.type = 0;\n            } else {\n              if (bpp === 128) {\n                texture.type = 1;\n                floatArray = DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(floatArray);\n                }\n              } else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {\n                texture.type = 1;\n                floatArray = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(floatArray);\n                }\n              } else {\n                // 64\n                texture.type = 2;\n                floatArray = DDSTools._GetHalfFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, data.buffer, i));\n                }\n              }\n            }\n\n            if (floatArray) {\n              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n            }\n          } else if (info.isRGB) {\n            texture.type = 0;\n\n            if (bpp === 24) {\n              texture.format = 4;\n              dataLength = width * height * 3;\n              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            } else {\n              // 32\n              texture.format = 5;\n              dataLength = width * height * 4;\n              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            }\n          } else if (info.isLuminance) {\n            var unpackAlignment = engine._getUnpackAlignement();\n\n            var unpaddedRowSize = width;\n            var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n            texture.format = 1;\n            texture.type = 0;\n\n            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n            texture.type = 0;\n\n            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n          }\n        }\n\n        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n        width *= 0.5;\n        height *= 0.5;\n        width = Math.max(1.0, width);\n        height = Math.max(1.0, height);\n      }\n\n      if (currentFace !== undefined) {\n        // Loading a single face\n        break;\n      }\n    }\n\n    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n        size: header[off_width],\n        right: sphericalPolynomialFaces[0],\n        left: sphericalPolynomialFaces[1],\n        up: sphericalPolynomialFaces[2],\n        down: sphericalPolynomialFaces[3],\n        front: sphericalPolynomialFaces[4],\n        back: sphericalPolynomialFaces[5],\n        format: 5,\n        type: 1,\n        gammaSpace: false\n      });\n    } else {\n      info.sphericalPolynomial = undefined;\n    }\n  };\n  /**\r\n   * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n   */\n\n\n  DDSTools.StoreLODInAlphaChannel = false;\n  return DDSTools;\n}();\n\nexport { DDSTools };\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\n\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, createPolynomials) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = true;\n  }\n\n  var callback = function (loadData) {\n    if (!loadData) {\n      if (onLoad) {\n        onLoad(null);\n      }\n\n      return;\n    }\n\n    var texture = loadData.texture;\n\n    if (!createPolynomials) {\n      texture._sphericalPolynomial = new SphericalPolynomial();\n    } else if (loadData.info.sphericalPolynomial) {\n      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n    }\n\n    texture._source = InternalTextureSource.CubePrefiltered;\n\n    if (_this.getCaps().textureLOD) {\n      // Do not add extra process if texture lod is supported.\n      if (onLoad) {\n        onLoad(texture);\n      }\n\n      return;\n    }\n\n    var mipSlices = 3;\n    var gl = _this._gl;\n    var width = loadData.width;\n\n    if (!width) {\n      return;\n    }\n\n    var textures = [];\n\n    for (var i = 0; i < mipSlices; i++) {\n      //compute LOD from even spacing in smoothness (matching shader calculation)\n      var smoothness = i / (mipSlices - 1);\n      var roughness = 1 - smoothness;\n      var minLODIndex = lodOffset; // roughness = 0\n\n      var maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n\n      var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n      var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n      var glTextureFromLod = new InternalTexture(_this, InternalTextureSource.Temp);\n      glTextureFromLod.type = texture.type;\n      glTextureFromLod.format = texture.format;\n      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n      glTextureFromLod.height = glTextureFromLod.width;\n      glTextureFromLod.isCube = true;\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n\n      glTextureFromLod.samplingMode = 2;\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      if (loadData.isDDS) {\n        var info = loadData.info;\n        var data = loadData.data;\n\n        _this._unpackFlipY(info.isCompressed);\n\n        DDSTools.UploadDDSLevels(_this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n      } else {\n        Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null); // Wrap in a base texture for easy binding.\n\n\n      var lodTexture = new BaseTexture(scene);\n      lodTexture.isCube = true;\n      lodTexture._texture = glTextureFromLod;\n      glTextureFromLod.isReady = true;\n      textures.push(lodTexture);\n    }\n\n    texture._lodTextureHigh = textures[2];\n    texture._lodTextureMid = textures[1];\n    texture._lodTextureLow = textures[0];\n\n    if (onLoad) {\n      onLoad(texture);\n    }\n  };\n\n  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};","map":{"version":3,"sources":["../../../sourceES6/core/Misc/dds.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\n\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport { Scene } from '../scene';\r\nimport { BaseTexture } from '../Materials/Textures/baseTexture';\r\n\r\nimport \"../Engines/Extensions/engine.cubeTexture\";\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\n\r\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\r\n// All values and structures referenced from:\r\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\nvar DDS_MAGIC = 0x20534444;\r\n\r\nvar\r\n    //DDSD_CAPS = 0x1,\r\n    //DDSD_HEIGHT = 0x2,\r\n    //DDSD_WIDTH = 0x4,\r\n    //DDSD_PITCH = 0x8,\r\n    //DDSD_PIXELFORMAT = 0x1000,\r\n    DDSD_MIPMAPCOUNT = 0x20000;\r\n//DDSD_LINEARSIZE = 0x80000,\r\n//DDSD_DEPTH = 0x800000;\r\n\r\n// var DDSCAPS_COMPLEX = 0x8,\r\n//     DDSCAPS_MIPMAP = 0x400000,\r\n//     DDSCAPS_TEXTURE = 0x1000;\r\n\r\nvar DDSCAPS2_CUBEMAP = 0x200;\r\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n// DDSCAPS2_VOLUME = 0x200000;\r\n\r\nvar\r\n    //DDPF_ALPHAPIXELS = 0x1,\r\n    //DDPF_ALPHA = 0x2,\r\n    DDPF_FOURCC = 0x4,\r\n    DDPF_RGB = 0x40,\r\n    //DDPF_YUV = 0x200,\r\n    DDPF_LUMINANCE = 0x20000;\r\n\r\nfunction FourCCToInt32(value: string) {\r\n    return value.charCodeAt(0) +\r\n        (value.charCodeAt(1) << 8) +\r\n        (value.charCodeAt(2) << 16) +\r\n        (value.charCodeAt(3) << 24);\r\n}\r\n\r\nfunction Int32ToFourCC(value: number) {\r\n    return String.fromCharCode(\r\n        value & 0xff,\r\n        (value >> 8) & 0xff,\r\n        (value >> 16) & 0xff,\r\n        (value >> 24) & 0xff\r\n    );\r\n}\r\n\r\nvar FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\r\nvar FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\r\nvar FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\r\nvar FOURCC_DX10 = FourCCToInt32(\"DX10\");\r\nvar FOURCC_D3DFMT_R16G16B16A16F = 113;\r\nvar FOURCC_D3DFMT_R32G32B32A32F = 116;\r\n\r\nvar DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\r\nvar DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\r\nvar DXGI_FORMAT_B8G8R8X8_UNORM = 88;\r\n\r\nvar headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n// Offsets into the header array\r\nvar off_magic = 0;\r\n\r\nvar off_size = 1;\r\nvar off_flags = 2;\r\nvar off_height = 3;\r\nvar off_width = 4;\r\n\r\nvar off_mipmapCount = 7;\r\n\r\nvar off_pfFlags = 20;\r\nvar off_pfFourCC = 21;\r\nvar off_RGBbpp = 22;\r\nvar off_RMask = 23;\r\nvar off_GMask = 24;\r\nvar off_BMask = 25;\r\nvar off_AMask = 26;\r\n// var off_caps1 = 27;\r\nvar off_caps2 = 28;\r\n// var off_caps3 = 29;\r\n// var off_caps4 = 30;\r\nvar off_dxgiFormat = 32;\r\n\r\n/**\r\n * Direct draw surface info\r\n * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dx-graphics-dds-pguide\r\n */\r\nexport interface DDSInfo {\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    width: number;\r\n    /**\r\n     * Width of the texture\r\n     */\r\n    height: number;\r\n    /**\r\n     * Number of Mipmaps for the texture\r\n     * @see https://en.wikipedia.org/wiki/Mipmap\r\n     */\r\n    mipmapCount: number;\r\n    /**\r\n     * If the textures format is a known fourCC format\r\n     * @see https://www.fourcc.org/\r\n     */\r\n    isFourCC: boolean;\r\n    /**\r\n     * If the texture is an RGB format eg. DXGI_FORMAT_B8G8R8X8_UNORM format\r\n     */\r\n    isRGB: boolean;\r\n    /**\r\n     * If the texture is a lumincance format\r\n     */\r\n    isLuminance: boolean;\r\n    /**\r\n     * If this is a cube texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/direct3ddds/dds-file-layout-for-cubic-environment-maps\r\n     */\r\n    isCube: boolean;\r\n    /**\r\n     * If the texture is a compressed format eg. FOURCC_DXT1\r\n     */\r\n    isCompressed: boolean;\r\n    /**\r\n     * The dxgiFormat of the texture\r\n     * @see https://docs.microsoft.com/en-us/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format\r\n     */\r\n    dxgiFormat: number;\r\n    /**\r\n     * Texture type eg. Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT\r\n     */\r\n    textureType: number;\r\n    /**\r\n     * Sphericle polynomial created for the dds texture\r\n     */\r\n    sphericalPolynomial?: SphericalPolynomial;\r\n}\r\n\r\n/**\r\n * Class used to provide DDS decompression tools\r\n */\r\nexport class DDSTools {\r\n    /**\r\n     * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\r\n     */\r\n    public static StoreLODInAlphaChannel = false;\r\n\r\n    /**\r\n     * Gets DDS information from an array buffer\r\n     * @param data defines the array buffer view to read data from\r\n     * @returns the DDS information\r\n     */\r\n    public static GetDDSInfo(data: ArrayBufferView): DDSInfo {\r\n        var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        var extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\r\n\r\n        var mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        var fourCC = header[off_pfFourCC];\r\n        var dxgiFormat = (fourCC === FOURCC_DX10) ? extendedHeader[off_dxgiFormat] : 0;\r\n        var textureType = 0;\r\n\r\n        switch (fourCC) {\r\n            case FOURCC_D3DFMT_R16G16B16A16F:\r\n                textureType = 2;\r\n                break;\r\n            case FOURCC_D3DFMT_R32G32B32A32F:\r\n                textureType = 1;\r\n                break;\r\n            case FOURCC_DX10:\r\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\r\n                    textureType = 2;\r\n                    break;\r\n                }\r\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\r\n                    textureType = 1;\r\n                    break;\r\n                }\r\n        }\r\n\r\n        return {\r\n            width: header[off_width],\r\n            height: header[off_height],\r\n            mipmapCount: mipmapCount,\r\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\r\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\r\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\r\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\r\n            isCompressed: (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5),\r\n            dxgiFormat: dxgiFormat,\r\n            textureType: textureType\r\n        };\r\n    }\r\n\r\n    // ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\n    private static _FloatView: Float32Array;\r\n    private static _Int32View: Int32Array;\r\n    private static _ToHalfFloat(value: number): number {\r\n        if (!DDSTools._FloatView) {\r\n            DDSTools._FloatView = new Float32Array(1);\r\n            DDSTools._Int32View = new Int32Array(DDSTools._FloatView.buffer);\r\n        }\r\n\r\n        DDSTools._FloatView[0] = value;\r\n        var x = DDSTools._Int32View[0];\r\n\r\n        var bits = (x >> 16) & 0x8000; /* Get the sign */\r\n        var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n        var e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n        /* If zero, or denormal, or exponent underflows too much for a denormal\r\n        * half, return signed zero. */\r\n        if (e < 103) {\r\n            return bits;\r\n        }\r\n\r\n        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n        if (e > 142) {\r\n            bits |= 0x7c00;\r\n            /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n            * not Inf, so make sure we set one mantissa bit too. */\r\n            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\r\n            return bits;\r\n        }\r\n\r\n        /* If exponent underflows but not too much, return a denormal */\r\n        if (e < 113) {\r\n            m |= 0x0800;\r\n            /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n            * to 1, which is OK. */\r\n            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n            return bits;\r\n        }\r\n\r\n        bits |= ((e - 112) << 10) | (m >> 1);\r\n        bits += m & 1;\r\n        return bits;\r\n    }\r\n\r\n    private static _FromHalfFloat(value: number): number {\r\n        var s = (value & 0x8000) >> 15;\r\n        var e = (value & 0x7C00) >> 10;\r\n        var f = value & 0x03FF;\r\n\r\n        if (e === 0) {\r\n            return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n        } else if (e == 0x1F) {\r\n            return f ? NaN : ((s ? -1 : 1) * Infinity);\r\n        }\r\n\r\n        return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\r\n    }\r\n\r\n    private static _GetHalfFloatAsFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        var destArray = new Float32Array(dataLength);\r\n        var srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width) * 4;\r\n                destArray[index] = DDSTools._FromHalfFloat(srcData[srcPos]);\r\n                destArray[index + 1] = DDSTools._FromHalfFloat(srcData[srcPos + 1]);\r\n                destArray[index + 2] = DDSTools._FromHalfFloat(srcData[srcPos + 2]);\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = DDSTools._FromHalfFloat(srcData[srcPos + 3]);\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Uint16Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            var destArray = new Uint16Array(dataLength);\r\n            var srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n            var index = 0;\r\n            for (var y = 0; y < height; y++) {\r\n                for (var x = 0; x < width; x++) {\r\n                    var srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = DDSTools._ToHalfFloat(lod);\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n\r\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        if (DDSTools.StoreLODInAlphaChannel) {\r\n            var destArray = new Float32Array(dataLength);\r\n            var srcData = new Float32Array(arrayBuffer, dataOffset);\r\n            var index = 0;\r\n            for (var y = 0; y < height; y++) {\r\n                for (var x = 0; x < width; x++) {\r\n                    var srcPos = (x + y * width) * 4;\r\n                    destArray[index] = srcData[srcPos];\r\n                    destArray[index + 1] = srcData[srcPos + 1];\r\n                    destArray[index + 2] = srcData[srcPos + 2];\r\n                    destArray[index + 3] = lod;\r\n                    index += 4;\r\n                }\r\n            }\r\n\r\n            return destArray;\r\n        }\r\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\r\n    }\r\n\r\n    private static _GetFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        var destArray = new Uint8Array(dataLength);\r\n        var srcData = new Float32Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetHalfFloatAsUIntRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, lod: number): Float32Array {\r\n        var destArray = new Uint8Array(dataLength);\r\n        var srcData = new Uint16Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width) * 4;\r\n                destArray[index] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos])) * 255;\r\n                destArray[index + 1] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 1])) * 255;\r\n                destArray[index + 2] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 2])) * 255;\r\n                if (DDSTools.StoreLODInAlphaChannel) {\r\n                    destArray[index + 3] = lod;\r\n                } else {\r\n                    destArray[index + 3] = Scalar.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 3])) * 255;\r\n                }\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return destArray;\r\n    }\r\n\r\n    private static _GetRGBAArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, rOffset: number, gOffset: number, bOffset: number, aOffset: number): Uint8Array {\r\n        var byteArray = new Uint8Array(dataLength);\r\n        var srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width) * 4;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                byteArray[index + 3] = srcData[srcPos + aOffset];\r\n                index += 4;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _ExtractLongWordOrder(value: number): number {\r\n        if (value === 0 || value === 255 || value === -16777216) {\r\n            return 0;\r\n        }\r\n\r\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\r\n    }\r\n\r\n    private static _GetRGBArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer, rOffset: number, gOffset: number, bOffset: number): Uint8Array {\r\n        var byteArray = new Uint8Array(dataLength);\r\n        var srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width) * 3;\r\n\r\n                byteArray[index] = srcData[srcPos + rOffset];\r\n                byteArray[index + 1] = srcData[srcPos + gOffset];\r\n                byteArray[index + 2] = srcData[srcPos + bOffset];\r\n                index += 3;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    private static _GetLuminanceArrayBuffer(width: number, height: number, dataOffset: number, dataLength: number, arrayBuffer: ArrayBuffer): Uint8Array {\r\n        var byteArray = new Uint8Array(dataLength);\r\n        var srcData = new Uint8Array(arrayBuffer, dataOffset);\r\n        var index = 0;\r\n        for (var y = 0; y < height; y++) {\r\n            for (var x = 0; x < width; x++) {\r\n                var srcPos = (x + y * width);\r\n                byteArray[index] = srcData[srcPos];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return byteArray;\r\n    }\r\n\r\n    /**\r\n     * Uploads DDS Levels to a Babylon Texture\r\n     * @hidden\r\n     */\r\n    public static UploadDDSLevels(engine: ThinEngine, texture: InternalTexture, data: ArrayBufferView, info: DDSInfo, loadMipmaps: boolean, faces: number, lodIndex = -1, currentFace?: number) {\r\n        var sphericalPolynomialFaces: Nullable<Array<ArrayBufferView>> = null;\r\n        if (info.sphericalPolynomial) {\r\n            sphericalPolynomialFaces = new Array<ArrayBufferView>();\r\n        }\r\n        var ext = engine.getCaps().s3tc;\r\n\r\n        var header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\r\n        var fourCC: number, width: number, height: number, dataLength: number = 0, dataOffset: number;\r\n        var byteArray: Uint8Array, mipmapCount: number, mip: number;\r\n        let internalCompressedFormat = 0;\r\n        let blockBytes = 1;\r\n\r\n        if (header[off_magic] !== DDS_MAGIC) {\r\n            Logger.Error(\"Invalid magic number in DDS header\");\r\n            return;\r\n        }\r\n\r\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\r\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\r\n            return;\r\n        }\r\n\r\n        if (info.isCompressed && !ext) {\r\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\r\n            return;\r\n        }\r\n\r\n        var bpp = header[off_RGBbpp];\r\n        dataOffset = header[off_size] + 4;\r\n\r\n        let computeFormats = false;\r\n\r\n        if (info.isFourCC) {\r\n            fourCC = header[off_pfFourCC];\r\n            switch (fourCC) {\r\n                case FOURCC_DXT1:\r\n                    blockBytes = 8;\r\n                    internalCompressedFormat = (<WEBGL_compressed_texture_s3tc>ext).COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n                    break;\r\n                case FOURCC_DXT3:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = (<WEBGL_compressed_texture_s3tc>ext).COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n                    break;\r\n                case FOURCC_DXT5:\r\n                    blockBytes = 16;\r\n                    internalCompressedFormat = (<WEBGL_compressed_texture_s3tc>ext).COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n                    break;\r\n                case FOURCC_D3DFMT_R16G16B16A16F:\r\n                    computeFormats = true;\r\n                    break;\r\n                case FOURCC_D3DFMT_R32G32B32A32F:\r\n                    computeFormats = true;\r\n                    break;\r\n                case FOURCC_DX10:\r\n                    // There is an additionnal header so dataOffset need to be changed\r\n                    dataOffset += 5 * 4; // 5 uints\r\n\r\n                    let supported = false;\r\n                    switch (info.dxgiFormat) {\r\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\r\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\r\n                            computeFormats = true;\r\n                            supported = true;\r\n                            break;\r\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\r\n                            info.isRGB = true;\r\n                            info.isFourCC = false;\r\n                            bpp = 32;\r\n                            supported = true;\r\n                            break;\r\n                    }\r\n\r\n                    if (supported) {\r\n                        break;\r\n                    }\r\n                default:\r\n                    console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\r\n                    return;\r\n            }\r\n        }\r\n\r\n        let rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\r\n        let gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\r\n        let bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\r\n        let aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\r\n\r\n        if (computeFormats) {\r\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\r\n        }\r\n\r\n        mipmapCount = 1;\r\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\r\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\r\n        }\r\n\r\n        const startFace = currentFace || 0;\r\n        for (var face = startFace; face < faces; face++) {\r\n            width = header[off_width];\r\n            height = header[off_height];\r\n\r\n            for (mip = 0; mip < mipmapCount; ++mip) {\r\n                if (lodIndex === -1 || lodIndex === mip) {\r\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\r\n                    const i = (lodIndex === -1) ? mip : 0;\r\n\r\n                    if (!info.isCompressed && info.isFourCC) {\r\n                        texture.format = 5;\r\n                        dataLength = width * height * 4;\r\n                        var floatArray: Nullable<ArrayBufferView> = null;\r\n\r\n                        if (engine._badOS || engine._badDesktopOS || (!engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat)) { // Required because iOS has many issues with float and half float generation\r\n                            if (bpp === 128) {\r\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            }\r\n                            else if (bpp === 64) {\r\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            }\r\n\r\n                            texture.type = 0;\r\n                        }\r\n                        else {\r\n                            if (bpp === 128) {\r\n                                texture.type = 1;\r\n                                floatArray = DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(floatArray);\r\n                                }\r\n                            } else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {\r\n                                texture.type = 1;\r\n                                floatArray = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(floatArray);\r\n                                }\r\n                            } else { // 64\r\n                                texture.type = 2;\r\n                                floatArray = DDSTools._GetHalfFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\r\n                                if (sphericalPolynomialFaces && i == 0) {\r\n                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, data.buffer, i));\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (floatArray) {\r\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\r\n                        }\r\n                    } else if (info.isRGB) {\r\n                        texture.type = 0;\r\n                        if (bpp === 24) {\r\n                            texture.format = 4;\r\n                            dataLength = width * height * 3;\r\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        } else { // 32\r\n                            texture.format = 5;\r\n                            dataLength = width * height * 4;\r\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\r\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                        }\r\n                    } else if (info.isLuminance) {\r\n                        var unpackAlignment = engine._getUnpackAlignement();\r\n                        var unpaddedRowSize = width;\r\n                        var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\r\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\r\n\r\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\r\n                        texture.format = 1;\r\n                        texture.type = 0;\r\n\r\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\r\n                    } else {\r\n                        dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\r\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\r\n\r\n                        texture.type = 0;\r\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\r\n                    }\r\n                }\r\n                dataOffset += bpp ? (width * height * (bpp / 8)) : dataLength;\r\n                width *= 0.5;\r\n                height *= 0.5;\r\n\r\n                width = Math.max(1.0, width);\r\n                height = Math.max(1.0, height);\r\n            }\r\n\r\n            if (currentFace !== undefined) {\r\n                // Loading a single face\r\n                break;\r\n            }\r\n        }\r\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\r\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\r\n                size: header[off_width],\r\n                right: sphericalPolynomialFaces[0],\r\n                left: sphericalPolynomialFaces[1],\r\n                up: sphericalPolynomialFaces[2],\r\n                down: sphericalPolynomialFaces[3],\r\n                front: sphericalPolynomialFaces[4],\r\n                back: sphericalPolynomialFaces[5],\r\n                format: 5,\r\n                type: 1,\r\n                gammaSpace: false,\r\n            });\r\n        } else {\r\n            info.sphericalPolynomial = undefined;\r\n        }\r\n    }\r\n}\r\n\r\ndeclare module \"../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n         * @param rootUrl defines the url where the file to load is located\r\n         * @param scene defines the current scene\r\n         * @param lodScale defines scale to apply to the mip map selection\r\n         * @param lodOffset defines offset to apply to the mip map selection\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createPrefilteredCubeTexture(rootUrl: string, scene: Nullable<Scene>, lodScale: number, lodOffset: number,\r\n            onLoad?: Nullable<(internalTexture: Nullable<InternalTexture>) => void>,\r\n            onError?: Nullable<(message?: string, exception?: any) => void>,\r\n            format?: number, forcedExtension?: any,\r\n            createPolynomials?: boolean): InternalTexture;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\r\n * @param rootUrl defines the url where the file to load is located\r\n * @param scene defines the current scene\r\n * @param lodScale defines scale to apply to the mip map selection\r\n * @param lodOffset defines offset to apply to the mip map selection\r\n * @param onLoad defines an optional callback raised when the texture is loaded\r\n * @param onError defines an optional callback raised if there is an issue to load the texture\r\n * @param format defines the format of the data\r\n * @param forcedExtension defines the extension to use to pick the right loader\r\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\r\n * @returns the cube texture as an InternalTexture\r\n */\r\nThinEngine.prototype.createPrefilteredCubeTexture = function(rootUrl: string, scene: Nullable<Scene>, lodScale: number, lodOffset: number,\r\n    onLoad: Nullable<(internalTexture: Nullable<InternalTexture>) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number, forcedExtension: any = null,\r\n    createPolynomials: boolean = true): InternalTexture {\r\n    var callback = (loadData: any) => {\r\n        if (!loadData) {\r\n            if (onLoad) {\r\n                onLoad(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        let texture = loadData.texture as InternalTexture;\r\n        if (!createPolynomials) {\r\n            texture._sphericalPolynomial = new SphericalPolynomial();\r\n        }\r\n        else if (loadData.info.sphericalPolynomial) {\r\n            texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\r\n        }\r\n        texture._source = InternalTextureSource.CubePrefiltered;\r\n\r\n        if (this.getCaps().textureLOD) {\r\n            // Do not add extra process if texture lod is supported.\r\n            if (onLoad) {\r\n                onLoad(texture);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const mipSlices = 3;\r\n\r\n        var gl = this._gl;\r\n        const width = loadData.width;\r\n        if (!width) {\r\n            return;\r\n        }\r\n\r\n        const textures: BaseTexture[] = [];\r\n        for (let i = 0; i < mipSlices; i++) {\r\n            //compute LOD from even spacing in smoothness (matching shader calculation)\r\n            let smoothness = i / (mipSlices - 1);\r\n            let roughness = 1 - smoothness;\r\n\r\n            let minLODIndex = lodOffset; // roughness = 0\r\n            let maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\r\n\r\n            let lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n            let mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n            var glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\r\n            glTextureFromLod.type = texture.type;\r\n            glTextureFromLod.format = texture.format;\r\n            glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\r\n            glTextureFromLod.height = glTextureFromLod.width;\r\n            glTextureFromLod.isCube = true;\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\r\n\r\n            glTextureFromLod.samplingMode = 2;\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n            if (loadData.isDDS) {\r\n                var info: DDSInfo = loadData.info;\r\n                var data: any = loadData.data;\r\n                this._unpackFlipY(info.isCompressed);\r\n\r\n                DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\r\n            }\r\n            else {\r\n                Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n            // Wrap in a base texture for easy binding.\r\n            const lodTexture = new BaseTexture(scene);\r\n            lodTexture.isCube = true;\r\n            lodTexture._texture = glTextureFromLod;\r\n\r\n            glTextureFromLod.isReady = true;\r\n            textures.push(lodTexture);\r\n        }\r\n\r\n        texture._lodTextureHigh = textures[2];\r\n        texture._lodTextureMid = textures[1];\r\n        texture._lodTextureLow = textures[0];\r\n\r\n        if (onLoad) {\r\n            onLoad(texture);\r\n        }\r\n    };\r\n\r\n    return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}