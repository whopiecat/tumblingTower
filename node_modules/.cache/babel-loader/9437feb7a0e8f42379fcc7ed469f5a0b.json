{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { PrePassRenderer } from \"./prePassRenderer\";\nimport { Logger } from \"../Misc/logger\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n  get: function () {\n    return this._prePassRenderer;\n  },\n  set: function (value) {\n    if (value && value.isSupported) {\n      this._prePassRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.enablePrePassRenderer = function () {\n  if (this._prePassRenderer) {\n    return this._prePassRenderer;\n  }\n\n  this._prePassRenderer = new PrePassRenderer(this);\n\n  if (!this._prePassRenderer.isSupported) {\n    this._prePassRenderer = null;\n    Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n  }\n\n  return this._prePassRenderer;\n};\n\nScene.prototype.disablePrePassRenderer = function () {\n  if (!this._prePassRenderer) {\n    return;\n  }\n\n  this._prePassRenderer.dispose();\n\n  this._prePassRenderer = null;\n};\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\n\n\nvar PrePassRendererSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function PrePassRendererSceneComponent(scene) {\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.register = function () {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);\n\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeCameraDraw = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._beforeCameraDraw();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterCameraDraw = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterCameraDraw();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeClearStage = function () {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer.clear();\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._beforeRenderingMeshStage = function (mesh, subMesh, batch, effect) {\n    if (!effect) {\n      return;\n    } // Render to MRT\n\n\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n    }\n  };\n\n  PrePassRendererSceneComponent.prototype._afterRenderingMeshStage = function (mesh) {\n    var scene = mesh.getScene();\n\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.restoreAttachments();\n    }\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\r\n   * Disposes the component and the associated ressources\r\n   */\n\n\n  PrePassRendererSceneComponent.prototype.dispose = function () {// Nothing to do for this component\n  };\n\n  return PrePassRendererSceneComponent;\n}();\n\nexport { PrePassRendererSceneComponent };\n\nPrePassRenderer._SceneComponentInitialization = function (scene) {\n  // Register the G Buffer component to the scene.\n  var component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n\n  if (!component) {\n    component = new PrePassRendererSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/prePassRendererSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { PrePassRenderer } from \"./prePassRenderer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /** @hidden (Backing field) */\r\n        _prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the current prepass renderer associated to the scene.\r\n         */\r\n        prePassRenderer: Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Enables the prepass and associates it with the scene\r\n         * @returns the PrePassRenderer\r\n         */\r\n        enablePrePassRenderer(): Nullable<PrePassRenderer>;\r\n\r\n        /**\r\n         * Disables the prepass associated with the scene\r\n         */\r\n        disablePrePassRenderer(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\r\n    get: function(this: Scene) {\r\n        return this._prePassRenderer;\r\n    },\r\n    set: function(this: Scene, value: Nullable<PrePassRenderer>) {\r\n        if (value && value.isSupported) {\r\n            this._prePassRenderer = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\nScene.prototype.enablePrePassRenderer = function(): Nullable<PrePassRenderer> {\r\n    if (this._prePassRenderer) {\r\n        return this._prePassRenderer;\r\n    }\r\n\r\n    this._prePassRenderer = new PrePassRenderer(this);\r\n\r\n    if (!this._prePassRenderer.isSupported) {\r\n        this._prePassRenderer = null;\r\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" +\r\n            \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" +\r\n            \" + Subsurface Scattering\");\r\n    }\r\n\r\n    return this._prePassRenderer;\r\n};\r\n\r\nScene.prototype.disablePrePassRenderer = function(): void {\r\n    if (!this._prePassRenderer) {\r\n        return;\r\n    }\r\n\r\n    this._prePassRenderer.dispose();\r\n    this._prePassRenderer = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class PrePassRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PREPASSRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEARSTAGE_PREPASS, this, this._beforeClearStage);\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\r\n    }\r\n\r\n    private _beforeCameraDraw() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._beforeCameraDraw();\r\n        }\r\n    }\r\n\r\n    private _afterCameraDraw() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer._afterCameraDraw();\r\n        }\r\n    }\r\n\r\n    private _beforeClearStage() {\r\n        if (this.scene.prePassRenderer) {\r\n            this.scene.prePassRenderer.clear();\r\n        }\r\n    }\r\n\r\n    private _beforeRenderingMeshStage(mesh: AbstractMesh, subMesh: SubMesh, batch: _InstancesBatch, effect: Nullable<Effect>) {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        // Render to MRT\r\n        const scene = mesh.getScene();\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMeshStage(mesh: AbstractMesh) {\r\n        const scene = mesh.getScene();\r\n\r\n        if (scene.prePassRenderer) {\r\n            scene.prePassRenderer.restoreAttachments();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n}\r\n\r\nPrePassRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER) as PrePassRendererSceneComponent;\r\n    if (!component) {\r\n        component = new PrePassRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}