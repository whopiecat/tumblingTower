{"ast":null,"code":"import { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\nimport { ImageProcessingPostProcess } from \"../PostProcesses/imageProcessingPostProcess\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color4 } from \"../Maths/math.color\";\nimport { Material } from '../Materials/material';\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\n/**\r\n * Renders a pre pass of the scene\r\n * This means every mesh in the scene will be rendered to a render target texture\r\n * And then this texture will be composited to the rendering canvas with post processes\r\n * It is necessary for effects like subsurface scattering or deferred shading\r\n */\n\nvar PrePassRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instanciates a prepass renderer\r\n   * @param scene The scene\r\n   */\n  function PrePassRenderer(scene) {\n    this._textureFormats = [{\n      type: 0,\n      format: 2\n    }, {\n      type: 1,\n      format: 2\n    }, {\n      type: 2,\n      format: 2\n    }, {\n      type: 3,\n      format: 0\n    }, {\n      type: 4,\n      format: 2\n    }, {\n      type: 5,\n      format: 2\n    }, {\n      type: 6,\n      format: 0\n    }];\n    /**\r\n     * To save performance, we can excluded skinned meshes from the prepass\r\n     */\n\n    this.excludedSkinnedMesh = [];\n    /**\r\n     * Force material to be excluded from the prepass\r\n     * Can be useful when `useGeometryBufferFallback` is set to `true`\r\n     * and you don't want a material to show in the effect.\r\n     */\n\n    this.excludedMaterials = [];\n    this._textureIndices = [];\n    this._isDirty = false;\n    /**\r\n     * Number of textures in the multi render target texture where the scene is directly rendered\r\n     */\n\n    this.mrtCount = 0;\n    this._postProcesses = [];\n    this._clearColor = new Color4(0, 0, 0, 0);\n    /**\r\n     * Configuration for prepass effects\r\n     */\n\n    this._effectConfigurations = [];\n    this._mrtFormats = [];\n    this._enabled = false;\n    this._useGeometryBufferFallback = false;\n    /**\r\n     * Set to true to disable gamma transform in PrePass.\r\n     * Can be useful in case you already proceed to gamma transform on a material level\r\n     * and your post processes don't need to be in linear color space.\r\n     */\n\n    this.disableGammaTransform = false;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n\n    PrePassRenderer._SceneComponentInitialization(this._scene);\n\n    this._resetLayout();\n  }\n\n  Object.defineProperty(PrePassRenderer.prototype, \"enabled\", {\n    /**\r\n     * Indicates if the prepass is enabled\r\n     */\n    get: function () {\n      return this._enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PrePassRenderer.prototype, \"samples\", {\n    /**\r\n     * How many samples are used for MSAA of the scene render target\r\n     */\n    get: function () {\n      return this.prePassRT.samples;\n    },\n    set: function (n) {\n      if (!this.imageProcessingPostProcess) {\n        this._createCompositionEffect();\n      }\n\n      this.prePassRT.samples = n;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PrePassRenderer.prototype, \"useGeometryBufferFallback\", {\n    /**\r\n     * Uses the geometry buffer renderer as a fallback for non prepass capable effects\r\n     */\n    get: function () {\n      return this._useGeometryBufferFallback;\n    },\n    set: function (value) {\n      this._useGeometryBufferFallback = value;\n\n      if (value) {\n        this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n\n        if (!this._geometryBuffer) {\n          // Not supported\n          this._useGeometryBufferFallback = false;\n          return;\n        }\n\n        this._geometryBuffer.renderList = [];\n\n        this._geometryBuffer._linkPrePassRenderer(this);\n\n        this._updateGeometryBufferLayout();\n      } else {\n        if (this._geometryBuffer) {\n          this._geometryBuffer._unlinkPrePassRenderer();\n        }\n\n        this._geometryBuffer = null;\n\n        this._scene.disableGeometryBufferRenderer();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  PrePassRenderer.prototype._initializeAttachments = function () {\n    var multiRenderLayout = [];\n    var clearLayout = [false];\n    var defaultLayout = [true];\n\n    for (var i = 0; i < this.mrtCount; i++) {\n      multiRenderLayout.push(true);\n\n      if (i > 0) {\n        clearLayout.push(true);\n        defaultLayout.push(false);\n      }\n    }\n\n    this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n    this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n    this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n  };\n\n  PrePassRenderer.prototype._createCompositionEffect = function () {\n    this.prePassRT = new MultiRenderTarget(\"sceneprePassRT\", {\n      width: this._engine.getRenderWidth(),\n      height: this._engine.getRenderHeight()\n    }, this.mrtCount, this._scene, {\n      generateMipMaps: false,\n      generateDepthTexture: true,\n      defaultType: 0,\n      types: this._mrtFormats\n    });\n    this.prePassRT.samples = 1;\n\n    this._initializeAttachments();\n\n    if (this._useGeometryBufferFallback && !this._geometryBuffer) {\n      // Initializes the link with geometry buffer\n      this.useGeometryBufferFallback = true;\n    }\n\n    this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"sceneCompositionPass\", 1, null, undefined, this._engine);\n    this.imageProcessingPostProcess.autoClear = false;\n  };\n\n  Object.defineProperty(PrePassRenderer.prototype, \"isSupported\", {\n    /**\r\n     * Indicates if rendering a prepass is supported\r\n     */\n    get: function () {\n      return this._engine.webGLVersion > 1 || this._scene.getEngine().getCaps().drawBuffersExtension;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the proper output textures to draw in the engine.\r\n   * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\r\n   * @param subMesh Submesh on which the effect is applied\r\n   */\n\n  PrePassRenderer.prototype.bindAttachmentsForEffect = function (effect, subMesh) {\n    if (this.enabled) {\n      if (effect._multiTarget) {\n        this._engine.bindAttachments(this._multiRenderAttachments);\n      } else {\n        this._engine.bindAttachments(this._defaultAttachments);\n\n        if (this._geometryBuffer) {\n          var material = subMesh.getMaterial();\n\n          if (material && this.excludedMaterials.indexOf(material) === -1) {\n            this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Restores attachments for single texture draw.\r\n   */\n\n\n  PrePassRenderer.prototype.restoreAttachments = function () {\n    if (this.enabled && this._defaultAttachments) {\n      this._engine.bindAttachments(this._defaultAttachments);\n    }\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PrePassRenderer.prototype._beforeCameraDraw = function () {\n    if (this._isDirty) {\n      this._update();\n    }\n\n    if (this._geometryBuffer) {\n      this._geometryBuffer.renderList.length = 0;\n    }\n\n    this._bindFrameBuffer();\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  PrePassRenderer.prototype._afterCameraDraw = function () {\n    if (this._enabled) {\n      var firstCameraPP = this._scene.activeCamera && this._scene.activeCamera._getFirstPostProcess();\n\n      if (firstCameraPP && this._postProcesses.length) {\n        this._scene.postProcessManager._prepareFrame();\n      }\n\n      this._scene.postProcessManager.directRender(this._postProcesses, firstCameraPP ? firstCameraPP.inputTexture : null);\n    }\n  };\n\n  PrePassRenderer.prototype._checkRTSize = function () {\n    var requiredWidth = this._engine.getRenderWidth(true);\n\n    var requiredHeight = this._engine.getRenderHeight(true);\n\n    var width = this.prePassRT.getRenderWidth();\n    var height = this.prePassRT.getRenderHeight();\n\n    if (width !== requiredWidth || height !== requiredHeight) {\n      this.prePassRT.resize({\n        width: requiredWidth,\n        height: requiredHeight\n      });\n\n      this._updateGeometryBufferLayout();\n\n      this._bindPostProcessChain();\n    }\n  };\n\n  PrePassRenderer.prototype._bindFrameBuffer = function () {\n    if (this._enabled) {\n      this._checkRTSize();\n\n      var internalTexture = this.prePassRT.getInternalTexture();\n\n      if (internalTexture) {\n        this._engine.bindFramebuffer(internalTexture);\n      }\n    }\n  };\n  /**\r\n   * Clears the scene render target (in the sense of settings pixels to the scene clear color value)\r\n   */\n\n\n  PrePassRenderer.prototype.clear = function () {\n    if (this._enabled) {\n      this._bindFrameBuffer(); // Regular clear color with the scene clear color of the 1st attachment\n\n\n      this._engine.clear(this._scene.clearColor, this._scene.autoClear || this._scene.forceWireframe || this._scene.forcePointsCloud, this._scene.autoClearDepthAndStencil, this._scene.autoClearDepthAndStencil); // Clearing other attachment with 0 on all other attachments\n\n\n      this._engine.bindAttachments(this._clearAttachments);\n\n      this._engine.clear(this._clearColor, true, false, false);\n\n      this._engine.bindAttachments(this._defaultAttachments);\n    }\n  };\n\n  PrePassRenderer.prototype._setState = function (enabled) {\n    this._enabled = enabled;\n    this._scene.prePass = enabled;\n\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.imageProcessingConfiguration.applyByPostProcess = enabled;\n    }\n  };\n\n  PrePassRenderer.prototype._updateGeometryBufferLayout = function () {\n    if (this._geometryBuffer) {\n      this._geometryBuffer._resetLayout();\n\n      var texturesActivated = [];\n\n      for (var i = 0; i < this._mrtLayout.length; i++) {\n        texturesActivated.push(false);\n      }\n\n      this._geometryBuffer._linkInternalTexture(this.prePassRT.getInternalTexture());\n\n      var matches = [{\n        prePassConstant: 5,\n        geometryBufferConstant: GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE\n      }, {\n        prePassConstant: 1,\n        geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE\n      }, {\n        prePassConstant: 3,\n        geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE\n      }, {\n        prePassConstant: 2,\n        geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE\n      }]; // replace textures in the geometryBuffer RT\n\n      for (var i = 0; i < matches.length; i++) {\n        var index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n\n        if (index !== -1) {\n          this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n\n          texturesActivated[index] = true;\n        }\n      }\n\n      this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n    }\n  };\n  /**\r\n   * Adds an effect configuration to the prepass.\r\n   * If an effect has already been added, it won't add it twice and will return the configuration\r\n   * already present.\r\n   * @param cfg the effect configuration\r\n   * @return the effect configuration now used by the prepass\r\n   */\n\n\n  PrePassRenderer.prototype.addEffectConfiguration = function (cfg) {\n    // Do not add twice\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].name === cfg.name) {\n        return this._effectConfigurations[i];\n      }\n    }\n\n    this._effectConfigurations.push(cfg);\n\n    return cfg;\n  };\n  /**\r\n   * Returns the index of a texture in the multi render target texture array.\r\n   * @param type Texture type\r\n   * @return The index\r\n   */\n\n\n  PrePassRenderer.prototype.getIndex = function (type) {\n    return this._textureIndices[type];\n  };\n\n  PrePassRenderer.prototype._enable = function () {\n    var _a, _b;\n\n    var previousMrtCount = this.mrtCount;\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled) {\n        this._enableTextures(this._effectConfigurations[i].texturesRequired);\n      }\n    }\n\n    if (this.prePassRT && this.mrtCount !== previousMrtCount) {\n      this.prePassRT.updateCount(this.mrtCount, {\n        types: this._mrtFormats\n      });\n    }\n\n    this._updateGeometryBufferLayout();\n\n    this._resetPostProcessChain();\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled) {\n        if (!this._effectConfigurations[i].postProcess && this._effectConfigurations[i].createPostProcess) {\n          this._effectConfigurations[i].createPostProcess();\n        }\n\n        if (this._effectConfigurations[i].postProcess) {\n          this._postProcesses.push(this._effectConfigurations[i].postProcess);\n        }\n      }\n    }\n\n    this._initializeAttachments();\n\n    if (!this.imageProcessingPostProcess) {\n      this._createCompositionEffect();\n    }\n\n    var isIPPAlreadyPresent = false;\n\n    if ((_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._postProcesses) {\n      for (var i = 0; i < this._scene.activeCamera._postProcesses.length; i++) {\n        if (((_b = this._scene.activeCamera._postProcesses[i]) === null || _b === void 0 ? void 0 : _b.getClassName()) === \"ImageProcessingPostProcess\") {\n          isIPPAlreadyPresent = true;\n        }\n      }\n    }\n\n    if (!isIPPAlreadyPresent && !this.disableGammaTransform) {\n      this._postProcesses.push(this.imageProcessingPostProcess);\n    }\n\n    this._bindPostProcessChain();\n\n    this._setState(true);\n  };\n\n  PrePassRenderer.prototype._disable = function () {\n    this._setState(false);\n\n    this._resetLayout();\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      this._effectConfigurations[i].enabled = false;\n    }\n  };\n\n  PrePassRenderer.prototype._resetLayout = function () {\n    for (var i = 0; i < this._textureFormats.length; i++) {\n      this._textureIndices[this._textureFormats[i].type] = -1;\n    }\n\n    this._textureIndices[4] = 0;\n    this._mrtLayout = [4];\n    this._mrtFormats = [2];\n    this.mrtCount = 1;\n  };\n\n  PrePassRenderer.prototype._resetPostProcessChain = function () {\n    this._postProcesses = [];\n\n    if (this.imageProcessingPostProcess) {\n      this.imageProcessingPostProcess.restoreDefaultInputTexture();\n    }\n\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].postProcess) {\n        this._effectConfigurations[i].postProcess.restoreDefaultInputTexture();\n      }\n    }\n  };\n\n  PrePassRenderer.prototype._bindPostProcessChain = function () {\n    var _a;\n\n    if (this._postProcesses.length) {\n      this._postProcesses[0].inputTexture = this.prePassRT.getInternalTexture();\n    } else {\n      var pp = (_a = this._scene.activeCamera) === null || _a === void 0 ? void 0 : _a._getFirstPostProcess();\n\n      if (pp) {\n        pp.inputTexture = this.prePassRT.getInternalTexture();\n      }\n    }\n  };\n  /**\r\n   * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\r\n   */\n\n\n  PrePassRenderer.prototype.markAsDirty = function () {\n    this._isDirty = true;\n  };\n  /**\r\n   * Enables a texture on the MultiRenderTarget for prepass\r\n   */\n\n\n  PrePassRenderer.prototype._enableTextures = function (types) {\n    for (var i = 0; i < types.length; i++) {\n      var type = types[i];\n\n      if (this._textureIndices[type] === -1) {\n        this._textureIndices[type] = this._mrtLayout.length;\n\n        this._mrtLayout.push(type);\n\n        this._mrtFormats.push(this._textureFormats[type].format);\n\n        this.mrtCount++;\n      }\n    }\n  };\n\n  PrePassRenderer.prototype._update = function () {\n    this._disable();\n\n    var enablePrePass = false;\n\n    for (var i = 0; i < this._scene.materials.length; i++) {\n      if (this._scene.materials[i].setPrePassRenderer(this)) {\n        enablePrePass = true;\n      }\n    }\n\n    var camera = this._scene.activeCamera;\n\n    if (!camera) {\n      return;\n    }\n\n    var postProcesses = camera._postProcesses.filter(function (pp) {\n      return pp != null;\n    });\n\n    if (postProcesses) {\n      for (var i = 0; i < postProcesses.length; i++) {\n        if (postProcesses[i].setPrePassRenderer(this)) {\n          enablePrePass = true;\n        }\n      }\n    }\n\n    this._markAllMaterialsAsPrePassDirty();\n\n    this._isDirty = false;\n\n    if (enablePrePass) {\n      this._enable();\n    }\n\n    if (!this.enabled) {\n      // Prepass disabled, we render only on 1 color attachment\n      this._engine.restoreDefaultFramebuffer();\n\n      this._engine.restoreSingleAttachment();\n    }\n  };\n\n  PrePassRenderer.prototype._markAllMaterialsAsPrePassDirty = function () {\n    var materials = this._scene.materials;\n\n    for (var i = 0; i < materials.length; i++) {\n      materials[i].markAsDirty(Material.PrePassDirtyFlag);\n    }\n  };\n  /**\r\n   * Disposes the prepass renderer.\r\n   */\n\n\n  PrePassRenderer.prototype.dispose = function () {\n    for (var i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].dispose) {\n        this._effectConfigurations[i].dispose();\n      }\n    }\n\n    this.imageProcessingPostProcess.dispose();\n    this.prePassRT.dispose();\n  };\n  /** @hidden */\n\n\n  PrePassRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"PrePassRendererSceneComponent\");\n  };\n\n  return PrePassRenderer;\n}();\n\nexport { PrePassRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/prePassRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\nimport { ImageProcessingPostProcess } from \"../PostProcesses/imageProcessingPostProcess\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { PrePassEffectConfiguration } from \"./prePassEffectConfiguration\";\r\nimport { Nullable } from \"../types\";\r\nimport { AbstractMesh } from '../Meshes/abstractMesh';\r\nimport { Material } from '../Materials/material';\r\nimport { SubMesh } from '../Meshes/subMesh';\r\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\r\n\r\n/**\r\n * Renders a pre pass of the scene\r\n * This means every mesh in the scene will be rendered to a render target texture\r\n * And then this texture will be composited to the rendering canvas with post processes\r\n * It is necessary for effects like subsurface scattering or deferred shading\r\n */\r\nexport class PrePassRenderer {\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"PrePassRendererSceneComponent\");\r\n    }\r\n\r\n    private _textureFormats = [\r\n        {\r\n            type: 0,\r\n            format: 2,\r\n        },\r\n        {\r\n            type: 1,\r\n            format: 2,\r\n        },\r\n        {\r\n            type: 2,\r\n            format: 2,\r\n        },\r\n        {\r\n            type: 3,\r\n            format: 0,\r\n        },\r\n        {\r\n            type: 4,\r\n            format: 2,\r\n        },\r\n        {\r\n            type: 5,\r\n            format: 2,\r\n        },\r\n        {\r\n            type: 6,\r\n            format: 0,\r\n        },\r\n    ];\r\n\r\n    /**\r\n     * To save performance, we can excluded skinned meshes from the prepass\r\n     */\r\n    public excludedSkinnedMesh: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Force material to be excluded from the prepass\r\n     * Can be useful when `useGeometryBufferFallback` is set to `true`\r\n     * and you don't want a material to show in the effect.\r\n     */\r\n    public excludedMaterials: Material[] = [];\r\n\r\n    private _textureIndices: number[] = [];\r\n\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _isDirty: boolean = false;\r\n\r\n    /**\r\n     * Number of textures in the multi render target texture where the scene is directly rendered\r\n     */\r\n    public mrtCount: number = 0;\r\n\r\n    /**\r\n     * The render target where the scene is directly rendered\r\n     */\r\n    public prePassRT: MultiRenderTarget;\r\n\r\n    private _multiRenderAttachments: number[];\r\n    private _defaultAttachments: number[];\r\n    private _clearAttachments: number[];\r\n\r\n    private _postProcesses: PostProcess[] = [];\r\n\r\n    private readonly _clearColor = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Image processing post process for composition\r\n     */\r\n    public imageProcessingPostProcess: ImageProcessingPostProcess;\r\n\r\n    /**\r\n     * Configuration for prepass effects\r\n     */\r\n    private _effectConfigurations: PrePassEffectConfiguration[] = [];\r\n\r\n    private _mrtFormats: number[] = [];\r\n    private _mrtLayout: number[];\r\n\r\n    private _enabled: boolean = false;\r\n\r\n    /**\r\n     * Indicates if the prepass is enabled\r\n     */\r\n    public get enabled() {\r\n        return this._enabled;\r\n    }\r\n\r\n    /**\r\n     * How many samples are used for MSAA of the scene render target\r\n     */\r\n    public get samples() {\r\n        return this.prePassRT.samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        if (!this.imageProcessingPostProcess) {\r\n            this._createCompositionEffect();\r\n        }\r\n\r\n        this.prePassRT.samples = n;\r\n    }\r\n\r\n    private _geometryBuffer: Nullable<GeometryBufferRenderer>;\r\n    private _useGeometryBufferFallback = false;\r\n    /**\r\n     * Uses the geometry buffer renderer as a fallback for non prepass capable effects\r\n     */\r\n    public get useGeometryBufferFallback() : boolean {\r\n        return this._useGeometryBufferFallback;\r\n    }\r\n\r\n    public set useGeometryBufferFallback(value: boolean) {\r\n        this._useGeometryBufferFallback = value;\r\n\r\n        if (value) {\r\n            this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\r\n\r\n            if (!this._geometryBuffer) {\r\n                // Not supported\r\n                this._useGeometryBufferFallback = false;\r\n                return;\r\n            }\r\n\r\n            this._geometryBuffer.renderList = [];\r\n            this._geometryBuffer._linkPrePassRenderer(this);\r\n            this._updateGeometryBufferLayout();\r\n        } else {\r\n            if (this._geometryBuffer) {\r\n                this._geometryBuffer._unlinkPrePassRenderer();\r\n            }\r\n            this._geometryBuffer = null;\r\n            this._scene.disableGeometryBufferRenderer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set to true to disable gamma transform in PrePass.\r\n     * Can be useful in case you already proceed to gamma transform on a material level\r\n     * and your post processes don't need to be in linear color space.\r\n     */\r\n    public disableGammaTransform = false;\r\n\r\n    /**\r\n     * Instanciates a prepass renderer\r\n     * @param scene The scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n\r\n        PrePassRenderer._SceneComponentInitialization(this._scene);\r\n        this._resetLayout();\r\n    }\r\n\r\n    private _initializeAttachments() {\r\n        const multiRenderLayout = [];\r\n        const clearLayout = [false];\r\n        const defaultLayout = [true];\r\n\r\n        for (let i = 0; i < this.mrtCount; i++) {\r\n            multiRenderLayout.push(true);\r\n\r\n            if (i > 0) {\r\n                clearLayout.push(true);\r\n                defaultLayout.push(false);\r\n            }\r\n        }\r\n\r\n        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\r\n        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\r\n        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\r\n    }\r\n\r\n    private _createCompositionEffect() {\r\n        this.prePassRT = new MultiRenderTarget(\"sceneprePassRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this.mrtCount, this._scene,\r\n            { generateMipMaps: false, generateDepthTexture: true, defaultType: 0, types: this._mrtFormats });\r\n        this.prePassRT.samples = 1;\r\n\r\n        this._initializeAttachments();\r\n        if (this._useGeometryBufferFallback && !this._geometryBuffer) {\r\n            // Initializes the link with geometry buffer\r\n            this.useGeometryBufferFallback = true;\r\n        }\r\n\r\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"sceneCompositionPass\", 1, null, undefined, this._engine);\r\n        this.imageProcessingPostProcess.autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Indicates if rendering a prepass is supported\r\n     */\r\n    public get isSupported() {\r\n        return this._engine.webGLVersion > 1 || this._scene.getEngine().getCaps().drawBuffersExtension;\r\n    }\r\n\r\n    /**\r\n     * Sets the proper output textures to draw in the engine.\r\n     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\r\n     * @param subMesh Submesh on which the effect is applied\r\n     */\r\n    public bindAttachmentsForEffect(effect: Effect, subMesh: SubMesh) {\r\n        if (this.enabled) {\r\n            if (effect._multiTarget) {\r\n                this._engine.bindAttachments(this._multiRenderAttachments);\r\n            } else {\r\n                this._engine.bindAttachments(this._defaultAttachments);\r\n\r\n                if (this._geometryBuffer) {\r\n                    const material = subMesh.getMaterial();\r\n                    if (material && this.excludedMaterials.indexOf(material) === -1) {\r\n                        this._geometryBuffer.renderList!.push(subMesh.getRenderingMesh());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores attachments for single texture draw.\r\n     */\r\n    public restoreAttachments() {\r\n        if (this.enabled && this._defaultAttachments) {\r\n            this._engine.bindAttachments(this._defaultAttachments);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _beforeCameraDraw() {\r\n        if (this._isDirty) {\r\n            this._update();\r\n        }\r\n\r\n        if (this._geometryBuffer) {\r\n            this._geometryBuffer.renderList!.length = 0;\r\n        }\r\n\r\n        this._bindFrameBuffer();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _afterCameraDraw() {\r\n        if (this._enabled) {\r\n            const firstCameraPP = this._scene.activeCamera && this._scene.activeCamera._getFirstPostProcess();\r\n            if (firstCameraPP && this._postProcesses.length) {\r\n                this._scene.postProcessManager._prepareFrame();\r\n            }\r\n            this._scene.postProcessManager.directRender(this._postProcesses, firstCameraPP ? firstCameraPP.inputTexture : null);\r\n        }\r\n    }\r\n\r\n    private _checkRTSize() {\r\n        var requiredWidth = this._engine.getRenderWidth(true);\r\n        var requiredHeight = this._engine.getRenderHeight(true);\r\n        var width = this.prePassRT.getRenderWidth();\r\n        var height = this.prePassRT.getRenderHeight();\r\n\r\n        if (width !== requiredWidth || height !== requiredHeight) {\r\n            this.prePassRT.resize({ width: requiredWidth, height: requiredHeight });\r\n\r\n            this._updateGeometryBufferLayout();\r\n            this._bindPostProcessChain();\r\n        }\r\n    }\r\n\r\n    private _bindFrameBuffer() {\r\n        if (this._enabled) {\r\n            this._checkRTSize();\r\n            var internalTexture = this.prePassRT.getInternalTexture();\r\n            if (internalTexture) {\r\n                this._engine.bindFramebuffer(internalTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the scene render target (in the sense of settings pixels to the scene clear color value)\r\n     */\r\n    public clear() {\r\n        if (this._enabled) {\r\n            this._bindFrameBuffer();\r\n\r\n            // Regular clear color with the scene clear color of the 1st attachment\r\n            this._engine.clear(this._scene.clearColor,\r\n                this._scene.autoClear || this._scene.forceWireframe || this._scene.forcePointsCloud,\r\n                this._scene.autoClearDepthAndStencil,\r\n                this._scene.autoClearDepthAndStencil);\r\n\r\n            // Clearing other attachment with 0 on all other attachments\r\n            this._engine.bindAttachments(this._clearAttachments);\r\n            this._engine.clear(this._clearColor, true, false, false);\r\n            this._engine.bindAttachments(this._defaultAttachments);\r\n        }\r\n    }\r\n\r\n    private _setState(enabled: boolean) {\r\n        this._enabled = enabled;\r\n        this._scene.prePass = enabled;\r\n\r\n        if (this.imageProcessingPostProcess) {\r\n            this.imageProcessingPostProcess.imageProcessingConfiguration.applyByPostProcess = enabled;\r\n        }\r\n    }\r\n\r\n    private _updateGeometryBufferLayout() {\r\n        if (this._geometryBuffer) {\r\n            this._geometryBuffer._resetLayout();\r\n\r\n            const texturesActivated = [];\r\n\r\n            for (let i = 0; i < this._mrtLayout.length; i++) {\r\n                texturesActivated.push(false);\r\n            }\r\n\r\n            this._geometryBuffer._linkInternalTexture(this.prePassRT.getInternalTexture()!);\r\n\r\n            const matches = [\r\n                {\r\n                    prePassConstant: 5,\r\n                    geometryBufferConstant: GeometryBufferRenderer.DEPTHNORMAL_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: 1,\r\n                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: 3,\r\n                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,\r\n                },\r\n                {\r\n                    prePassConstant: 2,\r\n                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,\r\n                }\r\n            ];\r\n\r\n            // replace textures in the geometryBuffer RT\r\n            for (let i = 0; i < matches.length; i++) {\r\n                const index = this._mrtLayout.indexOf(matches[i].prePassConstant);\r\n                if (index !== -1) {\r\n                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\r\n                    texturesActivated[index] = true;\r\n                }\r\n            }\r\n\r\n            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds an effect configuration to the prepass.\r\n     * If an effect has already been added, it won't add it twice and will return the configuration\r\n     * already present.\r\n     * @param cfg the effect configuration\r\n     * @return the effect configuration now used by the prepass\r\n     */\r\n    public addEffectConfiguration(cfg: PrePassEffectConfiguration) : PrePassEffectConfiguration {\r\n        // Do not add twice\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].name === cfg.name) {\r\n                return this._effectConfigurations[i];\r\n            }\r\n        }\r\n\r\n        this._effectConfigurations.push(cfg);\r\n        return cfg;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of a texture in the multi render target texture array.\r\n     * @param type Texture type\r\n     * @return The index\r\n     */\r\n    public getIndex(type: number) : number {\r\n        return this._textureIndices[type];\r\n    }\r\n\r\n    private _enable() {\r\n        const previousMrtCount = this.mrtCount;\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].enabled) {\r\n                this._enableTextures(this._effectConfigurations[i].texturesRequired);\r\n            }\r\n        }\r\n\r\n        if (this.prePassRT && this.mrtCount !== previousMrtCount) {\r\n            this.prePassRT.updateCount(this.mrtCount, { types: this._mrtFormats });\r\n        }\r\n\r\n        this._updateGeometryBufferLayout();\r\n        this._resetPostProcessChain();\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].enabled) {\r\n                if (!this._effectConfigurations[i].postProcess && this._effectConfigurations[i].createPostProcess) {\r\n                    this._effectConfigurations[i].createPostProcess!();\r\n                }\r\n\r\n                if (this._effectConfigurations[i].postProcess) {\r\n                    this._postProcesses.push(this._effectConfigurations[i].postProcess!);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._initializeAttachments();\r\n\r\n        if (!this.imageProcessingPostProcess) {\r\n            this._createCompositionEffect();\r\n        }\r\n\r\n        let isIPPAlreadyPresent = false;\r\n        if (this._scene.activeCamera?._postProcesses) {\r\n            for (let i = 0; i < this._scene.activeCamera._postProcesses.length; i++) {\r\n                if (this._scene.activeCamera._postProcesses[i]?.getClassName() === \"ImageProcessingPostProcess\") {\r\n                    isIPPAlreadyPresent = true;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        if (!isIPPAlreadyPresent && !this.disableGammaTransform) {\r\n            this._postProcesses.push(this.imageProcessingPostProcess);\r\n        }\r\n        this._bindPostProcessChain();\r\n        this._setState(true);\r\n    }\r\n\r\n    private _disable() {\r\n        this._setState(false);\r\n        this._resetLayout();\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            this._effectConfigurations[i].enabled = false;\r\n        }\r\n    }\r\n\r\n    private _resetLayout() {\r\n        for (let i = 0 ; i < this._textureFormats.length; i++) {\r\n            this._textureIndices[this._textureFormats[i].type] = -1;\r\n        }\r\n\r\n        this._textureIndices[4] = 0;\r\n        this._mrtLayout = [4];\r\n        this._mrtFormats = [2];\r\n        this.mrtCount = 1;\r\n    }\r\n\r\n    private _resetPostProcessChain() {\r\n        this._postProcesses = [];\r\n        if (this.imageProcessingPostProcess) {\r\n            this.imageProcessingPostProcess.restoreDefaultInputTexture();\r\n        }\r\n\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].postProcess) {\r\n                this._effectConfigurations[i].postProcess!.restoreDefaultInputTexture();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _bindPostProcessChain() {\r\n        if (this._postProcesses.length) {\r\n            this._postProcesses[0].inputTexture = this.prePassRT.getInternalTexture()!;\r\n        } else {\r\n            const pp = this._scene.activeCamera?._getFirstPostProcess();\r\n            if (pp) {\r\n                pp.inputTexture = this.prePassRT.getInternalTexture()!;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Enables a texture on the MultiRenderTarget for prepass\r\n     */\r\n    private _enableTextures(types: number[]) {\r\n        for (let i = 0; i < types.length; i++) {\r\n            let type = types[i];\r\n\r\n            if (this._textureIndices[type] === -1) {\r\n                this._textureIndices[type] = this._mrtLayout.length;\r\n                this._mrtLayout.push(type);\r\n\r\n                this._mrtFormats.push(this._textureFormats[type].format);\r\n                this.mrtCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _update() {\r\n        this._disable();\r\n        let enablePrePass = false;\r\n\r\n        for (let i = 0; i < this._scene.materials.length; i++) {\r\n            if (this._scene.materials[i].setPrePassRenderer(this)) {\r\n                enablePrePass = true;\r\n            }\r\n        }\r\n\r\n        const camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const postProcesses = (<Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => { return pp != null; }));\r\n\r\n        if (postProcesses) {\r\n            for (let i = 0; i < postProcesses.length; i++) {\r\n                if (postProcesses[i].setPrePassRenderer(this)) {\r\n                    enablePrePass = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._markAllMaterialsAsPrePassDirty();\r\n        this._isDirty = false;\r\n\r\n        if (enablePrePass) {\r\n            this._enable();\r\n        }\r\n\r\n        if (!this.enabled) {\r\n            // Prepass disabled, we render only on 1 color attachment\r\n            this._engine.restoreDefaultFramebuffer();\r\n            this._engine.restoreSingleAttachment();\r\n        }\r\n    }\r\n\r\n    private _markAllMaterialsAsPrePassDirty() {\r\n        const materials = this._scene.materials;\r\n\r\n        for (let i = 0; i < materials.length; i++) {\r\n            materials[i].markAsDirty(Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the prepass renderer.\r\n     */\r\n    public dispose() {\r\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\r\n            if (this._effectConfigurations[i].dispose) {\r\n                this._effectConfigurations[i].dispose!();\r\n            }\r\n        }\r\n\r\n        this.imageProcessingPostProcess.dispose();\r\n        this.prePassRT.dispose();\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}