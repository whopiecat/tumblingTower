{"ast":null,"code":"import { Buffer, VertexBuffer } from \"../Meshes/buffer\";\nimport \"../Engines/Extensions/engine.alpha\";\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\nimport \"../Shaders/sprites.fragment\";\nimport \"../Shaders/sprites.vertex\";\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSriptes with ThinEngine only.\r\n */\n\nvar SpriteRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sprite Renderer\r\n   * @param engine defines the engine the renderer works with\r\n   * @param capacity defines the maximum allowed number of sprites\r\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n   * @param scene defines the hosting scene\r\n   */\n  function SpriteRenderer(engine, capacity, epsilon, scene) {\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\n\n\n    this.blendMode = 2;\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\n\n    this.autoResetAlpha = true;\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\n\n    this.disableDepthWrite = false;\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\n\n    this.fogEnabled = true;\n    this._useVAO = false;\n    this._useInstancing = false;\n    this._vertexBuffers = {};\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._engine = engine;\n    this._useInstancing = engine.getCaps().instancedArrays;\n    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n    this._scene = scene;\n\n    if (!this._useInstancing) {\n      var indices = [];\n      var index = 0;\n\n      for (var count = 0; count < capacity; count++) {\n        indices.push(index);\n        indices.push(index + 1);\n        indices.push(index + 2);\n        indices.push(index);\n        indices.push(index + 2);\n        indices.push(index + 3);\n        index += 4;\n      }\n\n      this._indexBuffer = engine.createIndexBuffer(indices);\n    } // VBO\n    // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n    // 16 when using instances\n\n\n    this._vertexBufferSize = this._useInstancing ? 16 : 18;\n    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n\n    var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n\n    var options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n\n    var offset = 6;\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n    } else {\n      offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n      offset += 2;\n    }\n\n    var inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n\n    var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n\n    var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    this._vertexBuffers[\"options\"] = options;\n    this._vertexBuffers[\"offsets\"] = offsets;\n    this._vertexBuffers[\"inverts\"] = inverts;\n    this._vertexBuffers[\"cellInfo\"] = cellInfo;\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors; // Effects\n\n    this._effectBase = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\");\n\n    if (this._scene) {\n      this._effectFog = this._scene.getEngine().createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n    }\n  }\n\n  Object.defineProperty(SpriteRenderer.prototype, \"capacity\", {\n    /**\r\n     * Gets the capacity of the manager\r\n     */\n    get: function () {\n      return this._capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Render all child sprites\r\n   * @param sprites defines the list of sprites to render\r\n   * @param deltaTime defines the time since last frame\r\n   * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n   * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n   * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n   */\n\n  SpriteRenderer.prototype.render = function (sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate) {\n    if (customSpriteUpdate === void 0) {\n      customSpriteUpdate = null;\n    }\n\n    if (!this.texture || !this.texture.isReady() || !sprites.length) {\n      return;\n    }\n\n    var effect = this._effectBase;\n    var shouldRenderFog = false;\n\n    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n      effect = this._effectFog;\n      shouldRenderFog = true;\n    } // Check\n\n\n    if (!effect.isReady()) {\n      return;\n    }\n\n    var engine = this._engine;\n    var useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n    var baseSize = this.texture.getBaseSize(); // Sprites\n\n    var max = Math.min(this._capacity, sprites.length);\n    var offset = 0;\n    var noSprite = true;\n\n    for (var index = 0; index < max; index++) {\n      var sprite = sprites[index];\n\n      if (!sprite || !sprite.isVisible) {\n        continue;\n      }\n\n      noSprite = false;\n\n      sprite._animate(deltaTime);\n\n      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n      if (!this._useInstancing) {\n        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n\n        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n      }\n    }\n\n    if (noSprite) {\n      return;\n    }\n\n    this._buffer.update(this._vertexData);\n\n    var culling = engine.depthCullingState.cull || true;\n    var zOffset = engine.depthCullingState.zOffset; // Handle Right Handed\n\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, false);\n    } // Render\n\n\n    engine.enableEffect(effect);\n    effect.setTexture(\"diffuseSampler\", this.texture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", projectionMatrix); // Scene Info\n\n    if (shouldRenderFog) {\n      var scene = this._scene; // Fog\n\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n\n    if (this._useVAO) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // Draw order\n\n\n    engine.depthCullingState.depthFunc = 515;\n\n    if (!this.disableDepthWrite) {\n      effect.setBool(\"alphaTest\", true);\n      engine.setColorWrite(false);\n\n      if (this._useInstancing) {\n        engine.drawArraysType(8, 0, 4, offset);\n      } else {\n        engine.drawElementsType(0, 0, offset / 4 * 6);\n      }\n\n      engine.setColorWrite(true);\n      effect.setBool(\"alphaTest\", false);\n    }\n\n    engine.setAlphaMode(this.blendMode);\n\n    if (this._useInstancing) {\n      engine.drawArraysType(8, 0, 4, offset);\n    } else {\n      engine.drawElementsType(0, 0, offset / 4 * 6);\n    }\n\n    if (this.autoResetAlpha) {\n      engine.setAlphaMode(0);\n    } // Restore Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, true);\n    }\n\n    engine.unbindInstanceAttributes();\n  };\n\n  SpriteRenderer.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n    var arrayOffset = index * this._vertexBufferSize;\n\n    if (offsetX === 0) {\n      offsetX = this._epsilon;\n    } else if (offsetX === 1) {\n      offsetX = 1 - this._epsilon;\n    }\n\n    if (offsetY === 0) {\n      offsetY = this._epsilon;\n    } else if (offsetY === 1) {\n      offsetY = 1 - this._epsilon;\n    }\n\n    if (customSpriteUpdate) {\n      customSpriteUpdate(sprite, baseSize);\n    } else {\n      if (!sprite.cellIndex) {\n        sprite.cellIndex = 0;\n      }\n\n      var rowSize = baseSize.width / this.cellWidth;\n      var offset = sprite.cellIndex / rowSize >> 0;\n      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\n      sprite._yOffset = offset * this.cellHeight / baseSize.height;\n      sprite._xSize = this.cellWidth;\n      sprite._ySize = this.cellHeight;\n    } // Positions\n\n\n    this._vertexData[arrayOffset] = sprite.position.x;\n    this._vertexData[arrayOffset + 1] = sprite.position.y;\n    this._vertexData[arrayOffset + 2] = sprite.position.z;\n    this._vertexData[arrayOffset + 3] = sprite.angle; // Options\n\n    this._vertexData[arrayOffset + 4] = sprite.width;\n    this._vertexData[arrayOffset + 5] = sprite.height;\n\n    if (!this._useInstancing) {\n      this._vertexData[arrayOffset + 6] = offsetX;\n      this._vertexData[arrayOffset + 7] = offsetY;\n    } else {\n      arrayOffset -= 2;\n    } // Inverts according to Right Handed\n\n\n    if (useRightHandedSystem) {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n    } else {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n    }\n\n    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n    this._vertexData[arrayOffset + 10] = sprite._xOffset;\n    this._vertexData[arrayOffset + 11] = sprite._yOffset;\n    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height; // Color\n\n    this._vertexData[arrayOffset + 14] = sprite.color.r;\n    this._vertexData[arrayOffset + 15] = sprite.color.g;\n    this._vertexData[arrayOffset + 16] = sprite.color.b;\n    this._vertexData[arrayOffset + 17] = sprite.color.a;\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteRenderer.prototype.dispose = function () {\n    if (this._buffer) {\n      this._buffer.dispose();\n\n      this._buffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n  };\n\n  return SpriteRenderer;\n}();\n\nexport { SpriteRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Sprites/spriteRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\n\r\nimport { IMatrixLike } from '../Maths/math.like';\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { DataBuffer } from \"../Meshes/dataBuffer\";\r\nimport { Buffer, VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { ThinSprite } from './thinSprite';\r\nimport { ISize } from '../Maths/math.size';\r\n\r\ndeclare type ThinTexture = import(\"../Materials/Textures/thinTexture\").ThinTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport \"../Engines/Extensions/engine.dynamicBuffer\";\r\n\r\nimport \"../Shaders/sprites.fragment\";\r\nimport \"../Shaders/sprites.vertex\";\r\n\r\n/**\r\n * Class used to render sprites.\r\n *\r\n * It can be used either to render Sprites or ThinSriptes with ThinEngine only.\r\n */\r\nexport class SpriteRenderer {\r\n    /**\r\n     * Defines the texture of the spritesheet\r\n     */\r\n    public texture: Nullable<ThinTexture>;\r\n\r\n    /**\r\n     * Defines the default width of a cell in the spritesheet\r\n     */\r\n    public cellWidth: number;\r\n\r\n    /**\r\n     * Defines the default height of a cell in the spritesheet\r\n     */\r\n    public cellHeight: number;\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\r\n    public blendMode = 2;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if alpha mode is automatically\r\n     * reset.\r\n     */\r\n    public autoResetAlpha = true;\r\n\r\n    /**\r\n     * Disables writing to the depth buffer when rendering the sprites.\r\n     * It can be handy to disable depth writing when using textures without alpha channel\r\n     * and setting some specific blend modes.\r\n     */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\r\n     */\r\n    public fogEnabled = true;\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._capacity;\r\n    }\r\n\r\n    private readonly _engine: ThinEngine;\r\n    private readonly _useVAO: boolean = false;\r\n    private readonly _useInstancing: boolean = false;\r\n    private readonly _scene: Nullable<Scene>;\r\n\r\n    private readonly _capacity: number;\r\n    private readonly _epsilon: number;\r\n\r\n    private _vertexBufferSize: number;\r\n    private _vertexData: Float32Array;\r\n    private _buffer: Buffer;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: DataBuffer;\r\n    private _effectBase: Effect;\r\n    private _effectFog: Effect;\r\n    private _vertexArrayObject: WebGLVertexArrayObject;\r\n\r\n    /**\r\n     * Creates a new sprite Renderer\r\n     * @param engine defines the engine the renderer works with\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        engine: ThinEngine,\r\n        capacity: number,\r\n        epsilon: number = 0.01,\r\n        scene: Nullable<Scene> = null) {\r\n\r\n        this._capacity = capacity;\r\n        this._epsilon = epsilon;\r\n\r\n        this._engine = engine;\r\n        this._useInstancing = engine.getCaps().instancedArrays;\r\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\r\n        this._scene = scene;\r\n\r\n        if (!this._useInstancing) {\r\n            const indices = [];\r\n            let index = 0;\r\n            for (let count = 0; count < capacity; count++) {\r\n                indices.push(index);\r\n                indices.push(index + 1);\r\n                indices.push(index + 2);\r\n                indices.push(index);\r\n                indices.push(index + 2);\r\n                indices.push(index + 3);\r\n                index += 4;\r\n            }\r\n\r\n            this._indexBuffer = engine.createIndexBuffer(indices);\r\n        }\r\n\r\n        // VBO\r\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\r\n        // 16 when using instances\r\n        this._vertexBufferSize = this._useInstancing ? 16 : 18;\r\n        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\r\n        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\r\n\r\n        const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\r\n        const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\r\n\r\n        let offset = 6;\r\n        let offsets: VertexBuffer;\r\n\r\n        if (this._useInstancing) {\r\n            var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\r\n        } else {\r\n            offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n            offset += 2;\r\n        }\r\n\r\n        const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\r\n        const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\r\n        const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        this._vertexBuffers[\"options\"] = options;\r\n        this._vertexBuffers[\"offsets\"] = offsets;\r\n        this._vertexBuffers[\"inverts\"] = inverts;\r\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n\r\n        // Effects\r\n        this._effectBase = this._engine.createEffect(\"sprites\",\r\n            [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n            [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"],\r\n            [\"diffuseSampler\"], \"\");\r\n\r\n        if (this._scene) {\r\n            this._effectFog = this._scene.getEngine().createEffect(\"sprites\",\r\n                [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind],\r\n                [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"],\r\n                [\"diffuseSampler\"], \"#define FOG\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     * @param sprites defines the list of sprites to render\r\n     * @param deltaTime defines the time since last frame\r\n     * @param viewMatrix defines the viewMatrix to use to render the sprites\r\n     * @param projectionMatrix defines the projectionMatrix to use to render the sprites\r\n     * @param customSpriteUpdate defines a custom function to update the sprites data before they render\r\n     */\r\n    public render(sprites: ThinSprite[], deltaTime: number, viewMatrix: IMatrixLike, projectionMatrix: IMatrixLike, customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void> = null): void {\r\n        if (!this.texture || !this.texture.isReady() || !sprites.length) {\r\n            return;\r\n        }\r\n\r\n        let effect = this._effectBase;\r\n        let shouldRenderFog = false;\r\n        if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\r\n            effect = this._effectFog;\r\n            shouldRenderFog = true;\r\n        }\r\n\r\n        // Check\r\n        if (!effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\r\n        const baseSize = this.texture.getBaseSize();\r\n\r\n        // Sprites\r\n        const max = Math.min(this._capacity, sprites.length);\r\n\r\n        let offset = 0;\r\n        let noSprite = true;\r\n        for (var index = 0; index < max; index++) {\r\n            const sprite = sprites[index];\r\n            if (!sprite || !sprite.isVisible) {\r\n                continue;\r\n            }\r\n\r\n            noSprite = false;\r\n            sprite._animate(deltaTime);\r\n\r\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            if (!this._useInstancing) {\r\n                this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n                this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\r\n            }\r\n        }\r\n\r\n        if (noSprite) {\r\n            return;\r\n        }\r\n\r\n        this._buffer.update(this._vertexData);\r\n\r\n        const culling = engine.depthCullingState.cull || true;\r\n        const zOffset = engine.depthCullingState.zOffset;\r\n\r\n        // Handle Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._scene!.getEngine().setState(culling, zOffset, false, false);\r\n        }\r\n\r\n        // Render\r\n        engine.enableEffect(effect);\r\n\r\n        effect.setTexture(\"diffuseSampler\", this.texture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", projectionMatrix);\r\n\r\n        // Scene Info\r\n        if (shouldRenderFog) {\r\n            const scene = this._scene!;\r\n\r\n            // Fog\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n            engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        }\r\n        else {\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // Draw order\r\n        engine.depthCullingState.depthFunc = 515;\r\n        if (!this.disableDepthWrite) {\r\n            effect.setBool(\"alphaTest\", true);\r\n            engine.setColorWrite(false);\r\n            if (this._useInstancing) {\r\n                engine.drawArraysType(8, 0, 4, offset);\r\n            } else {\r\n                engine.drawElementsType(0, 0, (offset / 4) * 6);\r\n            }\r\n            engine.setColorWrite(true);\r\n            effect.setBool(\"alphaTest\", false);\r\n        }\r\n\r\n        engine.setAlphaMode(this.blendMode);\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(8, 0, 4, offset);\r\n        } else {\r\n            engine.drawElementsType(0, 0, (offset / 4) * 6);\r\n        }\r\n\r\n        if (this.autoResetAlpha) {\r\n            engine.setAlphaMode(0);\r\n        }\r\n\r\n        // Restore Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._scene!.getEngine().setState(culling, zOffset, false, true);\r\n        }\r\n\r\n        engine.unbindInstanceAttributes();\r\n    }\r\n\r\n    private _appendSpriteVertex(index: number, sprite: ThinSprite, offsetX: number, offsetY: number, baseSize: ISize, useRightHandedSystem: boolean, customSpriteUpdate: Nullable<(sprite: ThinSprite, baseSize: ISize) => void>): void {\r\n        var arrayOffset = index * this._vertexBufferSize;\r\n\r\n        if (offsetX === 0) {\r\n            offsetX = this._epsilon;\r\n        }\r\n        else if (offsetX === 1) {\r\n            offsetX = 1 - this._epsilon;\r\n        }\r\n\r\n        if (offsetY === 0) {\r\n            offsetY = this._epsilon;\r\n        }\r\n        else if (offsetY === 1) {\r\n            offsetY = 1 - this._epsilon;\r\n        }\r\n\r\n        if (customSpriteUpdate) {\r\n            customSpriteUpdate(sprite, baseSize);\r\n        }\r\n        else {\r\n            if (!sprite.cellIndex) {\r\n                sprite.cellIndex = 0;\r\n            }\r\n\r\n            const rowSize = baseSize.width / this.cellWidth;\r\n            const offset = (sprite.cellIndex / rowSize) >> 0;\r\n            sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\r\n            sprite._yOffset = offset * this.cellHeight / baseSize.height;\r\n            sprite._xSize = this.cellWidth;\r\n            sprite._ySize = this.cellHeight;\r\n        }\r\n\r\n        // Positions\r\n        this._vertexData[arrayOffset] = sprite.position.x;\r\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\r\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\r\n        this._vertexData[arrayOffset + 3] = sprite.angle;\r\n        // Options\r\n        this._vertexData[arrayOffset + 4] = sprite.width;\r\n        this._vertexData[arrayOffset + 5] = sprite.height;\r\n\r\n        if (!this._useInstancing) {\r\n            this._vertexData[arrayOffset + 6] = offsetX;\r\n            this._vertexData[arrayOffset + 7] = offsetY;\r\n        } else {\r\n            arrayOffset -= 2;\r\n        }\r\n\r\n        // Inverts according to Right Handed\r\n        if (useRightHandedSystem) {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\r\n        }\r\n        else {\r\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\r\n        }\r\n\r\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\r\n\r\n        this._vertexData[arrayOffset + 10] = sprite._xOffset;\r\n        this._vertexData[arrayOffset + 11] = sprite._yOffset;\r\n        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\r\n        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\r\n\r\n        // Color\r\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\r\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\r\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\r\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._buffer) {\r\n            this._buffer.dispose();\r\n            (<any>this._buffer) = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            (<any>this._indexBuffer) = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            (<any>this._vertexArrayObject) = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            (<any>this.texture) = null;\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}