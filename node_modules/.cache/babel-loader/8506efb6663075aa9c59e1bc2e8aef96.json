{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Buffer } from \"../Meshes/buffer\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index\";\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\nimport { Particle } from \"./particle\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport \"../Shaders/particles.fragment\";\nimport \"../Shaders/particles.vertex\";\nimport { Color4, Color3, TmpColors } from '../Maths/math.color';\nimport { ThinEngine } from '../Engines/thinEngine';\nimport { ThinMaterialHelper } from '../Materials/thinMaterialHelper';\nimport \"../Engines/Extensions/engine.alpha\";\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/babylon101/particles\r\n */\n\nvar ParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(ParticleSystem, _super);\n  /**\r\n   * Instantiates a particle system.\r\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n   * @param name The name of the particle system\r\n   * @param capacity The max number of particles alive at the same time\r\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n   * @param customEffect a custom effect used to change the way particles are rendered by default\r\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n   * @param epsilon Offset used to render the particles\r\n   */\n\n\n  function ParticleSystem(name, capacity, sceneOrEngine, customEffect, isAnimationSheetEnabled, epsilon) {\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    var _this = _super.call(this, name) || this;\n    /**\r\n     * @hidden\r\n     */\n\n\n    _this._inheritedVelocityOffset = new Vector3();\n    /**\r\n    * An event triggered when the system is disposed\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    /**\r\n    * An event triggered when the system is stopped\r\n    */\n\n    _this.onStoppedObservable = new Observable();\n    _this._particles = new Array();\n    _this._stockParticles = new Array();\n    _this._newPartsExcess = 0;\n    _this._vertexBuffers = {};\n    _this._scaledColorStep = new Color4(0, 0, 0, 0);\n    _this._colorDiff = new Color4(0, 0, 0, 0);\n    _this._scaledDirection = Vector3.Zero();\n    _this._scaledGravity = Vector3.Zero();\n    _this._currentRenderId = -1;\n    _this._useInstancing = false;\n    _this._started = false;\n    _this._stopped = false;\n    _this._actualFrame = 0;\n    /** @hidden */\n\n    _this._currentEmitRate1 = 0;\n    /** @hidden */\n\n    _this._currentEmitRate2 = 0;\n    /** @hidden */\n\n    _this._currentStartSize1 = 0;\n    /** @hidden */\n\n    _this._currentStartSize2 = 0;\n    _this._rawTextureWidth = 256;\n    _this._useRampGradients = false;\n    /**\r\n     * @hidden\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\n\n    _this._disposeEmitterOnDispose = false;\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null; // start of sub system methods\n\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     */\n\n    _this.recycleParticle = function (particle) {\n      // move particle from activeParticle list to stock particles\n      var lastParticle = _this._particles.pop();\n\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n\n      _this._stockParticles.push(lastParticle);\n    };\n\n    _this._createParticle = function () {\n      var particle;\n\n      if (_this._stockParticles.length !== 0) {\n        particle = _this._stockParticles.pop();\n\n        particle._reset();\n      } else {\n        particle = new Particle(_this);\n      } // Attach emitters\n\n\n      if (_this._subEmitters && _this._subEmitters.length > 0) {\n        var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];\n\n        particle._attachedSubEmitters = [];\n        subEmitters.forEach(function (subEmitter) {\n          if (subEmitter.type === SubEmitterType.ATTACHED) {\n            var newEmitter = subEmitter.clone();\n\n            particle._attachedSubEmitters.push(newEmitter);\n\n            newEmitter.particleSystem.start();\n          }\n        });\n      }\n\n      return particle;\n    };\n\n    _this._emitFromParticle = function (particle) {\n      if (!_this._subEmitters || _this._subEmitters.length === 0) {\n        return;\n      }\n\n      var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);\n\n      _this._subEmitters[templateIndex].forEach(function (subEmitter) {\n        if (subEmitter.type === SubEmitterType.END) {\n          var subSystem = subEmitter.clone();\n\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n\n          subSystem.particleSystem._rootParticleSystem = _this;\n\n          _this.activeSubSystems.push(subSystem.particleSystem);\n\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n\n    _this._capacity = capacity;\n    _this._epsilon = epsilon;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\n    }\n\n    if (_this._engine.getCaps().vertexArrayObject) {\n      _this._vertexArrayObject = null;\n    } // Setup the default processing configuration to the scene.\n\n\n    _this._attachImageProcessingConfiguration(null);\n\n    _this._customEffect = {\n      0: customEffect\n    };\n    _this._useInstancing = _this._engine.getCaps().instancedArrays;\n\n    _this._createIndexBuffer();\n\n    _this._createVertexBuffers(); // Default emitter type\n\n\n    _this.particleEmitterType = new BoxParticleEmitter(); // Update\n\n    _this.updateFunction = function (particles) {\n      var noiseTextureSize = null;\n      var noiseTextureData = null;\n\n      if (_this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = _this.noiseTexture.getSize();\n        noiseTextureData = _this.noiseTexture.getContent();\n      }\n\n      var _loop_1 = function () {\n        particle = particles[index];\n        var scaledUpdateSpeed = _this._scaledUpdateSpeed;\n        var previousAge = particle.age;\n        particle.age += scaledUpdateSpeed; // Evaluate step to death\n\n        if (particle.age > particle.lifeTime) {\n          var diff = particle.age - previousAge;\n          var oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n\n        var ratio = particle.age / particle.lifeTime; // Color\n\n        if (_this._colorGradients && _this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._colorGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);\n          particle.color.addInPlace(_this._scaledColorStep);\n\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        } // Angular speed\n\n\n        if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._angularSpeedGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n\n            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed; // Direction\n\n        var directionScale = scaledUpdateSpeed; /// Velocity\n\n        if (_this._velocityGradients && _this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._velocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n\n            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n\n        particle.direction.scaleToRef(directionScale, _this._scaledDirection); /// Limit velocity\n\n        if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._limitVelocityGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n\n            var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            var currentVelocity = particle.direction.length();\n\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(_this.limitVelocityDamping);\n            }\n          });\n        } /// Drag\n\n\n        if (_this._dragGradients && _this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._dragGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n\n            var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n\n            _this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n\n        if (_this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(_this._scaledDirection);\n\n          Vector3.TransformCoordinatesToRef(particle._localPosition, _this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(_this._scaledDirection);\n        } // Noise\n\n\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n          var force = TmpVectors.Vector3[0];\n          var scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        } // Gravity\n\n\n        _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);\n\n        particle.direction.addInPlace(_this._scaledGravity); // Size\n\n        if (_this._sizeGradients && _this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, _this._sizeGradients, function (currentGradient, nextGradient, scale) {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n\n            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        } // Remap data\n\n\n        if (_this._useRampGradients) {\n          if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._colorRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n\n          if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, _this._alphaRemapGradients, function (currentGradient, nextGradient, scale) {\n              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n\n        if (_this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        } // Update the position of the attached sub-emitters to match their attached particle\n\n\n        particle._inheritParticleInfoToSubEmitters();\n\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          _this._emitFromParticle(particle);\n\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(function (subEmitter) {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n\n            particle._attachedSubEmitters = null;\n          }\n\n          _this.recycleParticle(particle);\n\n          index--;\n          return \"continue\";\n        }\n      };\n\n      var particle;\n\n      for (var index = 0; index < particles.length; index++) {\n        _loop_1();\n      }\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(ParticleSystem.prototype, \"onDispose\", {\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\n    set: function (callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"useRampGradients\", {\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\n    get: function () {\n      return this._useRampGradients;\n    },\n    set: function (value) {\n      if (this._useRampGradients === value) {\n        return;\n      }\n\n      this._useRampGradients = value;\n\n      this._resetEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"particles\", {\n    //end of Sub-emitter\n\n    /**\r\n     * Gets the current list of active particles\r\n     */\n    get: function () {\n      return this._particles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the number of particles active at the same time.\r\n   * @returns The number of active particles.\r\n   */\n\n  ParticleSystem.prototype.getActiveCount = function () {\n    return this._particles.length;\n  };\n  /**\r\n   * Returns the string \"ParticleSystem\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  ParticleSystem.prototype.getClassName = function () {\n    return \"ParticleSystem\";\n  };\n  /**\r\n   * Gets a boolean indicating that the system is stopping\r\n   * @returns true if the system is currently stopping\r\n   */\n\n\n  ParticleSystem.prototype.isStopping = function () {\n    return this._stopped && this.isAlive();\n  };\n  /**\r\n   * Gets the custom effect used to render the particles\r\n   * @param blendMode Blend mode for which the effect should be retrieved\r\n   * @returns The effect\r\n   */\n\n\n  ParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];\n  };\n  /**\r\n   * Sets the custom effect used to render the particles\r\n   * @param effect The effect to set\r\n   * @param blendMode Blend mode for which the effect should be set\r\n   */\n\n\n  ParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customEffect[blendMode] = effect;\n  };\n\n  Object.defineProperty(ParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\n    get: function () {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleSystem.prototype, \"vertexShaderName\", {\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\n    get: function () {\n      return \"particles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor, factor2) {\n    var newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n  };\n\n  ParticleSystem.prototype._removeFactorGradient = function (factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {\n      var factorGradient = factorGradients_1[_i];\n\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n\n      index++;\n    }\n  };\n  /**\r\n   * Adds a new life time gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the life time factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific life time gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new size gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the size factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addSizeGradient = function (gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new color remap gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the color remap minimal range\r\n   * @param max defines the color remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific color remap gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeColorRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new alpha remap gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the alpha remap minimal range\r\n   * @param max defines the alpha remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific alpha remap gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeAlphaRemapGradient = function (gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new angular speed gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the angular speed  to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific angular speed gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the velocity to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new limit velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the limit velocity value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific limit velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new drag gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the drag value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addDragGradient = function (gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific drag gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the emit rate value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific emit rate gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeEmitRateGradient = function (gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n\n    return this;\n  };\n  /**\r\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the start size value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n\n    return this;\n  };\n  /**\r\n   * Remove a specific start size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeStartSizeGradient = function (gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n\n    return this;\n  };\n\n  ParticleSystem.prototype._createRampGradientTexture = function () {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color3[0];\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, function (currentGradient, nextGradient, scale) {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    }\n\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n  /**\r\n   * Gets the current list of ramp gradients.\r\n   * You must use addRampGradient and removeRampGradient to udpate this list\r\n   * @returns the list of ramp gradients\r\n   */\n\n\n  ParticleSystem.prototype.getRampGradients = function () {\n    return this._rampGradients;\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  ParticleSystem.prototype.forceRefreshGradients = function () {\n    this._syncRampGradientTexture();\n  };\n\n  ParticleSystem.prototype._syncRampGradientTexture = function () {\n    if (!this._rampGradients) {\n      return;\n    }\n\n    this._rampGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._createRampGradientTexture();\n  };\n  /**\r\n   * Adds a new ramp gradient used to remap particle colors\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color defines the color to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.addRampGradient = function (gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n\n    var rampGradient = new Color3Gradient(gradient, color);\n\n    this._rampGradients.push(rampGradient);\n\n    this._syncRampGradientTexture();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific ramp gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeRampGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n\n    this._rampGradientsTexture = null;\n\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n\n    return this;\n  };\n  /**\r\n   * Adds a new color gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color1 defines the color to affect to the specified gradient\r\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n   * @returns this particle system\r\n   */\n\n\n  ParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1, color2);\n\n    this._colorGradients.push(colorGradient);\n\n    this._colorGradients.sort(function (a, b) {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    return this;\n  };\n  /**\r\n   * Remove a specific color gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns this particle system\r\n   */\n\n\n  ParticleSystem.prototype.removeColorGradient = function (gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n\n    var index = 0;\n\n    for (var _i = 0, _a = this._colorGradients; _i < _a.length; _i++) {\n      var colorGradient = _a[_i];\n\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n\n        break;\n      }\n\n      index++;\n    }\n\n    return this;\n  };\n\n  ParticleSystem.prototype._fetchR = function (u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    var wrappedU = u * width % width | 0;\n    var wrappedV = v * height % height | 0;\n    var position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  };\n\n  ParticleSystem.prototype._reset = function () {\n    this._resetEffect();\n  };\n\n  ParticleSystem.prototype._resetEffect = function () {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    this._createVertexBuffers();\n  };\n\n  ParticleSystem.prototype._createVertexBuffers = function () {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexBufferSize += 3;\n    }\n\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n\n    var engine = this._engine;\n    this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n    var dataOffset = 0;\n\n    var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n\n    var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n\n    var options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n\n    var size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n\n    if (this._isAnimationSheetEnabled) {\n      var cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      var directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n\n    if (this._useRampGradients) {\n      var rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n\n    var offsets;\n\n    if (this._useInstancing) {\n      var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n\n    this._vertexBuffers[\"offset\"] = offsets;\n  };\n\n  ParticleSystem.prototype._createIndexBuffer = function () {\n    if (this._useInstancing) {\n      return;\n    }\n\n    var indices = [];\n    var index = 0;\n\n    for (var count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  };\n  /**\r\n   * Gets the maximum number of particles active at the same time.\r\n   * @returns The max number of active particles.\r\n   */\n\n\n  ParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n  /**\r\n   * Gets whether there are still active particles in the system.\r\n   * @returns True if it is alive, otherwise false.\r\n   */\n\n\n  ParticleSystem.prototype.isAlive = function () {\n    return this._alive;\n  };\n  /**\r\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n   * @returns True if it has been started, otherwise false.\r\n   */\n\n\n  ParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n\n  ParticleSystem.prototype._prepareSubEmitterInternalArray = function () {\n    var _this = this;\n\n    this._subEmitters = new Array();\n\n    if (this.subEmitters) {\n      this.subEmitters.forEach(function (subEmitter) {\n        if (subEmitter instanceof ParticleSystem) {\n          _this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          _this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          _this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  };\n  /**\r\n   * Starts the particle system and begins to emit\r\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n   */\n\n\n  ParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    var _a;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    } // Convert the subEmitters field to the constant type field _subEmitters\n\n\n    this._prepareSubEmitterInternalArray();\n\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = new Array();\n    } // Reset emit gradient so it acts the same on every start\n\n\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    } // Reset start size gradient so it acts the same on every start\n\n\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n\n    if (this.preWarmCycles) {\n      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n\n      var noiseTextureAsProcedural_1 = this.noiseTexture;\n\n      if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {\n        noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function () {\n          setTimeout(function () {\n            for (var index = 0; index < _this.preWarmCycles; index++) {\n              _this.animate(true);\n\n              noiseTextureAsProcedural_1.render();\n            }\n          });\n        });\n      } else {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    } // Animations\n\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\r\n   * Stops the particle system.\r\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n   */\n\n\n  ParticleSystem.prototype.stop = function (stopSubEmitters) {\n    if (stopSubEmitters === void 0) {\n      stopSubEmitters = true;\n    }\n\n    if (this._stopped) {\n      return;\n    }\n\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }; // animation sheet\n\n  /**\r\n   * Remove all active particles\r\n   */\n\n\n  ParticleSystem.prototype.reset = function () {\n    this._stockParticles = [];\n    this._particles = [];\n  };\n  /**\r\n   * @hidden (for internal use only)\r\n   */\n\n\n  ParticleSystem.prototype._appendParticleVertex = function (index, particle, offsetX, offsetY) {\n    var offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        var initialDirection = particle._initialDirection;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        var direction = particle.direction;\n\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  };\n\n  ParticleSystem.prototype._stopSubEmitters = function () {\n    if (!this.activeSubSystems) {\n      return;\n    }\n\n    this.activeSubSystems.forEach(function (subSystem) {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = new Array();\n  };\n\n  ParticleSystem.prototype._removeFromRoot = function () {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n\n    var index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n\n    this._rootParticleSystem = null;\n  }; // End of sub system methods\n\n\n  ParticleSystem.prototype._update = function (newParticles) {\n    var _this = this; // Update current\n\n\n    this._alive = this._particles.length > 0;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    this.updateFunction(this._particles); // Add new ones\n\n    var particle;\n\n    var _loop_2 = function () {\n      if (this_1._particles.length === this_1._capacity) {\n        return \"break\";\n      }\n\n      particle = this_1._createParticle();\n\n      this_1._particles.push(particle); // Life time\n\n\n      if (this_1.targetStopDuration && this_1._lifeTimeGradients && this_1._lifeTimeGradients.length > 0) {\n        var ratio_1 = Scalar.Clamp(this_1._actualFrame / this_1.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio_1, this_1._lifeTimeGradients, function (currentGradient, nextGradient) {\n          var factorGradient1 = currentGradient;\n          var factorGradient2 = nextGradient;\n          var lifeTime1 = factorGradient1.getFactor();\n          var lifeTime2 = factorGradient2.getFactor();\n          var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = Scalar.RandomRange(this_1.minLifeTime, this_1.maxLifeTime);\n      } // Emitter\n\n\n      var emitPower = Scalar.RandomRange(this_1.minEmitPower, this_1.maxEmitPower);\n\n      if (this_1.startPositionFunction) {\n        this_1.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);\n      } else {\n        this_1.particleEmitterType.startPositionFunction(this_1._emitterWorldMatrix, particle.position, particle, this_1.isLocal);\n      }\n\n      if (this_1.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this_1._emitterWorldMatrix, particle.position);\n      }\n\n      if (this_1.startDirectionFunction) {\n        this_1.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);\n      } else {\n        this_1.particleEmitterType.startDirectionFunction(this_1._emitterWorldMatrix, particle.direction, particle, this_1.isLocal);\n      }\n\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n\n      particle.direction.scaleInPlace(emitPower); // Size\n\n      if (!this_1._sizeGradients || this_1._sizeGradients.length === 0) {\n        particle.size = Scalar.RandomRange(this_1.minSize, this_1.maxSize);\n      } else {\n        particle._currentSizeGradient = this_1._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n\n        if (this_1._sizeGradients.length > 1) {\n          particle._currentSize2 = this_1._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      } // Size and scale\n\n\n      particle.scale.copyFromFloats(Scalar.RandomRange(this_1.minScaleX, this_1.maxScaleX), Scalar.RandomRange(this_1.minScaleY, this_1.maxScaleY)); // Adjust scale by start size\n\n      if (this_1._startSizeGradients && this_1._startSizeGradients[0] && this_1.targetStopDuration) {\n        var ratio = this_1._actualFrame / this_1.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this_1._startSizeGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentStartSizeGradient) {\n            _this._currentStartSize1 = _this._currentStartSize2;\n            _this._currentStartSize2 = nextGradient.getFactor();\n            _this._currentStartSizeGradient = currentGradient;\n          }\n\n          var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      } // Angle\n\n\n      if (!this_1._angularSpeedGradients || this_1._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = Scalar.RandomRange(this_1.minAngularSpeed, this_1.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this_1._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n\n        if (this_1._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this_1._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n\n      particle.angle = Scalar.RandomRange(this_1.minInitialRotation, this_1.maxInitialRotation); // Velocity\n\n      if (this_1._velocityGradients && this_1._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this_1._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n\n        if (this_1._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this_1._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      } // Limit velocity\n\n\n      if (this_1._limitVelocityGradients && this_1._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this_1._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n\n        if (this_1._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this_1._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      } // Drag\n\n\n      if (this_1._dragGradients && this_1._dragGradients.length > 0) {\n        particle._currentDragGradient = this_1._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n\n        if (this_1._dragGradients.length > 1) {\n          particle._currentDrag2 = this_1._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      } // Color\n\n\n      if (!this_1._colorGradients || this_1._colorGradients.length === 0) {\n        step = Scalar.RandomRange(0, 1.0);\n        Color4.LerpToRef(this_1.color1, this_1.color2, step, particle.color);\n        this_1.colorDead.subtractToRef(particle.color, this_1._colorDiff);\n\n        this_1._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this_1._colorGradients[0];\n\n        particle._currentColorGradient.getColorToRef(particle.color);\n\n        particle._currentColor1.copyFrom(particle.color);\n\n        if (this_1._colorGradients.length > 1) {\n          this_1._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      } // Sheet\n\n\n      if (this_1._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this_1.startSpriteCellID;\n        particle._initialEndSpriteCellID = this_1.endSpriteCellID;\n      } // Inherited Velocity\n\n\n      particle.direction.addInPlace(this_1._inheritedVelocityOffset); // Ramp\n\n      if (this_1._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      } // Noise texture coordinates\n\n\n      if (this_1.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      } // Update the position of the attached sub-emitters to match their attached particle\n\n\n      particle._inheritParticleInfoToSubEmitters();\n    };\n\n    var this_1 = this,\n        step;\n\n    for (var index = 0; index < newParticles; index++) {\n      var state_1 = _loop_2();\n\n      if (state_1 === \"break\") break;\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem._GetAttributeNamesOrOptions = function (isAnimationSheetEnabled, isBillboardBased, useRampGradients) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (isBillboardBased === void 0) {\n      isBillboardBased = false;\n    }\n\n    if (useRampGradients === void 0) {\n      useRampGradients = false;\n    }\n\n    var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n\n    return attributeNamesOrOptions;\n  };\n  /** @hidden */\n\n\n  ParticleSystem._GetEffectCreationOptions = function (isAnimationSheetEnabled) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    var effectCreationOption = [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n\n    return effectCreationOption;\n  };\n  /**\r\n   * Fill the defines array according to the current settings of the particle system\r\n   * @param defines Array to be updated\r\n   * @param blendMode blend mode to take into account when updating the array\r\n   */\n\n\n  ParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\r\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n   * @param uniforms Uniforms array to fill\r\n   * @param attributes Attributes array to fill\r\n   * @param samplers Samplers array to fill\r\n   */\n\n\n  ParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push.apply(attributes, ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED, this._useRampGradients));\n    uniforms.push.apply(uniforms, ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem.prototype._getEffect = function (blendMode) {\n    var customEffect = this.getCustomEffect(blendMode);\n\n    if (customEffect) {\n      return customEffect;\n    }\n\n    var defines = [];\n    this.fillDefines(defines, blendMode); // Effect\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      var attributesNamesOrOptions = [];\n      var effectCreationOption = [];\n      var samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      this._effect = this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join);\n    }\n\n    return this._effect;\n  };\n  /**\r\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n   */\n\n\n  ParticleSystem.prototype.animate = function (preWarmOnly) {\n    var _this = this;\n\n    var _a;\n\n    if (preWarmOnly === void 0) {\n      preWarmOnly = false;\n    }\n\n    if (!this._started) {\n      return;\n    }\n\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n    }\n\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1); // Determine the number of particles we need to create\n\n    var newParticles;\n\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      var rate_1 = this.emitRate;\n\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        var ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, function (currentGradient, nextGradient, scale) {\n          if (currentGradient !== _this._currentEmitRateGradient) {\n            _this._currentEmitRate1 = _this._currentEmitRate2;\n            _this._currentEmitRate2 = nextGradient.getFactor();\n            _this._currentEmitRateGradient = currentGradient;\n          }\n\n          rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);\n        });\n      }\n\n      newParticles = rate_1 * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;\n    }\n\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n\n    this._alive = false;\n\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n\n    this._update(newParticles); // Stopped?\n\n\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n\n    if (!preWarmOnly) {\n      // Update VBO\n      var offset = 0;\n\n      for (var index = 0; index < this._particles.length; index++) {\n        var particle = this._particles[index];\n\n        this._appendParticleVertices(offset, particle);\n\n        offset += this._useInstancing ? 1 : 4;\n      }\n\n      if (this._vertexBuffer) {\n        this._vertexBuffer.update(this._vertexData);\n      }\n    }\n\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  };\n\n  ParticleSystem.prototype._appendParticleVertices = function (offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n\n      this._appendParticleVertex(offset++, particle, 1, 1);\n\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  };\n  /**\r\n   * Rebuilds the particle system.\r\n   */\n\n\n  ParticleSystem.prototype.rebuild = function () {\n    this._createIndexBuffer();\n\n    if (this._vertexBuffer) {\n      this._vertexBuffer._rebuild();\n    }\n\n    for (var key in this._vertexBuffers) {\n      this._vertexBuffers[key]._rebuild();\n    }\n  };\n  /**\r\n   * Is this system ready to be used/rendered\r\n   * @return true if the system is ready\r\n   */\n\n\n  ParticleSystem.prototype.isReady = function () {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getEffect(this.blendMode).isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getEffect(ParticleSystem.BLENDMODE_MULTIPLY).isReady()) {\n        return false;\n      }\n\n      if (!this._getEffect(ParticleSystem.BLENDMODE_ADD).isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ParticleSystem.prototype._render = function (blendMode) {\n    var _a, _b;\n\n    var effect = this._getEffect(blendMode);\n\n    var engine = this._engine; // Render\n\n    engine.enableEffect(effect);\n    var viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      var baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n\n    if (this._isBillboardBased && this._scene) {\n      var camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n\n        this._rampGradientsTexture = null;\n      }\n\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n\n    var defines = effect.defines;\n\n    if (this._scene) {\n      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n        ThinMaterialHelper.BindClipPlane(effect, this._scene);\n      }\n    }\n\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n\n    if (this._vertexArrayObject !== undefined) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n\n      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    } // image processing\n\n\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    } // Draw order\n\n\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n\n      case ParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n\n      case ParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n\n    if (this._useInstancing) {\n      engine.drawArraysType(8, 0, 4, this._particles.length);\n    } else {\n      engine.drawElementsType(0, 0, this._particles.length * 6);\n    }\n\n    return this._particles.length;\n  };\n  /**\r\n   * Renders the particle system in its current state.\r\n   * @returns the current number of particles\r\n   */\n\n\n  ParticleSystem.prototype.render = function () {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n\n    var engine = this._engine;\n\n    if (engine.setState) {\n      engine.setState(false);\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n\n    var outparticles = 0;\n\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n\n    this._engine.unbindInstanceAttributes();\n\n    this._engine.setAlphaMode(0);\n\n    return outparticles;\n  };\n  /**\r\n   * Disposes the particle system and free the associated resources\r\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n   */\n\n\n  ParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n\n      this._vertexBuffer = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n\n      this._vertexArrayObject = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n\n      this._rampGradientsTexture = null;\n    }\n\n    this._removeFromRoot();\n\n    if (this._subEmitters && this._subEmitters.length) {\n      for (var index = 0; index < this._subEmitters.length; index++) {\n        for (var _i = 0, _a = this._subEmitters[index]; _i < _a.length; _i++) {\n          var subEmitter = _a[_i];\n          subEmitter.dispose();\n        }\n      }\n\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    } // Remove from scene\n\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n\n      this._scene._activeParticleSystems.dispose();\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }; // Clone\n\n  /**\r\n   * Clones the particle system.\r\n   * @param name The name of the cloned object\r\n   * @param newEmitter The new emitter to use\r\n   * @returns the cloned particle system\r\n   */\n\n\n  ParticleSystem.prototype.clone = function (name, newEmitter) {\n    var custom = __assign({}, this._customEffect);\n\n    var program = null;\n    var engine = this._engine;\n\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n      }\n    }\n\n    var serialization = this.serialize();\n    var result = ParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\n    result.name = name;\n    result.customShader = program;\n    result._customEffect = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n\n    result.emitter = newEmitter;\n\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n\n    return result;\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  ParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart; // SubEmitters\n\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n\n      for (var _i = 0, _a = this._subEmitters; _i < _a.length; _i++) {\n        var subs = _a[_i];\n        var cell = [];\n\n        for (var _b = 0, subs_1 = subs; _b < subs_1.length; _b++) {\n          var sub = subs_1[_b];\n          cell.push(sub.serialize());\n        }\n\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  ParticleSystem._Serialize = function (serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity(); // Emitter\n\n    if (particleSystem.emitter.position) {\n      var emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      var emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    } // Emitter\n\n\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n\n    serializationObject.isLocal = particleSystem.isLocal; // Animations\n\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop; // Particle system\n\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    var colorGradients = particleSystem.getColorGradients();\n\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n\n      for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {\n        var colorGradient = colorGradients_1[_i];\n        var serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n\n    var rampGradients = particleSystem.getRampGradients();\n\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n\n      for (var _a = 0, rampGradients_1 = rampGradients; _a < rampGradients_1.length; _a++) {\n        var rampGradient = rampGradients_1[_a];\n        var serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n\n    var colorRemapGradients = particleSystem.getColorRemapGradients();\n\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n\n      for (var _b = 0, colorRemapGradients_1 = colorRemapGradients; _b < colorRemapGradients_1.length; _b++) {\n        var colorRemapGradient = colorRemapGradients_1[_b];\n        var serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n\n      for (var _c = 0, alphaRemapGradients_1 = alphaRemapGradients; _c < alphaRemapGradients_1.length; _c++) {\n        var alphaRemapGradient = alphaRemapGradients_1[_c];\n        var serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n\n    var sizeGradients = particleSystem.getSizeGradients();\n\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n\n      for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {\n        var sizeGradient = sizeGradients_1[_d];\n        var serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n\n    var angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n\n      for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {\n        var angularSpeedGradient = angularSpeedGradients_1[_e];\n        var serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n\n    var velocityGradients = particleSystem.getVelocityGradients();\n\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n\n      for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {\n        var velocityGradient = velocityGradients_1[_f];\n        var serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n\n    var dragGradients = particleSystem.getDragGradients();\n\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n\n      for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {\n        var dragGradient = dragGradients_1[_g];\n        var serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n\n    var emitRateGradients = particleSystem.getEmitRateGradients();\n\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n\n      for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {\n        var emitRateGradient = emitRateGradients_1[_h];\n        var serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n\n    var startSizeGradients = particleSystem.getStartSizeGradients();\n\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n\n      for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {\n        var startSizeGradient = startSizeGradients_1[_j];\n        var serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n\n    var lifeTimeGradients = particleSystem.getLifeTimeGradients();\n\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n\n      for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {\n        var lifeTimeGradient = lifeTimeGradients_1[_k];\n        var serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n\n    var limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n\n      for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {\n        var limitVelocityGradient = limitVelocityGradients_1[_l];\n        var serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  };\n  /** @hidden */\n\n\n  ParticleSystem._Parse = function (parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n\n    var internalClass = _TypeStore.GetClass(\"BABYLON.Texture\");\n\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    } // Emitter\n\n\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal; // Misc.\n\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    } // Animations\n\n\n    if (parsedParticleSystem.animations) {\n      for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        var parsedAnimation = parsedParticleSystem.animations[animationIndex];\n\n        var internalClass_1 = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass_1) {\n          particleSystem.animations.push(internalClass_1.Parse(parsedAnimation));\n        }\n      }\n\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    } // Particle system\n\n\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n\n    if (parsedParticleSystem.colorGradients) {\n      for (var _i = 0, _a = parsedParticleSystem.colorGradients; _i < _a.length; _i++) {\n        var colorGradient = _a[_i];\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n\n    if (parsedParticleSystem.rampGradients) {\n      for (var _b = 0, _c = parsedParticleSystem.rampGradients; _b < _c.length; _b++) {\n        var rampGradient = _c[_b];\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (var _d = 0, _e = parsedParticleSystem.colorRemapGradients; _d < _e.length; _d++) {\n        var colorRemapGradient = _e[_d];\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (var _f = 0, _g = parsedParticleSystem.alphaRemapGradients; _f < _g.length; _f++) {\n        var alphaRemapGradient = _g[_f];\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.sizeGradients) {\n      for (var _h = 0, _j = parsedParticleSystem.sizeGradients; _h < _j.length; _h++) {\n        var sizeGradient = _j[_h];\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (var _k = 0, _l = parsedParticleSystem.angularSpeedGradients; _k < _l.length; _k++) {\n        var angularSpeedGradient = _l[_k];\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.velocityGradients) {\n      for (var _m = 0, _o = parsedParticleSystem.velocityGradients; _m < _o.length; _m++) {\n        var velocityGradient = _o[_m];\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.dragGradients) {\n      for (var _p = 0, _q = parsedParticleSystem.dragGradients; _p < _q.length; _p++) {\n        var dragGradient = _q[_p];\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.emitRateGradients) {\n      for (var _r = 0, _s = parsedParticleSystem.emitRateGradients; _r < _s.length; _r++) {\n        var emitRateGradient = _s[_r];\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.startSizeGradients) {\n      for (var _t = 0, _u = parsedParticleSystem.startSizeGradients; _t < _u.length; _t++) {\n        var startSizeGradient = _u[_t];\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (var _v = 0, _w = parsedParticleSystem.lifeTimeGradients; _v < _w.length; _v++) {\n        var lifeTimeGradient = _w[_v];\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (var _x = 0, _y = parsedParticleSystem.limitVelocityGradients; _x < _y.length; _x++) {\n        var limitVelocityGradient = _y[_x];\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n\n    if (parsedParticleSystem.noiseTexture && scene) {\n      var internalClass_2 = _TypeStore.GetClass(\"BABYLON.ProceduralTexture\");\n\n      particleSystem.noiseTexture = internalClass_2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    } // Emitter\n\n\n    var emitterType;\n\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n\n    particleSystem.particleEmitterType = emitterType; // Animation sheet\n\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n  };\n  /**\r\n   * Parses a JSON object to create a particle system.\r\n   * @param parsedParticleSystem The JSON object to parse\r\n   * @param sceneOrEngine The scene or the engine to create the particle system in\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n   * @returns the Parsed particle system\r\n   */\n\n\n  ParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var custom = null;\n    var program = null;\n    var engine;\n    var scene;\n\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n\n    var particleSystem = new ParticleSystem(name, parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    } // SubEmitters\n\n\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n\n      for (var _i = 0, _a = parsedParticleSystem.subEmitters; _i < _a.length; _i++) {\n        var cell = _a[_i];\n        var cellArray = [];\n\n        for (var _b = 0, cell_1 = cell; _b < cell_1.length; _b++) {\n          var sub = cell_1[_b];\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    } // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n  /**\r\n   * Billboard mode will only apply to Y axis\r\n   */\n\n\n  ParticleSystem.BILLBOARDMODE_Y = 2;\n  /**\r\n   * Billboard mode will apply to all axes\r\n   */\n\n  ParticleSystem.BILLBOARDMODE_ALL = 7;\n  /**\r\n   * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n   */\n\n  ParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n  return ParticleSystem;\n}(BaseParticleSystem);\n\nexport { ParticleSystem };\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;","map":{"version":3,"sources":["../../../sourceES6/core/Particles/particleSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\nimport { Observable, Observer } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Buffer } from \"../Meshes/buffer\";\nimport { Effect } from \"../Materials/effect\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { IDisposable } from \"../scene\";\nimport { BoxParticleEmitter, IParticleEmitterType, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index\";\nimport { IParticleSystem } from \"./IParticleSystem\";\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\nimport { Particle } from \"./particle\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\n\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { IAnimatable } from '../Animations/animatable.interface';\n\nimport \"../Shaders/particles.fragment\";\nimport \"../Shaders/particles.vertex\";\nimport { DataBuffer } from '../Meshes/dataBuffer';\nimport { Color4, Color3, TmpColors } from '../Maths/math.color';\nimport { ISize } from '../Maths/math.size';\nimport { BaseTexture } from '../Materials/Textures/baseTexture';\nimport { ThinEngine } from '../Engines/thinEngine';\nimport { ThinMaterialHelper } from '../Materials/thinMaterialHelper';\n\nimport \"../Engines/Extensions/engine.alpha\";\n\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\ndeclare type ProceduralTexture = import(\"../Materials/Textures/Procedurals/proceduralTexture\").ProceduralTexture;\ndeclare type Scene = import(\"../scene\").Scene;\n\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/babylon101/particles\n */\nexport class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {\n\n    /**\n     * Billboard mode will only apply to Y axis\n     */\n    public static readonly BILLBOARDMODE_Y = 2;\n    /**\n     * Billboard mode will apply to all axes\n     */\n    public static readonly BILLBOARDMODE_ALL = 7;\n    /**\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n     */\n    public static readonly BILLBOARDMODE_STRETCHED = 8;\n\n    /**\n     * This function can be defined to provide custom update for active particles.\n     * This function will be called instead of regular update (age, position, color, etc.).\n     * Do not forget that this function will be called on every frame so try to keep it simple and fast :)\n     */\n    public updateFunction: (particles: Particle[]) => void;\n\n    private _emitterWorldMatrix: Matrix;\n\n    /**\n     * This function can be defined to specify initial direction for every new particle.\n     * It by default use the emitterType defined function\n     */\n    public startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\n    /**\n     * This function can be defined to specify initial position for every new particle.\n     * It by default use the emitterType defined function\n     */\n    public startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\n\n    /**\n     * @hidden\n     */\n    public _inheritedVelocityOffset = new Vector3();\n    /**\n    * An event triggered when the system is disposed\n    */\n    public onDisposeObservable = new Observable<IParticleSystem>();\n    /**\n    * An event triggered when the system is stopped\n    */\n    public onStoppedObservable = new Observable<IParticleSystem>();\n\n    private _onDisposeObserver: Nullable<Observer<IParticleSystem>>;\n    /**\n     * Sets a callback that will be triggered when the system is disposed\n     */\n    public set onDispose(callback: () => void) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n\n    private _particles = new Array<Particle>();\n    private _epsilon: number;\n    private _capacity: number;\n    private _stockParticles = new Array<Particle>();\n    private _newPartsExcess = 0;\n    private _vertexData: Float32Array;\n    private _vertexBuffer: Nullable<Buffer>;\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\n    private _spriteBuffer: Nullable<Buffer>;\n    private _indexBuffer: Nullable<DataBuffer>;\n    private _effect: Effect;\n    private _customEffect: { [blendMode: number] : Nullable<Effect> };\n    private _cachedDefines: string;\n    private _scaledColorStep = new Color4(0, 0, 0, 0);\n    private _colorDiff = new Color4(0, 0, 0, 0);\n    private _scaledDirection = Vector3.Zero();\n    private _scaledGravity = Vector3.Zero();\n    private _currentRenderId = -1;\n    private _alive: boolean;\n    private _useInstancing = false;\n    private _vertexArrayObject: Nullable<WebGLVertexArrayObject>;\n\n    private _started = false;\n    private _stopped = false;\n    private _actualFrame = 0;\n    private _scaledUpdateSpeed: number;\n    private _vertexBufferSize: number;\n\n    /** @hidden */\n    public _currentEmitRateGradient: Nullable<FactorGradient>;\n    /** @hidden */\n    public _currentEmitRate1 = 0;\n    /** @hidden */\n    public _currentEmitRate2 = 0;\n\n    /** @hidden */\n    public _currentStartSizeGradient: Nullable<FactorGradient>;\n    /** @hidden */\n    public _currentStartSize1 = 0;\n    /** @hidden */\n    public _currentStartSize2 = 0;\n\n    private readonly _rawTextureWidth = 256;\n    private _rampGradientsTexture: Nullable<RawTexture>;\n    private _useRampGradients = false;\n\n    /** Gets or sets a matrix to use to compute projection */\n    public defaultProjectionMatrix: Matrix;\n\n    /** Gets or sets a matrix to use to compute view */\n    public defaultViewMatrix: Matrix;\n\n    /** Gets or sets a boolean indicating that ramp gradients must be used\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\n     */\n    public get useRampGradients(): boolean {\n        return this._useRampGradients;\n    }\n\n    public set useRampGradients(value: boolean) {\n        if (this._useRampGradients === value) {\n            return;\n        }\n\n        this._useRampGradients = value;\n\n        this._resetEffect();\n    }\n\n    // Sub-emitters\n    /**\n     * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.\n     * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])\n     */\n    public subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;\n    // the subEmitters field above converted to a constant type\n    private _subEmitters: Array<Array<SubEmitter>>;\n    /**\n     * @hidden\n     * If the particle systems emitter should be disposed when the particle system is disposed\n     */\n    public _disposeEmitterOnDispose = false;\n    /**\n    * The current active Sub-systems, this property is used by the root particle system only.\n    */\n    public activeSubSystems: Array<ParticleSystem>;\n\n    /**\n     * Specifies if the particles are updated in emitter local space or world space\n     */\n    public isLocal = false;\n\n    private _rootParticleSystem: Nullable<ParticleSystem>;\n    //end of Sub-emitter\n\n    /**\n     * Gets the current list of active particles\n     */\n    public get particles(): Particle[] {\n        return this._particles;\n    }\n\n    /**\n     * Gets the number of particles active at the same time.\n     * @returns The number of active particles.\n     */\n    public getActiveCount() {\n        return this._particles.length;\n    }\n\n    /**\n     * Returns the string \"ParticleSystem\"\n     * @returns a string containing the class name\n     */\n    public getClassName(): string {\n        return \"ParticleSystem\";\n    }\n\n    /**\n     * Gets a boolean indicating that the system is stopping\n     * @returns true if the system is currently stopping\n     */\n    public isStopping() {\n        return this._stopped && this.isAlive();\n    }\n\n    /**\n     * Gets the custom effect used to render the particles\n     * @param blendMode Blend mode for which the effect should be retrieved\n     * @returns The effect\n     */\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\n        return this._customEffect[blendMode] ?? this._customEffect[0];\n    }\n\n    /**\n     * Sets the custom effect used to render the particles\n     * @param effect The effect to set\n     * @param blendMode Blend mode for which the effect should be set\n     */\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\n        this._customEffect[blendMode] = effect;\n    }\n\n    /** @hidden */\n    private _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\n\n    /**\n     * Observable that will be called just before the particles are drawn\n     */\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\n        if (!this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\n        }\n\n        return this._onBeforeDrawParticlesObservable;\n    }\n\n    /**\n     * Gets the name of the particle vertex shader\n     */\n    public get vertexShaderName(): string {\n        return \"particles\";\n    }\n\n    /**\n     * Instantiates a particle system.\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n     * @param name The name of the particle system\n     * @param capacity The max number of particles alive at the same time\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n     * @param customEffect a custom effect used to change the way particles are rendered by default\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n     * @param epsilon Offset used to render the particles\n     */\n    constructor(name: string, capacity: number, sceneOrEngine: Scene | ThinEngine, customEffect: Nullable<Effect> = null, isAnimationSheetEnabled: boolean = false, epsilon: number = 0.01) {\n        super(name);\n\n        this._capacity = capacity;\n\n        this._epsilon = epsilon;\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\n            this._engine = this._scene.getEngine();\n            this.uniqueId = this._scene.getUniqueId();\n            this._scene.particleSystems.push(this);\n        } else {\n            this._engine = (sceneOrEngine as ThinEngine);\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\n        }\n\n        if (this._engine.getCaps().vertexArrayObject) {\n            this._vertexArrayObject = null;\n        }\n\n        // Setup the default processing configuration to the scene.\n        this._attachImageProcessingConfiguration(null);\n\n        this._customEffect = { 0: customEffect };\n\n        this._useInstancing = this._engine.getCaps().instancedArrays;\n\n        this._createIndexBuffer();\n        this._createVertexBuffers();\n\n        // Default emitter type\n        this.particleEmitterType = new BoxParticleEmitter();\n\n        // Update\n        this.updateFunction = (particles: Particle[]): void => {\n            let noiseTextureSize: Nullable<ISize> = null;\n            let noiseTextureData: Nullable<Uint8Array> = null;\n\n            if (this.noiseTexture) { // We need to get texture data back to CPU\n                noiseTextureSize = this.noiseTexture.getSize();\n                noiseTextureData = <Nullable<Uint8Array>>(this.noiseTexture.getContent());\n            }\n\n            for (var index = 0; index < particles.length; index++) {\n                var particle = particles[index];\n\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\n                let previousAge = particle.age;\n                particle.age += scaledUpdateSpeed;\n\n                // Evaluate step to death\n                if (particle.age > particle.lifeTime) {\n                    let diff = particle.age - previousAge;\n                    let oldDiff = particle.lifeTime - previousAge;\n\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\n\n                    particle.age = particle.lifeTime;\n                }\n\n                let ratio = particle.age / particle.lifeTime;\n\n                // Color\n                if (this._colorGradients && this._colorGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentColorGradient) {\n                            particle._currentColor1.copyFrom(particle._currentColor2);\n                            (<ColorGradient>nextGradient).getColorToRef(particle._currentColor2);\n                            particle._currentColorGradient = (<ColorGradient>currentGradient);\n                        }\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n                    });\n                }\n                else {\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\n                    particle.color.addInPlace(this._scaledColorStep);\n\n                    if (particle.color.a < 0) {\n                        particle.color.a = 0;\n                    }\n                }\n\n                // Angular speed\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n                            particle._currentAngularSpeed2 = (<FactorGradient>nextGradient).getFactor();\n                            particle._currentAngularSpeedGradient = (<FactorGradient>currentGradient);\n                        }\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n                    });\n                }\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\n\n                // Direction\n                let directionScale = scaledUpdateSpeed;\n\n                /// Velocity\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentVelocityGradient) {\n                            particle._currentVelocity1 = particle._currentVelocity2;\n                            particle._currentVelocity2 = (<FactorGradient>nextGradient).getFactor();\n                            particle._currentVelocityGradient = (<FactorGradient>currentGradient);\n                        }\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n                    });\n                }\n\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\n\n                /// Limit velocity\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n                            particle._currentLimitVelocity2 = (<FactorGradient>nextGradient).getFactor();\n                            particle._currentLimitVelocityGradient = (<FactorGradient>currentGradient);\n                        }\n\n                        let limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n                        let currentVelocity = particle.direction.length();\n\n                        if (currentVelocity > limitVelocity) {\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\n                        }\n                    });\n                }\n\n                /// Drag\n                if (this._dragGradients && this._dragGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentDragGradient) {\n                            particle._currentDrag1 = particle._currentDrag2;\n                            particle._currentDrag2 = (<FactorGradient>nextGradient).getFactor();\n                            particle._currentDragGradient = (<FactorGradient>currentGradient);\n                        }\n\n                        let drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\n                    });\n                }\n\n                if (this.isLocal && particle._localPosition) {\n                    particle._localPosition!.addInPlace(this._scaledDirection);\n                    Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\n                } else {\n                    particle.position.addInPlace(this._scaledDirection);\n                }\n\n                // Noise\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n                    let fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n                    let fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n                    let fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n\n                    let force = TmpVectors.Vector3[0];\n                    let scaledForce = TmpVectors.Vector3[1];\n\n                    force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);\n\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\n                    particle.direction.addInPlace(scaledForce);\n                }\n\n                // Gravity\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\n                particle.direction.addInPlace(this._scaledGravity);\n\n                // Size\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\n                        if (currentGradient !== particle._currentSizeGradient) {\n                            particle._currentSize1 = particle._currentSize2;\n                            particle._currentSize2 = (<FactorGradient>nextGradient).getFactor();\n                            particle._currentSizeGradient = (<FactorGradient>currentGradient);\n                        }\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n                    });\n                }\n\n                // Remap data\n                if (this._useRampGradients) {\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\n                            let min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\n                            let max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\n\n                            particle.remapData.x = min;\n                            particle.remapData.y = max - min;\n                        });\n                    }\n\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\n                            let min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\n                            let max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\n\n                            particle.remapData.z = min;\n                            particle.remapData.w = max - min;\n                        });\n                    }\n                }\n\n                if (this._isAnimationSheetEnabled) {\n                    particle.updateCellIndex();\n                }\n\n                // Update the position of the attached sub-emitters to match their attached particle\n                particle._inheritParticleInfoToSubEmitters();\n\n                if (particle.age >= particle.lifeTime) { // Recycle by swapping with last particle\n                    this._emitFromParticle(particle);\n                    if (particle._attachedSubEmitters) {\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\n                            subEmitter.particleSystem.disposeOnStop = true;\n                            subEmitter.particleSystem.stop();\n                        });\n                        particle._attachedSubEmitters = null;\n                    }\n                    this.recycleParticle(particle);\n                    index--;\n                    continue;\n                }\n            }\n        };\n    }\n\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number, factor2?: number) {\n        let newGradient = new FactorGradient(gradient, factor, factor2);\n        factorGradients.push(newGradient);\n\n        factorGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            } else if (a.gradient > b.gradient) {\n                return 1;\n            }\n\n            return 0;\n        });\n    }\n\n    private _removeFactorGradient(factorGradients: Nullable<FactorGradient[]>, gradient: number) {\n        if (!factorGradients) {\n            return;\n        }\n\n        let index = 0;\n        for (var factorGradient of factorGradients) {\n            if (factorGradient.gradient === gradient) {\n                factorGradients.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n    }\n\n    /**\n     * Adds a new life time gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the life time factor to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._lifeTimeGradients) {\n            this._lifeTimeGradients = [];\n        }\n\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific life time gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new size gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the size factor to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._sizeGradients) {\n            this._sizeGradients = [];\n        }\n\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific size gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeSizeGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._sizeGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new color remap gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param min defines the color remap minimal range\n     * @param max defines the color remap maximal range\n     * @returns the current particle system\n     */\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\n        if (!this._colorRemapGradients) {\n            this._colorRemapGradients = [];\n        }\n\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific color remap gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeColorRemapGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new alpha remap gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param min defines the alpha remap minimal range\n     * @param max defines the alpha remap maximal range\n     * @returns the current particle system\n     */\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\n        if (!this._alphaRemapGradients) {\n            this._alphaRemapGradients = [];\n        }\n\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific alpha remap gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeAlphaRemapGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new angular speed gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the angular speed  to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._angularSpeedGradients) {\n            this._angularSpeedGradients = [];\n        }\n\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific angular speed gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeAngularSpeedGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the velocity to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._velocityGradients) {\n            this._velocityGradients = [];\n        }\n\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeVelocityGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._velocityGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new limit velocity gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the limit velocity value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._limitVelocityGradients) {\n            this._limitVelocityGradients = [];\n        }\n\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific limit velocity gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeLimitVelocityGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new drag gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the drag value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._dragGradients) {\n            this._dragGradients = [];\n        }\n\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n\n        return this;\n    }\n\n    /**\n     * Remove a specific drag gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeDragGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._dragGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the emit rate value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._emitRateGradients) {\n            this._emitRateGradients = [];\n        }\n\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n        return this;\n    }\n\n    /**\n     * Remove a specific emit rate gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._emitRateGradients, gradient);\n\n        return this;\n    }\n\n    /**\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param factor defines the start size value to affect to the specified gradient\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n     * @returns the current particle system\n     */\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\n        if (!this._startSizeGradients) {\n            this._startSizeGradients = [];\n        }\n\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n        return this;\n    }\n\n    /**\n     * Remove a specific start size gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\n        this._removeFactorGradient(this._startSizeGradients, gradient);\n\n        return this;\n    }\n\n    private _createRampGradientTexture() {\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n            return;\n        }\n\n        let data = new Uint8Array(this._rawTextureWidth * 4);\n        let tmpColor = TmpColors.Color3[0];\n\n        for (var x = 0; x < this._rawTextureWidth; x++) {\n            var ratio = x / this._rawTextureWidth;\n\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\n\n                Color3.LerpToRef((<Color3Gradient>currentGradient).color, (<Color3Gradient>nextGradient).color, scale, tmpColor);\n                data[x * 4] = tmpColor.r * 255;\n                data[x * 4 + 1] = tmpColor.g * 255;\n                data[x * 4 + 2] = tmpColor.b * 255;\n                data[x * 4 + 3] = 255;\n            });\n\n        }\n\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n    }\n\n    /**\n     * Gets the current list of ramp gradients.\n     * You must use addRampGradient and removeRampGradient to udpate this list\n     * @returns the list of ramp gradients\n     */\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\n        return this._rampGradients;\n    }\n\n    /** Force the system to rebuild all gradients that need to be resync */\n    public forceRefreshGradients() {\n        this._syncRampGradientTexture();\n    }\n\n    private _syncRampGradientTexture() {\n        if (!this._rampGradients) {\n            return;\n        }\n\n        this._rampGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            } else if (a.gradient > b.gradient) {\n                return 1;\n            }\n\n            return 0;\n        });\n\n        if (this._rampGradientsTexture) {\n            this._rampGradientsTexture.dispose();\n            this._rampGradientsTexture = null;\n        }\n\n        this._createRampGradientTexture();\n    }\n\n    /**\n     * Adds a new ramp gradient used to remap particle colors\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param color defines the color to affect to the specified gradient\n     * @returns the current particle system\n     */\n    public addRampGradient(gradient: number, color: Color3): ParticleSystem {\n        if (!this._rampGradients) {\n            this._rampGradients = [];\n        }\n\n        let rampGradient = new Color3Gradient(gradient, color);\n        this._rampGradients.push(rampGradient);\n\n        this._syncRampGradientTexture();\n\n        return this;\n    }\n\n    /**\n     * Remove a specific ramp gradient\n     * @param gradient defines the gradient to remove\n     * @returns the current particle system\n     */\n    public removeRampGradient(gradient: number): ParticleSystem {\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n        this._rampGradientsTexture = null;\n\n        if (this._rampGradients && this._rampGradients.length > 0) {\n            this._createRampGradientTexture();\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a new color gradient\n     * @param gradient defines the gradient to use (between 0 and 1)\n     * @param color1 defines the color to affect to the specified gradient\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n     * @returns this particle system\n     */\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem {\n        if (!this._colorGradients) {\n            this._colorGradients = [];\n        }\n\n        let colorGradient = new ColorGradient(gradient, color1, color2);\n        this._colorGradients.push(colorGradient);\n\n        this._colorGradients.sort((a, b) => {\n            if (a.gradient < b.gradient) {\n                return -1;\n            } else if (a.gradient > b.gradient) {\n                return 1;\n            }\n\n            return 0;\n        });\n\n        return this;\n    }\n\n    /**\n     * Remove a specific color gradient\n     * @param gradient defines the gradient to remove\n     * @returns this particle system\n     */\n    public removeColorGradient(gradient: number): IParticleSystem {\n        if (!this._colorGradients) {\n            return this;\n        }\n\n        let index = 0;\n        for (var colorGradient of this._colorGradients) {\n            if (colorGradient.gradient === gradient) {\n                this._colorGradients.splice(index, 1);\n                break;\n            }\n            index++;\n        }\n\n        return this;\n    }\n\n    private _fetchR(u: number, v: number, width: number, height: number, pixels: Uint8Array): number {\n        u = Math.abs(u) * 0.5 + 0.5;\n        v = Math.abs(v) * 0.5 + 0.5;\n\n        let wrappedU = ((u * width) % width) | 0;\n        let wrappedV = ((v * height) % height) | 0;\n\n        let position = (wrappedU + wrappedV * width) * 4;\n        return pixels[position] / 255;\n    }\n\n    protected _reset() {\n        this._resetEffect();\n    }\n\n    private _resetEffect() {\n        if (this._vertexBuffer) {\n            this._vertexBuffer.dispose();\n            this._vertexBuffer = null;\n        }\n\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n\n        if (this._vertexArrayObject) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n            this._vertexArrayObject = null;\n        }\n\n        this._createVertexBuffers();\n    }\n\n    private _createVertexBuffers() {\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\n        if (this._isAnimationSheetEnabled) {\n            this._vertexBufferSize += 1;\n        }\n\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n            this._vertexBufferSize += 3;\n        }\n\n        if (this._useRampGradients) {\n            this._vertexBufferSize += 4;\n        }\n\n        let engine = this._engine;\n        this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n\n        let dataOffset = 0;\n        var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n        dataOffset += 3;\n\n        var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n        dataOffset += 4;\n\n        var options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[\"angle\"] = options;\n        dataOffset += 1;\n\n        var size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[\"size\"] = size;\n        dataOffset += 2;\n\n        if (this._isAnimationSheetEnabled) {\n            var cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n            dataOffset += 1;\n        }\n\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n            var directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"direction\"] = directionBuffer;\n            dataOffset += 3;\n        }\n\n        if (this._useRampGradients) {\n            var rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n            dataOffset += 4;\n        }\n\n        var offsets: VertexBuffer;\n        if (this._useInstancing) {\n            var spriteData = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n        } else {\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n            dataOffset += 2;\n        }\n        this._vertexBuffers[\"offset\"] = offsets;\n\n    }\n\n    private _createIndexBuffer() {\n        if (this._useInstancing) {\n            return;\n        }\n        var indices = [];\n        var index = 0;\n        for (var count = 0; count < this._capacity; count++) {\n            indices.push(index);\n            indices.push(index + 1);\n            indices.push(index + 2);\n            indices.push(index);\n            indices.push(index + 2);\n            indices.push(index + 3);\n            index += 4;\n        }\n\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\n    }\n\n    /**\n     * Gets the maximum number of particles active at the same time.\n     * @returns The max number of active particles.\n     */\n    public getCapacity(): number {\n        return this._capacity;\n    }\n\n    /**\n     * Gets whether there are still active particles in the system.\n     * @returns True if it is alive, otherwise false.\n     */\n    public isAlive(): boolean {\n        return this._alive;\n    }\n\n    /**\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\n     * @returns True if it has been started, otherwise false.\n     */\n    public isStarted(): boolean {\n        return this._started;\n    }\n\n    private _prepareSubEmitterInternalArray() {\n        this._subEmitters = new Array<Array<SubEmitter>>();\n        if (this.subEmitters) {\n            this.subEmitters.forEach((subEmitter) => {\n                if (subEmitter instanceof ParticleSystem) {\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\n                } else if (subEmitter instanceof SubEmitter) {\n                    this._subEmitters.push([subEmitter]);\n                } else if (subEmitter instanceof Array) {\n                    this._subEmitters.push(subEmitter);\n                }\n            });\n        }\n    }\n\n    /**\n     * Starts the particle system and begins to emit\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n     */\n    public start(delay = this.startDelay): void {\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n        }\n        if (delay) {\n            setTimeout(() => {\n                this.start(0);\n            }, delay);\n            return;\n        }\n        // Convert the subEmitters field to the constant type field _subEmitters\n        this._prepareSubEmitterInternalArray();\n\n        this._started = true;\n        this._stopped = false;\n        this._actualFrame = 0;\n        if (this._subEmitters && this._subEmitters.length != 0) {\n            this.activeSubSystems = new Array<ParticleSystem>();\n        }\n\n        // Reset emit gradient so it acts the same on every start\n        if (this._emitRateGradients) {\n            if (this._emitRateGradients.length > 0) {\n                this._currentEmitRateGradient = this._emitRateGradients[0];\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n                this._currentEmitRate2 = this._currentEmitRate1;\n            }\n            if (this._emitRateGradients.length > 1) {\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n            }\n        }\n        // Reset start size gradient so it acts the same on every start\n        if (this._startSizeGradients) {\n            if (this._startSizeGradients.length > 0) {\n                this._currentStartSizeGradient = this._startSizeGradients[0];\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n                this._currentStartSize2 = this._currentStartSize1;\n            }\n            if (this._startSizeGradients.length > 1) {\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n            }\n        }\n\n        if (this.preWarmCycles) {\n            if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\n                (this.emitter as any).computeWorldMatrix(true);\n            }\n\n            let noiseTextureAsProcedural = this.noiseTexture as ProceduralTexture;\n\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\n                    setTimeout(() => {\n                        for (var index = 0; index < this.preWarmCycles; index++) {\n                            this.animate(true);\n                            noiseTextureAsProcedural.render();\n                        }\n                    });\n                });\n            } else {\n                for (var index = 0; index < this.preWarmCycles; index++) {\n                    this.animate(true);\n                }\n            }\n        }\n\n        // Animations\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n        }\n    }\n\n    /**\n     * Stops the particle system.\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\n     */\n    public stop(stopSubEmitters = true): void {\n        if (this._stopped) {\n            return;\n        }\n\n        this.onStoppedObservable.notifyObservers(this);\n\n        this._stopped = true;\n\n        if (stopSubEmitters) {\n            this._stopSubEmitters();\n        }\n    }\n\n    // animation sheet\n\n    /**\n     * Remove all active particles\n     */\n    public reset(): void {\n        this._stockParticles = [];\n        this._particles = [];\n    }\n\n    /**\n     * @hidden (for internal use only)\n     */\n    public _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void {\n        var offset = index * this._vertexBufferSize;\n\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n        this._vertexData[offset++] = particle.color.r;\n        this._vertexData[offset++] = particle.color.g;\n        this._vertexData[offset++] = particle.color.b;\n        this._vertexData[offset++] = particle.color.a;\n        this._vertexData[offset++] = particle.angle;\n\n        this._vertexData[offset++] = particle.scale.x * particle.size;\n        this._vertexData[offset++] = particle.scale.y * particle.size;\n\n        if (this._isAnimationSheetEnabled) {\n            this._vertexData[offset++] = particle.cellIndex;\n        }\n\n        if (!this._isBillboardBased) {\n            if (particle._initialDirection) {\n                let initialDirection = particle._initialDirection;\n                if (this.isLocal) {\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n                    initialDirection = TmpVectors.Vector3[0];\n                }\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\n                    initialDirection.x = 0.001;\n                }\n\n                this._vertexData[offset++] = initialDirection.x;\n                this._vertexData[offset++] = initialDirection.y;\n                this._vertexData[offset++] = initialDirection.z;\n            } else {\n                let direction = particle.direction;\n                if (this.isLocal) {\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n                    direction = TmpVectors.Vector3[0];\n                }\n\n                if (direction.x === 0 && direction.z === 0) {\n                    direction.x = 0.001;\n                }\n                this._vertexData[offset++] = direction.x;\n                this._vertexData[offset++] = direction.y;\n                this._vertexData[offset++] = direction.z;\n\n            }\n        } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n            this._vertexData[offset++] = particle.direction.x;\n            this._vertexData[offset++] = particle.direction.y;\n            this._vertexData[offset++] = particle.direction.z;\n        }\n\n        if (this._useRampGradients && particle.remapData) {\n            this._vertexData[offset++] = particle.remapData.x;\n            this._vertexData[offset++] = particle.remapData.y;\n            this._vertexData[offset++] = particle.remapData.z;\n            this._vertexData[offset++] = particle.remapData.w;\n        }\n\n        if (!this._useInstancing) {\n            if (this._isAnimationSheetEnabled) {\n                if (offsetX === 0) {\n                    offsetX = this._epsilon;\n                }\n                else if (offsetX === 1) {\n                    offsetX = 1 - this._epsilon;\n                }\n\n                if (offsetY === 0) {\n                    offsetY = this._epsilon;\n                }\n                else if (offsetY === 1) {\n                    offsetY = 1 - this._epsilon;\n                }\n            }\n\n            this._vertexData[offset++] = offsetX;\n            this._vertexData[offset++] = offsetY;\n        }\n    }\n\n    // start of sub system methods\n\n    /**\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n     * Its lifetime will start back at 0.\n     */\n    public recycleParticle: (particle: Particle) => void = (particle) => {\n        // move particle from activeParticle list to stock particles\n        var lastParticle = <Particle>this._particles.pop();\n        if (lastParticle !== particle) {\n            lastParticle.copyTo(particle);\n        }\n        this._stockParticles.push(lastParticle);\n    }\n\n    private _stopSubEmitters(): void {\n        if (!this.activeSubSystems) {\n            return;\n        }\n        this.activeSubSystems.forEach((subSystem) => {\n            subSystem.stop(true);\n        });\n        this.activeSubSystems = new Array<ParticleSystem>();\n    }\n\n    private _createParticle: () => Particle = () => {\n        var particle: Particle;\n        if (this._stockParticles.length !== 0) {\n            particle = <Particle>this._stockParticles.pop();\n            particle._reset();\n        } else {\n            particle = new Particle(this);\n        }\n\n        // Attach emitters\n        if (this._subEmitters && this._subEmitters.length > 0) {\n            var subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\n            particle._attachedSubEmitters = [];\n            subEmitters.forEach((subEmitter) => {\n                if (subEmitter.type === SubEmitterType.ATTACHED) {\n                    var newEmitter = subEmitter.clone();\n                    (<Array<SubEmitter>>particle._attachedSubEmitters).push(newEmitter);\n                    newEmitter.particleSystem.start();\n                }\n            });\n        }\n        return particle;\n    }\n\n    private _removeFromRoot(): void {\n        if (!this._rootParticleSystem) {\n            return;\n        }\n\n        let index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n        if (index !== -1) {\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\n        }\n\n        this._rootParticleSystem = null;\n    }\n\n    private _emitFromParticle: (particle: Particle) => void = (particle) => {\n        if (!this._subEmitters || this._subEmitters.length === 0) {\n            return;\n        }\n        var templateIndex = Math.floor(Math.random() * this._subEmitters.length);\n\n        this._subEmitters[templateIndex].forEach((subEmitter) => {\n            if (subEmitter.type === SubEmitterType.END) {\n                var subSystem = subEmitter.clone();\n                particle._inheritParticleInfoToSubEmitter(subSystem);\n                subSystem.particleSystem._rootParticleSystem = this;\n                this.activeSubSystems.push(subSystem.particleSystem);\n                subSystem.particleSystem.start();\n            }\n        });\n    }\n\n    // End of sub system methods\n\n    private _update(newParticles: number): void {\n        // Update current\n        this._alive = this._particles.length > 0;\n\n        if ((<AbstractMesh>this.emitter).position) {\n            var emitterMesh = (<AbstractMesh>this.emitter);\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n\n        } else {\n            var emitterPosition = (<Vector3>this.emitter);\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n        }\n\n        this.updateFunction(this._particles);\n\n        // Add new ones\n        var particle: Particle;\n        for (var index = 0; index < newParticles; index++) {\n            if (this._particles.length === this._capacity) {\n                break;\n            }\n\n            particle = this._createParticle();\n\n            this._particles.push(particle);\n\n            // Life time\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\n                let ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\n                    let factorGradient1 = (<FactorGradient>currentGradient);\n                    let factorGradient2 = (<FactorGradient>nextGradient);\n                    let lifeTime1 = factorGradient1.getFactor();\n                    let lifeTime2 = factorGradient2.getFactor();\n                    let gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n                });\n            } else {\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\n            }\n\n            // Emitter\n            let emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\n\n            if (this.startPositionFunction) {\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n            }\n            else {\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n            }\n\n            if (this.isLocal) {\n                if (!particle._localPosition) {\n                    particle._localPosition = particle.position.clone();\n                } else {\n                    particle._localPosition.copyFrom(particle.position);\n                }\n                Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\n            }\n\n            if (this.startDirectionFunction) {\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n            }\n            else {\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n            }\n\n            if (emitPower === 0) {\n                if (!particle._initialDirection) {\n                    particle._initialDirection = particle.direction.clone();\n                } else {\n                    particle._initialDirection.copyFrom(particle.direction);\n                }\n            } else {\n                particle._initialDirection = null;\n            }\n\n            particle.direction.scaleInPlace(emitPower);\n\n            // Size\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\n            } else {\n                particle._currentSizeGradient = this._sizeGradients[0];\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\n                particle.size = particle._currentSize1;\n\n                if (this._sizeGradients.length > 1) {\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\n                } else {\n                    particle._currentSize2 = particle._currentSize1;\n                }\n            }\n            // Size and scale\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\n\n            // Adjust scale by start size\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\n                const ratio = this._actualFrame / this.targetStopDuration;\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\n                    if (currentGradient !== this._currentStartSizeGradient) {\n                        this._currentStartSize1 = this._currentStartSize2;\n                        this._currentStartSize2 = (<FactorGradient>nextGradient).getFactor();\n                        this._currentStartSizeGradient = (<FactorGradient>currentGradient);\n                    }\n\n                    var value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\n                    particle.scale.scaleInPlace(value);\n                });\n            }\n\n            // Angle\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\n            } else {\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n                particle._currentAngularSpeed1 = particle.angularSpeed;\n\n                if (this._angularSpeedGradients.length > 1) {\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\n                } else {\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n                }\n            }\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\n\n            // Velocity\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\n                particle._currentVelocityGradient = this._velocityGradients[0];\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n\n                if (this._velocityGradients.length > 1) {\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\n                } else {\n                    particle._currentVelocity2 = particle._currentVelocity1;\n                }\n            }\n\n            // Limit velocity\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n\n                if (this._limitVelocityGradients.length > 1) {\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\n                } else {\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n                }\n            }\n\n            // Drag\n            if (this._dragGradients && this._dragGradients.length > 0) {\n                particle._currentDragGradient = this._dragGradients[0];\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\n\n                if (this._dragGradients.length > 1) {\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\n                } else {\n                    particle._currentDrag2 = particle._currentDrag1;\n                }\n            }\n\n            // Color\n            if (!this._colorGradients || this._colorGradients.length === 0) {\n                var step = Scalar.RandomRange(0, 1.0);\n\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n            } else {\n                particle._currentColorGradient = this._colorGradients[0];\n                particle._currentColorGradient.getColorToRef(particle.color);\n                particle._currentColor1.copyFrom(particle.color);\n\n                if (this._colorGradients.length > 1) {\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\n                } else {\n                    particle._currentColor2.copyFrom(particle.color);\n                }\n            }\n\n            // Sheet\n            if (this._isAnimationSheetEnabled) {\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\n            }\n\n            // Inherited Velocity\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\n\n            // Ramp\n            if (this._useRampGradients) {\n                particle.remapData = new Vector4(0, 1, 0, 1);\n            }\n\n            // Noise texture coordinates\n            if (this.noiseTexture) {\n                if (particle._randomNoiseCoordinates1) {\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n                } else {\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n                }\n            }\n\n            // Update the position of the attached sub-emitters to match their attached particle\n            particle._inheritParticleInfoToSubEmitters();\n\n        }\n    }\n\n    /** @hidden */\n    public static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false): string[] {\n        var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n\n        if (isAnimationSheetEnabled) {\n            attributeNamesOrOptions.push(\"cellIndex\");\n        }\n\n        if (!isBillboardBased) {\n            attributeNamesOrOptions.push(\"direction\");\n        }\n\n        if (useRampGradients) {\n            attributeNamesOrOptions.push(\"remapData\");\n        }\n\n        return attributeNamesOrOptions;\n    }\n\n    /** @hidden */\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false): string[] {\n        var effectCreationOption = [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n\n        if (isAnimationSheetEnabled) {\n            effectCreationOption.push(\"particlesInfos\");\n        }\n\n        return effectCreationOption;\n    }\n\n    /**\n     * Fill the defines array according to the current settings of the particle system\n     * @param defines Array to be updated\n     * @param blendMode blend mode to take into account when updating the array\n     */\n    public fillDefines(defines: Array<string>, blendMode: number) {\n        if (this._scene) {\n            if (this._scene.clipPlane) {\n                defines.push(\"#define CLIPPLANE\");\n            }\n\n            if (this._scene.clipPlane2) {\n                defines.push(\"#define CLIPPLANE2\");\n            }\n\n            if (this._scene.clipPlane3) {\n                defines.push(\"#define CLIPPLANE3\");\n            }\n\n            if (this._scene.clipPlane4) {\n                defines.push(\"#define CLIPPLANE4\");\n            }\n\n            if (this._scene.clipPlane5) {\n                defines.push(\"#define CLIPPLANE5\");\n            }\n\n            if (this._scene.clipPlane6) {\n                defines.push(\"#define CLIPPLANE6\");\n            }\n        }\n\n        if (this._isAnimationSheetEnabled) {\n            defines.push(\"#define ANIMATESHEET\");\n        }\n\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n            defines.push(\"#define BLENDMULTIPLYMODE\");\n        }\n\n        if (this._useRampGradients) {\n            defines.push(\"#define RAMPGRADIENT\");\n        }\n\n        if (this._isBillboardBased) {\n            defines.push(\"#define BILLBOARD\");\n\n            switch (this.billboardMode) {\n                case ParticleSystem.BILLBOARDMODE_Y:\n                    defines.push(\"#define BILLBOARDY\");\n                    break;\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\n                    break;\n                case ParticleSystem.BILLBOARDMODE_ALL:\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n            defines.push(this._imageProcessingConfigurationDefines.toString());\n        }\n    }\n\n    /**\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n     * @param uniforms Uniforms array to fill\n     * @param attributes Attributes array to fill\n     * @param samplers Samplers array to fill\n     */\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\n        attributes.push(...ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED, this._useRampGradients));\n\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled));\n\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\n\n        if (this._imageProcessingConfiguration) {\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n        }\n    }\n\n    /** @hidden */\n    private _getEffect(blendMode: number): Effect {\n        const customEffect = this.getCustomEffect(blendMode);\n\n        if (customEffect) {\n            return customEffect;\n        }\n\n        var defines: Array<string> = [];\n\n        this.fillDefines(defines, blendMode);\n\n        // Effect\n        var join = defines.join(\"\\n\");\n        if (this._cachedDefines !== join) {\n            this._cachedDefines = join;\n\n            var attributesNamesOrOptions: Array<string> = [];\n            var effectCreationOption: Array<string> = [];\n            var samplers: Array<string> = [];\n\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n\n            this._effect = this._engine.createEffect(\n                \"particles\",\n                attributesNamesOrOptions,\n                effectCreationOption,\n                samplers, join);\n        }\n\n        return this._effect;\n    }\n\n    /**\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n     */\n    public animate(preWarmOnly = false): void {\n        if (!this._started) {\n            return;\n        }\n\n        if (!preWarmOnly && this._scene) {\n            // Check\n            if (!this.isReady()) {\n                return;\n            }\n\n            if (this._currentRenderId === this._scene.getFrameId()) {\n                return;\n            }\n            this._currentRenderId = this._scene.getFrameId();\n        }\n\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\n\n        // Determine the number of particles we need to create\n        var newParticles;\n\n        if (this.manualEmitCount > -1) {\n            newParticles = this.manualEmitCount;\n            this._newPartsExcess = 0;\n            this.manualEmitCount = 0;\n        } else {\n            let rate = this.emitRate;\n\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n                const ratio = this._actualFrame / this.targetStopDuration;\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\n                    if (currentGradient !== this._currentEmitRateGradient) {\n                        this._currentEmitRate1 = this._currentEmitRate2;\n                        this._currentEmitRate2 = (<FactorGradient>nextGradient).getFactor();\n                        this._currentEmitRateGradient = (<FactorGradient>currentGradient);\n                    }\n\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\n                });\n            }\n\n            newParticles = ((rate * this._scaledUpdateSpeed) >> 0);\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\n        }\n\n        if (this._newPartsExcess > 1.0) {\n            newParticles += this._newPartsExcess >> 0;\n            this._newPartsExcess -= this._newPartsExcess >> 0;\n        }\n\n        this._alive = false;\n\n        if (!this._stopped) {\n            this._actualFrame += this._scaledUpdateSpeed;\n\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n                this.stop();\n            }\n        } else {\n            newParticles = 0;\n        }\n        this._update(newParticles);\n\n        // Stopped?\n        if (this._stopped) {\n            if (!this._alive) {\n                this._started = false;\n                if (this.onAnimationEnd) {\n                    this.onAnimationEnd();\n                }\n                if (this.disposeOnStop && this._scene) {\n                    this._scene._toBeDisposed.push(this);\n                }\n            }\n        }\n\n        if (!preWarmOnly) {\n            // Update VBO\n            var offset = 0;\n            for (var index = 0; index < this._particles.length; index++) {\n                var particle = this._particles[index];\n                this._appendParticleVertices(offset, particle);\n                offset += this._useInstancing ? 1 : 4;\n            }\n\n            if (this._vertexBuffer) {\n                this._vertexBuffer.update(this._vertexData);\n            }\n        }\n\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\n            this.stop();\n        }\n    }\n\n    private _appendParticleVertices(offset: number, particle: Particle) {\n        this._appendParticleVertex(offset++, particle, 0, 0);\n        if (!this._useInstancing) {\n            this._appendParticleVertex(offset++, particle, 1, 0);\n            this._appendParticleVertex(offset++, particle, 1, 1);\n            this._appendParticleVertex(offset++, particle, 0, 1);\n        }\n    }\n\n    /**\n     * Rebuilds the particle system.\n     */\n    public rebuild(): void {\n        this._createIndexBuffer();\n\n        if (this._vertexBuffer) {\n            this._vertexBuffer._rebuild();\n        }\n\n        for (var key in this._vertexBuffers) {\n            this._vertexBuffers[key]._rebuild();\n        }\n    }\n\n    /**\n     * Is this system ready to be used/rendered\n     * @return true if the system is ready\n     */\n    public isReady(): boolean {\n        if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n            return false;\n        }\n\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n            if (!this._getEffect(this.blendMode).isReady()) {\n                return false;\n            }\n        } else {\n            if (!this._getEffect(ParticleSystem.BLENDMODE_MULTIPLY).isReady()) {\n                return false;\n            }\n            if (!this._getEffect(ParticleSystem.BLENDMODE_ADD).isReady()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _render(blendMode: number) {\n        var effect = this._getEffect(blendMode);\n\n        var engine = this._engine;\n\n        // Render\n        engine.enableEffect(effect);\n\n        var viewMatrix = this.defaultViewMatrix ?? this._scene!.getViewMatrix();\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\n        effect.setMatrix(\"view\", viewMatrix);\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\n\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\n            var baseSize = this.particleTexture.getBaseSize();\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n        }\n\n        effect.setVector2(\"translationPivot\", this.translationPivot);\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n\n        if (this._isBillboardBased && this._scene) {\n            var camera = this._scene.activeCamera!;\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\n        }\n\n        if (this._rampGradientsTexture) {\n            if (!this._rampGradients || !this._rampGradients.length) {\n                this._rampGradientsTexture.dispose();\n                this._rampGradientsTexture = null;\n            }\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n        }\n\n        const defines = effect.defines;\n\n        if (this._scene) {\n            if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n                ThinMaterialHelper.BindClipPlane(effect, this._scene);\n            }\n        }\n\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n        }\n\n        if (this._vertexArrayObject !== undefined) {\n            if (!this._vertexArrayObject) {\n                this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n            }\n\n            this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n        } else {\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n        }\n\n        // image processing\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n            this._imageProcessingConfiguration.bind(effect);\n        }\n\n        // Draw order\n        switch (blendMode) {\n            case ParticleSystem.BLENDMODE_ADD:\n                engine.setAlphaMode(1);\n                break;\n            case ParticleSystem.BLENDMODE_ONEONE:\n                engine.setAlphaMode(6);\n                break;\n            case ParticleSystem.BLENDMODE_STANDARD:\n                engine.setAlphaMode(2);\n                break;\n            case ParticleSystem.BLENDMODE_MULTIPLY:\n                engine.setAlphaMode(4);\n                break;\n        }\n\n        if (this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n        }\n\n        if (this._useInstancing) {\n            engine.drawArraysType(8, 0, 4, this._particles.length);\n        } else {\n            engine.drawElementsType(0, 0, this._particles.length * 6);\n        }\n\n        return this._particles.length;\n    }\n\n    /**\n     * Renders the particle system in its current state.\n     * @returns the current number of particles\n     */\n    public render(): number {\n        // Check\n        if (!this.isReady() || !this._particles.length) {\n            return 0;\n        }\n\n        var engine = this._engine as any;\n        if (engine.setState) {\n            engine.setState(false);\n\n            if (this.forceDepthWrite) {\n                engine.setDepthWrite(true);\n            }\n        }\n\n        let outparticles = 0;\n\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n        }\n        else {\n            outparticles = this._render(this.blendMode);\n        }\n\n        this._engine.unbindInstanceAttributes();\n        this._engine.setAlphaMode(0);\n\n        return outparticles;\n    }\n\n    /**\n     * Disposes the particle system and free the associated resources\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\n     */\n    public dispose(disposeTexture = true): void {\n        if (this._vertexBuffer) {\n            this._vertexBuffer.dispose();\n            this._vertexBuffer = null;\n        }\n\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n            this._indexBuffer = null;\n        }\n\n        if (this._vertexArrayObject) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n            this._vertexArrayObject = null;\n        }\n\n        if (disposeTexture && this.particleTexture) {\n            this.particleTexture.dispose();\n            this.particleTexture = null;\n        }\n\n        if (disposeTexture && this.noiseTexture) {\n            this.noiseTexture.dispose();\n            this.noiseTexture = null;\n        }\n\n        if (this._rampGradientsTexture) {\n            this._rampGradientsTexture.dispose();\n            this._rampGradientsTexture = null;\n        }\n\n        this._removeFromRoot();\n\n        if (this._subEmitters && this._subEmitters.length) {\n            for (var index = 0; index < this._subEmitters.length; index++) {\n                for (var subEmitter of this._subEmitters[index]) {\n                    subEmitter.dispose();\n                }\n            }\n\n            this._subEmitters = [];\n            this.subEmitters = [];\n        }\n\n        if (this._disposeEmitterOnDispose && this.emitter && (this.emitter as AbstractMesh).dispose) {\n            (<AbstractMesh>this.emitter).dispose(true);\n        }\n\n        if (this._onBeforeDrawParticlesObservable) {\n            this._onBeforeDrawParticlesObservable.clear();\n        }\n\n        // Remove from scene\n        if (this._scene) {\n            var index = this._scene.particleSystems.indexOf(this);\n            if (index > -1) {\n                this._scene.particleSystems.splice(index, 1);\n            }\n\n            this._scene._activeParticleSystems.dispose();\n        }\n\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n        this.onStoppedObservable.clear();\n\n        this.reset();\n    }\n\n    // Clone\n    /**\n     * Clones the particle system.\n     * @param name The name of the cloned object\n     * @param newEmitter The new emitter to use\n     * @returns the cloned particle system\n     */\n    public clone(name: string, newEmitter: any): ParticleSystem {\n        var custom = { ...this._customEffect };\n        var program: any = null;\n        var engine = this._engine as any;\n        if (engine.createEffectForParticles) {\n            if (this.customShader != null) {\n                program = this.customShader;\n                var defines: string = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n                custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n            }\n        }\n\n        let serialization = this.serialize();\n        var result = ParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\n        result.name = name;\n        result.customShader = program;\n        result._customEffect = custom;\n\n        if (newEmitter === undefined) {\n            newEmitter = this.emitter;\n        }\n\n        if (this.noiseTexture) {\n            result.noiseTexture = this.noiseTexture.clone();\n        }\n\n        result.emitter = newEmitter;\n        if (!this.preventAutoStart) {\n            result.start();\n        }\n\n        return result;\n    }\n\n    /**\n     * Serializes the particle system to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the JSON object\n     */\n    public serialize(serializeTexture = false): any {\n        var serializationObject: any = {};\n\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n        serializationObject.textureMask = this.textureMask.asArray();\n        serializationObject.customShader = this.customShader;\n        serializationObject.preventAutoStart = this.preventAutoStart;\n\n        // SubEmitters\n        if (this.subEmitters) {\n            serializationObject.subEmitters = [];\n\n            if (!this._subEmitters) {\n                this._prepareSubEmitterInternalArray();\n            }\n\n            for (var subs of this._subEmitters) {\n                let cell = [];\n                for (var sub of subs) {\n                    cell.push(sub.serialize());\n                }\n\n                serializationObject.subEmitters.push(cell);\n            }\n        }\n\n        return serializationObject;\n    }\n\n    /** @hidden */\n    public static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean) {\n        serializationObject.name = particleSystem.name;\n        serializationObject.id = particleSystem.id;\n\n        serializationObject.capacity = particleSystem.getCapacity();\n\n        // Emitter\n        if ((<AbstractMesh>particleSystem.emitter).position) {\n            var emitterMesh = (<AbstractMesh>particleSystem.emitter);\n            serializationObject.emitterId = emitterMesh.id;\n        } else {\n            var emitterPosition = (<Vector3>particleSystem.emitter);\n            serializationObject.emitter = emitterPosition.asArray();\n        }\n\n        // Emitter\n        if (particleSystem.particleEmitterType) {\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n        }\n\n        if (particleSystem.particleTexture) {\n            if (serializeTexture) {\n                serializationObject.texture = particleSystem.particleTexture.serialize();\n            } else {\n                serializationObject.textureName = particleSystem.particleTexture.name;\n                serializationObject.invertY = !!(particleSystem.particleTexture as any)._invertY;\n            }\n        }\n\n        serializationObject.isLocal = particleSystem.isLocal;\n\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\n\n        // Particle system\n        serializationObject.startDelay = particleSystem.startDelay;\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n        serializationObject.billboardMode = particleSystem.billboardMode;\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n        serializationObject.minSize = particleSystem.minSize;\n        serializationObject.maxSize = particleSystem.maxSize;\n        serializationObject.minScaleX = particleSystem.minScaleX;\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\n        serializationObject.minScaleY = particleSystem.minScaleY;\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n        serializationObject.emitRate = particleSystem.emitRate;\n        serializationObject.gravity = particleSystem.gravity.asArray();\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n        serializationObject.color1 = particleSystem.color1.asArray();\n        serializationObject.color2 = particleSystem.color2.asArray();\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n        serializationObject.blendMode = particleSystem.blendMode;\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n\n        let colorGradients = particleSystem.getColorGradients();\n        if (colorGradients) {\n            serializationObject.colorGradients = [];\n            for (var colorGradient of colorGradients) {\n                var serializedGradient: any = {\n                    gradient: colorGradient.gradient,\n                    color1: colorGradient.color1.asArray()\n                };\n\n                if (colorGradient.color2) {\n                    serializedGradient.color2 = colorGradient.color2.asArray();\n                } else {\n                    serializedGradient.color2 = colorGradient.color1.asArray();\n                }\n\n                serializationObject.colorGradients.push(serializedGradient);\n            }\n        }\n\n        let rampGradients = particleSystem.getRampGradients();\n        if (rampGradients) {\n            serializationObject.rampGradients = [];\n            for (var rampGradient of rampGradients) {\n                var serializedGradient: any = {\n                    gradient: rampGradient.gradient,\n                    color: rampGradient.color.asArray()\n                };\n\n                serializationObject.rampGradients.push(serializedGradient);\n            }\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\n        }\n\n        let colorRemapGradients = particleSystem.getColorRemapGradients();\n        if (colorRemapGradients) {\n            serializationObject.colorRemapGradients = [];\n            for (var colorRemapGradient of colorRemapGradients) {\n\n                var serializedGradient: any = {\n                    gradient: colorRemapGradient.gradient,\n                    factor1: colorRemapGradient.factor1\n                };\n\n                if (colorRemapGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\n                }\n\n                serializationObject.colorRemapGradients.push(serializedGradient);\n            }\n        }\n\n        let alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n        if (alphaRemapGradients) {\n            serializationObject.alphaRemapGradients = [];\n            for (var alphaRemapGradient of alphaRemapGradients) {\n\n                var serializedGradient: any = {\n                    gradient: alphaRemapGradient.gradient,\n                    factor1: alphaRemapGradient.factor1\n                };\n\n                if (alphaRemapGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\n                }\n\n                serializationObject.alphaRemapGradients.push(serializedGradient);\n            }\n        }\n\n        let sizeGradients = particleSystem.getSizeGradients();\n        if (sizeGradients) {\n            serializationObject.sizeGradients = [];\n            for (var sizeGradient of sizeGradients) {\n\n                var serializedGradient: any = {\n                    gradient: sizeGradient.gradient,\n                    factor1: sizeGradient.factor1\n                };\n\n                if (sizeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = sizeGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = sizeGradient.factor1;\n                }\n\n                serializationObject.sizeGradients.push(serializedGradient);\n            }\n        }\n\n        let angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n        if (angularSpeedGradients) {\n            serializationObject.angularSpeedGradients = [];\n            for (var angularSpeedGradient of angularSpeedGradients) {\n\n                var serializedGradient: any = {\n                    gradient: angularSpeedGradient.gradient,\n                    factor1: angularSpeedGradient.factor1\n                };\n\n                if (angularSpeedGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\n                }\n\n                serializationObject.angularSpeedGradients.push(serializedGradient);\n            }\n        }\n\n        let velocityGradients = particleSystem.getVelocityGradients();\n        if (velocityGradients) {\n            serializationObject.velocityGradients = [];\n            for (var velocityGradient of velocityGradients) {\n\n                var serializedGradient: any = {\n                    gradient: velocityGradient.gradient,\n                    factor1: velocityGradient.factor1\n                };\n\n                if (velocityGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = velocityGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = velocityGradient.factor1;\n                }\n\n                serializationObject.velocityGradients.push(serializedGradient);\n            }\n        }\n\n        let dragGradients = particleSystem.getDragGradients();\n        if (dragGradients) {\n            serializationObject.dragGradients = [];\n            for (var dragGradient of dragGradients) {\n\n                var serializedGradient: any = {\n                    gradient: dragGradient.gradient,\n                    factor1: dragGradient.factor1\n                };\n\n                if (dragGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = dragGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = dragGradient.factor1;\n                }\n\n                serializationObject.dragGradients.push(serializedGradient);\n            }\n        }\n\n        let emitRateGradients = particleSystem.getEmitRateGradients();\n        if (emitRateGradients) {\n            serializationObject.emitRateGradients = [];\n            for (var emitRateGradient of emitRateGradients) {\n\n                var serializedGradient: any = {\n                    gradient: emitRateGradient.gradient,\n                    factor1: emitRateGradient.factor1\n                };\n\n                if (emitRateGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = emitRateGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = emitRateGradient.factor1;\n                }\n\n                serializationObject.emitRateGradients.push(serializedGradient);\n            }\n        }\n\n        let startSizeGradients = particleSystem.getStartSizeGradients();\n        if (startSizeGradients) {\n            serializationObject.startSizeGradients = [];\n            for (var startSizeGradient of startSizeGradients) {\n\n                var serializedGradient: any = {\n                    gradient: startSizeGradient.gradient,\n                    factor1: startSizeGradient.factor1\n                };\n\n                if (startSizeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = startSizeGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = startSizeGradient.factor1;\n                }\n\n                serializationObject.startSizeGradients.push(serializedGradient);\n            }\n        }\n\n        let lifeTimeGradients = particleSystem.getLifeTimeGradients();\n        if (lifeTimeGradients) {\n            serializationObject.lifeTimeGradients = [];\n            for (var lifeTimeGradient of lifeTimeGradients) {\n\n                var serializedGradient: any = {\n                    gradient: lifeTimeGradient.gradient,\n                    factor1: lifeTimeGradient.factor1\n                };\n\n                if (lifeTimeGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\n                }\n\n                serializationObject.lifeTimeGradients.push(serializedGradient);\n            }\n        }\n\n        let limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n        if (limitVelocityGradients) {\n            serializationObject.limitVelocityGradients = [];\n            for (var limitVelocityGradient of limitVelocityGradients) {\n\n                var serializedGradient: any = {\n                    gradient: limitVelocityGradient.gradient,\n                    factor1: limitVelocityGradient.factor1\n                };\n\n                if (limitVelocityGradient.factor2 !== undefined) {\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\n                } else {\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\n                }\n\n                serializationObject.limitVelocityGradients.push(serializedGradient);\n            }\n\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n        }\n\n        if (particleSystem.noiseTexture) {\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n        }\n    }\n\n    /** @hidden */\n    public static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string) {\n        let scene: Nullable<Scene>;\n\n        if (sceneOrEngine instanceof ThinEngine) {\n            scene = null;\n        } else {\n            scene = sceneOrEngine as Scene;\n        }\n\n        const internalClass = _TypeStore.GetClass(\"BABYLON.Texture\");\n        if (internalClass && scene) {\n            // Texture\n            if (parsedParticleSystem.texture) {\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl) as BaseTexture;\n            } else if (parsedParticleSystem.textureName) {\n                particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n                particleSystem.particleTexture!.name = parsedParticleSystem.textureName;\n            }\n        }\n\n        // Emitter\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n            particleSystem.emitter = Vector3.Zero();\n        }\n        else if (parsedParticleSystem.emitterId && scene) {\n            particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);\n        } else {\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n        }\n\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\n\n        // Misc.\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n        }\n\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n        }\n\n        if (parsedParticleSystem.billboardMode !== undefined) {\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n        }\n\n        // Animations\n        if (parsedParticleSystem.animations) {\n            for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n                var parsedAnimation = parsedParticleSystem.animations[animationIndex];\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n        }\n\n        if (parsedParticleSystem.autoAnimate && scene) {\n            scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n        }\n\n        // Particle system\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n        particleSystem.minSize = parsedParticleSystem.minSize;\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\n\n        if (parsedParticleSystem.minScaleX) {\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n        }\n\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n        }\n\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n        }\n\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n        if (parsedParticleSystem.noiseStrength) {\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n        }\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\n\n        if (parsedParticleSystem.colorGradients) {\n            for (var colorGradient of parsedParticleSystem.colorGradients) {\n                particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n            }\n        }\n\n        if (parsedParticleSystem.rampGradients) {\n            for (var rampGradient of parsedParticleSystem.rampGradients) {\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n            }\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n        }\n\n        if (parsedParticleSystem.colorRemapGradients) {\n            for (var colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\n                particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.alphaRemapGradients) {\n            for (var alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\n                particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.sizeGradients) {\n            for (var sizeGradient of parsedParticleSystem.sizeGradients) {\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.angularSpeedGradients) {\n            for (var angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\n                particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.velocityGradients) {\n            for (var velocityGradient of parsedParticleSystem.velocityGradients) {\n                particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.dragGradients) {\n            for (var dragGradient of parsedParticleSystem.dragGradients) {\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.emitRateGradients) {\n            for (var emitRateGradient of parsedParticleSystem.emitRateGradients) {\n                particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.startSizeGradients) {\n            for (var startSizeGradient of parsedParticleSystem.startSizeGradients) {\n                particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.lifeTimeGradients) {\n            for (var lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\n                particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n            }\n        }\n\n        if (parsedParticleSystem.limitVelocityGradients) {\n            for (var limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\n                particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n            }\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n        }\n\n        if (parsedParticleSystem.noiseTexture && scene) {\n            const internalClass = _TypeStore.GetClass(\"BABYLON.ProceduralTexture\");\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n        }\n\n        // Emitter\n        let emitterType: IParticleEmitterType;\n        if (parsedParticleSystem.particleEmitterType) {\n            switch (parsedParticleSystem.particleEmitterType.type) {\n                case \"SphereParticleEmitter\":\n                    emitterType = new SphereParticleEmitter();\n                    break;\n                case \"SphereDirectedParticleEmitter\":\n                    emitterType = new SphereDirectedParticleEmitter();\n                    break;\n                case \"ConeEmitter\":\n                case \"ConeParticleEmitter\":\n                    emitterType = new ConeParticleEmitter();\n                    break;\n                case \"CylinderParticleEmitter\":\n                    emitterType = new CylinderParticleEmitter();\n                    break;\n                case \"CylinderDirectedParticleEmitter\":\n                    emitterType = new CylinderDirectedParticleEmitter();\n                    break;\n                case \"HemisphericParticleEmitter\":\n                    emitterType = new HemisphericParticleEmitter();\n                    break;\n                case \"PointParticleEmitter\":\n                    emitterType = new PointParticleEmitter();\n                    break;\n                case \"MeshParticleEmitter\":\n                    emitterType = new MeshParticleEmitter();\n                    break;\n                    case \"BoxEmitter\":\n                case \"BoxParticleEmitter\":\n                default:\n                    emitterType = new BoxParticleEmitter();\n                    break;\n            }\n\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n        } else {\n            emitterType = new BoxParticleEmitter();\n            emitterType.parse(parsedParticleSystem, scene);\n        }\n        particleSystem.particleEmitterType = emitterType;\n\n        // Animation sheet\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n    }\n\n    /**\n     * Parses a JSON object to create a particle system.\n     * @param parsedParticleSystem The JSON object to parse\n     * @param sceneOrEngine The scene or the engine to create the particle system in\n     * @param rootUrl The root url to use to load external dependencies like texture\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\n     * @returns the Parsed particle system\n     */\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false): ParticleSystem {\n        var name = parsedParticleSystem.name;\n        var custom: Nullable<Effect> = null;\n        var program: any = null;\n        let engine: ThinEngine;\n        let scene: Nullable<Scene>;\n\n        if (sceneOrEngine instanceof ThinEngine) {\n            engine = sceneOrEngine;\n        } else {\n            scene = sceneOrEngine as Scene;\n            engine = scene.getEngine();\n        }\n\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\n            program = parsedParticleSystem.customShader;\n            var defines: string = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n            custom = (engine as any).createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n        }\n        var particleSystem = new ParticleSystem(name, parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n        particleSystem.customShader = program;\n\n        if (parsedParticleSystem.id) {\n            particleSystem.id = parsedParticleSystem.id;\n        }\n\n        // SubEmitters\n        if (parsedParticleSystem.subEmitters) {\n            particleSystem.subEmitters = [];\n            for (var cell of parsedParticleSystem.subEmitters) {\n                let cellArray = [];\n                for (var sub of cell) {\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n                }\n\n                particleSystem.subEmitters.push(cellArray);\n            }\n        }\n\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n\n        if (parsedParticleSystem.textureMask) {\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n        }\n\n        // Auto start\n        if (parsedParticleSystem.preventAutoStart) {\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n        }\n\n        if (!doNotStart && !particleSystem.preventAutoStart) {\n            particleSystem.start();\n        }\n\n        return particleSystem;\n    }\n}\n\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}