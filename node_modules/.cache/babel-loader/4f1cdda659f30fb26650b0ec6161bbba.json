{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\n\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n  return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\r\n * Mesh representing the gorund\r\n */\n\n\nvar GroundMesh =\n/** @class */\nfunction (_super) {\n  __extends(GroundMesh, _super);\n\n  function GroundMesh(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n    /** If octree should be generated */\n\n\n    _this.generateOctree = false;\n    return _this;\n  }\n  /**\r\n   * \"GroundMesh\"\r\n   * @returns \"GroundMesh\"\r\n   */\n\n\n  GroundMesh.prototype.getClassName = function () {\n    return \"GroundMesh\";\n  };\n\n  Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\n    get: function () {\n      return Math.min(this._subdivisionsX, this._subdivisionsY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\n    /**\r\n     * X subdivisions\r\n     */\n    get: function () {\n      return this._subdivisionsX;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\n    /**\r\n     * Y subdivisions\r\n     */\n    get: function () {\n      return this._subdivisionsY;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n   * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n   * @param chunksCount the number of subdivisions for x and y\r\n   * @param octreeBlocksSize (Default: 32)\r\n   */\n\n  GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\n    if (octreeBlocksSize === void 0) {\n      octreeBlocksSize = 32;\n    }\n\n    this._subdivisionsX = chunksCount;\n    this._subdivisionsY = chunksCount;\n    this.subdivide(chunksCount); // Call the octree system optimization if it is defined.\n\n    var thisAsAny = this;\n\n    if (thisAsAny.createOrUpdateSubmeshesOctree) {\n      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n    }\n  };\n  /**\r\n   * Returns a height (y) value in the Worl system :\r\n   * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @returns the ground y position if (x, z) are outside the ground surface.\r\n   */\n\n\n  GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this.position.y;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    var y = -(facet.x * x + facet.z * z + facet.w) / facet.y; // return y in the World system\n\n    Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n    return tmpVect.y;\n  };\n  /**\r\n   * Returns a normalized vector (Vector3) orthogonal to the ground\r\n   * at the ground coordinates (x, z) expressed in the World system.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\n    var normal = new Vector3(0.0, 1.0, 0.0);\n    this.getNormalAtCoordinatesToRef(x, z, normal);\n    return normal;\n  };\n  /**\r\n   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n   * at the ground coordinates (x, z) expressed in the World system.\r\n   * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n   * @param x x coordinate\r\n   * @param z z coordinate\r\n   * @param ref vector to store the result\r\n   * @returns the GroundMesh.\r\n   */\n\n\n  GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\n    var world = this.getWorldMatrix();\n    var tmpMat = TmpVectors.Matrix[5];\n    world.invertToRef(tmpMat);\n    var tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n\n    x = tmpVect.x;\n    z = tmpVect.z;\n\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this;\n    }\n\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n\n      this._computeHeightQuads();\n    }\n\n    var facet = this._getFacetAt(x, z);\n\n    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n    return this;\n  };\n  /**\r\n  * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n  * if the ground has been updated.\r\n  * This can be used in the render loop.\r\n  * @returns the GroundMesh.\r\n  */\n\n\n  GroundMesh.prototype.updateCoordinateHeights = function () {\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n    }\n\n    this._computeHeightQuads();\n\n    return this;\n  }; // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n\n\n  GroundMesh.prototype._getFacetAt = function (x, z) {\n    // retrieve col and row from x, z coordinates in the ground local system\n    var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n    var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n    var quad = this._heightQuads[row * this._subdivisionsX + col];\n    var facet;\n\n    if (z < quad.slope.x * x + quad.slope.y) {\n      facet = quad.facet1;\n    } else {\n      facet = quad.facet2;\n    }\n\n    return facet;\n  }; //  Creates and populates the heightMap array with \"facet\" elements :\n  // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n  // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._initHeightQuads = function () {\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n    this._heightQuads = new Array();\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        var quad = {\n          slope: Vector2.Zero(),\n          facet1: new Vector4(0.0, 0.0, 0.0, 0.0),\n          facet2: new Vector4(0.0, 0.0, 0.0, 0.0)\n        };\n        this._heightQuads[row * subdivisionsX + col] = quad;\n      }\n    }\n\n    return this;\n  }; // Compute each quad element values and update the the heightMap array :\n  // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n\n\n  GroundMesh.prototype._computeHeightQuads = function () {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!positions) {\n      return this;\n    }\n\n    var v1 = TmpVectors.Vector3[3];\n    var v2 = TmpVectors.Vector3[2];\n    var v3 = TmpVectors.Vector3[1];\n    var v4 = TmpVectors.Vector3[0];\n    var v1v2 = TmpVectors.Vector3[4];\n    var v1v3 = TmpVectors.Vector3[5];\n    var v1v4 = TmpVectors.Vector3[6];\n    var norm1 = TmpVectors.Vector3[7];\n    var norm2 = TmpVectors.Vector3[8];\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var cd = 0; // 2D slope coefficient : z = cd * x + h\n\n    var h = 0;\n    var d1 = 0; // facet plane equation : ax + by + cz + d = 0\n\n    var d2 = 0;\n    var subdivisionsX = this._subdivisionsX;\n    var subdivisionsY = this._subdivisionsY;\n\n    for (var row = 0; row < subdivisionsY; row++) {\n      for (var col = 0; col < subdivisionsX; col++) {\n        i = col * 3;\n        j = row * (subdivisionsX + 1) * 3;\n        k = (row + 1) * (subdivisionsX + 1) * 3;\n        v1.x = positions[j + i];\n        v1.y = positions[j + i + 1];\n        v1.z = positions[j + i + 2];\n        v2.x = positions[j + i + 3];\n        v2.y = positions[j + i + 4];\n        v2.z = positions[j + i + 5];\n        v3.x = positions[k + i];\n        v3.y = positions[k + i + 1];\n        v3.z = positions[k + i + 2];\n        v4.x = positions[k + i + 3];\n        v4.y = positions[k + i + 4];\n        v4.z = positions[k + i + 5]; // 2D slope V1V4\n\n        cd = (v4.z - v1.z) / (v4.x - v1.x);\n        h = v1.z - cd * v1.x; // v1 belongs to the slope\n        // facet equations :\n        // we compute each facet normal vector\n        // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n        // we compute the value d by applying the equation to v1 which belongs to the plane\n        // then we store the facet equation in a Vector4\n\n        v2.subtractToRef(v1, v1v2);\n        v3.subtractToRef(v1, v1v3);\n        v4.subtractToRef(v1, v1v4);\n        Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n\n        Vector3.CrossToRef(v1v2, v1v4, norm2);\n        norm1.normalize();\n        norm2.normalize();\n        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n        var quad = this._heightQuads[row * subdivisionsX + col];\n        quad.slope.copyFromFloats(cd, h);\n        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Serializes this ground mesh\r\n   * @param serializationObject object to write serialization to\r\n   */\n\n\n  GroundMesh.prototype.serialize = function (serializationObject) {\n    _super.prototype.serialize.call(this, serializationObject);\n\n    serializationObject.subdivisionsX = this._subdivisionsX;\n    serializationObject.subdivisionsY = this._subdivisionsY;\n    serializationObject.minX = this._minX;\n    serializationObject.maxX = this._maxX;\n    serializationObject.minZ = this._minZ;\n    serializationObject.maxZ = this._maxZ;\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n  };\n  /**\r\n   * Parses a serialized ground mesh\r\n   * @param parsedMesh the serialized mesh\r\n   * @param scene the scene to create the ground mesh in\r\n   * @returns the created ground mesh\r\n   */\n\n\n  GroundMesh.Parse = function (parsedMesh, scene) {\n    var result = new GroundMesh(parsedMesh.name, scene);\n    result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n    result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n    result._minX = parsedMesh.minX;\n    result._maxX = parsedMesh.maxX;\n    result._minZ = parsedMesh.minZ;\n    result._maxZ = parsedMesh.maxZ;\n    result._width = parsedMesh.width;\n    result._height = parsedMesh.height;\n    return result;\n  };\n\n  return GroundMesh;\n}(Mesh);\n\nexport { GroundMesh };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/groundMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the gorund\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @hidden */\r\n    public _subdivisionsX: number;\r\n    /** @hidden */\r\n    public _subdivisionsY: number;\r\n    /** @hidden */\r\n    public _width: number;\r\n    /** @hidden */\r\n    public _height: number;\r\n    /** @hidden */\r\n    public _minX: number;\r\n    /** @hidden */\r\n    public _maxX: number;\r\n    /** @hidden */\r\n    public _minZ: number;\r\n    /** @hidden */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the Worl system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        var normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        var world = this.getWorldMatrix();\r\n        var tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n    * if the ground has been updated.\r\n    * This can be used in the render loop.\r\n    * @returns the GroundMesh.\r\n    */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\r\n        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\r\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        var facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        var v1 = TmpVectors.Vector3[3];\r\n        var v2 = TmpVectors.Vector3[2];\r\n        var v3 = TmpVectors.Vector3[1];\r\n        var v4 = TmpVectors.Vector3[0];\r\n        var v1v2 = TmpVectors.Vector3[4];\r\n        var v1v3 = TmpVectors.Vector3[5];\r\n        var v1v4 = TmpVectors.Vector3[6];\r\n        var norm1 = TmpVectors.Vector3[7];\r\n        var norm2 = TmpVectors.Vector3[8];\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var cd = 0;     // 2D slope coefficient : z = cd * x + h\r\n        var h = 0;\r\n        var d1 = 0;     // facet plane equation : ax + by + cz + d = 0\r\n        var d2 = 0;\r\n\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x;             // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1);  // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                var quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        var result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}