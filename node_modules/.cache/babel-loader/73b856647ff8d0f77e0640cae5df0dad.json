{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\n\nvar CustomParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance CustomParticleEmitter\r\n   */\n  function CustomParticleEmitter() {\n    /**\r\n     * Gets or sets the position generator that will create the inital position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\n    this.particlePositionGenerator = function () {};\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\n\n\n    this.particleDestinationGenerator = function () {};\n  }\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  CustomParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    var tmpVector = TmpVectors.Vector3[0];\n\n    if (this.particleDestinationGenerator) {\n      this.particleDestinationGenerator(-1, particle, tmpVector); // Get direction\n\n      var diffVector = TmpVectors.Vector3[1];\n      tmpVector.subtractToRef(particle.position, diffVector);\n      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n\n    if (isLocal) {\n      directionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n\n    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  CustomParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var tmpVector = TmpVectors.Vector3[0];\n\n    if (this.particlePositionGenerator) {\n      this.particlePositionGenerator(-1, particle, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n\n    if (isLocal) {\n      positionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n\n    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  CustomParticleEmitter.prototype.clone = function () {\n    var newOne = new CustomParticleEmitter();\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  CustomParticleEmitter.prototype.applyToShader = function (effect) {};\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  CustomParticleEmitter.prototype.getEffectDefines = function () {\n    return \"#define CUSTOMEMITTER\";\n  };\n  /**\r\n   * Returns the string \"PointParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  CustomParticleEmitter.prototype.getClassName = function () {\n    return \"CustomParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  CustomParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  CustomParticleEmitter.prototype.parse = function (serializationObject) {};\n\n  return CustomParticleEmitter;\n}();\n\nexport { CustomParticleEmitter };","map":{"version":3,"sources":["../../../../sourceES6/core/Particles/EmitterTypes/customParticleEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { Particle } from \"../particle\";\r\nimport { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { Nullable } from '../../types';\r\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\r\nexport class CustomParticleEmitter implements IParticleEmitterType {\r\n\r\n    /**\r\n     * Gets or sets the position generator that will create the inital position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Creates a new instance CustomParticleEmitter\r\n     */\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        let tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particleDestinationGenerator) {\r\n            this.particleDestinationGenerator(-1, particle, tmpVector);\r\n\r\n            // Get direction\r\n            let diffVector = TmpVectors.Vector3[1];\r\n            tmpVector.subtractToRef(particle.position, diffVector);\r\n\r\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        let tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particlePositionGenerator) {\r\n            this.particlePositionGenerator(-1, particle, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CustomParticleEmitter {\r\n        let newOne = new CustomParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param effect defines the update shader\r\n     */\r\n    public applyToShader(effect: Effect): void {\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containng the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CUSTOMEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CustomParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}