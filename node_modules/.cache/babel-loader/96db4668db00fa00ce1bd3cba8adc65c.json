{"ast":null,"code":"import { Scalar } from \"./math.scalar\";\nimport { Epsilon } from './math.constants';\nimport { ArrayTools } from '../Misc/arrayTools';\nimport { _TypeStore } from '../Misc/typeStore';\nimport { PerformanceConfigurator } from '../Engines/performanceConfigurator';\n/**\r\n * Class representing a vector containing 2 coordinates\r\n */\n\nvar Vector2 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Vector2 from the given x and y coordinates\r\n   * @param x defines the first coordinate\r\n   * @param y defines the second coordinate\r\n   */\n  function Vector2(\n  /** defines the first coordinate */\n  x,\n  /** defines the second coordinate */\n  y) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    this.x = x;\n    this.y = y;\n  }\n  /**\r\n   * Gets a string with the Vector2 coordinates\r\n   * @returns a string with the Vector2 coordinates\r\n   */\n\n\n  Vector2.prototype.toString = function () {\n    return \"{X: \" + this.x + \" Y: \" + this.y + \"}\";\n  };\n  /**\r\n   * Gets class name\r\n   * @returns the string \"Vector2\"\r\n   */\n\n\n  Vector2.prototype.getClassName = function () {\n    return \"Vector2\";\n  };\n  /**\r\n   * Gets current vector hash code\r\n   * @returns the Vector2 hash code as a number\r\n   */\n\n\n  Vector2.prototype.getHashCode = function () {\n    var hash = this.x | 0;\n    hash = hash * 397 ^ (this.y | 0);\n    return hash;\n  }; // Operators\n\n  /**\r\n   * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\r\n   * @param array defines the source array\r\n   * @param index defines the offset in source array\r\n   * @returns the current Vector2\r\n   */\n\n\n  Vector2.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this.x;\n    array[index + 1] = this.y;\n    return this;\n  };\n  /**\r\n   * Update the current vector from an array\r\n   * @param array defines the destination array\r\n   * @param index defines the offset in the destination array\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector2.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector2.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\r\n   * Copy the current vector to an array\r\n   * @returns a new array with 2 elements: the Vector2 coordinates.\r\n   */\n\n\n  Vector2.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\r\n   * Sets the Vector2 coordinates with the given Vector2 coordinates\r\n   * @param source defines the source Vector2\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.copyFrom = function (source) {\n    this.x = source.x;\n    this.y = source.y;\n    return this;\n  };\n  /**\r\n   * Sets the Vector2 coordinates with the given floats\r\n   * @param x defines the first coordinate\r\n   * @param y defines the second coordinate\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.copyFromFloats = function (x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  };\n  /**\r\n   * Sets the Vector2 coordinates with the given floats\r\n   * @param x defines the first coordinate\r\n   * @param y defines the second coordinate\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.set = function (x, y) {\n    return this.copyFromFloats(x, y);\n  };\n  /**\r\n   * Add another vector with the current one\r\n   * @param otherVector defines the other vector\r\n   * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\r\n   */\n\n\n  Vector2.prototype.add = function (otherVector) {\n    return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n  };\n  /**\r\n   * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @param result defines the target vector\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.addToRef = function (otherVector, result) {\n    result.x = this.x + otherVector.x;\n    result.y = this.y + otherVector.y;\n    return this;\n  };\n  /**\r\n   * Set the Vector2 coordinates by adding the given Vector2 coordinates\r\n   * @param otherVector defines the other vector\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.addInPlace = function (otherVector) {\n    this.x += otherVector.x;\n    this.y += otherVector.y;\n    return this;\n  };\n  /**\r\n   * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\r\n   * @param otherVector defines the other vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.addVector3 = function (otherVector) {\n    return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n  };\n  /**\r\n   * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\r\n   * @param otherVector defines the other vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.subtract = function (otherVector) {\n    return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n  };\n  /**\r\n   * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\r\n   * @param otherVector defines the other vector\r\n   * @param result defines the target vector\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.subtractToRef = function (otherVector, result) {\n    result.x = this.x - otherVector.x;\n    result.y = this.y - otherVector.y;\n    return this;\n  };\n  /**\r\n   * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector.x;\n    this.y -= otherVector.y;\n    return this;\n  };\n  /**\r\n   * Multiplies in place the current Vector2 coordinates by the given ones\r\n   * @param otherVector defines the other vector\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector.x;\n    this.y *= otherVector.y;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.multiply = function (otherVector) {\n    return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n  };\n  /**\r\n   * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @param result defines the target vector\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.multiplyToRef = function (otherVector, result) {\n    result.x = this.x * otherVector.x;\n    result.y = this.y * otherVector.y;\n    return this;\n  };\n  /**\r\n   * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\r\n   * @param x defines the first coordinate\r\n   * @param y defines the second coordinate\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.multiplyByFloats = function (x, y) {\n    return new Vector2(this.x * x, this.y * y);\n  };\n  /**\r\n   * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.divide = function (otherVector) {\n    return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n  };\n  /**\r\n   * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\r\n   * @param otherVector defines the other vector\r\n   * @param result defines the target vector\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.divideToRef = function (otherVector, result) {\n    result.x = this.x / otherVector.x;\n    result.y = this.y / otherVector.y;\n    return this;\n  };\n  /**\r\n   * Divides the current Vector2 coordinates by the given ones\r\n   * @param otherVector defines the other vector\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\r\n   * Gets a new Vector2 with current Vector2 negated coordinates\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.negate = function () {\n    return new Vector2(-this.x, -this.y);\n  };\n  /**\r\n   * Negate this vector in place\r\n   * @returns this\r\n   */\n\n\n  Vector2.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    return this;\n  };\n  /**\r\n   * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector2\r\n   */\n\n\n  Vector2.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this.x * -1, this.y * -1);\n  };\n  /**\r\n   * Multiply the Vector2 coordinates by scale\r\n   * @param scale defines the scaling factor\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector2 scaled by \"scale\" from the current Vector2\r\n   * @param scale defines the scaling factor\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.scale = function (scale) {\n    var result = new Vector2(0, 0);\n    this.scaleToRef(scale, result);\n    return result;\n  };\n  /**\r\n   * Scale the current Vector2 values by a factor to a given Vector2\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Vector2 object where to store the result\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.scaleToRef = function (scale, result) {\n    result.x = this.x * scale;\n    result.y = this.y * scale;\n    return this;\n  };\n  /**\r\n   * Scale the current Vector2 values by a factor and add the result to a given Vector2\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Vector2 object where to store the result\r\n   * @returns the unmodified current Vector2\r\n   */\n\n\n  Vector2.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this.x * scale;\n    result.y += this.y * scale;\n    return this;\n  };\n  /**\r\n   * Gets a boolean if two vectors are equals\r\n   * @param otherVector defines the other vector\r\n   * @returns true if the given vector coordinates strictly equal the current Vector2 ones\r\n   */\n\n\n  Vector2.prototype.equals = function (otherVector) {\n    return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n  };\n  /**\r\n   * Gets a boolean if two vectors are equals (using an epsilon value)\r\n   * @param otherVector defines the other vector\r\n   * @param epsilon defines the minimal distance to consider equality\r\n   * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\r\n   */\n\n\n  Vector2.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\n  };\n  /**\r\n   * Gets a new Vector2 from current Vector2 floored values\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.floor = function () {\n    return new Vector2(Math.floor(this.x), Math.floor(this.y));\n  };\n  /**\r\n   * Gets a new Vector2 from current Vector2 floored values\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.fract = function () {\n    return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n  }; // Properties\n\n  /**\r\n   * Gets the length of the vector\r\n   * @returns the vector length (float)\r\n   */\n\n\n  Vector2.prototype.length = function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  };\n  /**\r\n   * Gets the vector squared length\r\n   * @returns the vector squared length (float)\r\n   */\n\n\n  Vector2.prototype.lengthSquared = function () {\n    return this.x * this.x + this.y * this.y;\n  }; // Methods\n\n  /**\r\n   * Normalize the vector\r\n   * @returns the current updated Vector2\r\n   */\n\n\n  Vector2.prototype.normalize = function () {\n    var len = this.length();\n\n    if (len === 0) {\n      return this;\n    }\n\n    this.x /= len;\n    this.y /= len;\n    return this;\n  };\n  /**\r\n   * Gets a new Vector2 copied from the Vector2\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.prototype.clone = function () {\n    return new Vector2(this.x, this.y);\n  }; // Statics\n\n  /**\r\n   * Gets a new Vector2(0, 0)\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Zero = function () {\n    return new Vector2(0, 0);\n  };\n  /**\r\n   * Gets a new Vector2(1, 1)\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.One = function () {\n    return new Vector2(1, 1);\n  };\n  /**\r\n   * Gets a new Vector2 set from the given index element of the given array\r\n   * @param array defines the data source\r\n   * @param offset defines the offset in the data source\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Vector2(array[offset], array[offset + 1]);\n  };\n  /**\r\n   * Sets \"result\" from the given index element of the given array\r\n   * @param array defines the data source\r\n   * @param offset defines the offset in the data source\r\n   * @param result defines the target vector\r\n   */\n\n\n  Vector2.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n  };\n  /**\r\n   * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\r\n   * @param value1 defines 1st point of control\r\n   * @param value2 defines 2nd point of control\r\n   * @param value3 defines 3rd point of control\r\n   * @param value4 defines 4th point of control\r\n   * @param amount defines the interpolation factor\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.CatmullRom = function (value1, value2, value3, value4, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var x = 0.5 * (2.0 * value2.x + (-value1.x + value3.x) * amount + (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) * squared + (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n    var y = 0.5 * (2.0 * value2.y + (-value1.y + value3.y) * amount + (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) * squared + (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\r\n   * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\r\n   * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\r\n   * @param value defines the value to clamp\r\n   * @param min defines the lower limit\r\n   * @param max defines the upper limit\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Clamp = function (value, min, max) {\n    var x = value.x;\n    x = x > max.x ? max.x : x;\n    x = x < min.x ? min.x : x;\n    var y = value.y;\n    y = y > max.y ? max.y : y;\n    y = y < min.y ? min.y : y;\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\"\r\n   * @param value1 defines the 1st control point\r\n   * @param tangent1 defines the outgoing tangent\r\n   * @param value2 defines the 2nd control point\r\n   * @param tangent2 defines the incoming tangent\r\n   * @param amount defines the interpolation factor\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;\n    var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\r\n   * @param start defines the start vector\r\n   * @param end defines the end vector\r\n   * @param amount defines the interpolation factor\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Lerp = function (start, end, amount) {\n    var x = start.x + (end.x - start.x) * amount;\n    var y = start.y + (end.y - start.y) * amount;\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Gets the dot product of the vector \"left\" and the vector \"right\"\r\n   * @param left defines first vector\r\n   * @param right defines second vector\r\n   * @returns the dot product (float)\r\n   */\n\n\n  Vector2.Dot = function (left, right) {\n    return left.x * right.x + left.y * right.y;\n  };\n  /**\r\n   * Returns a new Vector2 equal to the normalized given vector\r\n   * @param vector defines the vector to normalize\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Normalize = function (vector) {\n    var newVector = vector.clone();\n    newVector.normalize();\n    return newVector;\n  };\n  /**\r\n   * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\r\n   * @param left defines 1st vector\r\n   * @param right defines 2nd vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Minimize = function (left, right) {\n    var x = left.x < right.x ? left.x : right.x;\n    var y = left.y < right.y ? left.y : right.y;\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Gets a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\r\n   * @param left defines 1st vector\r\n   * @param right defines 2nd vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Maximize = function (left, right) {\n    var x = left.x > right.x ? left.x : right.x;\n    var y = left.y > right.y ? left.y : right.y;\n    return new Vector2(x, y);\n  };\n  /**\r\n   * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\r\n   * @param vector defines the vector to transform\r\n   * @param transformation defines the matrix to apply\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Transform = function (vector, transformation) {\n    var r = Vector2.Zero();\n    Vector2.TransformToRef(vector, transformation, r);\n    return r;\n  };\n  /**\r\n   * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\r\n   * @param vector defines the vector to transform\r\n   * @param transformation defines the matrix to apply\r\n   * @param result defines the target vector\r\n   */\n\n\n  Vector2.TransformToRef = function (vector, transformation, result) {\n    var m = transformation.m;\n    var x = vector.x * m[0] + vector.y * m[4] + m[12];\n    var y = vector.x * m[1] + vector.y * m[5] + m[13];\n    result.x = x;\n    result.y = y;\n  };\n  /**\r\n   * Determines if a given vector is included in a triangle\r\n   * @param p defines the vector to test\r\n   * @param p0 defines 1st triangle point\r\n   * @param p1 defines 2nd triangle point\r\n   * @param p2 defines 3rd triangle point\r\n   * @returns true if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\r\n   */\n\n\n  Vector2.PointInTriangle = function (p, p0, p1, p2) {\n    var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n    var sign = a < 0 ? -1 : 1;\n    var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n    var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n    return s > 0 && t > 0 && s + t < 2 * a * sign;\n  };\n  /**\r\n   * Gets the distance between the vectors \"value1\" and \"value2\"\r\n   * @param value1 defines first vector\r\n   * @param value2 defines second vector\r\n   * @returns the distance between vectors\r\n   */\n\n\n  Vector2.Distance = function (value1, value2) {\n    return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n  };\n  /**\r\n   * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n   * @param value1 defines first vector\r\n   * @param value2 defines second vector\r\n   * @returns the squared distance between vectors\r\n   */\n\n\n  Vector2.DistanceSquared = function (value1, value2) {\n    var x = value1.x - value2.x;\n    var y = value1.y - value2.y;\n    return x * x + y * y;\n  };\n  /**\r\n   * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\r\n   * @param value1 defines first vector\r\n   * @param value2 defines second vector\r\n   * @returns a new Vector2\r\n   */\n\n\n  Vector2.Center = function (value1, value2) {\n    var center = value1.add(value2);\n    center.scaleInPlace(0.5);\n    return center;\n  };\n  /**\r\n   * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\r\n   * @param p defines the middle point\r\n   * @param segA defines one point of the segment\r\n   * @param segB defines the other point of the segment\r\n   * @returns the shortest distance\r\n   */\n\n\n  Vector2.DistanceOfPointFromSegment = function (p, segA, segB) {\n    var l2 = Vector2.DistanceSquared(segA, segB);\n\n    if (l2 === 0.0) {\n      return Vector2.Distance(p, segA);\n    }\n\n    var v = segB.subtract(segA);\n    var t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n    var proj = segA.add(v.multiplyByFloats(t, t));\n    return Vector2.Distance(p, proj);\n  };\n\n  return Vector2;\n}();\n\nexport { Vector2 };\n/**\r\n * Class used to store (x,y,z) vector representation\r\n * A Vector3 is the main object used in 3D geometry\r\n * It can represent etiher the coordinates of a point the space, either a direction\r\n * Reminder: js uses a left handed forward facing system\r\n */\n\nvar Vector3 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\r\n   * @param x defines the first coordinates (on X axis)\r\n   * @param y defines the second coordinates (on Y axis)\r\n   * @param z defines the third coordinates (on Z axis)\r\n   */\n  function Vector3(x, y, z) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (z === void 0) {\n      z = 0;\n    }\n    /** @hidden */\n\n\n    this._isDirty = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n  }\n\n  Object.defineProperty(Vector3.prototype, \"x\", {\n    /** Gets or sets the x coordinate */\n    get: function () {\n      return this._x;\n    },\n    set: function (value) {\n      this._x = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3.prototype, \"y\", {\n    /** Gets or sets the y coordinate */\n    get: function () {\n      return this._y;\n    },\n    set: function (value) {\n      this._y = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3.prototype, \"z\", {\n    /** Gets or sets the z coordinate */\n    get: function () {\n      return this._z;\n    },\n    set: function (value) {\n      this._z = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a string representation of the Vector3\r\n   * @returns a string with the Vector3 coordinates.\r\n   */\n\n  Vector3.prototype.toString = function () {\n    return \"{X: \" + this._x + \" Y:\" + this._y + \" Z:\" + this._z + \"}\";\n  };\n  /**\r\n   * Gets the class name\r\n   * @returns the string \"Vector3\"\r\n   */\n\n\n  Vector3.prototype.getClassName = function () {\n    return \"Vector3\";\n  };\n  /**\r\n   * Creates the Vector3 hash code\r\n   * @returns a number which tends to be unique between Vector3 instances\r\n   */\n\n\n  Vector3.prototype.getHashCode = function () {\n    var hash = this._x | 0;\n    hash = hash * 397 ^ (this._y | 0);\n    hash = hash * 397 ^ (this._z | 0);\n    return hash;\n  }; // Operators\n\n  /**\r\n   * Creates an array containing three elements : the coordinates of the Vector3\r\n   * @returns a new array of numbers\r\n   */\n\n\n  Vector3.prototype.asArray = function () {\n    var result = [];\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\r\n   * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\r\n   * @param array defines the destination array\r\n   * @param index defines the offset in the destination array\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.toArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    array[index] = this._x;\n    array[index + 1] = this._y;\n    array[index + 2] = this._z;\n    return this;\n  };\n  /**\r\n   * Update the current vector from an array\r\n   * @param array defines the destination array\r\n   * @param index defines the offset in the destination array\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector3.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\r\n   * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\r\n   * @returns a new Quaternion object, computed from the Vector3 coordinates\r\n   */\n\n\n  Vector3.prototype.toQuaternion = function () {\n    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\n  };\n  /**\r\n   * Adds the given vector to the current Vector3\r\n   * @param otherVector defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.addInPlace = function (otherVector) {\n    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\n  };\n  /**\r\n   * Adds the given coordinates to the current Vector3\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.addInPlaceFromFloats = function (x, y, z) {\n    this.x += x;\n    this.y += y;\n    this.z += z;\n    return this;\n  };\n  /**\r\n   * Gets a new Vector3, result of the addition the current Vector3 and the given vector\r\n   * @param otherVector defines the second operand\r\n   * @returns the resulting Vector3\r\n   */\n\n\n  Vector3.prototype.add = function (otherVector) {\n    return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n  };\n  /**\r\n   * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\r\n   * @param otherVector defines the second operand\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.addToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n  };\n  /**\r\n   * Subtract the given vector from the current Vector3\r\n   * @param otherVector defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector._x;\n    this.y -= otherVector._y;\n    this.z -= otherVector._z;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\r\n   * @param otherVector defines the second operand\r\n   * @returns the resulting Vector3\r\n   */\n\n\n  Vector3.prototype.subtract = function (otherVector) {\n    return new Vector3(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\n  };\n  /**\r\n   * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\r\n   * @param otherVector defines the second operand\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.subtractToRef = function (otherVector, result) {\n    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\n  };\n  /**\r\n   * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the resulting Vector3\r\n   */\n\n\n  Vector3.prototype.subtractFromFloats = function (x, y, z) {\n    return new Vector3(this._x - x, this._y - y, this._z - z);\n  };\n  /**\r\n   * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.subtractFromFloatsToRef = function (x, y, z, result) {\n    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\n  };\n  /**\r\n   * Gets a new Vector3 set with the current Vector3 negated coordinates\r\n   * @returns a new Vector3\r\n   */\n\n\n  Vector3.prototype.negate = function () {\n    return new Vector3(-this._x, -this._y, -this._z);\n  };\n  /**\r\n   * Negate this vector in place\r\n   * @returns this\r\n   */\n\n\n  Vector3.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  };\n  /**\r\n   * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\n  };\n  /**\r\n   * Multiplies the Vector3 coordinates by the float \"scale\"\r\n   * @param scale defines the multiplier factor\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    this.z *= scale;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\r\n   * @param scale defines the multiplier factor\r\n   * @returns a new Vector3\r\n   */\n\n\n  Vector3.prototype.scale = function (scale) {\n    return new Vector3(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\r\n   * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\r\n   * @param scale defines the multiplier factor\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.scaleToRef = function (scale, result) {\n    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\r\n   * Scale the current Vector3 values by a factor and add the result to a given Vector3\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the unmodified current Vector3\r\n   */\n\n\n  Vector3.prototype.scaleAndAddToRef = function (scale, result) {\n    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\n  };\n  /**\r\n   * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n   * @param origin defines the origin of the projection ray\r\n   * @param plane defines the plane to project to\r\n   * @returns the projected vector3\r\n   */\n\n\n  Vector3.prototype.projectOnPlane = function (plane, origin) {\n    var result = Vector3.Zero();\n    this.projectOnPlaneToRef(plane, origin, result);\n    return result;\n  };\n  /**\r\n   * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n   * @param origin defines the origin of the projection ray\r\n   * @param plane defines the plane to project to\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.prototype.projectOnPlaneToRef = function (plane, origin, result) {\n    var n = plane.normal;\n    var d = plane.d;\n    var V = MathTmp.Vector3[0]; // ray direction\n\n    this.subtractToRef(origin, V);\n    V.normalize();\n    var denom = Vector3.Dot(V, n);\n    var t = -(Vector3.Dot(origin, n) + d) / denom; // P = P0 + t*V\n\n    var scaledV = V.scaleInPlace(t);\n    origin.addToRef(scaledV, result);\n  };\n  /**\r\n   * Returns true if the current Vector3 and the given vector coordinates are strictly equal\r\n   * @param otherVector defines the second operand\r\n   * @returns true if both vectors are equals\r\n   */\n\n\n  Vector3.prototype.equals = function (otherVector) {\n    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\n  };\n  /**\r\n   * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\r\n   * @param otherVector defines the second operand\r\n   * @param epsilon defines the minimal distance to define values as equals\r\n   * @returns true if both vectors are distant less than epsilon\r\n   */\n\n\n  Vector3.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);\n  };\n  /**\r\n   * Returns true if the current Vector3 coordinates equals the given floats\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns true if both vectors are equals\r\n   */\n\n\n  Vector3.prototype.equalsToFloats = function (x, y, z) {\n    return this._x === x && this._y === y && this._z === z;\n  };\n  /**\r\n   * Multiplies the current Vector3 coordinates by the given ones\r\n   * @param otherVector defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector._x;\n    this.y *= otherVector._y;\n    this.z *= otherVector._z;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\r\n   * @param otherVector defines the second operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.prototype.multiply = function (otherVector) {\n    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\n  };\n  /**\r\n   * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\r\n   * @param otherVector defines the second operand\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.multiplyToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\n  };\n  /**\r\n   * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.prototype.multiplyByFloats = function (x, y, z) {\n    return new Vector3(this._x * x, this._y * y, this._z * z);\n  };\n  /**\r\n   * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\r\n   * @param otherVector defines the second operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.prototype.divide = function (otherVector) {\n    return new Vector3(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n  };\n  /**\r\n   * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\r\n   * @param otherVector defines the second operand\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector3.prototype.divideToRef = function (otherVector, result) {\n    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n  };\n  /**\r\n   * Divides the current Vector3 coordinates by the given ones.\r\n   * @param otherVector defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\r\n   * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\r\n   * @param other defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.minimizeInPlace = function (other) {\n    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\n  };\n  /**\r\n   * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\r\n   * @param other defines the second operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.maximizeInPlace = function (other) {\n    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\n  };\n  /**\r\n   * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.minimizeInPlaceFromFloats = function (x, y, z) {\n    if (x < this._x) {\n      this.x = x;\n    }\n\n    if (y < this._y) {\n      this.y = y;\n    }\n\n    if (z < this._z) {\n      this.z = z;\n    }\n\n    return this;\n  };\n  /**\r\n   * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.maximizeInPlaceFromFloats = function (x, y, z) {\n    if (x > this._x) {\n      this.x = x;\n    }\n\n    if (y > this._y) {\n      this.y = y;\n    }\n\n    if (z > this._z) {\n      this.z = z;\n    }\n\n    return this;\n  };\n  /**\r\n   * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\r\n   * Check if is non uniform within a certain amount of decimal places to account for this\r\n   * @param epsilon the amount the values can differ\r\n   * @returns if the the vector is non uniform to a certain number of decimal places\r\n   */\n\n\n  Vector3.prototype.isNonUniformWithinEpsilon = function (epsilon) {\n    var absX = Math.abs(this._x);\n    var absY = Math.abs(this._y);\n\n    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\n      return true;\n    }\n\n    var absZ = Math.abs(this._z);\n\n    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\n      return true;\n    }\n\n    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(Vector3.prototype, \"isNonUniform\", {\n    /**\r\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\r\n     */\n    get: function () {\n      var absX = Math.abs(this._x);\n      var absY = Math.abs(this._y);\n\n      if (absX !== absY) {\n        return true;\n      }\n\n      var absZ = Math.abs(this._z);\n\n      if (absX !== absZ) {\n        return true;\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a new Vector3 from current Vector3 floored values\r\n   * @returns a new Vector3\r\n   */\n\n  Vector3.prototype.floor = function () {\n    return new Vector3(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\n  };\n  /**\r\n   * Gets a new Vector3 from current Vector3 floored values\r\n   * @returns a new Vector3\r\n   */\n\n\n  Vector3.prototype.fract = function () {\n    return new Vector3(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\n  }; // Properties\n\n  /**\r\n   * Gets the length of the Vector3\r\n   * @returns the length of the Vector3\r\n   */\n\n\n  Vector3.prototype.length = function () {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\n  };\n  /**\r\n   * Gets the squared length of the Vector3\r\n   * @returns squared length of the Vector3\r\n   */\n\n\n  Vector3.prototype.lengthSquared = function () {\n    return this._x * this._x + this._y * this._y + this._z * this._z;\n  };\n  /**\r\n   * Normalize the current Vector3.\r\n   * Please note that this is an in place operation.\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.normalize = function () {\n    return this.normalizeFromLength(this.length());\n  };\n  /**\r\n   * Reorders the x y z properties of the vector in place\r\n   * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\r\n   * @returns the current updated vector\r\n   */\n\n\n  Vector3.prototype.reorderInPlace = function (order) {\n    var _this = this;\n\n    order = order.toLowerCase();\n\n    if (order === \"xyz\") {\n      return this;\n    }\n\n    MathTmp.Vector3[0].copyFrom(this);\n    [\"x\", \"y\", \"z\"].forEach(function (val, i) {\n      _this[val] = MathTmp.Vector3[0][order[i]];\n    });\n    return this;\n  };\n  /**\r\n   * Rotates the vector around 0,0,0 by a quaternion\r\n   * @param quaternion the rotation quaternion\r\n   * @param result vector to store the result\r\n   * @returns the resulting vector\r\n   */\n\n\n  Vector3.prototype.rotateByQuaternionToRef = function (quaternion, result) {\n    quaternion.toRotationMatrix(MathTmp.Matrix[0]);\n    Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\n    return result;\n  };\n  /**\r\n   * Rotates a vector around a given point\r\n   * @param quaternion the rotation quaternion\r\n   * @param point the point to rotate around\r\n   * @param result vector to store the result\r\n   * @returns the resulting vector\r\n   */\n\n\n  Vector3.prototype.rotateByQuaternionAroundPointToRef = function (quaternion, point, result) {\n    this.subtractToRef(point, MathTmp.Vector3[0]);\n    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\n    point.addToRef(MathTmp.Vector3[0], result);\n    return result;\n  };\n  /**\r\n   * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\r\n   * The cross product is then orthogonal to both current and \"other\"\r\n   * @param other defines the right operand\r\n   * @returns the cross product\r\n   */\n\n\n  Vector3.prototype.cross = function (other) {\n    return Vector3.Cross(this, other);\n  };\n  /**\r\n   * Normalize the current Vector3 with the given input length.\r\n   * Please note that this is an in place operation.\r\n   * @param len the length of the vector\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.normalizeFromLength = function (len) {\n    if (len === 0 || len === 1.0) {\n      return this;\n    }\n\n    return this.scaleInPlace(1.0 / len);\n  };\n  /**\r\n   * Normalize the current Vector3 to a new vector\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.prototype.normalizeToNew = function () {\n    var normalized = new Vector3(0, 0, 0);\n    this.normalizeToRef(normalized);\n    return normalized;\n  };\n  /**\r\n   * Normalize the current Vector3 to the reference\r\n   * @param reference define the Vector3 to update\r\n   * @returns the updated Vector3\r\n   */\n\n\n  Vector3.prototype.normalizeToRef = function (reference) {\n    var len = this.length();\n\n    if (len === 0 || len === 1.0) {\n      return reference.copyFromFloats(this._x, this._y, this._z);\n    }\n\n    return this.scaleToRef(1.0 / len, reference);\n  };\n  /**\r\n   * Creates a new Vector3 copied from the current Vector3\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.prototype.clone = function () {\n    return new Vector3(this._x, this._y, this._z);\n  };\n  /**\r\n   * Copies the given vector coordinates to the current Vector3 ones\r\n   * @param source defines the source Vector3\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.copyFrom = function (source) {\n    return this.copyFromFloats(source._x, source._y, source._z);\n  };\n  /**\r\n   * Copies the given floats to the current Vector3 coordinates\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.copyFromFloats = function (x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  };\n  /**\r\n   * Copies the given floats to the current Vector3 coordinates\r\n   * @param x defines the x coordinate of the operand\r\n   * @param y defines the y coordinate of the operand\r\n   * @param z defines the z coordinate of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.set = function (x, y, z) {\n    return this.copyFromFloats(x, y, z);\n  };\n  /**\r\n   * Copies the given float to the current Vector3 coordinates\r\n   * @param v defines the x, y and z coordinates of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector3.prototype.setAll = function (v) {\n    this.x = this.y = this.z = v;\n    return this;\n  }; // Statics\n\n  /**\r\n   * Get the clip factor between two vectors\r\n   * @param vector0 defines the first operand\r\n   * @param vector1 defines the second operand\r\n   * @param axis defines the axis to use\r\n   * @param size defines the size along the axis\r\n   * @returns the clip factor\r\n   */\n\n\n  Vector3.GetClipFactor = function (vector0, vector1, axis, size) {\n    var d0 = Vector3.Dot(vector0, axis) - size;\n    var d1 = Vector3.Dot(vector1, axis) - size;\n    var s = d0 / (d0 - d1);\n    return s;\n  };\n  /**\r\n   * Get angle between two vectors\r\n   * @param vector0 angle between vector0 and vector1\r\n   * @param vector1 angle between vector0 and vector1\r\n   * @param normal direction of the normal\r\n   * @return the angle between vector0 and vector1\r\n   */\n\n\n  Vector3.GetAngleBetweenVectors = function (vector0, vector1, normal) {\n    var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);\n    var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);\n    var dot = Vector3.Dot(v0, v1);\n    var n = MathTmp.Vector3[3];\n    Vector3.CrossToRef(v0, v1, n);\n\n    if (Vector3.Dot(n, normal) > 0) {\n      return Math.acos(dot);\n    }\n\n    return -Math.acos(dot);\n  };\n  /**\r\n   * Returns a new Vector3 set from the index \"offset\" of the given array\r\n   * @param array defines the source array\r\n   * @param offset defines the offset in the source array\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n  };\n  /**\r\n   * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\r\n   * @param array defines the source array\r\n   * @param offset defines the offset in the source array\r\n   * @returns the new Vector3\r\n   * @deprecated Please use FromArray instead.\r\n   */\n\n\n  Vector3.FromFloatArray = function (array, offset) {\n    return Vector3.FromArray(array, offset);\n  };\n  /**\r\n   * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\r\n   * @param array defines the source array\r\n   * @param offset defines the offset in the source array\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n  };\n  /**\r\n   * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\r\n   * @param array defines the source array\r\n   * @param offset defines the offset in the source array\r\n   * @param result defines the Vector3 where to store the result\r\n   * @deprecated Please use FromArrayToRef instead.\r\n   */\n\n\n  Vector3.FromFloatArrayToRef = function (array, offset, result) {\n    return Vector3.FromArrayToRef(array, offset, result);\n  };\n  /**\r\n   * Sets the given vector \"result\" with the given floats.\r\n   * @param x defines the x coordinate of the source\r\n   * @param y defines the y coordinate of the source\r\n   * @param z defines the z coordinate of the source\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.FromFloatsToRef = function (x, y, z, result) {\n    result.copyFromFloats(x, y, z);\n  };\n  /**\r\n   * Returns a new Vector3 set to (0.0, 0.0, 0.0)\r\n   * @returns a new empty Vector3\r\n   */\n\n\n  Vector3.Zero = function () {\n    return new Vector3(0.0, 0.0, 0.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (1.0, 1.0, 1.0)\r\n   * @returns a new unit Vector3\r\n   */\n\n\n  Vector3.One = function () {\n    return new Vector3(1.0, 1.0, 1.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (0.0, 1.0, 0.0)\r\n   * @returns a new up Vector3\r\n   */\n\n\n  Vector3.Up = function () {\n    return new Vector3(0.0, 1.0, 0.0);\n  };\n\n  Object.defineProperty(Vector3, \"UpReadOnly\", {\n    /**\r\n     * Gets a up Vector3 that must not be updated\r\n     */\n    get: function () {\n      return Vector3._UpReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Vector3, \"ZeroReadOnly\", {\n    /**\r\n     * Gets a zero Vector3 that must not be updated\r\n     */\n    get: function () {\n      return Vector3._ZeroReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a new Vector3 set to (0.0, -1.0, 0.0)\r\n   * @returns a new down Vector3\r\n   */\n\n  Vector3.Down = function () {\n    return new Vector3(0.0, -1.0, 0.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (0.0, 0.0, 1.0)\r\n   * @param rightHandedSystem is the scene right-handed (negative z)\r\n   * @returns a new forward Vector3\r\n   */\n\n\n  Vector3.Forward = function (rightHandedSystem) {\n    if (rightHandedSystem === void 0) {\n      rightHandedSystem = false;\n    }\n\n    return new Vector3(0.0, 0.0, rightHandedSystem ? -1.0 : 1.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (0.0, 0.0, -1.0)\r\n   * @param rightHandedSystem is the scene right-handed (negative-z)\r\n   * @returns a new forward Vector3\r\n   */\n\n\n  Vector3.Backward = function (rightHandedSystem) {\n    if (rightHandedSystem === void 0) {\n      rightHandedSystem = false;\n    }\n\n    return new Vector3(0.0, 0.0, rightHandedSystem ? 1.0 : -1.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (1.0, 0.0, 0.0)\r\n   * @returns a new right Vector3\r\n   */\n\n\n  Vector3.Right = function () {\n    return new Vector3(1.0, 0.0, 0.0);\n  };\n  /**\r\n   * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\r\n   * @returns a new left Vector3\r\n   */\n\n\n  Vector3.Left = function () {\n    return new Vector3(-1.0, 0.0, 0.0);\n  };\n  /**\r\n   * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\r\n   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n   * @param vector defines the Vector3 to transform\r\n   * @param transformation defines the transformation matrix\r\n   * @returns the transformed Vector3\r\n   */\n\n\n  Vector3.TransformCoordinates = function (vector, transformation) {\n    var result = Vector3.Zero();\n    Vector3.TransformCoordinatesToRef(vector, transformation, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\r\n   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n   * @param vector defines the Vector3 to transform\r\n   * @param transformation defines the transformation matrix\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.TransformCoordinatesToRef = function (vector, transformation, result) {\n    Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n  };\n  /**\r\n   * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\r\n   * This method computes tranformed coordinates only, not transformed direction vectors\r\n   * @param x define the x coordinate of the source vector\r\n   * @param y define the y coordinate of the source vector\r\n   * @param z define the z coordinate of the source vector\r\n   * @param transformation defines the transformation matrix\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n    var m = transformation.m;\n    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n    var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n    result.x = rx * rw;\n    result.y = ry * rw;\n    result.z = rz * rw;\n  };\n  /**\r\n   * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\r\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n   * @param vector defines the Vector3 to transform\r\n   * @param transformation defines the transformation matrix\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.TransformNormal = function (vector, transformation) {\n    var result = Vector3.Zero();\n    Vector3.TransformNormalToRef(vector, transformation, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\r\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n   * @param vector defines the Vector3 to transform\r\n   * @param transformation defines the transformation matrix\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.TransformNormalToRef = function (vector, transformation, result) {\n    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\r\n   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n   * @param x define the x coordinate of the source vector\r\n   * @param y define the y coordinate of the source vector\r\n   * @param z define the z coordinate of the source vector\r\n   * @param transformation defines the transformation matrix\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.TransformNormalFromFloatsToRef = function (x, y, z, transformation, result) {\n    var m = transformation.m;\n    result.x = x * m[0] + y * m[4] + z * m[8];\n    result.y = x * m[1] + y * m[5] + z * m[9];\n    result.z = x * m[2] + y * m[6] + z * m[10];\n  };\n  /**\r\n   * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\r\n   * @param value1 defines the first control point\r\n   * @param value2 defines the second control point\r\n   * @param value3 defines the third control point\r\n   * @param value4 defines the fourth control point\r\n   * @param amount defines the amount on the spline to use\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.CatmullRom = function (value1, value2, value3, value4, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var x = 0.5 * (2.0 * value2._x + (-value1._x + value3._x) * amount + (2.0 * value1._x - 5.0 * value2._x + 4.0 * value3._x - value4._x) * squared + (-value1._x + 3.0 * value2._x - 3.0 * value3._x + value4._x) * cubed);\n    var y = 0.5 * (2.0 * value2._y + (-value1._y + value3._y) * amount + (2.0 * value1._y - 5.0 * value2._y + 4.0 * value3._y - value4._y) * squared + (-value1._y + 3.0 * value2._y - 3.0 * value3._y + value4._y) * cubed);\n    var z = 0.5 * (2.0 * value2._z + (-value1._z + value3._z) * amount + (2.0 * value1._z - 5.0 * value2._z + 4.0 * value3._z - value4._z) * squared + (-value1._z + 3.0 * value2._z - 3.0 * value3._z + value4._z) * cubed);\n    return new Vector3(x, y, z);\n  };\n  /**\r\n   * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n   * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n   * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n   * @param value defines the current value\r\n   * @param min defines the lower range value\r\n   * @param max defines the upper range value\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Clamp = function (value, min, max) {\n    var v = new Vector3();\n    Vector3.ClampToRef(value, min, max, v);\n    return v;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n   * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n   * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n   * @param value defines the current value\r\n   * @param min defines the lower range value\r\n   * @param max defines the upper range value\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.ClampToRef = function (value, min, max, result) {\n    var x = value._x;\n    x = x > max._x ? max._x : x;\n    x = x < min._x ? min._x : x;\n    var y = value._y;\n    y = y > max._y ? max._y : y;\n    y = y < min._y ? min._y : y;\n    var z = value._z;\n    z = z > max._z ? max._z : z;\n    z = z < min._z ? min._z : z;\n    result.copyFromFloats(x, y, z);\n  };\n  /**\r\n   * Checks if a given vector is inside a specific range\r\n   * @param v defines the vector to test\r\n   * @param min defines the minimum range\r\n   * @param max defines the maximum range\r\n   */\n\n\n  Vector3.CheckExtends = function (v, min, max) {\n    min.minimizeInPlace(v);\n    max.maximizeInPlace(v);\n  };\n  /**\r\n   * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n   * @param value1 defines the first control point\r\n   * @param tangent1 defines the first tangent vector\r\n   * @param value2 defines the second control point\r\n   * @param tangent2 defines the second tangent vector\r\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n    return new Vector3(x, y, z);\n  };\n  /**\r\n   * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\r\n   * @param start defines the start value\r\n   * @param end defines the end value\r\n   * @param amount max defines amount between both (between 0 and 1)\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Lerp = function (start, end, amount) {\n    var result = new Vector3(0, 0, 0);\n    Vector3.LerpToRef(start, end, amount, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\r\n   * @param start defines the start value\r\n   * @param end defines the end value\r\n   * @param amount max defines amount between both (between 0 and 1)\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.LerpToRef = function (start, end, amount, result) {\n    result.x = start._x + (end._x - start._x) * amount;\n    result.y = start._y + (end._y - start._y) * amount;\n    result.z = start._z + (end._z - start._z) * amount;\n  };\n  /**\r\n   * Returns the dot product (float) between the vectors \"left\" and \"right\"\r\n   * @param left defines the left operand\r\n   * @param right defines the right operand\r\n   * @returns the dot product\r\n   */\n\n\n  Vector3.Dot = function (left, right) {\n    return left._x * right._x + left._y * right._y + left._z * right._z;\n  };\n  /**\r\n   * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\r\n   * The cross product is then orthogonal to both \"left\" and \"right\"\r\n   * @param left defines the left operand\r\n   * @param right defines the right operand\r\n   * @returns the cross product\r\n   */\n\n\n  Vector3.Cross = function (left, right) {\n    var result = Vector3.Zero();\n    Vector3.CrossToRef(left, right, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\r\n   * The cross product is then orthogonal to both \"left\" and \"right\"\r\n   * @param left defines the left operand\r\n   * @param right defines the right operand\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.CrossToRef = function (left, right, result) {\n    var x = left._y * right._z - left._z * right._y;\n    var y = left._z * right._x - left._x * right._z;\n    var z = left._x * right._y - left._y * right._x;\n    result.copyFromFloats(x, y, z);\n  };\n  /**\r\n   * Returns a new Vector3 as the normalization of the given vector\r\n   * @param vector defines the Vector3 to normalize\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Normalize = function (vector) {\n    var result = Vector3.Zero();\n    Vector3.NormalizeToRef(vector, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the normalization of the given first vector\r\n   * @param vector defines the Vector3 to normalize\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.NormalizeToRef = function (vector, result) {\n    vector.normalizeToRef(result);\n  };\n  /**\r\n   * Project a Vector3 onto screen space\r\n   * @param vector defines the Vector3 to project\r\n   * @param world defines the world matrix to use\r\n   * @param transform defines the transform (view x projection) matrix to use\r\n   * @param viewport defines the screen viewport to use\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Project = function (vector, world, transform, viewport) {\n    var result = new Vector3();\n    Vector3.ProjectToRef(vector, world, transform, viewport, result);\n    return result;\n  };\n  /**\r\n   * Project a Vector3 onto screen space to reference\r\n   * @param vector defines the Vector3 to project\r\n   * @param world defines the world matrix to use\r\n   * @param transform defines the transform (view x projection) matrix to use\r\n   * @param viewport defines the screen viewport to use\r\n   * @param result the vector in which the screen space will be stored\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.ProjectToRef = function (vector, world, transform, viewport, result) {\n    var cw = viewport.width;\n    var ch = viewport.height;\n    var cx = viewport.x;\n    var cy = viewport.y;\n    var viewportMatrix = MathTmp.Matrix[1];\n    Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(transform, matrix);\n    matrix.multiplyToRef(viewportMatrix, matrix);\n    Vector3.TransformCoordinatesToRef(vector, matrix, result);\n    return result;\n  };\n  /** @hidden */\n\n\n  Vector3._UnprojectFromInvertedMatrixToRef = function (source, matrix, result) {\n    Vector3.TransformCoordinatesToRef(source, matrix, result);\n    var m = matrix.m;\n    var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\n\n    if (Scalar.WithinEpsilon(num, 1.0)) {\n      result.scaleInPlace(1.0 / num);\n    }\n  };\n  /**\r\n   * Unproject from screen space to object space\r\n   * @param source defines the screen space Vector3 to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param transform defines the transform (view x projection) matrix to use\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.UnprojectFromTransform = function (source, viewportWidth, viewportHeight, world, transform) {\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(transform, matrix);\n    matrix.invert();\n    source.x = source._x / viewportWidth * 2 - 1;\n    source.y = -(source._y / viewportHeight * 2 - 1);\n    var vector = new Vector3();\n\n    Vector3._UnprojectFromInvertedMatrixToRef(source, matrix, vector);\n\n    return vector;\n  };\n  /**\r\n   * Unproject from screen space to object space\r\n   * @param source defines the screen space Vector3 to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param view defines the view matrix to use\r\n   * @param projection defines the projection matrix to use\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Unproject = function (source, viewportWidth, viewportHeight, world, view, projection) {\n    var result = Vector3.Zero();\n    Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\n    return result;\n  };\n  /**\r\n   * Unproject from screen space to object space\r\n   * @param source defines the screen space Vector3 to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param view defines the view matrix to use\r\n   * @param projection defines the projection matrix to use\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.UnprojectToRef = function (source, viewportWidth, viewportHeight, world, view, projection, result) {\n    Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\n  };\n  /**\r\n   * Unproject from screen space to object space\r\n   * @param sourceX defines the screen space x coordinate to use\r\n   * @param sourceY defines the screen space y coordinate to use\r\n   * @param sourceZ defines the screen space z coordinate to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param view defines the view matrix to use\r\n   * @param projection defines the projection matrix to use\r\n   * @param result defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.UnprojectFloatsToRef = function (sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    var screenSource = MathTmp.Vector3[0];\n    screenSource.x = sourceX / viewportWidth * 2 - 1;\n    screenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    screenSource.z = 2 * sourceZ - 1.0;\n\n    Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\n  };\n  /**\r\n   * Gets the minimal coordinate values between two Vector3\r\n   * @param left defines the first operand\r\n   * @param right defines the second operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Minimize = function (left, right) {\n    var min = left.clone();\n    min.minimizeInPlace(right);\n    return min;\n  };\n  /**\r\n   * Gets the maximal coordinate values between two Vector3\r\n   * @param left defines the first operand\r\n   * @param right defines the second operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Maximize = function (left, right) {\n    var max = left.clone();\n    max.maximizeInPlace(right);\n    return max;\n  };\n  /**\r\n   * Returns the distance between the vectors \"value1\" and \"value2\"\r\n   * @param value1 defines the first operand\r\n   * @param value2 defines the second operand\r\n   * @returns the distance\r\n   */\n\n\n  Vector3.Distance = function (value1, value2) {\n    return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n  };\n  /**\r\n   * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n   * @param value1 defines the first operand\r\n   * @param value2 defines the second operand\r\n   * @returns the squared distance\r\n   */\n\n\n  Vector3.DistanceSquared = function (value1, value2) {\n    var x = value1._x - value2._x;\n    var y = value1._y - value2._y;\n    var z = value1._z - value2._z;\n    return x * x + y * y + z * z;\n  };\n  /**\r\n   * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\r\n   * @param value1 defines the first operand\r\n   * @param value2 defines the second operand\r\n   * @returns the new Vector3\r\n   */\n\n\n  Vector3.Center = function (value1, value2) {\n    var center = value1.add(value2);\n    center.scaleInPlace(0.5);\n    return center;\n  };\n  /**\r\n   * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\r\n   * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\r\n   * to something in order to rotate it from its local system to the given target system\r\n   * Note: axis1, axis2 and axis3 are normalized during this operation\r\n   * @param axis1 defines the first axis\r\n   * @param axis2 defines the second axis\r\n   * @param axis3 defines the third axis\r\n   * @returns a new Vector3\r\n   */\n\n\n  Vector3.RotationFromAxis = function (axis1, axis2, axis3) {\n    var rotation = Vector3.Zero();\n    Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n    return rotation;\n  };\n  /**\r\n   * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\r\n   * @param axis1 defines the first axis\r\n   * @param axis2 defines the second axis\r\n   * @param axis3 defines the third axis\r\n   * @param ref defines the Vector3 where to store the result\r\n   */\n\n\n  Vector3.RotationFromAxisToRef = function (axis1, axis2, axis3, ref) {\n    var quat = MathTmp.Quaternion[0];\n    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n    quat.toEulerAnglesToRef(ref);\n  };\n\n  Vector3._UpReadOnly = Vector3.Up();\n  Vector3._ZeroReadOnly = Vector3.Zero();\n  return Vector3;\n}();\n\nexport { Vector3 };\n/**\r\n * Vector4 class created for EulerAngle class conversion to Quaternion\r\n */\n\nvar Vector4 =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Vector4 object from the given floats.\r\n   * @param x x value of the vector\r\n   * @param y y value of the vector\r\n   * @param z z value of the vector\r\n   * @param w w value of the vector\r\n   */\n  function Vector4(\n  /** x value of the vector */\n  x,\n  /** y value of the vector */\n  y,\n  /** z value of the vector */\n  z,\n  /** w value of the vector */\n  w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  /**\r\n   * Returns the string with the Vector4 coordinates.\r\n   * @returns a string containing all the vector values\r\n   */\n\n\n  Vector4.prototype.toString = function () {\n    return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n  };\n  /**\r\n   * Returns the string \"Vector4\".\r\n   * @returns \"Vector4\"\r\n   */\n\n\n  Vector4.prototype.getClassName = function () {\n    return \"Vector4\";\n  };\n  /**\r\n   * Returns the Vector4 hash code.\r\n   * @returns a unique hash code\r\n   */\n\n\n  Vector4.prototype.getHashCode = function () {\n    var hash = this.x | 0;\n    hash = hash * 397 ^ (this.y | 0);\n    hash = hash * 397 ^ (this.z | 0);\n    hash = hash * 397 ^ (this.w | 0);\n    return hash;\n  }; // Operators\n\n  /**\r\n   * Returns a new array populated with 4 elements : the Vector4 coordinates.\r\n   * @returns the resulting array\r\n   */\n\n\n  Vector4.prototype.asArray = function () {\n    var result = new Array();\n    this.toArray(result, 0);\n    return result;\n  };\n  /**\r\n   * Populates the given array from the given index with the Vector4 coordinates.\r\n   * @param array array to populate\r\n   * @param index index of the array to start at (default: 0)\r\n   * @returns the Vector4.\r\n   */\n\n\n  Vector4.prototype.toArray = function (array, index) {\n    if (index === undefined) {\n      index = 0;\n    }\n\n    array[index] = this.x;\n    array[index + 1] = this.y;\n    array[index + 2] = this.z;\n    array[index + 3] = this.w;\n    return this;\n  };\n  /**\r\n   * Update the current vector from an array\r\n   * @param array defines the destination array\r\n   * @param index defines the offset in the destination array\r\n   * @returns the current Vector3\r\n   */\n\n\n  Vector4.prototype.fromArray = function (array, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    Vector4.FromArrayToRef(array, index, this);\n    return this;\n  };\n  /**\r\n   * Adds the given vector to the current Vector4.\r\n   * @param otherVector the vector to add\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.addInPlace = function (otherVector) {\n    this.x += otherVector.x;\n    this.y += otherVector.y;\n    this.z += otherVector.z;\n    this.w += otherVector.w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\r\n   * @param otherVector the vector to add\r\n   * @returns the resulting vector\r\n   */\n\n\n  Vector4.prototype.add = function (otherVector) {\n    return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n  };\n  /**\r\n   * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\r\n   * @param otherVector the vector to add\r\n   * @param result the vector to store the result\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.addToRef = function (otherVector, result) {\n    result.x = this.x + otherVector.x;\n    result.y = this.y + otherVector.y;\n    result.z = this.z + otherVector.z;\n    result.w = this.w + otherVector.w;\n    return this;\n  };\n  /**\r\n   * Subtract in place the given vector from the current Vector4.\r\n   * @param otherVector the vector to subtract\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.subtractInPlace = function (otherVector) {\n    this.x -= otherVector.x;\n    this.y -= otherVector.y;\n    this.z -= otherVector.z;\n    this.w -= otherVector.w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\r\n   * @param otherVector the vector to add\r\n   * @returns the new vector with the result\r\n   */\n\n\n  Vector4.prototype.subtract = function (otherVector) {\n    return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\r\n   * @param otherVector the vector to subtract\r\n   * @param result the vector to store the result\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.subtractToRef = function (otherVector, result) {\n    result.x = this.x - otherVector.x;\n    result.y = this.y - otherVector.y;\n    result.z = this.z - otherVector.z;\n    result.w = this.w - otherVector.w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n   */\n\n  /**\r\n   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n   * @param x value to subtract\r\n   * @param y value to subtract\r\n   * @param z value to subtract\r\n   * @param w value to subtract\r\n   * @returns new vector containing the result\r\n   */\n\n\n  Vector4.prototype.subtractFromFloats = function (x, y, z, w) {\n    return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n  };\n  /**\r\n   * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n   * @param x value to subtract\r\n   * @param y value to subtract\r\n   * @param z value to subtract\r\n   * @param w value to subtract\r\n   * @param result the vector to store the result in\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.subtractFromFloatsToRef = function (x, y, z, w, result) {\n    result.x = this.x - x;\n    result.y = this.y - y;\n    result.z = this.z - z;\n    result.w = this.w - w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 set with the current Vector4 negated coordinates.\r\n   * @returns a new vector with the negated values\r\n   */\n\n\n  Vector4.prototype.negate = function () {\n    return new Vector4(-this.x, -this.y, -this.z, -this.w);\n  };\n  /**\r\n   * Negate this vector in place\r\n   * @returns this\r\n   */\n\n\n  Vector4.prototype.negateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    this.w *= -1;\n    return this;\n  };\n  /**\r\n   * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\r\n   * @param result defines the Vector3 object where to store the result\r\n   * @returns the current Vector4\r\n   */\n\n\n  Vector4.prototype.negateToRef = function (result) {\n    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\n  };\n  /**\r\n   * Multiplies the current Vector4 coordinates by scale (float).\r\n   * @param scale the number to scale with\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.scaleInPlace = function (scale) {\n    this.x *= scale;\n    this.y *= scale;\n    this.z *= scale;\n    this.w *= scale;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\r\n   * @param scale the number to scale with\r\n   * @returns a new vector with the result\r\n   */\n\n\n  Vector4.prototype.scale = function (scale) {\n    return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n  };\n  /**\r\n   * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\r\n   * @param scale the number to scale with\r\n   * @param result a vector to store the result in\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.scaleToRef = function (scale, result) {\n    result.x = this.x * scale;\n    result.y = this.y * scale;\n    result.z = this.z * scale;\n    result.w = this.w * scale;\n    return this;\n  };\n  /**\r\n   * Scale the current Vector4 values by a factor and add the result to a given Vector4\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Vector4 object where to store the result\r\n   * @returns the unmodified current Vector4\r\n   */\n\n\n  Vector4.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this.x * scale;\n    result.y += this.y * scale;\n    result.z += this.z * scale;\n    result.w += this.w * scale;\n    return this;\n  };\n  /**\r\n   * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\r\n   * @param otherVector the vector to compare against\r\n   * @returns true if they are equal\r\n   */\n\n\n  Vector4.prototype.equals = function (otherVector) {\n    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n  };\n  /**\r\n   * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\r\n   * @param otherVector vector to compare against\r\n   * @param epsilon (Default: very small number)\r\n   * @returns true if they are equal\r\n   */\n\n\n  Vector4.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);\n  };\n  /**\r\n   * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\r\n   * @param x x value to compare against\r\n   * @param y y value to compare against\r\n   * @param z z value to compare against\r\n   * @param w w value to compare against\r\n   * @returns true if equal\r\n   */\n\n\n  Vector4.prototype.equalsToFloats = function (x, y, z, w) {\n    return this.x === x && this.y === y && this.z === z && this.w === w;\n  };\n  /**\r\n   * Multiplies in place the current Vector4 by the given one.\r\n   * @param otherVector vector to multiple with\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.multiplyInPlace = function (otherVector) {\n    this.x *= otherVector.x;\n    this.y *= otherVector.y;\n    this.z *= otherVector.z;\n    this.w *= otherVector.w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\r\n   * @param otherVector vector to multiple with\r\n   * @returns resulting new vector\r\n   */\n\n\n  Vector4.prototype.multiply = function (otherVector) {\n    return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n  };\n  /**\r\n   * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\r\n   * @param otherVector vector to multiple with\r\n   * @param result vector to store the result\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.multiplyToRef = function (otherVector, result) {\n    result.x = this.x * otherVector.x;\n    result.y = this.y * otherVector.y;\n    result.z = this.z * otherVector.z;\n    result.w = this.w * otherVector.w;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\r\n   * @param x x value multiply with\r\n   * @param y y value multiply with\r\n   * @param z z value multiply with\r\n   * @param w w value multiply with\r\n   * @returns resulting new vector\r\n   */\n\n\n  Vector4.prototype.multiplyByFloats = function (x, y, z, w) {\n    return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n  };\n  /**\r\n   * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\r\n   * @param otherVector vector to devide with\r\n   * @returns resulting new vector\r\n   */\n\n\n  Vector4.prototype.divide = function (otherVector) {\n    return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n  };\n  /**\r\n   * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\r\n   * @param otherVector vector to devide with\r\n   * @param result vector to store the result\r\n   * @returns the current Vector4.\r\n   */\n\n\n  Vector4.prototype.divideToRef = function (otherVector, result) {\n    result.x = this.x / otherVector.x;\n    result.y = this.y / otherVector.y;\n    result.z = this.z / otherVector.z;\n    result.w = this.w / otherVector.w;\n    return this;\n  };\n  /**\r\n   * Divides the current Vector3 coordinates by the given ones.\r\n   * @param otherVector vector to devide with\r\n   * @returns the updated Vector3.\r\n   */\n\n\n  Vector4.prototype.divideInPlace = function (otherVector) {\n    return this.divideToRef(otherVector, this);\n  };\n  /**\r\n   * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\r\n   * @param other defines the second operand\r\n   * @returns the current updated Vector4\r\n   */\n\n\n  Vector4.prototype.minimizeInPlace = function (other) {\n    if (other.x < this.x) {\n      this.x = other.x;\n    }\n\n    if (other.y < this.y) {\n      this.y = other.y;\n    }\n\n    if (other.z < this.z) {\n      this.z = other.z;\n    }\n\n    if (other.w < this.w) {\n      this.w = other.w;\n    }\n\n    return this;\n  };\n  /**\r\n   * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\r\n   * @param other defines the second operand\r\n   * @returns the current updated Vector4\r\n   */\n\n\n  Vector4.prototype.maximizeInPlace = function (other) {\n    if (other.x > this.x) {\n      this.x = other.x;\n    }\n\n    if (other.y > this.y) {\n      this.y = other.y;\n    }\n\n    if (other.z > this.z) {\n      this.z = other.z;\n    }\n\n    if (other.w > this.w) {\n      this.w = other.w;\n    }\n\n    return this;\n  };\n  /**\r\n   * Gets a new Vector4 from current Vector4 floored values\r\n   * @returns a new Vector4\r\n   */\n\n\n  Vector4.prototype.floor = function () {\n    return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n  };\n  /**\r\n   * Gets a new Vector4 from current Vector3 floored values\r\n   * @returns a new Vector4\r\n   */\n\n\n  Vector4.prototype.fract = function () {\n    return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n  }; // Properties\n\n  /**\r\n   * Returns the Vector4 length (float).\r\n   * @returns the length\r\n   */\n\n\n  Vector4.prototype.length = function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  };\n  /**\r\n   * Returns the Vector4 squared length (float).\r\n   * @returns the length squared\r\n   */\n\n\n  Vector4.prototype.lengthSquared = function () {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }; // Methods\n\n  /**\r\n   * Normalizes in place the Vector4.\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.normalize = function () {\n    var len = this.length();\n\n    if (len === 0) {\n      return this;\n    }\n\n    return this.scaleInPlace(1.0 / len);\n  };\n  /**\r\n   * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\r\n   * @returns this converted to a new vector3\r\n   */\n\n\n  Vector4.prototype.toVector3 = function () {\n    return new Vector3(this.x, this.y, this.z);\n  };\n  /**\r\n   * Returns a new Vector4 copied from the current one.\r\n   * @returns the new cloned vector\r\n   */\n\n\n  Vector4.prototype.clone = function () {\n    return new Vector4(this.x, this.y, this.z, this.w);\n  };\n  /**\r\n   * Updates the current Vector4 with the given one coordinates.\r\n   * @param source the source vector to copy from\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.copyFrom = function (source) {\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    this.w = source.w;\n    return this;\n  };\n  /**\r\n   * Updates the current Vector4 coordinates with the given floats.\r\n   * @param x float to copy from\r\n   * @param y float to copy from\r\n   * @param z float to copy from\r\n   * @param w float to copy from\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.copyFromFloats = function (x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  };\n  /**\r\n   * Updates the current Vector4 coordinates with the given floats.\r\n   * @param x float to set from\r\n   * @param y float to set from\r\n   * @param z float to set from\r\n   * @param w float to set from\r\n   * @returns the updated Vector4.\r\n   */\n\n\n  Vector4.prototype.set = function (x, y, z, w) {\n    return this.copyFromFloats(x, y, z, w);\n  };\n  /**\r\n   * Copies the given float to the current Vector3 coordinates\r\n   * @param v defines the x, y, z and w coordinates of the operand\r\n   * @returns the current updated Vector3\r\n   */\n\n\n  Vector4.prototype.setAll = function (v) {\n    this.x = this.y = this.z = this.w = v;\n    return this;\n  }; // Statics\n\n  /**\r\n   * Returns a new Vector4 set from the starting index of the given array.\r\n   * @param array the array to pull values from\r\n   * @param offset the offset into the array to start at\r\n   * @returns the new vector\r\n   */\n\n\n  Vector4.FromArray = function (array, offset) {\n    if (!offset) {\n      offset = 0;\n    }\n\n    return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  };\n  /**\r\n   * Updates the given vector \"result\" from the starting index of the given array.\r\n   * @param array the array to pull values from\r\n   * @param offset the offset into the array to start at\r\n   * @param result the vector to store the result in\r\n   */\n\n\n  Vector4.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n    result.w = array[offset + 3];\n  };\n  /**\r\n   * Updates the given vector \"result\" from the starting index of the given Float32Array.\r\n   * @param array the array to pull values from\r\n   * @param offset the offset into the array to start at\r\n   * @param result the vector to store the result in\r\n   */\n\n\n  Vector4.FromFloatArrayToRef = function (array, offset, result) {\n    Vector4.FromArrayToRef(array, offset, result);\n  };\n  /**\r\n   * Updates the given vector \"result\" coordinates from the given floats.\r\n   * @param x float to set from\r\n   * @param y float to set from\r\n   * @param z float to set from\r\n   * @param w float to set from\r\n   * @param result the vector to the floats in\r\n   */\n\n\n  Vector4.FromFloatsToRef = function (x, y, z, w, result) {\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    result.w = w;\n  };\n  /**\r\n   * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\r\n   * @returns the new vector\r\n   */\n\n\n  Vector4.Zero = function () {\n    return new Vector4(0.0, 0.0, 0.0, 0.0);\n  };\n  /**\r\n   * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\r\n   * @returns the new vector\r\n   */\n\n\n  Vector4.One = function () {\n    return new Vector4(1.0, 1.0, 1.0, 1.0);\n  };\n  /**\r\n   * Returns a new normalized Vector4 from the given one.\r\n   * @param vector the vector to normalize\r\n   * @returns the vector\r\n   */\n\n\n  Vector4.Normalize = function (vector) {\n    var result = Vector4.Zero();\n    Vector4.NormalizeToRef(vector, result);\n    return result;\n  };\n  /**\r\n   * Updates the given vector \"result\" from the normalization of the given one.\r\n   * @param vector the vector to normalize\r\n   * @param result the vector to store the result in\r\n   */\n\n\n  Vector4.NormalizeToRef = function (vector, result) {\n    result.copyFrom(vector);\n    result.normalize();\n  };\n  /**\r\n   * Returns a vector with the minimum values from the left and right vectors\r\n   * @param left left vector to minimize\r\n   * @param right right vector to minimize\r\n   * @returns a new vector with the minimum of the left and right vector values\r\n   */\n\n\n  Vector4.Minimize = function (left, right) {\n    var min = left.clone();\n    min.minimizeInPlace(right);\n    return min;\n  };\n  /**\r\n   * Returns a vector with the maximum values from the left and right vectors\r\n   * @param left left vector to maximize\r\n   * @param right right vector to maximize\r\n   * @returns a new vector with the maximum of the left and right vector values\r\n   */\n\n\n  Vector4.Maximize = function (left, right) {\n    var max = left.clone();\n    max.maximizeInPlace(right);\n    return max;\n  };\n  /**\r\n   * Returns the distance (float) between the vectors \"value1\" and \"value2\".\r\n   * @param value1 value to calulate the distance between\r\n   * @param value2 value to calulate the distance between\r\n   * @return the distance between the two vectors\r\n   */\n\n\n  Vector4.Distance = function (value1, value2) {\n    return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n  };\n  /**\r\n   * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\r\n   * @param value1 value to calulate the distance between\r\n   * @param value2 value to calulate the distance between\r\n   * @return the distance between the two vectors squared\r\n   */\n\n\n  Vector4.DistanceSquared = function (value1, value2) {\n    var x = value1.x - value2.x;\n    var y = value1.y - value2.y;\n    var z = value1.z - value2.z;\n    var w = value1.w - value2.w;\n    return x * x + y * y + z * z + w * w;\n  };\n  /**\r\n   * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\r\n   * @param value1 value to calulate the center between\r\n   * @param value2 value to calulate the center between\r\n   * @return the center between the two vectors\r\n   */\n\n\n  Vector4.Center = function (value1, value2) {\n    var center = value1.add(value2);\n    center.scaleInPlace(0.5);\n    return center;\n  };\n  /**\r\n   * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\r\n   * This methods computes transformed normalized direction vectors only.\r\n   * @param vector the vector to transform\r\n   * @param transformation the transformation matrix to apply\r\n   * @returns the new vector\r\n   */\n\n\n  Vector4.TransformNormal = function (vector, transformation) {\n    var result = Vector4.Zero();\n    Vector4.TransformNormalToRef(vector, transformation, result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\r\n   * This methods computes transformed normalized direction vectors only.\r\n   * @param vector the vector to transform\r\n   * @param transformation the transformation matrix to apply\r\n   * @param result the vector to store the result in\r\n   */\n\n\n  Vector4.TransformNormalToRef = function (vector, transformation, result) {\n    var m = transformation.m;\n    var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n    var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n    var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    result.w = vector.w;\n  };\n  /**\r\n   * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\r\n   * This methods computes transformed normalized direction vectors only.\r\n   * @param x value to transform\r\n   * @param y value to transform\r\n   * @param z value to transform\r\n   * @param w value to transform\r\n   * @param transformation the transformation matrix to apply\r\n   * @param result the vector to store the results in\r\n   */\n\n\n  Vector4.TransformNormalFromFloatsToRef = function (x, y, z, w, transformation, result) {\n    var m = transformation.m;\n    result.x = x * m[0] + y * m[4] + z * m[8];\n    result.y = x * m[1] + y * m[5] + z * m[9];\n    result.z = x * m[2] + y * m[6] + z * m[10];\n    result.w = w;\n  };\n  /**\r\n   * Creates a new Vector4 from a Vector3\r\n   * @param source defines the source data\r\n   * @param w defines the 4th component (default is 0)\r\n   * @returns a new Vector4\r\n   */\n\n\n  Vector4.FromVector3 = function (source, w) {\n    if (w === void 0) {\n      w = 0;\n    }\n\n    return new Vector4(source._x, source._y, source._z, w);\n  };\n\n  return Vector4;\n}();\n\nexport { Vector4 };\n/**\r\n * Class used to store quaternion data\r\n * @see https://en.wikipedia.org/wiki/Quaternion\r\n * @see https://doc.babylonjs.com/features/position,_rotation,_scaling\r\n */\n\nvar Quaternion =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new Quaternion from the given floats\r\n   * @param x defines the first component (0 by default)\r\n   * @param y defines the second component (0 by default)\r\n   * @param z defines the third component (0 by default)\r\n   * @param w defines the fourth component (1.0 by default)\r\n   */\n  function Quaternion(x, y, z, w) {\n    if (x === void 0) {\n      x = 0.0;\n    }\n\n    if (y === void 0) {\n      y = 0.0;\n    }\n\n    if (z === void 0) {\n      z = 0.0;\n    }\n\n    if (w === void 0) {\n      w = 1.0;\n    }\n    /** @hidden */\n\n\n    this._isDirty = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  Object.defineProperty(Quaternion.prototype, \"x\", {\n    /** Gets or sets the x coordinate */\n    get: function () {\n      return this._x;\n    },\n    set: function (value) {\n      this._x = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"y\", {\n    /** Gets or sets the y coordinate */\n    get: function () {\n      return this._y;\n    },\n    set: function (value) {\n      this._y = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"z\", {\n    /** Gets or sets the z coordinate */\n    get: function () {\n      return this._z;\n    },\n    set: function (value) {\n      this._z = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Quaternion.prototype, \"w\", {\n    /** Gets or sets the w coordinate */\n    get: function () {\n      return this._w;\n    },\n    set: function (value) {\n      this._w = value;\n      this._isDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string representation for the current quaternion\r\n   * @returns a string with the Quaternion coordinates\r\n   */\n\n  Quaternion.prototype.toString = function () {\n    return \"{X: \" + this._x + \" Y:\" + this._y + \" Z:\" + this._z + \" W:\" + this._w + \"}\";\n  };\n  /**\r\n   * Gets the class name of the quaternion\r\n   * @returns the string \"Quaternion\"\r\n   */\n\n\n  Quaternion.prototype.getClassName = function () {\n    return \"Quaternion\";\n  };\n  /**\r\n   * Gets a hash code for this quaternion\r\n   * @returns the quaternion hash code\r\n   */\n\n\n  Quaternion.prototype.getHashCode = function () {\n    var hash = this._x | 0;\n    hash = hash * 397 ^ (this._y | 0);\n    hash = hash * 397 ^ (this._z | 0);\n    hash = hash * 397 ^ (this._w | 0);\n    return hash;\n  };\n  /**\r\n   * Copy the quaternion to an array\r\n   * @returns a new array populated with 4 elements from the quaternion coordinates\r\n   */\n\n\n  Quaternion.prototype.asArray = function () {\n    return [this._x, this._y, this._z, this._w];\n  };\n  /**\r\n   * Check if two quaternions are equals\r\n   * @param otherQuaternion defines the second operand\r\n   * @return true if the current quaternion and the given one coordinates are strictly equals\r\n   */\n\n\n  Quaternion.prototype.equals = function (otherQuaternion) {\n    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\n  };\n  /**\r\n   * Gets a boolean if two quaternions are equals (using an epsilon value)\r\n   * @param otherQuaternion defines the other quaternion\r\n   * @param epsilon defines the minimal distance to consider equality\r\n   * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\r\n   */\n\n\n  Quaternion.prototype.equalsWithEpsilon = function (otherQuaternion, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = Epsilon;\n    }\n\n    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);\n  };\n  /**\r\n   * Clone the current quaternion\r\n   * @returns a new quaternion copied from the current one\r\n   */\n\n\n  Quaternion.prototype.clone = function () {\n    return new Quaternion(this._x, this._y, this._z, this._w);\n  };\n  /**\r\n   * Copy a quaternion to the current one\r\n   * @param other defines the other quaternion\r\n   * @returns the updated current quaternion\r\n   */\n\n\n  Quaternion.prototype.copyFrom = function (other) {\n    this.x = other._x;\n    this.y = other._y;\n    this.z = other._z;\n    this.w = other._w;\n    return this;\n  };\n  /**\r\n   * Updates the current quaternion with the given float coordinates\r\n   * @param x defines the x coordinate\r\n   * @param y defines the y coordinate\r\n   * @param z defines the z coordinate\r\n   * @param w defines the w coordinate\r\n   * @returns the updated current quaternion\r\n   */\n\n\n  Quaternion.prototype.copyFromFloats = function (x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  };\n  /**\r\n   * Updates the current quaternion from the given float coordinates\r\n   * @param x defines the x coordinate\r\n   * @param y defines the y coordinate\r\n   * @param z defines the z coordinate\r\n   * @param w defines the w coordinate\r\n   * @returns the updated current quaternion\r\n   */\n\n\n  Quaternion.prototype.set = function (x, y, z, w) {\n    return this.copyFromFloats(x, y, z, w);\n  };\n  /**\r\n   * Adds two quaternions\r\n   * @param other defines the second operand\r\n   * @returns a new quaternion as the addition result of the given one and the current quaternion\r\n   */\n\n\n  Quaternion.prototype.add = function (other) {\n    return new Quaternion(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\n  };\n  /**\r\n   * Add a quaternion to the current one\r\n   * @param other defines the quaternion to add\r\n   * @returns the current quaternion\r\n   */\n\n\n  Quaternion.prototype.addInPlace = function (other) {\n    this._x += other._x;\n    this._y += other._y;\n    this._z += other._z;\n    this._w += other._w;\n    return this;\n  };\n  /**\r\n   * Subtract two quaternions\r\n   * @param other defines the second operand\r\n   * @returns a new quaternion as the subtraction result of the given one from the current one\r\n   */\n\n\n  Quaternion.prototype.subtract = function (other) {\n    return new Quaternion(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\n  };\n  /**\r\n   * Multiplies the current quaternion by a scale factor\r\n   * @param value defines the scale factor\r\n   * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\r\n   */\n\n\n  Quaternion.prototype.scale = function (value) {\n    return new Quaternion(this._x * value, this._y * value, this._z * value, this._w * value);\n  };\n  /**\r\n   * Scale the current quaternion values by a factor and stores the result to a given quaternion\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Quaternion object where to store the result\r\n   * @returns the unmodified current quaternion\r\n   */\n\n\n  Quaternion.prototype.scaleToRef = function (scale, result) {\n    result.x = this._x * scale;\n    result.y = this._y * scale;\n    result.z = this._z * scale;\n    result.w = this._w * scale;\n    return this;\n  };\n  /**\r\n   * Multiplies in place the current quaternion by a scale factor\r\n   * @param value defines the scale factor\r\n   * @returns the current modified quaternion\r\n   */\n\n\n  Quaternion.prototype.scaleInPlace = function (value) {\n    this.x *= value;\n    this.y *= value;\n    this.z *= value;\n    this.w *= value;\n    return this;\n  };\n  /**\r\n   * Scale the current quaternion values by a factor and add the result to a given quaternion\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Quaternion object where to store the result\r\n   * @returns the unmodified current quaternion\r\n   */\n\n\n  Quaternion.prototype.scaleAndAddToRef = function (scale, result) {\n    result.x += this._x * scale;\n    result.y += this._y * scale;\n    result.z += this._z * scale;\n    result.w += this._w * scale;\n    return this;\n  };\n  /**\r\n   * Multiplies two quaternions\r\n   * @param q1 defines the second operand\r\n   * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\r\n   */\n\n\n  Quaternion.prototype.multiply = function (q1) {\n    var result = new Quaternion(0, 0, 0, 1.0);\n    this.multiplyToRef(q1, result);\n    return result;\n  };\n  /**\r\n   * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\r\n   * @param q1 defines the second operand\r\n   * @param result defines the target quaternion\r\n   * @returns the current quaternion\r\n   */\n\n\n  Quaternion.prototype.multiplyToRef = function (q1, result) {\n    var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\n    var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\n    var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\n    var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\n    result.copyFromFloats(x, y, z, w);\n    return this;\n  };\n  /**\r\n   * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\r\n   * @param q1 defines the second operand\r\n   * @returns the currentupdated quaternion\r\n   */\n\n\n  Quaternion.prototype.multiplyInPlace = function (q1) {\n    this.multiplyToRef(q1, this);\n    return this;\n  };\n  /**\r\n   * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\r\n   * @param ref defines the target quaternion\r\n   * @returns the current quaternion\r\n   */\n\n\n  Quaternion.prototype.conjugateToRef = function (ref) {\n    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\n    return this;\n  };\n  /**\r\n   * Conjugates in place (1-q) the current quaternion\r\n   * @returns the current updated quaternion\r\n   */\n\n\n  Quaternion.prototype.conjugateInPlace = function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  };\n  /**\r\n   * Conjugates in place (1-q) the current quaternion\r\n   * @returns a new quaternion\r\n   */\n\n\n  Quaternion.prototype.conjugate = function () {\n    var result = new Quaternion(-this._x, -this._y, -this._z, this._w);\n    return result;\n  };\n  /**\r\n   * Gets length of current quaternion\r\n   * @returns the quaternion length (float)\r\n   */\n\n\n  Quaternion.prototype.length = function () {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  };\n  /**\r\n   * Normalize in place the current quaternion\r\n   * @returns the current updated quaternion\r\n   */\n\n\n  Quaternion.prototype.normalize = function () {\n    var len = this.length();\n\n    if (len === 0) {\n      return this;\n    }\n\n    var inv = 1.0 / len;\n    this.x *= inv;\n    this.y *= inv;\n    this.z *= inv;\n    this.w *= inv;\n    return this;\n  };\n  /**\r\n   * Returns a new Vector3 set with the Euler angles translated from the current quaternion\r\n   * @param order is a reserved parameter and is ignored for now\r\n   * @returns a new Vector3 containing the Euler angles\r\n   */\n\n\n  Quaternion.prototype.toEulerAngles = function (order) {\n    if (order === void 0) {\n      order = \"YZX\";\n    }\n\n    var result = Vector3.Zero();\n    this.toEulerAnglesToRef(result);\n    return result;\n  };\n  /**\r\n   * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\r\n   * @param result defines the vector which will be filled with the Euler angles\r\n   * @returns the current unchanged quaternion\r\n   */\n\n\n  Quaternion.prototype.toEulerAnglesToRef = function (result) {\n    var qz = this._z;\n    var qx = this._x;\n    var qy = this._y;\n    var qw = this._w;\n    var sqw = qw * qw;\n    var sqz = qz * qz;\n    var sqx = qx * qx;\n    var sqy = qy * qy;\n    var zAxisY = qy * qz - qx * qw;\n    var limit = .4999999;\n\n    if (zAxisY < -limit) {\n      result.y = 2 * Math.atan2(qy, qw);\n      result.x = Math.PI / 2;\n      result.z = 0;\n    } else if (zAxisY > limit) {\n      result.y = 2 * Math.atan2(qy, qw);\n      result.x = -Math.PI / 2;\n      result.z = 0;\n    } else {\n      result.z = Math.atan2(2.0 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);\n      result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\n      result.y = Math.atan2(2.0 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);\n    }\n\n    return this;\n  };\n  /**\r\n   * Updates the given rotation matrix with the current quaternion values\r\n   * @param result defines the target matrix\r\n   * @returns the current unchanged quaternion\r\n   */\n\n\n  Quaternion.prototype.toRotationMatrix = function (result) {\n    Matrix.FromQuaternionToRef(this, result);\n    return this;\n  };\n  /**\r\n   * Updates the current quaternion from the given rotation matrix values\r\n   * @param matrix defines the source matrix\r\n   * @returns the current updated quaternion\r\n   */\n\n\n  Quaternion.prototype.fromRotationMatrix = function (matrix) {\n    Quaternion.FromRotationMatrixToRef(matrix, this);\n    return this;\n  }; // Statics\n\n  /**\r\n   * Creates a new quaternion from a rotation matrix\r\n   * @param matrix defines the source matrix\r\n   * @returns a new quaternion created from the given rotation matrix values\r\n   */\n\n\n  Quaternion.FromRotationMatrix = function (matrix) {\n    var result = new Quaternion();\n    Quaternion.FromRotationMatrixToRef(matrix, result);\n    return result;\n  };\n  /**\r\n   * Updates the given quaternion with the given rotation matrix values\r\n   * @param matrix defines the source matrix\r\n   * @param result defines the target quaternion\r\n   */\n\n\n  Quaternion.FromRotationMatrixToRef = function (matrix, result) {\n    var data = matrix.m;\n    var m11 = data[0],\n        m12 = data[4],\n        m13 = data[8];\n    var m21 = data[1],\n        m22 = data[5],\n        m23 = data[9];\n    var m31 = data[2],\n        m32 = data[6],\n        m33 = data[10];\n    var trace = m11 + m22 + m33;\n    var s;\n\n    if (trace > 0) {\n      s = 0.5 / Math.sqrt(trace + 1.0);\n      result.w = 0.25 / s;\n      result.x = (m32 - m23) * s;\n      result.y = (m13 - m31) * s;\n      result.z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      result.w = (m32 - m23) / s;\n      result.x = 0.25 * s;\n      result.y = (m12 + m21) / s;\n      result.z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      result.w = (m13 - m31) / s;\n      result.x = (m12 + m21) / s;\n      result.y = 0.25 * s;\n      result.z = (m23 + m32) / s;\n    } else {\n      s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      result.w = (m21 - m12) / s;\n      result.x = (m13 + m31) / s;\n      result.y = (m23 + m32) / s;\n      result.z = 0.25 * s;\n    }\n  };\n  /**\r\n   * Returns the dot product (float) between the quaternions \"left\" and \"right\"\r\n   * @param left defines the left operand\r\n   * @param right defines the right operand\r\n   * @returns the dot product\r\n   */\n\n\n  Quaternion.Dot = function (left, right) {\n    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n  };\n  /**\r\n   * Checks if the two quaternions are close to each other\r\n   * @param quat0 defines the first quaternion to check\r\n   * @param quat1 defines the second quaternion to check\r\n   * @returns true if the two quaternions are close to each other\r\n   */\n\n\n  Quaternion.AreClose = function (quat0, quat1) {\n    var dot = Quaternion.Dot(quat0, quat1);\n    return dot >= 0;\n  };\n  /**\r\n   * Creates an empty quaternion\r\n   * @returns a new quaternion set to (0.0, 0.0, 0.0)\r\n   */\n\n\n  Quaternion.Zero = function () {\n    return new Quaternion(0.0, 0.0, 0.0, 0.0);\n  };\n  /**\r\n   * Inverse a given quaternion\r\n   * @param q defines the source quaternion\r\n   * @returns a new quaternion as the inverted current quaternion\r\n   */\n\n\n  Quaternion.Inverse = function (q) {\n    return new Quaternion(-q._x, -q._y, -q._z, q._w);\n  };\n  /**\r\n   * Inverse a given quaternion\r\n   * @param q defines the source quaternion\r\n   * @param result the quaternion the result will be stored in\r\n   * @returns the result quaternion\r\n   */\n\n\n  Quaternion.InverseToRef = function (q, result) {\n    result.set(-q._x, -q._y, -q._z, q._w);\n    return result;\n  };\n  /**\r\n   * Creates an identity quaternion\r\n   * @returns the identity quaternion\r\n   */\n\n\n  Quaternion.Identity = function () {\n    return new Quaternion(0.0, 0.0, 0.0, 1.0);\n  };\n  /**\r\n   * Gets a boolean indicating if the given quaternion is identity\r\n   * @param quaternion defines the quaternion to check\r\n   * @returns true if the quaternion is identity\r\n   */\n\n\n  Quaternion.IsIdentity = function (quaternion) {\n    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\n  };\n  /**\r\n   * Creates a quaternion from a rotation around an axis\r\n   * @param axis defines the axis to use\r\n   * @param angle defines the angle to use\r\n   * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\r\n   */\n\n\n  Quaternion.RotationAxis = function (axis, angle) {\n    return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\n  };\n  /**\r\n   * Creates a rotation around an axis and stores it into the given quaternion\r\n   * @param axis defines the axis to use\r\n   * @param angle defines the angle to use\r\n   * @param result defines the target quaternion\r\n   * @returns the target quaternion\r\n   */\n\n\n  Quaternion.RotationAxisToRef = function (axis, angle, result) {\n    var sin = Math.sin(angle / 2);\n    axis.normalize();\n    result.w = Math.cos(angle / 2);\n    result.x = axis._x * sin;\n    result.y = axis._y * sin;\n    result.z = axis._z * sin;\n    return result;\n  };\n  /**\r\n   * Creates a new quaternion from data stored into an array\r\n   * @param array defines the data source\r\n   * @param offset defines the offset in the source array where the data starts\r\n   * @returns a new quaternion\r\n   */\n\n\n  Quaternion.FromArray = function (array, offset) {\n    if (!offset) {\n      offset = 0;\n    }\n\n    return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  };\n  /**\r\n   * Updates the given quaternion \"result\" from the starting index of the given array.\r\n   * @param array the array to pull values from\r\n   * @param offset the offset into the array to start at\r\n   * @param result the quaternion to store the result in\r\n   */\n\n\n  Quaternion.FromArrayToRef = function (array, offset, result) {\n    result.x = array[offset];\n    result.y = array[offset + 1];\n    result.z = array[offset + 2];\n    result.w = array[offset + 3];\n  };\n  /**\r\n   * Create a quaternion from Euler rotation angles\r\n   * @param x Pitch\r\n   * @param y Yaw\r\n   * @param z Roll\r\n   * @returns the new Quaternion\r\n   */\n\n\n  Quaternion.FromEulerAngles = function (x, y, z) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(y, x, z, q);\n    return q;\n  };\n  /**\r\n   * Updates a quaternion from Euler rotation angles\r\n   * @param x Pitch\r\n   * @param y Yaw\r\n   * @param z Roll\r\n   * @param result the quaternion to store the result\r\n   * @returns the updated quaternion\r\n   */\n\n\n  Quaternion.FromEulerAnglesToRef = function (x, y, z, result) {\n    Quaternion.RotationYawPitchRollToRef(y, x, z, result);\n    return result;\n  };\n  /**\r\n   * Create a quaternion from Euler rotation vector\r\n   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n   * @returns the new Quaternion\r\n   */\n\n\n  Quaternion.FromEulerVector = function (vec) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\n    return q;\n  };\n  /**\r\n   * Updates a quaternion from Euler rotation vector\r\n   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n   * @param result the quaternion to store the result\r\n   * @returns the updated quaternion\r\n   */\n\n\n  Quaternion.FromEulerVectorToRef = function (vec, result) {\n    Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\n    return result;\n  };\n  /**\r\n   * Creates a new quaternion from the given Euler float angles (y, x, z)\r\n   * @param yaw defines the rotation around Y axis\r\n   * @param pitch defines the rotation around X axis\r\n   * @param roll defines the rotation around Z axis\r\n   * @returns the new quaternion\r\n   */\n\n\n  Quaternion.RotationYawPitchRoll = function (yaw, pitch, roll) {\n    var q = new Quaternion();\n    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n    return q;\n  };\n  /**\r\n   * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\r\n   * @param yaw defines the rotation around Y axis\r\n   * @param pitch defines the rotation around X axis\r\n   * @param roll defines the rotation around Z axis\r\n   * @param result defines the target quaternion\r\n   */\n\n\n  Quaternion.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n    // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n    var halfRoll = roll * 0.5;\n    var halfPitch = pitch * 0.5;\n    var halfYaw = yaw * 0.5;\n    var sinRoll = Math.sin(halfRoll);\n    var cosRoll = Math.cos(halfRoll);\n    var sinPitch = Math.sin(halfPitch);\n    var cosPitch = Math.cos(halfPitch);\n    var sinYaw = Math.sin(halfYaw);\n    var cosYaw = Math.cos(halfYaw);\n    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;\n    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;\n  };\n  /**\r\n   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\r\n   * @param alpha defines the rotation around first axis\r\n   * @param beta defines the rotation around second axis\r\n   * @param gamma defines the rotation around third axis\r\n   * @returns the new quaternion\r\n   */\n\n\n  Quaternion.RotationAlphaBetaGamma = function (alpha, beta, gamma) {\n    var result = new Quaternion();\n    Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n    return result;\n  };\n  /**\r\n   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\r\n   * @param alpha defines the rotation around first axis\r\n   * @param beta defines the rotation around second axis\r\n   * @param gamma defines the rotation around third axis\r\n   * @param result defines the target quaternion\r\n   */\n\n\n  Quaternion.RotationAlphaBetaGammaToRef = function (alpha, beta, gamma, result) {\n    // Produces a quaternion from Euler angles in the z-x-z orientation\n    var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n    var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n    var halfBeta = beta * 0.5;\n    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n  };\n  /**\r\n   * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\r\n   * @param axis1 defines the first axis\r\n   * @param axis2 defines the second axis\r\n   * @param axis3 defines the third axis\r\n   * @returns the new quaternion\r\n   */\n\n\n  Quaternion.RotationQuaternionFromAxis = function (axis1, axis2, axis3) {\n    var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n    return quat;\n  };\n  /**\r\n   * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\r\n   * @param axis1 defines the first axis\r\n   * @param axis2 defines the second axis\r\n   * @param axis3 defines the third axis\r\n   * @param ref defines the target quaternion\r\n   */\n\n\n  Quaternion.RotationQuaternionFromAxisToRef = function (axis1, axis2, axis3, ref) {\n    var rotMat = MathTmp.Matrix[0];\n    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n    Quaternion.FromRotationMatrixToRef(rotMat, ref);\n  };\n  /**\r\n   * Interpolates between two quaternions\r\n   * @param left defines first quaternion\r\n   * @param right defines second quaternion\r\n   * @param amount defines the gradient to use\r\n   * @returns the new interpolated quaternion\r\n   */\n\n\n  Quaternion.Slerp = function (left, right, amount) {\n    var result = Quaternion.Identity();\n    Quaternion.SlerpToRef(left, right, amount, result);\n    return result;\n  };\n  /**\r\n   * Interpolates between two quaternions and stores it into a target quaternion\r\n   * @param left defines first quaternion\r\n   * @param right defines second quaternion\r\n   * @param amount defines the gradient to use\r\n   * @param result defines the target quaternion\r\n   */\n\n\n  Quaternion.SlerpToRef = function (left, right, amount, result) {\n    var num2;\n    var num3;\n    var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n    var flag = false;\n\n    if (num4 < 0) {\n      flag = true;\n      num4 = -num4;\n    }\n\n    if (num4 > 0.999999) {\n      num3 = 1 - amount;\n      num2 = flag ? -amount : amount;\n    } else {\n      var num5 = Math.acos(num4);\n      var num6 = 1.0 / Math.sin(num5);\n      num3 = Math.sin((1.0 - amount) * num5) * num6;\n      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;\n    }\n\n    result.x = num3 * left._x + num2 * right._x;\n    result.y = num3 * left._y + num2 * right._y;\n    result.z = num3 * left._z + num2 * right._z;\n    result.w = num3 * left._w + num2 * right._w;\n  };\n  /**\r\n   * Interpolate between two quaternions using Hermite interpolation\r\n   * @param value1 defines first quaternion\r\n   * @param tangent1 defines the incoming tangent\r\n   * @param value2 defines second quaternion\r\n   * @param tangent2 defines the outgoing tangent\r\n   * @param amount defines the target quaternion\r\n   * @returns the new interpolated quaternion\r\n   */\n\n\n  Quaternion.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n    var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;\n    return new Quaternion(x, y, z, w);\n  };\n\n  return Quaternion;\n}();\n\nexport { Quaternion };\n/**\r\n * Class used to store matrix data (4x4)\r\n */\n\nvar Matrix =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an empty matrix (filled with zeros)\r\n   */\n  function Matrix() {\n    this._isIdentity = false;\n    this._isIdentityDirty = true;\n    this._isIdentity3x2 = true;\n    this._isIdentity3x2Dirty = true;\n    /**\r\n     * Gets the update flag of the matrix which is an unique number for the matrix.\r\n     * It will be incremented every time the matrix data change.\r\n     * You can use it to speed the comparison between two versions of the same matrix.\r\n     */\n\n    this.updateFlag = -1;\n\n    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\n      PerformanceConfigurator.MatrixTrackedMatrices.push(this);\n    }\n\n    this._m = new PerformanceConfigurator.MatrixCurrentType(16);\n\n    this._updateIdentityStatus(false);\n  }\n\n  Object.defineProperty(Matrix, \"Use64Bits\", {\n    /**\r\n     * Gets the precision of matrix computations\r\n     */\n    get: function () {\n      return PerformanceConfigurator.MatrixUse64Bits;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"m\", {\n    /**\r\n     * Gets the internal data of the matrix\r\n     */\n    get: function () {\n      return this._m;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  Matrix.prototype._markAsUpdated = function () {\n    this.updateFlag = Matrix._updateFlagSeed++;\n    this._isIdentity = false;\n    this._isIdentity3x2 = false;\n    this._isIdentityDirty = true;\n    this._isIdentity3x2Dirty = true;\n  };\n  /** @hidden */\n\n\n  Matrix.prototype._updateIdentityStatus = function (isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {\n    if (isIdentityDirty === void 0) {\n      isIdentityDirty = false;\n    }\n\n    if (isIdentity3x2 === void 0) {\n      isIdentity3x2 = false;\n    }\n\n    if (isIdentity3x2Dirty === void 0) {\n      isIdentity3x2Dirty = true;\n    }\n\n    this.updateFlag = Matrix._updateFlagSeed++;\n    this._isIdentity = isIdentity;\n    this._isIdentity3x2 = isIdentity || isIdentity3x2;\n    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n  }; // Properties\n\n  /**\r\n   * Check if the current matrix is identity\r\n   * @returns true is the matrix is the identity matrix\r\n   */\n\n\n  Matrix.prototype.isIdentity = function () {\n    if (this._isIdentityDirty) {\n      this._isIdentityDirty = false;\n      var m = this._m;\n      this._isIdentity = m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 && m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 && m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 && m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0;\n    }\n\n    return this._isIdentity;\n  };\n  /**\r\n   * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\r\n   * @returns true is the matrix is the identity matrix\r\n   */\n\n\n  Matrix.prototype.isIdentityAs3x2 = function () {\n    if (this._isIdentity3x2Dirty) {\n      this._isIdentity3x2Dirty = false;\n\n      if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n        this._isIdentity3x2 = false;\n      } else if (this._m[1] !== 0.0 || this._m[2] !== 0.0 || this._m[3] !== 0.0 || this._m[4] !== 0.0 || this._m[6] !== 0.0 || this._m[7] !== 0.0 || this._m[8] !== 0.0 || this._m[9] !== 0.0 || this._m[10] !== 0.0 || this._m[11] !== 0.0 || this._m[12] !== 0.0 || this._m[13] !== 0.0 || this._m[14] !== 0.0) {\n        this._isIdentity3x2 = false;\n      } else {\n        this._isIdentity3x2 = true;\n      }\n    }\n\n    return this._isIdentity3x2;\n  };\n  /**\r\n   * Gets the determinant of the matrix\r\n   * @returns the matrix determinant\r\n   */\n\n\n  Matrix.prototype.determinant = function () {\n    if (this._isIdentity === true) {\n      return 1;\n    }\n\n    var m = this._m;\n    var m00 = m[0],\n        m01 = m[1],\n        m02 = m[2],\n        m03 = m[3];\n    var m10 = m[4],\n        m11 = m[5],\n        m12 = m[6],\n        m13 = m[7];\n    var m20 = m[8],\n        m21 = m[9],\n        m22 = m[10],\n        m23 = m[11];\n    var m30 = m[12],\n        m31 = m[13],\n        m32 = m[14],\n        m33 = m[15]; // https://en.wikipedia.org/wiki/Laplace_expansion\n    // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n    // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n    // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n    // where\n    //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n    //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n    //\n    // Here we do that for the 1st row.\n\n    var det_22_33 = m22 * m33 - m32 * m23;\n    var det_21_33 = m21 * m33 - m31 * m23;\n    var det_21_32 = m21 * m32 - m31 * m22;\n    var det_20_33 = m20 * m33 - m30 * m23;\n    var det_20_32 = m20 * m32 - m22 * m30;\n    var det_20_31 = m20 * m31 - m30 * m21;\n    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n  }; // Methods\n\n  /**\r\n   * Returns the matrix as a Float32Array or Array<number>\r\n   * @returns the matrix underlying array\r\n   */\n\n\n  Matrix.prototype.toArray = function () {\n    return this._m;\n  };\n  /**\r\n   * Returns the matrix as a Float32Array or Array<number>\r\n  * @returns the matrix underlying array.\r\n  */\n\n\n  Matrix.prototype.asArray = function () {\n    return this._m;\n  };\n  /**\r\n   * Inverts the current matrix in place\r\n   * @returns the current inverted matrix\r\n   */\n\n\n  Matrix.prototype.invert = function () {\n    this.invertToRef(this);\n    return this;\n  };\n  /**\r\n   * Sets all the matrix elements to zero\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.reset = function () {\n    Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n\n    this._updateIdentityStatus(false);\n\n    return this;\n  };\n  /**\r\n   * Adds the current matrix with a second one\r\n   * @param other defines the matrix to add\r\n   * @returns a new matrix as the addition of the current matrix and the given one\r\n   */\n\n\n  Matrix.prototype.add = function (other) {\n    var result = new Matrix();\n    this.addToRef(other, result);\n    return result;\n  };\n  /**\r\n   * Sets the given matrix \"result\" to the addition of the current matrix and the given one\r\n   * @param other defines the matrix to add\r\n   * @param result defines the target matrix\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.addToRef = function (other, result) {\n    var m = this._m;\n    var resultM = result._m;\n    var otherM = other.m;\n\n    for (var index = 0; index < 16; index++) {\n      resultM[index] = m[index] + otherM[index];\n    }\n\n    result._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Adds in place the given matrix to the current matrix\r\n   * @param other defines the second operand\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.addToSelf = function (other) {\n    var m = this._m;\n    var otherM = other.m;\n\n    for (var index = 0; index < 16; index++) {\n      m[index] += otherM[index];\n    }\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Sets the given matrix to the current inverted Matrix\r\n   * @param other defines the target matrix\r\n   * @returns the unmodified current matrix\r\n   */\n\n\n  Matrix.prototype.invertToRef = function (other) {\n    if (this._isIdentity === true) {\n      Matrix.IdentityToRef(other);\n      return this;\n    } // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n\n\n    var m = this._m;\n    var m00 = m[0],\n        m01 = m[1],\n        m02 = m[2],\n        m03 = m[3];\n    var m10 = m[4],\n        m11 = m[5],\n        m12 = m[6],\n        m13 = m[7];\n    var m20 = m[8],\n        m21 = m[9],\n        m22 = m[10],\n        m23 = m[11];\n    var m30 = m[12],\n        m31 = m[13],\n        m32 = m[14],\n        m33 = m[15];\n    var det_22_33 = m22 * m33 - m32 * m23;\n    var det_21_33 = m21 * m33 - m31 * m23;\n    var det_21_32 = m21 * m32 - m31 * m22;\n    var det_20_33 = m20 * m33 - m30 * m23;\n    var det_20_32 = m20 * m32 - m22 * m30;\n    var det_20_31 = m20 * m31 - m30 * m21;\n    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n    var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n\n    if (det === 0) {\n      // not invertible\n      other.copyFrom(this);\n      return this;\n    }\n\n    var detInv = 1 / det;\n    var det_12_33 = m12 * m33 - m32 * m13;\n    var det_11_33 = m11 * m33 - m31 * m13;\n    var det_11_32 = m11 * m32 - m31 * m12;\n    var det_10_33 = m10 * m33 - m30 * m13;\n    var det_10_32 = m10 * m32 - m30 * m12;\n    var det_10_31 = m10 * m31 - m30 * m11;\n    var det_12_23 = m12 * m23 - m22 * m13;\n    var det_11_23 = m11 * m23 - m21 * m13;\n    var det_11_22 = m11 * m22 - m21 * m12;\n    var det_10_23 = m10 * m23 - m20 * m13;\n    var det_10_22 = m10 * m22 - m20 * m12;\n    var det_10_21 = m10 * m21 - m20 * m11;\n    var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n    var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n    var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n    var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n    var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n    var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n    var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n    var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n    var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n    var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n    var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n    var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n    Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n    return this;\n  };\n  /**\r\n   * add a value at the specified position in the current Matrix\r\n   * @param index the index of the value within the matrix. between 0 and 15.\r\n   * @param value the value to be added\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.addAtIndex = function (index, value) {\n    this._m[index] += value;\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * mutiply the specified position in the current Matrix by a value\r\n   * @param index the index of the value within the matrix. between 0 and 15.\r\n   * @param value the value to be added\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.multiplyAtIndex = function (index, value) {\n    this._m[index] *= value;\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Inserts the translation vector (using 3 floats) in the current matrix\r\n   * @param x defines the 1st component of the translation\r\n   * @param y defines the 2nd component of the translation\r\n   * @param z defines the 3rd component of the translation\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.setTranslationFromFloats = function (x, y, z) {\n    this._m[12] = x;\n    this._m[13] = y;\n    this._m[14] = z;\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Adds the translation vector (using 3 floats) in the current matrix\r\n   * @param x defines the 1st component of the translation\r\n   * @param y defines the 2nd component of the translation\r\n   * @param z defines the 3rd component of the translation\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.addTranslationFromFloats = function (x, y, z) {\n    this._m[12] += x;\n    this._m[13] += y;\n    this._m[14] += z;\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Inserts the translation vector in the current matrix\r\n   * @param vector3 defines the translation to insert\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.setTranslation = function (vector3) {\n    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\n  };\n  /**\r\n   * Gets the translation value of the current matrix\r\n   * @returns a new Vector3 as the extracted translation from the matrix\r\n   */\n\n\n  Matrix.prototype.getTranslation = function () {\n    return new Vector3(this._m[12], this._m[13], this._m[14]);\n  };\n  /**\r\n   * Fill a Vector3 with the extracted translation from the matrix\r\n   * @param result defines the Vector3 where to store the translation\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.getTranslationToRef = function (result) {\n    result.x = this._m[12];\n    result.y = this._m[13];\n    result.z = this._m[14];\n    return this;\n  };\n  /**\r\n   * Remove rotation and scaling part from the matrix\r\n   * @returns the updated matrix\r\n   */\n\n\n  Matrix.prototype.removeRotationAndScaling = function () {\n    var m = this.m;\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n\n    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n\n    return this;\n  };\n  /**\r\n   * Multiply two matrices\r\n   * @param other defines the second operand\r\n   * @returns a new matrix set with the multiplication result of the current Matrix and the given one\r\n   */\n\n\n  Matrix.prototype.multiply = function (other) {\n    var result = new Matrix();\n    this.multiplyToRef(other, result);\n    return result;\n  };\n  /**\r\n   * Copy the current matrix from the given one\r\n   * @param other defines the source matrix\r\n   * @returns the current updated matrix\r\n   */\n\n\n  Matrix.prototype.copyFrom = function (other) {\n    other.copyToArray(this._m);\n    var o = other;\n\n    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n\n    return this;\n  };\n  /**\r\n   * Populates the given array from the starting index with the current matrix values\r\n   * @param array defines the target array\r\n   * @param offset defines the offset in the target array where to start storing values\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.copyToArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var source = this._m;\n    array[offset] = source[0];\n    array[offset + 1] = source[1];\n    array[offset + 2] = source[2];\n    array[offset + 3] = source[3];\n    array[offset + 4] = source[4];\n    array[offset + 5] = source[5];\n    array[offset + 6] = source[6];\n    array[offset + 7] = source[7];\n    array[offset + 8] = source[8];\n    array[offset + 9] = source[9];\n    array[offset + 10] = source[10];\n    array[offset + 11] = source[11];\n    array[offset + 12] = source[12];\n    array[offset + 13] = source[13];\n    array[offset + 14] = source[14];\n    array[offset + 15] = source[15];\n    return this;\n  };\n  /**\r\n   * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\r\n   * @param other defines the second operand\r\n   * @param result defines the matrix where to store the multiplication\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.multiplyToRef = function (other, result) {\n    if (this._isIdentity) {\n      result.copyFrom(other);\n      return this;\n    }\n\n    if (other._isIdentity) {\n      result.copyFrom(this);\n      return this;\n    }\n\n    this.multiplyToArray(other, result._m, 0);\n\n    result._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\r\n   * @param other defines the second operand\r\n   * @param result defines the array where to store the multiplication\r\n   * @param offset defines the offset in the target array where to start storing values\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.multiplyToArray = function (other, result, offset) {\n    var m = this._m;\n    var otherM = other.m;\n    var tm0 = m[0],\n        tm1 = m[1],\n        tm2 = m[2],\n        tm3 = m[3];\n    var tm4 = m[4],\n        tm5 = m[5],\n        tm6 = m[6],\n        tm7 = m[7];\n    var tm8 = m[8],\n        tm9 = m[9],\n        tm10 = m[10],\n        tm11 = m[11];\n    var tm12 = m[12],\n        tm13 = m[13],\n        tm14 = m[14],\n        tm15 = m[15];\n    var om0 = otherM[0],\n        om1 = otherM[1],\n        om2 = otherM[2],\n        om3 = otherM[3];\n    var om4 = otherM[4],\n        om5 = otherM[5],\n        om6 = otherM[6],\n        om7 = otherM[7];\n    var om8 = otherM[8],\n        om9 = otherM[9],\n        om10 = otherM[10],\n        om11 = otherM[11];\n    var om12 = otherM[12],\n        om13 = otherM[13],\n        om14 = otherM[14],\n        om15 = otherM[15];\n    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n    return this;\n  };\n  /**\r\n   * Check equality between this matrix and a second one\r\n   * @param value defines the second matrix to compare\r\n   * @returns true is the current matrix and the given one values are strictly equal\r\n   */\n\n\n  Matrix.prototype.equals = function (value) {\n    var other = value;\n\n    if (!other) {\n      return false;\n    }\n\n    if (this._isIdentity || other._isIdentity) {\n      if (!this._isIdentityDirty && !other._isIdentityDirty) {\n        return this._isIdentity && other._isIdentity;\n      }\n    }\n\n    var m = this.m;\n    var om = other.m;\n    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];\n  };\n  /**\r\n   * Clone the current matrix\r\n   * @returns a new matrix from the current matrix\r\n   */\n\n\n  Matrix.prototype.clone = function () {\n    var matrix = new Matrix();\n    matrix.copyFrom(this);\n    return matrix;\n  };\n  /**\r\n   * Returns the name of the current matrix class\r\n   * @returns the string \"Matrix\"\r\n   */\n\n\n  Matrix.prototype.getClassName = function () {\n    return \"Matrix\";\n  };\n  /**\r\n   * Gets the hash code of the current matrix\r\n   * @returns the hash code\r\n   */\n\n\n  Matrix.prototype.getHashCode = function () {\n    var hash = this._m[0] | 0;\n\n    for (var i = 1; i < 16; i++) {\n      hash = hash * 397 ^ (this._m[i] | 0);\n    }\n\n    return hash;\n  };\n  /**\r\n   * Decomposes the current Matrix into a translation, rotation and scaling components\r\n   * @param scale defines the scale vector3 given as a reference to update\r\n   * @param rotation defines the rotation quaternion given as a reference to update\r\n   * @param translation defines the translation vector3 given as a reference to update\r\n   * @returns true if operation was successful\r\n   */\n\n\n  Matrix.prototype.decompose = function (scale, rotation, translation) {\n    if (this._isIdentity) {\n      if (translation) {\n        translation.setAll(0);\n      }\n\n      if (scale) {\n        scale.setAll(1);\n      }\n\n      if (rotation) {\n        rotation.copyFromFloats(0, 0, 0, 1);\n      }\n\n      return true;\n    }\n\n    var m = this._m;\n\n    if (translation) {\n      translation.copyFromFloats(m[12], m[13], m[14]);\n    }\n\n    scale = scale || MathTmp.Vector3[0];\n    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n\n    if (this.determinant() <= 0) {\n      scale.y *= -1;\n    }\n\n    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\n      if (rotation) {\n        rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n      }\n\n      return false;\n    }\n\n    if (rotation) {\n      var sx = 1 / scale._x,\n          sy = 1 / scale._y,\n          sz = 1 / scale._z;\n      Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, MathTmp.Matrix[0]);\n      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\n    }\n\n    return true;\n  };\n  /**\r\n   * Gets specific row of the matrix\r\n   * @param index defines the number of the row to get\r\n   * @returns the index-th row of the current matrix as a new Vector4\r\n   */\n\n\n  Matrix.prototype.getRow = function (index) {\n    if (index < 0 || index > 3) {\n      return null;\n    }\n\n    var i = index * 4;\n    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n  };\n  /**\r\n   * Sets the index-th row of the current matrix to the vector4 values\r\n   * @param index defines the number of the row to set\r\n   * @param row defines the target vector4\r\n   * @returns the updated current matrix\r\n   */\n\n\n  Matrix.prototype.setRow = function (index, row) {\n    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n  };\n  /**\r\n   * Compute the transpose of the matrix\r\n   * @returns the new transposed matrix\r\n   */\n\n\n  Matrix.prototype.transpose = function () {\n    return Matrix.Transpose(this);\n  };\n  /**\r\n   * Compute the transpose of the matrix and store it in a given matrix\r\n   * @param result defines the target matrix\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.transposeToRef = function (result) {\n    Matrix.TransposeToRef(this, result);\n    return this;\n  };\n  /**\r\n   * Sets the index-th row of the current matrix with the given 4 x float values\r\n   * @param index defines the row index\r\n   * @param x defines the x component to set\r\n   * @param y defines the y component to set\r\n   * @param z defines the z component to set\r\n   * @param w defines the w component to set\r\n   * @returns the updated current matrix\r\n   */\n\n\n  Matrix.prototype.setRowFromFloats = function (index, x, y, z, w) {\n    if (index < 0 || index > 3) {\n      return this;\n    }\n\n    var i = index * 4;\n    this._m[i + 0] = x;\n    this._m[i + 1] = y;\n    this._m[i + 2] = z;\n    this._m[i + 3] = w;\n\n    this._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Compute a new matrix set with the current matrix values multiplied by scale (float)\r\n   * @param scale defines the scale factor\r\n   * @returns a new matrix\r\n   */\n\n\n  Matrix.prototype.scale = function (scale) {\n    var result = new Matrix();\n    this.scaleToRef(scale, result);\n    return result;\n  };\n  /**\r\n   * Scale the current matrix values by a factor to a given result matrix\r\n   * @param scale defines the scale factor\r\n   * @param result defines the matrix to store the result\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.scaleToRef = function (scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = this._m[index] * scale;\n    }\n\n    result._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Scale the current matrix values by a factor and add the result to a given matrix\r\n   * @param scale defines the scale factor\r\n   * @param result defines the Matrix to store the result\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.scaleAndAddToRef = function (scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] += this._m[index] * scale;\n    }\n\n    result._markAsUpdated();\n\n    return this;\n  };\n  /**\r\n   * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\r\n   * @param ref matrix to store the result\r\n   */\n\n\n  Matrix.prototype.toNormalMatrix = function (ref) {\n    var tmp = MathTmp.Matrix[0];\n    this.invertToRef(tmp);\n    tmp.transposeToRef(ref);\n    var m = ref._m;\n    Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n  };\n  /**\r\n   * Gets only rotation part of the current matrix\r\n   * @returns a new matrix sets to the extracted rotation matrix from the current one\r\n   */\n\n\n  Matrix.prototype.getRotationMatrix = function () {\n    var result = new Matrix();\n    this.getRotationMatrixToRef(result);\n    return result;\n  };\n  /**\r\n   * Extracts the rotation matrix from the current one and sets it as the given \"result\"\r\n   * @param result defines the target matrix to store data to\r\n   * @returns the current matrix\r\n   */\n\n\n  Matrix.prototype.getRotationMatrixToRef = function (result) {\n    var scale = MathTmp.Vector3[0];\n\n    if (!this.decompose(scale)) {\n      Matrix.IdentityToRef(result);\n      return this;\n    }\n\n    var m = this._m;\n    var sx = 1 / scale._x,\n        sy = 1 / scale._y,\n        sz = 1 / scale._z;\n    Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n    return this;\n  };\n  /**\r\n   * Toggles model matrix from being right handed to left handed in place and vice versa\r\n   */\n\n\n  Matrix.prototype.toggleModelMatrixHandInPlace = function () {\n    var m = this._m;\n    m[2] *= -1;\n    m[6] *= -1;\n    m[8] *= -1;\n    m[9] *= -1;\n    m[14] *= -1;\n\n    this._markAsUpdated();\n  };\n  /**\r\n   * Toggles projection matrix from being right handed to left handed in place and vice versa\r\n   */\n\n\n  Matrix.prototype.toggleProjectionMatrixHandInPlace = function () {\n    var m = this._m;\n    m[8] *= -1;\n    m[9] *= -1;\n    m[10] *= -1;\n    m[11] *= -1;\n\n    this._markAsUpdated();\n  }; // Statics\n\n  /**\r\n   * Creates a matrix from an array\r\n   * @param array defines the source array\r\n   * @param offset defines an offset in the source array\r\n   * @returns a new Matrix set from the starting index of the given array\r\n   */\n\n\n  Matrix.FromArray = function (array, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var result = new Matrix();\n    Matrix.FromArrayToRef(array, offset, result);\n    return result;\n  };\n  /**\r\n   * Copy the content of an array into a given matrix\r\n   * @param array defines the source array\r\n   * @param offset defines an offset in the source array\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.FromArrayToRef = function (array, offset, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = array[index + offset];\n    }\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Stores an array into a matrix after having multiplied each component by a given factor\r\n   * @param array defines the source array\r\n   * @param offset defines the offset in the source array\r\n   * @param scale defines the scaling factor\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.FromFloat32ArrayToRefScaled = function (array, offset, scale, result) {\n    for (var index = 0; index < 16; index++) {\n      result._m[index] = array[index + offset] * scale;\n    }\n\n    result._markAsUpdated();\n  };\n\n  Object.defineProperty(Matrix, \"IdentityReadOnly\", {\n    /**\r\n     * Gets an identity matrix that must not be updated\r\n     */\n    get: function () {\n      return Matrix._identityReadOnly;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stores a list of values (16) inside a given matrix\r\n   * @param initialM11 defines 1st value of 1st row\r\n   * @param initialM12 defines 2nd value of 1st row\r\n   * @param initialM13 defines 3rd value of 1st row\r\n   * @param initialM14 defines 4th value of 1st row\r\n   * @param initialM21 defines 1st value of 2nd row\r\n   * @param initialM22 defines 2nd value of 2nd row\r\n   * @param initialM23 defines 3rd value of 2nd row\r\n   * @param initialM24 defines 4th value of 2nd row\r\n   * @param initialM31 defines 1st value of 3rd row\r\n   * @param initialM32 defines 2nd value of 3rd row\r\n   * @param initialM33 defines 3rd value of 3rd row\r\n   * @param initialM34 defines 4th value of 3rd row\r\n   * @param initialM41 defines 1st value of 4th row\r\n   * @param initialM42 defines 2nd value of 4th row\r\n   * @param initialM43 defines 3rd value of 4th row\r\n   * @param initialM44 defines 4th value of 4th row\r\n   * @param result defines the target matrix\r\n   */\n\n  Matrix.FromValuesToRef = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n    var m = result._m;\n    m[0] = initialM11;\n    m[1] = initialM12;\n    m[2] = initialM13;\n    m[3] = initialM14;\n    m[4] = initialM21;\n    m[5] = initialM22;\n    m[6] = initialM23;\n    m[7] = initialM24;\n    m[8] = initialM31;\n    m[9] = initialM32;\n    m[10] = initialM33;\n    m[11] = initialM34;\n    m[12] = initialM41;\n    m[13] = initialM42;\n    m[14] = initialM43;\n    m[15] = initialM44;\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Creates new matrix from a list of values (16)\r\n   * @param initialM11 defines 1st value of 1st row\r\n   * @param initialM12 defines 2nd value of 1st row\r\n   * @param initialM13 defines 3rd value of 1st row\r\n   * @param initialM14 defines 4th value of 1st row\r\n   * @param initialM21 defines 1st value of 2nd row\r\n   * @param initialM22 defines 2nd value of 2nd row\r\n   * @param initialM23 defines 3rd value of 2nd row\r\n   * @param initialM24 defines 4th value of 2nd row\r\n   * @param initialM31 defines 1st value of 3rd row\r\n   * @param initialM32 defines 2nd value of 3rd row\r\n   * @param initialM33 defines 3rd value of 3rd row\r\n   * @param initialM34 defines 4th value of 3rd row\r\n   * @param initialM41 defines 1st value of 4th row\r\n   * @param initialM42 defines 2nd value of 4th row\r\n   * @param initialM43 defines 3rd value of 4th row\r\n   * @param initialM44 defines 4th value of 4th row\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.FromValues = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n    var result = new Matrix();\n    var m = result._m;\n    m[0] = initialM11;\n    m[1] = initialM12;\n    m[2] = initialM13;\n    m[3] = initialM14;\n    m[4] = initialM21;\n    m[5] = initialM22;\n    m[6] = initialM23;\n    m[7] = initialM24;\n    m[8] = initialM31;\n    m[9] = initialM32;\n    m[10] = initialM33;\n    m[11] = initialM34;\n    m[12] = initialM41;\n    m[13] = initialM42;\n    m[14] = initialM43;\n    m[15] = initialM44;\n\n    result._markAsUpdated();\n\n    return result;\n  };\n  /**\r\n   * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n   * @param scale defines the scale vector3\r\n   * @param rotation defines the rotation quaternion\r\n   * @param translation defines the translation vector3\r\n   * @returns a new matrix\r\n   */\n\n\n  Matrix.Compose = function (scale, rotation, translation) {\n    var result = new Matrix();\n    Matrix.ComposeToRef(scale, rotation, translation, result);\n    return result;\n  };\n  /**\r\n   * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n   * @param scale defines the scale vector3\r\n   * @param rotation defines the rotation quaternion\r\n   * @param translation defines the translation vector3\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.ComposeToRef = function (scale, rotation, translation, result) {\n    var m = result._m;\n    var x = rotation._x,\n        y = rotation._y,\n        z = rotation._z,\n        w = rotation._w;\n    var x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    var xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    var yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    var wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n    var sx = scale._x,\n        sy = scale._y,\n        sz = scale._z;\n    m[0] = (1 - (yy + zz)) * sx;\n    m[1] = (xy + wz) * sx;\n    m[2] = (xz - wy) * sx;\n    m[3] = 0;\n    m[4] = (xy - wz) * sy;\n    m[5] = (1 - (xx + zz)) * sy;\n    m[6] = (yz + wx) * sy;\n    m[7] = 0;\n    m[8] = (xz + wy) * sz;\n    m[9] = (yz - wx) * sz;\n    m[10] = (1 - (xx + yy)) * sz;\n    m[11] = 0;\n    m[12] = translation._x;\n    m[13] = translation._y;\n    m[14] = translation._z;\n    m[15] = 1;\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Creates a new identity matrix\r\n   * @returns a new identity matrix\r\n   */\n\n\n  Matrix.Identity = function () {\n    var identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    identity._updateIdentityStatus(true);\n\n    return identity;\n  };\n  /**\r\n   * Creates a new identity matrix and stores the result in a given matrix\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.IdentityToRef = function (result) {\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(true);\n  };\n  /**\r\n   * Creates a new zero matrix\r\n   * @returns a new zero matrix\r\n   */\n\n\n  Matrix.Zero = function () {\n    var zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n\n    zero._updateIdentityStatus(false);\n\n    return zero;\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the X axis\r\n   * @param angle defines the angle (in radians) to use\r\n   * @return the new matrix\r\n   */\n\n\n  Matrix.RotationX = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationXToRef(angle, result);\n    return result;\n  };\n  /**\r\n   * Creates a new matrix as the invert of a given matrix\r\n   * @param source defines the source matrix\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.Invert = function (source) {\n    var result = new Matrix();\n    source.invertToRef(result);\n    return result;\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\r\n   * @param angle defines the angle (in radians) to use\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationXToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the Y axis\r\n   * @param angle defines the angle (in radians) to use\r\n   * @return the new matrix\r\n   */\n\n\n  Matrix.RotationY = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationYToRef(angle, result);\n    return result;\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\r\n   * @param angle defines the angle (in radians) to use\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationYToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the Z axis\r\n   * @param angle defines the angle (in radians) to use\r\n   * @return the new matrix\r\n   */\n\n\n  Matrix.RotationZ = function (angle) {\n    var result = new Matrix();\n    Matrix.RotationZToRef(angle, result);\n    return result;\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\r\n   * @param angle defines the angle (in radians) to use\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationZToRef = function (angle, result) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(c === 1 && s === 0);\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the given axis\r\n   * @param axis defines the axis to use\r\n   * @param angle defines the angle (in radians) to use\r\n   * @return the new matrix\r\n   */\n\n\n  Matrix.RotationAxis = function (axis, angle) {\n    var result = new Matrix();\n    Matrix.RotationAxisToRef(axis, angle, result);\n    return result;\n  };\n  /**\r\n   * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\r\n   * @param axis defines the axis to use\r\n   * @param angle defines the angle (in radians) to use\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationAxisToRef = function (axis, angle, result) {\n    var s = Math.sin(-angle);\n    var c = Math.cos(-angle);\n    var c1 = 1 - c;\n    axis.normalize();\n    var m = result._m;\n    m[0] = axis._x * axis._x * c1 + c;\n    m[1] = axis._x * axis._y * c1 - axis._z * s;\n    m[2] = axis._x * axis._z * c1 + axis._y * s;\n    m[3] = 0.0;\n    m[4] = axis._y * axis._x * c1 + axis._z * s;\n    m[5] = axis._y * axis._y * c1 + c;\n    m[6] = axis._y * axis._z * c1 - axis._x * s;\n    m[7] = 0.0;\n    m[8] = axis._z * axis._x * c1 - axis._y * s;\n    m[9] = axis._z * axis._y * c1 + axis._x * s;\n    m[10] = axis._z * axis._z * c1 + c;\n    m[11] = 0.0;\n    m[12] = 0.0;\n    m[13] = 0.0;\n    m[14] = 0.0;\n    m[15] = 1.0;\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\r\n   * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\r\n   * @param from defines the vector to align\r\n   * @param to defines the vector to align to\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationAlignToRef = function (from, to, result) {\n    var v = Vector3.Cross(to, from);\n    var c = Vector3.Dot(to, from);\n    var k = 1 / (1 + c);\n    var m = result._m;\n    m[0] = v._x * v._x * k + c;\n    m[1] = v._y * v._x * k - v._z;\n    m[2] = v._z * v._x * k + v._y;\n    m[3] = 0;\n    m[4] = v._x * v._y * k + v._z;\n    m[5] = v._y * v._y * k + c;\n    m[6] = v._z * v._y * k - v._x;\n    m[7] = 0;\n    m[8] = v._x * v._z * k - v._y;\n    m[9] = v._y * v._z * k + v._x;\n    m[10] = v._z * v._z * k + c;\n    m[11] = 0;\n    m[12] = 0;\n    m[13] = 0;\n    m[14] = 0;\n    m[15] = 1;\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Creates a rotation matrix\r\n   * @param yaw defines the yaw angle in radians (Y axis)\r\n   * @param pitch defines the pitch angle in radians (X axis)\r\n   * @param roll defines the roll angle in radians (Z axis)\r\n   * @returns the new rotation matrix\r\n   */\n\n\n  Matrix.RotationYawPitchRoll = function (yaw, pitch, roll) {\n    var result = new Matrix();\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n    return result;\n  };\n  /**\r\n   * Creates a rotation matrix and stores it in a given matrix\r\n   * @param yaw defines the yaw angle in radians (Y axis)\r\n   * @param pitch defines the pitch angle in radians (X axis)\r\n   * @param roll defines the roll angle in radians (Z axis)\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\n    MathTmp.Quaternion[0].toRotationMatrix(result);\n  };\n  /**\r\n   * Creates a scaling matrix\r\n   * @param x defines the scale factor on X axis\r\n   * @param y defines the scale factor on Y axis\r\n   * @param z defines the scale factor on Z axis\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.Scaling = function (x, y, z) {\n    var result = new Matrix();\n    Matrix.ScalingToRef(x, y, z, result);\n    return result;\n  };\n  /**\r\n   * Creates a scaling matrix and stores it in a given matrix\r\n   * @param x defines the scale factor on X axis\r\n   * @param y defines the scale factor on Y axis\r\n   * @param z defines the scale factor on Z axis\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.ScalingToRef = function (x, y, z, result) {\n    Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n\n    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n  };\n  /**\r\n   * Creates a translation matrix\r\n   * @param x defines the translation on X axis\r\n   * @param y defines the translation on Y axis\r\n   * @param z defines the translationon Z axis\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.Translation = function (x, y, z) {\n    var result = new Matrix();\n    Matrix.TranslationToRef(x, y, z, result);\n    return result;\n  };\n  /**\r\n   * Creates a translation matrix and stores it in a given matrix\r\n   * @param x defines the translation on X axis\r\n   * @param y defines the translation on Y axis\r\n   * @param z defines the translationon Z axis\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.TranslationToRef = function (x, y, z, result) {\n    Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n\n    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n  };\n  /**\r\n   * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n   * @param startValue defines the start value\r\n   * @param endValue defines the end value\r\n   * @param gradient defines the gradient factor\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.Lerp = function (startValue, endValue, gradient) {\n    var result = new Matrix();\n    Matrix.LerpToRef(startValue, endValue, gradient, result);\n    return result;\n  };\n  /**\r\n   * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n   * @param startValue defines the start value\r\n   * @param endValue defines the end value\r\n   * @param gradient defines the gradient factor\r\n   * @param result defines the Matrix object where to store data\r\n   */\n\n\n  Matrix.LerpToRef = function (startValue, endValue, gradient, result) {\n    var resultM = result._m;\n    var startM = startValue.m;\n    var endM = endValue.m;\n\n    for (var index = 0; index < 16; index++) {\n      resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\n    }\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Builds a new matrix whose values are computed by:\r\n   * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n   * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n   * @param startValue defines the first matrix\r\n   * @param endValue defines the second matrix\r\n   * @param gradient defines the gradient between the two matrices\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.DecomposeLerp = function (startValue, endValue, gradient) {\n    var result = new Matrix();\n    Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n    return result;\n  };\n  /**\r\n   * Update a matrix to values which are computed by:\r\n   * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n   * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n   * @param startValue defines the first matrix\r\n   * @param endValue defines the second matrix\r\n   * @param gradient defines the gradient between the two matrices\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.DecomposeLerpToRef = function (startValue, endValue, gradient, result) {\n    var startScale = MathTmp.Vector3[0];\n    var startRotation = MathTmp.Quaternion[0];\n    var startTranslation = MathTmp.Vector3[1];\n    startValue.decompose(startScale, startRotation, startTranslation);\n    var endScale = MathTmp.Vector3[2];\n    var endRotation = MathTmp.Quaternion[1];\n    var endTranslation = MathTmp.Vector3[3];\n    endValue.decompose(endScale, endRotation, endTranslation);\n    var resultScale = MathTmp.Vector3[4];\n    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n    var resultRotation = MathTmp.Quaternion[2];\n    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n    var resultTranslation = MathTmp.Vector3[5];\n    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n    Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n  };\n  /**\r\n   * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n   * This function works in left handed mode\r\n   * @param eye defines the final position of the entity\r\n   * @param target defines where the entity should look at\r\n   * @param up defines the up vector for the entity\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.LookAtLH = function (eye, target, up) {\n    var result = new Matrix();\n    Matrix.LookAtLHToRef(eye, target, up, result);\n    return result;\n  };\n  /**\r\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n   * This function works in left handed mode\r\n   * @param eye defines the final position of the entity\r\n   * @param target defines where the entity should look at\r\n   * @param up defines the up vector for the entity\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.LookAtLHToRef = function (eye, target, up, result) {\n    var xAxis = MathTmp.Vector3[0];\n    var yAxis = MathTmp.Vector3[1];\n    var zAxis = MathTmp.Vector3[2]; // Z axis\n\n    target.subtractToRef(eye, zAxis);\n    zAxis.normalize(); // X axis\n\n    Vector3.CrossToRef(up, zAxis, xAxis);\n    var xSquareLength = xAxis.lengthSquared();\n\n    if (xSquareLength === 0) {\n      xAxis.x = 1.0;\n    } else {\n      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n    } // Y axis\n\n\n    Vector3.CrossToRef(zAxis, xAxis, yAxis);\n    yAxis.normalize(); // Eye angles\n\n    var ex = -Vector3.Dot(xAxis, eye);\n    var ey = -Vector3.Dot(yAxis, eye);\n    var ez = -Vector3.Dot(zAxis, eye);\n    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n  };\n  /**\r\n   * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n   * This function works in right handed mode\r\n   * @param eye defines the final position of the entity\r\n   * @param target defines where the entity should look at\r\n   * @param up defines the up vector for the entity\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.LookAtRH = function (eye, target, up) {\n    var result = new Matrix();\n    Matrix.LookAtRHToRef(eye, target, up, result);\n    return result;\n  };\n  /**\r\n   * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n   * This function works in right handed mode\r\n   * @param eye defines the final position of the entity\r\n   * @param target defines where the entity should look at\r\n   * @param up defines the up vector for the entity\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.LookAtRHToRef = function (eye, target, up, result) {\n    var xAxis = MathTmp.Vector3[0];\n    var yAxis = MathTmp.Vector3[1];\n    var zAxis = MathTmp.Vector3[2]; // Z axis\n\n    eye.subtractToRef(target, zAxis);\n    zAxis.normalize(); // X axis\n\n    Vector3.CrossToRef(up, zAxis, xAxis);\n    var xSquareLength = xAxis.lengthSquared();\n\n    if (xSquareLength === 0) {\n      xAxis.x = 1.0;\n    } else {\n      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n    } // Y axis\n\n\n    Vector3.CrossToRef(zAxis, xAxis, yAxis);\n    yAxis.normalize(); // Eye angles\n\n    var ex = -Vector3.Dot(xAxis, eye);\n    var ey = -Vector3.Dot(yAxis, eye);\n    var ez = -Vector3.Dot(zAxis, eye);\n    Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n  };\n  /**\r\n   * Create a left-handed orthographic projection matrix\r\n   * @param width defines the viewport width\r\n   * @param height defines the viewport height\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a left-handed orthographic projection matrix\r\n   */\n\n\n  Matrix.OrthoLH = function (width, height, znear, zfar) {\n    var matrix = new Matrix();\n    Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\n    return matrix;\n  };\n  /**\r\n   * Store a left-handed orthographic projection to a given matrix\r\n   * @param width defines the viewport width\r\n   * @param height defines the viewport height\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.OrthoLHToRef = function (width, height, znear, zfar, result) {\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 / width;\n    var b = 2.0 / height;\n    var c = 2.0 / (f - n);\n    var d = -(f + n) / (f - n);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n\n    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n  };\n  /**\r\n   * Create a left-handed orthographic projection matrix\r\n   * @param left defines the viewport left coordinate\r\n   * @param right defines the viewport right coordinate\r\n   * @param bottom defines the viewport bottom coordinate\r\n   * @param top defines the viewport top coordinate\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a left-handed orthographic projection matrix\r\n   */\n\n\n  Matrix.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar) {\n    var matrix = new Matrix();\n    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\n    return matrix;\n  };\n  /**\r\n   * Stores a left-handed orthographic projection into a given matrix\r\n   * @param left defines the viewport left coordinate\r\n   * @param right defines the viewport right coordinate\r\n   * @param bottom defines the viewport bottom coordinate\r\n   * @param top defines the viewport top coordinate\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.OrthoOffCenterLHToRef = function (left, right, bottom, top, znear, zfar, result) {\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 / (right - left);\n    var b = 2.0 / (top - bottom);\n    var c = 2.0 / (f - n);\n    var d = -(f + n) / (f - n);\n    var i0 = (left + right) / (left - right);\n    var i1 = (top + bottom) / (bottom - top);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Creates a right-handed orthographic projection matrix\r\n   * @param left defines the viewport left coordinate\r\n   * @param right defines the viewport right coordinate\r\n   * @param bottom defines the viewport bottom coordinate\r\n   * @param top defines the viewport top coordinate\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a right-handed orthographic projection matrix\r\n   */\n\n\n  Matrix.OrthoOffCenterRH = function (left, right, bottom, top, znear, zfar) {\n    var matrix = new Matrix();\n    Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\n    return matrix;\n  };\n  /**\r\n   * Stores a right-handed orthographic projection into a given matrix\r\n   * @param left defines the viewport left coordinate\r\n   * @param right defines the viewport right coordinate\r\n   * @param bottom defines the viewport bottom coordinate\r\n   * @param top defines the viewport top coordinate\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.OrthoOffCenterRHToRef = function (left, right, bottom, top, znear, zfar, result) {\n    Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\n    result._m[10] *= -1; // No need to call _markAsUpdated as previous function already called it and let _isIdentityDirty to true\n  };\n  /**\r\n   * Creates a left-handed perspective projection matrix\r\n   * @param width defines the viewport width\r\n   * @param height defines the viewport height\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a left-handed perspective projection matrix\r\n   */\n\n\n  Matrix.PerspectiveLH = function (width, height, znear, zfar) {\n    var matrix = new Matrix();\n    var n = znear;\n    var f = zfar;\n    var a = 2.0 * n / width;\n    var b = 2.0 * n / height;\n    var c = (f + n) / (f - n);\n    var d = -2.0 * f * n / (f - n);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n\n    matrix._updateIdentityStatus(false);\n\n    return matrix;\n  };\n  /**\r\n   * Creates a left-handed perspective projection matrix\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a left-handed perspective projection matrix\r\n   */\n\n\n  Matrix.PerspectiveFovLH = function (fov, aspect, znear, zfar) {\n    var matrix = new Matrix();\n    Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\n    return matrix;\n  };\n  /**\r\n   * Stores a left-handed perspective projection into a given matrix\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n   */\n\n\n  Matrix.PerspectiveFovLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    var n = znear;\n    var f = zfar;\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var c = (f + n) / (f - n);\n    var d = -2.0 * f * n / (f - n);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n\n    result._updateIdentityStatus(false);\n  };\n  /**\r\n   * Stores a left-handed perspective projection into a given matrix with depth reversed\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar not used as infinity is used as far clip\r\n   * @param result defines the target matrix\r\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n   */\n\n\n  Matrix.PerspectiveFovReverseLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, -znear, 1.0, 0.0, 0.0, 1.0, 0.0, result);\n\n    result._updateIdentityStatus(false);\n  };\n  /**\r\n   * Creates a right-handed perspective projection matrix\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @returns a new matrix as a right-handed perspective projection matrix\r\n   */\n\n\n  Matrix.PerspectiveFovRH = function (fov, aspect, znear, zfar) {\n    var matrix = new Matrix();\n    Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\n    return matrix;\n  };\n  /**\r\n   * Stores a right-handed perspective projection into a given matrix\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n   */\n\n\n  Matrix.PerspectiveFovRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n    //alternatively this could be expressed as:\n    //    m = PerspectiveFovLHToRef\n    //    m[10] *= -1.0;\n    //    m[11] *= -1.0;\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    var n = znear;\n    var f = zfar;\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    var c = -(f + n) / (f - n);\n    var d = -2 * f * n / (f - n);\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n\n    result._updateIdentityStatus(false);\n  };\n  /**\r\n   * Stores a right-handed perspective projection into a given matrix\r\n   * @param fov defines the horizontal field of view\r\n   * @param aspect defines the aspect ratio\r\n   * @param znear defines the near clip plane\r\n   * @param zfar not used as infinity is used as far clip\r\n   * @param result defines the target matrix\r\n   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n   */\n\n\n  Matrix.PerspectiveFovReverseRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n    //alternatively this could be expressed as:\n    //    m = PerspectiveFovLHToRef\n    //    m[10] *= -1.0;\n    //    m[11] *= -1.0;\n    if (isVerticalFovFixed === void 0) {\n      isVerticalFovFixed = true;\n    }\n\n    var t = 1.0 / Math.tan(fov * 0.5);\n    var a = isVerticalFovFixed ? t / aspect : t;\n    var b = isVerticalFovFixed ? t : t * aspect;\n    Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, -znear, -1.0, 0.0, 0.0, -1.0, 0.0, result);\n\n    result._updateIdentityStatus(false);\n  };\n  /**\r\n   * Stores a perspective projection for WebVR info a given matrix\r\n   * @param fov defines the field of view\r\n   * @param znear defines the near clip plane\r\n   * @param zfar defines the far clip plane\r\n   * @param result defines the target matrix\r\n   * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\r\n   */\n\n\n  Matrix.PerspectiveFovWebVRToRef = function (fov, znear, zfar, result, rightHanded) {\n    if (rightHanded === void 0) {\n      rightHanded = false;\n    }\n\n    var rightHandedFactor = rightHanded ? -1 : 1;\n    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n    var xScale = 2.0 / (leftTan + rightTan);\n    var yScale = 2.0 / (upTan + downTan);\n    var m = result._m;\n    m[0] = xScale;\n    m[1] = m[2] = m[3] = m[4] = 0.0;\n    m[5] = yScale;\n    m[6] = m[7] = 0.0;\n    m[8] = (leftTan - rightTan) * xScale * 0.5;\n    m[9] = -((upTan - downTan) * yScale * 0.5);\n    m[10] = -zfar / (znear - zfar);\n    m[11] = 1.0 * rightHandedFactor;\n    m[12] = m[13] = m[15] = 0.0;\n    m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n\n    result._markAsUpdated();\n  };\n  /**\r\n   * Computes a complete transformation matrix\r\n   * @param viewport defines the viewport to use\r\n   * @param world defines the world matrix\r\n   * @param view defines the view matrix\r\n   * @param projection defines the projection matrix\r\n   * @param zmin defines the near clip plane\r\n   * @param zmax defines the far clip plane\r\n   * @returns the transformation matrix\r\n   */\n\n\n  Matrix.GetFinalMatrix = function (viewport, world, view, projection, zmin, zmax) {\n    var cw = viewport.width;\n    var ch = viewport.height;\n    var cx = viewport.x;\n    var cy = viewport.y;\n    var viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\n    var matrix = MathTmp.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    return matrix.multiply(viewportMatrix);\n  };\n  /**\r\n   * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\r\n   * @param matrix defines the matrix to use\r\n   * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\r\n   */\n\n\n  Matrix.GetAsMatrix2x2 = function (matrix) {\n    var m = matrix.m;\n    var arr = [m[0], m[1], m[4], m[5]];\n    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n  };\n  /**\r\n   * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\r\n   * @param matrix defines the matrix to use\r\n   * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\r\n   */\n\n\n  Matrix.GetAsMatrix3x3 = function (matrix) {\n    var m = matrix.m;\n    var arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\n    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n  };\n  /**\r\n   * Compute the transpose of a given matrix\r\n   * @param matrix defines the matrix to transpose\r\n   * @returns the new matrix\r\n   */\n\n\n  Matrix.Transpose = function (matrix) {\n    var result = new Matrix();\n    Matrix.TransposeToRef(matrix, result);\n    return result;\n  };\n  /**\r\n   * Compute the transpose of a matrix and store it in a target matrix\r\n   * @param matrix defines the matrix to transpose\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.TransposeToRef = function (matrix, result) {\n    var rm = result._m;\n    var mm = matrix.m;\n    rm[0] = mm[0];\n    rm[1] = mm[4];\n    rm[2] = mm[8];\n    rm[3] = mm[12];\n    rm[4] = mm[1];\n    rm[5] = mm[5];\n    rm[6] = mm[9];\n    rm[7] = mm[13];\n    rm[8] = mm[2];\n    rm[9] = mm[6];\n    rm[10] = mm[10];\n    rm[11] = mm[14];\n    rm[12] = mm[3];\n    rm[13] = mm[7];\n    rm[14] = mm[11];\n    rm[15] = mm[15]; // identity-ness does not change when transposing\n\n    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n  };\n  /**\r\n   * Computes a reflection matrix from a plane\r\n   * @param plane defines the reflection plane\r\n   * @returns a new matrix\r\n   */\n\n\n  Matrix.Reflection = function (plane) {\n    var matrix = new Matrix();\n    Matrix.ReflectionToRef(plane, matrix);\n    return matrix;\n  };\n  /**\r\n   * Computes a reflection matrix from a plane\r\n   * @param plane defines the reflection plane\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.ReflectionToRef = function (plane, result) {\n    plane.normalize();\n    var x = plane.normal.x;\n    var y = plane.normal.y;\n    var z = plane.normal.z;\n    var temp = -2 * x;\n    var temp2 = -2 * y;\n    var temp3 = -2 * z;\n    Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n  };\n  /**\r\n   * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\r\n   * @param xaxis defines the value of the 1st axis\r\n   * @param yaxis defines the value of the 2nd axis\r\n   * @param zaxis defines the value of the 3rd axis\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.FromXYZAxesToRef = function (xaxis, yaxis, zaxis, result) {\n    Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0.0, yaxis._x, yaxis._y, yaxis._z, 0.0, zaxis._x, zaxis._y, zaxis._z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n  };\n  /**\r\n   * Creates a rotation matrix from a quaternion and stores it in a target matrix\r\n   * @param quat defines the quaternion to use\r\n   * @param result defines the target matrix\r\n   */\n\n\n  Matrix.FromQuaternionToRef = function (quat, result) {\n    var xx = quat._x * quat._x;\n    var yy = quat._y * quat._y;\n    var zz = quat._z * quat._z;\n    var xy = quat._x * quat._y;\n    var zw = quat._z * quat._w;\n    var zx = quat._z * quat._x;\n    var yw = quat._y * quat._w;\n    var yz = quat._y * quat._z;\n    var xw = quat._x * quat._w;\n    result._m[0] = 1.0 - 2.0 * (yy + zz);\n    result._m[1] = 2.0 * (xy + zw);\n    result._m[2] = 2.0 * (zx - yw);\n    result._m[3] = 0.0;\n    result._m[4] = 2.0 * (xy - zw);\n    result._m[5] = 1.0 - 2.0 * (zz + xx);\n    result._m[6] = 2.0 * (yz + xw);\n    result._m[7] = 0.0;\n    result._m[8] = 2.0 * (zx + yw);\n    result._m[9] = 2.0 * (yz - xw);\n    result._m[10] = 1.0 - 2.0 * (yy + xx);\n    result._m[11] = 0.0;\n    result._m[12] = 0.0;\n    result._m[13] = 0.0;\n    result._m[14] = 0.0;\n    result._m[15] = 1.0;\n\n    result._markAsUpdated();\n  };\n\n  Matrix._updateFlagSeed = 0;\n  Matrix._identityReadOnly = Matrix.Identity();\n  return Matrix;\n}();\n\nexport { Matrix };\n/**\r\n * @hidden\r\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\r\n */\n\nvar MathTmp =\n/** @class */\nfunction () {\n  function MathTmp() {}\n\n  MathTmp.Vector3 = ArrayTools.BuildArray(6, Vector3.Zero);\n  MathTmp.Matrix = ArrayTools.BuildArray(2, Matrix.Identity);\n  MathTmp.Quaternion = ArrayTools.BuildArray(3, Quaternion.Zero);\n  return MathTmp;\n}();\n/**\r\n * @hidden\r\n */\n\n\nvar TmpVectors =\n/** @class */\nfunction () {\n  function TmpVectors() {}\n\n  TmpVectors.Vector2 = ArrayTools.BuildArray(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\n\n  TmpVectors.Vector3 = ArrayTools.BuildArray(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\n\n  TmpVectors.Vector4 = ArrayTools.BuildArray(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\n\n  TmpVectors.Quaternion = ArrayTools.BuildArray(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\n\n  TmpVectors.Matrix = ArrayTools.BuildArray(8, Matrix.Identity); // 8 temp Matrices at once should be enough\n\n  return TmpVectors;\n}();\n\nexport { TmpVectors };\n_TypeStore.RegisteredTypes[\"BABYLON.Vector2\"] = Vector2;\n_TypeStore.RegisteredTypes[\"BABYLON.Vector3\"] = Vector3;\n_TypeStore.RegisteredTypes[\"BABYLON.Vector4\"] = Vector4;\n_TypeStore.RegisteredTypes[\"BABYLON.Matrix\"] = Matrix;","map":{"version":3,"sources":["../../../sourceES6/core/Maths/math.vector.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,eAAvB;AACA,SAAS,OAAT,QAAwB,kBAAxB;AAGA,SAAS,UAAT,QAA2B,oBAA3B;AAEA,SAAS,UAAT,QAA2B,mBAA3B;AAEA,SAAS,uBAAT,QAAwC,oCAAxC;AAEA;;;;AAGA,IAAA,OAAA;AAAA;AAAA,YAAA;AACI;;;;;AAKA,WAAA,OAAA;AACI;AACO,EAAA,CAFX;AAGI;AACO,EAAA,CAJX,EAIwB;AAFb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;;AAEb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;;AAFb,SAAA,CAAA,GAAA,CAAA;AAEA,SAAA,CAAA,GAAA,CAAA;AACV;AAED;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,SAAS,KAAK,CAAd,GAAkB,MAAlB,GAA2B,KAAK,CAAhC,GAAoC,GAA3C;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,KAAK,CAAL,GAAS,CAApB;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,CAAL,GAAS,CAAzB,CAAP;AACA,WAAO,IAAP;AACH,GAJM,CAjCX,CAuCI;;AAEA;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAAkC,KAAlC,EAAmD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAiB;;AAC/C,IAAA,KAAK,CAAC,KAAD,CAAL,GAAe,KAAK,CAApB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,CAAxB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAAoC,KAApC,EAAqD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAiB;;AACjD,IAAA,OAAO,CAAC,cAAR,CAAuB,KAAvB,EAA8B,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,MAAM,GAAG,IAAI,KAAJ,EAAb;AACA,SAAK,OAAL,CAAa,MAAb,EAAqB,CAArB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,MAAhB,EAA8C;AAC1C,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA0C;AACtC,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAsB,CAAtB,EAA+B;AAC3B,WAAO,KAAK,cAAL,CAAoB,CAApB,EAAuB,CAAvB,CAAP;AACH,GAFM;AAGP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,WAAX,EAA8C;AAC1C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAqD,MAArD,EAAoE;AAChE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAAqD;AACjD,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAAsC;AAClC,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAoC;AAChC,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAKP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA0D;AACtD,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA0D;AACtD,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAmD;AAC/C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,CAAxB,EAAmC,CAAnC,EAA4C;AACxC,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,CAArB,EAAwB,KAAK,CAAL,GAAS,CAAjC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAkC;AAC9B,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,WAAnB,EAAwD,MAAxD,EAAuE;AACnE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAAwD;AACpD,WAAO,KAAK,WAAL,CAAiB,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAC,KAAK,CAAlB,EAAqB,CAAC,KAAK,CAA3B,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAkC;AAC9B,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAL,GAAS,CAAC,CAAhC,EAAmC,KAAK,CAAL,GAAS,CAAC,CAA7C,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,KAApB,EAAiC;AAC7B,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B;AACtB,QAAI,MAAM,GAAG,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAb;AACA,SAAK,UAAL,CAAgB,KAAhB,EAAuB,MAAvB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,MAAjC,EAAgD;AAC5C,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,MAAvC,EAAsD;AAClD,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAiD;AAC7C,WAAO,WAAW,IAAI,KAAK,CAAL,KAAW,WAAW,CAAC,CAAtC,IAA2C,KAAK,CAAL,KAAW,WAAW,CAAC,CAAzE;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,WAAzB,EAA8D,OAA9D,EAAuF;AAAzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,OAAA;AAAyB;;AACnF,WAAO,WAAW,IAAI,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CAAf,IAAuE,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CAA9E;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAZ,EAAgC,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAhC,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAArB,EAAyC,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAlD,CAAP;AACH,GAFM,CAlWX,CAsWI;;AAEA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,CAAC,IAAL,CAAU,KAAK,CAAL,GAAS,KAAK,CAAd,GAAkB,KAAK,CAAL,GAAS,KAAK,CAA1C,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,WAAQ,KAAK,CAAL,GAAS,KAAK,CAAd,GAAkB,KAAK,CAAL,GAAS,KAAK,CAAxC;AACH,GAFM,CApXX,CAwXI;;AAEA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,GAAG,GAAG,KAAK,MAAL,EAAV;;AAEA,QAAI,GAAG,KAAK,CAAZ,EAAe;AACX,aAAO,IAAP;AACH;;AAED,SAAK,CAAL,IAAU,GAAV;AACA,SAAK,CAAL,IAAU,GAAV;AAEA,WAAO,IAAP;AACH,GAXM;AAaP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAjB,EAAoB,KAAK,CAAzB,CAAP;AACH,GAFM,CA/YX,CAmZI;;AAEA;;;;;;AAIc,EAAA,OAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAFa;AAId;;;;;;AAIc,EAAA,OAAA,CAAA,GAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAiE,MAAjE,EAAmF;AAAlB,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAA;AAAkB;;AAC/E,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAC,MAAD,CAAjB,EAA2B,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhC,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAsE,MAAtE,EAAsF,MAAtF,EAAqG;AACjG,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAD,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACH,GAHa;AAKd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,UAAA,GAAd,UAAyB,MAAzB,EAAyD,MAAzD,EAAyF,MAAzF,EAAyH,MAAzH,EAAyJ,MAAzJ,EAAuK;AACnK,QAAI,OAAO,GAAG,MAAM,GAAG,MAAvB;AACA,QAAI,KAAK,GAAG,MAAM,GAAG,OAArB;AAEA,QAAI,CAAC,GAAG,OAAU,MAAM,MAAM,CAAC,CAAd,GAAoB,CAAC,CAAC,MAAM,CAAC,CAAR,GAAY,MAAM,CAAC,CAApB,IAAyB,MAA9C,GACX,CAAI,MAAM,MAAM,CAAC,CAAd,GAAoB,MAAM,MAAM,CAAC,CAAlC,GAAyC,MAAM,MAAM,CAAC,CAAvD,GAA6D,MAAM,CAAC,CAArE,IAA0E,OADhE,GAEV,CAAG,CAAC,MAAM,CAAC,CAAR,GAAa,MAAM,MAAM,CAAC,CAA3B,GAAkC,MAAM,MAAM,CAAC,CAAhD,GAAsD,MAAM,CAAC,CAA9D,IAAmE,KAFhE,CAAR;AAIA,QAAI,CAAC,GAAG,OAAU,MAAM,MAAM,CAAC,CAAd,GAAoB,CAAC,CAAC,MAAM,CAAC,CAAR,GAAY,MAAM,CAAC,CAApB,IAAyB,MAA9C,GACX,CAAI,MAAM,MAAM,CAAC,CAAd,GAAoB,MAAM,MAAM,CAAC,CAAlC,GAAyC,MAAM,MAAM,CAAC,CAAvD,GAA6D,MAAM,CAAC,CAArE,IAA0E,OADhE,GAEV,CAAG,CAAC,MAAM,CAAC,CAAR,GAAa,MAAM,MAAM,CAAC,CAA3B,GAAkC,MAAM,MAAM,CAAC,CAAhD,GAAsD,MAAM,CAAC,CAA9D,IAAmE,KAFhE,CAAR;AAIA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAba;AAed;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,KAAA,GAAd,UAAoB,KAApB,EAAmD,GAAnD,EAAgF,GAAhF,EAA2G;AACvG,QAAI,CAAC,GAAG,KAAK,CAAC,CAAd;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,CAAT,GAAc,GAAG,CAAC,CAAlB,GAAsB,CAA1B;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,CAAT,GAAc,GAAG,CAAC,CAAlB,GAAsB,CAA1B;AAEA,QAAI,CAAC,GAAG,KAAK,CAAC,CAAd;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,CAAT,GAAc,GAAG,CAAC,CAAlB,GAAsB,CAA1B;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,CAAT,GAAc,GAAG,CAAC,CAAlB,GAAsB,CAA1B;AAEA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAVa;AAYd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,OAAA,GAAd,UAAsB,MAAtB,EAAsD,QAAtD,EAAwF,MAAxF,EAAwH,QAAxH,EAA0J,MAA1J,EAAwK;AACpK,QAAI,OAAO,GAAG,MAAM,GAAG,MAAvB;AACA,QAAI,KAAK,GAAG,MAAM,GAAG,OAArB;AACA,QAAI,KAAK,GAAK,MAAM,KAAP,GAAiB,MAAM,OAAxB,GAAoC,GAAhD;AACA,QAAI,KAAK,GAAI,CAAC,GAAD,GAAO,KAAR,GAAkB,MAAM,OAApC;AACA,QAAI,KAAK,GAAI,KAAK,GAAI,MAAM,OAAhB,GAA4B,MAAxC;AACA,QAAI,KAAK,GAAG,KAAK,GAAG,OAApB;AAEA,QAAI,CAAC,GAAM,MAAM,CAAC,CAAP,GAAW,KAAZ,GAAsB,MAAM,CAAC,CAAP,GAAW,KAAlC,GAA6C,QAAQ,CAAC,CAAT,GAAa,KAA3D,GAAsE,QAAQ,CAAC,CAAT,GAAa,KAA3F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,CAAP,GAAW,KAAZ,GAAsB,MAAM,CAAC,CAAP,GAAW,KAAlC,GAA6C,QAAQ,CAAC,CAAT,GAAa,KAA3D,GAAsE,QAAQ,CAAC,CAAT,GAAa,KAA3F;AAEA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAZa;AAcd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,IAAA,GAAd,UAAmB,KAAnB,EAAkD,GAAlD,EAA+E,MAA/E,EAA6F;AACzF,QAAI,CAAC,GAAG,KAAK,CAAC,CAAN,GAAW,CAAC,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAC,CAAf,IAAoB,MAAvC;AACA,QAAI,CAAC,GAAG,KAAK,CAAC,CAAN,GAAW,CAAC,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAC,CAAf,IAAoB,MAAvC;AACA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,GAAA,GAAd,UAAkB,IAAlB,EAAgD,KAAhD,EAA6E;AACzE,WAAO,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAf,GAAmB,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAzC;AACH,GAFa;AAId;;;;;;;AAKc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAsD;AAClD,QAAI,SAAS,GAAG,MAAM,CAAC,KAAP,EAAhB;AACA,IAAA,SAAS,CAAC,SAAV;AACA,WAAO,SAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,CAAC,GAAI,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAhB,GAAqB,IAAI,CAAC,CAA1B,GAA8B,KAAK,CAAC,CAA5C;AACA,QAAI,CAAC,GAAI,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAhB,GAAqB,IAAI,CAAC,CAA1B,GAA8B,KAAK,CAAC,CAA5C;AACA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,CAAC,GAAI,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAhB,GAAqB,IAAI,CAAC,CAA1B,GAA8B,KAAK,CAAC,CAA5C;AACA,QAAI,CAAC,GAAI,IAAI,CAAC,CAAL,GAAS,KAAK,CAAC,CAAhB,GAAqB,IAAI,CAAC,CAA1B,GAA8B,KAAK,CAAC,CAA5C;AACA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAwD,cAAxD,EAA6F;AACzF,QAAI,CAAC,GAAG,OAAO,CAAC,IAAR,EAAR;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,MAAvB,EAA+B,cAA/B,EAA+C,CAA/C;AACA,WAAO,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA6D,cAA7D,EAAoG,MAApG,EAAmH;AAC/G,QAAM,CAAC,GAAG,cAAc,CAAC,CAAzB;AACA,QAAI,CAAC,GAAI,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAb,GAAqB,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAjC,GAAwC,CAAC,CAAC,EAAD,CAAjD;AACA,QAAI,CAAC,GAAI,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAb,GAAqB,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAjC,GAAwC,CAAC,CAAC,EAAD,CAAjD;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACH,GANa;AAQd;;;;;;;;;;AAQc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,CAA9B,EAAyD,EAAzD,EAAqF,EAArF,EAAiH,EAAjH,EAA2I;AACvI,QAAI,CAAC,GAAG,IAAI,CAAJ,IAAS,CAAC,EAAE,CAAC,CAAJ,GAAQ,EAAE,CAAC,CAAX,GAAe,EAAE,CAAC,CAAH,IAAQ,CAAC,EAAE,CAAC,CAAJ,GAAQ,EAAE,CAAC,CAAnB,CAAf,GAAuC,EAAE,CAAC,CAAH,IAAQ,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAlB,CAAvC,GAA8D,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAjF,CAAR;AACA,QAAI,IAAI,GAAG,CAAC,GAAG,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAAxB;AACA,QAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAV,GAAc,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAxB,GAA4B,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,CAAC,CAAC,CAA9C,GAAkD,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,CAAC,CAAC,CAArE,IAA0E,IAAlF;AACA,QAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAV,GAAc,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAxB,GAA4B,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,CAAC,CAAC,CAA9C,GAAkD,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,CAAC,CAAC,CAArE,IAA0E,IAAlF;AAEA,WAAO,CAAC,GAAG,CAAJ,IAAS,CAAC,GAAG,CAAb,IAAmB,CAAC,GAAG,CAAL,GAAU,IAAI,CAAJ,GAAQ,IAA3C;AACH,GAPa;AASd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,MAAvB,EAAuD,MAAvD,EAAqF;AACjF,WAAO,IAAI,CAAC,IAAL,CAAU,OAAO,CAAC,eAAR,CAAwB,MAAxB,EAAgC,MAAhC,CAAV,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,MAA9B,EAA8D,MAA9D,EAA4F;AACxF,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AACA,WAAQ,CAAC,GAAG,CAAL,GAAW,CAAC,GAAG,CAAtB;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,MAAA,GAAd,UAAqB,MAArB,EAAqD,MAArD,EAAmF;AAC/E,QAAI,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,MAAX,CAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,GAApB;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,0BAAA,GAAd,UAAyC,CAAzC,EAAoE,IAApE,EAAkG,IAAlG,EAA8H;AAC1H,QAAI,EAAE,GAAG,OAAO,CAAC,eAAR,CAAwB,IAAxB,EAA8B,IAA9B,CAAT;;AACA,QAAI,EAAE,KAAK,GAAX,EAAgB;AACZ,aAAO,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,IAApB,CAAP;AACH;;AACD,QAAI,CAAC,GAAG,IAAI,CAAC,QAAL,CAAc,IAAd,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,OAAO,CAAC,GAAR,CAAY,CAAC,CAAC,QAAF,CAAW,IAAX,CAAZ,EAA8B,CAA9B,IAAmC,EAA/C,CAAZ,CAAR;AACA,QAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,CAAC,gBAAF,CAAmB,CAAnB,EAAsB,CAAtB,CAAT,CAAX;AACA,WAAO,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,IAApB,CAAP;AACH,GATa;;AAUlB,SAAA,OAAA;AAAC,CAtpBD,EAAA;;;AAwpBA;;;;;;;AAMA,IAAA,OAAA;AAAA;AAAA,YAAA;AA8CI;;;;;;AAMA,WAAA,OAAA,CACI,CADJ,EAEI,CAFJ,EAGI,CAHJ,EAGiB;AAFb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;;AACb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;;AACb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;AA1CjB;;;AACO,SAAA,QAAA,GAAW,IAAX;AA2CH,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACH;;AA3CD,EAAA,MAAA,CAAA,cAAA,CAAW,OAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,OAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,OAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAyBA;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,SAAS,KAAK,EAAd,GAAmB,KAAnB,GAA2B,KAAK,EAAhC,GAAqC,KAArC,GAA6C,KAAK,EAAlD,GAAuD,GAA9D;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,KAAK,EAAL,GAAU,CAArB;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,GAAU,CAA1B,CAAP;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,GAAU,CAA1B,CAAP;AACA,WAAO,IAAP;AACH,GALM,CAlFX,CAyFI;;AAEA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,MAAM,GAAa,EAAvB;AACA,SAAK,OAAL,CAAa,MAAb,EAAqB,CAArB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAAkC,KAAlC,EAAmD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAiB;;AAC/C,IAAA,KAAK,CAAC,KAAD,CAAL,GAAe,KAAK,EAApB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,EAAxB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,EAAxB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAAoC,KAApC,EAAqD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAiB;;AACjD,IAAA,OAAO,CAAC,cAAR,CAAuB,KAAvB,EAA8B,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,UAAU,CAAC,oBAAX,CAAgC,KAAK,EAArC,EAAyC,KAAK,EAA9C,EAAkD,KAAK,EAAvD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAAqD;AACjD,WAAO,KAAK,oBAAL,CAA0B,WAAW,CAAC,EAAtC,EAA0C,WAAW,CAAC,EAAtD,EAA0D,WAAW,CAAC,EAAtE,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,UAA4B,CAA5B,EAAuC,CAAvC,EAAkD,CAAlD,EAA2D;AACvD,SAAK,CAAL,IAAU,CAAV;AACA,SAAK,CAAL,IAAU,CAAV;AACA,SAAK,CAAL,IAAU,CAAV;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,WAAX,EAA8C;AAC1C,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,WAAW,CAAC,EAAlC,EAAsC,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5D,EAAgE,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAqD,MAArD,EAAoE;AAChE,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5C,EAAgD,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtE,EAA0E,KAAK,EAAL,GAAU,WAAW,CAAC,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA0D;AACtD,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAmD;AAC/C,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,WAAW,CAAC,EAAlC,EAAsC,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5D,EAAgE,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,WAAO,KAAK,uBAAL,CAA6B,WAAW,CAAC,EAAzC,EAA6C,WAAW,CAAC,EAAzD,EAA6D,WAAW,CAAC,EAAzE,EAA6E,MAA7E,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,CAA1B,EAAqC,CAArC,EAAgD,CAAhD,EAAyD;AACrD,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,CAAtB,EAAyB,KAAK,EAAL,GAAU,CAAnC,EAAsC,KAAK,EAAL,GAAU,CAAhD,CAAP;AACH,GAFM;AAIP;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,CAA/B,EAA0C,CAA1C,EAAqD,CAArD,EAAgE,MAAhE,EAA+E;AAC3E,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,CAAhC,EAAmC,KAAK,EAAL,GAAU,CAA7C,EAAgD,KAAK,EAAL,GAAU,CAA1D,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAC,KAAK,EAAlB,EAAsB,CAAC,KAAK,EAA5B,EAAgC,CAAC,KAAK,EAAtC,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAkC;AAC9B,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,CAAC,CAAjC,EAAoC,KAAK,EAAL,GAAU,CAAC,CAA/C,EAAkD,KAAK,EAAL,GAAU,CAAC,CAA7D,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,KAApB,EAAiC;AAC7B,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B;AACtB,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,KAAtB,EAA6B,KAAK,EAAL,GAAU,KAAvC,EAA8C,KAAK,EAAL,GAAU,KAAxD,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,MAAjC,EAAgD;AAC5C,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,KAAhC,EAAuC,KAAK,EAAL,GAAU,KAAjD,EAAwD,KAAK,EAAL,GAAU,KAAlE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,MAAvC,EAAsD;AAClD,WAAO,MAAM,CAAC,oBAAP,CAA4B,KAAK,EAAL,GAAU,KAAtC,EAA6C,KAAK,EAAL,GAAU,KAAvD,EAA8D,KAAK,EAAL,GAAU,KAAxE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,KAAtB,EAAoC,MAApC,EAAmD;AAC/C,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,SAAK,mBAAL,CAAyB,KAAzB,EAAgC,MAAhC,EAAwC,MAAxC;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,KAA3B,EAAyC,MAAzC,EAA0D,MAA1D,EAAyE;AACrE,QAAI,CAAC,GAAG,KAAK,CAAC,MAAd;AACA,QAAI,CAAC,GAAG,KAAK,CAAC,CAAd;AAEA,QAAI,CAAC,GAAI,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAT,CAJqE,CAMrE;;AACA,SAAK,aAAL,CAAmB,MAAnB,EAA2B,CAA3B;AAEA,IAAA,CAAC,CAAC,SAAF;AAEA,QAAI,KAAK,GAAG,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,CAAf,CAAZ;AACA,QAAI,CAAC,GAAG,EAAE,OAAO,CAAC,GAAR,CAAY,MAAZ,EAAoB,CAApB,IAAyB,CAA3B,IAAgC,KAAxC,CAZqE,CAcrE;;AACA,QAAI,OAAO,GAAG,CAAC,CAAC,YAAF,CAAe,CAAf,CAAd;AACA,IAAA,MAAM,CAAC,QAAP,CAAgB,OAAhB,EAAyB,MAAzB;AACH,GAjBM;AAmBP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAiD;AAC7C,WAAO,WAAW,IAAI,KAAK,EAAL,KAAY,WAAW,CAAC,EAAvC,IAA6C,KAAK,EAAL,KAAY,WAAW,CAAC,EAArE,IAA2E,KAAK,EAAL,KAAY,WAAW,CAAC,EAA1G;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,WAAzB,EAA8D,OAA9D,EAAuF;AAAzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,OAAA;AAAyB;;AACnF,WAAO,WAAW,IAAI,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,WAAW,CAAC,EAA1C,EAA8C,OAA9C,CAAf,IAAyE,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,WAAW,CAAC,EAA1C,EAA8C,OAA9C,CAAzE,IAAmI,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,WAAW,CAAC,EAA1C,EAA8C,OAA9C,CAA1I;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAqD;AACjD,WAAO,KAAK,EAAL,KAAY,CAAZ,IAAiB,KAAK,EAAL,KAAY,CAA7B,IAAkC,KAAK,EAAL,KAAY,CAArD;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA0D;AACtD,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,EAAtB;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAmD;AAC/C,WAAO,KAAK,gBAAL,CAAsB,WAAW,CAAC,EAAlC,EAAsC,WAAW,CAAC,EAAlD,EAAsD,WAAW,CAAC,EAAlE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5C,EAAgD,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtE,EAA0E,KAAK,EAAL,GAAU,WAAW,CAAC,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,CAAxB,EAAmC,CAAnC,EAA8C,CAA9C,EAAuD;AACnD,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,CAAtB,EAAyB,KAAK,EAAL,GAAU,CAAnC,EAAsC,KAAK,EAAL,GAAU,CAAhD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAiD;AAC7C,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,WAAW,CAAC,EAAlC,EAAsC,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5D,EAAgE,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtF,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,WAAnB,EAAwD,MAAxD,EAAuE;AACnE,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,EAAL,GAAU,WAAW,CAAC,EAA5C,EAAgD,KAAK,EAAL,GAAU,WAAW,CAAC,EAAtE,EAA0E,KAAK,EAAL,GAAU,WAAW,CAAC,EAAhG,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAAyC;AACrC,WAAO,KAAK,WAAL,CAAiB,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAoD;AAChD,WAAO,KAAK,yBAAL,CAA+B,KAAK,CAAC,EAArC,EAAyC,KAAK,CAAC,EAA/C,EAAmD,KAAK,CAAC,EAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAoD;AAChD,WAAO,KAAK,yBAAL,CAA+B,KAAK,CAAC,EAArC,EAAyC,KAAK,CAAC,EAA/C,EAAmD,KAAK,CAAC,EAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,UAAiC,CAAjC,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC5D,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,UAAiC,CAAjC,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC5D,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,QAAI,CAAC,GAAG,KAAK,EAAb,EAAiB;AAAE,WAAK,CAAL,GAAS,CAAT;AAAa;;AAChC,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,UAAiC,OAAjC,EAAgD;AAC5C,QAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;AACA,QAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;;AACA,QAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,QAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;;AACA,QAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,QAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,OAAjC,CAAL,EAAgD;AAC5C,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH,GAjBM;;AAsBP,EAAA,MAAA,CAAA,cAAA,CAAW,OAAA,CAAA,SAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA,YAAA;AACI,UAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACf,eAAO,IAAP;AACH;;AAED,UAAI,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,EAAd,CAAX;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACf,eAAO,IAAP;AACH;;AAED,aAAO,KAAP;AACH,KAbsB;qBAAA;;AAAA,GAAvB;AAeA;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAAZ,EAAiC,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAAjC,EAAsD,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAAtD,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,GAAU,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAAtB,EAA2C,KAAK,EAAL,GAAU,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAArD,EAA0E,KAAK,EAAL,GAAU,IAAI,CAAC,KAAL,CAAW,KAAK,EAAhB,CAApF,CAAP;AACH,GAFM,CA1hBX,CA8hBI;;AACA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,CAAC,IAAL,CAAU,KAAK,EAAL,GAAU,KAAK,EAAf,GAAoB,KAAK,EAAL,GAAU,KAAK,EAAnC,GAAwC,KAAK,EAAL,GAAU,KAAK,EAAjE,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,WAAQ,KAAK,EAAL,GAAU,KAAK,EAAf,GAAoB,KAAK,EAAL,GAAU,KAAK,EAAnC,GAAwC,KAAK,EAAL,GAAU,KAAK,EAA/D;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,KAAK,mBAAL,CAAyB,KAAK,MAAL,EAAzB,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,KAAtB,EAAmC;AAAnC,QAAA,KAAA,GAAA,IAAA;;AACI,IAAA,KAAK,GAAG,KAAK,CAAC,WAAN,EAAR;;AACA,QAAI,KAAK,KAAK,KAAd,EAAqB;AACjB,aAAO,IAAP;AACH;;AACD,IAAA,OAAO,CAAC,OAAR,CAAgB,CAAhB,EAAmB,QAAnB,CAA4B,IAA5B;AACA,KAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,OAAhB,CAAwB,UAAC,GAAD,EAAM,CAAN,EAAO;AACrB,MAAA,KAAK,CAAC,GAAD,CAAL,GAAmB,OAAO,CAAC,OAAR,CAAgB,CAAhB,EAAoB,KAAK,CAAC,CAAD,CAAzB,CAAnB;AACT,KAFD;AAGA,WAAO,IAAP;AACH,GAVM;AAYP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,UAA/B,EAAuD,MAAvD,EAAsE;AAClE,IAAA,UAAU,CAAC,gBAAX,CAA4B,OAAO,CAAC,MAAR,CAAe,CAAf,CAA5B;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,IAAlC,EAAwC,OAAO,CAAC,MAAR,CAAe,CAAf,CAAxC,EAA2D,MAA3D;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,kCAAA,GAAP,UAA0C,UAA1C,EAAkE,KAAlE,EAAkF,MAAlF,EAAiG;AAC7F,SAAK,aAAL,CAAmB,KAAnB,EAA0B,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAA1B;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,CAAhB,EAAmB,uBAAnB,CAA2C,UAA3C,EAAuD,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAvD;AACA,IAAA,KAAK,CAAC,QAAN,CAAe,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAf,EAAmC,MAAnC;AACA,WAAO,MAAP;AACH,GALM;AAOP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA2B;AACvB,WAAO,OAAO,CAAC,KAAR,CAAc,IAAd,EAAoB,KAApB,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,GAA3B,EAAsC;AAClC,QAAI,GAAG,KAAK,CAAR,IAAa,GAAG,KAAK,GAAzB,EAA8B;AAC1B,aAAO,IAAP;AACH;;AAED,WAAO,KAAK,YAAL,CAAkB,MAAM,GAAxB,CAAP;AACH,GANM;AAQP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,QAAM,UAAU,GAAG,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAnB;AACA,SAAK,cAAL,CAAoB,UAApB;AACA,WAAO,UAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,SAAtB,EAAwC;AACpC,QAAI,GAAG,GAAG,KAAK,MAAL,EAAV;;AACA,QAAI,GAAG,KAAK,CAAR,IAAa,GAAG,KAAK,GAAzB,EAA8B;AAC1B,aAAO,SAAS,CAAC,cAAV,CAAyB,KAAK,EAA9B,EAAkC,KAAK,EAAvC,EAA2C,KAAK,EAAhD,CAAP;AACH;;AAED,WAAO,KAAK,UAAL,CAAgB,MAAM,GAAtB,EAA2B,SAA3B,CAAP;AACH,GAPM;AASP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAjB,EAAqB,KAAK,EAA1B,EAA8B,KAAK,EAAnC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,MAAhB,EAA8C;AAC1C,WAAO,KAAK,cAAL,CAAoB,MAAM,CAAC,EAA3B,EAA+B,MAAM,CAAC,EAAtC,EAA0C,MAAM,CAAC,EAAjD,CAAP;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAqD;AACjD,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;;AAOO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAsB,CAAtB,EAAiC,CAAjC,EAA0C;AACtC,WAAO,KAAK,cAAL,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,CAAd,EAAuB;AACnB,SAAK,CAAL,GAAS,KAAK,CAAL,GAAS,KAAK,CAAL,GAAS,CAA3B;AACA,WAAO,IAAP;AACH,GAHM,CAlsBX,CAusBI;;AAEA;;;;;;;;;;AAQc,EAAA,OAAA,CAAA,aAAA,GAAd,UAA4B,OAA5B,EAA6D,OAA7D,EAA8F,IAA9F,EAA4H,IAA5H,EAAwI;AACpI,QAAI,EAAE,GAAG,OAAO,CAAC,GAAR,CAAY,OAAZ,EAAqB,IAArB,IAA6B,IAAtC;AACA,QAAI,EAAE,GAAG,OAAO,CAAC,GAAR,CAAY,OAAZ,EAAqB,IAArB,IAA6B,IAAtC;AAEA,QAAI,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAT,CAAV;AAEA,WAAO,CAAP;AACH,GAPa;AASd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,sBAAA,GAAd,UAAqC,OAArC,EAAsE,OAAtE,EAAuG,MAAvG,EAAqI;AACjI,QAAM,EAAE,GAAY,OAAO,CAAC,cAAR,CAAuB,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAvB,CAApB;AACA,QAAM,EAAE,GAAY,OAAO,CAAC,cAAR,CAAuB,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAvB,CAApB;AACA,QAAM,GAAG,GAAW,OAAO,CAAC,GAAR,CAAY,EAAZ,EAAgB,EAAhB,CAApB;AACA,QAAM,CAAC,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAV;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,EAAnB,EAAuB,EAAvB,EAA2B,CAA3B;;AACA,QAAI,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,MAAf,IAAyB,CAA7B,EAAgC;AAC5B,aAAO,IAAI,CAAC,IAAL,CAAU,GAAV,CAAP;AACH;;AACD,WAAO,CAAC,IAAI,CAAC,IAAL,CAAU,GAAV,CAAR;AACH,GAVa;AAYd;;;;;;;;AAMc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAiE,MAAjE,EAAmF;AAAlB,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAA;AAAkB;;AAC/E,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAC,MAAD,CAAjB,EAA2B,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhC,EAA8C,KAAK,CAAC,MAAM,GAAG,CAAV,CAAnD,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAiE,MAAjE,EAAgF;AAC5E,WAAO,OAAO,CAAC,SAAR,CAAkB,KAAlB,EAAyB,MAAzB,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAsE,MAAtE,EAAsF,MAAtF,EAAqG;AACjG,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAD,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,mBAAA,GAAd,UAAkC,KAAlC,EAAsE,MAAtE,EAAsF,MAAtF,EAAqG;AACjG,WAAO,OAAO,CAAC,cAAR,CAAuB,KAAvB,EAA8B,MAA9B,EAAsC,MAAtC,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,CAA9B,EAAyC,CAAzC,EAAoD,CAApD,EAA+D,MAA/D,EAA8E;AAC1E,IAAA,MAAM,CAAC,cAAP,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B;AACH,GAFa;AAId;;;;;;AAIc,EAAA,OAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIc,EAAA,OAAA,CAAA,GAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIc,EAAA,OAAA,CAAA,EAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;;AAOd,EAAA,MAAA,CAAA,cAAA,CAAkB,OAAlB,EAAkB,YAAlB,EAA4B;AAH5B;;;SAGA,YAAA;AACI,aAAO,OAAO,CAAC,WAAf;AACH,KAF2B;qBAAA;;AAAA,GAA5B;AAOA,EAAA,MAAA,CAAA,cAAA,CAAkB,OAAlB,EAAkB,cAAlB,EAA8B;AAH9B;;;SAGA,YAAA;AACI,aAAO,OAAO,CAAC,aAAf;AACH,KAF6B;qBAAA;;AAAA,GAA9B;AAIA;;;;;AAIc,EAAA,OAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,CAAC,GAAlB,EAAuB,GAAvB,CAAP;AACH,GAFa;AAGd;;;;;;;AAKc,EAAA,OAAA,CAAA,OAAA,GAAd,UAAsB,iBAAtB,EAAwD;AAAlC,QAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAkC;;AACpD,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAuB,iBAAiB,GAAG,CAAC,GAAJ,GAAU,GAAlD,CAAP;AACH,GAFa;AAGd;;;;;;;AAKc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,iBAAvB,EAAyD;AAAlC,QAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAkC;;AACrD,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAuB,iBAAiB,GAAG,GAAH,GAAS,CAAC,GAAlD,CAAP;AACH,GAFa;AAGd;;;;;;AAIc,EAAA,OAAA,CAAA,KAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,CAAP;AACH,GAFa;AAGd;;;;;;AAIc,EAAA,OAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAC,GAAb,EAAkB,GAAlB,EAAuB,GAAvB,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc,EAAA,OAAA,CAAA,oBAAA,GAAd,UAAmC,MAAnC,EAAmE,cAAnE,EAAwG;AACpG,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,MAAlC,EAA0C,cAA1C,EAA0D,MAA1D;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,yBAAA,GAAd,UAAwC,MAAxC,EAAwE,cAAxE,EAA+G,MAA/G,EAA8H;AAC1H,IAAA,OAAO,CAAC,mCAAR,CAA4C,MAAM,CAAC,EAAnD,EAAuD,MAAM,CAAC,EAA9D,EAAkE,MAAM,CAAC,EAAzE,EAA6E,cAA7E,EAA6F,MAA7F;AACH,GAFa;AAId;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,mCAAA,GAAd,UAAkD,CAAlD,EAA6D,CAA7D,EAAwE,CAAxE,EAAmF,cAAnF,EAA0H,MAA1H,EAAyI;AACrI,QAAM,CAAC,GAAG,cAAc,CAAC,CAAzB;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,CAAD,CAA3B,GAAiC,CAAC,CAAC,EAAD,CAA3C;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,CAAD,CAA3B,GAAiC,CAAC,CAAC,EAAD,CAA3C;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,EAAD,CAA3B,GAAkC,CAAC,CAAC,EAAD,CAA5C;AACA,QAAI,EAAE,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,EAAD,CAA3B,GAAkC,CAAC,CAAC,EAAD,CAAxC,CAAT;AAEA,IAAA,MAAM,CAAC,CAAP,GAAW,EAAE,GAAG,EAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,EAAE,GAAG,EAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,EAAE,GAAG,EAAhB;AACH,GAVa;AAYd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,MAA9B,EAA8D,cAA9D,EAAmG;AAC/F,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,oBAAR,CAA6B,MAA7B,EAAqC,cAArC,EAAqD,MAArD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,oBAAA,GAAd,UAAmC,MAAnC,EAAmE,cAAnE,EAA0G,MAA1G,EAAyH;AACrH,SAAK,8BAAL,CAAoC,MAAM,CAAC,EAA3C,EAA+C,MAAM,CAAC,EAAtD,EAA0D,MAAM,CAAC,EAAjE,EAAqE,cAArE,EAAqF,MAArF;AACH,GAFa;AAId;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,8BAAA,GAAd,UAA6C,CAA7C,EAAwD,CAAxD,EAAmE,CAAnE,EAA8E,cAA9E,EAAqH,MAArH,EAAoI;AAChI,QAAM,CAAC,GAAG,cAAc,CAAC,CAAzB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,CAAD,CAAtC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,CAAD,CAAtC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,CAAC,CAAC,CAAD,CAAhB,GAAsB,CAAC,GAAG,CAAC,CAAC,EAAD,CAAtC;AACH,GALa;AAOd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,UAAA,GAAd,UAAyB,MAAzB,EAAyD,MAAzD,EAAyF,MAAzF,EAAyH,MAAzH,EAAyJ,MAAzJ,EAAuK;AACnK,QAAI,OAAO,GAAG,MAAM,GAAG,MAAvB;AACA,QAAI,KAAK,GAAG,MAAM,GAAG,OAArB;AAEA,QAAI,CAAC,GAAG,OAAU,MAAM,MAAM,CAAC,EAAd,GAAqB,CAAC,CAAC,MAAM,CAAC,EAAR,GAAa,MAAM,CAAC,EAArB,IAA2B,MAAjD,GACX,CAAI,MAAM,MAAM,CAAC,EAAd,GAAqB,MAAM,MAAM,CAAC,EAAnC,GAA2C,MAAM,MAAM,CAAC,EAAzD,GAAgE,MAAM,CAAC,EAAxE,IAA8E,OADpE,GAEV,CAAG,CAAC,MAAM,CAAC,EAAR,GAAc,MAAM,MAAM,CAAC,EAA5B,GAAoC,MAAM,MAAM,CAAC,EAAlD,GAAyD,MAAM,CAAC,EAAjE,IAAuE,KAFpE,CAAR;AAIA,QAAI,CAAC,GAAG,OAAU,MAAM,MAAM,CAAC,EAAd,GAAqB,CAAC,CAAC,MAAM,CAAC,EAAR,GAAa,MAAM,CAAC,EAArB,IAA2B,MAAjD,GACX,CAAI,MAAM,MAAM,CAAC,EAAd,GAAqB,MAAM,MAAM,CAAC,EAAnC,GAA2C,MAAM,MAAM,CAAC,EAAzD,GAAgE,MAAM,CAAC,EAAxE,IAA8E,OADpE,GAEV,CAAG,CAAC,MAAM,CAAC,EAAR,GAAc,MAAM,MAAM,CAAC,EAA5B,GAAoC,MAAM,MAAM,CAAC,EAAlD,GAAyD,MAAM,CAAC,EAAjE,IAAuE,KAFpE,CAAR;AAIA,QAAI,CAAC,GAAG,OAAU,MAAM,MAAM,CAAC,EAAd,GAAqB,CAAC,CAAC,MAAM,CAAC,EAAR,GAAa,MAAM,CAAC,EAArB,IAA2B,MAAjD,GACX,CAAI,MAAM,MAAM,CAAC,EAAd,GAAqB,MAAM,MAAM,CAAC,EAAnC,GAA2C,MAAM,MAAM,CAAC,EAAzD,GAAgE,MAAM,CAAC,EAAxE,IAA8E,OADpE,GAEV,CAAG,CAAC,MAAM,CAAC,EAAR,GAAc,MAAM,MAAM,CAAC,EAA5B,GAAoC,MAAM,MAAM,CAAC,EAAlD,GAAyD,MAAM,CAAC,EAAjE,IAAuE,KAFpE,CAAR;AAIA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAP;AACH,GAjBa;AAmBd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,KAAA,GAAd,UAAoB,KAApB,EAAmD,GAAnD,EAAgF,GAAhF,EAA2G;AACvG,QAAM,CAAC,GAAG,IAAI,OAAJ,EAAV;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,KAAnB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,CAApC;AACA,WAAO,CAAP;AACH,GAJa;AAKd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,UAAA,GAAd,UAAyB,KAAzB,EAAwD,GAAxD,EAAqF,GAArF,EAAkH,MAAlH,EAAiI;AAC7H,QAAI,CAAC,GAAG,KAAK,CAAC,EAAd;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AAEA,QAAI,CAAC,GAAG,KAAK,CAAC,EAAd;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AAEA,QAAI,CAAC,GAAG,KAAK,CAAC,EAAd;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AACA,IAAA,CAAC,GAAI,CAAC,GAAG,GAAG,CAAC,EAAT,GAAe,GAAG,CAAC,EAAnB,GAAwB,CAA5B;AAEA,IAAA,MAAM,CAAC,cAAP,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B;AACH,GAda;AAgBd;;;;;;;;AAMc,EAAA,OAAA,CAAA,YAAA,GAAd,UAA2B,CAA3B,EAAuC,GAAvC,EAAqD,GAArD,EAAiE;AAC7D,IAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB;AACA,IAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB;AACH,GAHa;AAKd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,OAAA,GAAd,UAAsB,MAAtB,EAAsD,QAAtD,EAAwF,MAAxF,EAAwH,QAAxH,EAA0J,MAA1J,EAAwK;AACpK,QAAI,OAAO,GAAG,MAAM,GAAG,MAAvB;AACA,QAAI,KAAK,GAAG,MAAM,GAAG,OAArB;AACA,QAAI,KAAK,GAAK,MAAM,KAAP,GAAiB,MAAM,OAAxB,GAAoC,GAAhD;AACA,QAAI,KAAK,GAAI,CAAC,GAAD,GAAO,KAAR,GAAkB,MAAM,OAApC;AACA,QAAI,KAAK,GAAI,KAAK,GAAI,MAAM,OAAhB,GAA4B,MAAxC;AACA,QAAI,KAAK,GAAG,KAAK,GAAG,OAApB;AAEA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,WAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAP;AACH,GAZa;AAcd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,IAAA,GAAd,UAAmB,KAAnB,EAAkD,GAAlD,EAA+E,MAA/E,EAA6F;AACzF,QAAI,MAAM,GAAG,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,CAAb;AACA,IAAA,OAAO,CAAC,SAAR,CAAkB,KAAlB,EAAyB,GAAzB,EAA8B,MAA9B,EAAsC,MAAtC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAuD,GAAvD,EAAoF,MAApF,EAAoG,MAApG,EAAmH;AAC/G,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,EAAN,GAAY,CAAC,GAAG,CAAC,EAAJ,GAAS,KAAK,CAAC,EAAhB,IAAsB,MAA7C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,EAAN,GAAY,CAAC,GAAG,CAAC,EAAJ,GAAS,KAAK,CAAC,EAAhB,IAAsB,MAA7C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,EAAN,GAAY,CAAC,GAAG,CAAC,EAAJ,GAAS,KAAK,CAAC,EAAhB,IAAsB,MAA7C;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,GAAA,GAAd,UAAkB,IAAlB,EAAgD,KAAhD,EAA6E;AACzE,WAAQ,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAhB,GAAqB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAArC,GAA0C,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAlE;AACH,GAFa;AAId;;;;;;;;;AAOc,EAAA,OAAA,CAAA,KAAA,GAAd,UAAoB,IAApB,EAAkD,KAAlD,EAA+E;AAC3E,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,IAAnB,EAAyB,KAAzB,EAAgC,MAAhC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,UAAA,GAAd,UAAyB,IAAzB,EAAuD,KAAvD,EAAsF,MAAtF,EAAqG;AACjG,QAAM,CAAC,GAAG,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAhB,GAAqB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAA/C;AACA,QAAM,CAAC,GAAG,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAhB,GAAqB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAA/C;AACA,QAAM,CAAC,GAAG,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAhB,GAAqB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAA/C;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B;AACH,GALa;AAOd;;;;;;;AAKc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAsD;AAClD,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,MAAvB,EAA+B,MAA/B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA6D,MAA7D,EAA4E;AACxE,IAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB;AACH,GAFa;AAId;;;;;;;;;;AAQc,EAAA,OAAA,CAAA,OAAA,GAAd,UAAsB,MAAtB,EAAsD,KAAtD,EAAoF,SAApF,EAAsH,QAAtH,EAAuJ;AACnJ,QAAM,MAAM,GAAG,IAAI,OAAJ,EAAf;AACA,IAAA,OAAO,CAAC,YAAR,CAAqB,MAArB,EAA6B,KAA7B,EAAoC,SAApC,EAA+C,QAA/C,EAAyD,MAAzD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,YAAA,GAAd,UAA2B,MAA3B,EAA2D,KAA3D,EAAyF,SAAzF,EAA2H,QAA3H,EAA8J,MAA9J,EAA4L;AACxL,QAAI,EAAE,GAAG,QAAQ,CAAC,KAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,MAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,CAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,CAAlB;AAEA,QAAI,cAAc,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAArB;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,EAAE,GAAG,GADT,EACc,CADd,EACiB,CADjB,EACoB,CADpB,EAEI,CAFJ,EAEO,CAAC,EAAD,GAAM,GAFb,EAEkB,CAFlB,EAEqB,CAFrB,EAGI,CAHJ,EAGO,CAHP,EAGU,GAHV,EAGe,CAHf,EAII,EAAE,GAAG,EAAE,GAAG,GAJd,EAImB,EAAE,GAAG,GAAL,GAAW,EAJ9B,EAIkC,GAJlC,EAIuC,CAJvC,EAI0C,cAJ1C;AAMA,QAAI,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAb;AACA,IAAA,KAAK,CAAC,aAAN,CAAoB,SAApB,EAA+B,MAA/B;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,cAArB,EAAqC,MAArC;AAEA,IAAA,OAAO,CAAC,yBAAR,CAAkC,MAAlC,EAA0C,MAA1C,EAAkD,MAAlD;AACA,WAAO,MAAP;AACH,GApBa;AAsBd;;;AACc,EAAA,OAAA,CAAA,iCAAA,GAAd,UAAgD,MAAhD,EAAgF,MAAhF,EAA+G,MAA/G,EAA8H;AAC1H,IAAA,OAAO,CAAC,yBAAR,CAAkC,MAAlC,EAA0C,MAA1C,EAAkD,MAAlD;AACA,QAAM,CAAC,GAAG,MAAM,CAAC,CAAjB;AACA,QAAI,GAAG,GAAG,MAAM,CAAC,EAAP,GAAY,CAAC,CAAC,CAAD,CAAb,GAAmB,MAAM,CAAC,EAAP,GAAY,CAAC,CAAC,CAAD,CAAhC,GAAsC,MAAM,CAAC,EAAP,GAAY,CAAC,CAAC,EAAD,CAAnD,GAA0D,CAAC,CAAC,EAAD,CAArE;;AACA,QAAI,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,GAA1B,CAAJ,EAAoC;AAChC,MAAA,MAAM,CAAC,YAAP,CAAoB,MAAM,GAA1B;AACH;AACJ,GAPa;AASd;;;;;;;;;;;AASc,EAAA,OAAA,CAAA,sBAAA,GAAd,UAAqC,MAArC,EAAsD,aAAtD,EAA6E,cAA7E,EAAqG,KAArG,EAAmI,SAAnI,EAAmK;AAC/J,QAAI,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAb;AACA,IAAA,KAAK,CAAC,aAAN,CAAoB,SAApB,EAA+B,MAA/B;AACA,IAAA,MAAM,CAAC,MAAP;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,EAAP,GAAY,aAAZ,GAA4B,CAA5B,GAAgC,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,EAAE,MAAM,CAAC,EAAP,GAAY,cAAZ,GAA6B,CAA7B,GAAiC,CAAnC,CAAX;AACA,QAAM,MAAM,GAAG,IAAI,OAAJ,EAAf;;AACA,IAAA,OAAO,CAAC,iCAAR,CAA0C,MAA1C,EAAkD,MAAlD,EAA0D,MAA1D;;AACA,WAAO,MAAP;AACH,GATa;AAWd;;;;;;;;;;;;AAUc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAwD,aAAxD,EAA+E,cAA/E,EAAuG,KAAvG,EAAqI,IAArI,EAAkK,UAAlK,EAAmM;AAC/L,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,IAAA,OAAO,CAAC,cAAR,CAAuB,MAAvB,EAA+B,aAA/B,EAA8C,cAA9C,EAA8D,KAA9D,EAAqE,IAArE,EAA2E,UAA3E,EAAuF,MAAvF;AAEA,WAAO,MAAP;AACH,GANa;AAQd;;;;;;;;;;;;AAUc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA6D,aAA7D,EAAoF,cAApF,EAA4G,KAA5G,EAA0I,IAA1I,EAAuK,UAAvK,EAA0M,MAA1M,EAAyN;AACrN,IAAA,OAAO,CAAC,oBAAR,CAA6B,MAAM,CAAC,EAApC,EAAwC,MAAM,CAAC,EAA/C,EAAmD,MAAM,CAAC,EAA1D,EAA8D,aAA9D,EAA6E,cAA7E,EAA6F,KAA7F,EAAoG,IAApG,EAA0G,UAA1G,EAAsH,MAAtH;AACH,GAFa;AAId;;;;;;;;;;;;;;AAYc,EAAA,OAAA,CAAA,oBAAA,GAAd,UAAmC,OAAnC,EAAmD,OAAnD,EAAmE,OAAnE,EAAmF,aAAnF,EAA0G,cAA1G,EAAkI,KAAlI,EAAgK,IAAhK,EAA6L,UAA7L,EAAgO,MAAhO,EAA+O;AAC3O,QAAI,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAb;AACA,IAAA,KAAK,CAAC,aAAN,CAAoB,IAApB,EAA0B,MAA1B;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,UAArB,EAAiC,MAAjC;AACA,IAAA,MAAM,CAAC,MAAP;AACA,QAAI,YAAY,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAnB;AACA,IAAA,YAAY,CAAC,CAAb,GAAiB,OAAO,GAAG,aAAV,GAA0B,CAA1B,GAA8B,CAA/C;AACA,IAAA,YAAY,CAAC,CAAb,GAAiB,EAAE,OAAO,GAAG,cAAV,GAA2B,CAA3B,GAA+B,CAAjC,CAAjB;AACA,IAAA,YAAY,CAAC,CAAb,GAAiB,IAAI,OAAJ,GAAc,GAA/B;;AACA,IAAA,OAAO,CAAC,iCAAR,CAA0C,YAA1C,EAAwD,MAAxD,EAAgE,MAAhE;AACH,GAVa;AAYd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,GAAG,GAAG,IAAI,CAAC,KAAL,EAAV;AACA,IAAA,GAAG,CAAC,eAAJ,CAAoB,KAApB;AACA,WAAO,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,GAAG,GAAG,IAAI,CAAC,KAAL,EAAV;AACA,IAAA,GAAG,CAAC,eAAJ,CAAoB,KAApB;AACA,WAAO,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,MAAvB,EAAuD,MAAvD,EAAqF;AACjF,WAAO,IAAI,CAAC,IAAL,CAAU,OAAO,CAAC,eAAR,CAAwB,MAAxB,EAAgC,MAAhC,CAAV,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,MAA9B,EAA8D,MAA9D,EAA4F;AACxF,QAAI,CAAC,GAAG,MAAM,CAAC,EAAP,GAAY,MAAM,CAAC,EAA3B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,EAAP,GAAY,MAAM,CAAC,EAA3B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,EAAP,GAAY,MAAM,CAAC,EAA3B;AAEA,WAAQ,CAAC,GAAG,CAAL,GAAW,CAAC,GAAG,CAAf,GAAqB,CAAC,GAAG,CAAhC;AACH,GANa;AAQd;;;;;;;;AAMc,EAAA,OAAA,CAAA,MAAA,GAAd,UAAqB,MAArB,EAAqD,MAArD,EAAmF;AAC/E,QAAI,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,MAAX,CAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,GAApB;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;AAUc,EAAA,OAAA,CAAA,gBAAA,GAAd,UAA+B,KAA/B,EAA8D,KAA9D,EAA6F,KAA7F,EAA0H;AACtH,QAAI,QAAQ,GAAG,OAAO,CAAC,IAAR,EAAf;AACA,IAAA,OAAO,CAAC,qBAAR,CAA8B,KAA9B,EAAqC,KAArC,EAA4C,KAA5C,EAAmD,QAAnD;AACA,WAAO,QAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,qBAAA,GAAd,UAAoC,KAApC,EAAmE,KAAnE,EAAkG,KAAlG,EAAiI,GAAjI,EAA6I;AACzI,QAAI,IAAI,GAAG,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAAX;AACA,IAAA,UAAU,CAAC,+BAAX,CAA2C,KAA3C,EAAkD,KAAlD,EAAyD,KAAzD,EAAgE,IAAhE;AACA,IAAA,IAAI,CAAC,kBAAL,CAAwB,GAAxB;AACH,GAJa;;AAh1CC,EAAA,OAAA,CAAA,WAAA,GAAc,OAAO,CAAC,EAAR,EAAd;AACA,EAAA,OAAA,CAAA,aAAA,GAAgB,OAAO,CAAC,IAAR,EAAhB;AAo1CnB,SAAA,OAAA;AAAC,CAt1CD,EAAA;;SAAa,O;AAw1Cb;;;;AAGA,IAAA,OAAA;AAAA;AAAA,YAAA;AACI;;;;;;;AAOA,WAAA,OAAA;AACI;AACO,EAAA,CAFX;AAGI;AACO,EAAA,CAJX;AAKI;AACO,EAAA,CANX;AAOI;AACO,EAAA,CARX,EAQoB;AANT,SAAA,CAAA,GAAA,CAAA;AAEA,SAAA,CAAA,GAAA,CAAA;AAEA,SAAA,CAAA,GAAA,CAAA;AAEA,SAAA,CAAA,GAAA,CAAA;AACN;AAEL;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,SAAS,KAAK,CAAd,GAAkB,KAAlB,GAA0B,KAAK,CAA/B,GAAmC,KAAnC,GAA2C,KAAK,CAAhD,GAAoD,KAApD,GAA4D,KAAK,CAAjE,GAAqE,GAA5E;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,SAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,KAAK,CAAL,GAAS,CAApB;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,CAAL,GAAS,CAAzB,CAAP;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,CAAL,GAAS,CAAzB,CAAP;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,CAAL,GAAS,CAAzB,CAAP;AACA,WAAO,IAAP;AACH,GANM,CAvCX,CA+CI;;AACA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,MAAM,GAAG,IAAI,KAAJ,EAAb;AAEA,SAAK,OAAL,CAAa,MAAb,EAAqB,CAArB;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAAkC,KAAlC,EAAgD;AAC5C,QAAI,KAAK,KAAK,SAAd,EAAyB;AACrB,MAAA,KAAK,GAAG,CAAR;AACH;;AACD,IAAA,KAAK,CAAC,KAAD,CAAL,GAAe,KAAK,CAApB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,CAAxB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,CAAxB;AACA,IAAA,KAAK,CAAC,KAAK,GAAG,CAAT,CAAL,GAAmB,KAAK,CAAxB;AACA,WAAO,IAAP;AACH,GATM;AAWP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAAoC,KAApC,EAAqD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAiB;;AACjD,IAAA,OAAO,CAAC,cAAR,CAAuB,KAAvB,EAA8B,KAA9B,EAAqC,IAArC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAAqD;AACjD,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,WAAX,EAA8C;AAC1C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,EAA4D,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjF,EAAoF,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzG,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAqD,MAArD,EAAoE;AAChE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA0D;AACtD,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAmD;AAC/C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,EAA4D,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjF,EAAoF,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzG,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;AAGA;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,CAA1B,EAAqC,CAArC,EAAgD,CAAhD,EAA2D,CAA3D,EAAoE;AAChE,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,CAArB,EAAwB,KAAK,CAAL,GAAS,CAAjC,EAAoC,KAAK,CAAL,GAAS,CAA7C,EAAgD,KAAK,CAAL,GAAS,CAAzD,CAAP;AACH,GAFM;AAIP;;;;;;;;;;;AASO,EAAA,OAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,CAA/B,EAA0C,CAA1C,EAAqD,CAArD,EAAgE,CAAhE,EAA2E,MAA3E,EAA0F;AACtF,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,CAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,CAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,CAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,CAApB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,CAAC,KAAK,CAAlB,EAAqB,CAAC,KAAK,CAA3B,EAA8B,CAAC,KAAK,CAApC,EAAuC,CAAC,KAAK,CAA7C,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAkC;AAC9B,WAAO,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAL,GAAS,CAAC,CAAhC,EAAmC,KAAK,CAAL,GAAS,CAAC,CAA7C,EAAgD,KAAK,CAAL,GAAS,CAAC,CAA1D,EAA6D,KAAK,CAAL,GAAS,CAAC,CAAvE,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,KAApB,EAAiC;AAC7B,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B;AACtB,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,KAArB,EAA4B,KAAK,CAAL,GAAS,KAArC,EAA4C,KAAK,CAAL,GAAS,KAArD,EAA4D,KAAK,CAAL,GAAS,KAArE,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,MAAjC,EAAgD;AAC5C,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,KAApB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,MAAvC,EAAsD;AAClD,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,CAAL,GAAS,KAArB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAiD;AAC7C,WAAO,WAAW,IAAI,KAAK,CAAL,KAAW,WAAW,CAAC,CAAtC,IAA2C,KAAK,CAAL,KAAW,WAAW,CAAC,CAAlE,IAAuE,KAAK,CAAL,KAAW,WAAW,CAAC,CAA9F,IAAmG,KAAK,CAAL,KAAW,WAAW,CAAC,CAAjI;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,WAAzB,EAA8D,OAA9D,EAAuF;AAAzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,OAAA;AAAyB;;AACnF,WAAO,WAAW,IACX,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CADA,IAEA,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CAFA,IAGA,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CAHA,IAIA,MAAM,CAAC,aAAP,CAAqB,KAAK,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,OAA5C,CAJP;AAKH,GANM;AAQP;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC5D,WAAO,KAAK,CAAL,KAAW,CAAX,IAAgB,KAAK,CAAL,KAAW,CAA3B,IAAgC,KAAK,CAAL,KAAW,CAA3C,IAAgD,KAAK,CAAL,KAAW,CAAlE;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,WAAvB,EAA2C;AACvC,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,SAAK,CAAL,IAAU,WAAW,CAAC,CAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,WAAhB,EAAmD;AAC/C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,EAA4D,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjF,EAAoF,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzG,CAAP;AACH,GAFM;AAGP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAA0D,MAA1D,EAAyE;AACrE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,CAAxB,EAAmC,CAAnC,EAA8C,CAA9C,EAAyD,CAAzD,EAAkE;AAC9D,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,CAArB,EAAwB,KAAK,CAAL,GAAS,CAAjC,EAAoC,KAAK,CAAL,GAAS,CAA7C,EAAgD,KAAK,CAAL,GAAS,CAAzD,CAAP;AACH,GAFM;AAGP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,WAAd,EAAiD;AAC7C,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjC,EAAoC,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzD,EAA4D,KAAK,CAAL,GAAS,WAAW,CAAC,CAAjF,EAAoF,KAAK,CAAL,GAAS,WAAW,CAAC,CAAzG,CAAP;AACH,GAFM;AAGP;;;;;;;;AAMO,EAAA,OAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,WAAnB,EAAwD,MAAxD,EAAuE;AACnE,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAL,GAAS,WAAW,CAAC,CAAhC;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAAwD;AACpD,WAAO,KAAK,WAAL,CAAiB,WAAjB,EAA8B,IAA9B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAoD;AAChD,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAoD;AAChD,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,QAAI,KAAK,CAAC,CAAN,GAAU,KAAK,CAAnB,EAAsB;AAAE,WAAK,CAAL,GAAS,KAAK,CAAC,CAAf;AAAmB;;AAC3C,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAZ,EAAgC,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAhC,EAAoD,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAApD,EAAwE,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAxE,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAArB,EAAyC,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAAlD,EAAsE,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAA/E,EAAmG,KAAK,CAAL,GAAS,IAAI,CAAC,KAAL,CAAW,KAAK,CAAhB,CAA5G,CAAP;AACH,GAFM,CAnaX,CAuaI;;AACA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,CAAC,IAAL,CAAU,KAAK,CAAL,GAAS,KAAK,CAAd,GAAkB,KAAK,CAAL,GAAS,KAAK,CAAhC,GAAoC,KAAK,CAAL,GAAS,KAAK,CAAlD,GAAsD,KAAK,CAAL,GAAS,KAAK,CAA9E,CAAP;AACH,GAFM;AAGP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,WAAQ,KAAK,CAAL,GAAS,KAAK,CAAd,GAAkB,KAAK,CAAL,GAAS,KAAK,CAAhC,GAAoC,KAAK,CAAL,GAAS,KAAK,CAAlD,GAAsD,KAAK,CAAL,GAAS,KAAK,CAA5E;AACH,GAFM,CAnbX,CAubI;;AACA;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,GAAG,GAAG,KAAK,MAAL,EAAV;;AAEA,QAAI,GAAG,KAAK,CAAZ,EAAe;AACX,aAAO,IAAP;AACH;;AAED,WAAO,KAAK,YAAL,CAAkB,MAAM,GAAxB,CAAP;AACH,GARM;AAUP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAjB,EAAoB,KAAK,CAAzB,EAA4B,KAAK,CAAjC,CAAP;AACH,GAFM;AAGP;;;;;;AAIO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAjB,EAAoB,KAAK,CAAzB,EAA4B,KAAK,CAAjC,EAAoC,KAAK,CAAzC,CAAP;AACH,GAFM;AAGP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,MAAhB,EAA8C;AAC1C,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,SAAK,CAAL,GAAS,MAAM,CAAC,CAAhB;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC5D,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;;;;AAQO,EAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAqD;AACjD,WAAO,KAAK,cAAL,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,CAAd,EAAuB;AACnB,SAAK,CAAL,GAAS,KAAK,CAAL,GAAS,KAAK,CAAL,GAAS,KAAK,CAAL,GAAS,CAApC;AACA,WAAO,IAAP;AACH,GAHM,CAhgBX,CAqgBI;;AACA;;;;;;;;AAMc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAiE,MAAjE,EAAgF;AAC5E,QAAI,CAAC,MAAL,EAAa;AACT,MAAA,MAAM,GAAG,CAAT;AACH;;AACD,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAC,MAAD,CAAjB,EAA2B,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhC,EAA8C,KAAK,CAAC,MAAM,GAAG,CAAV,CAAnD,EAAiE,KAAK,CAAC,MAAM,GAAG,CAAV,CAAtE,CAAP;AACH,GALa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAsE,MAAtE,EAAsF,MAAtF,EAAqG;AACjG,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAD,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACH,GALa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,mBAAA,GAAd,UAAkC,KAAlC,EAAsE,MAAtE,EAAsF,MAAtF,EAAqG;AACjG,IAAA,OAAO,CAAC,cAAR,CAAuB,KAAvB,EAA8B,MAA9B,EAAsC,MAAtC;AACH,GAFa;AAGd;;;;;;;;;;AAQc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,CAA9B,EAAyC,CAAzC,EAAoD,CAApD,EAA+D,CAA/D,EAA0E,MAA1E,EAAyF;AACrF,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACH,GALa;AAMd;;;;;;AAIc,EAAA,OAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAP;AACH,GAFa;AAGd;;;;;;AAIc,EAAA,OAAA,CAAA,GAAA,GAAd,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAjB,EAAsB,GAAtB,EAA2B,GAA3B,CAAP;AACH,GAFa;AAGd;;;;;;;AAKc,EAAA,OAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAsD;AAClD,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,MAAvB,EAA+B,MAA/B;AACA,WAAO,MAAP;AACH,GAJa;AAKd;;;;;;;AAKc,EAAA,OAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA6D,MAA7D,EAA4E;AACxE,IAAA,MAAM,CAAC,QAAP,CAAgB,MAAhB;AACA,IAAA,MAAM,CAAC,SAAP;AACH,GAHa;AAKd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,GAAG,GAAG,IAAI,CAAC,KAAL,EAAV;AACA,IAAA,GAAG,CAAC,eAAJ,CAAoB,KAApB;AACA,WAAO,GAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAqD,KAArD,EAAkF;AAC9E,QAAI,GAAG,GAAG,IAAI,CAAC,KAAL,EAAV;AACA,IAAA,GAAG,CAAC,eAAJ,CAAoB,KAApB;AACA,WAAO,GAAP;AACH,GAJa;AAKd;;;;;;;;AAMc,EAAA,OAAA,CAAA,QAAA,GAAd,UAAuB,MAAvB,EAAuD,MAAvD,EAAqF;AACjF,WAAO,IAAI,CAAC,IAAL,CAAU,OAAO,CAAC,eAAR,CAAwB,MAAxB,EAAgC,MAAhC,CAAV,CAAP;AACH,GAFa;AAGd;;;;;;;;AAMc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,MAA9B,EAA8D,MAA9D,EAA4F;AACxF,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AACA,QAAI,CAAC,GAAG,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAA1B;AAEA,WAAQ,CAAC,GAAG,CAAL,GAAW,CAAC,GAAG,CAAf,GAAqB,CAAC,GAAG,CAAzB,GAA+B,CAAC,GAAG,CAA1C;AACH,GAPa;AAQd;;;;;;;;AAMc,EAAA,OAAA,CAAA,MAAA,GAAd,UAAqB,MAArB,EAAqD,MAArD,EAAmF;AAC/E,QAAI,MAAM,GAAG,MAAM,CAAC,GAAP,CAAW,MAAX,CAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,GAApB;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,eAAA,GAAd,UAA8B,MAA9B,EAA8D,cAA9D,EAAmG;AAC/F,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,IAAA,OAAO,CAAC,oBAAR,CAA6B,MAA7B,EAAqC,cAArC,EAAqD,MAArD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,OAAA,CAAA,oBAAA,GAAd,UAAmC,MAAnC,EAAmE,cAAnE,EAA0G,MAA1G,EAAyH;AACrH,QAAM,CAAC,GAAG,cAAc,CAAC,CAAzB;AACA,QAAI,CAAC,GAAI,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAb,GAAqB,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAjC,GAAyC,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAA7D;AACA,QAAI,CAAC,GAAI,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAb,GAAqB,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAjC,GAAyC,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAA7D;AACA,QAAI,CAAC,GAAI,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAb,GAAqB,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,CAAD,CAAjC,GAAyC,MAAM,CAAC,CAAP,GAAW,CAAC,CAAC,EAAD,CAA7D;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,MAAM,CAAC,CAAlB;AACH,GATa;AAWd;;;;;;;;;;;;AAUc,EAAA,OAAA,CAAA,8BAAA,GAAd,UAA6C,CAA7C,EAAwD,CAAxD,EAAmE,CAAnE,EAA8E,CAA9E,EAAyF,cAAzF,EAAgI,MAAhI,EAA+I;AAC3I,QAAM,CAAC,GAAG,cAAc,CAAC,CAAzB;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,CAAC,GAAG,CAAC,CAAC,CAAD,CAAN,GAAc,CAAC,GAAG,CAAC,CAAC,CAAD,CAAnB,GAA2B,CAAC,GAAG,CAAC,CAAC,CAAD,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,CAAC,GAAG,CAAC,CAAC,CAAD,CAAN,GAAc,CAAC,GAAG,CAAC,CAAC,CAAD,CAAnB,GAA2B,CAAC,GAAG,CAAC,CAAC,CAAD,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,CAAC,GAAG,CAAC,CAAC,CAAD,CAAN,GAAc,CAAC,GAAG,CAAC,CAAC,CAAD,CAAnB,GAA2B,CAAC,GAAG,CAAC,CAAC,EAAD,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACH,GANa;AAQd;;;;;;;;AAMc,EAAA,OAAA,CAAA,WAAA,GAAd,UAA0B,MAA1B,EAA2C,CAA3C,EAAwD;AAAb,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,CAAA;AAAa;;AACpD,WAAO,IAAI,OAAJ,CAAY,MAAM,CAAC,EAAnB,EAAuB,MAAM,CAAC,EAA9B,EAAkC,MAAM,CAAC,EAAzC,EAA6C,CAA7C,CAAP;AACH,GAFa;;AAGlB,SAAA,OAAA;AAAC,CA3sBD,EAAA;;;AA6sBA;;;;;;AAKA,IAAA,UAAA;AAAA;AAAA,YAAA;AAuDI;;;;;;;AAOA,WAAA,UAAA,CACI,CADJ,EAEI,CAFJ,EAGI,CAHJ,EAII,CAJJ,EAImB;AAHf,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,GAAA;AAAe;;AACf,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,GAAA;AAAe;;AACf,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,GAAA;AAAe;;AACf,QAAA,CAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,CAAA,GAAA,GAAA;AAAe;AArDnB;;;AACO,SAAA,QAAA,GAAW,IAAX;AAqDC,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACA,SAAK,EAAL,GAAU,CAAV;AACP;;AAtDD,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AADZ;SACA,YAAA;AACI,aAAO,KAAK,EAAZ;AACH,KAFW;SAIZ,UAAa,KAAb,EAA0B;AACtB,WAAK,EAAL,GAAU,KAAV;AACA,WAAK,QAAL,GAAgB,IAAhB;AACH,KAPW;qBAAA;;AAAA,GAAZ;AA0BA;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,SAAS,KAAK,EAAd,GAAmB,KAAnB,GAA2B,KAAK,EAAhC,GAAqC,KAArC,GAA6C,KAAK,EAAlD,GAAuD,KAAvD,GAA+D,KAAK,EAApE,GAAyE,GAAhF;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,YAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,KAAK,EAAL,GAAU,CAArB;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,GAAU,CAA1B,CAAP;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,GAAU,CAA1B,CAAP;AACA,IAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,GAAU,CAA1B,CAAP;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,WAAO,CAAC,KAAK,EAAN,EAAU,KAAK,EAAf,EAAmB,KAAK,EAAxB,EAA4B,KAAK,EAAjC,CAAP;AACH,GAFM;AAGP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,eAAd,EAAwD;AACpD,WAAO,eAAe,IAAI,KAAK,EAAL,KAAY,eAAe,CAAC,EAA/C,IAAqD,KAAK,EAAL,KAAY,eAAe,CAAC,EAAjF,IAAuF,KAAK,EAAL,KAAY,eAAe,CAAC,EAAnH,IAAyH,KAAK,EAAL,KAAY,eAAe,CAAC,EAA5J;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,eAAzB,EAAqE,OAArE,EAA8F;AAAzB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,OAAA;AAAyB;;AAC1F,WAAO,eAAe,IACf,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,eAAe,CAAC,EAA9C,EAAkD,OAAlD,CADA,IAEA,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,eAAe,CAAC,EAA9C,EAAkD,OAAlD,CAFA,IAGA,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,eAAe,CAAC,EAA9C,EAAkD,OAAlD,CAHA,IAIA,MAAM,CAAC,aAAP,CAAqB,KAAK,EAA1B,EAA8B,eAAe,CAAC,EAA9C,EAAkD,OAAlD,CAJP;AAKH,GANM;AAQP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,UAAJ,CAAe,KAAK,EAApB,EAAwB,KAAK,EAA7B,EAAiC,KAAK,EAAtC,EAA0C,KAAK,EAA/C,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAAgD;AAC5C,SAAK,CAAL,GAAS,KAAK,CAAC,EAAf;AACA,SAAK,CAAL,GAAS,KAAK,CAAC,EAAf;AACA,SAAK,CAAL,GAAS,KAAK,CAAC,EAAf;AACA,SAAK,CAAL,GAAS,KAAK,CAAC,EAAf;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;;AAQO,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AAC5D,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,SAAK,CAAL,GAAS,CAAT;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;;AAQO,EAAA,UAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAqD;AACjD,WAAO,KAAK,cAAL,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAA2C;AACvC,WAAO,IAAI,UAAJ,CAAe,KAAK,EAAL,GAAU,KAAK,CAAC,EAA/B,EAAmC,KAAK,EAAL,GAAU,KAAK,CAAC,EAAnD,EAAuD,KAAK,EAAL,GAAU,KAAK,CAAC,EAAvE,EAA2E,KAAK,EAAL,GAAU,KAAK,CAAC,EAA3F,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAkD;AAC9C,SAAK,EAAL,IAAW,KAAK,CAAC,EAAjB;AACA,SAAK,EAAL,IAAW,KAAK,CAAC,EAAjB;AACA,SAAK,EAAL,IAAW,KAAK,CAAC,EAAjB;AACA,SAAK,EAAL,IAAW,KAAK,CAAC,EAAjB;AACA,WAAO,IAAP;AACH,GANM;AAOP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAAiC;AAC7B,WAAO,IAAI,UAAJ,CAAe,KAAK,EAAL,GAAU,KAAK,CAAC,EAA/B,EAAmC,KAAK,EAAL,GAAU,KAAK,CAAC,EAAnD,EAAuD,KAAK,EAAL,GAAU,KAAK,CAAC,EAAvE,EAA2E,KAAK,EAAL,GAAU,KAAK,CAAC,EAA3F,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B;AACtB,WAAO,IAAI,UAAJ,CAAe,KAAK,EAAL,GAAU,KAAzB,EAAgC,KAAK,EAAL,GAAU,KAA1C,EAAiD,KAAK,EAAL,GAAU,KAA3D,EAAkE,KAAK,EAAL,GAAU,KAA5E,CAAP;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,MAAjC,EAAmD;AAC/C,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,GAAU,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,GAAU,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,GAAU,KAArB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,GAAU,KAArB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,KAApB,EAAiC;AAC7B,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AACA,SAAK,CAAL,IAAU,KAAV;AAEA,WAAO,IAAP;AACH,GAPM;AASP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,MAAvC,EAAyD;AACrD,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,EAAL,GAAU,KAAtB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,EAAL,GAAU,KAAtB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,EAAL,GAAU,KAAtB;AACA,IAAA,MAAM,CAAC,CAAP,IAAY,KAAK,EAAL,GAAU,KAAtB;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,EAAhB,EAA6C;AACzC,QAAI,MAAM,GAAG,IAAI,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,GAAxB,CAAb;AACA,SAAK,aAAL,CAAmB,EAAnB,EAAuB,MAAvB;AACA,WAAO,MAAP;AACH,GAJM;AAKP;;;;;;;;AAMO,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,EAArB,EAAoD,MAApD,EAAsE;AAClE,QAAI,CAAC,GAAG,KAAK,EAAL,GAAU,EAAE,CAAC,EAAb,GAAkB,KAAK,EAAL,GAAU,EAAE,CAAC,EAA/B,GAAoC,KAAK,EAAL,GAAU,EAAE,CAAC,EAAjD,GAAsD,KAAK,EAAL,GAAU,EAAE,CAAC,EAA3E;AACA,QAAI,CAAC,GAAG,CAAC,KAAK,EAAN,GAAW,EAAE,CAAC,EAAd,GAAmB,KAAK,EAAL,GAAU,EAAE,CAAC,EAAhC,GAAqC,KAAK,EAAL,GAAU,EAAE,CAAC,EAAlD,GAAuD,KAAK,EAAL,GAAU,EAAE,CAAC,EAA5E;AACA,QAAI,CAAC,GAAG,KAAK,EAAL,GAAU,EAAE,CAAC,EAAb,GAAkB,KAAK,EAAL,GAAU,EAAE,CAAC,EAA/B,GAAoC,KAAK,EAAL,GAAU,EAAE,CAAC,EAAjD,GAAsD,KAAK,EAAL,GAAU,EAAE,CAAC,EAA3E;AACA,QAAI,CAAC,GAAG,CAAC,KAAK,EAAN,GAAW,EAAE,CAAC,EAAd,GAAmB,KAAK,EAAL,GAAU,EAAE,CAAC,EAAhC,GAAqC,KAAK,EAAL,GAAU,EAAE,CAAC,EAAlD,GAAuD,KAAK,EAAL,GAAU,EAAE,CAAC,EAA5E;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B;AACA,WAAO,IAAP;AACH,GAPM;AASP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,EAAvB,EAAoD;AAChD,SAAK,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,GAAtB,EAAqC;AACjC,IAAA,GAAG,CAAC,cAAJ,CAAmB,CAAC,KAAK,EAAzB,EAA6B,CAAC,KAAK,EAAnC,EAAuC,CAAC,KAAK,EAA7C,EAAiD,KAAK,EAAtD;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,YAAA;AACI,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,SAAK,CAAL,IAAU,CAAC,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,MAAM,GAAG,IAAI,UAAJ,CAAe,CAAC,KAAK,EAArB,EAAyB,CAAC,KAAK,EAA/B,EAAmC,CAAC,KAAK,EAAzC,EAA6C,KAAK,EAAlD,CAAb;AACA,WAAO,MAAP;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,WAAO,IAAI,CAAC,IAAL,CAAW,KAAK,EAAL,GAAU,KAAK,EAAhB,GAAuB,KAAK,EAAL,GAAU,KAAK,EAAtC,GAA6C,KAAK,EAAL,GAAU,KAAK,EAA5D,GAAmE,KAAK,EAAL,GAAU,KAAK,EAA5F,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,GAAG,GAAG,KAAK,MAAL,EAAV;;AAEA,QAAI,GAAG,KAAK,CAAZ,EAAe;AACX,aAAO,IAAP;AACH;;AAED,QAAI,GAAG,GAAG,MAAM,GAAhB;AACA,SAAK,CAAL,IAAU,GAAV;AACA,SAAK,CAAL,IAAU,GAAV;AACA,SAAK,CAAL,IAAU,GAAV;AACA,SAAK,CAAL,IAAU,GAAV;AACA,WAAO,IAAP;AACH,GAbM;AAeP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,KAArB,EAAkC;AAAb,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAa;;AAC9B,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,SAAK,kBAAL,CAAwB,MAAxB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,MAA1B,EAAyC;AAErC,QAAI,EAAE,GAAG,KAAK,EAAd;AACA,QAAI,EAAE,GAAG,KAAK,EAAd;AACA,QAAI,EAAE,GAAG,KAAK,EAAd;AACA,QAAI,EAAE,GAAG,KAAK,EAAd;AAEA,QAAI,GAAG,GAAG,EAAE,GAAG,EAAf;AACA,QAAI,GAAG,GAAG,EAAE,GAAG,EAAf;AACA,QAAI,GAAG,GAAG,EAAE,GAAG,EAAf;AACA,QAAI,GAAG,GAAG,EAAE,GAAG,EAAf;AAEA,QAAI,MAAM,GAAG,EAAE,GAAG,EAAL,GAAU,EAAE,GAAG,EAA5B;AACA,QAAI,KAAK,GAAG,QAAZ;;AAEA,QAAI,MAAM,GAAG,CAAC,KAAd,EAAqB;AACjB,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,IAAI,CAAC,KAAL,CAAW,EAAX,EAAe,EAAf,CAAf;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,EAAL,GAAU,CAArB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACH,KAJD,MAIO,IAAI,MAAM,GAAG,KAAb,EAAoB;AACvB,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,IAAI,CAAC,KAAL,CAAW,EAAX,EAAe,EAAf,CAAf;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,IAAI,CAAC,EAAN,GAAW,CAAtB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAX;AACH,KAJM,MAIA;AACH,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,KAAL,CAAW,OAAO,EAAE,GAAG,EAAL,GAAU,EAAE,GAAG,EAAtB,CAAX,EAAuC,CAAC,GAAD,GAAO,GAAP,GAAa,GAAb,GAAmB,GAA1D,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,IAAL,CAAU,CAAC,GAAD,IAAQ,EAAE,GAAG,EAAL,GAAU,EAAE,GAAG,EAAvB,CAAV,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,KAAL,CAAW,OAAO,EAAE,GAAG,EAAL,GAAU,EAAE,GAAG,EAAtB,CAAX,EAAuC,GAAG,GAAG,GAAN,GAAY,GAAZ,GAAkB,GAAzD,CAAX;AACH;;AAED,WAAO,IAAP;AAEH,GA/BM;AAiCP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,MAAxB,EAAsC;AAClC,IAAA,MAAM,CAAC,mBAAP,CAA2B,IAA3B,EAAiC,MAAjC;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;AAKO,EAAA,UAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,MAA1B,EAAuD;AACnD,IAAA,UAAU,CAAC,uBAAX,CAAmC,MAAnC,EAA2C,IAA3C;AACA,WAAO,IAAP;AACH,GAHM,CAjaX,CAsaI;;AAEA;;;;;;;AAKc,EAAA,UAAA,CAAA,kBAAA,GAAd,UAAiC,MAAjC,EAA8D;AAC1D,QAAI,MAAM,GAAG,IAAI,UAAJ,EAAb;AACA,IAAA,UAAU,CAAC,uBAAX,CAAmC,MAAnC,EAA2C,MAA3C;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,UAAA,CAAA,uBAAA,GAAd,UAAsC,MAAtC,EAAqE,MAArE,EAAuF;AACnF,QAAI,IAAI,GAAG,MAAM,CAAC,CAAlB;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,CAAD,CAAd;AAAA,QAAmB,GAAG,GAAG,IAAI,CAAC,CAAD,CAA7B;AAAA,QAAkC,GAAG,GAAG,IAAI,CAAC,CAAD,CAA5C;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,CAAD,CAAd;AAAA,QAAmB,GAAG,GAAG,IAAI,CAAC,CAAD,CAA7B;AAAA,QAAkC,GAAG,GAAG,IAAI,CAAC,CAAD,CAA5C;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,CAAD,CAAd;AAAA,QAAmB,GAAG,GAAG,IAAI,CAAC,CAAD,CAA7B;AAAA,QAAkC,GAAG,GAAG,IAAI,CAAC,EAAD,CAA5C;AACA,QAAI,KAAK,GAAG,GAAG,GAAG,GAAN,GAAY,GAAxB;AACA,QAAI,CAAJ;;AAEA,QAAI,KAAK,GAAG,CAAZ,EAAe;AAEX,MAAA,CAAC,GAAG,MAAM,IAAI,CAAC,IAAL,CAAU,KAAK,GAAG,GAAlB,CAAV;AAEA,MAAA,MAAM,CAAC,CAAP,GAAW,OAAO,CAAlB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACH,KARD,MAQO,IAAI,GAAG,GAAG,GAAN,IAAa,GAAG,GAAG,GAAvB,EAA4B;AAE/B,MAAA,CAAC,GAAG,MAAM,IAAI,CAAC,IAAL,CAAU,MAAM,GAAN,GAAY,GAAZ,GAAkB,GAA5B,CAAV;AAEA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,OAAO,CAAlB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACH,KARM,MAQA,IAAI,GAAG,GAAG,GAAV,EAAe;AAElB,MAAA,CAAC,GAAG,MAAM,IAAI,CAAC,IAAL,CAAU,MAAM,GAAN,GAAY,GAAZ,GAAkB,GAA5B,CAAV;AAEA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,OAAO,CAAlB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACH,KARM,MAQA;AAEH,MAAA,CAAC,GAAG,MAAM,IAAI,CAAC,IAAL,CAAU,MAAM,GAAN,GAAY,GAAZ,GAAkB,GAA5B,CAAV;AAEA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,GAAG,GAAP,IAAc,CAAzB;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,OAAO,CAAlB;AACH;AACJ,GAzCa;AA2Cd;;;;;;;;AAMc,EAAA,UAAA,CAAA,GAAA,GAAd,UAAkB,IAAlB,EAAmD,KAAnD,EAAmF;AAC/E,WAAQ,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAhB,GAAqB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAArC,GAA0C,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAA1D,GAA+D,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAvF;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,UAAA,CAAA,QAAA,GAAd,UAAuB,KAAvB,EAAyD,KAAzD,EAAyF;AACrF,QAAI,GAAG,GAAG,UAAU,CAAC,GAAX,CAAe,KAAf,EAAsB,KAAtB,CAAV;AAEA,WAAO,GAAG,IAAI,CAAd;AACH,GAJa;AAMd;;;;;;AAIc,EAAA,UAAA,CAAA,IAAA,GAAd,YAAA;AACI,WAAO,IAAI,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAP;AACH,GAFa;AAId;;;;;;;AAKc,EAAA,UAAA,CAAA,OAAA,GAAd,UAAsB,CAAtB,EAAkD;AAC9C,WAAO,IAAI,UAAJ,CAAe,CAAC,CAAC,CAAC,EAAlB,EAAsB,CAAC,CAAC,CAAC,EAAzB,EAA6B,CAAC,CAAC,CAAC,EAAhC,EAAoC,CAAC,CAAC,EAAtC,CAAP;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,UAAA,CAAA,YAAA,GAAd,UAA2B,CAA3B,EAA0C,MAA1C,EAA4D;AACxD,IAAA,MAAM,CAAC,GAAP,CAAW,CAAC,CAAC,CAAC,EAAd,EAAkB,CAAC,CAAC,CAAC,EAArB,EAAyB,CAAC,CAAC,CAAC,EAA5B,EAAgC,CAAC,CAAC,EAAlC;AACA,WAAO,MAAP;AACH,GAHa;AAKd;;;;;;AAIc,EAAA,UAAA,CAAA,QAAA,GAAd,YAAA;AACI,WAAO,IAAI,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAP;AACH,GAFa;AAId;;;;;;;AAKc,EAAA,UAAA,CAAA,UAAA,GAAd,UAAyB,UAAzB,EAA8D;AAC1D,WAAO,UAAU,IAAI,UAAU,CAAC,EAAX,KAAkB,CAAhC,IAAqC,UAAU,CAAC,EAAX,KAAkB,CAAvD,IAA4D,UAAU,CAAC,EAAX,KAAkB,CAA9E,IAAmF,UAAU,CAAC,EAAX,KAAkB,CAA5G;AACH,GAFa;AAId;;;;;;;;AAMc,EAAA,UAAA,CAAA,YAAA,GAAd,UAA2B,IAA3B,EAAyD,KAAzD,EAAsE;AAClE,WAAO,UAAU,CAAC,iBAAX,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C,IAAI,UAAJ,EAA1C,CAAP;AACH,GAFa;AAId;;;;;;;;;AAOc,EAAA,UAAA,CAAA,iBAAA,GAAd,UAAgC,IAAhC,EAA8D,KAA9D,EAA6E,MAA7E,EAA+F;AAC3F,QAAI,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,CAAjB,CAAV;AACA,IAAA,IAAI,CAAC,SAAL;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,CAAjB,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,EAAL,GAAU,GAArB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,EAAL,GAAU,GAArB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,EAAL,GAAU,GAArB;AACA,WAAO,MAAP;AACH,GARa;AAUd;;;;;;;;AAMc,EAAA,UAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAiE,MAAjE,EAAgF;AAC5E,QAAI,CAAC,MAAL,EAAa;AACT,MAAA,MAAM,GAAG,CAAT;AACH;;AACD,WAAO,IAAI,UAAJ,CAAe,KAAK,CAAC,MAAD,CAApB,EAA8B,KAAK,CAAC,MAAM,GAAG,CAAV,CAAnC,EAAiD,KAAK,CAAC,MAAM,GAAG,CAAV,CAAtD,EAAoE,KAAK,CAAC,MAAM,GAAG,CAAV,CAAzE,CAAP;AACH,GALa;AAOd;;;;;;;;AAMc,EAAA,UAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAsE,MAAtE,EAAsF,MAAtF,EAAwG;AACpG,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAD,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,CAAC,MAAM,GAAG,CAAV,CAAhB;AACH,GALa;AAOd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,eAAA,GAAd,UAA8B,CAA9B,EAAyC,CAAzC,EAAoD,CAApD,EAA6D;AACzD,QAAI,CAAC,GAAG,IAAI,UAAJ,EAAR;AACA,IAAA,UAAU,CAAC,yBAAX,CAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,CAA9C;AACA,WAAO,CAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQc,EAAA,UAAA,CAAA,oBAAA,GAAd,UAAmC,CAAnC,EAA8C,CAA9C,EAAyD,CAAzD,EAAoE,MAApE,EAAsF;AAClF,IAAA,UAAU,CAAC,yBAAX,CAAqC,CAArC,EAAwC,CAAxC,EAA2C,CAA3C,EAA8C,MAA9C;AACA,WAAO,MAAP;AACH,GAHa;AAKd;;;;;;;AAKc,EAAA,UAAA,CAAA,eAAA,GAAd,UAA8B,GAA9B,EAAyD;AACrD,QAAI,CAAC,GAAG,IAAI,UAAJ,EAAR;AACA,IAAA,UAAU,CAAC,yBAAX,CAAqC,GAAG,CAAC,EAAzC,EAA6C,GAAG,CAAC,EAAjD,EAAqD,GAAG,CAAC,EAAzD,EAA6D,CAA7D;AACA,WAAO,CAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,UAAA,CAAA,oBAAA,GAAd,UAAmC,GAAnC,EAAgE,MAAhE,EAAkF;AAC9E,IAAA,UAAU,CAAC,yBAAX,CAAqC,GAAG,CAAC,EAAzC,EAA6C,GAAG,CAAC,EAAjD,EAAqD,GAAG,CAAC,EAAzD,EAA6D,MAA7D;AACA,WAAO,MAAP;AACH,GAHa;AAKd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,oBAAA,GAAd,UAAmC,GAAnC,EAAgD,KAAhD,EAA+D,IAA/D,EAA2E;AACvE,QAAI,CAAC,GAAG,IAAI,UAAJ,EAAR;AACA,IAAA,UAAU,CAAC,yBAAX,CAAqC,GAArC,EAA0C,KAA1C,EAAiD,IAAjD,EAAuD,CAAvD;AACA,WAAO,CAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,yBAAA,GAAd,UAAwC,GAAxC,EAAqD,KAArD,EAAoE,IAApE,EAAkF,MAAlF,EAAoG;AAChG;AACA,QAAI,QAAQ,GAAG,IAAI,GAAG,GAAtB;AACA,QAAI,SAAS,GAAG,KAAK,GAAG,GAAxB;AACA,QAAI,OAAO,GAAG,GAAG,GAAG,GAApB;AAEA,QAAI,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,QAAT,CAAd;AACA,QAAI,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,QAAT,CAAd;AACA,QAAI,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAf;AACA,QAAI,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAf;AACA,QAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAAb;AACA,QAAI,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAAb;AAEA,IAAA,MAAM,CAAC,CAAP,GAAY,MAAM,GAAG,QAAT,GAAoB,OAArB,GAAiC,MAAM,GAAG,QAAT,GAAoB,OAAhE;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,MAAM,GAAG,QAAT,GAAoB,OAArB,GAAiC,MAAM,GAAG,QAAT,GAAoB,OAAhE;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,MAAM,GAAG,QAAT,GAAoB,OAArB,GAAiC,MAAM,GAAG,QAAT,GAAoB,OAAhE;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,MAAM,GAAG,QAAT,GAAoB,OAArB,GAAiC,MAAM,GAAG,QAAT,GAAoB,OAAhE;AACH,GAjBa;AAmBd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,sBAAA,GAAd,UAAqC,KAArC,EAAoD,IAApD,EAAkE,KAAlE,EAA+E;AAC3E,QAAI,MAAM,GAAG,IAAI,UAAJ,EAAb;AACA,IAAA,UAAU,CAAC,2BAAX,CAAuC,KAAvC,EAA8C,IAA9C,EAAoD,KAApD,EAA2D,MAA3D;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,2BAAA,GAAd,UAA0C,KAA1C,EAAyD,IAAzD,EAAuE,KAAvE,EAAsF,MAAtF,EAAwG;AACpG;AACA,QAAI,kBAAkB,GAAG,CAAC,KAAK,GAAG,KAAT,IAAkB,GAA3C;AACA,QAAI,mBAAmB,GAAG,CAAC,KAAK,GAAG,KAAT,IAAkB,GAA5C;AACA,QAAI,QAAQ,GAAG,IAAI,GAAG,GAAtB;AAEA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,GAAL,CAAS,mBAAT,IAAgC,IAAI,CAAC,GAAL,CAAS,QAAT,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,GAAL,CAAS,mBAAT,IAAgC,IAAI,CAAC,GAAL,CAAS,QAAT,CAA3C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,GAAL,CAAS,kBAAT,IAA+B,IAAI,CAAC,GAAL,CAAS,QAAT,CAA1C;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,GAAL,CAAS,kBAAT,IAA+B,IAAI,CAAC,GAAL,CAAS,QAAT,CAA1C;AACH,GAVa;AAYd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,0BAAA,GAAd,UAAyC,KAAzC,EAAwE,KAAxE,EAAuG,KAAvG,EAAoI;AAChI,QAAI,IAAI,GAAG,IAAI,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,CAAX;AACA,IAAA,UAAU,CAAC,+BAAX,CAA2C,KAA3C,EAAkD,KAAlD,EAAyD,KAAzD,EAAgE,IAAhE;AACA,WAAO,IAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,+BAAA,GAAd,UAA8C,KAA9C,EAA6E,KAA7E,EAA4G,KAA5G,EAA2I,GAA3I,EAA0J;AACtJ,QAAI,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAb;AACA,IAAA,MAAM,CAAC,gBAAP,CAAwB,KAAK,CAAC,SAAN,EAAxB,EAA2C,KAAK,CAAC,SAAN,EAA3C,EAA8D,KAAK,CAAC,SAAN,EAA9D,EAAiF,MAAjF;AACA,IAAA,UAAU,CAAC,uBAAX,CAAmC,MAAnC,EAA2C,GAA3C;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,KAAA,GAAd,UAAoB,IAApB,EAAqD,KAArD,EAAuF,MAAvF,EAAqG;AACjG,QAAI,MAAM,GAAG,UAAU,CAAC,QAAX,EAAb;AAEA,IAAA,UAAU,CAAC,UAAX,CAAsB,IAAtB,EAA4B,KAA5B,EAAmC,MAAnC,EAA2C,MAA3C;AAEA,WAAO,MAAP;AACH,GANa;AAQd;;;;;;;;;AAOc,EAAA,UAAA,CAAA,UAAA,GAAd,UAAyB,IAAzB,EAA0D,KAA1D,EAA4F,MAA5F,EAA4G,MAA5G,EAA8H;AAC1H,QAAI,IAAJ;AACA,QAAI,IAAJ;AACA,QAAI,IAAI,GAAM,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAjB,GAAwB,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAzC,GAAiD,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAAlE,GAA0E,IAAI,CAAC,EAAL,GAAU,KAAK,CAAC,EAArG;AACA,QAAI,IAAI,GAAG,KAAX;;AAEA,QAAI,IAAI,GAAG,CAAX,EAAc;AACV,MAAA,IAAI,GAAG,IAAP;AACA,MAAA,IAAI,GAAG,CAAC,IAAR;AACH;;AAED,QAAI,IAAI,GAAG,QAAX,EAAqB;AACjB,MAAA,IAAI,GAAG,IAAI,MAAX;AACA,MAAA,IAAI,GAAG,IAAI,GAAG,CAAC,MAAJ,GAAa,MAAxB;AACH,KAHD,MAIK;AACD,UAAI,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,IAAV,CAAX;AACA,UAAI,IAAI,GAAI,MAAM,IAAI,CAAC,GAAL,CAAS,IAAT,CAAlB;AACA,MAAA,IAAI,GAAI,IAAI,CAAC,GAAL,CAAS,CAAC,MAAM,MAAP,IAAiB,IAA1B,CAAD,GAAoC,IAA3C;AACA,MAAA,IAAI,GAAG,IAAI,GAAK,CAAC,IAAI,CAAC,GAAL,CAAS,MAAM,GAAG,IAAlB,CAAF,GAA6B,IAAjC,GAA2C,IAAI,CAAC,GAAL,CAAS,MAAM,GAAG,IAAlB,CAAD,GAA4B,IAAjF;AACH;;AAED,IAAA,MAAM,CAAC,CAAP,GAAY,IAAI,GAAG,IAAI,CAAC,EAAb,GAAoB,IAAI,GAAG,KAAK,CAAC,EAA5C;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,IAAI,GAAG,IAAI,CAAC,EAAb,GAAoB,IAAI,GAAG,KAAK,CAAC,EAA5C;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,IAAI,GAAG,IAAI,CAAC,EAAb,GAAoB,IAAI,GAAG,KAAK,CAAC,EAA5C;AACA,IAAA,MAAM,CAAC,CAAP,GAAY,IAAI,GAAG,IAAI,CAAC,EAAb,GAAoB,IAAI,GAAG,KAAK,CAAC,EAA5C;AACH,GA1Ba;AA4Bd;;;;;;;;;;;AASc,EAAA,UAAA,CAAA,OAAA,GAAd,UAAsB,MAAtB,EAAyD,QAAzD,EAA8F,MAA9F,EAAiI,QAAjI,EAAsK,MAAtK,EAAoL;AAChL,QAAI,OAAO,GAAG,MAAM,GAAG,MAAvB;AACA,QAAI,KAAK,GAAG,MAAM,GAAG,OAArB;AACA,QAAI,KAAK,GAAK,MAAM,KAAP,GAAiB,MAAM,OAAxB,GAAoC,GAAhD;AACA,QAAI,KAAK,GAAI,CAAC,GAAD,GAAO,KAAR,GAAkB,MAAM,OAApC;AACA,QAAI,KAAK,GAAI,KAAK,GAAI,MAAM,OAAhB,GAA4B,MAAxC;AACA,QAAI,KAAK,GAAG,KAAK,GAAG,OAApB;AAEA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,QAAI,CAAC,GAAM,MAAM,CAAC,EAAP,GAAY,KAAb,GAAuB,MAAM,CAAC,EAAP,GAAY,KAApC,GAA+C,QAAQ,CAAC,EAAT,GAAc,KAA9D,GAAyE,QAAQ,CAAC,EAAT,GAAc,KAA/F;AACA,WAAO,IAAI,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAP;AACH,GAba;;AAclB,SAAA,UAAA;AAAC,CArzBD,EAAA;;;AAuzBA;;;;AAGA,IAAA,MAAA;AAAA;AAAA,YAAA;AAgDI;;;AAGA,WAAA,MAAA,GAAA;AAvCQ,SAAA,WAAA,GAAc,KAAd;AACA,SAAA,gBAAA,GAAmB,IAAnB;AACA,SAAA,cAAA,GAAiB,IAAjB;AACA,SAAA,mBAAA,GAAsB,IAAtB;AACR;;;;;;AAKO,SAAA,UAAA,GAAqB,CAAC,CAAtB;;AA+BH,QAAI,uBAAuB,CAAC,0BAA5B,EAAwD;AACpD,MAAA,uBAAuB,CAAC,qBAAxB,CAA+C,IAA/C,CAAoD,IAApD;AACH;;AAED,SAAK,EAAL,GAAU,IAAI,uBAAuB,CAAC,iBAA5B,CAA8C,EAA9C,CAAV;;AACA,SAAK,qBAAL,CAA2B,KAA3B;AACH;;AArDD,EAAA,MAAA,CAAA,cAAA,CAAkB,MAAlB,EAAkB,WAAlB,EAA2B;AAH3B;;;SAGA,YAAA;AACI,aAAO,uBAAuB,CAAC,eAA/B;AACH,KAF0B;qBAAA;;AAAA,GAA3B;AAuBA,EAAA,MAAA,CAAA,cAAA,CAAW,MAAA,CAAA,SAAX,EAAW,GAAX,EAAY;AAHZ;;;SAGA,YAAA;AAA8D,aAAO,KAAK,EAAZ;AAAiB,KAAnE;qBAAA;;AAAA,GAAZ;AAEA;;AACO,EAAA,MAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,SAAK,UAAL,GAAkB,MAAM,CAAC,eAAP,EAAlB;AACA,SAAK,WAAL,GAAmB,KAAnB;AACA,SAAK,cAAL,GAAsB,KAAtB;AACA,SAAK,gBAAL,GAAwB,IAAxB;AACA,SAAK,mBAAL,GAA2B,IAA3B;AACH,GANM;AAQP;;;AACQ,EAAA,MAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,UAA9B,EAAmD,eAAnD,EAAqF,aAArF,EAAqH,kBAArH,EAAuJ;AAApG,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,KAAA;AAAgC;;AAAE,QAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,aAAA,GAAA,KAAA;AAA8B;;AAAE,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,IAAA;AAAkC;;AACnJ,SAAK,UAAL,GAAkB,MAAM,CAAC,eAAP,EAAlB;AACA,SAAK,WAAL,GAAmB,UAAnB;AACA,SAAK,cAAL,GAAsB,UAAU,IAAI,aAApC;AACA,SAAK,gBAAL,GAAwB,KAAK,WAAL,GAAmB,KAAnB,GAA2B,eAAnD;AACA,SAAK,mBAAL,GAA2B,KAAK,cAAL,GAAsB,KAAtB,GAA8B,kBAAzD;AACH,GANO,CAxCZ,CA4DI;;AAEA;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,UAAA,GAAP,YAAA;AACI,QAAI,KAAK,gBAAT,EAA2B;AACvB,WAAK,gBAAL,GAAwB,KAAxB;AACA,UAAM,CAAC,GAAG,KAAK,EAAf;AACA,WAAK,WAAL,GACI,CAAC,CAAC,CAAD,CAAD,KAAS,GAAT,IAAgB,CAAC,CAAC,CAAD,CAAD,KAAS,GAAzB,IAAgC,CAAC,CAAC,CAAD,CAAD,KAAS,GAAzC,IAAgD,CAAC,CAAC,CAAD,CAAD,KAAS,GAAzD,IACA,CAAC,CAAC,CAAD,CAAD,KAAS,GADT,IACgB,CAAC,CAAC,CAAD,CAAD,KAAS,GADzB,IACgC,CAAC,CAAC,CAAD,CAAD,KAAS,GADzC,IACgD,CAAC,CAAC,CAAD,CAAD,KAAS,GADzD,IAEA,CAAC,CAAC,CAAD,CAAD,KAAS,GAFT,IAEgB,CAAC,CAAC,CAAD,CAAD,KAAS,GAFzB,IAEgC,CAAC,CAAC,EAAD,CAAD,KAAU,GAF1C,IAEiD,CAAC,CAAC,EAAD,CAAD,KAAU,GAF3D,IAGA,CAAC,CAAC,EAAD,CAAD,KAAU,GAHV,IAGiB,CAAC,CAAC,EAAD,CAAD,KAAU,GAH3B,IAGkC,CAAC,CAAC,EAAD,CAAD,KAAU,GAH5C,IAGmD,CAAC,CAAC,EAAD,CAAD,KAAU,GAJjE;AAMH;;AAED,WAAO,KAAK,WAAZ;AACH,GAbM;AAeP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,eAAA,GAAP,YAAA;AACI,QAAI,KAAK,mBAAT,EAA8B;AAC1B,WAAK,mBAAL,GAA2B,KAA3B;;AACA,UAAI,KAAK,EAAL,CAAQ,CAAR,MAAe,GAAf,IAAsB,KAAK,EAAL,CAAQ,CAAR,MAAe,GAArC,IAA4C,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAAhE,EAAqE;AACjE,aAAK,cAAL,GAAsB,KAAtB;AACH,OAFD,MAEO,IAAI,KAAK,EAAL,CAAQ,CAAR,MAAe,GAAf,IAAsB,KAAK,EAAL,CAAQ,CAAR,MAAe,GAArC,IAA4C,KAAK,EAAL,CAAQ,CAAR,MAAe,GAA3D,IACP,KAAK,EAAL,CAAQ,CAAR,MAAe,GADR,IACe,KAAK,EAAL,CAAQ,CAAR,MAAe,GAD9B,IACqC,KAAK,EAAL,CAAQ,CAAR,MAAe,GADpD,IAEP,KAAK,EAAL,CAAQ,CAAR,MAAe,GAFR,IAEe,KAAK,EAAL,CAAQ,CAAR,MAAe,GAF9B,IAEqC,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAFrD,IAE4D,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAF5E,IAGP,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAHT,IAGgB,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAHhC,IAGuC,KAAK,EAAL,CAAQ,EAAR,MAAgB,GAH3D,EAGgE;AACnE,aAAK,cAAL,GAAsB,KAAtB;AACH,OALM,MAKA;AACH,aAAK,cAAL,GAAsB,IAAtB;AACH;AACJ;;AAED,WAAO,KAAK,cAAZ;AACH,GAhBM;AAkBP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC3B,aAAO,CAAP;AACH;;AAED,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,CAAD,CAArC;AAAA,QAA0C,GAAG,GAAG,CAAC,CAAC,CAAD,CAAjD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,CAAD,CAArC;AAAA,QAA0C,GAAG,GAAG,CAAC,CAAC,CAAD,CAAjD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,EAAD,CAArC;AAAA,QAA2C,GAAG,GAAG,CAAC,CAAC,EAAD,CAAlD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,EAAD,CAAb;AAAA,QAAmB,GAAG,GAAG,CAAC,CAAC,EAAD,CAA1B;AAAA,QAAgC,GAAG,GAAG,CAAC,CAAC,EAAD,CAAvC;AAAA,QAA6C,GAAG,GAAG,CAAC,CAAC,EAAD,CAApD,CATJ,CAUI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,WAAO,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA1C,GAAsD,GAAG,GAAG,SAAnE;AACH,GA/BM,CA3GX,CA4II;;AAEA;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,WAAO,KAAK,EAAZ;AACH,GAFM;AAGP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,WAAO,KAAK,EAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,SAAK,WAAL,CAAiB,IAAjB;AACA,WAAO,IAAP;AACH,GAHM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,IAAA,MAAM,CAAC,eAAP,CACI,GADJ,EACS,GADT,EACc,GADd,EACmB,GADnB,EAEI,GAFJ,EAES,GAFT,EAEc,GAFd,EAEmB,GAFnB,EAGI,GAHJ,EAGS,GAHT,EAGc,GAHd,EAGmB,GAHnB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,IALJ;;AAOA,SAAK,qBAAL,CAA2B,KAA3B;;AACA,WAAO,IAAP;AACH,GAVM;AAYP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAAuC;AACnC,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,SAAK,QAAL,CAAc,KAAd,EAAqB,MAArB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA8C,MAA9C,EAA4D;AACxD,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,OAAO,GAAG,MAAM,CAAC,EAAvB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,CAArB;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,CAAC,CAAC,KAAD,CAAD,GAAW,MAAM,CAAC,KAAD,CAAlC;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;;AACA,WAAO,IAAP;AACH,GATM;AAWP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAA6C;AACzC,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,CAArB;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,CAAC,CAAC,KAAD,CAAD,IAAY,MAAM,CAAC,KAAD,CAAlB;AACH;;AACD,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GARM;AAUP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAgC;AAC5B,QAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC3B,MAAA,MAAM,CAAC,aAAP,CAAqB,KAArB;AACA,aAAO,IAAP;AACH,KAJ2B,CAM5B;;;AACA,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,CAAD,CAArC;AAAA,QAA0C,GAAG,GAAG,CAAC,CAAC,CAAD,CAAjD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,CAAD,CAArC;AAAA,QAA0C,GAAG,GAAG,CAAC,CAAC,CAAD,CAAjD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAD,CAAb;AAAA,QAAkB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAzB;AAAA,QAA8B,GAAG,GAAG,CAAC,CAAC,EAAD,CAArC;AAAA,QAA2C,GAAG,GAAG,CAAC,CAAC,EAAD,CAAlD;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,EAAD,CAAb;AAAA,QAAmB,GAAG,GAAG,CAAC,CAAC,EAAD,CAA1B;AAAA,QAAgC,GAAG,GAAG,CAAC,CAAC,EAAD,CAAvC;AAAA,QAA6C,GAAG,GAAG,CAAC,CAAC,EAAD,CAApD;AAEA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AAEA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AAEA,QAAM,GAAG,GAAG,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA1C,GAAsD,GAAG,GAAG,SAAxE;;AAEA,QAAI,GAAG,KAAK,CAAZ,EAAe;AACX;AACA,MAAA,KAAK,CAAC,QAAN,CAAe,IAAf;AACA,aAAO,IAAP;AACH;;AAED,QAAM,MAAM,GAAG,IAAI,GAAnB;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AACA,QAAM,SAAS,GAAG,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAApC;AAEA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AAEA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AAEA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AACA,QAAM,SAAS,GAAG,EAAE,GAAG,GAAG,SAAN,GAAkB,GAAG,GAAG,SAAxB,GAAoC,GAAG,GAAG,SAA5C,CAAlB;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,SAAS,GAAG,MADhB,EACwB,SAAS,GAAG,MADpC,EAC4C,SAAS,GAAG,MADxD,EACgE,SAAS,GAAG,MAD5E,EAEI,SAAS,GAAG,MAFhB,EAEwB,SAAS,GAAG,MAFpC,EAE4C,SAAS,GAAG,MAFxD,EAEgE,SAAS,GAAG,MAF5E,EAGI,SAAS,GAAG,MAHhB,EAGwB,SAAS,GAAG,MAHpC,EAG4C,SAAS,GAAG,MAHxD,EAGgE,SAAS,GAAG,MAH5E,EAII,SAAS,GAAG,MAJhB,EAIwB,SAAS,GAAG,MAJpC,EAI4C,SAAS,GAAG,MAJxD,EAIgE,SAAS,GAAG,MAJ5E,EAKI,KALJ;AAQA,WAAO,IAAP;AACH,GAvEM;AAyEP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,KAAjC,EAA8C;AAC1C,SAAK,EAAL,CAAQ,KAAR,KAAkB,KAAlB;;AACA,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAsC,KAAtC,EAAmD;AAC/C,SAAK,EAAL,CAAQ,KAAR,KAAkB,KAAlB;;AACA,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GAJM;AAMP;;;;;;;;;AAOO,EAAA,MAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,CAAhC,EAA2C,CAA3C,EAAsD,CAAtD,EAA+D;AAC3D,SAAK,EAAL,CAAQ,EAAR,IAAc,CAAd;AACA,SAAK,EAAL,CAAQ,EAAR,IAAc,CAAd;AACA,SAAK,EAAL,CAAQ,EAAR,IAAc,CAAd;;AACA,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;AAOO,EAAA,MAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,CAAhC,EAA2C,CAA3C,EAAsD,CAAtD,EAA+D;AAC3D,SAAK,EAAL,CAAQ,EAAR,KAAe,CAAf;AACA,SAAK,EAAL,CAAQ,EAAR,KAAe,CAAf;AACA,SAAK,EAAL,CAAQ,EAAR,KAAe,CAAf;;AACA,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,OAAtB,EAAqD;AACjD,WAAO,KAAK,wBAAL,CAA8B,OAAO,CAAC,EAAtC,EAA0C,OAAO,CAAC,EAAlD,EAAsD,OAAO,CAAC,EAA9D,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,CAAQ,EAAR,CAAZ,EAAyB,KAAK,EAAL,CAAQ,EAAR,CAAzB,EAAsC,KAAK,EAAL,CAAQ,EAAR,CAAtC,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,MAA3B,EAA0C;AACtC,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,CAAQ,EAAR,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,CAAQ,EAAR,CAAX;AACA,IAAA,MAAM,CAAC,CAAP,GAAW,KAAK,EAAL,CAAQ,EAAR,CAAX;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,YAAA;AACI,QAAM,CAAC,GAAG,KAAK,CAAf;AACA,IAAA,MAAM,CAAC,eAAP,CACI,GADJ,EACS,GADT,EACc,GADd,EACmB,GADnB,EAEI,GAFJ,EAES,GAFT,EAEc,GAFd,EAEmB,GAFnB,EAGI,GAHJ,EAGS,GAHT,EAGc,GAHd,EAGmB,GAHnB,EAII,CAAC,CAAC,EAAD,CAJL,EAIW,CAAC,CAAC,EAAD,CAJZ,EAIkB,CAAC,CAAC,EAAD,CAJnB,EAIyB,CAAC,CAAC,EAAD,CAJ1B,EAKI,IALJ;;AAOA,SAAK,qBAAL,CAA2B,CAAC,CAAC,EAAD,CAAD,KAAU,CAAV,IAAe,CAAC,CAAC,EAAD,CAAD,KAAU,CAAzB,IAA8B,CAAC,CAAC,EAAD,CAAD,KAAU,CAAxC,IAA6C,CAAC,CAAC,EAAD,CAAD,KAAU,CAAlF;;AACA,WAAO,IAAP;AACH,GAXM;AAaP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA4C;AACxC,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,SAAK,aAAL,CAAmB,KAAnB,EAA0B,MAA1B;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA4C;AACxC,IAAA,KAAK,CAAC,WAAN,CAAkB,KAAK,EAAvB;AACA,QAAM,CAAC,GAAI,KAAX;;AACA,SAAK,qBAAL,CAA2B,CAAC,CAAC,WAA7B,EAA0C,CAAC,CAAC,gBAA5C,EAA8D,CAAC,CAAC,cAAhE,EAAgF,CAAC,CAAC,mBAAlF;;AACA,WAAO,IAAP;AACH,GALM;AAOP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAwD,MAAxD,EAA0E;AAAlB,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAA;AAAkB;;AACtE,QAAI,MAAM,GAAG,KAAK,EAAlB;AACA,IAAA,KAAK,CAAC,MAAD,CAAL,GAAgB,MAAM,CAAC,CAAD,CAAtB;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,MAAM,CAAC,CAAD,CAA1B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AACA,IAAA,KAAK,CAAC,MAAM,GAAG,EAAV,CAAL,GAAqB,MAAM,CAAC,EAAD,CAA3B;AAEA,WAAO,IAAP;AACH,GApBM;AAsBP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,KAArB,EAAmD,MAAnD,EAAiE;AAC7D,QAAI,KAAK,WAAT,EAAsB;AAClB,MAAA,MAAM,CAAC,QAAP,CAAgB,KAAhB;AACA,aAAO,IAAP;AACH;;AACD,QAAK,KAAgB,CAAC,WAAtB,EAAmC;AAC/B,MAAA,MAAM,CAAC,QAAP,CAAgB,IAAhB;AACA,aAAO,IAAP;AACH;;AAED,SAAK,eAAL,CAAqB,KAArB,EAA4B,MAAM,CAAC,EAAnC,EAAuC,CAAvC;;AACA,IAAA,MAAM,CAAC,cAAP;;AACA,WAAO,IAAP;AACH,GAbM;AAeP;;;;;;;;;AAOO,EAAA,MAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAqD,MAArD,EAA2F,MAA3F,EAAyG;AACrG,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,CAArB;AACA,QAAI,GAAG,GAAG,CAAC,CAAC,CAAD,CAAX;AAAA,QAAgB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAvB;AAAA,QAA4B,GAAG,GAAG,CAAC,CAAC,CAAD,CAAnC;AAAA,QAAwC,GAAG,GAAG,CAAC,CAAC,CAAD,CAA/C;AACA,QAAI,GAAG,GAAG,CAAC,CAAC,CAAD,CAAX;AAAA,QAAgB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAvB;AAAA,QAA4B,GAAG,GAAG,CAAC,CAAC,CAAD,CAAnC;AAAA,QAAwC,GAAG,GAAG,CAAC,CAAC,CAAD,CAA/C;AACA,QAAI,GAAG,GAAG,CAAC,CAAC,CAAD,CAAX;AAAA,QAAgB,GAAG,GAAG,CAAC,CAAC,CAAD,CAAvB;AAAA,QAA4B,IAAI,GAAG,CAAC,CAAC,EAAD,CAApC;AAAA,QAA0C,IAAI,GAAG,CAAC,CAAC,EAAD,CAAlD;AACA,QAAI,IAAI,GAAG,CAAC,CAAC,EAAD,CAAZ;AAAA,QAAkB,IAAI,GAAG,CAAC,CAAC,EAAD,CAA1B;AAAA,QAAgC,IAAI,GAAG,CAAC,CAAC,EAAD,CAAxC;AAAA,QAA8C,IAAI,GAAG,CAAC,CAAC,EAAD,CAAtD;AAEA,QAAI,GAAG,GAAG,MAAM,CAAC,CAAD,CAAhB;AAAA,QAAqB,GAAG,GAAG,MAAM,CAAC,CAAD,CAAjC;AAAA,QAAsC,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlD;AAAA,QAAuD,GAAG,GAAG,MAAM,CAAC,CAAD,CAAnE;AACA,QAAI,GAAG,GAAG,MAAM,CAAC,CAAD,CAAhB;AAAA,QAAqB,GAAG,GAAG,MAAM,CAAC,CAAD,CAAjC;AAAA,QAAsC,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlD;AAAA,QAAuD,GAAG,GAAG,MAAM,CAAC,CAAD,CAAnE;AACA,QAAI,GAAG,GAAG,MAAM,CAAC,CAAD,CAAhB;AAAA,QAAqB,GAAG,GAAG,MAAM,CAAC,CAAD,CAAjC;AAAA,QAAsC,IAAI,GAAG,MAAM,CAAC,EAAD,CAAnD;AAAA,QAAyD,IAAI,GAAG,MAAM,CAAC,EAAD,CAAtE;AACA,QAAI,IAAI,GAAG,MAAM,CAAC,EAAD,CAAjB;AAAA,QAAuB,IAAI,GAAG,MAAM,CAAC,EAAD,CAApC;AAAA,QAA0C,IAAI,GAAG,MAAM,CAAC,EAAD,CAAvD;AAAA,QAA6D,IAAI,GAAG,MAAM,CAAC,EAAD,CAA1E;AAEA,IAAA,MAAM,CAAC,MAAD,CAAN,GAAiB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,GAA9B,GAAoC,GAAG,GAAG,IAA3D;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,GAA9B,GAAoC,GAAG,GAAG,IAA/D;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,IAA9B,GAAqC,GAAG,GAAG,IAAhE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,IAA9B,GAAqC,GAAG,GAAG,IAAhE;AAEA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,GAA9B,GAAoC,GAAG,GAAG,IAA/D;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,GAA9B,GAAoC,GAAG,GAAG,IAA/D;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,IAA9B,GAAqC,GAAG,GAAG,IAAhE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,GAAG,GAAG,IAA9B,GAAqC,GAAG,GAAG,IAAhE;AAEA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,IAAI,GAAG,GAA/B,GAAqC,IAAI,GAAG,IAAjE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,CAAV,CAAN,GAAqB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,IAAI,GAAG,GAA/B,GAAqC,IAAI,GAAG,IAAjE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,IAAI,GAAG,IAA/B,GAAsC,IAAI,GAAG,IAAnE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAAlB,GAAwB,IAAI,GAAG,IAA/B,GAAsC,IAAI,GAAG,IAAnE;AAEA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,IAAI,GAAG,GAAP,GAAa,IAAI,GAAG,GAApB,GAA0B,IAAI,GAAG,GAAjC,GAAuC,IAAI,GAAG,IAApE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,IAAI,GAAG,GAAP,GAAa,IAAI,GAAG,GAApB,GAA0B,IAAI,GAAG,GAAjC,GAAuC,IAAI,GAAG,IAApE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,IAAI,GAAG,GAAP,GAAa,IAAI,GAAG,GAApB,GAA0B,IAAI,GAAG,IAAjC,GAAwC,IAAI,GAAG,IAArE;AACA,IAAA,MAAM,CAAC,MAAM,GAAG,EAAV,CAAN,GAAsB,IAAI,GAAG,GAAP,GAAa,IAAI,GAAG,GAApB,GAA0B,IAAI,GAAG,IAAjC,GAAwC,IAAI,GAAG,IAArE;AACA,WAAO,IAAP;AACH,GAjCM;AAmCP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,KAAd,EAA0C;AACtC,QAAM,KAAK,GAAI,KAAf;;AACA,QAAI,CAAC,KAAL,EAAY;AACR,aAAO,KAAP;AACH;;AAED,QAAI,KAAK,WAAL,IAAoB,KAAK,CAAC,WAA9B,EAA2C;AACvC,UAAI,CAAC,KAAK,gBAAN,IAA0B,CAAC,KAAK,CAAC,gBAArC,EAAuD;AACnD,eAAO,KAAK,WAAL,IAAoB,KAAK,CAAC,WAAjC;AACH;AACJ;;AAED,QAAM,CAAC,GAAG,KAAK,CAAf;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,CAAjB;AACA,WACI,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAAX,IAAkB,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAA7B,IAAoC,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAA/C,IAAsD,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAAjE,IACA,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CADX,IACkB,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAD7B,IACoC,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAD/C,IACsD,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CADjE,IAEA,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAFX,IAEkB,CAAC,CAAC,CAAD,CAAD,KAAS,EAAE,CAAC,CAAD,CAF7B,IAEoC,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAFhD,IAEwD,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAFpE,IAGA,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAHZ,IAGoB,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAHhC,IAGwC,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAHpD,IAG4D,CAAC,CAAC,EAAD,CAAD,KAAU,EAAE,CAAC,EAAD,CAJ5E;AAMH,GApBM;AAsBP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,QAAM,MAAM,GAAG,IAAI,MAAJ,EAAf;AACA,IAAA,MAAM,CAAC,QAAP,CAAgB,IAAhB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,QAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,KAAK,EAAL,CAAQ,CAAR,IAAa,CAAxB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAApB,EAAwB,CAAC,EAAzB,EAA6B;AACzB,MAAA,IAAI,GAAI,IAAI,GAAG,GAAR,IAAgB,KAAK,EAAL,CAAQ,CAAR,IAAa,CAA7B,CAAP;AACH;;AACD,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;;AAOO,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAAkC,QAAlC,EAAyD,WAAzD,EAA8E;AAC1E,QAAI,KAAK,WAAT,EAAsB;AAClB,UAAI,WAAJ,EAAiB;AACb,QAAA,WAAW,CAAC,MAAZ,CAAmB,CAAnB;AACH;;AACD,UAAI,KAAJ,EAAW;AACP,QAAA,KAAK,CAAC,MAAN,CAAa,CAAb;AACH;;AACD,UAAI,QAAJ,EAAc;AACV,QAAA,QAAQ,CAAC,cAAT,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC;AACH;;AACD,aAAO,IAAP;AACH;;AAED,QAAM,CAAC,GAAG,KAAK,EAAf;;AACA,QAAI,WAAJ,EAAiB;AACb,MAAA,WAAW,CAAC,cAAZ,CAA2B,CAAC,CAAC,EAAD,CAA5B,EAAkC,CAAC,CAAC,EAAD,CAAnC,EAAyC,CAAC,CAAC,EAAD,CAA1C;AACH;;AAED,IAAA,KAAK,GAAG,KAAK,IAAI,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAjB;AACA,IAAA,KAAK,CAAC,CAAN,GAAU,IAAI,CAAC,IAAL,CAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAR,GAAc,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAtB,GAA4B,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAA9C,CAAV;AACA,IAAA,KAAK,CAAC,CAAN,GAAU,IAAI,CAAC,IAAL,CAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAR,GAAc,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAtB,GAA4B,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAA9C,CAAV;AACA,IAAA,KAAK,CAAC,CAAN,GAAU,IAAI,CAAC,IAAL,CAAU,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAR,GAAc,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAtB,GAA4B,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,CAAC,EAAD,CAA/C,CAAV;;AAEA,QAAI,KAAK,WAAL,MAAsB,CAA1B,EAA6B;AACzB,MAAA,KAAK,CAAC,CAAN,IAAW,CAAC,CAAZ;AACH;;AAED,QAAI,KAAK,CAAC,EAAN,KAAa,CAAb,IAAkB,KAAK,CAAC,EAAN,KAAa,CAA/B,IAAoC,KAAK,CAAC,EAAN,KAAa,CAArD,EAAwD;AACpD,UAAI,QAAJ,EAAc;AACV,QAAA,QAAQ,CAAC,cAAT,CAAwB,GAAxB,EAA6B,GAA7B,EAAkC,GAAlC,EAAuC,GAAvC;AACH;;AACD,aAAO,KAAP;AACH;;AAED,QAAI,QAAJ,EAAc;AACV,UAAM,EAAE,GAAG,IAAI,KAAK,CAAC,EAArB;AAAA,UAAyB,EAAE,GAAG,IAAI,KAAK,CAAC,EAAxC;AAAA,UAA4C,EAAE,GAAG,IAAI,KAAK,CAAC,EAA3D;AACA,MAAA,MAAM,CAAC,eAAP,CACI,CAAC,CAAC,CAAD,CAAD,GAAO,EADX,EACe,CAAC,CAAC,CAAD,CAAD,GAAO,EADtB,EAC0B,CAAC,CAAC,CAAD,CAAD,GAAO,EADjC,EACqC,GADrC,EAEI,CAAC,CAAC,CAAD,CAAD,GAAO,EAFX,EAEe,CAAC,CAAC,CAAD,CAAD,GAAO,EAFtB,EAE0B,CAAC,CAAC,CAAD,CAAD,GAAO,EAFjC,EAEqC,GAFrC,EAGI,CAAC,CAAC,CAAD,CAAD,GAAO,EAHX,EAGe,CAAC,CAAC,CAAD,CAAD,GAAO,EAHtB,EAG0B,CAAC,CAAC,EAAD,CAAD,GAAQ,EAHlC,EAGsC,GAHtC,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,OAAO,CAAC,MAAR,CAAe,CAAf,CALJ;AAQA,MAAA,UAAU,CAAC,uBAAX,CAAmC,OAAO,CAAC,MAAR,CAAe,CAAf,CAAnC,EAAsD,QAAtD;AACH;;AAED,WAAO,IAAP;AACH,GAjDM;AAmDP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,KAAd,EAA2B;AACvB,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,GAAG,CAAzB,EAA4B;AACxB,aAAO,IAAP;AACH;;AACD,QAAI,CAAC,GAAG,KAAK,GAAG,CAAhB;AACA,WAAO,IAAI,OAAJ,CAAY,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAAZ,EAA4B,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAA5B,EAA4C,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAA5C,EAA4D,KAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,CAA5D,CAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,KAAd,EAA6B,GAA7B,EAAyC;AACrC,WAAO,KAAK,gBAAL,CAAsB,KAAtB,EAA6B,GAAG,CAAC,CAAjC,EAAoC,GAAG,CAAC,CAAxC,EAA2C,GAAG,CAAC,CAA/C,EAAkD,GAAG,CAAC,CAAtD,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,MAAM,CAAC,SAAP,CAAiB,IAAjB,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,MAAtB,EAAoC;AAChC,IAAA,MAAM,CAAC,cAAP,CAAsB,IAAtB,EAA4B,MAA5B;AACA,WAAO,IAAP;AACH,GAHM;AAKP;;;;;;;;;;;AASO,EAAA,MAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,CAAvC,EAAkD,CAAlD,EAA6D,CAA7D,EAAwE,CAAxE,EAAiF;AAC7E,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,GAAG,CAAzB,EAA4B;AACxB,aAAO,IAAP;AACH;;AACD,QAAI,CAAC,GAAG,KAAK,GAAG,CAAhB;AACA,SAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,IAAiB,CAAjB;AACA,SAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,IAAiB,CAAjB;AACA,SAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,IAAiB,CAAjB;AACA,SAAK,EAAL,CAAQ,CAAC,GAAG,CAAZ,IAAiB,CAAjB;;AAEA,SAAK,cAAL;;AACA,WAAO,IAAP;AACH,GAZM;AAcP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B;AACtB,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,SAAK,UAAL,CAAgB,KAAhB,EAAuB,MAAvB;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,KAAlB,EAAiC,MAAjC,EAA+C;AAC3C,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,MAAM,CAAC,EAAP,CAAU,KAAV,IAAmB,KAAK,EAAL,CAAQ,KAAR,IAAiB,KAApC;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,MAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAAuC,MAAvC,EAAqD;AACjD,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,MAAM,CAAC,EAAP,CAAU,KAAV,KAAoB,KAAK,EAAL,CAAQ,KAAR,IAAiB,KAArC;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;;AACA,WAAO,IAAP;AACH,GANM;AAQP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,GAAtB,EAAiC;AAC7B,QAAM,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAZ;AACA,SAAK,WAAL,CAAiB,GAAjB;AACA,IAAA,GAAG,CAAC,cAAJ,CAAmB,GAAnB;AACA,QAAI,CAAC,GAAG,GAAG,CAAC,EAAZ;AACA,IAAA,MAAM,CAAC,eAAP,CACI,CAAC,CAAC,CAAD,CADL,EACU,CAAC,CAAC,CAAD,CADX,EACgB,CAAC,CAAC,CAAD,CADjB,EACsB,GADtB,EAEI,CAAC,CAAC,CAAD,CAFL,EAEU,CAAC,CAAC,CAAD,CAFX,EAEgB,CAAC,CAAC,CAAD,CAFjB,EAEsB,GAFtB,EAGI,CAAC,CAAC,CAAD,CAHL,EAGU,CAAC,CAAC,CAAD,CAHX,EAGgB,CAAC,CAAC,EAAD,CAHjB,EAGuB,GAHvB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,GALJ;AAOH,GAZM;AAcP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACI,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,SAAK,sBAAL,CAA4B,MAA5B;AACA,WAAO,MAAP;AACH,GAJM;AAMP;;;;;;;AAKO,EAAA,MAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,UAA8B,MAA9B,EAA4C;AACxC,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd;;AACA,QAAI,CAAC,KAAK,SAAL,CAAe,KAAf,CAAL,EAA4B;AACxB,MAAA,MAAM,CAAC,aAAP,CAAqB,MAArB;AACA,aAAO,IAAP;AACH;;AAED,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,QAAM,EAAE,GAAG,IAAI,KAAK,CAAC,EAArB;AAAA,QAAyB,EAAE,GAAG,IAAI,KAAK,CAAC,EAAxC;AAAA,QAA4C,EAAE,GAAG,IAAI,KAAK,CAAC,EAA3D;AACA,IAAA,MAAM,CAAC,eAAP,CACI,CAAC,CAAC,CAAD,CAAD,GAAO,EADX,EACe,CAAC,CAAC,CAAD,CAAD,GAAO,EADtB,EAC0B,CAAC,CAAC,CAAD,CAAD,GAAO,EADjC,EACqC,GADrC,EAEI,CAAC,CAAC,CAAD,CAAD,GAAO,EAFX,EAEe,CAAC,CAAC,CAAD,CAAD,GAAO,EAFtB,EAE0B,CAAC,CAAC,CAAD,CAAD,GAAO,EAFjC,EAEqC,GAFrC,EAGI,CAAC,CAAC,CAAD,CAAD,GAAO,EAHX,EAGe,CAAC,CAAC,CAAD,CAAD,GAAO,EAHtB,EAG0B,CAAC,CAAC,EAAD,CAAD,GAAQ,EAHlC,EAGsC,GAHtC,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;AAOA,WAAO,IAAP;AACH,GAjBM;AAmBP;;;;;AAGO,EAAA,MAAA,CAAA,SAAA,CAAA,4BAAA,GAAP,YAAA;AACI,QAAM,CAAC,GAAG,KAAK,EAAf;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;;AACA,SAAK,cAAL;AACH,GARM;AAUP;;;;;AAGO,EAAA,MAAA,CAAA,SAAA,CAAA,iCAAA,GAAP,YAAA;AACI,QAAI,CAAC,GAAG,KAAK,EAAb;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAT;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,IAAS,CAAC,CAAV;;AACA,SAAK,cAAL;AACH,GAPM,CAlyBX,CA2yBI;;AACA;;;;;;;;AAMc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAiE,MAAjE,EAAmF;AAAlB,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAA;AAAkB;;AAC/E,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA6B,MAA7B,EAAqC,MAArC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAAsE,MAAtE,EAAsF,MAAtF,EAAoG;AAChG,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,MAAM,CAAC,EAAP,CAAU,KAAV,IAAmB,KAAK,CAAC,KAAK,GAAG,MAAT,CAAxB;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;AACH,GALa;AAOd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,2BAAA,GAAd,UAA0C,KAA1C,EAA8F,MAA9F,EAA8G,KAA9G,EAA6H,MAA7H,EAA2I;AACvI,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,MAAM,CAAC,EAAP,CAAU,KAAV,IAAmB,KAAK,CAAC,KAAK,GAAG,MAAT,CAAL,GAAwB,KAA3C;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;AACH,GALa;;AAUd,EAAA,MAAA,CAAA,cAAA,CAAkB,MAAlB,EAAkB,kBAAlB,EAAkC;AAHlC;;;SAGA,YAAA;AACI,aAAO,MAAM,CAAC,iBAAd;AACH,KAFiC;qBAAA;;AAAA,GAAlC;AAIA;;;;;;;;;;;;;;;;;;;;;AAoBc,EAAA,MAAA,CAAA,eAAA,GAAd,UAA8B,UAA9B,EAAkD,UAAlD,EAAsE,UAAtE,EAA0F,UAA1F,EACI,UADJ,EACwB,UADxB,EAC4C,UAD5C,EACgE,UADhE,EAEI,UAFJ,EAEwB,UAFxB,EAE4C,UAF5C,EAEgE,UAFhE,EAGI,UAHJ,EAGwB,UAHxB,EAG4C,UAH5C,EAGgE,UAHhE,EAGoF,MAHpF,EAGkG;AAE9F,QAAM,CAAC,GAAG,MAAM,CAAC,EAAjB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AACzD,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AACzD,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAC1D,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;;AAE5D,IAAA,MAAM,CAAC,cAAP;AACH,GAZa;AAcd;;;;;;;;;;;;;;;;;;;;;;AAoBc,EAAA,MAAA,CAAA,UAAA,GAAd,UAAyB,UAAzB,EAA6C,UAA7C,EAAiE,UAAjE,EAAqF,UAArF,EACI,UADJ,EACwB,UADxB,EAC4C,UAD5C,EACgE,UADhE,EAEI,UAFJ,EAEwB,UAFxB,EAE4C,UAF5C,EAEgE,UAFhE,EAGI,UAHJ,EAGwB,UAHxB,EAG4C,UAH5C,EAGgE,UAHhE,EAGkF;AAE9E,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,QAAM,CAAC,GAAG,MAAM,CAAC,EAAjB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AACzD,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AACzD,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,UAAP;AAAmB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAC1D,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;AAAoB,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,UAAR;;AAC5D,IAAA,MAAM,CAAC,cAAP;;AACA,WAAO,MAAP;AACH,GAba;AAed;;;;;;;;;AAOc,EAAA,MAAA,CAAA,OAAA,GAAd,UAAsB,KAAtB,EAAqD,QAArD,EAA0F,WAA1F,EAA6H;AACzH,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,KAApB,EAA2B,QAA3B,EAAqC,WAArC,EAAkD,MAAlD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,YAAA,GAAd,UAA2B,KAA3B,EAA0D,QAA1D,EAA+F,WAA/F,EAAoI,MAApI,EAAkJ;AAC9I,QAAI,CAAC,GAAG,MAAM,CAAC,EAAf;AACA,QAAI,CAAC,GAAG,QAAQ,CAAC,EAAjB;AAAA,QAAqB,CAAC,GAAG,QAAQ,CAAC,EAAlC;AAAA,QAAsC,CAAC,GAAG,QAAQ,CAAC,EAAnD;AAAA,QAAuD,CAAC,GAAG,QAAQ,CAAC,EAApE;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,CAAb;AAAA,QAAgB,EAAE,GAAG,CAAC,GAAG,CAAzB;AAAA,QAA4B,EAAE,GAAG,CAAC,GAAG,CAArC;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,EAAb;AAAA,QAAiB,EAAE,GAAG,CAAC,GAAG,EAA1B;AAAA,QAA8B,EAAE,GAAG,CAAC,GAAG,EAAvC;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,EAAb;AAAA,QAAiB,EAAE,GAAG,CAAC,GAAG,EAA1B;AAAA,QAA8B,EAAE,GAAG,CAAC,GAAG,EAAvC;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,EAAb;AAAA,QAAiB,EAAE,GAAG,CAAC,GAAG,EAA1B;AAAA,QAA8B,EAAE,GAAG,CAAC,GAAG,EAAvC;AAEA,QAAI,EAAE,GAAG,KAAK,CAAC,EAAf;AAAA,QAAmB,EAAE,GAAG,KAAK,CAAC,EAA9B;AAAA,QAAkC,EAAE,GAAG,KAAK,CAAC,EAA7C;AAEA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,KAAK,EAAE,GAAG,EAAV,CAAD,IAAkB,EAAzB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAEA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,KAAK,EAAE,GAAG,EAAV,CAAD,IAAkB,EAAzB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAEA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,EAAE,GAAG,EAAN,IAAY,EAAnB;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,KAAK,EAAE,GAAG,EAAV,CAAD,IAAkB,EAA1B;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAEA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,WAAW,CAAC,EAApB;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,WAAW,CAAC,EAApB;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,WAAW,CAAC,EAApB;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;;AAEA,IAAA,MAAM,CAAC,cAAP;AACH,GA/Ba;AAiCd;;;;;;AAIc,EAAA,MAAA,CAAA,QAAA,GAAd,YAAA;AACI,QAAM,QAAQ,GAAG,MAAM,CAAC,UAAP,CACb,GADa,EACR,GADQ,EACH,GADG,EACE,GADF,EAEb,GAFa,EAER,GAFQ,EAEH,GAFG,EAEE,GAFF,EAGb,GAHa,EAGR,GAHQ,EAGH,GAHG,EAGE,GAHF,EAIb,GAJa,EAIR,GAJQ,EAIH,GAJG,EAIE,GAJF,CAAjB;;AAKA,IAAA,QAAQ,CAAC,qBAAT,CAA+B,IAA/B;;AACA,WAAO,QAAP;AACH,GARa;AAUd;;;;;;AAIc,EAAA,MAAA,CAAA,aAAA,GAAd,UAA4B,MAA5B,EAA0C;AACtC,IAAA,MAAM,CAAC,eAAP,CACI,GADJ,EACS,GADT,EACc,GADd,EACmB,GADnB,EAEI,GAFJ,EAES,GAFT,EAEc,GAFd,EAEmB,GAFnB,EAGI,GAHJ,EAGS,GAHT,EAGc,GAHd,EAGmB,GAHnB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAOA,IAAA,MAAM,CAAC,qBAAP,CAA6B,IAA7B;AACH,GATa;AAWd;;;;;;AAIc,EAAA,MAAA,CAAA,IAAA,GAAd,YAAA;AACI,QAAM,IAAI,GAAG,MAAM,CAAC,UAAP,CACT,GADS,EACJ,GADI,EACC,GADD,EACM,GADN,EAET,GAFS,EAEJ,GAFI,EAEC,GAFD,EAEM,GAFN,EAGT,GAHS,EAGJ,GAHI,EAGC,GAHD,EAGM,GAHN,EAIT,GAJS,EAIJ,GAJI,EAIC,GAJD,EAIM,GAJN,CAAb;;AAKA,IAAA,IAAI,CAAC,qBAAL,CAA2B,KAA3B;;AACA,WAAO,IAAP;AACH,GARa;AAUd;;;;;;;AAKc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAqC;AACjC,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA6B,MAA7B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,MAAA,GAAd,UAAqB,MAArB,EAAkD;AAC9C,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,WAAP,CAAmB,MAAnB;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAA4C,MAA5C,EAA0D;AACtD,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,IAAA,MAAM,CAAC,eAAP,CACI,GADJ,EACS,GADT,EACc,GADd,EACmB,GADnB,EAEI,GAFJ,EAES,CAFT,EAEY,CAFZ,EAEe,GAFf,EAGI,GAHJ,EAGS,CAAC,CAHV,EAGa,CAHb,EAGgB,GAHhB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAA9C;AACH,GAZa;AAcd;;;;;;;AAKc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAqC;AACjC,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA6B,MAA7B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAA4C,MAA5C,EAA0D;AACtD,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,CAAC,CADb,EACgB,GADhB,EAEI,GAFJ,EAES,GAFT,EAEc,GAFd,EAEmB,GAFnB,EAGI,CAHJ,EAGO,GAHP,EAGY,CAHZ,EAGe,GAHf,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAA9C;AACH,GAZa;AAcd;;;;;;;AAKc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,KAAxB,EAAqC;AACjC,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA6B,MAA7B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,KAA7B,EAA4C,MAA5C,EAA0D;AACtD,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,CAAR;AACA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,CADP,EACU,GADV,EACe,GADf,EAEI,CAAC,CAFL,EAEQ,CAFR,EAEW,GAFX,EAEgB,GAFhB,EAGI,GAHJ,EAGS,GAHT,EAGc,GAHd,EAGmB,GAHnB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAA9C;AACH,GAZa;AAcd;;;;;;;;AAMc,EAAA,MAAA,CAAA,YAAA,GAAd,UAA2B,IAA3B,EAAyD,KAAzD,EAAsE;AAClE,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,iBAAP,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,MAAtC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;AAMc,EAAA,MAAA,CAAA,iBAAA,GAAd,UAAgC,IAAhC,EAA8D,KAA9D,EAA6E,MAA7E,EAA2F;AACvF,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,KAAV,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,KAAV,CAAR;AACA,QAAI,EAAE,GAAG,IAAI,CAAb;AAEA,IAAA,IAAI,CAAC,SAAL;AACA,QAAM,CAAC,GAAG,MAAM,CAAC,EAAjB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA2B,CAAlC;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,GAAP;AAEA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA2B,CAAlC;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,GAAP;AAEA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA4B,IAAI,CAAC,EAAL,GAAU,CAA7C;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAS,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAhB,GAAsB,EAAtB,GAA2B,CAAnC;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AAEA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAR;;AAEA,IAAA,MAAM,CAAC,cAAP;AACH,GA5Ba;AA8Bd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,kBAAA,GAAd,UAAiC,IAAjC,EAA+D,EAA/D,EAA2F,MAA3F,EAAyG;AACrG,QAAM,CAAC,GAAG,OAAO,CAAC,KAAR,CAAc,EAAd,EAAkB,IAAlB,CAAV;AACA,QAAM,CAAC,GAAG,OAAO,CAAC,GAAR,CAAY,EAAZ,EAAgB,IAAhB,CAAV;AACA,QAAM,CAAC,GAAG,KAAK,IAAI,CAAT,CAAV;AAEA,QAAM,CAAC,GAAG,MAAM,CAAC,EAAjB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAzB;AAA4B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAC1F,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAzB;AAA4B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AAC1F,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAAC,CAAC,EAA3B;AAA+B,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,CAAC,EAAF,GAAO,CAAC,CAAC,EAAT,GAAc,CAAd,GAAkB,CAA1B;AAA6B,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAC3F,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAAW,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAAW,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;AAAW,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAR;;AAEjC,IAAA,MAAM,CAAC,cAAP;AACH,GAZa;AAcd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,oBAAA,GAAd,UAAmC,GAAnC,EAAgD,KAAhD,EAA+D,IAA/D,EAA2E;AACvE,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,yBAAP,CAAiC,GAAjC,EAAsC,KAAtC,EAA6C,IAA7C,EAAmD,MAAnD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,yBAAA,GAAd,UAAwC,GAAxC,EAAqD,KAArD,EAAoE,IAApE,EAAkF,MAAlF,EAAgG;AAC5F,IAAA,UAAU,CAAC,yBAAX,CAAqC,GAArC,EAA0C,KAA1C,EAAiD,IAAjD,EAAuD,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAAvD;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,CAAnB,EAAsB,gBAAtB,CAAuC,MAAvC;AACH,GAHa;AAKd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,OAAA,GAAd,UAAsB,CAAtB,EAAiC,CAAjC,EAA4C,CAA5C,EAAqD;AACjD,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,MAA7B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,YAAA,GAAd,UAA2B,CAA3B,EAAsC,CAAtC,EAAiD,CAAjD,EAA4D,MAA5D,EAA0E;AACtE,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,GAHjB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAjB,IAAsB,CAAC,KAAK,CAAzD;AACH,GAVa;AAYd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,WAAA,GAAd,UAA0B,CAA1B,EAAqC,CAArC,EAAgD,CAAhD,EAAyD;AACrD,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,gBAAP,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,MAAjC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,CAA/B,EAA0C,CAA1C,EAAqD,CAArD,EAAgE,MAAhE,EAA8E;AAC1E,IAAA,MAAM,CAAC,eAAP,CACI,GADJ,EACS,GADT,EACc,GADd,EACmB,GADnB,EAEI,GAFJ,EAES,GAFT,EAEc,GAFd,EAEmB,GAFnB,EAGI,GAHJ,EAGS,GAHT,EAGc,GAHd,EAGmB,GAHnB,EAII,CAJJ,EAIO,CAJP,EAIU,CAJV,EAIa,GAJb,EAKI,MALJ;;AAOA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAjB,IAAsB,CAAC,KAAK,CAAzD;AACH,GATa;AAWd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,IAAA,GAAd,UAAmB,UAAnB,EAAsD,QAAtD,EAAuF,QAAvF,EAAuG;AACnG,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,SAAP,CAAiB,UAAjB,EAA6B,QAA7B,EAAuC,QAAvC,EAAiD,MAAjD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,UAAxB,EAA2D,QAA3D,EAA4F,QAA5F,EAA8G,MAA9G,EAA4H;AACxH,QAAM,OAAO,GAAG,MAAM,CAAC,EAAvB;AACA,QAAM,MAAM,GAAG,UAAU,CAAC,CAA1B;AACA,QAAM,IAAI,GAAG,QAAQ,CAAC,CAAtB;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,EAA5B,EAAgC,KAAK,EAArC,EAAyC;AACrC,MAAA,OAAO,CAAC,KAAD,CAAP,GAAiB,MAAM,CAAC,KAAD,CAAN,IAAiB,MAAM,QAAvB,IAAmC,IAAI,CAAC,KAAD,CAAJ,GAAc,QAAlE;AACH;;AACD,IAAA,MAAM,CAAC,cAAP;AACH,GARa;AAUd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,aAAA,GAAd,UAA4B,UAA5B,EAA+D,QAA/D,EAAgG,QAAhG,EAAgH;AAC5G,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,kBAAP,CAA0B,UAA1B,EAAsC,QAAtC,EAAgD,QAAhD,EAA0D,MAA1D;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,kBAAA,GAAd,UAAiC,UAAjC,EAAoE,QAApE,EAAqG,QAArG,EAAuH,MAAvH,EAAqI;AACjI,QAAI,UAAU,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAjB;AACA,QAAI,aAAa,GAAG,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAApB;AACA,QAAI,gBAAgB,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAvB;AACA,IAAA,UAAU,CAAC,SAAX,CAAqB,UAArB,EAAiC,aAAjC,EAAgD,gBAAhD;AAEA,QAAI,QAAQ,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAf;AACA,QAAI,WAAW,GAAG,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAAlB;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAArB;AACA,IAAA,QAAQ,CAAC,SAAT,CAAmB,QAAnB,EAA6B,WAA7B,EAA0C,cAA1C;AAEA,QAAI,WAAW,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAlB;AACA,IAAA,OAAO,CAAC,SAAR,CAAkB,UAAlB,EAA8B,QAA9B,EAAwC,QAAxC,EAAkD,WAAlD;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,UAAR,CAAmB,CAAnB,CAArB;AACA,IAAA,UAAU,CAAC,UAAX,CAAsB,aAAtB,EAAqC,WAArC,EAAkD,QAAlD,EAA4D,cAA5D;AAEA,QAAI,iBAAiB,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAxB;AACA,IAAA,OAAO,CAAC,SAAR,CAAkB,gBAAlB,EAAoC,cAApC,EAAoD,QAApD,EAA8D,iBAA9D;AAEA,IAAA,MAAM,CAAC,YAAP,CAAoB,WAApB,EAAiC,cAAjC,EAAiD,iBAAjD,EAAoE,MAApE;AACH,GApBa;AAsBd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,QAAA,GAAd,UAAuB,GAAvB,EAAoD,MAApD,EAAoF,EAApF,EAA8G;AAC1G,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,MAA1B,EAAkC,EAAlC,EAAsC,MAAtC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,aAAA,GAAd,UAA4B,GAA5B,EAAyD,MAAzD,EAAyF,EAAzF,EAAqH,MAArH,EAAmI;AAC/H,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd,CAH+H,CAK/H;;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,KAA1B;AACA,IAAA,KAAK,CAAC,SAAN,GAP+H,CAS/H;;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,EAAnB,EAAuB,KAAvB,EAA8B,KAA9B;AAEA,QAAM,aAAa,GAAG,KAAK,CAAC,aAAN,EAAtB;;AACA,QAAI,aAAa,KAAK,CAAtB,EAAyB;AACrB,MAAA,KAAK,CAAC,CAAN,GAAU,GAAV;AACH,KAFD,MAEO;AACH,MAAA,KAAK,CAAC,mBAAN,CAA0B,IAAI,CAAC,IAAL,CAAU,aAAV,CAA1B;AACH,KAjB8H,CAmB/H;;;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,KAAnB,EAA0B,KAA1B,EAAiC,KAAjC;AACA,IAAA,KAAK,CAAC,SAAN,GArB+H,CAuB/H;;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,KAAK,CAAC,EADV,EACc,KAAK,CAAC,EADpB,EACwB,KAAK,CAAC,EAD9B,EACkC,GADlC,EAEI,KAAK,CAAC,EAFV,EAEc,KAAK,CAAC,EAFpB,EAEwB,KAAK,CAAC,EAF9B,EAEkC,GAFlC,EAGI,KAAK,CAAC,EAHV,EAGc,KAAK,CAAC,EAHpB,EAGwB,KAAK,CAAC,EAH9B,EAGkC,GAHlC,EAII,EAJJ,EAIQ,EAJR,EAIY,EAJZ,EAIgB,GAJhB,EAKI,MALJ;AAOH,GAnCa;AAqCd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,QAAA,GAAd,UAAuB,GAAvB,EAAoD,MAApD,EAAoF,EAApF,EAA8G;AAC1G,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,GAArB,EAA0B,MAA1B,EAAkC,EAAlC,EAAsC,MAAtC;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,aAAA,GAAd,UAA4B,GAA5B,EAAyD,MAAzD,EAAyF,EAAzF,EAAqH,MAArH,EAAmI;AAC/H,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd;AACA,QAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,CAAhB,CAAd,CAH+H,CAK/H;;AACA,IAAA,GAAG,CAAC,aAAJ,CAAkB,MAAlB,EAA0B,KAA1B;AACA,IAAA,KAAK,CAAC,SAAN,GAP+H,CAS/H;;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,EAAnB,EAAuB,KAAvB,EAA8B,KAA9B;AAEA,QAAM,aAAa,GAAG,KAAK,CAAC,aAAN,EAAtB;;AACA,QAAI,aAAa,KAAK,CAAtB,EAAyB;AACrB,MAAA,KAAK,CAAC,CAAN,GAAU,GAAV;AACH,KAFD,MAEO;AACH,MAAA,KAAK,CAAC,mBAAN,CAA0B,IAAI,CAAC,IAAL,CAAU,aAAV,CAA1B;AACH,KAjB8H,CAmB/H;;;AACA,IAAA,OAAO,CAAC,UAAR,CAAmB,KAAnB,EAA0B,KAA1B,EAAiC,KAAjC;AACA,IAAA,KAAK,CAAC,SAAN,GArB+H,CAuB/H;;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AACA,QAAI,EAAE,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,KAAZ,EAAmB,GAAnB,CAAV;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,KAAK,CAAC,EADV,EACc,KAAK,CAAC,EADpB,EACwB,KAAK,CAAC,EAD9B,EACkC,GADlC,EAEI,KAAK,CAAC,EAFV,EAEc,KAAK,CAAC,EAFpB,EAEwB,KAAK,CAAC,EAF9B,EAEkC,GAFlC,EAGI,KAAK,CAAC,EAHV,EAGc,KAAK,CAAC,EAHpB,EAGwB,KAAK,CAAC,EAH9B,EAGkC,GAHlC,EAII,EAJJ,EAIQ,EAJR,EAIY,EAJZ,EAIgB,GAJhB,EAKI,MALJ;AAOH,GAnCa;AAqCd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,OAAA,GAAd,UAAsB,KAAtB,EAAqC,MAArC,EAAqD,KAArD,EAAoE,IAApE,EAAgF;AAC5E,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,KAApB,EAA2B,MAA3B,EAAmC,KAAnC,EAA0C,IAA1C,EAAgD,MAAhD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,YAAA,GAAd,UAA2B,KAA3B,EAA0C,MAA1C,EAA0D,KAA1D,EAAyE,IAAzE,EAAuF,MAAvF,EAAqG;AACjG,QAAI,CAAC,GAAG,KAAR;AACA,QAAI,CAAC,GAAG,IAAR;AAEA,QAAI,CAAC,GAAG,MAAM,KAAd;AACA,QAAI,CAAC,GAAG,MAAM,MAAd;AACA,QAAI,CAAC,GAAG,OAAO,CAAC,GAAG,CAAX,CAAR;AACA,QAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAN,KAAY,CAAC,GAAG,CAAhB,CAAR;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,GAHjB,EAII,GAJJ,EAIS,GAJT,EAIc,CAJd,EAIiB,GAJjB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,CAAjB,IAAsB,CAAC,KAAK,CAA5B,IAAiC,CAAC,KAAK,CAApE;AACH,GAlBa;AAoBd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,IAA/B,EAA6C,KAA7C,EAA4D,MAA5D,EAA4E,GAA5E,EAAyF,KAAzF,EAAwG,IAAxG,EAAoH;AAChH,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,qBAAP,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C,MAA1C,EAAkD,GAAlD,EAAuD,KAAvD,EAA8D,IAA9D,EAAoE,MAApE;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,qBAAA,GAAd,UAAoC,IAApC,EAAkD,KAAlD,EAAiE,MAAjE,EAAiF,GAAjF,EAA8F,KAA9F,EAA6G,IAA7G,EAA2H,MAA3H,EAAyI;AACrI,QAAI,CAAC,GAAG,KAAR;AACA,QAAI,CAAC,GAAG,IAAR;AAEA,QAAI,CAAC,GAAG,OAAO,KAAK,GAAG,IAAf,CAAR;AACA,QAAI,CAAC,GAAG,OAAO,GAAG,GAAG,MAAb,CAAR;AACA,QAAI,CAAC,GAAG,OAAO,CAAC,GAAG,CAAX,CAAR;AACA,QAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAN,KAAY,CAAC,GAAG,CAAhB,CAAR;AACA,QAAI,EAAE,GAAG,CAAC,IAAI,GAAG,KAAR,KAAkB,IAAI,GAAG,KAAzB,CAAT;AACA,QAAI,EAAE,GAAG,CAAC,GAAG,GAAG,MAAP,KAAkB,MAAM,GAAG,GAA3B,CAAT;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,GAHjB,EAII,EAJJ,EAIQ,EAJR,EAIY,CAJZ,EAIe,GAJf,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,cAAP;AACH,GApBa;AAsBd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,IAA/B,EAA6C,KAA7C,EAA4D,MAA5D,EAA4E,GAA5E,EAAyF,KAAzF,EAAwG,IAAxG,EAAoH;AAChH,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,qBAAP,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C,MAA1C,EAAkD,GAAlD,EAAuD,KAAvD,EAA8D,IAA9D,EAAoE,MAApE;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,qBAAA,GAAd,UAAoC,IAApC,EAAkD,KAAlD,EAAiE,MAAjE,EAAiF,GAAjF,EAA8F,KAA9F,EAA6G,IAA7G,EAA2H,MAA3H,EAAyI;AACrI,IAAA,MAAM,CAAC,qBAAP,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C,MAA1C,EAAkD,GAAlD,EAAuD,KAAvD,EAA8D,IAA9D,EAAoE,MAApE;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,KAAiB,CAAC,CAAlB,CAFqI,CAEhH;AACxB,GAHa;AAKd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,aAAA,GAAd,UAA4B,KAA5B,EAA2C,MAA3C,EAA2D,KAA3D,EAA0E,IAA1E,EAAsF;AAClF,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AAEA,QAAI,CAAC,GAAG,KAAR;AACA,QAAI,CAAC,GAAG,IAAR;AAEA,QAAI,CAAC,GAAG,MAAM,CAAN,GAAU,KAAlB;AACA,QAAI,CAAC,GAAG,MAAM,CAAN,GAAU,MAAlB;AACA,QAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAL,KAAW,CAAC,GAAG,CAAf,CAAR;AACA,QAAI,CAAC,GAAG,CAAC,GAAD,GAAO,CAAP,GAAW,CAAX,IAAgB,CAAC,GAAG,CAApB,CAAR;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,GAHjB,EAII,GAJJ,EAIS,GAJT,EAIc,CAJd,EAIiB,GAJjB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,KAA7B;;AACA,WAAO,MAAP;AACH,GArBa;AAuBd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,GAA/B,EAA4C,MAA5C,EAA4D,KAA5D,EAA2E,IAA3E,EAAuF;AACnF,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,qBAAP,CAA6B,GAA7B,EAAkC,MAAlC,EAA0C,KAA1C,EAAiD,IAAjD,EAAuD,MAAvD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;AASc,EAAA,MAAA,CAAA,qBAAA,GAAd,UAAoC,GAApC,EAAiD,MAAjD,EAAiE,KAAjE,EAAgF,IAAhF,EAA8F,MAA9F,EAA8G,kBAA9G,EAAuI;AAAzB,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,IAAA;AAAyB;;AACnI,QAAI,CAAC,GAAG,KAAR;AACA,QAAI,CAAC,GAAG,IAAR;AAEA,QAAI,CAAC,GAAG,MAAO,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,GAAf,CAAf;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAI,CAAC,GAAG,MAAR,GAAkB,CAA5C;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAG,CAAH,GAAQ,CAAC,GAAG,MAAtC;AACA,QAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAL,KAAW,CAAC,GAAG,CAAf,CAAR;AACA,QAAI,CAAC,GAAG,CAAC,GAAD,GAAO,CAAP,GAAW,CAAX,IAAgB,CAAC,GAAG,CAApB,CAAR;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,GAHjB,EAII,GAJJ,EAIS,GAJT,EAIc,CAJd,EAIiB,GAJjB,EAKI,MALJ;;AAOA,IAAA,MAAM,CAAC,qBAAP,CAA6B,KAA7B;AACH,GAlBa;AAoBd;;;;;;;;;;;AASc,EAAA,MAAA,CAAA,4BAAA,GAAd,UAA2C,GAA3C,EAAwD,MAAxD,EAAwE,KAAxE,EAAuF,IAAvF,EAAqG,MAArG,EAAqH,kBAArH,EAA8I;AAAzB,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,IAAA;AAAyB;;AAC1I,QAAI,CAAC,GAAG,MAAO,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,GAAf,CAAf;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAI,CAAC,GAAG,MAAR,GAAkB,CAA5C;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAG,CAAH,GAAQ,CAAC,GAAG,MAAtC;AACA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAAC,KAHf,EAGsB,GAHtB,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;;AAOA,IAAA,MAAM,CAAC,qBAAP,CAA6B,KAA7B;AACH,GAZa;AAcd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,GAA/B,EAA4C,MAA5C,EAA4D,KAA5D,EAA2E,IAA3E,EAAuF;AACnF,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,qBAAP,CAA6B,GAA7B,EAAkC,MAAlC,EAA0C,KAA1C,EAAiD,IAAjD,EAAuD,MAAvD;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;;;;;AASc,EAAA,MAAA,CAAA,qBAAA,GAAd,UAAoC,GAApC,EAAiD,MAAjD,EAAiE,KAAjE,EAAgF,IAAhF,EAA8F,MAA9F,EAA8G,kBAA9G,EAAuI;AACnI;AACA;AACA;AACA;AAJ0G,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,IAAA;AAAyB;;AAMnI,QAAI,CAAC,GAAG,KAAR;AACA,QAAI,CAAC,GAAG,IAAR;AAEA,QAAI,CAAC,GAAG,MAAO,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,GAAf,CAAf;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAI,CAAC,GAAG,MAAR,GAAkB,CAA5C;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAG,CAAH,GAAQ,CAAC,GAAG,MAAtC;AACA,QAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAN,KAAY,CAAC,GAAG,CAAhB,CAAR;AACA,QAAI,CAAC,GAAG,CAAC,CAAD,GAAK,CAAL,GAAS,CAAT,IAAc,CAAC,GAAG,CAAlB,CAAR;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAHd,EAGiB,CAAC,GAHlB,EAII,GAJJ,EAIS,GAJT,EAIc,CAJd,EAIiB,GAJjB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,KAA7B;AACH,GAxBa;AA0Bd;;;;;;;;;;;AASc,EAAA,MAAA,CAAA,4BAAA,GAAd,UAA2C,GAA3C,EAAwD,MAAxD,EAAwE,KAAxE,EAAuF,IAAvF,EAAqG,MAArG,EAAqH,kBAArH,EAA8I;AAC1I;AACA;AACA;AACA;AAJiH,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,IAAA;AAAyB;;AAM1I,QAAI,CAAC,GAAG,MAAO,IAAI,CAAC,GAAL,CAAS,GAAG,GAAG,GAAf,CAAf;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAI,CAAC,GAAG,MAAR,GAAkB,CAA5C;AACA,QAAI,CAAC,GAAG,kBAAkB,GAAG,CAAH,GAAQ,CAAC,GAAG,MAAtC;AAEA,IAAA,MAAM,CAAC,eAAP,CACI,CADJ,EACO,GADP,EACY,GADZ,EACiB,GADjB,EAEI,GAFJ,EAES,CAFT,EAEY,GAFZ,EAEiB,GAFjB,EAGI,GAHJ,EAGS,GAHT,EAGc,CAAC,KAHf,EAGsB,CAAC,GAHvB,EAII,GAJJ,EAIS,GAJT,EAIc,CAAC,GAJf,EAIoB,GAJpB,EAKI,MALJ;;AAQA,IAAA,MAAM,CAAC,qBAAP,CAA6B,KAA7B;AACH,GAnBa;AAqBd;;;;;;;;;;AAQc,EAAA,MAAA,CAAA,wBAAA,GAAd,UAAuC,GAAvC,EAAmI,KAAnI,EAAkJ,IAAlJ,EAAgK,MAAhK,EAAgL,WAAhL,EAAmM;AAAnB,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,KAAA;AAAmB;;AAE/L,QAAI,iBAAiB,GAAG,WAAW,GAAG,CAAC,CAAJ,GAAQ,CAA3C;AAEA,QAAI,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,CAAC,SAAJ,GAAgB,IAAI,CAAC,EAArB,GAA0B,KAAnC,CAAZ;AACA,QAAI,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,CAAC,WAAJ,GAAkB,IAAI,CAAC,EAAvB,GAA4B,KAArC,CAAd;AACA,QAAI,OAAO,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,CAAC,WAAJ,GAAkB,IAAI,CAAC,EAAvB,GAA4B,KAArC,CAAd;AACA,QAAI,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,GAAG,CAAC,YAAJ,GAAmB,IAAI,CAAC,EAAxB,GAA6B,KAAtC,CAAf;AACA,QAAI,MAAM,GAAG,OAAO,OAAO,GAAG,QAAjB,CAAb;AACA,QAAI,MAAM,GAAG,OAAO,KAAK,GAAG,OAAf,CAAb;AACA,QAAM,CAAC,GAAG,MAAM,CAAC,EAAjB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,MAAP;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAD,GAAO,GAA5B;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,MAAP;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAC,CAAC,CAAD,CAAD,GAAO,GAAd;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAQ,CAAC,OAAO,GAAG,QAAX,IAAuB,MAAvB,GAAgC,GAAxC;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,EAAE,CAAC,KAAK,GAAG,OAAT,IAAoB,MAApB,GAA6B,GAA/B,CAAP;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,IAAD,IAAS,KAAK,GAAG,IAAjB,CAAR;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,MAAM,iBAAd;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,CAAC,EAAD,CAAD,GAAQ,CAAC,CAAC,EAAD,CAAD,GAAQ,GAAxB;AACA,IAAA,CAAC,CAAC,EAAD,CAAD,GAAQ,EAAE,MAAM,IAAN,GAAa,KAAf,KAAyB,IAAI,GAAG,KAAhC,CAAR;;AAEA,IAAA,MAAM,CAAC,cAAP;AACH,GAvBa;AAyBd;;;;;;;;;;;;AAUc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,QAA7B,EAAgE,KAAhE,EAA8F,IAA9F,EAA2H,UAA3H,EAA8J,IAA9J,EAA4K,IAA5K,EAAwL;AACpL,QAAI,EAAE,GAAG,QAAQ,CAAC,KAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,MAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,CAAlB;AACA,QAAI,EAAE,GAAG,QAAQ,CAAC,CAAlB;AAEA,QAAI,cAAc,GAAG,MAAM,CAAC,UAAP,CACjB,EAAE,GAAG,GADY,EACP,GADO,EACF,GADE,EACG,GADH,EAEjB,GAFiB,EAEZ,CAAC,EAAD,GAAM,GAFM,EAED,GAFC,EAEI,GAFJ,EAGjB,GAHiB,EAGZ,GAHY,EAGP,IAAI,GAAG,IAHA,EAGM,GAHN,EAIjB,EAAE,GAAG,EAAE,GAAG,GAJO,EAIF,EAAE,GAAG,GAAL,GAAW,EAJT,EAIa,IAJb,EAImB,GAJnB,CAArB;AAMA,QAAI,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,CAAf,CAAb;AACA,IAAA,KAAK,CAAC,aAAN,CAAoB,IAApB,EAA0B,MAA1B;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,UAArB,EAAiC,MAAjC;AACA,WAAO,MAAM,CAAC,QAAP,CAAgB,cAAhB,CAAP;AACH,GAhBa;AAkBd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA0D;AACtD,QAAM,CAAC,GAAG,MAAM,CAAC,CAAjB;AACA,QAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,EAAa,CAAC,CAAC,CAAD,CAAd,EAAmB,CAAC,CAAC,CAAD,CAApB,CAAZ;AACA,WAAO,uBAAuB,CAAC,eAAxB,GAA0C,GAA1C,GAAgD,IAAI,YAAJ,CAAiB,GAAjB,CAAvD;AACH,GAJa;AAKd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA0D;AACtD,QAAM,CAAC,GAAG,MAAM,CAAC,CAAjB;AACA,QAAM,GAAG,GAAG,CACR,CAAC,CAAC,CAAD,CADO,EACF,CAAC,CAAC,CAAD,CADC,EACI,CAAC,CAAC,CAAD,CADL,EAER,CAAC,CAAC,CAAD,CAFO,EAEF,CAAC,CAAC,CAAD,CAFC,EAEI,CAAC,CAAC,CAAD,CAFL,EAGR,CAAC,CAAC,CAAD,CAHO,EAGF,CAAC,CAAC,CAAD,CAHC,EAGI,CAAC,CAAC,EAAD,CAHL,CAAZ;AAKA,WAAO,uBAAuB,CAAC,eAAxB,GAA0C,GAA1C,GAAgD,IAAI,YAAJ,CAAiB,GAAjB,CAAvD;AACH,GARa;AAUd;;;;;;;AAKc,EAAA,MAAA,CAAA,SAAA,GAAd,UAAwB,MAAxB,EAAqD;AACjD,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,MAA9B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,cAAA,GAAd,UAA6B,MAA7B,EAA4D,MAA5D,EAA0E;AACtE,QAAM,EAAE,GAAG,MAAM,CAAC,EAAlB;AACA,QAAM,EAAE,GAAG,MAAM,CAAC,CAAlB;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,EAAD,CAAV;AAEA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,EAAD,CAAV;AAEA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAV;AACA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,EAAD,CAAX;AACA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,EAAD,CAAX;AAEA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,CAAD,CAAX;AACA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,CAAD,CAAX;AACA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,EAAD,CAAX;AACA,IAAA,EAAE,CAAC,EAAD,CAAF,GAAS,EAAE,CAAC,EAAD,CAAX,CArBsE,CAsBtE;;AACA,IAAA,MAAM,CAAC,qBAAP,CAA8B,MAAiB,CAAC,WAAhD,EAA8D,MAAiB,CAAC,gBAAhF;AACH,GAxBa;AA0Bd;;;;;;;AAKc,EAAA,MAAA,CAAA,UAAA,GAAd,UAAyB,KAAzB,EAAyD;AACrD,QAAI,MAAM,GAAG,IAAI,MAAJ,EAAb;AACA,IAAA,MAAM,CAAC,eAAP,CAAuB,KAAvB,EAA8B,MAA9B;AACA,WAAO,MAAP;AACH,GAJa;AAMd;;;;;;;AAKc,EAAA,MAAA,CAAA,eAAA,GAAd,UAA8B,KAA9B,EAAgE,MAAhE,EAA8E;AAC1E,IAAA,KAAK,CAAC,SAAN;AACA,QAAI,CAAC,GAAG,KAAK,CAAC,MAAN,CAAa,CAArB;AACA,QAAI,CAAC,GAAG,KAAK,CAAC,MAAN,CAAa,CAArB;AACA,QAAI,CAAC,GAAG,KAAK,CAAC,MAAN,CAAa,CAArB;AACA,QAAI,IAAI,GAAG,CAAC,CAAD,GAAK,CAAhB;AACA,QAAI,KAAK,GAAG,CAAC,CAAD,GAAK,CAAjB;AACA,QAAI,KAAK,GAAG,CAAC,CAAD,GAAK,CAAjB;AACA,IAAA,MAAM,CAAC,eAAP,CACI,IAAI,GAAG,CAAP,GAAW,CADf,EACkB,KAAK,GAAG,CAD1B,EAC6B,KAAK,GAAG,CADrC,EACwC,GADxC,EAEI,IAAI,GAAG,CAFX,EAEc,KAAK,GAAG,CAAR,GAAY,CAF1B,EAE6B,KAAK,GAAG,CAFrC,EAEwC,GAFxC,EAGI,IAAI,GAAG,CAHX,EAGc,KAAK,GAAG,CAHtB,EAGyB,KAAK,GAAG,CAAR,GAAY,CAHrC,EAGwC,GAHxC,EAII,IAAI,GAAG,KAAK,CAAC,CAJjB,EAIoB,KAAK,GAAG,KAAK,CAAC,CAJlC,EAIqC,KAAK,GAAG,KAAK,CAAC,CAJnD,EAIsD,GAJtD,EAKI,MALJ;AAOH,GAfa;AAiBd;;;;;;;;;AAOc,EAAA,MAAA,CAAA,gBAAA,GAAd,UAA+B,KAA/B,EAA8D,KAA9D,EAA6F,KAA7F,EAA4H,MAA5H,EAA0I;AACtI,IAAA,MAAM,CAAC,eAAP,CACI,KAAK,CAAC,EADV,EACc,KAAK,CAAC,EADpB,EACwB,KAAK,CAAC,EAD9B,EACkC,GADlC,EAEI,KAAK,CAAC,EAFV,EAEc,KAAK,CAAC,EAFpB,EAEwB,KAAK,CAAC,EAF9B,EAEkC,GAFlC,EAGI,KAAK,CAAC,EAHV,EAGc,KAAK,CAAC,EAHpB,EAGwB,KAAK,CAAC,EAH9B,EAGkC,GAHlC,EAII,GAJJ,EAIS,GAJT,EAIc,GAJd,EAImB,GAJnB,EAKI,MALJ;AAOH,GARa;AAUd;;;;;;;AAKc,EAAA,MAAA,CAAA,mBAAA,GAAd,UAAkC,IAAlC,EAAmE,MAAnE,EAAiF;AAC7E,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,EAAL,GAAU,IAAI,CAAC,EAAxB;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,MAAO,OAAO,EAAE,GAAG,EAAZ,CAAtB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,GAAf;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,MAAO,OAAO,EAAE,GAAG,EAAZ,CAAtB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,GAAf;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,CAAV,IAAe,OAAO,EAAE,GAAG,EAAZ,CAAf;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,MAAO,OAAO,EAAE,GAAG,EAAZ,CAAvB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,GAAhB;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,GAAhB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,EAAV,IAAgB,GAAhB;;AAEA,IAAA,MAAM,CAAC,cAAP;AACH,GAhCa;;AA55DC,EAAA,MAAA,CAAA,eAAA,GAAkB,CAAlB;AACA,EAAA,MAAA,CAAA,iBAAA,GAAoB,MAAM,CAAC,QAAP,EAApB;AA47DnB,SAAA,MAAA;AAAC,CAt8DD,EAAA;;SAAa,M;AAw8Db;;;;;AAIA,IAAA,OAAA;AAAA;AAAA,YAAA;AAAA,WAAA,OAAA,GAAA,CAIC;;AAHiB,EAAA,OAAA,CAAA,OAAA,GAAqB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,OAAO,CAAC,IAAjC,CAArB;AACA,EAAA,OAAA,CAAA,MAAA,GAAmB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,MAAM,CAAC,QAAhC,CAAnB;AACA,EAAA,OAAA,CAAA,UAAA,GAA2B,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,UAAU,CAAC,IAApC,CAA3B;AAClB,SAAA,OAAA;AAAC,CAJD,EAAA;AAMA;;;;;AAGA,IAAA,UAAA;AAAA;AAAA,YAAA;AAAA,WAAA,UAAA,GAAA,CAMC;;AALiB,EAAA,UAAA,CAAA,OAAA,GAAqB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,OAAO,CAAC,IAAjC,CAArB,CADlB,CAC+E;;AAC7D,EAAA,UAAA,CAAA,OAAA,GAAqB,UAAU,CAAC,UAAX,CAAsB,EAAtB,EAA0B,OAAO,CAAC,IAAlC,CAArB,CAFlB,CAEgF;;AAC9D,EAAA,UAAA,CAAA,OAAA,GAAqB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,OAAO,CAAC,IAAjC,CAArB,CAHlB,CAG+E;;AAC7D,EAAA,UAAA,CAAA,UAAA,GAA2B,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,UAAU,CAAC,IAApC,CAA3B,CAJlB,CAIwF;;AACtE,EAAA,UAAA,CAAA,MAAA,GAAmB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,MAAM,CAAC,QAAhC,CAAnB,CALlB,CAKgF;;AAChF,SAAA,UAAA;AAAC,CAND,EAAA;;SAAa,U;AAQb,UAAU,CAAC,eAAX,CAA2B,iBAA3B,IAAgD,OAAhD;AACA,UAAU,CAAC,eAAX,CAA2B,iBAA3B,IAAgD,OAAhD;AACA,UAAU,CAAC,eAAX,CAA2B,iBAA3B,IAAgD,OAAhD;AACA,UAAU,CAAC,eAAX,CAA2B,gBAA3B,IAA+C,MAA/C","sourcesContent":["import { Scalar } from \"./math.scalar\";\r\nimport { Epsilon } from './math.constants';\r\nimport { Viewport } from './math.viewport';\r\nimport { DeepImmutable, Nullable, FloatArray, float } from \"../types\";\r\nimport { ArrayTools } from '../Misc/arrayTools';\r\nimport { IPlaneLike } from './math.like';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Plane } from './math.plane';\r\nimport { PerformanceConfigurator } from '../Engines/performanceConfigurator';\r\n\r\n/**\r\n * Class representing a vector containing 2 coordinates\r\n */\r\nexport class Vector2 {\r\n    /**\r\n     * Creates a new Vector2 from the given x and y coordinates\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     */\r\n    constructor(\r\n        /** defines the first coordinate */\r\n        public x: number = 0,\r\n        /** defines the second coordinate */\r\n        public y: number = 0) {\r\n    }\r\n\r\n    /**\r\n     * Gets a string with the Vector2 coordinates\r\n     * @returns a string with the Vector2 coordinates\r\n     */\r\n    public toString(): string {\r\n        return \"{X: \" + this.x + \" Y: \" + this.y + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Gets class name\r\n     * @returns the string \"Vector2\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector2\";\r\n    }\r\n\r\n    /**\r\n     * Gets current vector hash code\r\n     * @returns the Vector2 hash code as a number\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.x | 0;\r\n        hash = (hash * 397) ^ (this.y | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\r\n     * @param array defines the source array\r\n     * @param index defines the offset in source array\r\n     * @returns the current Vector2\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Vector2 {\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector2 {\r\n        Vector2.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy the current vector to an array\r\n     * @returns a new array with 2 elements: the Vector2 coordinates.\r\n     */\r\n    public asArray(): number[] {\r\n        var result = new Array<number>();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\r\n     * @param source defines the source Vector2\r\n     * @returns the current updated Vector2\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector2>): Vector2 {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    public copyFromFloats(x: number, y: number): Vector2 {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    public set(x: number, y: number): Vector2 {\r\n        return this.copyFromFloats(x, y);\r\n    }\r\n    /**\r\n     * Add another vector with the current one\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public addVector3(otherVector: Vector3): Vector2 {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public subtract(otherVector: Vector2): Vector2 {\r\n        return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public multiplyInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns a new Vector2\r\n     */\r\n    public multiplyByFloats(x: number, y: number): Vector2 {\r\n        return new Vector2(this.x * x, this.y * y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    public divide(otherVector: Vector2): Vector2 {\r\n        return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\r\n    }\r\n\r\n    /**\r\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector2>, result: Vector2): Vector2 {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public divideInPlace(otherVector: DeepImmutable<Vector2>): Vector2 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 with current Vector2 negated coordinates\r\n     * @returns a new Vector2\r\n     */\r\n    public negate(): Vector2 {\r\n        return new Vector2(-this.x, -this.y);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector2 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector2\r\n     */\r\n    public negateToRef(result: Vector2): Vector2 {\r\n        return result.copyFromFloats(this.x * -1, this.y * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiply the Vector2 coordinates by scale\r\n     * @param scale defines the scaling factor\r\n     * @returns the current updated Vector2\r\n     */\r\n    public scaleInPlace(scale: number): Vector2 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\r\n     * @param scale defines the scaling factor\r\n     * @returns a new Vector2\r\n     */\r\n    public scale(scale: number): Vector2 {\r\n        let result = new Vector2(0, 0);\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector2 values by a factor to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public scaleToRef(scale: number, result: Vector2): Vector2 {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector2): Vector2 {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two vectors are equals\r\n     * @param otherVector defines the other vector\r\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector2>): boolean {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two vectors are equals (using an epsilon value)\r\n     * @param otherVector defines the other vector\r\n     * @param epsilon defines the minimal distance to consider equality\r\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector2>, epsilon: number = Epsilon): boolean {\r\n        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 floored values\r\n     * @returns a new Vector2\r\n     */\r\n    public floor(): Vector2 {\r\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 floored values\r\n     * @returns a new Vector2\r\n     */\r\n    public fract(): Vector2 {\r\n        return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets the length of the vector\r\n     * @returns the vector length (float)\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    /**\r\n     * Gets the vector squared length\r\n     * @returns the vector squared length (float)\r\n     */\r\n    public lengthSquared(): number {\r\n        return (this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Normalize the vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    public normalize(): Vector2 {\r\n        var len = this.length();\r\n\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n\r\n        this.x /= len;\r\n        this.y /= len;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 copied from the Vector2\r\n     * @returns a new Vector2\r\n     */\r\n    public clone(): Vector2 {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Gets a new Vector2(0, 0)\r\n     * @returns a new Vector2\r\n     */\r\n    public static Zero(): Vector2 {\r\n        return new Vector2(0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2(1, 1)\r\n     * @returns a new Vector2\r\n     */\r\n    public static One(): Vector2 {\r\n        return new Vector2(1, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @returns a new Vector2\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Vector2 {\r\n        return new Vector2(array[offset], array[offset + 1]);\r\n    }\r\n\r\n    /**\r\n     * Sets \"result\" from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @param result defines the target vector\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector2): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\r\n     * @param value1 defines 1st point of control\r\n     * @param value2 defines 2nd point of control\r\n     * @param value3 defines 3rd point of control\r\n     * @param value4 defines 4th point of control\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static CatmullRom(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>, value3: DeepImmutable<Vector2>, value4: DeepImmutable<Vector2>, amount: number): Vector2 {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n\r\n        var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) +\r\n            (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) +\r\n            ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\r\n\r\n        var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) +\r\n            (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) +\r\n            ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\r\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\r\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\r\n     * @param value defines the value to clamp\r\n     * @param min defines the lower limit\r\n     * @param max defines the upper limit\r\n     * @returns a new Vector2\r\n     */\r\n    public static Clamp(value: DeepImmutable<Vector2>, min: DeepImmutable<Vector2>, max: DeepImmutable<Vector2>): Vector2 {\r\n        var x = value.x;\r\n        x = (x > max.x) ? max.x : x;\r\n        x = (x < min.x) ? min.x : x;\r\n\r\n        var y = value.y;\r\n        y = (y > max.y) ? max.y : y;\r\n        y = (y < min.y) ? min.y : y;\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\"\r\n     * @param value1 defines the 1st control point\r\n     * @param tangent1 defines the outgoing tangent\r\n     * @param value2 defines the 2nd control point\r\n     * @param tangent2 defines the incoming tangent\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Vector2>, tangent1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>, tangent2: DeepImmutable<Vector2>, amount: number): Vector2 {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n\r\n        var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\r\n        var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\r\n\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\r\n     * @param start defines the start vector\r\n     * @param end defines the end vector\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    public static Lerp(start: DeepImmutable<Vector2>, end: DeepImmutable<Vector2>, amount: number): Vector2 {\r\n        var x = start.x + ((end.x - start.x) * amount);\r\n        var y = start.y + ((end.y - start.y) * amount);\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\r\n     * @param left defines first vector\r\n     * @param right defines second vector\r\n     * @returns the dot product (float)\r\n     */\r\n    public static Dot(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): number {\r\n        return left.x * right.x + left.y * right.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector2 equal to the normalized given vector\r\n     * @param vector defines the vector to normalize\r\n     * @returns a new Vector2\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector2>): Vector2 {\r\n        var newVector = vector.clone();\r\n        newVector.normalize();\r\n        return newVector;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2 {\r\n        var x = (left.x < right.x) ? left.x : right.x;\r\n        var y = (left.y < right.y) ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector2>, right: DeepImmutable<Vector2>): Vector2 {\r\n        var x = (left.x > right.x) ? left.x : right.x;\r\n        var y = (left.y > right.y) ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @returns a new Vector2\r\n     */\r\n    public static Transform(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>): Vector2 {\r\n        let r = Vector2.Zero();\r\n        Vector2.TransformToRef(vector, transformation, r);\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @param result defines the target vector\r\n     */\r\n    public static TransformToRef(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Matrix>, result: Vector2) {\r\n        const m = transformation.m;\r\n        var x = (vector.x * m[0]) + (vector.y * m[4]) + m[12];\r\n        var y = (vector.x * m[1]) + (vector.y * m[5]) + m[13];\r\n        result.x = x;\r\n        result.y = y;\r\n    }\r\n\r\n    /**\r\n     * Determines if a given vector is included in a triangle\r\n     * @param p defines the vector to test\r\n     * @param p0 defines 1st triangle point\r\n     * @param p1 defines 2nd triangle point\r\n     * @param p2 defines 3rd triangle point\r\n     * @returns true if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\r\n     */\r\n    public static PointInTriangle(p: DeepImmutable<Vector2>, p0: DeepImmutable<Vector2>, p1: DeepImmutable<Vector2>, p2: DeepImmutable<Vector2>) {\r\n        let a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\r\n        let sign = a < 0 ? -1 : 1;\r\n        let s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\r\n        let t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\r\n\r\n        return s > 0 && t > 0 && (s + t) < 2 * a * sign;\r\n    }\r\n\r\n    /**\r\n     * Gets the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the distance between vectors\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number {\r\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\r\n    }\r\n\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the squared distance between vectors\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): number {\r\n        var x = value1.x - value2.x;\r\n        var y = value1.y - value2.y;\r\n        return (x * x) + (y * y);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns a new Vector2\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector2>, value2: DeepImmutable<Vector2>): Vector2 {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\r\n     * @param p defines the middle point\r\n     * @param segA defines one point of the segment\r\n     * @param segB defines the other point of the segment\r\n     * @returns the shortest distance\r\n     */\r\n    public static DistanceOfPointFromSegment(p: DeepImmutable<Vector2>, segA: DeepImmutable<Vector2>, segB: DeepImmutable<Vector2>): number {\r\n        let l2 = Vector2.DistanceSquared(segA, segB);\r\n        if (l2 === 0.0) {\r\n            return Vector2.Distance(p, segA);\r\n        }\r\n        let v = segB.subtract(segA);\r\n        let t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\r\n        let proj = segA.add(v.multiplyByFloats(t, t));\r\n        return Vector2.Distance(p, proj);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store (x,y,z) vector representation\r\n * A Vector3 is the main object used in 3D geometry\r\n * It can represent etiher the coordinates of a point the space, either a direction\r\n * Reminder: js uses a left handed forward facing system\r\n */\r\nexport class Vector3 {\r\n    private static _UpReadOnly = Vector3.Up() as DeepImmutable<Vector3>;\r\n    private static _ZeroReadOnly = Vector3.Zero() as DeepImmutable<Vector3>;\r\n\r\n    /** @hidden */\r\n    public _x: number;\r\n\r\n    /** @hidden */\r\n    public _y: number;\r\n\r\n    /** @hidden */\r\n    public _z: number;\r\n\r\n    /** @hidden */\r\n    public _isDirty = true;\r\n\r\n    /** Gets or sets the x coordinate */\r\n    public get x() {\r\n        return this._x;\r\n    }\r\n\r\n    public set x(value: number) {\r\n        this._x = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the y coordinate */\r\n    public get y() {\r\n        return this._y;\r\n    }\r\n\r\n    public set y(value: number) {\r\n        this._y = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the z coordinate */\r\n    public get z() {\r\n        return this._z;\r\n    }\r\n\r\n    public set z(value: number) {\r\n        this._z = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\r\n     * @param x defines the first coordinates (on X axis)\r\n     * @param y defines the second coordinates (on Y axis)\r\n     * @param z defines the third coordinates (on Z axis)\r\n     */\r\n    constructor(\r\n        x: number = 0,\r\n        y: number = 0,\r\n        z: number = 0\r\n    ) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n    }\r\n\r\n    /**\r\n     * Creates a string representation of the Vector3\r\n     * @returns a string with the Vector3 coordinates.\r\n     */\r\n    public toString(): string {\r\n        return \"{X: \" + this._x + \" Y:\" + this._y + \" Z:\" + this._z + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"Vector3\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector3\";\r\n    }\r\n\r\n    /**\r\n     * Creates the Vector3 hash code\r\n     * @returns a number which tends to be unique between Vector3 instances\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this._x | 0;\r\n        hash = (hash * 397) ^ (this._y | 0);\r\n        hash = (hash * 397) ^ (this._z | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Creates an array containing three elements : the coordinates of the Vector3\r\n     * @returns a new array of numbers\r\n     */\r\n    public asArray(): number[] {\r\n        var result: number[] = [];\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Vector3 {\r\n        array[index] = this._x;\r\n        array[index + 1] = this._y;\r\n        array[index + 2] = this._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector3 {\r\n        Vector3.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\r\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\r\n     */\r\n    public toQuaternion(): Quaternion {\r\n        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the given vector to the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the given coordinates to the current Vector3\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public addInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Subtract the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        this.x -= otherVector._x;\r\n        this.y -= otherVector._y;\r\n        this.z -= otherVector._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public subtract(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    public subtractFromFloats(x: number, y: number, z: number): Vector3 {\r\n        return new Vector3(this._x - x, this._y - y, this._z - z);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\r\n     * @returns a new Vector3\r\n     */\r\n    public negate(): Vector3 {\r\n        return new Vector3(-this._x, -this._y, -this._z);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector3 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public negateToRef(result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Vector3 coordinates by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns the current updated Vector3\r\n     */\r\n    public scaleInPlace(scale: number): Vector3 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns a new Vector3\r\n     */\r\n    public scale(scale: number): Vector3 {\r\n        return new Vector3(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\r\n     * @param scale defines the multiplier factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public scaleToRef(scale: number, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the unmodified current Vector3\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector3): Vector3 {\r\n        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\r\n    }\r\n\r\n    /**\r\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n     * @param origin defines the origin of the projection ray\r\n     * @param plane defines the plane to project to\r\n     * @returns the projected vector3\r\n     */\r\n    public projectOnPlane(plane: Plane, origin: Vector3): Vector3 {\r\n        let result = Vector3.Zero();\r\n\r\n        this.projectOnPlaneToRef(plane, origin, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\r\n     * @param origin defines the origin of the projection ray\r\n     * @param plane defines the plane to project to\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public projectOnPlaneToRef(plane: Plane, origin: Vector3, result: Vector3): void {\r\n        let n = plane.normal;\r\n        let d = plane.d;\r\n\r\n        let V  = MathTmp.Vector3[0];\r\n\r\n        // ray direction\r\n        this.subtractToRef(origin, V);\r\n\r\n        V.normalize();\r\n\r\n        let denom = Vector3.Dot(V, n);\r\n        let t = -(Vector3.Dot(origin, n) + d) / denom;\r\n\r\n        // P = P0 + t*V\r\n        let scaledV = V.scaleInPlace(t);\r\n        origin.addToRef(scaledV, result);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\r\n     * @param otherVector defines the second operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector3>): boolean {\r\n        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\r\n     * @param otherVector defines the second operand\r\n     * @param epsilon defines the minimal distance to define values as equals\r\n     * @returns true if both vectors are distant less than epsilon\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector3>, epsilon: number = Epsilon): boolean {\r\n        return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current Vector3 coordinates equals the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    public equalsToFloats(x: number, y: number, z: number): boolean {\r\n        return this._x === x && this._y === y && this._z === z;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public multiplyInPlace(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        this.x *= otherVector._x;\r\n        this.y *= otherVector._y;\r\n        this.z *= otherVector._z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the new Vector3\r\n     */\r\n    public multiplyByFloats(x: number, y: number, z: number): Vector3 {\r\n        return new Vector3(this._x * x, this._y * y, this._z * z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public divide(otherVector: DeepImmutable<Vector3>): Vector3 {\r\n        return new Vector3(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector3>, result: Vector3): Vector3 {\r\n        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public divideInPlace(otherVector: Vector3): Vector3 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<Vector3>): Vector3 {\r\n        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<Vector3>): Vector3 {\r\n        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public minimizeInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        if (x < this._x) { this.x = x; }\r\n        if (y < this._y) { this.y = y; }\r\n        if (z < this._z) { this.z = z; }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public maximizeInPlaceFromFloats(x: number, y: number, z: number): Vector3 {\r\n        if (x > this._x) { this.x = x; }\r\n        if (y > this._y) { this.y = y; }\r\n        if (z > this._z) { this.z = z; }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\r\n     * Check if is non uniform within a certain amount of decimal places to account for this\r\n     * @param epsilon the amount the values can differ\r\n     * @returns if the the vector is non uniform to a certain number of decimal places\r\n     */\r\n    public isNonUniformWithinEpsilon(epsilon: number) {\r\n        let absX = Math.abs(this._x);\r\n        let absY = Math.abs(this._y);\r\n        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        let absZ = Math.abs(this._z);\r\n        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\r\n     */\r\n    public get isNonUniform(): boolean {\r\n        let absX = Math.abs(this._x);\r\n        let absY = Math.abs(this._y);\r\n        if (absX !== absY) {\r\n            return true;\r\n        }\r\n\r\n        let absZ = Math.abs(this._z);\r\n        if (absX !== absZ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    public floor(): Vector3 {\r\n        return new Vector3(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    public fract(): Vector3 {\r\n        return new Vector3(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\r\n    }\r\n\r\n    // Properties\r\n    /**\r\n     * Gets the length of the Vector3\r\n     * @returns the length of the Vector3\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\r\n    }\r\n\r\n    /**\r\n     * Gets the squared length of the Vector3\r\n     * @returns squared length of the Vector3\r\n     */\r\n    public lengthSquared(): number {\r\n        return (this._x * this._x + this._y * this._y + this._z * this._z);\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3.\r\n     * Please note that this is an in place operation.\r\n     * @returns the current updated Vector3\r\n     */\r\n    public normalize(): Vector3 {\r\n        return this.normalizeFromLength(this.length());\r\n    }\r\n\r\n    /**\r\n     * Reorders the x y z properties of the vector in place\r\n     * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\r\n     * @returns the current updated vector\r\n     */\r\n    public reorderInPlace(order: string) {\r\n        order = order.toLowerCase();\r\n        if (order === \"xyz\") {\r\n            return this;\r\n        }\r\n        MathTmp.Vector3[0].copyFrom(this);\r\n        [\"x\", \"y\", \"z\"].forEach((val, i) => {\r\n            (<any>this)[val] = (<any>MathTmp.Vector3[0])[order[i]];\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Rotates the vector around 0,0,0 by a quaternion\r\n     * @param quaternion the rotation quaternion\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    public rotateByQuaternionToRef(quaternion: Quaternion, result: Vector3) {\r\n        quaternion.toRotationMatrix(MathTmp.Matrix[0]);\r\n        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Rotates a vector around a given point\r\n     * @param quaternion the rotation quaternion\r\n     * @param point the point to rotate around\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    public rotateByQuaternionAroundPointToRef(quaternion: Quaternion, point: Vector3, result: Vector3) {\r\n        this.subtractToRef(point, MathTmp.Vector3[0]);\r\n        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\r\n        point.addToRef(MathTmp.Vector3[0], result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\r\n     * The cross product is then orthogonal to both current and \"other\"\r\n     * @param other defines the right operand\r\n     * @returns the cross product\r\n     */\r\n    public cross(other: Vector3) {\r\n        return Vector3.Cross(this, other);\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 with the given input length.\r\n     * Please note that this is an in place operation.\r\n     * @param len the length of the vector\r\n     * @returns the current updated Vector3\r\n     */\r\n    public normalizeFromLength(len: number): Vector3 {\r\n        if (len === 0 || len === 1.0) {\r\n            return this;\r\n        }\r\n\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 to a new vector\r\n     * @returns the new Vector3\r\n     */\r\n    public normalizeToNew(): Vector3 {\r\n        const normalized = new Vector3(0, 0, 0);\r\n        this.normalizeToRef(normalized);\r\n        return normalized;\r\n    }\r\n\r\n    /**\r\n     * Normalize the current Vector3 to the reference\r\n     * @param reference define the Vector3 to update\r\n     * @returns the updated Vector3\r\n     */\r\n    public normalizeToRef(reference: Vector3): Vector3 {\r\n        var len = this.length();\r\n        if (len === 0 || len === 1.0) {\r\n            return reference.copyFromFloats(this._x, this._y, this._z);\r\n        }\r\n\r\n        return this.scaleToRef(1.0 / len, reference);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector3 copied from the current Vector3\r\n     * @returns the new Vector3\r\n     */\r\n    public clone(): Vector3 {\r\n        return new Vector3(this._x, this._y, this._z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given vector coordinates to the current Vector3 ones\r\n     * @param source defines the source Vector3\r\n     * @returns the current updated Vector3\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector3>): Vector3 {\r\n        return this.copyFromFloats(source._x, source._y, source._z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number): Vector3 {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public set(x: number, y: number, z: number): Vector3 {\r\n        return this.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y and z coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public setAll(v: number): Vector3 {\r\n        this.x = this.y = this.z = v;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Get the clip factor between two vectors\r\n     * @param vector0 defines the first operand\r\n     * @param vector1 defines the second operand\r\n     * @param axis defines the axis to use\r\n     * @param size defines the size along the axis\r\n     * @returns the clip factor\r\n     */\r\n    public static GetClipFactor(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, axis: DeepImmutable<Vector3>, size: number) {\r\n        var d0 = Vector3.Dot(vector0, axis) - size;\r\n        var d1 = Vector3.Dot(vector1, axis) - size;\r\n\r\n        var s = d0 / (d0 - d1);\r\n\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Get angle between two vectors\r\n     * @param vector0 angle between vector0 and vector1\r\n     * @param vector1 angle between vector0 and vector1\r\n     * @param normal direction of the normal\r\n     * @return the angle between vector0 and vector1\r\n     */\r\n    public static GetAngleBetweenVectors(vector0: DeepImmutable<Vector3>, vector1: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>): number {\r\n        const v0: Vector3 = vector0.normalizeToRef(MathTmp.Vector3[1]);\r\n        const v1: Vector3 = vector1.normalizeToRef(MathTmp.Vector3[2]);\r\n        const dot: number = Vector3.Dot(v0, v1);\r\n        const n = MathTmp.Vector3[3];\r\n        Vector3.CrossToRef(v0, v1, n);\r\n        if (Vector3.Dot(n, normal) > 0) {\r\n            return Math.acos(dot);\r\n        }\r\n        return -Math.acos(dot);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Vector3 {\r\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     * @deprecated Please use FromArray instead.\r\n     */\r\n    public static FromFloatArray(array: DeepImmutable<Float32Array>, offset?: number): Vector3 {\r\n        return Vector3.FromArray(array, offset);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector3): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     * @deprecated Please use FromArrayToRef instead.\r\n     */\r\n    public static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector3): void {\r\n        return Vector3.FromArrayToRef(array, offset, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the given floats.\r\n     * @param x defines the x coordinate of the source\r\n     * @param y defines the y coordinate of the source\r\n     * @param z defines the z coordinate of the source\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void {\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\r\n     * @returns a new empty Vector3\r\n     */\r\n    public static Zero(): Vector3 {\r\n        return new Vector3(0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\r\n     * @returns a new unit Vector3\r\n     */\r\n    public static One(): Vector3 {\r\n        return new Vector3(1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\r\n     * @returns a new up Vector3\r\n     */\r\n    public static Up(): Vector3 {\r\n        return new Vector3(0.0, 1.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Gets a up Vector3 that must not be updated\r\n     */\r\n    public static get UpReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._UpReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a zero Vector3 that must not be updated\r\n     */\r\n    public static get ZeroReadOnly(): DeepImmutable<Vector3> {\r\n        return Vector3._ZeroReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\r\n     * @returns a new down Vector3\r\n     */\r\n    public static Down(): Vector3 {\r\n        return new Vector3(0.0, -1.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\r\n     * @param rightHandedSystem is the scene right-handed (negative z)\r\n     * @returns a new forward Vector3\r\n     */\r\n    public static Forward(rightHandedSystem: boolean = false): Vector3 {\r\n        return new Vector3(0.0, 0.0, (rightHandedSystem ? -1.0 : 1.0));\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\r\n     * @param rightHandedSystem is the scene right-handed (negative-z)\r\n     * @returns a new forward Vector3\r\n     */\r\n    public static Backward(rightHandedSystem: boolean = false): Vector3 {\r\n        return new Vector3(0.0, 0.0, (rightHandedSystem ? 1.0 : -1.0));\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\r\n     * @returns a new right Vector3\r\n     */\r\n    public static Right(): Vector3 {\r\n        return new Vector3(1.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\r\n     * @returns a new left Vector3\r\n     */\r\n    public static Left(): Vector3 {\r\n        return new Vector3(-1.0, 0.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the transformed Vector3\r\n     */\r\n    public static TransformCoordinates(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3 {\r\n        var result = Vector3.Zero();\r\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformCoordinatesToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\r\n     * This method computes tranformed coordinates only, not transformed direction vectors\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        const m = transformation.m;\r\n        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\r\n        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\r\n        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\r\n        var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\r\n\r\n        result.x = rx * rw;\r\n        result.y = ry * rw;\r\n        result.z = rz * rw;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the new Vector3\r\n     */\r\n    public static TransformNormal(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>): Vector3 {\r\n        var result = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformNormalToRef(vector: DeepImmutable<Vector3>, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: DeepImmutable<Matrix>, result: Vector3): void {\r\n        const m = transformation.m;\r\n        result.x = x * m[0] + y * m[4] + z * m[8];\r\n        result.y = x * m[1] + y * m[5] + z * m[9];\r\n        result.z = x * m[2] + y * m[6] + z * m[10];\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\r\n     * @param value1 defines the first control point\r\n     * @param value2 defines the second control point\r\n     * @param value3 defines the third control point\r\n     * @param value4 defines the fourth control point\r\n     * @param amount defines the amount on the spline to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static CatmullRom(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>, value3: DeepImmutable<Vector3>, value4: DeepImmutable<Vector3>, amount: number): Vector3 {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n\r\n        var x = 0.5 * ((((2.0 * value2._x) + ((-value1._x + value3._x) * amount)) +\r\n            (((((2.0 * value1._x) - (5.0 * value2._x)) + (4.0 * value3._x)) - value4._x) * squared)) +\r\n            ((((-value1._x + (3.0 * value2._x)) - (3.0 * value3._x)) + value4._x) * cubed));\r\n\r\n        var y = 0.5 * ((((2.0 * value2._y) + ((-value1._y + value3._y) * amount)) +\r\n            (((((2.0 * value1._y) - (5.0 * value2._y)) + (4.0 * value3._y)) - value4._y) * squared)) +\r\n            ((((-value1._y + (3.0 * value2._y)) - (3.0 * value3._y)) + value4._y) * cubed));\r\n\r\n        var z = 0.5 * ((((2.0 * value2._z) + ((-value1._z + value3._z) * amount)) +\r\n            (((((2.0 * value1._z) - (5.0 * value2._z)) + (4.0 * value3._z)) - value4._z) * squared)) +\r\n            ((((-value1._z + (3.0 * value2._z)) - (3.0 * value3._z)) + value4._z) * cubed));\r\n\r\n        return new Vector3(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @returns the new Vector3\r\n     */\r\n    public static Clamp(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): Vector3 {\r\n        const v = new Vector3();\r\n        Vector3.ClampToRef(value, min, max, v);\r\n        return v;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static ClampToRef(value: DeepImmutable<Vector3>, min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, result: Vector3): void {\r\n        var x = value._x;\r\n        x = (x > max._x) ? max._x : x;\r\n        x = (x < min._x) ? min._x : x;\r\n\r\n        var y = value._y;\r\n        y = (y > max._y) ? max._y : y;\r\n        y = (y < min._y) ? min._y : y;\r\n\r\n        var z = value._z;\r\n        z = (z > max._z) ? max._z : z;\r\n        z = (z < min._z) ? min._z : z;\r\n\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Checks if a given vector is inside a specific range\r\n     * @param v defines the vector to test\r\n     * @param min defines the minimum range\r\n     * @param max defines the maximum range\r\n     */\r\n    public static CheckExtends(v: Vector3, min: Vector3, max: Vector3): void {\r\n        min.minimizeInPlace(v);\r\n        max.maximizeInPlace(v);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent vector\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent vector\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Vector3>, tangent1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>, tangent2: DeepImmutable<Vector3>, amount: number): Vector3 {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n\r\n        var x = (((value1._x * part1) + (value2._x * part2)) + (tangent1._x * part3)) + (tangent2._x * part4);\r\n        var y = (((value1._y * part1) + (value2._y * part2)) + (tangent1._y * part3)) + (tangent2._y * part4);\r\n        var z = (((value1._z * part1) + (value2._z * part2)) + (tangent1._z * part3)) + (tangent2._z * part4);\r\n        return new Vector3(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    public static Lerp(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number): Vector3 {\r\n        var result = new Vector3(0, 0, 0);\r\n        Vector3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static LerpToRef(start: DeepImmutable<Vector3>, end: DeepImmutable<Vector3>, amount: number, result: Vector3): void {\r\n        result.x = start._x + ((end._x - start._x) * amount);\r\n        result.y = start._y + ((end._y - start._y) * amount);\r\n        result.z = start._z + ((end._z - start._z) * amount);\r\n    }\r\n\r\n    /**\r\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    public static Dot(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): number {\r\n        return (left._x * right._x + left._y * right._y + left._z * right._z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the cross product\r\n     */\r\n    public static Cross(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        var result = Vector3.Zero();\r\n        Vector3.CrossToRef(left, right, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static CrossToRef(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>, result: Vector3): void {\r\n        const x = left._y * right._z - left._z * right._y;\r\n        const y = left._z * right._x - left._x * right._z;\r\n        const z = left._x * right._y - left._y * right._x;\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 as the normalization of the given vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @returns the new Vector3\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector3>): Vector3 {\r\n        var result = Vector3.Zero();\r\n        Vector3.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the normalization of the given first vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static NormalizeToRef(vector: DeepImmutable<Vector3>, result: Vector3): void {\r\n        vector.normalizeToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Project a Vector3 onto screen space\r\n     * @param vector defines the Vector3 to project\r\n     * @param world defines the world matrix to use\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @param viewport defines the screen viewport to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static Project(vector: DeepImmutable<Vector3>, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>, viewport: DeepImmutable<Viewport>): Vector3 {\r\n        const result = new Vector3();\r\n        Vector3.ProjectToRef(vector, world, transform, viewport, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Project a Vector3 onto screen space to reference\r\n     * @param vector defines the Vector3 to project\r\n     * @param world defines the world matrix to use\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @param viewport defines the screen viewport to use\r\n     * @param result the vector in which the screen space will be stored\r\n     * @returns the new Vector3\r\n     */\r\n    public static ProjectToRef(vector: DeepImmutable<Vector3>, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>, viewport: DeepImmutable<Viewport>, result: DeepImmutable<Vector3>): Vector3 {\r\n        var cw = viewport.width;\r\n        var ch = viewport.height;\r\n        var cx = viewport.x;\r\n        var cy = viewport.y;\r\n\r\n        var viewportMatrix = MathTmp.Matrix[1];\r\n\r\n        Matrix.FromValuesToRef(\r\n            cw / 2.0, 0, 0, 0,\r\n            0, -ch / 2.0, 0, 0,\r\n            0, 0, 0.5, 0,\r\n            cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\r\n\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(transform, matrix);\r\n        matrix.multiplyToRef(viewportMatrix, matrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(vector, matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _UnprojectFromInvertedMatrixToRef(source: DeepImmutable<Vector3>, matrix: DeepImmutable<Matrix>, result: Vector3) {\r\n        Vector3.TransformCoordinatesToRef(source, matrix, result);\r\n        const m = matrix.m;\r\n        var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\r\n        if (Scalar.WithinEpsilon(num, 1.0)) {\r\n            result.scaleInPlace(1.0 / num);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static UnprojectFromTransform(source: Vector3, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, transform: DeepImmutable<Matrix>): Vector3 {\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(transform, matrix);\r\n        matrix.invert();\r\n        source.x = source._x / viewportWidth * 2 - 1;\r\n        source.y = -(source._y / viewportHeight * 2 - 1);\r\n        const vector = new Vector3();\r\n        Vector3._UnprojectFromInvertedMatrixToRef(source, matrix, vector);\r\n        return vector;\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    public static Unproject(source: DeepImmutable<Vector3>, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Vector3 {\r\n        let result = Vector3.Zero();\r\n\r\n        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static UnprojectToRef(source: DeepImmutable<Vector3>, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, result: Vector3): void {\r\n        Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\r\n    }\r\n\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param sourceZ defines the screen space z coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    public static UnprojectFloatsToRef(sourceX: float, sourceY: float, sourceZ: float, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, result: Vector3): void {\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n        var screenSource = MathTmp.Vector3[0];\r\n        screenSource.x = sourceX / viewportWidth * 2 - 1;\r\n        screenSource.y = -(sourceY / viewportHeight * 2 - 1);\r\n        screenSource.z = 2 * sourceZ - 1.0;\r\n        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\r\n    }\r\n\r\n    /**\r\n     * Gets the minimal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        var min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Gets the maximal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector3>, right: DeepImmutable<Vector3>): Vector3 {\r\n        var max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n\r\n    /**\r\n     * Returns the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the distance\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number {\r\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\r\n    }\r\n\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the squared distance\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): number {\r\n        var x = value1._x - value2._x;\r\n        var y = value1._y - value2._y;\r\n        var z = value1._z - value2._z;\r\n\r\n        return (x * x) + (y * y) + (z * z);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector3>, value2: DeepImmutable<Vector3>): Vector3 {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\r\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\r\n     * to something in order to rotate it from its local system to the given target system\r\n     * Note: axis1, axis2 and axis3 are normalized during this operation\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns a new Vector3\r\n     */\r\n    public static RotationFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Vector3 {\r\n        var rotation = Vector3.Zero();\r\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\r\n        return rotation;\r\n    }\r\n\r\n    /**\r\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the Vector3 where to store the result\r\n     */\r\n    public static RotationFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Vector3): void {\r\n        var quat = MathTmp.Quaternion[0];\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        quat.toEulerAnglesToRef(ref);\r\n    }\r\n}\r\n\r\n/**\r\n * Vector4 class created for EulerAngle class conversion to Quaternion\r\n */\r\nexport class Vector4 {\r\n    /**\r\n     * Creates a Vector4 object from the given floats.\r\n     * @param x x value of the vector\r\n     * @param y y value of the vector\r\n     * @param z z value of the vector\r\n     * @param w w value of the vector\r\n     */\r\n    constructor(\r\n        /** x value of the vector */\r\n        public x: number,\r\n        /** y value of the vector */\r\n        public y: number,\r\n        /** z value of the vector */\r\n        public z: number,\r\n        /** w value of the vector */\r\n        public w: number\r\n    ) { }\r\n\r\n    /**\r\n     * Returns the string with the Vector4 coordinates.\r\n     * @returns a string containing all the vector values\r\n     */\r\n    public toString(): string {\r\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Vector4\".\r\n     * @returns \"Vector4\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Vector4\";\r\n    }\r\n\r\n    /**\r\n     * Returns the Vector4 hash code.\r\n     * @returns a unique hash code\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.x | 0;\r\n        hash = (hash * 397) ^ (this.y | 0);\r\n        hash = (hash * 397) ^ (this.z | 0);\r\n        hash = (hash * 397) ^ (this.w | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n    /**\r\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\r\n     * @returns the resulting array\r\n     */\r\n    public asArray(): number[] {\r\n        var result = new Array<number>();\r\n\r\n        this.toArray(result, 0);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array from the given index with the Vector4 coordinates.\r\n     * @param array array to populate\r\n     * @param index index of the array to start at (default: 0)\r\n     * @returns the Vector4.\r\n     */\r\n    public toArray(array: FloatArray, index?: number): Vector4 {\r\n        if (index === undefined) {\r\n            index = 0;\r\n        }\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        array[index + 2] = this.z;\r\n        array[index + 3] = this.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current vector from an array\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    public fromArray(array: FloatArray, index: number = 0): Vector4 {\r\n        Vector4.FromArrayToRef(array, index, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the given vector to the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the updated Vector4.\r\n     */\r\n    public addInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        this.z += otherVector.z;\r\n        this.w += otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @returns the resulting vector\r\n     */\r\n    public add(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\r\n    }\r\n\r\n    /**\r\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public addToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        result.z = this.z + otherVector.z;\r\n        result.w = this.w + otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Subtract in place the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @returns the updated Vector4.\r\n     */\r\n    public subtractInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        this.z -= otherVector.z;\r\n        this.w -= otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the new vector with the result\r\n     */\r\n    public subtract(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public subtractToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        result.z = this.z - otherVector.z;\r\n        result.w = this.w - otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     */\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @returns new vector containing the result\r\n     */\r\n    public subtractFromFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @param result the vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    public subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4 {\r\n        result.x = this.x - x;\r\n        result.y = this.y - y;\r\n        result.z = this.z - z;\r\n        result.w = this.w - w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\r\n     * @returns a new vector with the negated values\r\n     */\r\n    public negate(): Vector4 {\r\n        return new Vector4(-this.x, -this.y, -this.z, -this.w);\r\n    }\r\n\r\n    /**\r\n     * Negate this vector in place\r\n     * @returns this\r\n     */\r\n    public negateInPlace(): Vector4 {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        this.w *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector4\r\n     */\r\n    public negateToRef(result: Vector4): Vector4 {\r\n        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Vector4 coordinates by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns the updated Vector4.\r\n     */\r\n    public scaleInPlace(scale: number): Vector4 {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns a new vector with the result\r\n     */\r\n    public scale(scale: number): Vector4 {\r\n        return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @param result a vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    public scaleToRef(scale: number, result: Vector4): Vector4 {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        result.z = this.z * scale;\r\n        result.w = this.w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector4 object where to store the result\r\n     * @returns the unmodified current Vector4\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Vector4): Vector4 {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        result.z += this.z * scale;\r\n        result.w += this.w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\r\n     * @param otherVector the vector to compare against\r\n     * @returns true if they are equal\r\n     */\r\n    public equals(otherVector: DeepImmutable<Vector4>): boolean {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\r\n     * @param otherVector vector to compare against\r\n     * @param epsilon (Default: very small number)\r\n     * @returns true if they are equal\r\n     */\r\n    public equalsWithEpsilon(otherVector: DeepImmutable<Vector4>, epsilon: number = Epsilon): boolean {\r\n        return otherVector\r\n            && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon)\r\n            && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon)\r\n            && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon)\r\n            && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\r\n     * @param x x value to compare against\r\n     * @param y y value to compare against\r\n     * @param z z value to compare against\r\n     * @param w w value to compare against\r\n     * @returns true if equal\r\n     */\r\n    public equalsToFloats(x: number, y: number, z: number, w: number): boolean {\r\n        return this.x === x && this.y === y && this.z === z && this.w === w;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current Vector4 by the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns the updated Vector4.\r\n     */\r\n    public multiplyInPlace(otherVector: Vector4): Vector4 {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        this.z *= otherVector.z;\r\n        this.w *= otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns resulting new vector\r\n     */\r\n    public multiply(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public multiplyToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        result.z = this.z * otherVector.z;\r\n        result.w = this.w * otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\r\n     * @param x x value multiply with\r\n     * @param y y value multiply with\r\n     * @param z z value multiply with\r\n     * @param w w value multiply with\r\n     * @returns resulting new vector\r\n     */\r\n    public multiplyByFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @returns resulting new vector\r\n     */\r\n    public divide(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    public divideToRef(otherVector: DeepImmutable<Vector4>, result: Vector4): Vector4 {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        result.z = this.z / otherVector.z;\r\n        result.w = this.w / otherVector.w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector vector to devide with\r\n     * @returns the updated Vector3.\r\n     */\r\n    public divideInPlace(otherVector: DeepImmutable<Vector4>): Vector4 {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    public minimizeInPlace(other: DeepImmutable<Vector4>): Vector4 {\r\n        if (other.x < this.x) { this.x = other.x; }\r\n        if (other.y < this.y) { this.y = other.y; }\r\n        if (other.z < this.z) { this.z = other.z; }\r\n        if (other.w < this.w) { this.w = other.w; }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    public maximizeInPlace(other: DeepImmutable<Vector4>): Vector4 {\r\n        if (other.x > this.x) { this.x = other.x; }\r\n        if (other.y > this.y) { this.y = other.y; }\r\n        if (other.z > this.z) { this.z = other.z; }\r\n        if (other.w > this.w) { this.w = other.w; }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector4 from current Vector4 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    public floor(): Vector4 {\r\n        return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\r\n    }\r\n\r\n    /**\r\n     * Gets a new Vector4 from current Vector3 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    public fract(): Vector4 {\r\n        return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\r\n    }\r\n\r\n    // Properties\r\n    /**\r\n     * Returns the Vector4 length (float).\r\n     * @returns the length\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    }\r\n    /**\r\n     * Returns the Vector4 squared length (float).\r\n     * @returns the length squared\r\n     */\r\n    public lengthSquared(): number {\r\n        return (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Normalizes in place the Vector4.\r\n     * @returns the updated Vector4.\r\n     */\r\n    public normalize(): Vector4 {\r\n        var len = this.length();\r\n\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\r\n     * @returns this converted to a new vector3\r\n     */\r\n    public toVector3(): Vector3 {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 copied from the current one.\r\n     * @returns the new cloned vector\r\n     */\r\n    public clone(): Vector4 {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    }\r\n    /**\r\n     * Updates the current Vector4 with the given one coordinates.\r\n     * @param source the source vector to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public copyFrom(source: DeepImmutable<Vector4>): Vector4 {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        this.z = source.z;\r\n        this.w = source.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to copy from\r\n     * @param y float to copy from\r\n     * @param z float to copy from\r\n     * @param w float to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number, w: number): Vector4 {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @returns the updated Vector4.\r\n     */\r\n    public set(x: number, y: number, z: number, w: number): Vector4 {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y, z and w coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    public setAll(v: number): Vector4 {\r\n        this.x = this.y = this.z = this.w = v;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new Vector4 set from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @returns the new vector\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Vector4 {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Vector4): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n        result.w = array[offset + 3];\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given Float32Array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static FromFloatArrayToRef(array: DeepImmutable<Float32Array>, offset: number, result: Vector4): void {\r\n        Vector4.FromArrayToRef(array, offset, result);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" coordinates from the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @param result the vector to the floats in\r\n     */\r\n    public static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void {\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = w;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\r\n     * @returns the new vector\r\n     */\r\n    public static Zero(): Vector4 {\r\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\r\n     * @returns the new vector\r\n     */\r\n    public static One(): Vector4 {\r\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new normalized Vector4 from the given one.\r\n     * @param vector the vector to normalize\r\n     * @returns the vector\r\n     */\r\n    public static Normalize(vector: DeepImmutable<Vector4>): Vector4 {\r\n        var result = Vector4.Zero();\r\n        Vector4.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the normalization of the given one.\r\n     * @param vector the vector to normalize\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static NormalizeToRef(vector: DeepImmutable<Vector4>, result: Vector4): void {\r\n        result.copyFrom(vector);\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns a vector with the minimum values from the left and right vectors\r\n     * @param left left vector to minimize\r\n     * @param right right vector to minimize\r\n     * @returns a new vector with the minimum of the left and right vector values\r\n     */\r\n    public static Minimize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4 {\r\n        var min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n\r\n    /**\r\n     * Returns a vector with the maximum values from the left and right vectors\r\n     * @param left left vector to maximize\r\n     * @param right right vector to maximize\r\n     * @returns a new vector with the maximum of the left and right vector values\r\n     */\r\n    public static Maximize(left: DeepImmutable<Vector4>, right: DeepImmutable<Vector4>): Vector4 {\r\n        var max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n    /**\r\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors\r\n     */\r\n    public static Distance(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number {\r\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\r\n    }\r\n    /**\r\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors squared\r\n     */\r\n    public static DistanceSquared(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): number {\r\n        var x = value1.x - value2.x;\r\n        var y = value1.y - value2.y;\r\n        var z = value1.z - value2.z;\r\n        var w = value1.w - value2.w;\r\n\r\n        return (x * x) + (y * y) + (z * z) + (w * w);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the center between\r\n     * @param value2 value to calulate the center between\r\n     * @return the center between the two vectors\r\n     */\r\n    public static Center(value1: DeepImmutable<Vector4>, value2: DeepImmutable<Vector4>): Vector4 {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @returns the new vector\r\n     */\r\n    public static TransformNormal(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>): Vector4 {\r\n        var result = Vector4.Zero();\r\n        Vector4.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the result in\r\n     */\r\n    public static TransformNormalToRef(vector: DeepImmutable<Vector4>, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        const m = transformation.m;\r\n        var x = (vector.x * m[0]) + (vector.y * m[4]) + (vector.z * m[8]);\r\n        var y = (vector.x * m[1]) + (vector.y * m[5]) + (vector.z * m[9]);\r\n        var z = (vector.x * m[2]) + (vector.y * m[6]) + (vector.z * m[10]);\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = vector.w;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param x value to transform\r\n     * @param y value to transform\r\n     * @param z value to transform\r\n     * @param w value to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the results in\r\n     */\r\n    public static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: DeepImmutable<Matrix>, result: Vector4): void {\r\n        const m = transformation.m;\r\n        result.x = (x * m[0]) + (y * m[4]) + (z * m[8]);\r\n        result.y = (x * m[1]) + (y * m[5]) + (z * m[9]);\r\n        result.z = (x * m[2]) + (y * m[6]) + (z * m[10]);\r\n        result.w = w;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector4 from a Vector3\r\n     * @param source defines the source data\r\n     * @param w defines the 4th component (default is 0)\r\n     * @returns a new Vector4\r\n     */\r\n    public static FromVector3(source: Vector3, w: number = 0) {\r\n        return new Vector4(source._x, source._y, source._z, w);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store quaternion data\r\n * @see https://en.wikipedia.org/wiki/Quaternion\r\n * @see https://doc.babylonjs.com/features/position,_rotation,_scaling\r\n */\r\nexport class Quaternion {\r\n    /** @hidden */\r\n    public _x: number;\r\n\r\n    /** @hidden */\r\n    public _y: number;\r\n\r\n    /** @hidden */\r\n    public _z: number;\r\n\r\n    /** @hidden */\r\n    public _w: number;\r\n\r\n    /** @hidden */\r\n    public _isDirty = true;\r\n\r\n    /** Gets or sets the x coordinate */\r\n    public get x() {\r\n        return this._x;\r\n    }\r\n\r\n    public set x(value: number) {\r\n        this._x = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the y coordinate */\r\n    public get y() {\r\n        return this._y;\r\n    }\r\n\r\n    public set y(value: number) {\r\n        this._y = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the z coordinate */\r\n    public get z() {\r\n        return this._z;\r\n    }\r\n\r\n    public set z(value: number) {\r\n        this._z = value;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** Gets or sets the w coordinate */\r\n    public get w() {\r\n        return this._w;\r\n    }\r\n\r\n    public set w(value: number) {\r\n        this._w = value;\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Creates a new Quaternion from the given floats\r\n     * @param x defines the first component (0 by default)\r\n     * @param y defines the second component (0 by default)\r\n     * @param z defines the third component (0 by default)\r\n     * @param w defines the fourth component (1.0 by default)\r\n     */\r\n    constructor(\r\n        x: number = 0.0,\r\n        y: number = 0.0,\r\n        z: number = 0.0,\r\n        w: number = 1.0) {\r\n            this._x = x;\r\n            this._y = y;\r\n            this._z = z;\r\n            this._w = w;\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation for the current quaternion\r\n     * @returns a string with the Quaternion coordinates\r\n     */\r\n    public toString(): string {\r\n        return \"{X: \" + this._x + \" Y:\" + this._y + \" Z:\" + this._z + \" W:\" + this._w + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the quaternion\r\n     * @returns the string \"Quaternion\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Quaternion\";\r\n    }\r\n\r\n    /**\r\n     * Gets a hash code for this quaternion\r\n     * @returns the quaternion hash code\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this._x | 0;\r\n        hash = (hash * 397) ^ (this._y | 0);\r\n        hash = (hash * 397) ^ (this._z | 0);\r\n        hash = (hash * 397) ^ (this._w | 0);\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion to an array\r\n     * @returns a new array populated with 4 elements from the quaternion coordinates\r\n     */\r\n    public asArray(): number[] {\r\n        return [this._x, this._y, this._z, this._w];\r\n    }\r\n    /**\r\n     * Check if two quaternions are equals\r\n     * @param otherQuaternion defines the second operand\r\n     * @return true if the current quaternion and the given one coordinates are strictly equals\r\n     */\r\n    public equals(otherQuaternion: DeepImmutable<Quaternion>): boolean {\r\n        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean if two quaternions are equals (using an epsilon value)\r\n     * @param otherQuaternion defines the other quaternion\r\n     * @param epsilon defines the minimal distance to consider equality\r\n     * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\r\n     */\r\n    public equalsWithEpsilon(otherQuaternion: DeepImmutable<Quaternion>, epsilon: number = Epsilon): boolean {\r\n        return otherQuaternion\r\n            && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon)\r\n            && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon)\r\n            && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon)\r\n            && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Clone the current quaternion\r\n     * @returns a new quaternion copied from the current one\r\n     */\r\n    public clone(): Quaternion {\r\n        return new Quaternion(this._x, this._y, this._z, this._w);\r\n    }\r\n\r\n    /**\r\n     * Copy a quaternion to the current one\r\n     * @param other defines the other quaternion\r\n     * @returns the updated current quaternion\r\n     */\r\n    public copyFrom(other: DeepImmutable<Quaternion>): Quaternion {\r\n        this.x = other._x;\r\n        this.y = other._y;\r\n        this.z = other._z;\r\n        this.w = other._w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion with the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    public copyFromFloats(x: number, y: number, z: number, w: number): Quaternion {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion from the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    public set(x: number, y: number, z: number, w: number): Quaternion {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n\r\n    /**\r\n     * Adds two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\r\n     */\r\n    public add(other: DeepImmutable<Quaternion>): Quaternion {\r\n        return new Quaternion(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\r\n    }\r\n\r\n    /**\r\n     * Add a quaternion to the current one\r\n     * @param other defines the quaternion to add\r\n     * @returns the current quaternion\r\n     */\r\n    public addInPlace(other: DeepImmutable<Quaternion>): Quaternion {\r\n        this._x += other._x;\r\n        this._y += other._y;\r\n        this._z += other._z;\r\n        this._w += other._w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Subtract two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the subtraction result of the given one from the current one\r\n     */\r\n    public subtract(other: Quaternion): Quaternion {\r\n        return new Quaternion(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\r\n     */\r\n    public scale(value: number): Quaternion {\r\n        return new Quaternion(this._x * value, this._y * value, this._z * value, this._w * value);\r\n    }\r\n\r\n    /**\r\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    public scaleToRef(scale: number, result: Quaternion): Quaternion {\r\n        result.x = this._x * scale;\r\n        result.y = this._y * scale;\r\n        result.z = this._z * scale;\r\n        result.w = this._w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies in place the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns the current modified quaternion\r\n     */\r\n    public scaleInPlace(value: number): Quaternion {\r\n        this.x *= value;\r\n        this.y *= value;\r\n        this.z *= value;\r\n        this.w *= value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Quaternion): Quaternion {\r\n        result.x += this._x * scale;\r\n        result.y += this._y * scale;\r\n        result.z += this._z * scale;\r\n        result.w += this._w * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two quaternions\r\n     * @param q1 defines the second operand\r\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\r\n     */\r\n    public multiply(q1: DeepImmutable<Quaternion>): Quaternion {\r\n        var result = new Quaternion(0, 0, 0, 1.0);\r\n        this.multiplyToRef(q1, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @param result defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    public multiplyToRef(q1: DeepImmutable<Quaternion>, result: Quaternion): Quaternion {\r\n        var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\r\n        var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\r\n        var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\r\n        var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\r\n        result.copyFromFloats(x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @returns the currentupdated quaternion\r\n     */\r\n    public multiplyInPlace(q1: DeepImmutable<Quaternion>): Quaternion {\r\n        this.multiplyToRef(q1, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\r\n     * @param ref defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    public conjugateToRef(ref: Quaternion): Quaternion {\r\n        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    public conjugateInPlace(): Quaternion {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns a new quaternion\r\n     */\r\n    public conjugate(): Quaternion {\r\n        var result = new Quaternion(-this._x, -this._y, -this._z, this._w);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets length of current quaternion\r\n     * @returns the quaternion length (float)\r\n     */\r\n    public length(): number {\r\n        return Math.sqrt((this._x * this._x) + (this._y * this._y) + (this._z * this._z) + (this._w * this._w));\r\n    }\r\n\r\n    /**\r\n     * Normalize in place the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    public normalize(): Quaternion {\r\n        var len = this.length();\r\n\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n\r\n        var inv = 1.0 / len;\r\n        this.x *= inv;\r\n        this.y *= inv;\r\n        this.z *= inv;\r\n        this.w *= inv;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 set with the Euler angles translated from the current quaternion\r\n     * @param order is a reserved parameter and is ignored for now\r\n     * @returns a new Vector3 containing the Euler angles\r\n     */\r\n    public toEulerAngles(order = \"YZX\"): Vector3 {\r\n        var result = Vector3.Zero();\r\n        this.toEulerAnglesToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\r\n     * @param result defines the vector which will be filled with the Euler angles\r\n     * @returns the current unchanged quaternion\r\n     */\r\n    public toEulerAnglesToRef(result: Vector3): Quaternion {\r\n\r\n        var qz = this._z;\r\n        var qx = this._x;\r\n        var qy = this._y;\r\n        var qw = this._w;\r\n\r\n        var sqw = qw * qw;\r\n        var sqz = qz * qz;\r\n        var sqx = qx * qx;\r\n        var sqy = qy * qy;\r\n\r\n        var zAxisY = qy * qz - qx * qw;\r\n        var limit = .4999999;\r\n\r\n        if (zAxisY < -limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = Math.PI / 2;\r\n            result.z = 0;\r\n        } else if (zAxisY > limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = -Math.PI / 2;\r\n            result.z = 0;\r\n        } else {\r\n            result.z = Math.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw));\r\n            result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\r\n            result.y = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * Updates the given rotation matrix with the current quaternion values\r\n     * @param result defines the target matrix\r\n     * @returns the current unchanged quaternion\r\n     */\r\n    public toRotationMatrix(result: Matrix): Quaternion {\r\n        Matrix.FromQuaternionToRef(this, result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the current quaternion from the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @returns the current updated quaternion\r\n     */\r\n    public fromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion {\r\n        Quaternion.FromRotationMatrixToRef(matrix, this);\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new quaternion from a rotation matrix\r\n     * @param matrix defines the source matrix\r\n     * @returns a new quaternion created from the given rotation matrix values\r\n     */\r\n    public static FromRotationMatrix(matrix: DeepImmutable<Matrix>): Quaternion {\r\n        var result = new Quaternion();\r\n        Quaternion.FromRotationMatrixToRef(matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Updates the given quaternion with the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static FromRotationMatrixToRef(matrix: DeepImmutable<Matrix>, result: Quaternion): void {\r\n        var data = matrix.m;\r\n        var m11 = data[0], m12 = data[4], m13 = data[8];\r\n        var m21 = data[1], m22 = data[5], m23 = data[9];\r\n        var m31 = data[2], m32 = data[6], m33 = data[10];\r\n        var trace = m11 + m22 + m33;\r\n        var s;\r\n\r\n        if (trace > 0) {\r\n\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n\r\n            result.w = 0.25 / s;\r\n            result.x = (m32 - m23) * s;\r\n            result.y = (m13 - m31) * s;\r\n            result.z = (m21 - m12) * s;\r\n        } else if (m11 > m22 && m11 > m33) {\r\n\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n\r\n            result.w = (m32 - m23) / s;\r\n            result.x = 0.25 * s;\r\n            result.y = (m12 + m21) / s;\r\n            result.z = (m13 + m31) / s;\r\n        } else if (m22 > m33) {\r\n\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n\r\n            result.w = (m13 - m31) / s;\r\n            result.x = (m12 + m21) / s;\r\n            result.y = 0.25 * s;\r\n            result.z = (m23 + m32) / s;\r\n        } else {\r\n\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n\r\n            result.w = (m21 - m12) / s;\r\n            result.x = (m13 + m31) / s;\r\n            result.y = (m23 + m32) / s;\r\n            result.z = 0.25 * s;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    public static Dot(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>): number {\r\n        return (left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w);\r\n    }\r\n\r\n    /**\r\n     * Checks if the two quaternions are close to each other\r\n     * @param quat0 defines the first quaternion to check\r\n     * @param quat1 defines the second quaternion to check\r\n     * @returns true if the two quaternions are close to each other\r\n     */\r\n    public static AreClose(quat0: DeepImmutable<Quaternion>, quat1: DeepImmutable<Quaternion>): boolean {\r\n        let dot = Quaternion.Dot(quat0, quat1);\r\n\r\n        return dot >= 0;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty quaternion\r\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\r\n     */\r\n    public static Zero(): Quaternion {\r\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @returns a new quaternion as the inverted current quaternion\r\n     */\r\n    public static Inverse(q: DeepImmutable<Quaternion>): Quaternion {\r\n        return new Quaternion(-q._x, -q._y, -q._z, q._w);\r\n    }\r\n\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @param result the quaternion the result will be stored in\r\n     * @returns the result quaternion\r\n     */\r\n    public static InverseToRef(q: Quaternion, result: Quaternion): Quaternion {\r\n        result.set(-q._x, -q._y, -q._z, q._w);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates an identity quaternion\r\n     * @returns the identity quaternion\r\n     */\r\n    public static Identity(): Quaternion {\r\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given quaternion is identity\r\n     * @param quaternion defines the quaternion to check\r\n     * @returns true if the quaternion is identity\r\n     */\r\n    public static IsIdentity(quaternion: DeepImmutable<Quaternion>): boolean {\r\n        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a quaternion from a rotation around an axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\r\n     */\r\n    public static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Quaternion {\r\n        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation around an axis and stores it into the given quaternion\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @param result defines the target quaternion\r\n     * @returns the target quaternion\r\n     */\r\n    public static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Quaternion): Quaternion {\r\n        var sin = Math.sin(angle / 2);\r\n        axis.normalize();\r\n        result.w = Math.cos(angle / 2);\r\n        result.x = axis._x * sin;\r\n        result.y = axis._y * sin;\r\n        result.z = axis._z * sin;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from data stored into an array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the source array where the data starts\r\n     * @returns a new quaternion\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset?: number): Quaternion {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n\r\n    /**\r\n     * Updates the given quaternion \"result\" from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the quaternion to store the result in\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Quaternion): void {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n        result.w = array[offset + 3];\r\n    }\r\n\r\n    /**\r\n     * Create a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @returns the new Quaternion\r\n     */\r\n    public static FromEulerAngles(x: number, y: number, z: number): Quaternion {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Updates a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    public static FromEulerAnglesToRef(x: number, y: number, z: number, result: Quaternion): Quaternion {\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @returns the new Quaternion\r\n     */\r\n    public static FromEulerVector(vec: DeepImmutable<Vector3>): Quaternion {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Updates a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    public static FromEulerVectorToRef(vec: DeepImmutable<Vector3>, result: Quaternion): Quaternion {\r\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\r\n        return q;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void {\r\n        // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\r\n        var halfRoll = roll * 0.5;\r\n        var halfPitch = pitch * 0.5;\r\n        var halfYaw = yaw * 0.5;\r\n\r\n        var sinRoll = Math.sin(halfRoll);\r\n        var cosRoll = Math.cos(halfRoll);\r\n        var sinPitch = Math.sin(halfPitch);\r\n        var cosPitch = Math.cos(halfPitch);\r\n        var sinYaw = Math.sin(halfYaw);\r\n        var cosYaw = Math.cos(halfYaw);\r\n\r\n        result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n        result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n        result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n        result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion {\r\n        var result = new Quaternion();\r\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void {\r\n        // Produces a quaternion from Euler angles in the z-x-z orientation\r\n        var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\r\n        var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\r\n        var halfBeta = beta * 0.5;\r\n\r\n        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n    }\r\n\r\n    /**\r\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns the new quaternion\r\n     */\r\n    public static RotationQuaternionFromAxis(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>): Quaternion {\r\n        var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        return quat;\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the target quaternion\r\n     */\r\n    public static RotationQuaternionFromAxisToRef(axis1: DeepImmutable<Vector3>, axis2: DeepImmutable<Vector3>, axis3: DeepImmutable<Vector3>, ref: Quaternion): void {\r\n        var rotMat = MathTmp.Matrix[0];\r\n        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\r\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\r\n    }\r\n\r\n    /**\r\n     * Interpolates between two quaternions\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    public static Slerp(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number): Quaternion {\r\n        var result = Quaternion.Identity();\r\n\r\n        Quaternion.SlerpToRef(left, right, amount, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Interpolates between two quaternions and stores it into a target quaternion\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @param result defines the target quaternion\r\n     */\r\n    public static SlerpToRef(left: DeepImmutable<Quaternion>, right: DeepImmutable<Quaternion>, amount: number, result: Quaternion): void {\r\n        var num2;\r\n        var num3;\r\n        var num4 = (((left._x * right._x) + (left._y * right._y)) + (left._z * right._z)) + (left._w * right._w);\r\n        var flag = false;\r\n\r\n        if (num4 < 0) {\r\n            flag = true;\r\n            num4 = -num4;\r\n        }\r\n\r\n        if (num4 > 0.999999) {\r\n            num3 = 1 - amount;\r\n            num2 = flag ? -amount : amount;\r\n        }\r\n        else {\r\n            var num5 = Math.acos(num4);\r\n            var num6 = (1.0 / Math.sin(num5));\r\n            num3 = (Math.sin((1.0 - amount) * num5)) * num6;\r\n            num2 = flag ? ((-Math.sin(amount * num5)) * num6) : ((Math.sin(amount * num5)) * num6);\r\n        }\r\n\r\n        result.x = (num3 * left._x) + (num2 * right._x);\r\n        result.y = (num3 * left._y) + (num2 * right._y);\r\n        result.z = (num3 * left._z) + (num2 * right._z);\r\n        result.w = (num3 * left._w) + (num2 * right._w);\r\n    }\r\n\r\n    /**\r\n     * Interpolate between two quaternions using Hermite interpolation\r\n     * @param value1 defines first quaternion\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second quaternion\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target quaternion\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Quaternion>, tangent1: DeepImmutable<Quaternion>, value2: DeepImmutable<Quaternion>, tangent2: DeepImmutable<Quaternion>, amount: number): Quaternion {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n\r\n        var x = (((value1._x * part1) + (value2._x * part2)) + (tangent1._x * part3)) + (tangent2._x * part4);\r\n        var y = (((value1._y * part1) + (value2._y * part2)) + (tangent1._y * part3)) + (tangent2._y * part4);\r\n        var z = (((value1._z * part1) + (value2._z * part2)) + (tangent1._z * part3)) + (tangent2._z * part4);\r\n        var w = (((value1._w * part1) + (value2._w * part2)) + (tangent1._w * part3)) + (tangent2._w * part4);\r\n        return new Quaternion(x, y, z, w);\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to store matrix data (4x4)\r\n */\r\nexport class Matrix {\r\n\r\n    /**\r\n     * Gets the precision of matrix computations\r\n     */\r\n    public static get Use64Bits(): boolean {\r\n        return PerformanceConfigurator.MatrixUse64Bits;\r\n    }\r\n\r\n    private static _updateFlagSeed = 0;\r\n    private static _identityReadOnly = Matrix.Identity() as DeepImmutable<Matrix>;\r\n\r\n    private _isIdentity = false;\r\n    private _isIdentityDirty = true;\r\n    private _isIdentity3x2 = true;\r\n    private _isIdentity3x2Dirty = true;\r\n    /**\r\n     * Gets the update flag of the matrix which is an unique number for the matrix.\r\n     * It will be incremented every time the matrix data change.\r\n     * You can use it to speed the comparison between two versions of the same matrix.\r\n     */\r\n    public updateFlag: number = -1;\r\n\r\n    private readonly _m: Float32Array | Array<number>;\r\n\r\n    /**\r\n     * Gets the internal data of the matrix\r\n     */\r\n    public get m(): DeepImmutable<Float32Array | Array<number>> { return this._m; }\r\n\r\n    /** @hidden */\r\n    public _markAsUpdated() {\r\n        this.updateFlag = Matrix._updateFlagSeed++;\r\n        this._isIdentity = false;\r\n        this._isIdentity3x2 = false;\r\n        this._isIdentityDirty = true;\r\n        this._isIdentity3x2Dirty = true;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _updateIdentityStatus(isIdentity: boolean, isIdentityDirty: boolean = false, isIdentity3x2: boolean = false, isIdentity3x2Dirty: boolean = true) {\r\n        this.updateFlag = Matrix._updateFlagSeed++;\r\n        this._isIdentity = isIdentity;\r\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\r\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\r\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty matrix (filled with zeros)\r\n     */\r\n    public constructor() {\r\n        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\r\n            PerformanceConfigurator.MatrixTrackedMatrices!.push(this);\r\n        }\r\n\r\n        this._m = new PerformanceConfigurator.MatrixCurrentType(16);\r\n        this._updateIdentityStatus(false);\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Check if the current matrix is identity\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    public isIdentity(): boolean {\r\n        if (this._isIdentityDirty) {\r\n            this._isIdentityDirty = false;\r\n            const m = this._m;\r\n            this._isIdentity = (\r\n                m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 &&\r\n                m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 &&\r\n                m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 &&\r\n                m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0\r\n            );\r\n        }\r\n\r\n        return this._isIdentity;\r\n    }\r\n\r\n    /**\r\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    public isIdentityAs3x2(): boolean {\r\n        if (this._isIdentity3x2Dirty) {\r\n            this._isIdentity3x2Dirty = false;\r\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\r\n                this._isIdentity3x2 = false;\r\n            } else if (this._m[1] !== 0.0 || this._m[2] !== 0.0 || this._m[3] !== 0.0 ||\r\n                this._m[4] !== 0.0 || this._m[6] !== 0.0 || this._m[7] !== 0.0 ||\r\n                this._m[8] !== 0.0 || this._m[9] !== 0.0 || this._m[10] !== 0.0 || this._m[11] !== 0.0 ||\r\n                this._m[12] !== 0.0 || this._m[13] !== 0.0 || this._m[14] !== 0.0) {\r\n                this._isIdentity3x2 = false;\r\n            } else {\r\n                this._isIdentity3x2 = true;\r\n            }\r\n        }\r\n\r\n        return this._isIdentity3x2;\r\n    }\r\n\r\n    /**\r\n     * Gets the determinant of the matrix\r\n     * @returns the matrix determinant\r\n     */\r\n    public determinant(): number {\r\n        if (this._isIdentity === true) {\r\n            return 1;\r\n        }\r\n\r\n        const m = this._m;\r\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\r\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\r\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\r\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\r\n        // https://en.wikipedia.org/wiki/Laplace_expansion\r\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\r\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\r\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\r\n        // where\r\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\r\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\r\n        //\r\n        // Here we do that for the 1st row.\r\n\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Returns the matrix as a Float32Array or Array<number>\r\n     * @returns the matrix underlying array\r\n     */\r\n    public toArray(): DeepImmutable<Float32Array | Array<number>> {\r\n        return this._m;\r\n    }\r\n    /**\r\n     * Returns the matrix as a Float32Array or Array<number>\r\n    * @returns the matrix underlying array.\r\n    */\r\n    public asArray(): DeepImmutable<Float32Array | Array<number>> {\r\n        return this._m;\r\n    }\r\n\r\n    /**\r\n     * Inverts the current matrix in place\r\n     * @returns the current inverted matrix\r\n     */\r\n    public invert(): Matrix {\r\n        this.invertToRef(this);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets all the matrix elements to zero\r\n     * @returns the current matrix\r\n     */\r\n    public reset(): Matrix {\r\n        Matrix.FromValuesToRef(\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0,\r\n            this\r\n        );\r\n        this._updateIdentityStatus(false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the current matrix with a second one\r\n     * @param other defines the matrix to add\r\n     * @returns a new matrix as the addition of the current matrix and the given one\r\n     */\r\n    public add(other: DeepImmutable<Matrix>): Matrix {\r\n        var result = new Matrix();\r\n        this.addToRef(other, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\r\n     * @param other defines the matrix to add\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public addToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix {\r\n        const m = this._m;\r\n        const resultM = result._m;\r\n        const otherM = other.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            resultM[index] = m[index] + otherM[index];\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds in place the given matrix to the current matrix\r\n     * @param other defines the second operand\r\n     * @returns the current updated matrix\r\n     */\r\n    public addToSelf(other: DeepImmutable<Matrix>): Matrix {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            m[index] += otherM[index];\r\n        }\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix to the current inverted Matrix\r\n     * @param other defines the target matrix\r\n     * @returns the unmodified current matrix\r\n     */\r\n    public invertToRef(other: Matrix): Matrix {\r\n        if (this._isIdentity === true) {\r\n            Matrix.IdentityToRef(other);\r\n            return this;\r\n        }\r\n\r\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\r\n        const m = this._m;\r\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\r\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\r\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\r\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\r\n\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n\r\n        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n\r\n        if (det === 0) {\r\n            // not invertible\r\n            other.copyFrom(this);\r\n            return this;\r\n        }\r\n\r\n        const detInv = 1 / det;\r\n        const det_12_33 = m12 * m33 - m32 * m13;\r\n        const det_11_33 = m11 * m33 - m31 * m13;\r\n        const det_11_32 = m11 * m32 - m31 * m12;\r\n        const det_10_33 = m10 * m33 - m30 * m13;\r\n        const det_10_32 = m10 * m32 - m30 * m12;\r\n        const det_10_31 = m10 * m31 - m30 * m11;\r\n        const det_12_23 = m12 * m23 - m22 * m13;\r\n        const det_11_23 = m11 * m23 - m21 * m13;\r\n        const det_11_22 = m11 * m22 - m21 * m12;\r\n        const det_10_23 = m10 * m23 - m20 * m13;\r\n        const det_10_22 = m10 * m22 - m20 * m12;\r\n        const det_10_21 = m10 * m21 - m20 * m11;\r\n\r\n        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\r\n        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\r\n        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\r\n        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\r\n\r\n        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\r\n        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\r\n        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\r\n        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\r\n\r\n        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\r\n        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\r\n        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\r\n        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\r\n\r\n        Matrix.FromValuesToRef(\r\n            cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv,\r\n            cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv,\r\n            cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv,\r\n            cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv,\r\n            other\r\n        );\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * add a value at the specified position in the current Matrix\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    public addAtIndex(index: number, value: number): Matrix {\r\n        this._m[index] += value;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * mutiply the specified position in the current Matrix by a value\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    public multiplyAtIndex(index: number, value: number): Matrix {\r\n        this._m[index] *= value;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Inserts the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    public setTranslationFromFloats(x: number, y: number, z: number): Matrix {\r\n        this._m[12] = x;\r\n        this._m[13] = y;\r\n        this._m[14] = z;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    public addTranslationFromFloats(x: number, y: number, z: number): Matrix {\r\n        this._m[12] += x;\r\n        this._m[13] += y;\r\n        this._m[14] += z;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Inserts the translation vector in the current matrix\r\n     * @param vector3 defines the translation to insert\r\n     * @returns the current updated matrix\r\n     */\r\n    public setTranslation(vector3: DeepImmutable<Vector3>): Matrix {\r\n        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\r\n    }\r\n\r\n    /**\r\n     * Gets the translation value of the current matrix\r\n     * @returns a new Vector3 as the extracted translation from the matrix\r\n     */\r\n    public getTranslation(): Vector3 {\r\n        return new Vector3(this._m[12], this._m[13], this._m[14]);\r\n    }\r\n\r\n    /**\r\n     * Fill a Vector3 with the extracted translation from the matrix\r\n     * @param result defines the Vector3 where to store the translation\r\n     * @returns the current matrix\r\n     */\r\n    public getTranslationToRef(result: Vector3): Matrix {\r\n        result.x = this._m[12];\r\n        result.y = this._m[13];\r\n        result.z = this._m[14];\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove rotation and scaling part from the matrix\r\n     * @returns the updated matrix\r\n     */\r\n    public removeRotationAndScaling(): Matrix {\r\n        const m = this.m;\r\n        Matrix.FromValuesToRef(\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            m[12], m[13], m[14], m[15],\r\n            this\r\n        );\r\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply two matrices\r\n     * @param other defines the second operand\r\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\r\n     */\r\n    public multiply(other: DeepImmutable<Matrix>): Matrix {\r\n        var result = new Matrix();\r\n        this.multiplyToRef(other, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the current matrix from the given one\r\n     * @param other defines the source matrix\r\n     * @returns the current updated matrix\r\n     */\r\n    public copyFrom(other: DeepImmutable<Matrix>): Matrix {\r\n        other.copyToArray(this._m);\r\n        const o = (other as Matrix);\r\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Populates the given array from the starting index with the current matrix values\r\n     * @param array defines the target array\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    public copyToArray(array: Float32Array | Array<number>, offset: number = 0): Matrix {\r\n        let source = this._m;\r\n        array[offset] = source[0];\r\n        array[offset + 1] = source[1];\r\n        array[offset + 2] = source[2];\r\n        array[offset + 3] = source[3];\r\n        array[offset + 4] = source[4];\r\n        array[offset + 5] = source[5];\r\n        array[offset + 6] = source[6];\r\n        array[offset + 7] = source[7];\r\n        array[offset + 8] = source[8];\r\n        array[offset + 9] = source[9];\r\n        array[offset + 10] = source[10];\r\n        array[offset + 11] = source[11];\r\n        array[offset + 12] = source[12];\r\n        array[offset + 13] = source[13];\r\n        array[offset + 14] = source[14];\r\n        array[offset + 15] = source[15];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the matrix where to store the multiplication\r\n     * @returns the current matrix\r\n     */\r\n    public multiplyToRef(other: DeepImmutable<Matrix>, result: Matrix): Matrix {\r\n        if (this._isIdentity) {\r\n            result.copyFrom(other);\r\n            return this;\r\n        }\r\n        if ((other as Matrix)._isIdentity) {\r\n            result.copyFrom(this);\r\n            return this;\r\n        }\r\n\r\n        this.multiplyToArray(other, result._m, 0);\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the array where to store the multiplication\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    public multiplyToArray(other: DeepImmutable<Matrix>, result: Float32Array | Array<number>, offset: number): Matrix {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\r\n        var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\r\n        var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\r\n        var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\r\n\r\n        var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\r\n        var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\r\n        var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\r\n        var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\r\n\r\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\r\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\r\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\r\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\r\n\r\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\r\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\r\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\r\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\r\n\r\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\r\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\r\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\r\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\r\n\r\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\r\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\r\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\r\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Check equality between this matrix and a second one\r\n     * @param value defines the second matrix to compare\r\n     * @returns true is the current matrix and the given one values are strictly equal\r\n     */\r\n    public equals(value: DeepImmutable<Matrix>): boolean {\r\n        const other = (value as Matrix);\r\n        if (!other) {\r\n            return false;\r\n        }\r\n\r\n        if (this._isIdentity || other._isIdentity) {\r\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\r\n                return this._isIdentity && other._isIdentity;\r\n            }\r\n        }\r\n\r\n        const m = this.m;\r\n        const om = other.m;\r\n        return (\r\n            m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] &&\r\n            m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] &&\r\n            m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] &&\r\n            m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Clone the current matrix\r\n     * @returns a new matrix from the current matrix\r\n     */\r\n    public clone(): Matrix {\r\n        const matrix = new Matrix();\r\n        matrix.copyFrom(this);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the name of the current matrix class\r\n     * @returns the string \"Matrix\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Matrix\";\r\n    }\r\n\r\n    /**\r\n     * Gets the hash code of the current matrix\r\n     * @returns the hash code\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this._m[0] | 0;\r\n        for (let i = 1; i < 16; i++) {\r\n            hash = (hash * 397) ^ (this._m[i] | 0);\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Decomposes the current Matrix into a translation, rotation and scaling components\r\n     * @param scale defines the scale vector3 given as a reference to update\r\n     * @param rotation defines the rotation quaternion given as a reference to update\r\n     * @param translation defines the translation vector3 given as a reference to update\r\n     * @returns true if operation was successful\r\n     */\r\n    public decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3): boolean {\r\n        if (this._isIdentity) {\r\n            if (translation) {\r\n                translation.setAll(0);\r\n            }\r\n            if (scale) {\r\n                scale.setAll(1);\r\n            }\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0, 0, 0, 1);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        const m = this._m;\r\n        if (translation) {\r\n            translation.copyFromFloats(m[12], m[13], m[14]);\r\n        }\r\n\r\n        scale = scale || MathTmp.Vector3[0];\r\n        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\r\n        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\r\n        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\r\n\r\n        if (this.determinant() <= 0) {\r\n            scale.y *= -1;\r\n        }\r\n\r\n        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (rotation) {\r\n            const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\r\n            Matrix.FromValuesToRef(\r\n                m[0] * sx, m[1] * sx, m[2] * sx, 0.0,\r\n                m[4] * sy, m[5] * sy, m[6] * sy, 0.0,\r\n                m[8] * sz, m[9] * sz, m[10] * sz, 0.0,\r\n                0.0, 0.0, 0.0, 1.0,\r\n                MathTmp.Matrix[0]\r\n            );\r\n\r\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets specific row of the matrix\r\n     * @param index defines the number of the row to get\r\n     * @returns the index-th row of the current matrix as a new Vector4\r\n     */\r\n    public getRow(index: number): Nullable<Vector4> {\r\n        if (index < 0 || index > 3) {\r\n            return null;\r\n        }\r\n        var i = index * 4;\r\n        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\r\n    }\r\n\r\n    /**\r\n     * Sets the index-th row of the current matrix to the vector4 values\r\n     * @param index defines the number of the row to set\r\n     * @param row defines the target vector4\r\n     * @returns the updated current matrix\r\n     */\r\n    public setRow(index: number, row: Vector4): Matrix {\r\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of the matrix\r\n     * @returns the new transposed matrix\r\n     */\r\n    public transpose(): Matrix {\r\n        return Matrix.Transpose(this);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of the matrix and store it in a given matrix\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    public transposeToRef(result: Matrix): Matrix {\r\n        Matrix.TransposeToRef(this, result);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the index-th row of the current matrix with the given 4 x float values\r\n     * @param index defines the row index\r\n     * @param x defines the x component to set\r\n     * @param y defines the y component to set\r\n     * @param z defines the z component to set\r\n     * @param w defines the w component to set\r\n     * @returns the updated current matrix\r\n     */\r\n    public setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix {\r\n        if (index < 0 || index > 3) {\r\n            return this;\r\n        }\r\n        var i = index * 4;\r\n        this._m[i + 0] = x;\r\n        this._m[i + 1] = y;\r\n        this._m[i + 2] = z;\r\n        this._m[i + 3] = w;\r\n\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\r\n     * @param scale defines the scale factor\r\n     * @returns a new matrix\r\n     */\r\n    public scale(scale: number): Matrix {\r\n        var result = new Matrix();\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scale the current matrix values by a factor to a given result matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    public scaleToRef(scale: number, result: Matrix): Matrix {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = this._m[index] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current matrix values by a factor and add the result to a given matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Matrix): Matrix {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] += this._m[index] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\r\n     * @param ref matrix to store the result\r\n     */\r\n    public toNormalMatrix(ref: Matrix): void {\r\n        const tmp = MathTmp.Matrix[0];\r\n        this.invertToRef(tmp);\r\n        tmp.transposeToRef(ref);\r\n        var m = ref._m;\r\n        Matrix.FromValuesToRef(\r\n            m[0], m[1], m[2], 0.0,\r\n            m[4], m[5], m[6], 0.0,\r\n            m[8], m[9], m[10], 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            ref\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets only rotation part of the current matrix\r\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\r\n     */\r\n    public getRotationMatrix(): Matrix {\r\n        var result = new Matrix();\r\n        this.getRotationMatrixToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\r\n     * @param result defines the target matrix to store data to\r\n     * @returns the current matrix\r\n     */\r\n    public getRotationMatrixToRef(result: Matrix): Matrix {\r\n        const scale = MathTmp.Vector3[0];\r\n        if (!this.decompose(scale)) {\r\n            Matrix.IdentityToRef(result);\r\n            return this;\r\n        }\r\n\r\n        const m = this._m;\r\n        const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\r\n        Matrix.FromValuesToRef(\r\n            m[0] * sx, m[1] * sx, m[2] * sx, 0.0,\r\n            m[4] * sy, m[5] * sy, m[6] * sy, 0.0,\r\n            m[8] * sz, m[9] * sz, m[10] * sz, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Toggles model matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    public toggleModelMatrixHandInPlace() {\r\n        const m = this._m;\r\n        m[2] *= -1;\r\n        m[6] *= -1;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[14] *= -1;\r\n        this._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    public toggleProjectionMatrixHandInPlace() {\r\n        var m = this._m;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[10] *= -1;\r\n        m[11] *= -1;\r\n        this._markAsUpdated();\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a matrix from an array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Matrix set from the starting index of the given array\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.FromArrayToRef(array, offset, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the content of an array into a given matrix\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number, result: Matrix) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset];\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Stores an array into a matrix after having multiplied each component by a given factor\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromFloat32ArrayToRefScaled(array: DeepImmutable<Float32Array | Array<number>>, offset: number, scale: number, result: Matrix) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Gets an identity matrix that must not be updated\r\n     */\r\n    public static get IdentityReadOnly(): DeepImmutable<Matrix> {\r\n        return Matrix._identityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Stores a list of values (16) inside a given matrix\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromValuesToRef(initialM11: number, initialM12: number, initialM13: number, initialM14: number,\r\n        initialM21: number, initialM22: number, initialM23: number, initialM24: number,\r\n        initialM31: number, initialM32: number, initialM33: number, initialM34: number,\r\n        initialM41: number, initialM42: number, initialM43: number, initialM44: number, result: Matrix): void {\r\n\r\n        const m = result._m;\r\n        m[0] = initialM11; m[1] = initialM12; m[2] = initialM13; m[3] = initialM14;\r\n        m[4] = initialM21; m[5] = initialM22; m[6] = initialM23; m[7] = initialM24;\r\n        m[8] = initialM31; m[9] = initialM32; m[10] = initialM33; m[11] = initialM34;\r\n        m[12] = initialM41; m[13] = initialM42; m[14] = initialM43; m[15] = initialM44;\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates new matrix from a list of values (16)\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @returns the new matrix\r\n     */\r\n    public static FromValues(initialM11: number, initialM12: number, initialM13: number, initialM14: number,\r\n        initialM21: number, initialM22: number, initialM23: number, initialM24: number,\r\n        initialM31: number, initialM32: number, initialM33: number, initialM34: number,\r\n        initialM41: number, initialM42: number, initialM43: number, initialM44: number): Matrix {\r\n\r\n        var result = new Matrix();\r\n        const m = result._m;\r\n        m[0] = initialM11; m[1] = initialM12; m[2] = initialM13; m[3] = initialM14;\r\n        m[4] = initialM21; m[5] = initialM22; m[6] = initialM23; m[7] = initialM24;\r\n        m[8] = initialM31; m[9] = initialM32; m[10] = initialM33; m[11] = initialM34;\r\n        m[12] = initialM41; m[13] = initialM42; m[14] = initialM43; m[15] = initialM44;\r\n        result._markAsUpdated();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @returns a new matrix\r\n     */\r\n    public static Compose(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.ComposeToRef(scale, rotation, translation, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ComposeToRef(scale: DeepImmutable<Vector3>, rotation: DeepImmutable<Quaternion>, translation: DeepImmutable<Vector3>, result: Matrix): void {\r\n        let m = result._m;\r\n        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;\r\n        var x2 = x + x, y2 = y + y, z2 = z + z;\r\n        var xx = x * x2, xy = x * y2, xz = x * z2;\r\n        var yy = y * y2, yz = y * z2, zz = z * z2;\r\n        var wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n        var sx = scale._x, sy = scale._y, sz = scale._z;\r\n\r\n        m[0] = (1 - (yy + zz)) * sx;\r\n        m[1] = (xy + wz) * sx;\r\n        m[2] = (xz - wy) * sx;\r\n        m[3] = 0;\r\n\r\n        m[4] = (xy - wz) * sy;\r\n        m[5] = (1 - (xx + zz)) * sy;\r\n        m[6] = (yz + wx) * sy;\r\n        m[7] = 0;\r\n\r\n        m[8] = (xz + wy) * sz;\r\n        m[9] = (yz - wx) * sz;\r\n        m[10] = (1 - (xx + yy)) * sz;\r\n        m[11] = 0;\r\n\r\n        m[12] = translation._x;\r\n        m[13] = translation._y;\r\n        m[14] = translation._z;\r\n        m[15] = 1;\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a new identity matrix\r\n     * @returns a new identity matrix\r\n     */\r\n    public static Identity(): Matrix {\r\n        const identity = Matrix.FromValues(\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0);\r\n        identity._updateIdentityStatus(true);\r\n        return identity;\r\n    }\r\n\r\n    /**\r\n     * Creates a new identity matrix and stores the result in a given matrix\r\n     * @param result defines the target matrix\r\n     */\r\n    public static IdentityToRef(result: Matrix): void {\r\n        Matrix.FromValuesToRef(\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n        result._updateIdentityStatus(true);\r\n    }\r\n\r\n    /**\r\n     * Creates a new zero matrix\r\n     * @returns a new zero matrix\r\n     */\r\n    public static Zero(): Matrix {\r\n        const zero = Matrix.FromValues(\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0,\r\n            0.0, 0.0, 0.0, 0.0);\r\n        zero._updateIdentityStatus(false);\r\n        return zero;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationX(angle: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.RotationXToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new matrix as the invert of a given matrix\r\n     * @param source defines the source matrix\r\n     * @returns the new matrix\r\n     */\r\n    public static Invert(source: DeepImmutable<Matrix>): Matrix {\r\n        var result = new Matrix();\r\n        source.invertToRef(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationXToRef(angle: number, result: Matrix): void {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, c, s, 0.0,\r\n            0.0, -s, c, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationY(angle: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.RotationYToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationYToRef(angle: number, result: Matrix): void {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(\r\n            c, 0.0, -s, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            s, 0.0, c, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationZ(angle: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.RotationZToRef(angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationZToRef(angle: number, result: Matrix): void {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(\r\n            c, s, 0.0, 0.0,\r\n            -s, c, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    public static RotationAxis(axis: DeepImmutable<Vector3>, angle: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.RotationAxisToRef(axis, angle, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationAxisToRef(axis: DeepImmutable<Vector3>, angle: number, result: Matrix): void {\r\n        var s = Math.sin(-angle);\r\n        var c = Math.cos(-angle);\r\n        var c1 = 1 - c;\r\n\r\n        axis.normalize();\r\n        const m = result._m;\r\n        m[0] = (axis._x * axis._x) * c1 + c;\r\n        m[1] = (axis._x * axis._y) * c1 - (axis._z * s);\r\n        m[2] = (axis._x * axis._z) * c1 + (axis._y * s);\r\n        m[3] = 0.0;\r\n\r\n        m[4] = (axis._y * axis._x) * c1 + (axis._z * s);\r\n        m[5] = (axis._y * axis._y) * c1 + c;\r\n        m[6] = (axis._y * axis._z) * c1 - (axis._x * s);\r\n        m[7] = 0.0;\r\n\r\n        m[8] = (axis._z * axis._x) * c1 - (axis._y * s);\r\n        m[9] = (axis._z * axis._y) * c1 + (axis._x * s);\r\n        m[10] = (axis._z * axis._z) * c1 + c;\r\n        m[11] = 0.0;\r\n\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = 0.0;\r\n        m[15] = 1.0;\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\r\n     * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\r\n     * @param from defines the vector to align\r\n     * @param to defines the vector to align to\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationAlignToRef(from: DeepImmutable<Vector3>, to: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const v = Vector3.Cross(to, from);\r\n        const c = Vector3.Dot(to, from);\r\n        const k = 1 / (1 + c);\r\n\r\n        const m = result._m;\r\n        m[0] = v._x * v._x * k + c; m[1] = v._y * v._x * k - v._z; m[2] = v._z * v._x * k + v._y; m[3] = 0;\r\n        m[4] = v._x * v._y * k + v._z; m[5] = v._y * v._y * k + c; m[6] = v._z * v._y * k - v._x; m[7] = 0;\r\n        m[8] = v._x * v._z * k - v._y; m[9] = v._y * v._z * k + v._x; m[10] = v._z * v._z * k + c; m[11] = 0;\r\n        m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (Z axis)\r\n     * @returns the new rotation matrix\r\n     */\r\n    public static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix and stores it in a given matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (Z axis)\r\n     * @param result defines the target matrix\r\n     */\r\n    public static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void {\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\r\n        MathTmp.Quaternion[0].toRotationMatrix(result);\r\n    }\r\n\r\n    /**\r\n     * Creates a scaling matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @returns the new matrix\r\n     */\r\n    public static Scaling(x: number, y: number, z: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.ScalingToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a scaling matrix and stores it in a given matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ScalingToRef(x: number, y: number, z: number, result: Matrix): void {\r\n        Matrix.FromValuesToRef(\r\n            x, 0.0, 0.0, 0.0,\r\n            0.0, y, 0.0, 0.0,\r\n            0.0, 0.0, z, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\r\n    }\r\n\r\n    /**\r\n     * Creates a translation matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @returns the new matrix\r\n     */\r\n    public static Translation(x: number, y: number, z: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.TranslationToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a translation matrix and stores it in a given matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static TranslationToRef(x: number, y: number, z: number, result: Matrix): void {\r\n        Matrix.FromValuesToRef(\r\n            1.0, 0.0, 0.0, 0.0,\r\n            0.0, 1.0, 0.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            x, y, z, 1.0,\r\n            result\r\n        );\r\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @returns the new matrix\r\n     */\r\n    public static Lerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @param result defines the Matrix object where to store data\r\n     */\r\n    public static LerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix): void {\r\n        const resultM = result._m;\r\n        const startM = startValue.m;\r\n        const endM = endValue.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Builds a new matrix whose values are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @returns the new matrix\r\n     */\r\n    public static DecomposeLerp(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a matrix to values which are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @param result defines the target matrix\r\n     */\r\n    public static DecomposeLerpToRef(startValue: DeepImmutable<Matrix>, endValue: DeepImmutable<Matrix>, gradient: number, result: Matrix) {\r\n        var startScale = MathTmp.Vector3[0];\r\n        var startRotation = MathTmp.Quaternion[0];\r\n        var startTranslation = MathTmp.Vector3[1];\r\n        startValue.decompose(startScale, startRotation, startTranslation);\r\n\r\n        var endScale = MathTmp.Vector3[2];\r\n        var endRotation = MathTmp.Quaternion[1];\r\n        var endTranslation = MathTmp.Vector3[3];\r\n        endValue.decompose(endScale, endRotation, endTranslation);\r\n\r\n        var resultScale = MathTmp.Vector3[4];\r\n        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\r\n        var resultRotation = MathTmp.Quaternion[2];\r\n        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\r\n\r\n        var resultTranslation = MathTmp.Vector3[5];\r\n        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\r\n\r\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    public static LookAtLH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.LookAtLHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookAtLHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n\r\n        // Z axis\r\n        target.subtractToRef(eye, zAxis);\r\n        zAxis.normalize();\r\n\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        } else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n\r\n        // Eye angles\r\n        var ex = -Vector3.Dot(xAxis, eye);\r\n        var ey = -Vector3.Dot(yAxis, eye);\r\n        var ez = -Vector3.Dot(zAxis, eye);\r\n\r\n        Matrix.FromValuesToRef(\r\n            xAxis._x, yAxis._x, zAxis._x, 0.0,\r\n            xAxis._y, yAxis._y, zAxis._y, 0.0,\r\n            xAxis._z, yAxis._z, zAxis._z, 0.0,\r\n            ex, ey, ez, 1.0,\r\n            result\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    public static LookAtRH(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.LookAtRHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    public static LookAtRHToRef(eye: DeepImmutable<Vector3>, target: DeepImmutable<Vector3>, up: DeepImmutable<Vector3>, result: Matrix): void {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n\r\n        // Z axis\r\n        eye.subtractToRef(target, zAxis);\r\n        zAxis.normalize();\r\n\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        } else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n\r\n        // Eye angles\r\n        var ex = -Vector3.Dot(xAxis, eye);\r\n        var ey = -Vector3.Dot(yAxis, eye);\r\n        var ez = -Vector3.Dot(zAxis, eye);\r\n\r\n        Matrix.FromValuesToRef(\r\n            xAxis._x, yAxis._x, zAxis._x, 0.0,\r\n            xAxis._y, yAxis._y, zAxis._y, 0.0,\r\n            xAxis._z, yAxis._z, zAxis._z, 0.0,\r\n            ex, ey, ez, 1.0,\r\n            result\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    public static OrthoLH(width: number, height: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Store a left-handed orthographic projection to a given matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    public static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix): void {\r\n        let n = znear;\r\n        let f = zfar;\r\n\r\n        let a = 2.0 / width;\r\n        let b = 2.0 / height;\r\n        let c = 2.0 / (f - n);\r\n        let d = -(f + n) / (f - n);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, c, 0.0,\r\n            0.0, 0.0, d, 1.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\r\n    }\r\n\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    public static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    public static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void {\r\n        let n = znear;\r\n        let f = zfar;\r\n\r\n        let a = 2.0 / (right - left);\r\n        let b = 2.0 / (top - bottom);\r\n        let c = 2.0 / (f - n);\r\n        let d = -(f + n) / (f - n);\r\n        let i0 = (left + right) / (left - right);\r\n        let i1 = (top + bottom) / (bottom - top);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, c, 0.0,\r\n            i0, i1, d, 1.0,\r\n            result\r\n        );\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Creates a right-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a right-handed orthographic projection matrix\r\n     */\r\n    public static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    public static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void {\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\r\n        result._m[10] *= -1; // No need to call _markAsUpdated as previous function already called it and let _isIdentityDirty to true\r\n    }\r\n\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveLH(width: number, height: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n\r\n        let n = znear;\r\n        let f = zfar;\r\n\r\n        let a = 2.0 * n / width;\r\n        let b = 2.0 * n / height;\r\n        let c = (f + n) / (f - n);\r\n        let d = -2.0 * f * n / (f - n);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, c, 1.0,\r\n            0.0, 0.0, d, 0.0,\r\n            matrix\r\n        );\r\n\r\n        matrix._updateIdentityStatus(false);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveFovLH(fov: number, aspect: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    public static PerspectiveFovLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed = true): void {\r\n        let n = znear;\r\n        let f = zfar;\r\n\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n        let c = (f + n) / (f - n);\r\n        let d = -2.0 * f * n / (f - n);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, c, 1.0,\r\n            0.0, 0.0, d, 0.0,\r\n            result\r\n        );\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a left-handed perspective projection into a given matrix with depth reversed\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar not used as infinity is used as far clip\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    public static PerspectiveFovReverseLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed = true): void {\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, -znear, 1.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            result\r\n        );\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Creates a right-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a right-handed perspective projection matrix\r\n     */\r\n    public static PerspectiveFovRH(fov: number, aspect: number, znear: number, zfar: number): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    public static PerspectiveFovRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed = true): void {\r\n        //alternatively this could be expressed as:\r\n        //    m = PerspectiveFovLHToRef\r\n        //    m[10] *= -1.0;\r\n        //    m[11] *= -1.0;\r\n\r\n        let n = znear;\r\n        let f = zfar;\r\n\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n        let c = -(f + n) / (f - n);\r\n        let d = -2 * f * n / (f - n);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, c, -1.0,\r\n            0.0, 0.0, d, 0.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a right-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar not used as infinity is used as far clip\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    public static PerspectiveFovReverseRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed = true): void {\r\n        //alternatively this could be expressed as:\r\n        //    m = PerspectiveFovLHToRef\r\n        //    m[10] *= -1.0;\r\n        //    m[11] *= -1.0;\r\n\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n\r\n        Matrix.FromValuesToRef(\r\n            a, 0.0, 0.0, 0.0,\r\n            0.0, b, 0.0, 0.0,\r\n            0.0, 0.0, -znear, -1.0,\r\n            0.0, 0.0, -1.0, 0.0,\r\n            result\r\n        );\r\n\r\n        result._updateIdentityStatus(false);\r\n    }\r\n\r\n    /**\r\n     * Stores a perspective projection for WebVR info a given matrix\r\n     * @param fov defines the field of view\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\r\n     */\r\n    public static PerspectiveFovWebVRToRef(fov: { upDegrees: number, downDegrees: number, leftDegrees: number, rightDegrees: number }, znear: number, zfar: number, result: Matrix, rightHanded = false): void {\r\n\r\n        var rightHandedFactor = rightHanded ? -1 : 1;\r\n\r\n        var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\r\n        var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\r\n        var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\r\n        var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\r\n        var xScale = 2.0 / (leftTan + rightTan);\r\n        var yScale = 2.0 / (upTan + downTan);\r\n        const m = result._m;\r\n        m[0] = xScale;\r\n        m[1] = m[2] = m[3] = m[4] = 0.0;\r\n        m[5] = yScale;\r\n        m[6] = m[7] = 0.0;\r\n        m[8] = ((leftTan - rightTan) * xScale * 0.5);\r\n        m[9] = -((upTan - downTan) * yScale * 0.5);\r\n        m[10] = -zfar / (znear - zfar);\r\n        m[11] = 1.0 * rightHandedFactor;\r\n        m[12] = m[13] = m[15] = 0.0;\r\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\r\n\r\n        result._markAsUpdated();\r\n    }\r\n\r\n    /**\r\n     * Computes a complete transformation matrix\r\n     * @param viewport defines the viewport to use\r\n     * @param world defines the world matrix\r\n     * @param view defines the view matrix\r\n     * @param projection defines the projection matrix\r\n     * @param zmin defines the near clip plane\r\n     * @param zmax defines the far clip plane\r\n     * @returns the transformation matrix\r\n     */\r\n    public static GetFinalMatrix(viewport: DeepImmutable<Viewport>, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>, zmin: number, zmax: number): Matrix {\r\n        var cw = viewport.width;\r\n        var ch = viewport.height;\r\n        var cx = viewport.x;\r\n        var cy = viewport.y;\r\n\r\n        var viewportMatrix = Matrix.FromValues(\r\n            cw / 2.0, 0.0, 0.0, 0.0,\r\n            0.0, -ch / 2.0, 0.0, 0.0,\r\n            0.0, 0.0, zmax - zmin, 0.0,\r\n            cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\r\n\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        return matrix.multiply(viewportMatrix);\r\n    }\r\n\r\n    /**\r\n     * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\r\n     */\r\n    public static GetAsMatrix2x2(matrix: DeepImmutable<Matrix>): Float32Array | Array<number> {\r\n        const m = matrix.m;\r\n        const arr = [m[0], m[1], m[4], m[5]];\r\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\r\n    }\r\n    /**\r\n     * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\r\n     */\r\n    public static GetAsMatrix3x3(matrix: DeepImmutable<Matrix>): Float32Array | Array<number> {\r\n        const m = matrix.m;\r\n        const arr = [\r\n            m[0], m[1], m[2],\r\n            m[4], m[5], m[6],\r\n            m[8], m[9], m[10]\r\n        ];\r\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of a given matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @returns the new matrix\r\n     */\r\n    public static Transpose(matrix: DeepImmutable<Matrix>): Matrix {\r\n        var result = new Matrix();\r\n        Matrix.TransposeToRef(matrix, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Compute the transpose of a matrix and store it in a target matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @param result defines the target matrix\r\n     */\r\n    public static TransposeToRef(matrix: DeepImmutable<Matrix>, result: Matrix): void {\r\n        const rm = result._m;\r\n        const mm = matrix.m;\r\n        rm[0] = mm[0];\r\n        rm[1] = mm[4];\r\n        rm[2] = mm[8];\r\n        rm[3] = mm[12];\r\n\r\n        rm[4] = mm[1];\r\n        rm[5] = mm[5];\r\n        rm[6] = mm[9];\r\n        rm[7] = mm[13];\r\n\r\n        rm[8] = mm[2];\r\n        rm[9] = mm[6];\r\n        rm[10] = mm[10];\r\n        rm[11] = mm[14];\r\n\r\n        rm[12] = mm[3];\r\n        rm[13] = mm[7];\r\n        rm[14] = mm[11];\r\n        rm[15] = mm[15];\r\n        // identity-ness does not change when transposing\r\n        result._updateIdentityStatus((matrix as Matrix)._isIdentity, (matrix as Matrix)._isIdentityDirty);\r\n    }\r\n\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @returns a new matrix\r\n     */\r\n    public static Reflection(plane: DeepImmutable<IPlaneLike>): Matrix {\r\n        var matrix = new Matrix();\r\n        Matrix.ReflectionToRef(plane, matrix);\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @param result defines the target matrix\r\n     */\r\n    public static ReflectionToRef(plane: DeepImmutable<IPlaneLike>, result: Matrix): void {\r\n        plane.normalize();\r\n        var x = plane.normal.x;\r\n        var y = plane.normal.y;\r\n        var z = plane.normal.z;\r\n        var temp = -2 * x;\r\n        var temp2 = -2 * y;\r\n        var temp3 = -2 * z;\r\n        Matrix.FromValuesToRef(\r\n            temp * x + 1, temp2 * x, temp3 * x, 0.0,\r\n            temp * y, temp2 * y + 1, temp3 * y, 0.0,\r\n            temp * z, temp2 * z, temp3 * z + 1, 0.0,\r\n            temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0,\r\n            result\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\r\n     * @param xaxis defines the value of the 1st axis\r\n     * @param yaxis defines the value of the 2nd axis\r\n     * @param zaxis defines the value of the 3rd axis\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromXYZAxesToRef(xaxis: DeepImmutable<Vector3>, yaxis: DeepImmutable<Vector3>, zaxis: DeepImmutable<Vector3>, result: Matrix) {\r\n        Matrix.FromValuesToRef(\r\n            xaxis._x, xaxis._y, xaxis._z, 0.0,\r\n            yaxis._x, yaxis._y, yaxis._z, 0.0,\r\n            zaxis._x, zaxis._y, zaxis._z, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            result\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\r\n     * @param quat defines the quaternion to use\r\n     * @param result defines the target matrix\r\n     */\r\n    public static FromQuaternionToRef(quat: DeepImmutable<Quaternion>, result: Matrix) {\r\n        var xx = quat._x * quat._x;\r\n        var yy = quat._y * quat._y;\r\n        var zz = quat._z * quat._z;\r\n        var xy = quat._x * quat._y;\r\n        var zw = quat._z * quat._w;\r\n        var zx = quat._z * quat._x;\r\n        var yw = quat._y * quat._w;\r\n        var yz = quat._y * quat._z;\r\n        var xw = quat._x * quat._w;\r\n\r\n        result._m[0] = 1.0 - (2.0 * (yy + zz));\r\n        result._m[1] = 2.0 * (xy + zw);\r\n        result._m[2] = 2.0 * (zx - yw);\r\n        result._m[3] = 0.0;\r\n\r\n        result._m[4] = 2.0 * (xy - zw);\r\n        result._m[5] = 1.0 - (2.0 * (zz + xx));\r\n        result._m[6] = 2.0 * (yz + xw);\r\n        result._m[7] = 0.0;\r\n\r\n        result._m[8] = 2.0 * (zx + yw);\r\n        result._m[9] = 2.0 * (yz - xw);\r\n        result._m[10] = 1.0 - (2.0 * (yy + xx));\r\n        result._m[11] = 0.0;\r\n\r\n        result._m[12] = 0.0;\r\n        result._m[13] = 0.0;\r\n        result._m[14] = 0.0;\r\n        result._m[15] = 1.0;\r\n\r\n        result._markAsUpdated();\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\r\n */\r\nclass MathTmp {\r\n    public static Vector3: Vector3[] = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    public static Matrix: Matrix[] = ArrayTools.BuildArray(2, Matrix.Identity);\r\n    public static Quaternion: Quaternion[] = ArrayTools.BuildArray(3, Quaternion.Zero);\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class TmpVectors {\r\n    public static Vector2: Vector2[] = ArrayTools.BuildArray(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\r\n    public static Vector3: Vector3[] = ArrayTools.BuildArray(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\r\n    public static Vector4: Vector4[] = ArrayTools.BuildArray(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\r\n    public static Quaternion: Quaternion[] = ArrayTools.BuildArray(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\r\n    public static Matrix: Matrix[] = ArrayTools.BuildArray(8, Matrix.Identity); // 8 temp Matrices at once should be enough\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.Vector2\"] = Vector2;\r\n_TypeStore.RegisteredTypes[\"BABYLON.Vector3\"] = Vector3;\r\n_TypeStore.RegisteredTypes[\"BABYLON.Vector4\"] = Vector4;\r\n_TypeStore.RegisteredTypes[\"BABYLON.Matrix\"] = Matrix;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}