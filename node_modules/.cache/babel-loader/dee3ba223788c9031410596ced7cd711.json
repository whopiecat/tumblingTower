{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { Scene } from \"../scene\";\nimport { Ray } from \"../Culling/ray\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { ActionEvent } from \"../Actions/actionEvent\";\n\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n\n      if (!result || !result.hit) {\n        continue;\n      }\n\n      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        continue;\n      }\n\n      pickingInfo = result;\n\n      if (fastCheck) {\n        break;\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  if (this.spriteManagers.length > 0) {\n    for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      var spriteManager = this.spriteManagers[spriteIndex];\n\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n\n      var results = spriteManager.multiIntersects(ray, camera, predicate);\n\n      if (results !== null) {\n        pickingInfos = pickingInfos.concat(results);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n};\n\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n};\n\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\n\nScene.prototype.setPointerOverSprite = function (sprite) {\n  if (this._pointerOverSprite === sprite) {\n    return;\n  }\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n\n  this._pointerOverSprite = sprite;\n\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n};\n\nScene.prototype.getPointerOverSprite = function () {\n  return this._pointerOverSprite;\n};\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\n\n\nvar SpriteSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function SpriteSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_SPRITE;\n    this.scene = scene;\n    this.scene.spriteManagers = new Array();\n    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n    this.scene.onBeforeSpritesRenderingObservable = new Observable();\n    this.scene.onAfterSpritesRenderingObservable = new Observable();\n\n    this._spritePredicate = function (sprite) {\n      if (!sprite.actionManager) {\n        return false;\n      }\n\n      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n    };\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  SpriteSceneComponent.prototype.register = function () {\n    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n\n    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n\n    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  SpriteSceneComponent.prototype.rebuild = function () {\n    /** Nothing to do for sprites */\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  SpriteSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforeSpritesRenderingObservable.clear();\n    this.scene.onAfterSpritesRenderingObservable.clear();\n    var spriteManagers = this.scene.spriteManagers;\n\n    while (spriteManagers.length) {\n      spriteManagers[0].dispose();\n    }\n  };\n\n  SpriteSceneComponent.prototype._pickSpriteButKeepRay = function (originalPointerInfo, x, y, fastCheck, camera) {\n    var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n\n    if (result) {\n      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n    }\n\n    return result;\n  };\n\n  SpriteSceneComponent.prototype._pointerMove = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n    var scene = this.scene;\n\n    if (isMeshPicked) {\n      scene.setPointerOverSprite(null);\n    } else {\n      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        scene.setPointerOverSprite(pickResult.pickedSprite);\n\n        if (!scene.doNotHandleCursors) {\n          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n          } else {\n            element.style.cursor = scene.hoverCursor;\n          }\n        }\n      } else {\n        scene.setPointerOverSprite(null);\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerDown = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n    scene._pickedDownSprite = null;\n\n    if (scene.spriteManagers.length > 0) {\n      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        if (pickResult.pickedSprite.actionManager) {\n          scene._pickedDownSprite = pickResult.pickedSprite;\n\n          switch (evt.button) {\n            case 0:\n              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 1:\n              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n\n            case 2:\n              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n          }\n\n          if (pickResult.pickedSprite.actionManager) {\n            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n          }\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  SpriteSceneComponent.prototype._pointerUp = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    var scene = this.scene;\n\n    if (scene.spriteManagers.length > 0) {\n      var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n\n      if (spritePickResult) {\n        if (spritePickResult.hit && spritePickResult.pickedSprite) {\n          if (spritePickResult.pickedSprite.actionManager) {\n            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n\n            if (spritePickResult.pickedSprite.actionManager) {\n              if (!this.scene._inputManager._isPointerSwiping()) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n            }\n          }\n        }\n\n        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n        }\n      }\n    }\n\n    return pickResult;\n  };\n\n  return SpriteSceneComponent;\n}();\n\nexport { SpriteSceneComponent };","map":{"version":3,"sources":["../../../sourceES6/core/Sprites/spriteSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { ISpriteManager } from \"./spriteManager\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\n\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _pointerOverSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _pickedDownSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _tempSpritePickingRay: Nullable<Ray>;\r\n\r\n        /**\r\n         * All of the sprite managers added to this scene\r\n         * @see https://doc.babylonjs.com/babylon101/sprites\r\n         */\r\n        spriteManagers: Array<ISpriteManager>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is about to start\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onBeforeSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is done\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onAfterSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /** @hidden */\r\n        _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Launch a ray to try to pick a sprite in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Use the given ray to pick a sprite in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** @hidden */\r\n        _internalMultiPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Launch a ray to try to pick sprites in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /** Use the given ray to pick sprites in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo array\r\n         */\r\n        multiPickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]>;\r\n\r\n        /**\r\n         * Force the sprite under the pointer\r\n         * @param sprite defines the sprite to use\r\n         */\r\n        setPointerOverSprite(sprite: Nullable<Sprite>): void;\r\n\r\n        /**\r\n         * Gets the sprite under the pointer\r\n         * @returns a Sprite or null if no sprite is under the pointer\r\n         */\r\n        getPointerOverSprite(): Nullable<Sprite>;\r\n    }\r\n}\r\n\r\nScene.prototype._internalPickSprites = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    var pickingInfo = null;\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers.length > 0) {\r\n        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            var spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\r\n            if (!result || !result.hit) {\r\n                continue;\r\n            }\r\n\r\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n                continue;\r\n            }\r\n\r\n            pickingInfo = result;\r\n\r\n            if (fastCheck) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPickSprites = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    var pickingInfos = new Array<PickingInfo>();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers.length > 0) {\r\n        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            var spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            var results = spriteManager.multiIntersects(ray, camera, predicate);\r\n\r\n             if (results !== null) {\r\n                 pickingInfos = pickingInfos.concat(results);\r\n             }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickSprite = function(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\r\n\r\n    return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.pickSpriteWithRay = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.multiPickSprite = function(x: number, y: number, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay!, camera);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay!, predicate, camera);\r\n};\r\n\r\nScene.prototype.multiPickSpriteWithRay = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, camera?: Camera): Nullable<PickingInfo[]> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\r\n};\r\n\r\nScene.prototype.setPointerOverSprite = function(sprite: Nullable<Sprite>): void {\r\n    if (this._pointerOverSprite === sprite) {\r\n        return;\r\n    }\r\n\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n\r\n    this._pointerOverSprite = sprite;\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n};\r\n\r\nScene.prototype.getPointerOverSprite = function(): Nullable<Sprite> {\r\n    return this._pointerOverSprite;\r\n};\r\n\r\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\r\nexport class SpriteSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SPRITE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /** @hidden */\r\n    private _spritePredicate: (sprite: Sprite) => boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.spriteManagers = new Array<ISpriteManager>();\r\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\r\n        this.scene.onBeforeSpritesRenderingObservable = new Observable<Scene>();\r\n        this.scene.onAfterSpritesRenderingObservable = new Observable<Scene>();\r\n        this._spritePredicate = (sprite: Sprite): boolean => {\r\n            if (!sprite.actionManager) {\r\n                return false;\r\n            }\r\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\r\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\r\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        /** Nothing to do for sprites */\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforeSpritesRenderingObservable.clear();\r\n        this.scene.onAfterSpritesRenderingObservable.clear();\r\n\r\n        let spriteManagers = this.scene.spriteManagers;\r\n        while (spriteManagers.length) {\r\n            spriteManagers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _pickSpriteButKeepRay(originalPointerInfo: Nullable<PickingInfo>, x: number, y: number, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n        var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\r\n        if (result) {\r\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _pointerMove(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, isMeshPicked: boolean, element: HTMLElement): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverSprite(null);\r\n        } else {\r\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                scene.setPointerOverSprite(pickResult.pickedSprite);\r\n                if (!scene.doNotHandleCursors) {\r\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\r\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\r\n                    } else {\r\n                        element.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            } else {\r\n                scene.setPointerOverSprite(null);\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerDown(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: PointerEvent): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        scene._pickedDownSprite = null;\r\n        if (scene.spriteManagers.length > 0) {\r\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                if (pickResult.pickedSprite.actionManager) {\r\n                    scene._pickedDownSprite = pickResult.pickedSprite;\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                        case 1:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                        case 2:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                    }\r\n                    if (pickResult.pickedSprite.actionManager) {\r\n                        pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerUp(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: PointerEvent): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        if (scene.spriteManagers.length > 0) {\r\n            let spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (spritePickResult) {\r\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\r\n                    if (spritePickResult.pickedSprite.actionManager) {\r\n                        spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\r\n                        if (spritePickResult.pickedSprite.actionManager) {\r\n                            if (!this.scene._inputManager._isPointerSwiping()) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\r\n                    scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}