{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Tools } from \"../../Misc/tools\";\nvar anchorIdProvider = 0;\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\n\nvar WebXRAnchorSystem =\n/** @class */\nfunction (_super) {\n  __extends(WebXRAnchorSystem, _super);\n  /**\r\n   * constructs a new anchor system\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param _options configuration object for this feature\r\n   */\n\n\n  function WebXRAnchorSystem(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._lastFrameDetected = new Set();\n    _this._trackedAnchors = [];\n    _this._futureAnchors = [];\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\n\n    _this.onAnchorAddedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\n\n    _this.onAnchorRemovedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\n\n    _this.onAnchorUpdatedObservable = new Observable();\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    _this.xrNativeFeatureName = \"anchors\";\n    return _this;\n  }\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"referenceSpaceForFrameAnchors\", {\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\n    set: function (referenceSpace) {\n      this._referenceSpaceForFrameAnchors = referenceSpace;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRAnchorSystem.prototype._populateTmpTransformation = function (position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  };\n  /**\r\n   * Create a new anchor point using a hit test result at a specific point in the scene\r\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n   *\r\n   * @param hitTestResult The hit test result to use for this anchor creation\r\n   * @param position an optional position offset for this anchor\r\n   * @param rotationQuaternion an optional rotation offset for this anchor\r\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorPointUsingHitTestResultAsync = function (hitTestResult, position, rotationQuaternion) {\n    if (position === void 0) {\n      position = new Vector3();\n    }\n\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var m, nativeAnchor_1, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            m = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!!hitTestResult.xrHitResult.createAnchor) return [3\n            /*break*/\n            , 1];\n            this.detach();\n            throw new Error(\"Anchors not enabled in this environment/browser\");\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , hitTestResult.xrHitResult.createAnchor(m)];\n\n          case 2:\n            nativeAnchor_1 = _a.sent();\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: nativeAnchor_1,\n                resolved: false,\n                submitted: true,\n                xrTransformation: m,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n\n          case 3:\n            error_1 = _a.sent();\n            throw new Error(error_1);\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add a new anchor at a specific position and rotation\r\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n   *\r\n   * @param position the position in which to add an anchor\r\n   * @param rotationQuaternion an optional rotation for the anchor transformation\r\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n   */\n\n\n  WebXRAnchorSystem.prototype.addAnchorAtPositionAndRotationAsync = function (position, rotationQuaternion, forceCreateInCurrentFrame) {\n    if (rotationQuaternion === void 0) {\n      rotationQuaternion = new Quaternion();\n    }\n\n    if (forceCreateInCurrentFrame === void 0) {\n      forceCreateInCurrentFrame = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var xrTransformation, xrAnchor, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            // convert to XR space (right handed) if needed\n            this._populateTmpTransformation(position, rotationQuaternion);\n\n            xrTransformation = new XRRigidTransform({\n              x: this._tmpVector.x,\n              y: this._tmpVector.y,\n              z: this._tmpVector.z\n            }, {\n              x: this._tmpQuaternion.x,\n              y: this._tmpQuaternion.y,\n              z: this._tmpQuaternion.z,\n              w: this._tmpQuaternion.w\n            });\n            if (!(forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _a = undefined;\n            _b.label = 3;\n\n          case 3:\n            xrAnchor = _a; // add the transformation to the future anchors list\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              _this._futureAnchors.push({\n                nativeAnchor: xrAnchor,\n                resolved: false,\n                submitted: false,\n                xrTransformation: xrTransformation,\n                resolve: resolve,\n                reject: reject\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(WebXRAnchorSystem.prototype, \"anchors\", {\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\n    get: function () {\n      return this._trackedAnchors;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n  WebXRAnchorSystem.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        var toRemove = this._trackedAnchors.pop();\n\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {// no-op\n          } // as the xr frame loop is removed, we need to notify manually\n\n\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRAnchorSystem.prototype.dispose = function () {\n    this._futureAnchors.length = 0;\n\n    _super.prototype.dispose.call(this);\n\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  };\n\n  WebXRAnchorSystem.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    if (!this.attached || !frame) {\n      return;\n    }\n\n    var trackedAnchors = frame.trackedAnchors;\n\n    if (trackedAnchors) {\n      var toRemove = this._trackedAnchors.filter(function (anchor) {\n        return !trackedAnchors.has(anchor.xrAnchor);\n      }).map(function (anchor) {\n        var index = _this._trackedAnchors.indexOf(anchor);\n\n        return index;\n      });\n\n      var idxTracker_1 = 0;\n      toRemove.forEach(function (index) {\n        var anchor = _this._trackedAnchors.splice(index - idxTracker_1, 1)[0];\n\n        _this.onAnchorRemovedObservable.notifyObservers(anchor);\n\n        idxTracker_1++;\n      }); // now check for new ones\n\n      trackedAnchors.forEach(function (xrAnchor) {\n        if (!_this._lastFrameDetected.has(xrAnchor)) {\n          var newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: xrAnchor.delete\n          };\n\n          var anchor = _this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n\n          _this._trackedAnchors.push(anchor);\n\n          _this.onAnchorAddedObservable.notifyObservers(anchor); // search for the future anchor promise that matches this\n\n\n          var results = _this._futureAnchors.filter(function (futureAnchor) {\n            return futureAnchor.nativeAnchor === xrAnchor;\n          });\n\n          var result = results[0];\n\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          var index = _this._findIndexInAnchorArray(xrAnchor);\n\n          var anchor = _this._trackedAnchors[index];\n\n          try {\n            // anchors update every frame\n            _this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n\n            _this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(\"Anchor could not be updated\");\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    } // process future anchors\n\n\n    this._futureAnchors.forEach(function (futureAnchor) {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        _this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(function (nativeAnchor) {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, function (error) {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n\n        futureAnchor.submitted = true;\n      }\n    });\n  };\n  /**\r\n   * avoiding using Array.find for global support.\r\n   * @param xrAnchor the plane to find in the array\r\n   */\n\n\n  WebXRAnchorSystem.prototype._findIndexInAnchorArray = function (xrAnchor) {\n    for (var i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  WebXRAnchorSystem.prototype._updateAnchorWithXRFrame = function (xrAnchor, anchor, xrFrame) {\n    // matrix\n    var pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n\n    if (pose) {\n      var mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n\n      anchor.transformationMatrix = mat;\n\n      if (!this._options.worldParentNode) {// Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n\n    return anchor;\n  };\n\n  WebXRAnchorSystem.prototype._createAnchorAtTransformation = function (xrTransformation, xrFrame) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        if (xrFrame.createAnchor) {\n          try {\n            return [2\n            /*return*/\n            , xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace)];\n          } catch (error) {\n            throw new Error(error);\n          }\n        } else {\n          this.detach();\n          throw new Error(\"Anchors are not enabled in your browser\");\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRAnchorSystem.Version = 1;\n  return WebXRAnchorSystem;\n}(WebXRAbstractFeature);\n\nexport { WebXRAnchorSystem }; // register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRAnchorSystem(xrSessionManager, options);\n  };\n}, WebXRAnchorSystem.Version);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRAnchorSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { IWebXRHitResult } from \"./WebXRHitTest\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created anchors will be kept until the next session starts\r\n     * If not defined, anchors will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveAnchorsOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n\r\n    /**\r\n     * if defined, this object will be constantly updated by the anchor's position and rotation\r\n     */\r\n    attachedNode?: TransformNode;\r\n\r\n    /**\r\n     * Remove this anchor from the scene\r\n     */\r\n    remove(): void;\r\n}\r\n\r\n/**\r\n * An internal interface for a future (promise based) anchor\r\n */\r\ninterface IWebXRFutureAnchor {\r\n    /**\r\n     * The native anchor\r\n     */\r\n    nativeAnchor?: XRAnchor;\r\n    /**\r\n     * Was this request submitted to the xr frame?\r\n     */\r\n    submitted: boolean;\r\n    /**\r\n     * Was this promise resolved already?\r\n     */\r\n    resolved: boolean;\r\n    /**\r\n     * A resolve function\r\n     */\r\n    resolve: (xrAnchor: IWebXRAnchor) => void;\r\n    /**\r\n     * A reject function\r\n     */\r\n    reject: (msg?: string) => void;\r\n    /**\r\n     * The XR Transformation of the future anchor\r\n     */\r\n    xrTransformation: XRRigidTransform;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    private _referenceSpaceForFrameAnchors: XRReferenceSpace;\r\n\r\n    private _futureAnchors: IWebXRFutureAnchor[] = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\r\n    public set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace) {\r\n        this._referenceSpaceForFrameAnchors = referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRAnchorSystemOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"anchors\";\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    private _populateTmpTransformation(position: Vector3, rotationQuaternion: Quaternion) {\r\n        this._tmpVector.copyFrom(position);\r\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\r\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n            this._tmpVector.z *= -1;\r\n            this._tmpQuaternion.z *= -1;\r\n            this._tmpQuaternion.w *= -1;\r\n        }\r\n        return {\r\n            position: this._tmpVector,\r\n            rotationQuaternion: this._tmpQuaternion,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a new anchor point using a hit test result at a specific point in the scene\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param hitTestResult The hit test result to use for this anchor creation\r\n     * @param position an optional position offset for this anchor\r\n     * @param rotationQuaternion an optional rotation offset for this anchor\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorPointUsingHitTestResultAsync(hitTestResult: IWebXRHitResult, position: Vector3 = new Vector3(), rotationQuaternion: Quaternion = new Quaternion()): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const m = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });\r\n        if (!hitTestResult.xrHitResult.createAnchor) {\r\n            this.detach();\r\n            throw new Error(\"Anchors not enabled in this environment/browser\");\r\n        } else {\r\n            try {\r\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\r\n                return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n                    this._futureAnchors.push({\r\n                        nativeAnchor,\r\n                        resolved: false,\r\n                        submitted: true,\r\n                        xrTransformation: m,\r\n                        resolve,\r\n                        reject,\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new anchor at a specific position and rotation\r\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param position the position in which to add an anchor\r\n     * @param rotationQuaternion an optional rotation for the anchor transformation\r\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorAtPositionAndRotationAsync(position: Vector3, rotationQuaternion: Quaternion = new Quaternion(), forceCreateInCurrentFrame = false): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const xrTransformation = new XRRigidTransform({ x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z }, { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w });\r\n        const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame) : undefined;\r\n        // add the transformation to the future anchors list\r\n        return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n            this._futureAnchors.push({\r\n                nativeAnchor: xrAnchor,\r\n                resolved: false,\r\n                submitted: false,\r\n                xrTransformation,\r\n                resolve,\r\n                reject,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\r\n    public get anchors(): IWebXRAnchor[] {\r\n        return this._trackedAnchors;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\r\n            while (this._trackedAnchors.length) {\r\n                const toRemove = this._trackedAnchors.pop();\r\n                if (toRemove) {\r\n                    try {\r\n                        // try to natively remove it as well\r\n                        toRemove.remove();\r\n                    } catch (e) {\r\n                        // no-op\r\n                    }\r\n                    // as the xr frame loop is removed, we need to notify manually\r\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._futureAnchors.length = 0;\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors) {\r\n            const toRemove = this._trackedAnchors\r\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\r\n                .map((anchor) => {\r\n                    const index = this._trackedAnchors.indexOf(anchor);\r\n                    return index;\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor,\r\n                        remove: xrAnchor.delete,\r\n                    };\r\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(anchor);\r\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\r\n                    // search for the future anchor promise that matches this\r\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\r\n                    const result = results[0];\r\n                    if (result) {\r\n                        result.resolve(anchor);\r\n                        result.resolved = true;\r\n                    }\r\n                } else {\r\n                    let index = this._findIndexInAnchorArray(xrAnchor);\r\n                    const anchor = this._trackedAnchors[index];\r\n                    try {\r\n                        // anchors update every frame\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        if (anchor.attachedNode) {\r\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\r\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\r\n                        }\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    } catch (e) {\r\n                        Tools.Warn(`Anchor could not be updated`);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n\r\n        // process future anchors\r\n        this._futureAnchors.forEach((futureAnchor) => {\r\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\r\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(\r\n                    (nativeAnchor) => {\r\n                        futureAnchor.nativeAnchor = nativeAnchor;\r\n                    },\r\n                    (error) => {\r\n                        futureAnchor.resolved = true;\r\n                        futureAnchor.reject(error);\r\n                    }\r\n                );\r\n                futureAnchor.submitted = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n\r\n    private async _createAnchorAtTransformation(xrTransformation: XRRigidTransform, xrFrame: XRFrame) {\r\n        if (xrFrame.createAnchor) {\r\n            try {\r\n                return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        } else {\r\n            this.detach();\r\n            throw new Error(\"Anchors are not enabled in your browser\");\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRAnchorSystem.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n    },\r\n    WebXRAnchorSystem.Version\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}