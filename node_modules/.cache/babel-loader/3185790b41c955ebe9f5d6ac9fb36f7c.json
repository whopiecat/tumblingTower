{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine\";\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\n\nThinEngine.prototype.updateVideoTexture = function (texture, video, invertY) {\n  if (!texture || texture._isDisabled) {\n    return;\n  }\n\n  var wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n  this._unpackFlipY(!invertY); // Video are upside down by default\n\n\n  try {\n    // Testing video texture support\n    if (this._videoTextureSupported === undefined) {\n      // clear old errors just in case.\n      this._gl.getError();\n\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n\n      if (this._gl.getError() !== 0) {\n        this._videoTextureSupported = false;\n      } else {\n        this._videoTextureSupported = true;\n      }\n    } // Copy video through the current working canvas if video texture is not supported\n\n\n    if (!this._videoTextureSupported) {\n      if (!texture._workingCanvas) {\n        texture._workingCanvas = CanvasGenerator.CreateCanvas(texture.width, texture.height);\n\n        var context = texture._workingCanvas.getContext(\"2d\");\n\n        if (!context) {\n          throw new Error(\"Unable to get 2d context\");\n        }\n\n        texture._workingContext = context;\n        texture._workingCanvas.width = texture.width;\n        texture._workingCanvas.height = texture.height;\n      }\n\n      texture._workingContext.clearRect(0, 0, texture.width, texture.height);\n\n      texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\n\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas);\n    } else {\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n    }\n\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(this._gl.TEXTURE_2D);\n    }\n\n    if (!wasPreviouslyBound) {\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n    } //    this.resetTextureCache();\n\n\n    texture.isReady = true;\n  } catch (ex) {\n    // Something unexpected\n    // Let's disable the texture\n    texture._isDisabled = true;\n  }\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Extensions/engine.videoTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture } from '../../Materials/Textures/internalTexture';\r\nimport { Nullable } from '../../types';\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateVideoTexture = function(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    var wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(!invertY); // Video are upside down by default\r\n\r\n    try {\r\n        // Testing video texture support\r\n        if (this._videoTextureSupported === undefined) {\r\n            // clear old errors just in case.\r\n            this._gl.getError();\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\r\n\r\n            if (this._gl.getError() !== 0) {\r\n                this._videoTextureSupported = false;\r\n            } else {\r\n                this._videoTextureSupported = true;\r\n            }\r\n        }\r\n\r\n        // Copy video through the current working canvas if video texture is not supported\r\n        if (!this._videoTextureSupported) {\r\n            if (!texture._workingCanvas) {\r\n                texture._workingCanvas = CanvasGenerator.CreateCanvas(texture.width, texture.height);\r\n                let context = texture._workingCanvas.getContext(\"2d\");\r\n\r\n                if (!context) {\r\n                    throw new Error(\"Unable to get 2d context\");\r\n                }\r\n\r\n                texture._workingContext = context;\r\n                texture._workingCanvas.width = texture.width;\r\n                texture._workingCanvas.height = texture.height;\r\n            }\r\n\r\n            texture._workingContext!.clearRect(0, 0, texture.width, texture.height);\r\n            texture._workingContext!.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas);\r\n        } else {\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n        }\r\n\r\n        if (!wasPreviouslyBound) {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n        }\r\n        //    this.resetTextureCache();\r\n        texture.isReady = true;\r\n\r\n    } catch (ex) {\r\n        // Something unexpected\r\n        // Let's disable the texture\r\n        texture._isDisabled = true;\r\n    }\r\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}