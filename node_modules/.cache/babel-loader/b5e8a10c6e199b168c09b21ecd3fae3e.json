{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\n\nvar MeshExploder =\n/** @class */\nfunction () {\n  /**\r\n   * Explodes meshes from a center mesh.\r\n   * @param meshes The meshes to explode.\r\n   * @param centerMesh The mesh to be center of explosion.\r\n   */\n  function MeshExploder(meshes, centerMesh) {\n    this._meshesOrigins = [];\n    this._toCenterVectors = [];\n    this._scaledDirection = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    this._centerPosition = Vector3.Zero();\n    this._meshes = meshes.slice();\n\n    if (centerMesh) {\n      this._centerMesh = centerMesh;\n    } else {\n      this._setCenterMesh();\n    }\n\n    var centerMeshIndex = this._meshes.indexOf(this._centerMesh);\n\n    if (centerMeshIndex >= 0) {\n      this._meshes.splice(centerMeshIndex, 1);\n    }\n\n    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\n        this._toCenterVectors[index] = Vector3.Zero();\n\n        if (mesh._boundingInfo && this._centerMesh._boundingInfo) {\n          mesh._boundingInfo.boundingBox.centerWorld.subtractToRef(this._centerMesh._boundingInfo.boundingBox.centerWorld, this._toCenterVectors[index]);\n        }\n      }\n    }\n  }\n\n  MeshExploder.prototype._setCenterMesh = function () {\n    var averageCenter = Vector3.Zero();\n    var totalCenters = Vector3.Zero();\n    var shortestToCenter = Number.MAX_VALUE;\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        var boundingInfo = mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\n        }\n      }\n    }\n\n    averageCenter = totalCenters.scale(1 / this._meshes.length);\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        var mesh = this._meshes[index];\n        var boundingInfo = mesh.getBoundingInfo();\n\n        if (boundingInfo) {\n          var distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\n\n          if (distanceToCenter < shortestToCenter) {\n            this._centerMesh = mesh;\n            shortestToCenter = distanceToCenter;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Get class name\r\n   * @returns \"MeshExploder\"\r\n   */\n\n\n  MeshExploder.prototype.getClassName = function () {\n    return \"MeshExploder\";\n  };\n  /**\r\n   * \"Exploded meshes\"\r\n   * @returns Array of meshes with the centerMesh at index 0.\r\n   */\n\n\n  MeshExploder.prototype.getMeshes = function () {\n    var meshArray = this._meshes.slice();\n\n    meshArray.unshift(this._centerMesh);\n    return meshArray;\n  };\n  /**\r\n   * Explodes meshes giving a specific direction\r\n   * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n   */\n\n\n  MeshExploder.prototype.explode = function (direction) {\n    if (direction === void 0) {\n      direction = 1.0;\n    }\n\n    for (var index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\n        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\n\n        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\n\n        this._meshes[index].setAbsolutePosition(this._newPosition);\n      }\n    }\n\n    this._centerMesh.setAbsolutePosition(this._centerPosition);\n  };\n\n  return MeshExploder;\n}();\n\nexport { MeshExploder };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/meshExploder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Mesh } from \"../Meshes/mesh\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\r\nexport class MeshExploder {\r\n    private _centerMesh: Mesh;\r\n    private _meshes: Array<Mesh>;\r\n    private _meshesOrigins: Array<Vector3> = [];\r\n    private _toCenterVectors: Array<Vector3> = [];\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n    private _centerPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Explodes meshes from a center mesh.\r\n     * @param meshes The meshes to explode.\r\n     * @param centerMesh The mesh to be center of explosion.\r\n     */\r\n    constructor(meshes: Array<Mesh>, centerMesh?: Mesh) {\r\n\r\n        this._meshes = meshes.slice();\r\n\r\n        if (centerMesh) {\r\n            this._centerMesh = centerMesh;\r\n        } else {\r\n            this._setCenterMesh();\r\n        }\r\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\r\n        if (centerMeshIndex >= 0) {\r\n            this._meshes.splice(centerMeshIndex, 1);\r\n        }\r\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\r\n        for (var index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                var mesh = this._meshes[index];\r\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\r\n                this._toCenterVectors[index] = Vector3.Zero();\r\n                if (mesh._boundingInfo && this._centerMesh._boundingInfo) {\r\n                    mesh._boundingInfo.boundingBox.centerWorld.subtractToRef(this._centerMesh._boundingInfo.boundingBox.centerWorld, this._toCenterVectors[index]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setCenterMesh(): void {\r\n        var averageCenter = Vector3.Zero();\r\n        var totalCenters = Vector3.Zero();\r\n        var shortestToCenter = Number.MAX_VALUE;\r\n        for (var index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                var mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\r\n                }\r\n            }\r\n        }\r\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\r\n        for (var index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                var mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    var distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\r\n                    if (distanceToCenter < shortestToCenter) {\r\n                        this._centerMesh = mesh;\r\n                        shortestToCenter = distanceToCenter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get class name\r\n     * @returns \"MeshExploder\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshExploder\";\r\n    }\r\n\r\n    /**\r\n     * \"Exploded meshes\"\r\n     * @returns Array of meshes with the centerMesh at index 0.\r\n     */\r\n    public getMeshes(): Array<Mesh> {\r\n        var meshArray = this._meshes.slice();\r\n        meshArray.unshift(this._centerMesh);\r\n        return meshArray;\r\n    }\r\n\r\n    /**\r\n     * Explodes meshes giving a specific direction\r\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n     */\r\n    public explode(direction: number = 1.0): void {\r\n        for (var index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\r\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\r\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\r\n                this._meshes[index].setAbsolutePosition(this._newPosition);\r\n            }\r\n        }\r\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}