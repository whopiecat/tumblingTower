{"ast":null,"code":"var _jsxFileName = \"D:\\\\tumblingTower\\\\src\\\\index.js\";\nimport React from \"react\";\nimport * as BABYLON from \"@babylonjs/core\";\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\n\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\n\nimport Scene from \"./3dScene\"; // import Gateway from \"../logic/GatewayLogic\";\n// import LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\n// import EventManager from \"../utilities/EventManager\";\n\nexport default class Lobby extends React.Component {\n  constructor(props) {\n    super();\n\n    this.onSceneReady = async e => {\n      let that = this;\n      const {\n        scene\n      } = e;\n      this.scene = scene; // maybe use DeviceOrientationCamera so that tilting works on devices?\n\n      this.camera = new BABYLON.UniversalCamera(\"mainCamera\", new BABYLON.Vector3(0, 0, 0), scene); // 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\n\n      /* \r\n          // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n          var camerasBorderFunction = function () {\r\n            let alpha = -Math.PI / 2;\r\n            let beta = Math.PI / 2;\r\n            console.log(\"----  this.camera.beta ----\" + beta);\r\n            if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n            else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n            if (this.camera.radius > 150) this.camera.radius = 150;\r\n            if (this.camera.radius < 30) this.camera.radius = 30;\r\n          };\r\n          scene.registerBeforeRender(camerasBorderFunction);\r\n          this.camera.attachControl(this.canvas, true);\r\n      \r\n       */\n\n      const light1 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);\n      light1.intensity = 1.8;\n      var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\"default\", true, scene, [this.camera]);\n      var curve = new BABYLON.ColorCurves();\n      curve.globalHue = 200;\n      curve.globalDensity = 80;\n      curve.globalSaturation = 80;\n      curve.highlightsHue = 240; // 20;\n\n      curve.highlightsDensity = 100; // 80;\n\n      curve.highlightsSaturation = 100; // -80;\n\n      curve.shadowsHue = 2;\n      curve.shadowsDensity = 80;\n      curve.shadowsSaturation = 40;\n      defaultPipeline.imageProcessing.colorCurves = curve;\n      defaultPipeline.depthOfField.focalLength = 150; // sequin Bloom\n\n      defaultPipeline.bloomEnabled = true;\n      defaultPipeline.bloomThreshold = 0.8;\n      defaultPipeline.bloomWeight = 0.3;\n      defaultPipeline.bloomKernel = 64;\n      defaultPipeline.bloomScale = 0.5;\n      defaultPipeline.imageProcessingEnabled = true;\n      const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\n\n      const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\n      skyboxMaterial.backFaceCulling = false; // WORKS with out below line\n\n      skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\"/textures/skybox/TropicalSunnyDay\", scene);\n      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n      skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.disableLighting = true;\n      skybox.material = skyboxMaterial;\n      skybox.position.y = -30.0;\n      skybox.isPickable = false; // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\n      // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      // hdrBox.isPickable = false;\n      // var hdrRotation = 180; // in degrees\n      // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n      // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\n\n      let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true); //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\n      //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\n\n      let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      hdrBox.isPickable = false; //  var hdrRotation = -60; // in degrees //-50\n      //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n\n      this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene); // Exclude Mesh from roll over\n\n      this.hlLayer.addExcludedMesh(skybox); // PLEASE ADJUST AS NEEDED //\n      // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\n      // init state for setSequinsPickable();\n      //   this.hasCompletedSequinPickableInitRun = false;\n      // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\n\n      /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n              if (hasCompletedSequinPickableInitRun == false) {\r\n                  for (var i = 0; i < scene.meshes.length; i++) {\r\n                      var mesh = scene.meshes[i];\r\n                      var re = /sequin/gi;\r\n                      var str = mesh.name;\r\n                      if (str.search(re) == -1) {\r\n                         // console.log(\"Does not contain sequin\");\r\n                      } else {\r\n                          if (mesh.isPickable == false) {\r\n                             // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                             // console.log(\" ---- setting pickable ----\");\r\n                              mesh.isPickable = true;\r\n                          }\r\n                      }\r\n                  }\r\n              }\r\n              return hasCompletedSequinPickableInitRun = true;\r\n          } */\n      // PLEASE ADJUST AS NEEDED //\n\n      BABYLON.SceneLoader.ShowLoadingScreen = false;\n      await Promise.all([BABYLON.SceneLoader.AppendAsync(\"/models/\", \"setNoSequin_1a.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinOnlyNonPick29_l.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraIntro_1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion2.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion3.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion4.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"cloud001.babylon\", scene // cloud mesh and animation of 'Curve.001'(cloud001) Action\n      )]); // preload region tree meshes\n\n      Gateway.allRegions().forEach(r => {\n        r.treeNames.forEach(n => {\n          r.meshes.push(scene.getMeshByName(n));\n        });\n      });\n      if (this.sceneLoadedHandler) this.sceneLoadedHandler();\n      this.lobbyState$ = LobbyState.stream.subscribe(async ({\n        oldState,\n        newState\n      }) => {\n        await this._handleStateChange(oldState, newState);\n      }); // var createReflectionProbes = function () {\n\n      let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene); //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\n\n      probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\n      //}\n\n      this.camera.onViewMatrixChangedObservable.add(function () {\n        if (that.camera) {// console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\n          // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\n        } else {\n          console.log(\"no camera!\");\n        }\n      }); // scene.debugLayer.show();\n      // not sure where the code for rthe debugLayer is, but needs below line\n      // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\n      // debug GUI needs above line otherwise Inspector window hides when mesh selected.\n    };\n\n    this.onSceneRender = e => {};\n\n    this.sceneLoadedHandler = props.sceneLoaded;\n    this.lobbyState$ = undefined;\n    this.data$ = undefined;\n    this.scene = undefined;\n    this.hlLayer = undefined;\n    this.camera = undefined;\n    this.materials = [];\n  }\n\n  componentWillUnmount() {\n    // unsubscribe from all observables\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\n    if (this.data$) this.data$.unsubscribe();\n  }\n  /*  _updateSequin = (sequinInfo, region) => {\r\n     const sequin = this.scene.getMeshByName(sequinInfo.name);\r\n     sequin.isPickable = true;\r\n     sequin.metadata = {\r\n       id: sequinInfo.id,\r\n       name: sequinInfo.name,\r\n       region: region,\r\n     };\r\n     this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\r\n   }; */\n\n  /*   _animateCamera = (trackName, speed = 1, reverse = false) => {\r\n      const track = this.scene.getMeshByName(trackName);\r\n      const keysLength = track.animations[0]._keys.length;\r\n      const start = 0;\r\n      const end = track.animations[0]._keys[keysLength - 1].frame;\r\n      const startFrame = reverse ? end : start;\r\n      const endFrame = reverse ? start : end;\r\n      this.camera.parent = track;\r\n      this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\r\n      return this.scene\r\n        .beginAnimation(track, startFrame, endFrame, false, speed)\r\n        .waitAsync();\r\n    }; */\n\n  /*   _handleClickMain = () => {\r\n      const scene = this.scene;\r\n      let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n  \r\n      if (pickResult.hit) {\r\n        console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\r\n        let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n        if (region) {\r\n          LobbyState.toRegionSelected(region);\r\n        }\r\n      }\r\n    }; */\n\n  /*   _handleMouseMoveMain = () => {\r\n      this.hlLayer.removeAllMeshes();\r\n  \r\n      let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\r\n  \r\n      if (pickResult.hit) {\r\n        const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n        if (r) {\r\n          r.meshes.forEach((m) =>\r\n            this.hlLayer.addMesh(m, BABYLON.Color3.Green())\r\n          );\r\n        }\r\n      }\r\n    }; */\n\n  /*   _handleClickRegion = () => {\r\n      const scene = this.scene;\r\n      const region = LobbyState.current.newState.data.name;\r\n      let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n  \r\n      if (pickResult.hit) {\r\n        const mesh = pickResult.pickedMesh;\r\n        console.log(\"picked mesh: \" + mesh);\r\n        // make sure a sequin was picked and the sequin is in the current region\r\n        if (mesh.name.indexOf(\"sequin\") === -1 || mesh.name.indexOf(region) === -1)\r\n          return;\r\n  \r\n        LobbyState.toSequinView(mesh.metadata);\r\n      }\r\n    }; */\n\n  /* \r\n    _handleStateChange = async (oldState, newState) => {\r\n      if (oldState) this._cleanUpOldState(oldState);\r\n      if (newState) await this._setUpNewState(oldState, newState);\r\n    }; */\n\n  /*   _cleanUpOldState = (oldState) => {\r\n      switch (oldState.type) {\r\n        case LobbyStates.main:\r\n        case LobbyStates.regionEntered:\r\n          EventManager.removeAllListeners(window, \"click\");\r\n          EventManager.removeAllListeners(window, \"mousemove\");\r\n          break;\r\n  \r\n        default:\r\n          break;\r\n      }\r\n    }; */\n\n  /*  _setUpNewState = async (oldState, newState) => {\r\n     switch (newState.type) {\r\n       case LobbyStates.intro:\r\n         await this._animateCamera(\"introToWorldEmpty_2\", 2.6);\r\n         LobbyState.toMainView();\r\n         break;\r\n  \n       case LobbyStates.main:\r\n         if (this.data$) this.data$.unsubscribe();\r\n  \n         if (oldState.type === LobbyStates.regionEntered) {\r\n           const region = oldState.data;\r\n           await this._animateCamera(region.trackName, 2, true);\r\n         }\r\n         EventManager.addListener(window, \"click\", this._handleClickMain);\r\n         EventManager.addListener(\r\n           window,\r\n           \"mousemove\",\r\n           this._handleMouseMoveMain\r\n         );\r\n         break;\r\n  \n       case LobbyStates.regionSelected:\r\n         this.hlLayer.removeAllMeshes();\r\n         let regionSelected = newState.data;\r\n         if (oldState.type === LobbyStates.main) {\r\n           await this._animateCamera(regionSelected.trackName, 2);\r\n         }\r\n         LobbyState.toRegionEntered(regionSelected);\r\n         break;\r\n  \n       case LobbyStates.regionEntered:\r\n         let regionEntered = newState.data;\r\n         this.data$ = Gateway.getRegion(regionEntered.name).stream.subscribe(\r\n           (sequins) => {\r\n             sequins.forEach((seq) => {\r\n               this._updateSequin(seq, regionEntered);\r\n             });\r\n           }\r\n         );\r\n         setTimeout(\r\n           () =>\r\n             EventManager.addListener(window, \"click\", this._handleClickRegion),\r\n           200\r\n         ); // slight pause prevents the sequin info modal from immediately popping back open\r\n         break;\r\n  \n       case LobbyStates.sequin:\r\n         if (this.data$) this.data$.unsubscribe();\r\n         break;\r\n  \n       case LobbyStates.sequinLink:\r\n         let regionLinked = newState.data.region;\r\n         await this._animateCamera(regionLinked.trackName, 2);\r\n         LobbyState.toSequinView(newState.data);\r\n         break;\r\n  \n       default:\r\n         break;\r\n     }\r\n   }; */\n\n\n  renderScene() {\n    return /*#__PURE__*/React.createElement(Scene, {\n      antialias: true,\n      onSceneReady: this.onSceneReady,\n      onRender: this.onSceneRender,\n      canvasId: \"lobbyCanvas\",\n      className: \"lobby-canvas\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 393,\n        columnNumber: 7\n      }\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"lobby-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 12\n      }\n    }, this.renderScene());\n  }\n\n}","map":{"version":3,"sources":["D:/tumblingTower/src/index.js"],"names":["React","BABYLON","Scene","Lobby","Component","constructor","props","onSceneReady","e","that","scene","camera","UniversalCamera","Vector3","light1","HemisphericLight","intensity","defaultPipeline","DefaultRenderingPipeline","curve","ColorCurves","globalHue","globalDensity","globalSaturation","highlightsHue","highlightsDensity","highlightsSaturation","shadowsHue","shadowsDensity","shadowsSaturation","imageProcessing","colorCurves","depthOfField","focalLength","bloomEnabled","bloomThreshold","bloomWeight","bloomKernel","bloomScale","imageProcessingEnabled","skybox","Mesh","CreateBox","skyboxMaterial","StandardMaterial","backFaceCulling","reflectionTexture","CubeTexture","coordinatesMode","Texture","SKYBOX_MODE","diffuseColor","Color3","specularColor","disableLighting","material","position","y","isPickable","hdrTexture","HDRCubeTexture","hdrBox","createDefaultSkybox","hlLayer","HighlightLayer","addExcludedMesh","SceneLoader","ShowLoadingScreen","Promise","all","AppendAsync","Gateway","allRegions","forEach","r","treeNames","n","meshes","push","getMeshByName","sceneLoadedHandler","lobbyState$","LobbyState","stream","subscribe","oldState","newState","_handleStateChange","probe","ReflectionProbe","renderList","onViewMatrixChangedObservable","add","console","log","onSceneRender","sceneLoaded","undefined","data$","materials","componentWillUnmount","unsubscribe","renderScene","render"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,KAAKC,OAAZ,MAAyB,iBAAzB;AACA,OAAO,kCAAP,C,CAA2C;;AAC3C,OAAO,sBAAP,C,CAA+B;;AAE/B,OAAOC,KAAP,MAAkB,WAAlB,C,CACA;AACA;AACA;;AAEA,eAAe,MAAMC,KAAN,SAAoBH,KAAK,CAACI,SAA1B,CAAoC;AACjDC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB;;AADiB,SAyKnBC,YAzKmB,GAyKJ,MAAOC,CAAP,IAAa;AAC1B,UAAIC,IAAI,GAAG,IAAX;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAYF,CAAlB;AACA,WAAKE,KAAL,GAAaA,KAAb,CAH0B,CAK1B;;AACA,WAAKC,MAAL,GAAc,IAAIV,OAAO,CAACW,eAAZ,CACZ,YADY,EAEZ,IAAIX,OAAO,CAACY,OAAZ,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAFY,EAGZH,KAHY,CAAd,CAN0B,CAY9B;;AAEA;;;;;;;;;;;;;;;;AAeI,YAAMI,MAAM,GAAG,IAAIb,OAAO,CAACc,gBAAZ,CACb,QADa,EAEb,IAAId,OAAO,CAACY,OAAZ,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAFa,EAGbH,KAHa,CAAf;AAKAI,MAAAA,MAAM,CAACE,SAAP,GAAmB,GAAnB;AAEA,UAAIC,eAAe,GAAG,IAAIhB,OAAO,CAACiB,wBAAZ,CACpB,SADoB,EAEpB,IAFoB,EAGpBR,KAHoB,EAIpB,CAAC,KAAKC,MAAN,CAJoB,CAAtB;AAMA,UAAIQ,KAAK,GAAG,IAAIlB,OAAO,CAACmB,WAAZ,EAAZ;AACAD,MAAAA,KAAK,CAACE,SAAN,GAAkB,GAAlB;AACAF,MAAAA,KAAK,CAACG,aAAN,GAAsB,EAAtB;AACAH,MAAAA,KAAK,CAACI,gBAAN,GAAyB,EAAzB;AACAJ,MAAAA,KAAK,CAACK,aAAN,GAAsB,GAAtB,CA9C0B,CA8CC;;AAC3BL,MAAAA,KAAK,CAACM,iBAAN,GAA0B,GAA1B,CA/C0B,CA+CK;;AAC/BN,MAAAA,KAAK,CAACO,oBAAN,GAA6B,GAA7B,CAhD0B,CAgDQ;;AAClCP,MAAAA,KAAK,CAACQ,UAAN,GAAmB,CAAnB;AACAR,MAAAA,KAAK,CAACS,cAAN,GAAuB,EAAvB;AACAT,MAAAA,KAAK,CAACU,iBAAN,GAA0B,EAA1B;AACAZ,MAAAA,eAAe,CAACa,eAAhB,CAAgCC,WAAhC,GAA8CZ,KAA9C;AACAF,MAAAA,eAAe,CAACe,YAAhB,CAA6BC,WAA7B,GAA2C,GAA3C,CArD0B,CAsD1B;;AACAhB,MAAAA,eAAe,CAACiB,YAAhB,GAA+B,IAA/B;AACAjB,MAAAA,eAAe,CAACkB,cAAhB,GAAiC,GAAjC;AACAlB,MAAAA,eAAe,CAACmB,WAAhB,GAA8B,GAA9B;AACAnB,MAAAA,eAAe,CAACoB,WAAhB,GAA8B,EAA9B;AACApB,MAAAA,eAAe,CAACqB,UAAhB,GAA6B,GAA7B;AACArB,MAAAA,eAAe,CAACsB,sBAAhB,GAAyC,IAAzC;AAEA,YAAMC,MAAM,GAAGvC,OAAO,CAACwC,IAAR,CAAaC,SAAb,CAAuB,QAAvB,EAAiC,KAAjC,EAAwChC,KAAxC,CAAf,CA9D0B,CA8DqC;;AAC/D,YAAMiC,cAAc,GAAG,IAAI1C,OAAO,CAAC2C,gBAAZ,CAA6B,QAA7B,EAAuClC,KAAvC,CAAvB;AACAiC,MAAAA,cAAc,CAACE,eAAf,GAAiC,KAAjC,CAhE0B,CAiE1B;;AACAF,MAAAA,cAAc,CAACG,iBAAf,GAAmC,IAAI7C,OAAO,CAAC8C,WAAZ,CACjC,mCADiC,EAEjCrC,KAFiC,CAAnC;AAIAiC,MAAAA,cAAc,CAACG,iBAAf,CAAiCE,eAAjC,GACE/C,OAAO,CAACgD,OAAR,CAAgBC,WADlB;AAEAP,MAAAA,cAAc,CAACQ,YAAf,GAA8B,IAAIlD,OAAO,CAACmD,MAAZ,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAA9B;AACAT,MAAAA,cAAc,CAACU,aAAf,GAA+B,IAAIpD,OAAO,CAACmD,MAAZ,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAA/B;AACAT,MAAAA,cAAc,CAACW,eAAf,GAAiC,IAAjC;AACAd,MAAAA,MAAM,CAACe,QAAP,GAAkBZ,cAAlB;AACAH,MAAAA,MAAM,CAACgB,QAAP,CAAgBC,CAAhB,GAAoB,CAAC,IAArB;AACAjB,MAAAA,MAAM,CAACkB,UAAP,GAAoB,KAApB,CA7E0B,CA8E1B;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AACC,UAAIC,UAAU,GAAK,IAAI1D,OAAO,CAAC2D,cAAZ,CAA2B,qCAA3B,EAAkElD,KAAlE,EAAyE,GAAzE,EAA8E,KAA9E,EAAqF,IAArF,EAA2F,KAA3F,EAAkG,IAAlG,CAAnB,CAtF0B,CAuF5B;AACE;;AACA,UAAImD,MAAM,GAAGnD,KAAK,CAACoD,mBAAN,CAA0BH,UAA1B,EAAsC,IAAtC,EAA4C,KAA5C,CAAb;AAEAE,MAAAA,MAAM,CAACH,UAAP,GAAoB,KAApB,CA3F0B,CA4F5B;AACA;;AAGE,WAAKK,OAAL,GAAe,IAAI9D,OAAO,CAAC+D,cAAZ,CAA2B,KAA3B,EAAkCtD,KAAlC,CAAf,CAhG0B,CAiG1B;;AACA,WAAKqD,OAAL,CAAaE,eAAb,CAA6BzB,MAA7B,EAlG0B,CAoG1B;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;;;;;;;;;;;AAmBA;;AAEAvC,MAAAA,OAAO,CAACiE,WAAR,CAAoBC,iBAApB,GAAwC,KAAxC;AAEA,YAAMC,OAAO,CAACC,GAAR,CAAY,CAChBpE,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,wBAFF,EAGE5D,KAHF,CADgB,EAMhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,+BAFF,EAGE5D,KAHF,CANgB,EAWhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,6BAFF,EAGE5D,KAHF,CAXgB,EAgBhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,6BAFF,EAGE5D,KAHF,CAhBgB,EAqBhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,6BAFF,EAGE5D,KAHF,CArBgB,EA0BhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,6BAFF,EAGE5D,KAHF,CA1BgB,EA+BhBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,6BAFF,EAGE5D,KAHF,CA/BgB,EAoChBT,OAAO,CAACiE,WAAR,CAAoBI,WAApB,CACE,UADF,EAEE,kBAFF,EAGE5D,KAHF,CAIE;AAJF,OApCgB,CAAZ,CAAN,CAhI0B,CA4K1B;;AACA6D,MAAAA,OAAO,CAACC,UAAR,GAAqBC,OAArB,CAA8BC,CAAD,IAAO;AAClCA,QAAAA,CAAC,CAACC,SAAF,CAAYF,OAAZ,CAAqBG,CAAD,IAAO;AACzBF,UAAAA,CAAC,CAACG,MAAF,CAASC,IAAT,CAAcpE,KAAK,CAACqE,aAAN,CAAoBH,CAApB,CAAd;AACD,SAFD;AAGD,OAJD;AAMA,UAAI,KAAKI,kBAAT,EAA6B,KAAKA,kBAAL;AAE7B,WAAKC,WAAL,GAAmBC,UAAU,CAACC,MAAX,CAAkBC,SAAlB,CACjB,OAAO;AAAEC,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,OAAP,KAAkC;AAChC,cAAM,KAAKC,kBAAL,CAAwBF,QAAxB,EAAkCC,QAAlC,CAAN;AACD,OAHgB,CAAnB,CArL0B,CA2L1B;;AACA,UAAIE,KAAK,GAAG,IAAIvF,OAAO,CAACwF,eAAZ,CAA4B,MAA5B,EAAoC,GAApC,EAAyC/E,KAAzC,CAAZ,CA5L0B,CA6L1B;;AACA8E,MAAAA,KAAK,CAACE,UAAN,CAAiBZ,IAAjB,CAAsBjB,MAAtB,EA9L0B,CA8LK;AAC/B;;AAEA,WAAKlD,MAAL,CAAYgF,6BAAZ,CAA0CC,GAA1C,CAA8C,YAAY;AACxD,YAAInF,IAAI,CAACE,MAAT,EAAiB,CACf;AACA;AACD,SAHD,MAGO;AACLkF,UAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACD;AACF,OAPD,EAjM0B,CA0M1B;AACA;AACA;AACA;AACD,KAvXkB;;AAAA,SAyXnBC,aAzXmB,GAyXFvF,CAAD,IAAO,CAAG,CAzXP;;AAGjB,SAAKwE,kBAAL,GAA0B1E,KAAK,CAAC0F,WAAhC;AACA,SAAKf,WAAL,GAAmBgB,SAAnB;AACA,SAAKC,KAAL,GAAaD,SAAb;AACA,SAAKvF,KAAL,GAAauF,SAAb;AACA,SAAKlC,OAAL,GAAekC,SAAf;AACA,SAAKtF,MAAL,GAAcsF,SAAd;AACA,SAAKE,SAAL,GAAiB,EAAjB;AACD;;AAEDC,EAAAA,oBAAoB,GAAG;AACrB;AACA,QAAI,KAAKnB,WAAT,EAAsB,KAAKA,WAAL,CAAiBoB,WAAjB;AACtB,QAAI,KAAKH,KAAT,EAAgB,KAAKA,KAAL,CAAWG,WAAX;AACjB;AAEF;;;;;;;;;;;AAWD;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;AAgBA;;;;;;AAMA;;;;;;;;;;;;;AAaC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiRCC,EAAAA,WAAW,GAAG;AACZ,wBACE,oBAAC,KAAD;AACE,MAAA,SAAS,EAAE,IADb;AAEE,MAAA,YAAY,EAAE,KAAK/F,YAFrB;AAGE,MAAA,QAAQ,EAAE,KAAKwF,aAHjB;AAIE,MAAA,QAAQ,EAAC,aAJX;AAKE,MAAA,SAAS,EAAC,cALZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF;AASD;;AAEDQ,EAAAA,MAAM,GAAG;AACP,wBAAO;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAkC,KAAKD,WAAL,EAAlC,CAAP;AACD;;AA1YgD","sourcesContent":["import React from \"react\";\r\nimport * as BABYLON from \"@babylonjs/core\";\r\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\r\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\r\n\r\nimport Scene from \"./3dScene\";\r\n// import Gateway from \"../logic/GatewayLogic\";\r\n// import LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\r\n// import EventManager from \"../utilities/EventManager\";\r\n\r\nexport default class Lobby extends React.Component {\r\n  constructor(props) {\r\n    super();\r\n\r\n    this.sceneLoadedHandler = props.sceneLoaded;\r\n    this.lobbyState$ = undefined;\r\n    this.data$ = undefined;\r\n    this.scene = undefined;\r\n    this.hlLayer = undefined;\r\n    this.camera = undefined;\r\n    this.materials = [];\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // unsubscribe from all observables\r\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\r\n    if (this.data$) this.data$.unsubscribe();\r\n  }\r\n\r\n /*  _updateSequin = (sequinInfo, region) => {\r\n    const sequin = this.scene.getMeshByName(sequinInfo.name);\r\n    sequin.isPickable = true;\r\n    sequin.metadata = {\r\n      id: sequinInfo.id,\r\n      name: sequinInfo.name,\r\n      region: region,\r\n    };\r\n    this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\r\n  }; */\r\n\r\n/*   _animateCamera = (trackName, speed = 1, reverse = false) => {\r\n    const track = this.scene.getMeshByName(trackName);\r\n    const keysLength = track.animations[0]._keys.length;\r\n    const start = 0;\r\n    const end = track.animations[0]._keys[keysLength - 1].frame;\r\n    const startFrame = reverse ? end : start;\r\n    const endFrame = reverse ? start : end;\r\n    this.camera.parent = track;\r\n    this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\r\n    return this.scene\r\n      .beginAnimation(track, startFrame, endFrame, false, speed)\r\n      .waitAsync();\r\n  }; */\r\n\r\n/*   _handleClickMain = () => {\r\n    const scene = this.scene;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\r\n      let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (region) {\r\n        LobbyState.toRegionSelected(region);\r\n      }\r\n    }\r\n  }; */\r\n\r\n/*   _handleMouseMoveMain = () => {\r\n    this.hlLayer.removeAllMeshes();\r\n\r\n    let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (r) {\r\n        r.meshes.forEach((m) =>\r\n          this.hlLayer.addMesh(m, BABYLON.Color3.Green())\r\n        );\r\n      }\r\n    }\r\n  }; */\r\n\r\n/*   _handleClickRegion = () => {\r\n    const scene = this.scene;\r\n    const region = LobbyState.current.newState.data.name;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const mesh = pickResult.pickedMesh;\r\n      console.log(\"picked mesh: \" + mesh);\r\n      // make sure a sequin was picked and the sequin is in the current region\r\n      if (mesh.name.indexOf(\"sequin\") === -1 || mesh.name.indexOf(region) === -1)\r\n        return;\r\n\r\n      LobbyState.toSequinView(mesh.metadata);\r\n    }\r\n  }; */\r\n\r\n/* \r\n  _handleStateChange = async (oldState, newState) => {\r\n    if (oldState) this._cleanUpOldState(oldState);\r\n    if (newState) await this._setUpNewState(oldState, newState);\r\n  }; */\r\n\r\n/*   _cleanUpOldState = (oldState) => {\r\n    switch (oldState.type) {\r\n      case LobbyStates.main:\r\n      case LobbyStates.regionEntered:\r\n        EventManager.removeAllListeners(window, \"click\");\r\n        EventManager.removeAllListeners(window, \"mousemove\");\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }; */\r\n\r\n /*  _setUpNewState = async (oldState, newState) => {\r\n    switch (newState.type) {\r\n      case LobbyStates.intro:\r\n        await this._animateCamera(\"introToWorldEmpty_2\", 2.6);\r\n        LobbyState.toMainView();\r\n        break;\r\n\r\n      case LobbyStates.main:\r\n        if (this.data$) this.data$.unsubscribe();\r\n\r\n        if (oldState.type === LobbyStates.regionEntered) {\r\n          const region = oldState.data;\r\n          await this._animateCamera(region.trackName, 2, true);\r\n        }\r\n        EventManager.addListener(window, \"click\", this._handleClickMain);\r\n        EventManager.addListener(\r\n          window,\r\n          \"mousemove\",\r\n          this._handleMouseMoveMain\r\n        );\r\n        break;\r\n\r\n      case LobbyStates.regionSelected:\r\n        this.hlLayer.removeAllMeshes();\r\n        let regionSelected = newState.data;\r\n        if (oldState.type === LobbyStates.main) {\r\n          await this._animateCamera(regionSelected.trackName, 2);\r\n        }\r\n        LobbyState.toRegionEntered(regionSelected);\r\n        break;\r\n\r\n      case LobbyStates.regionEntered:\r\n        let regionEntered = newState.data;\r\n        this.data$ = Gateway.getRegion(regionEntered.name).stream.subscribe(\r\n          (sequins) => {\r\n            sequins.forEach((seq) => {\r\n              this._updateSequin(seq, regionEntered);\r\n            });\r\n          }\r\n        );\r\n        setTimeout(\r\n          () =>\r\n            EventManager.addListener(window, \"click\", this._handleClickRegion),\r\n          200\r\n        ); // slight pause prevents the sequin info modal from immediately popping back open\r\n        break;\r\n\r\n      case LobbyStates.sequin:\r\n        if (this.data$) this.data$.unsubscribe();\r\n        break;\r\n\r\n      case LobbyStates.sequinLink:\r\n        let regionLinked = newState.data.region;\r\n        await this._animateCamera(regionLinked.trackName, 2);\r\n        LobbyState.toSequinView(newState.data);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }; */\r\n  \r\n\r\n  onSceneReady = async (e) => {\r\n    let that = this;\r\n    const { scene } = e;\r\n    this.scene = scene;\r\n\r\n    // maybe use DeviceOrientationCamera so that tilting works on devices?\r\n    this.camera = new BABYLON.UniversalCamera(\r\n      \"mainCamera\",\r\n      new BABYLON.Vector3(0, 0, 0),\r\n      scene\r\n    );\r\n\r\n// 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\r\n\r\n/* \r\n    // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n    var camerasBorderFunction = function () {\r\n      let alpha = -Math.PI / 2;\r\n      let beta = Math.PI / 2;\r\n      console.log(\"----  this.camera.beta ----\" + beta);\r\n      if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n      else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n      if (this.camera.radius > 150) this.camera.radius = 150;\r\n      if (this.camera.radius < 30) this.camera.radius = 30;\r\n    };\r\n    scene.registerBeforeRender(camerasBorderFunction);\r\n    this.camera.attachControl(this.canvas, true);\r\n\r\n */\r\n    const light1 = new BABYLON.HemisphericLight(\r\n      \"light1\",\r\n      new BABYLON.Vector3(0, 1, 0),\r\n      scene\r\n    );\r\n    light1.intensity = 1.8;\r\n\r\n    var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\r\n      \"default\",\r\n      true,\r\n      scene,\r\n      [this.camera]\r\n    );\r\n    var curve = new BABYLON.ColorCurves();\r\n    curve.globalHue = 200;\r\n    curve.globalDensity = 80;\r\n    curve.globalSaturation = 80;\r\n    curve.highlightsHue = 240; // 20;\r\n    curve.highlightsDensity = 100; // 80;\r\n    curve.highlightsSaturation = 100; // -80;\r\n    curve.shadowsHue = 2;\r\n    curve.shadowsDensity = 80;\r\n    curve.shadowsSaturation = 40;\r\n    defaultPipeline.imageProcessing.colorCurves = curve;\r\n    defaultPipeline.depthOfField.focalLength = 150;\r\n    // sequin Bloom\r\n    defaultPipeline.bloomEnabled = true;\r\n    defaultPipeline.bloomThreshold = 0.8;\r\n    defaultPipeline.bloomWeight = 0.3;\r\n    defaultPipeline.bloomKernel = 64;\r\n    defaultPipeline.bloomScale = 0.5;\r\n    defaultPipeline.imageProcessingEnabled = true;\r\n\r\n    const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\r\n    const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n    // WORKS with out below line\r\n    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\r\n      \"/textures/skybox/TropicalSunnyDay\",\r\n      scene\r\n    );\r\n    skyboxMaterial.reflectionTexture.coordinatesMode =\r\n      BABYLON.Texture.SKYBOX_MODE;\r\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.disableLighting = true;\r\n    skybox.material = skyboxMaterial;\r\n    skybox.position.y = -30.0;\r\n    skybox.isPickable = false;\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n    // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\r\n    // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    // hdrBox.isPickable = false;\r\n    // var hdrRotation = 180; // in degrees\r\n    // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n   // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\r\n    let hdrTexture =   new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true);\r\n  //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\r\n    //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\r\n    let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    \r\n    hdrBox.isPickable = false;\r\n  //  var hdrRotation = -60; // in degrees //-50\r\n  //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n\r\n\r\n    this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene);\r\n    // Exclude Mesh from roll over\r\n    this.hlLayer.addExcludedMesh(skybox);\r\n\r\n    // PLEASE ADJUST AS NEEDED //\r\n    // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\r\n    // init state for setSequinsPickable();\r\n    //   this.hasCompletedSequinPickableInitRun = false;\r\n    // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\r\n    /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n            if (hasCompletedSequinPickableInitRun == false) {\r\n                for (var i = 0; i < scene.meshes.length; i++) {\r\n                    var mesh = scene.meshes[i];\r\n                    var re = /sequin/gi;\r\n                    var str = mesh.name;\r\n                    if (str.search(re) == -1) {\r\n                       // console.log(\"Does not contain sequin\");\r\n                    } else {\r\n                        if (mesh.isPickable == false) {\r\n                           // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                           // console.log(\" ---- setting pickable ----\");\r\n                            mesh.isPickable = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return hasCompletedSequinPickableInitRun = true;\r\n        } */\r\n    // PLEASE ADJUST AS NEEDED //\r\n\r\n    BABYLON.SceneLoader.ShowLoadingScreen = false;\r\n\r\n    await Promise.all([\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"setNoSequin_1a.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinOnlyNonPick29_l.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraIntro_1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion2.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion3.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion4.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"cloud001.babylon\",\r\n        scene\r\n        // cloud mesh and animation of 'Curve.001'(cloud001) Action\r\n      ), \r\n    ]);\r\n\r\n    // preload region tree meshes\r\n    Gateway.allRegions().forEach((r) => {\r\n      r.treeNames.forEach((n) => {\r\n        r.meshes.push(scene.getMeshByName(n));\r\n      });\r\n    });\r\n\r\n    if (this.sceneLoadedHandler) this.sceneLoadedHandler();\r\n\r\n    this.lobbyState$ = LobbyState.stream.subscribe(\r\n      async ({ oldState, newState }) => {\r\n        await this._handleStateChange(oldState, newState);\r\n      }\r\n    );\r\n\r\n    // var createReflectionProbes = function () {\r\n    let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene);\r\n    //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\r\n    probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\r\n    //}\r\n\r\n    this.camera.onViewMatrixChangedObservable.add(function () {\r\n      if (that.camera) {\r\n        // console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\r\n        // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\r\n      } else {\r\n        console.log(\"no camera!\");\r\n      }\r\n    });\r\n\r\n    // scene.debugLayer.show();\r\n    // not sure where the code for rthe debugLayer is, but needs below line\r\n    // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\r\n    // debug GUI needs above line otherwise Inspector window hides when mesh selected.\r\n  };\r\n\r\n  onSceneRender = (e) => { };\r\n\r\n  renderScene() {\r\n    return (\r\n      <Scene\r\n        antialias={true}\r\n        onSceneReady={this.onSceneReady}\r\n        onRender={this.onSceneRender}\r\n        canvasId=\"lobbyCanvas\"\r\n        className=\"lobby-canvas\"\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return <div className=\"lobby-container\">{this.renderScene()}</div>;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}