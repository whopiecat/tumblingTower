{"ast":null,"code":"import { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { AnimationKeyInterpolation } from './animationKey';\nimport { AnimationRange } from './animationRange';\nimport { Node } from \"../node\";\nimport { Size } from '../Maths/math.size';\nimport { WebRequest } from '../Misc/webRequest';\n/**\r\n * @hidden\r\n */\n\nvar _IAnimationState =\n/** @class */\nfunction () {\n  function _IAnimationState() {}\n\n  return _IAnimationState;\n}();\n\nexport { _IAnimationState };\n/**\r\n * Class used to store any kind of animation\r\n */\n\nvar Animation =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the animation\r\n   * @param name Name of the animation\r\n   * @param targetProperty Property to animate\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param dataType The data type of the animation\r\n   * @param loopMode The loop mode of the animation\r\n   * @param enableBlending Specifies if blending should be enabled\r\n   */\n  function Animation(\n  /**Name of the animation */\n  name,\n  /**Property to animate */\n  targetProperty,\n  /**The frames per second of the animation */\n  framePerSecond,\n  /**The data type of the animation */\n  dataType,\n  /**The loop mode of the animation */\n  loopMode,\n  /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\r\n     * @hidden Internal use only\r\n     */\n\n    this._runtimeAnimations = new Array();\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\n\n    this._events = new Array();\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\n\n    this.blendingSpeed = 0.01;\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\n\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n  }\n  /**\r\n   * @hidden Internal use\r\n   */\n\n\n  Animation._PrepareAnimation = function (name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    var dataType = undefined;\n\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n\n    if (dataType == undefined) {\n      return null;\n    }\n\n    var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    var keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n\n    return animation;\n  };\n  /**\r\n   * Sets up an animation\r\n   * @param property The property to animate\r\n   * @param animationType The animation type to apply\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param easingFunction The easing function used in the animation\r\n   * @returns The created animation\r\n   */\n\n\n  Animation.CreateAnimation = function (property, animationType, framePerSecond, easingFunction) {\n    var animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  };\n  /**\r\n   * Create and start an animation on a node\r\n   * @param name defines the name of the global animation that will be run on all nodes\r\n   * @param node defines the root node where the animation will take place\r\n   * @param targetProperty defines property to animate\r\n   * @param framePerSecond defines the number of frame per second yo use\r\n   * @param totalFrame defines the number of frames in total\r\n   * @param from defines the initial value\r\n   * @param to defines the final value\r\n   * @param loopMode defines which loop mode you want to use (off by default)\r\n   * @param easingFunction defines the easing function to use (linear by default)\r\n   * @param onAnimationEnd defines the callback to call when animation end\r\n   * @returns the animatable created for this animation\r\n   */\n\n\n  Animation.CreateAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Create and start an animation on a node and its descendants\r\n   * @param name defines the name of the global animation that will be run on all nodes\r\n   * @param node defines the root node where the animation will take place\r\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n   * @param targetProperty defines property to animate\r\n   * @param framePerSecond defines the number of frame per second to use\r\n   * @param totalFrame defines the number of frames in total\r\n   * @param from defines the initial value\r\n   * @param to defines the final value\r\n   * @param loopMode defines which loop mode you want to use (off by default)\r\n   * @param easingFunction defines the easing function to use (linear by default)\r\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n   * @returns the list of animatables created for all nodes\r\n   * @example https://www.babylonjs-playground.com/#MH0VLI\r\n   */\n\n\n  Animation.CreateAndStartHierarchyAnimation = function (name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    var scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Creates a new animation, merges it with the existing animations and starts it\r\n   * @param name Name of the animation\r\n   * @param node Node which contains the scene that begins the animations\r\n   * @param targetProperty Specifies which property to animate\r\n   * @param framePerSecond The frames per second of the animation\r\n   * @param totalFrame The total number of frames\r\n   * @param from The frame at the beginning of the animation\r\n   * @param to The frame at the end of the animation\r\n   * @param loopMode Specifies the loop mode of the animation\r\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n   * @param onAnimationEnd Callback to run once the animation is complete\r\n   * @returns Nullable animation\r\n   */\n\n\n  Animation.CreateMergeAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n\n    if (!animation) {\n      return null;\n    }\n\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  };\n  /**\r\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n   * @param sourceAnimation defines the Animation containing keyframes to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n   * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n   * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n   * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n   */\n\n\n  Animation.MakeAnimationAdditive = function (sourceAnimation, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animation = sourceAnimation;\n\n    if (cloneOriginal) {\n      animation = sourceAnimation.clone();\n      animation.name = clonedName || animation.name;\n    }\n\n    if (!animation._keys.length) {\n      return animation;\n    }\n\n    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\n    var startIndex = 0;\n    var firstKey = animation._keys[0];\n    var endIndex = animation._keys.length - 1;\n    var lastKey = animation._keys[endIndex];\n    var valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    var referenceFound = false;\n    var from = firstKey.frame;\n    var to = lastKey.frame;\n\n    if (range) {\n      var rangeValue = animation.getRange(range);\n\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    }\n\n    var fromKeyFound = firstKey.frame === from;\n    var toKeyFound = lastKey.frame === to; // There's only one key, so use it\n\n    if (animation._keys.length === 1) {\n      var value = animation._getKeyValue(animation._keys[0]);\n\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    } // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n        var value = animation._getKeyValue(firstKey.value);\n\n        valueStore.referenceValue = value.clone ? value.clone() : value;\n        referenceFound = true;\n      } // Reference frame is after the last frame, so just use the last frame\n      else if (referenceFrame >= lastKey.frame) {\n          var value = animation._getKeyValue(lastKey.value);\n\n          valueStore.referenceValue = value.clone ? value.clone() : value;\n          referenceFound = true;\n        } // Find key bookends, create them if they don't exist\n\n\n    var index = 0;\n\n    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\n      var currentKey = animation._keys[index];\n      var nextKey = animation._keys[index + 1]; // If reference frame wasn't found yet, check if we can interpolate to it\n\n      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\n        var value = void 0;\n\n        if (referenceFrame === currentKey.frame) {\n          value = animation._getKeyValue(currentKey.value);\n        } else if (referenceFrame === nextKey.frame) {\n          value = animation._getKeyValue(nextKey.value);\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          value = animation._interpolate(referenceFrame, animationState);\n        }\n\n        valueStore.referenceValue = value.clone ? value.clone() : value;\n        referenceFound = true;\n      } // If from key wasn't found yet, check if we can interpolate to it\n\n\n      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\n        if (from === currentKey.frame) {\n          startIndex = index;\n        } else if (from === nextKey.frame) {\n          startIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(from, animationState);\n\n          var key = {\n            frame: from,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          startIndex = index + 1;\n        }\n\n        fromKeyFound = true;\n      } // If to key wasn't found yet, check if we can interpolate to it\n\n\n      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\n        if (to === currentKey.frame) {\n          endIndex = index;\n        } else if (to === nextKey.frame) {\n          endIndex = index + 1;\n        } else {\n          var animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n\n          var value = animation._interpolate(to, animationState);\n\n          var key = {\n            frame: to,\n            value: value.clone ? value.clone() : value\n          };\n\n          animation._keys.splice(index + 1, 0, key);\n\n          endIndex = index + 1;\n        }\n\n        toKeyFound = true;\n      }\n\n      index++;\n    } // Conjugate the quaternion\n\n\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    } // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n        valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n        valueStore.referenceQuaternion.normalize().conjugateInPlace();\n      } // Subtract the reference value from all of the key values\n\n\n    for (var index = startIndex; index <= endIndex; index++) {\n      var key = animation._keys[index]; // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n\n    return animation;\n  };\n  /**\r\n   * Transition property of an host to the target Value\r\n   * @param property The property to transition\r\n   * @param targetValue The target Value of the property\r\n   * @param host The object where the property to animate belongs\r\n   * @param scene Scene used to run the animation\r\n   * @param frameRate Framerate (in frame/s) to use\r\n   * @param transition The transition type we want to use\r\n   * @param duration The duration of the animation, in milliseconds\r\n   * @param onAnimationEnd Callback trigger at the end of the animation\r\n   * @returns Nullable animation\r\n   */\n\n\n  Animation.TransitionTo = function (property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd) {\n    if (onAnimationEnd === void 0) {\n      onAnimationEnd = null;\n    }\n\n    if (duration <= 0) {\n      host[property] = targetValue;\n\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n\n      return null;\n    }\n\n    var endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n\n    if (!host.animations) {\n      host.animations = [];\n    }\n\n    host.animations.push(transition);\n    var animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  };\n\n  Object.defineProperty(Animation.prototype, \"runtimeAnimations\", {\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\n    get: function () {\n      return this._runtimeAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Animation.prototype, \"hasRunningRuntimeAnimations\", {\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\n    get: function () {\n      for (var _i = 0, _a = this._runtimeAnimations; _i < _a.length; _i++) {\n        var runtimeAnimation = _a[_i];\n\n        if (!runtimeAnimation.isStopped) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  /**\r\n   * Converts the animation to a string\r\n   * @param fullDetails support for multiple levels of logging within scene loading\r\n   * @returns String form of the animation\r\n   */\n\n  Animation.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\r\n   * Add an event to this animation\r\n   * @param event Event to add\r\n   */\n\n\n  Animation.prototype.addEvent = function (event) {\n    this._events.push(event);\n\n    this._events.sort(function (a, b) {\n      return a.frame - b.frame;\n    });\n  };\n  /**\r\n   * Remove all events found at the given frame\r\n   * @param frame The frame to remove events from\r\n   */\n\n\n  Animation.prototype.removeEvents = function (frame) {\n    for (var index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n\n        index--;\n      }\n    }\n  };\n  /**\r\n   * Retrieves all the events from the animation\r\n   * @returns Events from the animation\r\n   */\n\n\n  Animation.prototype.getEvents = function () {\n    return this._events;\n  };\n  /**\r\n   * Creates an animation range\r\n   * @param name Name of the animation range\r\n   * @param from Starting frame of the animation range\r\n   * @param to Ending frame of the animation\r\n   */\n\n\n  Animation.prototype.createRange = function (name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  };\n  /**\r\n   * Deletes an animation range by name\r\n   * @param name Name of the animation range to delete\r\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n   */\n\n\n  Animation.prototype.deleteRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    var range = this._ranges[name];\n\n    if (!range) {\n      return;\n    }\n\n    if (deleteFrames) {\n      var from = range.from;\n      var to = range.to; // this loop MUST go high to low for multiple splices to work\n\n      for (var key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\r\n   * Gets the animation range by name, or null if not defined\r\n   * @param name Name of the animation range\r\n   * @returns Nullable animation range\r\n   */\n\n\n  Animation.prototype.getRange = function (name) {\n    return this._ranges[name];\n  };\n  /**\r\n   * Gets the key frames from the animation\r\n   * @returns The key frames of the animation\r\n   */\n\n\n  Animation.prototype.getKeys = function () {\n    return this._keys;\n  };\n  /**\r\n   * Gets the highest frame rate of the animation\r\n   * @returns Highest frame rate of the animation\r\n   */\n\n\n  Animation.prototype.getHighestFrame = function () {\n    var ret = 0;\n\n    for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Gets the easing function of the animation\r\n   * @returns Easing function of the animation\r\n   */\n\n\n  Animation.prototype.getEasingFunction = function () {\n    return this._easingFunction;\n  };\n  /**\r\n   * Sets the easing function of the animation\r\n   * @param easingFunction A custom mathematical formula for animation\r\n   */\n\n\n  Animation.prototype.setEasingFunction = function (easingFunction) {\n    this._easingFunction = easingFunction;\n  };\n  /**\r\n   * Interpolates a scalar linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a scalar cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.floatInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a quaternion using a spherical linear interpolation\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated quaternion value\r\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a quaternion cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated quaternion value\r\n   */\n\n\n  Animation.prototype.quaternionInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  };\n  /**\r\n   * Interpolates a Vector3 linearl\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated scalar value\r\n   */\n\n\n  Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Vector3 cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns InterpolatedVector3 value\r\n   */\n\n\n  Animation.prototype.vector3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a Vector2 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Vector2 value\r\n   */\n\n\n  Animation.prototype.vector2InterpolateFunction = function (startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Vector2 cubically\r\n   * @param startValue Start value of the animation curve\r\n   * @param outTangent End tangent of the animation\r\n   * @param endValue End value of the animation curve\r\n   * @param inTangent Start tangent of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Vector2 value\r\n   */\n\n\n  Animation.prototype.vector2InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  };\n  /**\r\n   * Interpolates a size linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Size value\r\n   */\n\n\n  Animation.prototype.sizeInterpolateFunction = function (startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Color3 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Color3 value\r\n   */\n\n\n  Animation.prototype.color3InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Interpolates a Color4 linearly\r\n   * @param startValue Start value of the animation curve\r\n   * @param endValue End value of the animation curve\r\n   * @param gradient Scalar amount to interpolate\r\n   * @returns Interpolated Color3 value\r\n   */\n\n\n  Animation.prototype.color4InterpolateFunction = function (startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  Animation.prototype._getKeyValue = function (value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n\n    return value;\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  Animation.prototype._interpolate = function (currentFrame, state) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n\n    var keys = this._keys;\n\n    if (keys.length === 1) {\n      return this._getKeyValue(keys[0].value);\n    }\n\n    var startKeyIndex = state.key;\n\n    if (keys[startKeyIndex].frame >= currentFrame) {\n      while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\n        startKeyIndex--;\n      }\n    }\n\n    for (var key = startKeyIndex; key < keys.length; key++) {\n      var endKey = keys[key + 1];\n\n      if (endKey.frame >= currentFrame) {\n        state.key = key;\n        var startKey = keys[key];\n\n        var startValue = this._getKeyValue(startKey.value);\n\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n          return startValue;\n        }\n\n        var endValue = this._getKeyValue(endKey.value);\n\n        var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n        var frameDelta = endKey.frame - startKey.frame; // gradient : percent of currentFrame between the frame inf and the frame sup\n\n        var gradient = (currentFrame - startKey.frame) / frameDelta; // check for easingFunction and correction of gradient\n\n        var easingFunction = this.getEasingFunction();\n\n        if (easingFunction != null) {\n          gradient = easingFunction.ease(gradient);\n        }\n\n        switch (this.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return floatValue;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return state.offsetValue * state.repeatCount + floatValue;\n            }\n\n            break;\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return quatValue;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\n            }\n\n            return quatValue;\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return vec3Value;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return vec3Value.add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return vec2Value;\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return vec2Value.add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.sizeInterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.color3InterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.color3InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Color4\n\n          case Animation.ANIMATIONTYPE_COLOR4:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                return this.color4InterpolateFunction(startValue, endValue, gradient);\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return this.color4InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n            }\n\n          // Matrix\n\n          case Animation.ANIMATIONTYPE_MATRIX:\n            switch (state.loopMode) {\n              case Animation.ANIMATIONLOOPMODE_CYCLE:\n              case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                if (Animation.AllowMatricesInterpolation) {\n                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                }\n\n              case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                return startValue;\n            }\n\n          default:\n            break;\n        }\n\n        break;\n      }\n    }\n\n    return this._getKeyValue(keys[keys.length - 1].value);\n  };\n  /**\r\n   * Defines the function to use to interpolate matrices\r\n   * @param startValue defines the start matrix\r\n   * @param endValue defines the end matrix\r\n   * @param gradient defines the gradient between both matrices\r\n   * @param result defines an optional target matrix where to store the interpolation\r\n   * @returns the interpolated matrix\r\n   */\n\n\n  Animation.prototype.matrixInterpolateFunction = function (startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n\n    return Matrix.Lerp(startValue, endValue, gradient);\n  };\n  /**\r\n   * Makes a copy of the animation\r\n   * @returns Cloned animation\r\n   */\n\n\n  Animation.prototype.clone = function () {\n    var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n\n    if (this._ranges) {\n      clone._ranges = {};\n\n      for (var name in this._ranges) {\n        var range = this._ranges[name];\n\n        if (!range) {\n          continue;\n        }\n\n        clone._ranges[name] = range.clone();\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * Sets the key frames of the animation\r\n   * @param values The animation key frames to set\r\n   */\n\n\n  Animation.prototype.setKeys = function (values) {\n    this._keys = values.slice(0);\n  };\n  /**\r\n   * Serializes the animation to an object\r\n   * @returns Serialized object\r\n   */\n\n\n  Animation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    var dataType = this.dataType;\n    serializationObject.keys = [];\n    var keys = this.getKeys();\n\n    for (var index = 0; index < keys.length; index++) {\n      var animationKey = keys[index];\n      var key = {};\n      key.frame = animationKey.frame;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent);\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n\n            key.values.push(animationKey.outTangent.asArray());\n          }\n\n          break;\n      }\n\n      serializationObject.keys.push(key);\n    }\n\n    serializationObject.ranges = [];\n\n    for (var name in this._ranges) {\n      var source = this._ranges[name];\n\n      if (!source) {\n        continue;\n      }\n\n      var range = {};\n      range.name = name;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  Animation._UniversalLerp = function (left, right, amount) {\n    var constructor = left.constructor;\n\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  };\n  /**\r\n   * Parses an animation object and creates an animation\r\n   * @param parsedAnimation Parsed animation object\r\n   * @returns Animation object\r\n   */\n\n\n  Animation.Parse = function (parsedAnimation) {\n    var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    var dataType = parsedAnimation.dataType;\n    var keys = [];\n    var data;\n    var index;\n\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      var key = parsedAnimation.keys[index];\n      var inTangent;\n      var outTangent;\n\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n\n          if (key.values.length >= 1) {\n            inTangent = key.values[1];\n          }\n\n          if (key.values.length >= 2) {\n            outTangent = key.values[2];\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n\n          if (key.values.length >= 8) {\n            var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n\n          if (key.values.length >= 12) {\n            var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n\n          break;\n\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n          break;\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n          break;\n      }\n\n      var keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n\n      keys.push(keyData);\n    }\n\n    animation.setKeys(keys);\n\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n\n    return animation;\n  };\n  /**\r\n   * Appends the serialized animations from the source animations\r\n   * @param source Source containing the animations\r\n   * @param destination Target to store the animations\r\n   */\n\n\n  Animation.AppendSerializedAnimations = function (source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  };\n  /**\r\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @returns a promise that will resolve to the new animation or an array of animations\r\n   */\n\n\n  Animation.ParseFromFileAsync = function (name, url) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n\n            if (serializationObject.length) {\n              var output = new Array();\n\n              for (var _i = 0, serializationObject_1 = serializationObject; _i < serializationObject_1.length; _i++) {\n                var serializedAnimation = serializationObject_1[_i];\n                output.push(_this.Parse(serializedAnimation));\n              }\n\n              resolve(output);\n            } else {\n              var output = _this.Parse(serializationObject);\n\n              if (name) {\n                output.name = name;\n              }\n\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n   * @param snippetId defines the snippet to load\r\n   * @returns a promise that will resolve to the new animation or a new array of animations\r\n   */\n\n\n  Animation.CreateFromSnippetAsync = function (snippetId) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n\n            if (snippet.animations) {\n              var serializationObject = JSON.parse(snippet.animations);\n              var output = new Array();\n\n              for (var _i = 0, serializationObject_2 = serializationObject; _i < serializationObject_2.length; _i++) {\n                var serializedAnimation = serializationObject_2[_i];\n                output.push(_this.Parse(serializedAnimation));\n              }\n\n              resolve(output);\n            } else {\n              var serializationObject = JSON.parse(snippet.animation);\n\n              var output = _this.Parse(serializationObject);\n\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\r\n   * Use matrix interpolation instead of using direct key value when animating matrices\r\n   */\n\n\n  Animation.AllowMatricesInterpolation = false;\n  /**\r\n   * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n   */\n\n  Animation.AllowMatrixDecomposeForInterpolation = true;\n  /** Define the Url to load snippets */\n\n  Animation.SnippetUrl = \"https://snippet.babylonjs.com\"; // Statics\n\n  /**\r\n   * Float animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_FLOAT = 0;\n  /**\r\n   * Vector3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR3 = 1;\n  /**\r\n   * Quaternion animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_QUATERNION = 2;\n  /**\r\n   * Matrix animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_MATRIX = 3;\n  /**\r\n   * Color3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_COLOR3 = 4;\n  /**\r\n   * Color3 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_COLOR4 = 7;\n  /**\r\n   * Vector2 animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_VECTOR2 = 5;\n  /**\r\n   * Size animation type\r\n   */\n\n  Animation.ANIMATIONTYPE_SIZE = 6;\n  /**\r\n   * Relative Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_RELATIVE = 0;\n  /**\r\n   * Cycle Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_CYCLE = 1;\n  /**\r\n   * Constant Loop Mode\r\n   */\n\n  Animation.ANIMATIONLOOPMODE_CONSTANT = 2;\n  return Animation;\n}();\n\nexport { Animation };\n_TypeStore.RegisteredTypes[\"BABYLON.Animation\"] = Animation;\n\nNode._AnimationRangeFactory = function (name, from, to) {\n  return new AnimationRange(name, from, to);\n};","map":{"version":3,"sources":["../../../sourceES6/core/Animations/animation.ts"],"names":[],"mappings":"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","sourcesContent":["import { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { IAnimationKey, AnimationKeyInterpolation } from './animationKey';\r\nimport { AnimationRange } from './animationRange';\r\nimport { AnimationEvent } from './animationEvent';\r\nimport { Node } from \"../node\";\r\nimport { IAnimatable } from './animatable.interface';\r\nimport { Size } from '../Maths/math.size';\r\nimport { WebRequest } from '../Misc/webRequest';\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\ndeclare type RuntimeAnimation = import(\"./runtimeAnimation\").RuntimeAnimation;\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: IEasingFunction;\r\n\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @hidden Internal use\r\n     */\r\n    public static _PrepareAnimation(name: string, targetProperty: string, framePerSecond: number, totalFrame: number,\r\n        from: any, to: any, loopMode?: number, easingFunction?: EasingFunction): Nullable<Animation> {\r\n        var dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        var keys: Array<IAnimationKey> = [{ frame: 0, value: from }, { frame: totalFrame, value: to }];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        var animation: Animation = new Animation(property + \"Animation\",\r\n            property,\r\n            framePerSecond,\r\n            animationType,\r\n            Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(name: string, node: Node, targetProperty: string,\r\n        framePerSecond: number, totalFrame: number,\r\n        from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(name: string, node: Node, directDescendantsOnly: boolean, targetProperty: string,\r\n        framePerSecond: number, totalFrame: number,\r\n        from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable[]> {\r\n\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        let scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(name: string, node: Node, targetProperty: string,\r\n        framePerSecond: number, totalFrame: number,\r\n        from: any, to: any, loopMode?: number, easingFunction?: EasingFunction, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n\r\n        var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): Animation {\r\n        let animation = sourceAnimation;\r\n\r\n        if (cloneOriginal) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = clonedName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\r\n        let startIndex = 0;\r\n        let firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        let lastKey = animation._keys[endIndex];\r\n        let valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3]\r\n        };\r\n        let referenceFound = false;\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (range) {\r\n            let rangeValue = animation.getRange(range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        }\r\n        let fromKeyFound = firstKey.frame === from;\r\n        let toKeyFound = lastKey.frame === to;\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            let value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            let value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            let value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Find key bookends, create them if they don't exist\r\n        var index = 0;\r\n        while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\r\n            let currentKey = animation._keys[index];\r\n            let nextKey = animation._keys[index + 1];\r\n\r\n            // If reference frame wasn't found yet, check if we can interpolate to it\r\n            if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\r\n                let value;\r\n\r\n                if (referenceFrame === currentKey.frame) {\r\n                    value = animation._getKeyValue(currentKey.value);\r\n                } else if (referenceFrame === nextKey.frame) {\r\n                    value = animation._getKeyValue(nextKey.value);\r\n                } else {\r\n                    let animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    value = animation._interpolate(referenceFrame, animationState);\r\n                }\r\n\r\n                valueStore.referenceValue = value.clone ? value.clone() : value;\r\n                referenceFound = true;\r\n            }\r\n\r\n            // If from key wasn't found yet, check if we can interpolate to it\r\n            if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\r\n                if (from === currentKey.frame) {\r\n                    startIndex = index;\r\n                } else if (from === nextKey.frame) {\r\n                    startIndex = index + 1;\r\n                } else {\r\n                    let animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    let value = animation._interpolate(from, animationState);\r\n                    let key: IAnimationKey = {\r\n                        frame: from,\r\n                        value: value.clone ? value.clone() : value\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    startIndex = index + 1;\r\n                }\r\n\r\n                fromKeyFound = true;\r\n            }\r\n\r\n            // If to key wasn't found yet, check if we can interpolate to it\r\n            if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\r\n                if (to === currentKey.frame) {\r\n                    endIndex = index;\r\n                } else if (to === nextKey.frame) {\r\n                    endIndex = index + 1;\r\n                } else {\r\n                    let animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT\r\n                    };\r\n                    let value = animation._interpolate(to, animationState);\r\n                    let key: IAnimationKey = {\r\n                        frame: to,\r\n                        value: value.clone ? value.clone() : value\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    endIndex = index + 1;\r\n                }\r\n\r\n                toKeyFound = true;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (var index = startIndex; index <= endIndex; index++) {\r\n            let key = animation._keys[index];\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(property: string, targetValue: any, host: any, scene: Scene, frameRate: number, transition: Animation, duration: number, onAnimationEnd: Nullable<() => void> = null): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        var endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([{\r\n            frame: 0,\r\n            value: host[property].clone ? host[property].clone() : host[property]\r\n        },\r\n        {\r\n            frame: endFrame,\r\n            value: targetValue\r\n        }]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        var animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (var runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + ([\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"])[this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            var first = true;\r\n            for (var name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (var index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        let range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n\r\n        }\r\n        if (deleteFrames) {\r\n            var from = range.from;\r\n            var to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (var key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        var ret = 0;\r\n\r\n        for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): IEasingFunction {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: EasingFunction): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearl\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        if (keys.length === 1) {\r\n            return this._getKeyValue(keys[0].value);\r\n        }\r\n\r\n        var startKeyIndex = state.key;\r\n\r\n        if (keys[startKeyIndex].frame >= currentFrame) {\r\n            while (startKeyIndex - 1 >= 0 && keys[startKeyIndex].frame >= currentFrame) {\r\n                startKeyIndex--;\r\n            }\r\n        }\r\n\r\n        for (var key = startKeyIndex; key < keys.length; key++) {\r\n            var endKey = keys[key + 1];\r\n\r\n            if (endKey.frame >= currentFrame) {\r\n                state.key = key;\r\n                var startKey = keys[key];\r\n                var startValue = this._getKeyValue(startKey.value);\r\n                if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n                    return startValue;\r\n                }\r\n\r\n                var endValue = this._getKeyValue(endKey.value);\r\n\r\n                var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n                var frameDelta = endKey.frame - startKey.frame;\r\n\r\n                // gradient : percent of currentFrame between the frame inf and the frame sup\r\n                var gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n                // check for easingFunction and correction of gradient\r\n                let easingFunction = this.getEasingFunction();\r\n                if (easingFunction != null) {\r\n                    gradient = easingFunction.ease(gradient);\r\n                }\r\n\r\n                switch (this.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return floatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return state.offsetValue * state.repeatCount + floatValue;\r\n                        }\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return quatValue;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n\r\n                        return quatValue;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec3Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return vec2Value;\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.color3InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Color4\r\n                    case Animation.ANIMATIONTYPE_COLOR4:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                return this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return this.color4InterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                        }\r\n                    // Matrix\r\n                    case Animation.ANIMATIONTYPE_MATRIX:\r\n                        switch (state.loopMode) {\r\n                            case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                            case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                                if (Animation.AllowMatricesInterpolation) {\r\n                                    return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                                }\r\n                            case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                                return startValue;\r\n                        }\r\n                    default:\r\n                        break;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this._getKeyValue(keys[keys.length - 1].value);\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (var name in this._ranges) {\r\n                let range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>): void {\r\n        this._keys = values.slice(0);\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        var dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        var keys = this.getKeys();\r\n        for (var index = 0; index < keys.length; index++) {\r\n            var animationKey = keys[index];\r\n\r\n            var key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (var name in this._ranges) {\r\n            let source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            var range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n\r\n    /** @hidden */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        let constructor = left.constructor;\r\n        if (constructor.Lerp) { // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) { // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) { // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else { // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        var dataType = parsedAnimation.dataType;\r\n        var keys: Array<IAnimationKey> = [];\r\n        var data;\r\n        var index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            var key = parsedAnimation.keys[index];\r\n            var inTangent: any;\r\n            var outTangent: any;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 1) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 2) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        var _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        var _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    break;\r\n            }\r\n\r\n            var keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n\r\n                        if (serializationObject.length) {\r\n                            let output = new Array<Animation>();\r\n                            for (var serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            let output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            let serializationObject = JSON.parse(snippet.animations);\r\n                            let output = new Array<Animation>();\r\n                            for (var serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            let serializationObject = JSON.parse(snippet.animation);\r\n                            let output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.Animation\"] = Animation;\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}