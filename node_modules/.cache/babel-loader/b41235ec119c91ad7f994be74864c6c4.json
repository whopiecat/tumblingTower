{"ast":null,"code":"import { TmpVectors } from \"../../Maths/math.vector\";\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\nimport { VertexBuffer } from \"../buffer\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\n\nVertexData.CreateRibbon = function (options) {\n  var pathArray = options.pathArray;\n  var closeArray = options.closeArray || false;\n  var closePath = options.closePath || false;\n  var invertUV = options.invertUV || false;\n  var defaultOffset = Math.floor(pathArray[0].length / 2);\n  var offset = options.offset || defaultOffset;\n  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var customUV = options.uvs;\n  var customColors = options.colors;\n  var positions = [];\n  var indices = [];\n  var normals = [];\n  var uvs = [];\n  var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n\n  var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray\n\n  var uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n\n  var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n\n  var minlg; // minimal length among all paths from pathArray\n\n  var lg = []; // array of path lengths : nb of vertex per path\n\n  var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n\n  var p; // path iterator\n\n  var i; // point iterator\n\n  var j; // point iterator\n  // if single path in pathArray\n\n  if (pathArray.length < 2) {\n    var ar1 = [];\n    var ar2 = [];\n\n    for (i = 0; i < pathArray[0].length - offset; i++) {\n      ar1.push(pathArray[0][i]);\n      ar2.push(pathArray[0][i + offset]);\n    }\n\n    pathArray = [ar1, ar2];\n  } // positions and horizontal distances (u)\n\n\n  var idc = 0;\n  var closePathCorr = closePath ? 1 : 0; // the final index will be +1 if closePath\n\n  var path;\n  var l;\n  minlg = pathArray[0].length;\n  var vectlg;\n  var dist;\n\n  for (p = 0; p < pathArray.length; p++) {\n    uTotalDistance[p] = 0;\n    us[p] = [0];\n    path = pathArray[p];\n    l = path.length;\n    minlg = minlg < l ? minlg : l;\n    j = 0;\n\n    while (j < l) {\n      positions.push(path[j].x, path[j].y, path[j].z);\n\n      if (j > 0) {\n        vectlg = path[j].subtract(path[j - 1]).length();\n        dist = vectlg + uTotalDistance[p];\n        us[p].push(dist);\n        uTotalDistance[p] = dist;\n      }\n\n      j++;\n    }\n\n    if (closePath) {\n      // an extra hidden vertex is added in the \"positions\" array\n      j--;\n      positions.push(path[0].x, path[0].y, path[0].z);\n      vectlg = path[j].subtract(path[0]).length();\n      dist = vectlg + uTotalDistance[p];\n      us[p].push(dist);\n      uTotalDistance[p] = dist;\n    }\n\n    lg[p] = l + closePathCorr;\n    idx[p] = idc;\n    idc += l + closePathCorr;\n  } // vertical distances (v)\n\n\n  var path1;\n  var path2;\n  var vertex1 = null;\n  var vertex2 = null;\n\n  for (i = 0; i < minlg + closePathCorr; i++) {\n    vTotalDistance[i] = 0;\n    vs[i] = [0];\n\n    for (p = 0; p < pathArray.length - 1; p++) {\n      path1 = pathArray[p];\n      path2 = pathArray[p + 1];\n\n      if (i === minlg) {\n        // closePath\n        vertex1 = path1[0];\n        vertex2 = path2[0];\n      } else {\n        vertex1 = path1[i];\n        vertex2 = path2[i];\n      }\n\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vs[i].push(dist);\n      vTotalDistance[i] = dist;\n    }\n\n    if (closeArray && vertex2 && vertex1) {\n      path1 = pathArray[p];\n      path2 = pathArray[0];\n\n      if (i === minlg) {\n        // closePath\n        vertex2 = path2[0];\n      }\n\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vTotalDistance[i] = dist;\n    }\n  } // uvs\n\n\n  var u;\n  var v;\n\n  if (customUV) {\n    for (p = 0; p < customUV.length; p++) {\n      uvs.push(customUV[p].x, customUV[p].y);\n    }\n  } else {\n    for (p = 0; p < pathArray.length; p++) {\n      for (i = 0; i < minlg + closePathCorr; i++) {\n        u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\n        v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\n\n        if (invertUV) {\n          uvs.push(v, u);\n        } else {\n          uvs.push(u, v);\n        }\n      }\n    }\n  } // indices\n\n\n  p = 0; // path index\n\n  var pi = 0; // positions array index\n\n  var l1 = lg[p] - 1; // path1 length\n\n  var l2 = lg[p + 1] - 1; // path2 length\n\n  var min = l1 < l2 ? l1 : l2; // current path stop index\n\n  var shft = idx[1] - idx[0]; // shift\n\n  var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n\n  while (pi <= min && p < path1nb) {\n    //  stay under min and don't go over next to last path\n    // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n    indices.push(pi, pi + shft, pi + 1);\n    indices.push(pi + shft + 1, pi + 1, pi + shft);\n    pi += 1;\n\n    if (pi === min) {\n      // if end of one of two consecutive paths reached, go to next existing path\n      p++;\n\n      if (p === lg.length - 1) {\n        // last path of pathArray reached <=> closeArray == true\n        shft = idx[0] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[0] - 1;\n      } else {\n        shft = idx[p + 1] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[p + 1] - 1;\n      }\n\n      pi = idx[p];\n      min = l1 < l2 ? l1 + pi : l2 + pi;\n    }\n  } // normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  if (closePath) {\n    // update both the first and last vertex normals to their average value\n    var indexFirst = 0;\n    var indexLast = 0;\n\n    for (p = 0; p < pathArray.length; p++) {\n      indexFirst = idx[p] * 3;\n\n      if (p + 1 < pathArray.length) {\n        indexLast = (idx[p + 1] - 1) * 3;\n      } else {\n        indexLast = normals.length - 3;\n      }\n\n      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n      normals[indexLast] = normals[indexFirst];\n      normals[indexLast + 1] = normals[indexFirst + 1];\n      normals[indexLast + 2] = normals[indexFirst + 2];\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Colors\n\n\n  var colors = null;\n\n  if (customColors) {\n    colors = new Float32Array(customColors.length * 4);\n\n    for (var c = 0; c < customColors.length; c++) {\n      colors[c * 4] = customColors[c].r;\n      colors[c * 4 + 1] = customColors[c].g;\n      colors[c * 4 + 2] = customColors[c].b;\n      colors[c * 4 + 3] = customColors[c].a;\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  var positions32 = new Float32Array(positions);\n  var normals32 = new Float32Array(normals);\n  var uvs32 = new Float32Array(uvs);\n  vertexData.indices = indices;\n  vertexData.positions = positions32;\n  vertexData.normals = normals32;\n  vertexData.uvs = uvs32;\n\n  if (colors) {\n    vertexData.set(colors, VertexBuffer.ColorKind);\n  }\n\n  if (closePath) {\n    vertexData._idx = idx;\n  }\n\n  return vertexData;\n};\n\nMesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\n  if (closeArray === void 0) {\n    closeArray = false;\n  }\n\n  if (updatable === void 0) {\n    updatable = false;\n  }\n\n  return RibbonBuilder.CreateRibbon(name, {\n    pathArray: pathArray,\n    closeArray: closeArray,\n    closePath: closePath,\n    offset: offset,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  }, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar RibbonBuilder =\n/** @class */\nfunction () {\n  function RibbonBuilder() {}\n  /**\r\n   * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n   * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n   * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n   * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n   * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n   * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n   * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n   * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n   * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n   * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the ribbon mesh\r\n   * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   */\n\n\n  RibbonBuilder.CreateRibbon = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var pathArray = options.pathArray;\n    var closeArray = options.closeArray;\n    var closePath = options.closePath;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var instance = options.instance;\n    var updatable = options.updatable;\n\n    if (instance) {\n      // existing ribbon instance update\n      // positionFunction : ribbon case\n      // only pathArray and sideOrientation parameters are taken into account for positions update\n      var minimum_1 = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\n      var maximum_1 = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\n\n      var positionFunction = function (positions) {\n        var minlg = pathArray[0].length;\n        var mesh = instance;\n        var i = 0;\n        var ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\n\n        for (var si = 1; si <= ns; ++si) {\n          for (var p = 0; p < pathArray.length; ++p) {\n            var path = pathArray[p];\n            var l = path.length;\n            minlg = minlg < l ? minlg : l;\n\n            for (var j = 0; j < minlg; ++j) {\n              var pathPoint = path[j];\n              positions[i] = pathPoint.x;\n              positions[i + 1] = pathPoint.y;\n              positions[i + 2] = pathPoint.z;\n              minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n              maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n              i += 3;\n            }\n\n            if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\n              var pathPoint = path[0];\n              positions[i] = pathPoint.x;\n              positions[i + 1] = pathPoint.y;\n              positions[i + 2] = pathPoint.z;\n              i += 3;\n            }\n          }\n        }\n      };\n\n      var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n      positionFunction(positions);\n\n      if (instance._boundingInfo) {\n        instance._boundingInfo.reConstruct(minimum_1, maximum_1, instance._worldMatrix);\n      } else {\n        instance._boundingInfo = new BoundingInfo(minimum_1, maximum_1, instance._worldMatrix);\n      }\n\n      instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n      if (options.colors) {\n        var colors = instance.getVerticesData(VertexBuffer.ColorKind);\n\n        for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\n          var color = options.colors[c];\n          colors[colorIndex] = color.r;\n          colors[colorIndex + 1] = color.g;\n          colors[colorIndex + 2] = color.b;\n          colors[colorIndex + 3] = color.a;\n        }\n\n        instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\n      }\n\n      if (options.uvs) {\n        var uvs = instance.getVerticesData(VertexBuffer.UVKind);\n\n        for (var i = 0; i < options.uvs.length; i++) {\n          uvs[i * 2] = options.uvs[i].x;\n          uvs[i * 2 + 1] = options.uvs[i].y;\n        }\n\n        instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\n      }\n\n      if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n        var indices = instance.getIndices();\n        var normals = instance.getVerticesData(VertexBuffer.NormalKind);\n        var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n        VertexData.ComputeNormals(positions, indices, normals, params);\n\n        if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\n          var indexFirst = 0;\n          var indexLast = 0;\n\n          for (var p = 0; p < pathArray.length; p++) {\n            indexFirst = instance._creationDataStorage.idx[p] * 3;\n\n            if (p + 1 < pathArray.length) {\n              indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\n            } else {\n              indexLast = normals.length - 3;\n            }\n\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n            normals[indexLast] = normals[indexFirst];\n            normals[indexLast + 1] = normals[indexFirst + 1];\n            normals[indexLast + 2] = normals[indexFirst + 2];\n          }\n        }\n\n        if (!instance.areNormalsFrozen) {\n          instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n        }\n      }\n\n      return instance;\n    } else {\n      // new ribbon creation\n      var ribbon = new Mesh(name, scene);\n      ribbon._originalBuilderSideOrientation = sideOrientation;\n      ribbon._creationDataStorage = new _CreationDataStorage();\n      var vertexData = VertexData.CreateRibbon(options);\n\n      if (closePath) {\n        ribbon._creationDataStorage.idx = vertexData._idx;\n      }\n\n      ribbon._creationDataStorage.closePath = closePath;\n      ribbon._creationDataStorage.closeArray = closeArray;\n      vertexData.applyToMesh(ribbon, updatable);\n      return ribbon;\n    }\n  };\n\n  return RibbonBuilder;\n}();\n\nexport { RibbonBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/ribbonBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\r\n\r\nVertexData.CreateRibbon = function(options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }): VertexData {\r\n    var pathArray: Vector3[][] = options.pathArray;\r\n    var closeArray: boolean = options.closeArray || false;\r\n    var closePath: boolean = options.closePath || false;\r\n    var invertUV: boolean = options.invertUV || false;\r\n    var defaultOffset: number = Math.floor(pathArray[0].length / 2);\r\n    var offset: number = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    var sideOrientation: number = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var customUV = options.uvs;\r\n    var customColors = options.colors;\r\n\r\n    var positions: number[] = [];\r\n    var indices: number[] = [];\r\n    var normals: number[] = [];\r\n    var uvs: number[] = [];\r\n\r\n    var us: number[][] = [];        \t\t// us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    var vs: number[][] = [];        \t\t// vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray\r\n    var uTotalDistance: number[] = []; \t\t// uTotalDistance[p] : total distance of path p\r\n    var vTotalDistance: number[] = []; \t\t//  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    var minlg: number;          \t        // minimal length among all paths from pathArray\r\n    var lg: number[] = [];        \t\t    // array of path lengths : nb of vertex per path\r\n    var idx: number[] = [];       \t\t    // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    var p: number;\t\t\t\t\t\t\t// path iterator\r\n    var i: number;\t\t\t\t\t\t\t// point iterator\r\n    var j: number;\t\t\t\t\t\t\t// point iterator\r\n\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        var ar1: Vector3[] = [];\r\n        var ar2: Vector3[] = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n\r\n    // positions and horizontal distances (u)\r\n    var idc: number = 0;\r\n    var closePathCorr: number = (closePath) ? 1 : 0;    // the final index will be +1 if closePath\r\n    var path: Vector3[];\r\n    var l: number;\r\n    minlg = pathArray[0].length;\r\n    var vectlg: number;\r\n    var dist: number;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = (minlg < l) ? minlg : l;\r\n\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n\r\n        if (closePath) {        // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += (l + closePathCorr);\r\n    }\r\n\r\n    // vertical distances (v)\r\n    var path1: Vector3[];\r\n    var path2: Vector3[];\r\n    var vertex1: Nullable<Vector3> = null;\r\n    var vertex2: Nullable<Vector3> = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) {   // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            }\r\n            else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) {   // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n\r\n    // uvs\r\n    var u: number;\r\n    var v: number;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, customUV[p].y);\r\n        }\r\n    }\r\n    else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = (uTotalDistance[p] != 0.0) ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = (vTotalDistance[i] != 0.0) ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                } else {\r\n                    uvs.push(u, v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    p = 0;                    \t\t\t\t\t// path index\r\n    var pi: number = 0;                    \t\t// positions array index\r\n    var l1: number = lg[p] - 1;           \t\t// path1 length\r\n    var l2: number = lg[p + 1] - 1;         \t// path2 length\r\n    var min: number = (l1 < l2) ? l1 : l2;   \t// current path stop index\r\n    var shft: number = idx[1] - idx[0];         // shift\r\n    var path1nb: number = closeArray ? lg.length : lg.length - 1;     // number of path1 to iterate\ton\r\n\r\n    while (pi <= min && p < path1nb) {       \t//  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) {                   \t\t\t// if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) {                 // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            }\r\n            else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = (l1 < l2) ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n\r\n    // normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    if (closePath) {        // update both the first and last vertex normals to their average value\r\n        var indexFirst: number = 0;\r\n        var indexLast: number = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            }\r\n            else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Colors\r\n    let colors: Nullable<Float32Array> = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (var c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    var positions32 = new Float32Array(positions);\r\n    var normals32 = new Float32Array(normals);\r\n    var uvs32 = new Float32Array(uvs);\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, VertexBuffer.ColorKind);\r\n    }\r\n\r\n    if (closePath) {\r\n        (<any>vertexData)._idx = idx;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateRibbon = (name: string, pathArray: Vector3[][], closeArray: boolean = false, closePath: boolean, offset: number, scene?: Scene, updatable: boolean = false, sideOrientation?: number, instance?: Mesh) => {\r\n    return RibbonBuilder.CreateRibbon(name, {\r\n        pathArray: pathArray,\r\n        closeArray: closeArray,\r\n        closePath: closePath,\r\n        offset: offset,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    }, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class RibbonBuilder {\r\n    /**\r\n     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ribbon mesh\r\n     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     */\r\n    public static CreateRibbon(name: string, options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }, scene: Nullable<Scene> = null): Mesh {\r\n        var pathArray = options.pathArray;\r\n        var closeArray = options.closeArray;\r\n        var closePath = options.closePath;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var updatable = options.updatable;\r\n\r\n        if (instance) {   // existing ribbon instance update\r\n            // positionFunction : ribbon case\r\n            // only pathArray and sideOrientation parameters are taken into account for positions update\r\n            const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\r\n            const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\r\n            var positionFunction = (positions: FloatArray) => {\r\n                var minlg = pathArray[0].length;\r\n                var mesh = (<Mesh>instance);\r\n                var i = 0;\r\n                var ns = (mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE) ? 2 : 1;\r\n                for (var si = 1; si <= ns; ++si) {\r\n                    for (var p = 0; p < pathArray.length; ++p) {\r\n                        var path = pathArray[p];\r\n                        var l = path.length;\r\n                        minlg = (minlg < l) ? minlg : l;\r\n                        for (let j = 0; j < minlg; ++j) {\r\n                            const pathPoint = path[j];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            i += 3;\r\n                        }\r\n                        if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                            const pathPoint = path[0];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            i += 3;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            var positions = <FloatArray>instance.getVerticesData(VertexBuffer.PositionKind);\r\n            positionFunction(positions);\r\n            if (instance._boundingInfo) {\r\n                instance._boundingInfo.reConstruct(minimum, maximum, instance._worldMatrix);\r\n            }\r\n            else {\r\n                instance._boundingInfo = new BoundingInfo(minimum, maximum, instance._worldMatrix);\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n            if (options.colors) {\r\n                var colors = <FloatArray>instance.getVerticesData(VertexBuffer.ColorKind);\r\n                for (var c = 0, colorIndex = 0; c < options.colors.length; c++ , colorIndex += 4) {\r\n                    const color = options.colors[c];\r\n                    colors[colorIndex] = color.r;\r\n                    colors[colorIndex + 1] = color.g;\r\n                    colors[colorIndex + 2] = color.b;\r\n                    colors[colorIndex + 3] = color.a;\r\n                }\r\n                instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\r\n            }\r\n            if (options.uvs) {\r\n                var uvs = <FloatArray>instance.getVerticesData(VertexBuffer.UVKind);\r\n                for (var i = 0; i < options.uvs.length; i++) {\r\n                    uvs[i * 2] = options.uvs[i].x;\r\n                    uvs[i * 2 + 1] = options.uvs[i].y;\r\n                }\r\n                instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\r\n            }\r\n            if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n                var indices = instance.getIndices();\r\n                var normals = <FloatArray>instance.getVerticesData(VertexBuffer.NormalKind);\r\n                var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n                VertexData.ComputeNormals(positions, indices, normals, params);\r\n\r\n                if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                    var indexFirst: number = 0;\r\n                    var indexLast: number = 0;\r\n                    for (var p = 0; p < pathArray.length; p++) {\r\n                        indexFirst = instance._creationDataStorage!.idx[p] * 3;\r\n                        if (p + 1 < pathArray.length) {\r\n                            indexLast = (instance._creationDataStorage!.idx[p + 1] - 1) * 3;\r\n                        }\r\n                        else {\r\n                            indexLast = normals.length - 3;\r\n                        }\r\n                        normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                        normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                        normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                        normals[indexLast] = normals[indexFirst];\r\n                        normals[indexLast + 1] = normals[indexFirst + 1];\r\n                        normals[indexLast + 2] = normals[indexFirst + 2];\r\n                    }\r\n                }\r\n                if (!(instance.areNormalsFrozen)) {\r\n                    instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\r\n                }\r\n            }\r\n\r\n            return instance;\r\n        }\r\n        else {  // new ribbon creation\r\n\r\n            var ribbon = new Mesh(name, scene);\r\n            ribbon._originalBuilderSideOrientation = sideOrientation;\r\n            ribbon._creationDataStorage = new _CreationDataStorage();\r\n\r\n            var vertexData = VertexData.CreateRibbon(options);\r\n            if (closePath) {\r\n                ribbon._creationDataStorage.idx = (<any>vertexData)._idx;\r\n            }\r\n            ribbon._creationDataStorage.closePath = closePath;\r\n            ribbon._creationDataStorage.closeArray = closeArray;\r\n\r\n            vertexData.applyToMesh(ribbon, updatable);\r\n\r\n            return ribbon;\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}