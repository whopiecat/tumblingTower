{"ast":null,"code":"import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\n/**\r\n * @hidden\r\n */\n\nvar FaceDirectionInfo =\n/** @class */\nfunction () {\n  function FaceDirectionInfo(direction, rotatedDirection, diff, ignore) {\n    if (rotatedDirection === void 0) {\n      rotatedDirection = new Vector3();\n    }\n\n    if (diff === void 0) {\n      diff = 0;\n    }\n\n    if (ignore === void 0) {\n      ignore = false;\n    }\n\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n\n  return FaceDirectionInfo;\n}();\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\n\n\nvar AttachToBoxBehavior =\n/** @class */\nfunction () {\n  /**\r\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n   * @param ui The transform node that should be attched to the mesh\r\n   */\n  function AttachToBoxBehavior(ui) {\n    this.ui = ui;\n    /**\r\n     *  The name of the behavior\r\n     */\n\n    this.name = \"AttachToBoxBehavior\";\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\n\n    this.distanceAwayFromFace = 0.15;\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\n\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\r\n   *  Initializes the behavior\r\n   */\n\n\n  AttachToBoxBehavior.prototype.init = function () {\n    /* Does nothing */\n  };\n\n  AttachToBoxBehavior.prototype._closestFace = function (targetDirection) {\n    var _this = this; // Go over each face and calculate the angle between the face's normal and targetDirection\n\n\n    this._faceVectors.forEach(function (v) {\n      if (!_this._target.rotationQuaternion) {\n        _this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._target.rotation.y, _this._target.rotation.x, _this._target.rotation.z);\n      }\n\n      _this._target.rotationQuaternion.toRotationMatrix(_this._tmpMatrix);\n\n      Vector3.TransformCoordinatesToRef(v.direction, _this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    }); // Return the face information of the one with the normal closeset to target direction\n\n\n    return this._faceVectors.reduce(function (min, p) {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  };\n\n  AttachToBoxBehavior.prototype._lookAtToRef = function (pos, up, ref) {\n    if (up === void 0) {\n      up = new Vector3(0, 1, 0);\n    }\n\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n\n    this._lookAtTmpMatrix.invert();\n\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  };\n  /**\r\n   * Attaches the AttachToBoxBehavior to the passed in mesh\r\n   * @param target The mesh that the specified node will be attached to\r\n   */\n\n\n  AttachToBoxBehavior.prototype.attach = function (target) {\n    var _this = this;\n\n    this._target = target;\n    this._scene = this._target.getScene(); // Every frame, update the app bars position\n\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n      if (!_this._scene.activeCamera) {\n        return;\n      } // Find the face closest to the cameras position\n\n\n      var cameraPos = _this._scene.activeCamera.position;\n\n      if (_this._scene.activeCamera.devicePosition) {\n        cameraPos = _this._scene.activeCamera.devicePosition;\n      }\n\n      var facing = _this._closestFace(cameraPos.subtract(target.position));\n\n      if (_this._scene.activeCamera.leftCamera) {\n        _this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } else {\n        _this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(_this._tmpMatrix);\n      } // Get camera up direction\n\n\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), _this._tmpMatrix, _this._tmpVector); // Ignore faces to not select a parrelel face for the up vector of the UI\n\n      _this._faceVectors.forEach(function (v) {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n\n      var facingUp = _this._closestFace(_this._tmpVector); // Unignore faces\n\n\n      _this._faceVectors.forEach(function (v) {\n        v.ignore = false;\n      }); // Position the app bar on that face\n\n\n      _this.ui.position.copyFrom(target.position);\n\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      }\n\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + _this.distanceAwayFromFace, _this._tmpVector);\n\n        _this.ui.position.addInPlace(_this._tmpVector);\n      } // Rotate to be oriented properly to the camera\n\n\n      if (!_this.ui.rotationQuaternion) {\n        _this.ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.ui.rotation.y, _this.ui.rotation.x, _this.ui.rotation.z);\n      }\n\n      facing.rotatedDirection.scaleToRef(-1, _this._tmpVector);\n\n      _this._lookAtToRef(_this._tmpVector, facingUp.rotatedDirection, _this.ui.rotationQuaternion); // Place ui the correct distance from the bottom of the mesh\n\n\n      if (facingUp.direction.x) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.x / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.y) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.y / 2, _this._tmpVector);\n      }\n\n      if (facingUp.direction.z) {\n        _this.ui.up.scaleToRef(_this.distanceAwayFromBottomOfFace - target.scaling.z / 2, _this._tmpVector);\n      }\n\n      _this.ui.position.addInPlace(_this._tmpVector);\n    });\n  };\n  /**\r\n   *  Detaches the behavior from the mesh\r\n   */\n\n\n  AttachToBoxBehavior.prototype.detach = function () {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  };\n\n  return AttachToBoxBehavior;\n}();\n\nexport { AttachToBoxBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Meshes/attachToBoxBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Behavior } from \"../../Behaviors/behavior\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nclass FaceDirectionInfo {\r\n    constructor(public direction: Vector3, public rotatedDirection = new Vector3(), public diff = 0, public ignore = false) { }\r\n}\r\n\r\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\r\nexport class AttachToBoxBehavior implements Behavior<Mesh> {\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public name = \"AttachToBoxBehavior\";\r\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromFace = 0.15;\r\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromBottomOfFace = 0.15;\r\n    private _faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\r\n    private _target: Mesh;\r\n    private _scene: Scene;\r\n    private _onRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVector = new Vector3();\r\n\r\n    /**\r\n     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n     * @param ui The transform node that should be attched to the mesh\r\n     */\r\n    constructor(private ui: TransformNode) {\r\n        /* Does nothing */\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {\r\n        /* Does nothing */\r\n    }\r\n\r\n    private _closestFace(targetDirection: Vector3) {\r\n        // Go over each face and calculate the angle between the face's normal and targetDirection\r\n        this._faceVectors.forEach((v) => {\r\n            if (!this._target.rotationQuaternion) {\r\n                this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\r\n            }\r\n            this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\r\n            Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\r\n            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\r\n        });\r\n        // Return the face information of the one with the normal closeset to target direction\r\n        return this._faceVectors.reduce((min, p) => {\r\n            if (min.ignore) {\r\n                return p;\r\n            } else if (p.ignore) {\r\n                return min;\r\n            } else {\r\n                return min.diff < p.diff ? min : p;\r\n            }\r\n        }, this._faceVectors[0]);\r\n    }\r\n\r\n    private _zeroVector = Vector3.Zero();\r\n    private _lookAtTmpMatrix = new Matrix();\r\n    private _lookAtToRef(pos: Vector3, up = new Vector3(0, 1, 0), ref: Quaternion) {\r\n        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\r\n        this._lookAtTmpMatrix.invert();\r\n        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\r\n    }\r\n\r\n    /**\r\n     * Attaches the AttachToBoxBehavior to the passed in mesh\r\n     * @param target The mesh that the specified node will be attached to\r\n     */\r\n    attach(target: Mesh) {\r\n        this._target = target;\r\n        this._scene = this._target.getScene();\r\n\r\n        // Every frame, update the app bars position\r\n        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            // Find the face closest to the cameras position\r\n            var cameraPos = this._scene.activeCamera.position;\r\n            if ((<any>this._scene.activeCamera).devicePosition) {\r\n                cameraPos = (<any>this._scene.activeCamera).devicePosition;\r\n            }\r\n            var facing = this._closestFace(cameraPos.subtract(target.position));\r\n            if (this._scene.activeCamera.leftCamera) {\r\n                this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            } else {\r\n                this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            }\r\n\r\n            // Get camera up direction\r\n            Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\r\n            // Ignore faces to not select a parrelel face for the up vector of the UI\r\n            this._faceVectors.forEach((v) => {\r\n                if (facing.direction.x && v.direction.x) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.y && v.direction.y) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.z && v.direction.z) {\r\n                    v.ignore = true;\r\n                }\r\n            });\r\n            var facingUp = this._closestFace(this._tmpVector);\r\n            // Unignore faces\r\n            this._faceVectors.forEach((v) => {\r\n                v.ignore = false;\r\n            });\r\n\r\n            // Position the app bar on that face\r\n            this.ui.position.copyFrom(target.position);\r\n            if (facing.direction.x) {\r\n                facing.rotatedDirection.scaleToRef((target.scaling.x / 2) + this.distanceAwayFromFace, this._tmpVector);\r\n                this.ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.y) {\r\n                facing.rotatedDirection.scaleToRef((target.scaling.y / 2) + this.distanceAwayFromFace, this._tmpVector);\r\n                this.ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.z) {\r\n                facing.rotatedDirection.scaleToRef((target.scaling.z / 2) + this.distanceAwayFromFace, this._tmpVector);\r\n                this.ui.position.addInPlace(this._tmpVector);\r\n            }\r\n\r\n            // Rotate to be oriented properly to the camera\r\n            if (!this.ui.rotationQuaternion) {\r\n                this.ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.ui.rotation.y, this.ui.rotation.x, this.ui.rotation.z);\r\n            }\r\n            facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\r\n            this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this.ui.rotationQuaternion);\r\n\r\n            // Place ui the correct distance from the bottom of the mesh\r\n            if (facingUp.direction.x) {\r\n                this.ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.y) {\r\n                this.ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.z) {\r\n                this.ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\r\n            }\r\n            this.ui.position.addInPlace(this._tmpVector);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    detach() {\r\n        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}