{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Tools } from \"./Misc/tools\";\nimport { PrecisionDate } from \"./Misc/precisionDate\";\nimport { Observable } from \"./Misc/observable\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray\";\nimport { StringDictionary } from \"./Misc/stringDictionary\";\nimport { Tags } from \"./Misc/tags\";\nimport { Vector3, Matrix } from \"./Maths/math.vector\";\nimport { TransformNode } from \"./Meshes/transformNode\";\nimport { AbstractMesh } from \"./Meshes/abstractMesh\";\nimport { Camera } from \"./Cameras/camera\";\nimport { AbstractScene } from \"./abstractScene\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer\";\nimport { Light } from \"./Lights/light\";\nimport { PickingInfo } from \"./Collisions/pickingInfo\";\nimport { ActionEvent } from \"./Actions/actionEvent\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager\";\nimport { RenderingManager } from \"./Rendering/renderingManager\";\nimport { Stage } from \"./sceneComponent\";\nimport { DomManagement } from \"./Misc/domManagement\";\nimport { Logger } from \"./Misc/logger\";\nimport { EngineStore } from \"./Engines/engineStore\";\nimport { _DevTools } from './Misc/devTools';\nimport { InputManager } from './Inputs/scene.inputManager';\nimport { PerfCounter } from './Misc/perfCounter';\nimport { Color4, Color3 } from './Maths/math.color';\nimport { Frustum } from './Maths/math.frustum';\nimport { UniqueIdGenerator } from './Misc/uniqueIdGenerator';\nimport { FileTools } from './Misc/fileTools';\n/**\r\n * Represents a scene to be rendered by the engine.\r\n * @see https://doc.babylonjs.com/features/scene\r\n */\n\nvar Scene =\n/** @class */\nfunction (_super) {\n  __extends(Scene, _super);\n  /**\r\n   * Creates a new Scene\r\n   * @param engine defines the engine to use to render this scene\r\n   * @param options defines the scene options\r\n   */\n\n\n  function Scene(engine, options) {\n    var _this = _super.call(this) || this; // Members\n\n    /** @hidden */\n\n\n    _this._inputManager = new InputManager(_this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n\n    _this.cameraToUseForPointers = null;\n    /** @hidden */\n\n    _this._isScene = true;\n    /** @hidden */\n\n    _this._blockEntityCollection = false;\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\r\n     */\n\n    _this.autoClear = true;\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\r\n     */\n\n    _this.autoClearDepthAndStencil = true;\n    /**\r\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\r\n     */\n\n    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\r\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\r\n     */\n\n    _this.ambientColor = new Color3(0, 0, 0);\n    /** @hidden */\n\n    _this._environmentIntensity = 1;\n    _this._forceWireframe = false;\n    _this._skipFrustumClipping = false;\n    _this._forcePointsCloud = false;\n    /**\r\n     * Gets or sets a boolean indicating if animations are enabled\r\n     */\n\n    _this.animationsEnabled = true;\n    _this._animationPropertiesOverride = null;\n    /**\r\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\r\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\r\n     */\n\n    _this.useConstantAnimationDeltaTime = false;\n    /**\r\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\r\n     * Please note that it requires to run a ray cast through the scene on every frame\r\n     */\n\n    _this.constantlyUpdateMeshUnderPointer = false;\n    /**\r\n     * Defines the HTML cursor to use when hovering over interactive elements\r\n     */\n\n    _this.hoverCursor = \"pointer\";\n    /**\r\n     * Defines the HTML default cursor to use (empty by default)\r\n     */\n\n    _this.defaultCursor = \"\";\n    /**\r\n     * Defines whether cursors are handled by the scene.\r\n     */\n\n    _this.doNotHandleCursors = false;\n    /**\r\n     * This is used to call preventDefault() on pointer down\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\n\n    _this.preventDefaultOnPointerDown = true;\n    /**\r\n     * This is used to call preventDefault() on pointer up\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\n\n    _this.preventDefaultOnPointerUp = true; // Metadata\n\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\n\n    _this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    _this.reservedDataStore = null;\n    /**\r\n     * Use this array to add regular expressions used to disable offline support for specific urls\r\n     */\n\n    _this.disableOfflineSupportExceptionRules = new Array();\n    /**\r\n    * An event triggered when the scene is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    /**\r\n    * An event triggered before rendering the scene (right after animations and physics)\r\n    */\n\n    _this.onBeforeRenderObservable = new Observable();\n    _this._onBeforeRenderObserver = null;\n    /**\r\n    * An event triggered after rendering the scene\r\n    */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\r\n    */\n\n    _this.onAfterRenderCameraObservable = new Observable();\n    _this._onAfterRenderObserver = null;\n    /**\r\n    * An event triggered before animating the scene\r\n    */\n\n    _this.onBeforeAnimationsObservable = new Observable();\n    /**\r\n    * An event triggered after animations processing\r\n    */\n\n    _this.onAfterAnimationsObservable = new Observable();\n    /**\r\n    * An event triggered before draw calls are ready to be sent\r\n    */\n\n    _this.onBeforeDrawPhaseObservable = new Observable();\n    /**\r\n    * An event triggered after draw calls have been sent\r\n    */\n\n    _this.onAfterDrawPhaseObservable = new Observable();\n    /**\r\n    * An event triggered when the scene is ready\r\n    */\n\n    _this.onReadyObservable = new Observable();\n    /**\r\n    * An event triggered before rendering a camera\r\n    */\n\n    _this.onBeforeCameraRenderObservable = new Observable();\n    _this._onBeforeCameraRenderObserver = null;\n    /**\r\n    * An event triggered after rendering a camera\r\n    */\n\n    _this.onAfterCameraRenderObservable = new Observable();\n    _this._onAfterCameraRenderObserver = null;\n    /**\r\n    * An event triggered when active meshes evaluation is about to start\r\n    */\n\n    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\r\n    * An event triggered when active meshes evaluation is done\r\n    */\n\n    _this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\r\n    * An event triggered when particles rendering is about to start\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\n\n    _this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\r\n    * An event triggered when particles rendering is done\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\n\n    _this.onAfterParticlesRenderingObservable = new Observable();\n    /**\r\n    * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\r\n    */\n\n    _this.onDataLoadedObservable = new Observable();\n    /**\r\n    * An event triggered when a camera is created\r\n    */\n\n    _this.onNewCameraAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a camera is removed\r\n    */\n\n    _this.onCameraRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a light is created\r\n    */\n\n    _this.onNewLightAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a light is removed\r\n    */\n\n    _this.onLightRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a geometry is created\r\n    */\n\n    _this.onNewGeometryAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a geometry is removed\r\n    */\n\n    _this.onGeometryRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a transform node is created\r\n    */\n\n    _this.onNewTransformNodeAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a transform node is removed\r\n    */\n\n    _this.onTransformNodeRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a mesh is created\r\n    */\n\n    _this.onNewMeshAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a mesh is removed\r\n    */\n\n    _this.onMeshRemovedObservable = new Observable();\n    /**\r\n     * An event triggered when a skeleton is created\r\n     */\n\n    _this.onNewSkeletonAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a skeleton is removed\r\n    */\n\n    _this.onSkeletonRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a material is created\r\n    */\n\n    _this.onNewMaterialAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a multi material is created\r\n    */\n\n    _this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a material is removed\r\n    */\n\n    _this.onMaterialRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a multi material is removed\r\n    */\n\n    _this.onMultiMaterialRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when a texture is created\r\n    */\n\n    _this.onNewTextureAddedObservable = new Observable();\n    /**\r\n    * An event triggered when a texture is removed\r\n    */\n\n    _this.onTextureRemovedObservable = new Observable();\n    /**\r\n    * An event triggered when render targets are about to be rendered\r\n    * Can happen multiple times per frame.\r\n    */\n\n    _this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\r\n    * An event triggered when render targets were rendered.\r\n    * Can happen multiple times per frame.\r\n    */\n\n    _this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\r\n    * An event triggered before calculating deterministic simulation step\r\n    */\n\n    _this.onBeforeStepObservable = new Observable();\n    /**\r\n    * An event triggered after calculating deterministic simulation step\r\n    */\n\n    _this.onAfterStepObservable = new Observable();\n    /**\r\n     * An event triggered when the activeCamera property is updated\r\n     */\n\n    _this.onActiveCameraChanged = new Observable();\n    /**\r\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\n\n    _this.onBeforeRenderingGroupObservable = new Observable();\n    /**\r\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\n\n    _this.onAfterRenderingGroupObservable = new Observable();\n    /**\r\n     * This Observable will when a mesh has been imported into the scene.\r\n     */\n\n    _this.onMeshImportedObservable = new Observable();\n    /**\r\n     * This Observable will when an animation file has been imported into the scene.\r\n     */\n\n    _this.onAnimationFileImportedObservable = new Observable(); // Animations\n\n    /** @hidden */\n\n    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    /**\r\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\r\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\r\n     */\n\n    _this.onPrePointerObservable = new Observable();\n    /**\r\n     * Observable event triggered each time an input event is received from the rendering canvas\r\n     */\n\n    _this.onPointerObservable = new Observable(); // Keyboard\n\n    /**\r\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\r\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\r\n     */\n\n    _this.onPreKeyboardObservable = new Observable();\n    /**\r\n     * Observable event triggered each time an keyboard event is received from the hosting window\r\n     */\n\n    _this.onKeyboardObservable = new Observable(); // Coordinates system\n\n    _this._useRightHandedSystem = false; // Deterministic lockstep\n\n    _this._timeAccumulator = 0;\n    _this._currentStepId = 0;\n    _this._currentInternalStep = 0; // Fog\n\n    _this._fogEnabled = true;\n    _this._fogMode = Scene.FOGMODE_NONE;\n    /**\r\n    * Gets or sets the fog color to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is Color3(0.2, 0.2, 0.3))\r\n    */\n\n    _this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\r\n    * Gets or sets the fog density to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0.1)\r\n    */\n\n    _this.fogDensity = 0.1;\n    /**\r\n    * Gets or sets the fog start distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0)\r\n    */\n\n    _this.fogStart = 0;\n    /**\r\n    * Gets or sets the fog end distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 1000)\r\n    */\n\n    _this.fogEnd = 1000.0;\n    /**\r\n    * Flag indicating that the frame buffer binding is handled by another component\r\n    */\n\n    _this.prePass = false; // Lights\n\n    _this._shadowsEnabled = true;\n    _this._lightsEnabled = true;\n    /** All of the active cameras added to this scene. */\n\n    _this.activeCameras = new Array(); // Textures\n\n    _this._texturesEnabled = true; // Physics\n\n    /**\r\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\r\n     */\n\n    _this.physicsEnabled = true; // Particles\n\n    /**\r\n    * Gets or sets a boolean indicating if particles are enabled on this scene\r\n    */\n\n    _this.particlesEnabled = true; // Sprites\n\n    /**\r\n    * Gets or sets a boolean indicating if sprites are enabled on this scene\r\n    */\n\n    _this.spritesEnabled = true; // Skeletons\n\n    _this._skeletonsEnabled = true; // Lens flares\n\n    /**\r\n    * Gets or sets a boolean indicating if lens flares are enabled on this scene\r\n    */\n\n    _this.lensFlaresEnabled = true; // Collisions\n\n    /**\r\n    * Gets or sets a boolean indicating if collisions are enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n    */\n\n    _this.collisionsEnabled = true;\n    /**\r\n     * Defines the gravity applied to this scene (used only for collisions)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.gravity = new Vector3(0, -9.807, 0); // Postprocesses\n\n    /**\r\n    * Gets or sets a boolean indicating if postprocesses are enabled on this scene\r\n    */\n\n    _this.postProcessesEnabled = true; // Customs render targets\n\n    /**\r\n    * Gets or sets a boolean indicating if render targets are enabled on this scene\r\n    */\n\n    _this.renderTargetsEnabled = true;\n    /**\r\n    * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\r\n    * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\r\n    */\n\n    _this.dumpNextRenderTargets = false;\n    /**\r\n     * The list of user defined render targets added to the scene\r\n     */\n\n    _this.customRenderTargets = new Array();\n    /**\r\n     * Gets the list of meshes imported to the scene through SceneLoader\r\n     */\n\n    _this.importedMeshesFiles = new Array(); // Probes\n\n    /**\r\n    * Gets or sets a boolean indicating if probes are enabled on this scene\r\n    */\n\n    _this.probesEnabled = true;\n    _this._meshesForIntersections = new SmartArrayNoDuplicate(256); // Procedural textures\n\n    /**\r\n    * Gets or sets a boolean indicating if procedural textures are enabled on this scene\r\n    */\n\n    _this.proceduralTexturesEnabled = true; // Performance counters\n\n    _this._totalVertices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeIndices = new PerfCounter();\n    /** @hidden */\n\n    _this._activeParticles = new PerfCounter();\n    /** @hidden */\n\n    _this._activeBones = new PerfCounter();\n    /** @hidden */\n\n    _this._animationTime = 0;\n    /**\r\n     * Gets or sets a general scale for animation speed\r\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\r\n     */\n\n    _this.animationTimeScale = 1;\n    _this._renderId = 0;\n    _this._frameId = 0;\n    _this._executeWhenReadyTimeoutId = -1;\n    _this._intermediateRendering = false;\n    _this._viewUpdateFlag = -1;\n    _this._projectionUpdateFlag = -1;\n    /** @hidden */\n\n    _this._toBeDisposed = new Array(256);\n    _this._activeRequests = new Array();\n    /** @hidden */\n\n    _this._pendingData = new Array();\n    _this._isDisposed = false;\n    /**\r\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\r\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\r\n     */\n\n    _this.dispatchAllSubMeshesOfActiveMeshes = false;\n    _this._activeMeshes = new SmartArray(256);\n    _this._processedMaterials = new SmartArray(256);\n    _this._renderTargets = new SmartArrayNoDuplicate(256);\n    /** @hidden */\n\n    _this._activeParticleSystems = new SmartArray(256);\n    _this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @hidden */\n\n    _this._activeAnimatables = new Array();\n    _this._transformMatrix = Matrix.Zero();\n    /**\r\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\r\n     * This is useful if there are more lights that the maximum simulteanous authorized\r\n     */\n\n    _this.requireLightSorting = false;\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\n\n    _this._components = [];\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\n\n    _this._serializableComponents = [];\n    /**\r\n     * List of components to register on the next registration step.\r\n     */\n\n    _this._transientComponents = [];\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before camera updates.\r\n     */\n\n    _this._beforeCameraUpdateStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before clear the canvas.\r\n     */\n\n    _this._beforeClearStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions when collecting render targets for the frame.\r\n     */\n\n    _this._gatherRenderTargetsStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening for one camera in the frame.\r\n     */\n\n    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per mesh ready checks.\r\n     */\n\n    _this._isReadyForMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before evaluate active mesh checks.\r\n     */\n\n    _this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the evaluate sub mesh checks.\r\n     */\n\n    _this._evaluateSubMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the active mesh stage.\r\n     */\n\n    _this._preActiveMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per camera render target step.\r\n     */\n\n    _this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before the active camera is drawing.\r\n     */\n\n    _this._beforeCameraDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a render target is drawing.\r\n     */\n\n    _this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a rendering group is drawing.\r\n     */\n\n    _this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a mesh is drawing.\r\n     */\n\n    _this._beforeRenderingMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a mesh has been drawn.\r\n     */\n\n    _this._afterRenderingMeshStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a rendering group has been drawn.\r\n     */\n\n    _this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after the active camera has been drawn.\r\n     */\n\n    _this._afterCameraDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a render target has been drawn.\r\n     */\n\n    _this._afterRenderTargetDrawStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after rendering all cameras and computing intersections.\r\n     */\n\n    _this._afterRenderStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer move event happens.\r\n     */\n\n    _this._pointerMoveStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer down event happens.\r\n     */\n\n    _this._pointerDownStage = Stage.Create();\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer up event happens.\r\n     */\n\n    _this._pointerUpStage = Stage.Create();\n    /**\r\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\r\n     */\n\n    _this.geometriesByUniqueId = null;\n    _this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @hidden */\n\n    _this._activeMeshesFrozen = false;\n    _this._skipEvaluateActiveMeshesCompletely = false;\n    /** @hidden */\n\n    _this._allowPostProcessClearColor = true;\n    /**\r\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\r\n     */\n\n    _this.getDeterministicFrameTime = function () {\n      return _this._engine.getTimeStep();\n    };\n\n    _this._blockMaterialDirtyMechanism = false;\n\n    var fullOptions = __assign({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n\n    _this._engine = engine || EngineStore.LastCreatedEngine;\n\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = _this;\n\n      _this._engine.scenes.push(_this);\n    }\n\n    _this._uid = null;\n    _this._renderingManager = new RenderingManager(_this);\n\n    if (PostProcessManager) {\n      _this.postProcessManager = new PostProcessManager(_this);\n    }\n\n    if (DomManagement.IsWindowObjectExist()) {\n      _this.attachControl();\n    } // Uniform Buffer\n\n\n    _this._createUbo(); // Default Image processing definition\n\n\n    if (ImageProcessingConfiguration) {\n      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n\n    _this.setDefaultCandidateProviders();\n\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      _this.geometriesByUniqueId = {};\n    }\n\n    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n\n    if (!options || !options.virtual) {\n      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);\n    }\n\n    return _this;\n  }\n  /**\r\n   * Factory used to create the default material.\r\n   * @param name The name of the material to create\r\n   * @param scene The scene to create the material for\r\n   * @returns The default material\r\n   */\n\n\n  Scene.DefaultMaterialFactory = function (scene) {\n    throw _DevTools.WarnImport(\"StandardMaterial\");\n  };\n  /**\r\n   * Factory used to create the a collision coordinator.\r\n   * @returns The collision coordinator\r\n   */\n\n\n  Scene.CollisionCoordinatorFactory = function () {\n    throw _DevTools.WarnImport(\"DefaultCollisionCoordinator\");\n  };\n\n  Object.defineProperty(Scene.prototype, \"environmentTexture\", {\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\n    get: function () {\n      return this._environmentTexture;\n    },\n\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\n    set: function (value) {\n      if (this._environmentTexture === value) {\n        return;\n      }\n\n      this._environmentTexture = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"environmentIntensity\", {\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\n    get: function () {\n      return this._environmentIntensity;\n    },\n\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\n    set: function (value) {\n      if (this._environmentIntensity === value) {\n        return;\n      }\n\n      this._environmentIntensity = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Default image processing configuration used either in the rendering\r\n     * Forward main pass or through the imageProcessingPostProcess if present.\r\n     * As in the majority of the scene they are the same (exception for multi camera),\r\n     * this is easier to reference from here than from all the materials and post process.\r\n     *\r\n     * No setter as we it is a shared configuration, you can set the values instead.\r\n     */\n    get: function () {\n      return this._imageProcessingConfiguration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forceWireframe\", {\n    get: function () {\n      return this._forceWireframe;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\r\n     */\n    set: function (value) {\n      if (this._forceWireframe === value) {\n        return;\n      }\n\n      this._forceWireframe = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skipFrustumClipping\", {\n    get: function () {\n      return this._skipFrustumClipping;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\r\n     */\n    set: function (value) {\n      if (this._skipFrustumClipping === value) {\n        return;\n      }\n\n      this._skipFrustumClipping = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"forcePointsCloud\", {\n    get: function () {\n      return this._forcePointsCloud;\n    },\n\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\r\n     */\n    set: function (value) {\n      if (this._forcePointsCloud === value) {\n        return;\n      }\n\n      this._forcePointsCloud = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function () {\n      return this._animationPropertiesOverride;\n    },\n    set: function (value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"onDispose\", {\n    /** Sets a function to be executed when this scene is disposed. */\n    set: function (callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeRender\", {\n    /** Sets a function to be executed before rendering this scene */\n    set: function (callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      if (callback) {\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterRender\", {\n    /** Sets a function to be executed after rendering this scene */\n    set: function (callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      if (callback) {\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"beforeCameraRender\", {\n    /** Sets a function to be executed before rendering a camera*/\n    set: function (callback) {\n      if (this._onBeforeCameraRenderObserver) {\n        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n      }\n\n      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"afterCameraRender\", {\n    /** Sets a function to be executed after rendering a camera*/\n    set: function (callback) {\n      if (this._onAfterCameraRenderObserver) {\n        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n      }\n\n      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"unTranslatedPointer\", {\n    /**\r\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\r\n     */\n    get: function () {\n      return this._inputManager.unTranslatedPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DragMovementThreshold\", {\n    /**\r\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\r\n     */\n    get: function () {\n      return InputManager.DragMovementThreshold;\n    },\n    set: function (value) {\n      InputManager.DragMovementThreshold = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"LongPressDelay\", {\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\r\n     */\n    get: function () {\n      return InputManager.LongPressDelay;\n    },\n    set: function (value) {\n      InputManager.LongPressDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"DoubleClickDelay\", {\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\r\n     */\n    get: function () {\n      return InputManager.DoubleClickDelay;\n    },\n    set: function (value) {\n      InputManager.DoubleClickDelay = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene, \"ExclusiveDoubleClickMode\", {\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    get: function () {\n      return InputManager.ExclusiveDoubleClickMode;\n    },\n    set: function (value) {\n      InputManager.ExclusiveDoubleClickMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"useRightHandedSystem\", {\n    get: function () {\n      return this._useRightHandedSystem;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\r\n    */\n    set: function (value) {\n      if (this._useRightHandedSystem === value) {\n        return;\n      }\n\n      this._useRightHandedSystem = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the step Id used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @param newStepId defines the step Id\r\n   */\n\n  Scene.prototype.setStepId = function (newStepId) {\n    this._currentStepId = newStepId;\n  };\n  /**\r\n   * Gets the step Id used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the step Id\r\n   */\n\n\n  Scene.prototype.getStepId = function () {\n    return this._currentStepId;\n  };\n  /**\r\n   * Gets the internal step used by deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the internal step\r\n   */\n\n\n  Scene.prototype.getInternalStep = function () {\n    return this._currentInternalStep;\n  };\n\n  Object.defineProperty(Scene.prototype, \"fogEnabled\", {\n    get: function () {\n      return this._fogEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if fog is enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is true)\r\n    */\n    set: function (value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"fogMode\", {\n    get: function () {\n      return this._fogMode;\n    },\n\n    /**\r\n    * Gets or sets the fog mode to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * | mode | value |\r\n    * | --- | --- |\r\n    * | FOGMODE_NONE | 0 |\r\n    * | FOGMODE_EXP | 1 |\r\n    * | FOGMODE_EXP2 | 2 |\r\n    * | FOGMODE_LINEAR | 3 |\r\n    */\n    set: function (value) {\n      if (this._fogMode === value) {\n        return;\n      }\n\n      this._fogMode = value;\n      this.markAllMaterialsAsDirty(16);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"shadowsEnabled\", {\n    get: function () {\n      return this._shadowsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if shadows are enabled on this scene\r\n    */\n    set: function (value) {\n      if (this._shadowsEnabled === value) {\n        return;\n      }\n\n      this._shadowsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"lightsEnabled\", {\n    get: function () {\n      return this._lightsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if lights are enabled on this scene\r\n    */\n    set: function (value) {\n      if (this._lightsEnabled === value) {\n        return;\n      }\n\n      this._lightsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"activeCamera\", {\n    /** Gets or sets the current active camera */\n    get: function () {\n      return this._activeCamera;\n    },\n    set: function (value) {\n      if (value === this._activeCamera) {\n        return;\n      }\n\n      this._activeCamera = value;\n      this.onActiveCameraChanged.notifyObservers(this);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"defaultMaterial\", {\n    /** The default material used on meshes when no material is affected */\n    get: function () {\n      if (!this._defaultMaterial) {\n        this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n      }\n\n      return this._defaultMaterial;\n    },\n\n    /** The default material used on meshes when no material is affected */\n    set: function (value) {\n      this._defaultMaterial = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"texturesEnabled\", {\n    get: function () {\n      return this._texturesEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if textures are enabled on this scene\r\n    */\n    set: function (value) {\n      if (this._texturesEnabled === value) {\n        return;\n      }\n\n      this._texturesEnabled = value;\n      this.markAllMaterialsAsDirty(1);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"skeletonsEnabled\", {\n    get: function () {\n      return this._skeletonsEnabled;\n    },\n\n    /**\r\n    * Gets or sets a boolean indicating if skeletons are enabled on this scene\r\n    */\n    set: function (value) {\n      if (this._skeletonsEnabled === value) {\n        return;\n      }\n\n      this._skeletonsEnabled = value;\n      this.markAllMaterialsAsDirty(8);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"collisionCoordinator\", {\n    /** @hidden */\n    get: function () {\n      if (!this._collisionCoordinator) {\n        this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n\n        this._collisionCoordinator.init(this);\n      }\n\n      return this._collisionCoordinator;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"frustumPlanes\", {\n    /**\r\n     * Gets the list of frustum planes (built from the active camera)\r\n     */\n    get: function () {\n      return this._frustumPlanes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Registers the transient components if needed.\r\n   */\n\n  Scene.prototype._registerTransientComponents = function () {\n    // Register components that have been associated lately to the scene.\n    if (this._transientComponents.length > 0) {\n      for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {\n        var component = _a[_i];\n        component.register();\n      }\n\n      this._transientComponents = [];\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Add a component to the scene.\r\n   * Note that the ccomponent could be registered on th next frame if this is called after\r\n   * the register component stage.\r\n   * @param component Defines the component to add to the scene\r\n   */\n\n\n  Scene.prototype._addComponent = function (component) {\n    this._components.push(component);\n\n    this._transientComponents.push(component);\n\n    var serializableComponent = component;\n\n    if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n      this._serializableComponents.push(serializableComponent);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Gets a component from the scene.\r\n   * @param name defines the name of the component to retrieve\r\n   * @returns the component or null if not present\r\n   */\n\n\n  Scene.prototype._getComponent = function (name) {\n    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {\n      var component = _a[_i];\n\n      if (component.name === name) {\n        return component;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"Scene\" string\r\n   */\n\n\n  Scene.prototype.getClassName = function () {\n    return \"Scene\";\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  Scene.prototype._getDefaultMeshCandidates = function () {\n    this._defaultMeshCandidates.data = this.meshes;\n    this._defaultMeshCandidates.length = this.meshes.length;\n    return this._defaultMeshCandidates;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  Scene.prototype._getDefaultSubMeshCandidates = function (mesh) {\n    this._defaultSubMeshCandidates.data = mesh.subMeshes;\n    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n    return this._defaultSubMeshCandidates;\n  };\n  /**\r\n   * Sets the default candidate providers for the scene.\r\n   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\r\n   * and getCollidingSubMeshCandidates to their default function\r\n   */\n\n\n  Scene.prototype.setDefaultCandidateProviders = function () {\n    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n  };\n\n  Object.defineProperty(Scene.prototype, \"meshUnderPointer\", {\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\n    get: function () {\n      return this._inputManager.meshUnderPointer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerX\", {\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\n    get: function () {\n      return this._inputManager.pointerX;\n    },\n    set: function (value) {\n      this._inputManager.pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Scene.prototype, \"pointerY\", {\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\n    get: function () {\n      return this._inputManager.pointerY;\n    },\n    set: function (value) {\n      this._inputManager.pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the cached material (ie. the latest rendered one)\r\n   * @returns the cached material\r\n   */\n\n  Scene.prototype.getCachedMaterial = function () {\n    return this._cachedMaterial;\n  };\n  /**\r\n   * Gets the cached effect (ie. the latest rendered one)\r\n   * @returns the cached effect\r\n   */\n\n\n  Scene.prototype.getCachedEffect = function () {\n    return this._cachedEffect;\n  };\n  /**\r\n   * Gets the cached visibility state (ie. the latest rendered one)\r\n   * @returns the cached visibility state\r\n   */\n\n\n  Scene.prototype.getCachedVisibility = function () {\n    return this._cachedVisibility;\n  };\n  /**\r\n   * Gets a boolean indicating if the current material / effect / visibility must be bind again\r\n   * @param material defines the current material\r\n   * @param effect defines the current effect\r\n   * @param visibility defines the current visibility state\r\n   * @returns true if one parameter is not cached\r\n   */\n\n\n  Scene.prototype.isCachedMaterialInvalid = function (material, effect, visibility) {\n    if (visibility === void 0) {\n      visibility = 1;\n    }\n\n    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n  };\n  /**\r\n   * Gets the engine associated with the scene\r\n   * @returns an Engine\r\n   */\n\n\n  Scene.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Gets the total number of vertices rendered per frame\r\n   * @returns the total number of vertices rendered per frame\r\n   */\n\n\n  Scene.prototype.getTotalVertices = function () {\n    return this._totalVertices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalVerticesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for total vertices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function () {\n      return this._totalVertices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\r\n   * @returns the total number of active indices rendered per frame\r\n   */\n\n  Scene.prototype.getActiveIndices = function () {\n    return this._activeIndices.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"totalActiveIndicesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active indices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function () {\n      return this._activeIndices;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active particles rendered per frame\r\n   * @returns the total number of active particles rendered per frame\r\n   */\n\n  Scene.prototype.getActiveParticles = function () {\n    return this._activeParticles.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeParticlesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active particles\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function () {\n      return this._activeParticles;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the total number of active bones rendered per frame\r\n   * @returns the total number of active bones rendered per frame\r\n   */\n\n  Scene.prototype.getActiveBones = function () {\n    return this._activeBones.current;\n  };\n\n  Object.defineProperty(Scene.prototype, \"activeBonesPerfCounter\", {\n    /**\r\n     * Gets the performance counter for active bones\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\n    get: function () {\n      return this._activeBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the array of active meshes\r\n   * @returns an array of AbstractMesh\r\n   */\n\n  Scene.prototype.getActiveMeshes = function () {\n    return this._activeMeshes;\n  };\n  /**\r\n   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getAnimationRatio = function () {\n    return this._animationRatio !== undefined ? this._animationRatio : 1;\n  };\n  /**\r\n   * Gets an unique Id for the current render phase\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getRenderId = function () {\n    return this._renderId;\n  };\n  /**\r\n   * Gets an unique Id for the current frame\r\n   * @returns a number\r\n   */\n\n\n  Scene.prototype.getFrameId = function () {\n    return this._frameId;\n  };\n  /** Call this function if you want to manually increment the render Id*/\n\n\n  Scene.prototype.incrementRenderId = function () {\n    this._renderId++;\n  };\n\n  Scene.prototype._createUbo = function () {\n    this._sceneUbo = new UniformBuffer(this._engine, undefined, true);\n\n    this._sceneUbo.addUniform(\"viewProjection\", 16);\n\n    this._sceneUbo.addUniform(\"view\", 16);\n  };\n  /**\r\n   * Use this method to simulate a pointer move on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\r\n   * Use this method to simulate a pointer down on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n\n    return this;\n  };\n  /**\r\n   * Use this method to simulate a pointer up on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n\n    return this;\n  };\n  /**\r\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n   * @returns true if the pointer was captured\r\n   */\n\n\n  Scene.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._inputManager.isPointerCaptured(pointerId);\n  };\n  /**\r\n  * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n  * @param attachUp defines if you want to attach events to pointerup\r\n  * @param attachDown defines if you want to attach events to pointerdown\r\n  * @param attachMove defines if you want to attach events to pointermove\r\n  */\n\n\n  Scene.prototype.attachControl = function (attachUp, attachDown, attachMove) {\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    this._inputManager.attachControl(attachUp, attachDown, attachMove);\n  };\n  /** Detaches all event handlers*/\n\n\n  Scene.prototype.detachControl = function () {\n    this._inputManager.detachControl();\n  };\n  /**\r\n   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\r\n   * Delay loaded resources are not taking in account\r\n   * @return true if all required resources are ready\r\n   */\n\n\n  Scene.prototype.isReady = function () {\n    if (this._isDisposed) {\n      return false;\n    }\n\n    var index;\n    var engine = this.getEngine(); // Effects\n\n    if (!engine.areAllEffectsReady()) {\n      return false;\n    } // Pending data\n\n\n    if (this._pendingData.length > 0) {\n      return false;\n    } // Meshes\n\n\n    for (index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (!mesh.isEnabled()) {\n        continue;\n      }\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n        continue;\n      }\n\n      if (!mesh.isReady(true)) {\n        return false;\n      }\n\n      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0; // Is Ready For Mesh\n\n      for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n\n        if (!step.action(mesh, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    } // Geometries\n\n\n    for (index = 0; index < this.geometries.length; index++) {\n      var geometry = this.geometries[index];\n\n      if (geometry.delayLoadState === 2) {\n        return false;\n      }\n    } // Post-processes\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var _b = 0, _c = this.activeCameras; _b < _c.length; _b++) {\n        var camera = _c[_b];\n\n        if (!camera.isReady(true)) {\n          return false;\n        }\n      }\n    } else if (this.activeCamera) {\n      if (!this.activeCamera.isReady(true)) {\n        return false;\n      }\n    } // Particles\n\n\n    for (var _d = 0, _e = this.particleSystems; _d < _e.length; _d++) {\n      var particleSystem = _e[_d];\n\n      if (!particleSystem.isReady()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /** Resets all cached information relative to material (including effect and visibility) */\n\n\n  Scene.prototype.resetCachedMaterial = function () {\n    this._cachedMaterial = null;\n    this._cachedEffect = null;\n    this._cachedVisibility = null;\n  };\n  /**\r\n   * Registers a function to be called before every frame render\r\n   * @param func defines the function to register\r\n   */\n\n\n  Scene.prototype.registerBeforeRender = function (func) {\n    this.onBeforeRenderObservable.add(func);\n  };\n  /**\r\n   * Unregisters a function called before every frame render\r\n   * @param func defines the function to unregister\r\n   */\n\n\n  Scene.prototype.unregisterBeforeRender = function (func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n  };\n  /**\r\n   * Registers a function to be called after every frame render\r\n   * @param func defines the function to register\r\n   */\n\n\n  Scene.prototype.registerAfterRender = function (func) {\n    this.onAfterRenderObservable.add(func);\n  };\n  /**\r\n   * Unregisters a function called after every frame render\r\n   * @param func defines the function to unregister\r\n   */\n\n\n  Scene.prototype.unregisterAfterRender = function (func) {\n    this.onAfterRenderObservable.removeCallback(func);\n  };\n\n  Scene.prototype._executeOnceBeforeRender = function (func) {\n    var _this = this;\n\n    var execFunc = function () {\n      func();\n      setTimeout(function () {\n        _this.unregisterBeforeRender(execFunc);\n      });\n    };\n\n    this.registerBeforeRender(execFunc);\n  };\n  /**\r\n   * The provided function will run before render once and will be disposed afterwards.\r\n   * A timeout delay can be provided so that the function will be executed in N ms.\r\n   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\r\n   * @param func The function to be executed.\r\n   * @param timeout optional delay in ms\r\n   */\n\n\n  Scene.prototype.executeOnceBeforeRender = function (func, timeout) {\n    var _this = this;\n\n    if (timeout !== undefined) {\n      setTimeout(function () {\n        _this._executeOnceBeforeRender(func);\n      }, timeout);\n    } else {\n      this._executeOnceBeforeRender(func);\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._addPendingData = function (data) {\n    this._pendingData.push(data);\n  };\n  /** @hidden */\n\n\n  Scene.prototype._removePendingData = function (data) {\n    var wasLoading = this.isLoading;\n\n    var index = this._pendingData.indexOf(data);\n\n    if (index !== -1) {\n      this._pendingData.splice(index, 1);\n    }\n\n    if (wasLoading && !this.isLoading) {\n      this.onDataLoadedObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Returns the number of items waiting to be loaded\r\n   * @returns the number of items waiting to be loaded\r\n   */\n\n\n  Scene.prototype.getWaitingItemsCount = function () {\n    return this._pendingData.length;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isLoading\", {\n    /**\r\n     * Returns a boolean indicating if the scene is still loading data\r\n     */\n    get: function () {\n      return this._pendingData.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Registers a function to be executed when the scene is ready\r\n   * @param {Function} func - the function to be executed\r\n   */\n\n  Scene.prototype.executeWhenReady = function (func) {\n    var _this = this;\n\n    this.onReadyObservable.add(func);\n\n    if (this._executeWhenReadyTimeoutId !== -1) {\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady();\n    }, 150);\n  };\n  /**\r\n   * Returns a promise that resolves when the scene is ready\r\n   * @returns A promise that resolves when the scene is ready\r\n   */\n\n\n  Scene.prototype.whenReadyAsync = function () {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.executeWhenReady(function () {\n        resolve();\n      });\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._checkIsReady = function () {\n    var _this = this;\n\n    this._registerTransientComponents();\n\n    if (this.isReady()) {\n      this.onReadyObservable.notifyObservers(this);\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = -1;\n      return;\n    }\n\n    if (this._isDisposed) {\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = -1;\n      return;\n    }\n\n    this._executeWhenReadyTimeoutId = setTimeout(function () {\n      _this._checkIsReady();\n    }, 150);\n  };\n\n  Object.defineProperty(Scene.prototype, \"animatables\", {\n    /**\r\n     * Gets all animatable attached to the scene\r\n     */\n    get: function () {\n      return this._activeAnimatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the last animation time frame.\r\n   * Useful to override when animations start running when loading a scene for the first time.\r\n   */\n\n  Scene.prototype.resetLastAnimationTimeFrame = function () {\n    this._animationTimeLast = PrecisionDate.Now;\n  }; // Matrix\n\n  /**\r\n   * Gets the current view matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  Scene.prototype.getViewMatrix = function () {\n    return this._viewMatrix;\n  };\n  /**\r\n   * Gets the current projection matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  Scene.prototype.getProjectionMatrix = function () {\n    return this._projectionMatrix;\n  };\n  /**\r\n   * Gets the current transform matrix\r\n   * @returns a Matrix made of View * Projection\r\n   */\n\n\n  Scene.prototype.getTransformMatrix = function () {\n    return this._transformMatrix;\n  };\n  /**\r\n   * Sets the current transform matrix\r\n   * @param viewL defines the View matrix to use\r\n   * @param projectionL defines the Projection matrix to use\r\n   * @param viewR defines the right View matrix to use (if provided)\r\n   * @param projectionR defines the right Projection matrix to use (if provided)\r\n   */\n\n\n  Scene.prototype.setTransformMatrix = function (viewL, projectionL, viewR, projectionR) {\n    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n      return;\n    }\n\n    this._viewUpdateFlag = viewL.updateFlag;\n    this._projectionUpdateFlag = projectionL.updateFlag;\n    this._viewMatrix = viewL;\n    this._projectionMatrix = projectionL;\n\n    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix); // Update frustum\n\n\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n\n    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n      this._updateMultiviewUbo(viewR, projectionR);\n    } else if (this._sceneUbo.useUbo) {\n      this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n\n      this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n      this._sceneUbo.update();\n    }\n  };\n  /**\r\n   * Gets the uniform buffer used to store scene data\r\n   * @returns a UniformBuffer\r\n   */\n\n\n  Scene.prototype.getSceneUniformBuffer = function () {\n    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n  };\n  /**\r\n   * Gets an unique (relatively to the current scene) Id\r\n   * @returns an unique number for the scene\r\n   */\n\n\n  Scene.prototype.getUniqueId = function () {\n    return UniqueIdGenerator.UniqueId;\n  };\n  /**\r\n   * Add a mesh to the list of scene's meshes\r\n   * @param newMesh defines the mesh to add\r\n   * @param recursive if all child meshes should also be added to the scene\r\n   */\n\n\n  Scene.prototype.addMesh = function (newMesh, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.meshes.push(newMesh);\n\n    newMesh._resyncLightSources();\n\n    if (!newMesh.parent) {\n      newMesh._addToSceneRootNodes();\n    }\n\n    this.onNewMeshAddedObservable.notifyObservers(newMesh);\n\n    if (recursive) {\n      newMesh.getChildMeshes().forEach(function (m) {\n        _this.addMesh(m);\n      });\n    }\n  };\n  /**\r\n   * Remove a mesh for the list of scene's meshes\r\n   * @param toRemove defines the mesh to remove\r\n   * @param recursive if all child meshes should also be removed from the scene\r\n   * @returns the index where the mesh was in the mesh list\r\n   */\n\n\n  Scene.prototype.removeMesh = function (toRemove, recursive) {\n    var _this = this;\n\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    var index = this.meshes.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.meshes[index] = this.meshes[this.meshes.length - 1];\n      this.meshes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onMeshRemovedObservable.notifyObservers(toRemove);\n\n    if (recursive) {\n      toRemove.getChildMeshes().forEach(function (m) {\n        _this.removeMesh(m);\n      });\n    }\n\n    return index;\n  };\n  /**\r\n   * Add a transform node to the list of scene's transform nodes\r\n   * @param newTransformNode defines the transform node to add\r\n   */\n\n\n  Scene.prototype.addTransformNode = function (newTransformNode) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n    this.transformNodes.push(newTransformNode);\n\n    if (!newTransformNode.parent) {\n      newTransformNode._addToSceneRootNodes();\n    }\n\n    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n  };\n  /**\r\n   * Remove a transform node for the list of scene's transform nodes\r\n   * @param toRemove defines the transform node to remove\r\n   * @returns the index where the transform node was in the transform node list\r\n   */\n\n\n  Scene.prototype.removeTransformNode = function (toRemove) {\n    var index = toRemove._indexInSceneTransformNodesArray;\n\n    if (index !== -1) {\n      if (index !== this.transformNodes.length - 1) {\n        var lastNode = this.transformNodes[this.transformNodes.length - 1];\n        this.transformNodes[index] = lastNode;\n        lastNode._indexInSceneTransformNodesArray = index;\n      }\n\n      toRemove._indexInSceneTransformNodesArray = -1;\n      this.transformNodes.pop();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a skeleton for the list of scene's skeletons\r\n   * @param toRemove defines the skeleton to remove\r\n   * @returns the index where the skeleton was in the skeleton list\r\n   */\n\n\n  Scene.prototype.removeSkeleton = function (toRemove) {\n    var index = this.skeletons.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.skeletons.splice(index, 1);\n      this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a morph target for the list of scene's morph targets\r\n   * @param toRemove defines the morph target to remove\r\n   * @returns the index where the morph target was in the morph target list\r\n   */\n\n\n  Scene.prototype.removeMorphTargetManager = function (toRemove) {\n    var index = this.morphTargetManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.morphTargetManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a light for the list of scene's lights\r\n   * @param toRemove defines the light to remove\r\n   * @returns the index where the light was in the light list\r\n   */\n\n\n  Scene.prototype.removeLight = function (toRemove) {\n    var index = this.lights.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from meshes\n      for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n        var mesh = _a[_i];\n\n        mesh._removeLightSource(toRemove, false);\n      } // Remove from the scene if mesh found\n\n\n      this.lights.splice(index, 1);\n      this.sortLightsByPriority();\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n\n    this.onLightRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a camera for the list of scene's cameras\r\n   * @param toRemove defines the camera to remove\r\n   * @returns the index where the camera was in the camera list\r\n   */\n\n\n  Scene.prototype.removeCamera = function (toRemove) {\n    var index = this.cameras.indexOf(toRemove);\n\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.cameras.splice(index, 1);\n\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    } // Remove from activeCameras\n\n\n    if (this.activeCameras) {\n      var index2 = this.activeCameras.indexOf(toRemove);\n\n      if (index2 !== -1) {\n        // Remove from the scene if mesh found\n        this.activeCameras.splice(index2, 1);\n      }\n    } // Reset the activeCamera\n\n\n    if (this.activeCamera === toRemove) {\n      if (this.cameras.length > 0) {\n        this.activeCamera = this.cameras[0];\n      } else {\n        this.activeCamera = null;\n      }\n    }\n\n    this.onCameraRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Remove a particle system for the list of scene's particle systems\r\n   * @param toRemove defines the particle system to remove\r\n   * @returns the index where the particle system was in the particle system list\r\n   */\n\n\n  Scene.prototype.removeParticleSystem = function (toRemove) {\n    var index = this.particleSystems.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.particleSystems.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Remove a animation for the list of scene's animations\r\n   * @param toRemove defines the animation to remove\r\n   * @returns the index where the animation was in the animation list\r\n   */\n\n\n  Scene.prototype.removeAnimation = function (toRemove) {\n    var index = this.animations.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Will stop the animation of the given target\r\n   * @param target - the target\r\n   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n   */\n\n\n  Scene.prototype.stopAnimation = function (target, animationName, targetMask) {// Do nothing as code will be provided by animation component\n  };\n  /**\r\n   * Removes the given animation group from this scene.\r\n   * @param toRemove The animation group to remove\r\n   * @returns The index of the removed animation group\r\n   */\n\n\n  Scene.prototype.removeAnimationGroup = function (toRemove) {\n    var index = this.animationGroups.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.animationGroups.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Removes the given multi-material from this scene.\r\n   * @param toRemove The multi-material to remove\r\n   * @returns The index of the removed multi-material\r\n   */\n\n\n  Scene.prototype.removeMultiMaterial = function (toRemove) {\n    var index = this.multiMaterials.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.multiMaterials.splice(index, 1);\n    }\n\n    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Removes the given material from this scene.\r\n   * @param toRemove The material to remove\r\n   * @returns The index of the removed material\r\n   */\n\n\n  Scene.prototype.removeMaterial = function (toRemove) {\n    var index = toRemove._indexInSceneMaterialArray;\n\n    if (index !== -1 && index < this.materials.length) {\n      if (index !== this.materials.length - 1) {\n        var lastMaterial = this.materials[this.materials.length - 1];\n        this.materials[index] = lastMaterial;\n        lastMaterial._indexInSceneMaterialArray = index;\n      }\n\n      toRemove._indexInSceneMaterialArray = -1;\n      this.materials.pop();\n    }\n\n    this.onMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Removes the given action manager from this scene.\r\n   * @param toRemove The action manager to remove\r\n   * @returns The index of the removed action manager\r\n   */\n\n\n  Scene.prototype.removeActionManager = function (toRemove) {\n    var index = this.actionManagers.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.actionManagers.splice(index, 1);\n    }\n\n    return index;\n  };\n  /**\r\n   * Removes the given texture from this scene.\r\n   * @param toRemove The texture to remove\r\n   * @returns The index of the removed texture\r\n   */\n\n\n  Scene.prototype.removeTexture = function (toRemove) {\n    var index = this.textures.indexOf(toRemove);\n\n    if (index !== -1) {\n      this.textures.splice(index, 1);\n    }\n\n    this.onTextureRemovedObservable.notifyObservers(toRemove);\n    return index;\n  };\n  /**\r\n   * Adds the given light to this scene\r\n   * @param newLight The light to add\r\n   */\n\n\n  Scene.prototype.addLight = function (newLight) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.lights.push(newLight);\n    this.sortLightsByPriority();\n\n    if (!newLight.parent) {\n      newLight._addToSceneRootNodes();\n    } // Add light to all meshes (To support if the light is removed and then re-added)\n\n\n    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.lightSources.indexOf(newLight) === -1) {\n        mesh.lightSources.push(newLight);\n\n        mesh._resyncLightSources();\n      }\n    }\n\n    this.onNewLightAddedObservable.notifyObservers(newLight);\n  };\n  /**\r\n   * Sorts the list list based on light priorities\r\n   */\n\n\n  Scene.prototype.sortLightsByPriority = function () {\n    if (this.requireLightSorting) {\n      this.lights.sort(Light.CompareLightsPriority);\n    }\n  };\n  /**\r\n   * Adds the given camera to this scene\r\n   * @param newCamera The camera to add\r\n   */\n\n\n  Scene.prototype.addCamera = function (newCamera) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.cameras.push(newCamera);\n    this.onNewCameraAddedObservable.notifyObservers(newCamera);\n\n    if (!newCamera.parent) {\n      newCamera._addToSceneRootNodes();\n    }\n  };\n  /**\r\n   * Adds the given skeleton to this scene\r\n   * @param newSkeleton The skeleton to add\r\n   */\n\n\n  Scene.prototype.addSkeleton = function (newSkeleton) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.skeletons.push(newSkeleton);\n    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n  };\n  /**\r\n   * Adds the given particle system to this scene\r\n   * @param newParticleSystem The particle system to add\r\n   */\n\n\n  Scene.prototype.addParticleSystem = function (newParticleSystem) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.particleSystems.push(newParticleSystem);\n  };\n  /**\r\n   * Adds the given animation to this scene\r\n   * @param newAnimation The animation to add\r\n   */\n\n\n  Scene.prototype.addAnimation = function (newAnimation) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animations.push(newAnimation);\n  };\n  /**\r\n   * Adds the given animation group to this scene.\r\n   * @param newAnimationGroup The animation group to add\r\n   */\n\n\n  Scene.prototype.addAnimationGroup = function (newAnimationGroup) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.animationGroups.push(newAnimationGroup);\n  };\n  /**\r\n   * Adds the given multi-material to this scene\r\n   * @param newMultiMaterial The multi-material to add\r\n   */\n\n\n  Scene.prototype.addMultiMaterial = function (newMultiMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.multiMaterials.push(newMultiMaterial);\n    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n  };\n  /**\r\n   * Adds the given material to this scene\r\n   * @param newMaterial The material to add\r\n   */\n\n\n  Scene.prototype.addMaterial = function (newMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    newMaterial._indexInSceneMaterialArray = this.materials.length;\n    this.materials.push(newMaterial);\n    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n  };\n  /**\r\n   * Adds the given morph target to this scene\r\n   * @param newMorphTargetManager The morph target to add\r\n   */\n\n\n  Scene.prototype.addMorphTargetManager = function (newMorphTargetManager) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.morphTargetManagers.push(newMorphTargetManager);\n  };\n  /**\r\n   * Adds the given geometry to this scene\r\n   * @param newGeometry The geometry to add\r\n   */\n\n\n  Scene.prototype.addGeometry = function (newGeometry) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    if (this.geometriesByUniqueId) {\n      this.geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n    }\n\n    this.geometries.push(newGeometry);\n  };\n  /**\r\n   * Adds the given action manager to this scene\r\n   * @param newActionManager The action manager to add\r\n   */\n\n\n  Scene.prototype.addActionManager = function (newActionManager) {\n    this.actionManagers.push(newActionManager);\n  };\n  /**\r\n   * Adds the given texture to this scene.\r\n   * @param newTexture The texture to add\r\n   */\n\n\n  Scene.prototype.addTexture = function (newTexture) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n\n    this.textures.push(newTexture);\n    this.onNewTextureAddedObservable.notifyObservers(newTexture);\n  };\n  /**\r\n   * Switch active camera\r\n   * @param newCamera defines the new active camera\r\n   * @param attachControl defines if attachControl must be called for the new active camera (default: true)\r\n   */\n\n\n  Scene.prototype.switchActiveCamera = function (newCamera, attachControl) {\n    if (attachControl === void 0) {\n      attachControl = true;\n    }\n\n    var canvas = this._engine.getInputElement();\n\n    if (!canvas) {\n      return;\n    }\n\n    if (this.activeCamera) {\n      this.activeCamera.detachControl();\n    }\n\n    this.activeCamera = newCamera;\n\n    if (attachControl) {\n      newCamera.attachControl();\n    }\n  };\n  /**\r\n   * sets the active camera of the scene using its ID\r\n   * @param id defines the camera's ID\r\n   * @return the new active camera or null if none found.\r\n   */\n\n\n  Scene.prototype.setActiveCameraByID = function (id) {\n    var camera = this.getCameraByID(id);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\r\n   * sets the active camera of the scene using its name\r\n   * @param name defines the camera's name\r\n   * @returns the new active camera or null if none found.\r\n   */\n\n\n  Scene.prototype.setActiveCameraByName = function (name) {\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n\n    return null;\n  };\n  /**\r\n   * get an animation group using its name\r\n   * @param name defines the material's name\r\n   * @return the animation group or null if none found.\r\n   */\n\n\n  Scene.prototype.getAnimationGroupByName = function (name) {\n    for (var index = 0; index < this.animationGroups.length; index++) {\n      if (this.animationGroups[index].name === name) {\n        return this.animationGroups[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get a material using its unique id\r\n   * @param uniqueId defines the material's unique id\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].uniqueId === uniqueId) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * get a material using its id\r\n   * @param id defines the material's ID\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByID = function (id) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added material using a given id\r\n   * @param id defines the material's ID\r\n   * @return the last material with the given id or null if none found.\r\n   */\n\n\n  Scene.prototype.getLastMaterialByID = function (id) {\n    for (var index = this.materials.length - 1; index >= 0; index--) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a material using its name\r\n   * @param name defines the material's name\r\n   * @return the material or null if none found.\r\n   */\n\n\n  Scene.prototype.getMaterialByName = function (name) {\n    for (var index = 0; index < this.materials.length; index++) {\n      if (this.materials[index].name === name) {\n        return this.materials[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get a texture using its unique id\r\n   * @param uniqueId defines the texture's unique id\r\n   * @return the texture or null if none found.\r\n   */\n\n\n  Scene.prototype.getTextureByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].uniqueId === uniqueId) {\n        return this.textures[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its id\r\n   * @param id defines the id to look for\r\n   * @returns the camera or null if not found\r\n   */\n\n\n  Scene.prototype.getCameraByID = function (id) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its unique id\r\n   * @param uniqueId defines the unique id to look for\r\n   * @returns the camera or null if not found\r\n   */\n\n\n  Scene.prototype.getCameraByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].uniqueId === uniqueId) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a camera using its name\r\n   * @param name defines the camera's name\r\n   * @return the camera or null if none found.\r\n   */\n\n\n  Scene.prototype.getCameraByName = function (name) {\n    for (var index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].name === name) {\n        return this.cameras[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a bone using its id\r\n   * @param id defines the bone's id\r\n   * @return the bone or null if not found\r\n   */\n\n\n  Scene.prototype.getBoneByID = function (id) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].id === id) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n  * Gets a bone using its id\r\n  * @param name defines the bone's name\r\n  * @return the bone or null if not found\r\n  */\n\n\n  Scene.prototype.getBoneByName = function (name) {\n    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      var skeleton = this.skeletons[skeletonIndex];\n\n      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].name === name) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its name\r\n   * @param name defines the the light's name\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByName = function (name) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].name === name) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its id\r\n   * @param id defines the light's id\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByID = function (id) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a light node using its scene-generated unique ID\r\n   * @param uniqueId defines the light's unique id\r\n   * @return the light or null if none found.\r\n   */\n\n\n  Scene.prototype.getLightByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].uniqueId === uniqueId) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a particle system by id\r\n   * @param id defines the particle system id\r\n   * @return the corresponding system or null if none found\r\n   */\n\n\n  Scene.prototype.getParticleSystemByID = function (id) {\n    for (var index = 0; index < this.particleSystems.length; index++) {\n      if (this.particleSystems[index].id === id) {\n        return this.particleSystems[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a geometry using its ID\r\n   * @param id defines the geometry's id\r\n   * @return the geometry or null if none found.\r\n   */\n\n\n  Scene.prototype.getGeometryByID = function (id) {\n    for (var index = 0; index < this.geometries.length; index++) {\n      if (this.geometries[index].id === id) {\n        return this.geometries[index];\n      }\n    }\n\n    return null;\n  };\n\n  Scene.prototype._getGeometryByUniqueID = function (uniqueId) {\n    if (this.geometriesByUniqueId) {\n      var index_1 = this.geometriesByUniqueId[uniqueId];\n\n      if (index_1 !== undefined) {\n        return this.geometries[index_1];\n      }\n    } else {\n      for (var index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].uniqueId === uniqueId) {\n          return this.geometries[index];\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Add a new geometry to this scene\r\n   * @param geometry defines the geometry to be added to the scene.\r\n   * @param force defines if the geometry must be pushed even if a geometry with this id already exists\r\n   * @return a boolean defining if the geometry was added or not\r\n   */\n\n\n  Scene.prototype.pushGeometry = function (geometry, force) {\n    if (!force && this._getGeometryByUniqueID(geometry.uniqueId)) {\n      return false;\n    }\n\n    this.addGeometry(geometry);\n    this.onNewGeometryAddedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\r\n   * Removes an existing geometry\r\n   * @param geometry defines the geometry to be removed from the scene\r\n   * @return a boolean defining if the geometry was removed or not\r\n   */\n\n\n  Scene.prototype.removeGeometry = function (geometry) {\n    var index;\n\n    if (this.geometriesByUniqueId) {\n      index = this.geometriesByUniqueId[geometry.uniqueId];\n\n      if (index === undefined) {\n        return false;\n      }\n    } else {\n      index = this.geometries.indexOf(geometry);\n\n      if (index < 0) {\n        return false;\n      }\n    }\n\n    if (index !== this.geometries.length - 1) {\n      var lastGeometry = this.geometries[this.geometries.length - 1];\n\n      if (lastGeometry) {\n        this.geometries[index] = lastGeometry;\n\n        if (this.geometriesByUniqueId) {\n          this.geometriesByUniqueId[lastGeometry.uniqueId] = index;\n          this.geometriesByUniqueId[geometry.uniqueId] = undefined;\n        }\n      }\n    }\n\n    this.geometries.pop();\n    this.onGeometryRemovedObservable.notifyObservers(geometry);\n    return true;\n  };\n  /**\r\n   * Gets the list of geometries attached to the scene\r\n   * @returns an array of Geometry\r\n   */\n\n\n  Scene.prototype.getGeometries = function () {\n    return this.geometries;\n  };\n  /**\r\n   * Gets the first added mesh found of a given ID\r\n   * @param id defines the id to search for\r\n   * @return the mesh found or null if not found at all\r\n   */\n\n\n  Scene.prototype.getMeshByID = function (id) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a list of meshes using their id\r\n   * @param id defines the id to search for\r\n   * @returns a list of meshes\r\n   */\n\n\n  Scene.prototype.getMeshesByID = function (id) {\n    return this.meshes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\r\n   * Gets the first added transform node found of a given ID\r\n   * @param id defines the id to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByID = function (id) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a transform node with its auto-generated unique id\r\n   * @param uniqueId efines the unique id to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].uniqueId === uniqueId) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a list of transform nodes using their id\r\n   * @param id defines the id to search for\r\n   * @returns a list of transform nodes\r\n   */\n\n\n  Scene.prototype.getTransformNodesByID = function (id) {\n    return this.transformNodes.filter(function (m) {\n      return m.id === id;\n    });\n  };\n  /**\r\n   * Gets a mesh with its auto-generated unique id\r\n   * @param uniqueId defines the unique id to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMeshByUniqueID = function (uniqueId) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].uniqueId === uniqueId) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added mesh using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getLastMeshByID = function (id) {\n    for (var index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a the last added node (Mesh, Camera, Light) using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found node or null if not found at all\r\n   */\n\n\n  Scene.prototype.getLastEntryByID = function (id) {\n    var index;\n\n    for (index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n\n    for (index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n\n    for (index = this.cameras.length - 1; index >= 0; index--) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n\n    for (index = this.lights.length - 1; index >= 0; index--) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a node (Mesh, Camera, Light) using a given id\r\n   * @param id defines the id to search for\r\n   * @return the found node or null if not found at all\r\n   */\n\n\n  Scene.prototype.getNodeByID = function (id) {\n    var mesh = this.getMeshByID(id);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeByID(id);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightByID(id);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraByID(id);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneByID(id);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a node (Mesh, Camera, Light) using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getNodeByName = function (name) {\n    var mesh = this.getMeshByName(name);\n\n    if (mesh) {\n      return mesh;\n    }\n\n    var transformNode = this.getTransformNodeByName(name);\n\n    if (transformNode) {\n      return transformNode;\n    }\n\n    var light = this.getLightByName(name);\n\n    if (light) {\n      return light;\n    }\n\n    var camera = this.getCameraByName(name);\n\n    if (camera) {\n      return camera;\n    }\n\n    var bone = this.getBoneByName(name);\n\n    if (bone) {\n      return bone;\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a mesh using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found mesh or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMeshByName = function (name) {\n    for (var index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].name === name) {\n        return this.meshes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a transform node using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found transform node or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getTransformNodeByName = function (name) {\n    for (var index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].name === name) {\n        return this.transformNodes[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given id (if many are found, this function will pick the last one)\r\n   * @param id defines the id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getLastSkeletonByID = function (id) {\n    for (var index = this.skeletons.length - 1; index >= 0; index--) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given auto generated unique id\r\n   * @param  uniqueId defines the unique id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonByUniqueId = function (uniqueId) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].uniqueId === uniqueId) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given id (if many are found, this function will pick the first one)\r\n   * @param id defines the id to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonById = function (id) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a skeleton using a given name\r\n   * @param name defines the name to search for\r\n   * @return the found skeleton or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getSkeletonByName = function (name) {\n    for (var index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].name === name) {\n        return this.skeletons[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\r\n   * @param id defines the id to search for\r\n   * @return the found morph target manager or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetManagerById = function (id) {\n    for (var index = 0; index < this.morphTargetManagers.length; index++) {\n      if (this.morphTargetManagers[index].uniqueId === id) {\n        return this.morphTargetManagers[index];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target using a given id (if many are found, this function will pick the first one)\r\n   * @param id defines the id to search for\r\n   * @return the found morph target or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetById = function (id) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.id === id) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a morph target using a given name (if many are found, this function will pick the first one)\r\n   * @param name defines the name to search for\r\n   * @return the found morph target or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getMorphTargetByName = function (name) {\n    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n      for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n        var target = morphTargetManager.getTarget(index);\n\n        if (target.name === name) {\n          return target;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a post process using a given name (if many are found, this function will pick the first one)\r\n   * @param name defines the name to search for\r\n   * @return the found post process or null if not found at all.\r\n   */\n\n\n  Scene.prototype.getPostProcessByName = function (name) {\n    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n      var postProcess = this.postProcesses[postProcessIndex];\n\n      if (postProcess.name === name) {\n        return postProcess;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets a boolean indicating if the given mesh is active\r\n   * @param mesh defines the mesh to look for\r\n   * @returns true if the mesh is in the active list\r\n   */\n\n\n  Scene.prototype.isActiveMesh = function (mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  };\n\n  Object.defineProperty(Scene.prototype, \"uid\", {\n    /**\r\n     * Return a unique id as a string which can serve as an identifier for the scene\r\n     */\n    get: function () {\n      if (!this._uid) {\n        this._uid = Tools.RandomId();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add an externaly attached data from its key.\r\n   * This method call will fail and return false, if such key already exists.\r\n   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\r\n   * @param key the unique key that identifies the data\r\n   * @param data the data object to associate to the key for this Engine instance\r\n   * @return true if no such key were already present and the data was added successfully, false otherwise\r\n   */\n\n  Scene.prototype.addExternalData = function (key, data) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.add(key, data);\n  };\n  /**\r\n   * Get an externaly attached data from its key\r\n   * @param key the unique key that identifies the data\r\n   * @return the associated data, if present (can be null), or undefined if not present\r\n   */\n\n\n  Scene.prototype.getExternalData = function (key) {\n    if (!this._externalData) {\n      return null;\n    }\n\n    return this._externalData.get(key);\n  };\n  /**\r\n   * Get an externaly attached data from its key, create it using a factory if it's not already present\r\n   * @param key the unique key that identifies the data\r\n   * @param factory the factory that will be called to create the instance if and only if it doesn't exists\r\n   * @return the associated data, can be null if the factory returned null.\r\n   */\n\n\n  Scene.prototype.getOrAddExternalDataWithFactory = function (key, factory) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n\n    return this._externalData.getOrAddWithFactory(key, factory);\n  };\n  /**\r\n   * Remove an externaly attached data from the Engine instance\r\n   * @param key the unique key that identifies the data\r\n   * @return true if the data was successfully removed, false if it doesn't exist\r\n   */\n\n\n  Scene.prototype.removeExternalData = function (key) {\n    return this._externalData.remove(key);\n  };\n\n  Scene.prototype._evaluateSubMesh = function (subMesh, mesh, initialMesh) {\n    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\n      for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(mesh, subMesh);\n      }\n\n      var material = subMesh.getMaterial();\n\n      if (material !== null && material !== undefined) {\n        // Render targets\n        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n          if (this._processedMaterials.indexOf(material) === -1) {\n            this._processedMaterials.push(material);\n\n            this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n          }\n        } // Dispatch\n\n\n        this._renderingManager.dispatch(subMesh, mesh, material);\n      }\n    }\n  };\n  /**\r\n   * Clear the processed materials smart array preventing retention point in material dispose.\r\n   */\n\n\n  Scene.prototype.freeProcessedMaterials = function () {\n    this._processedMaterials.dispose();\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockfreeActiveMeshesAndRenderingGroups\", {\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\r\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\r\n     * when disposing several meshes in a row or a hierarchy of meshes.\r\n     * When used, it is the responsability of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\r\n     */\n    get: function () {\n      return this._preventFreeActiveMeshesAndRenderingGroups;\n    },\n    set: function (value) {\n      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n        return;\n      }\n\n      if (value) {\n        this.freeActiveMeshes();\n        this.freeRenderingGroups();\n      }\n\n      this._preventFreeActiveMeshesAndRenderingGroups = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Clear the active meshes smart array preventing retention point in mesh dispose.\r\n   */\n\n  Scene.prototype.freeActiveMeshes = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    this._activeMeshes.dispose();\n\n    if (this.activeCamera && this.activeCamera._activeMeshes) {\n      this.activeCamera._activeMeshes.dispose();\n    }\n\n    if (this.activeCameras) {\n      for (var i = 0; i < this.activeCameras.length; i++) {\n        var activeCamera = this.activeCameras[i];\n\n        if (activeCamera && activeCamera._activeMeshes) {\n          activeCamera._activeMeshes.dispose();\n        }\n      }\n    }\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention points during dispose.\r\n   */\n\n\n  Scene.prototype.freeRenderingGroups = function () {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n\n    if (this.textures) {\n      for (var i = 0; i < this.textures.length; i++) {\n        var texture = this.textures[i];\n\n        if (texture && texture.renderList) {\n          texture.freeRenderingGroups();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._isInIntermediateRendering = function () {\n    return this._intermediateRendering;\n  };\n  /**\r\n   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\r\n   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\r\n   * @param onSuccess optional success callback\r\n   * @param onError optional error callback\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.freezeActiveMeshes = function (skipEvaluateActiveMeshes, onSuccess, onError) {\n    var _this = this;\n\n    if (skipEvaluateActiveMeshes === void 0) {\n      skipEvaluateActiveMeshes = false;\n    }\n\n    this.executeWhenReady(function () {\n      if (!_this.activeCamera) {\n        onError && onError('No active camera found');\n        return;\n      }\n\n      if (!_this._frustumPlanes) {\n        _this.setTransformMatrix(_this.activeCamera.getViewMatrix(), _this.activeCamera.getProjectionMatrix());\n      }\n\n      _this._evaluateActiveMeshes();\n\n      _this._activeMeshesFrozen = true;\n      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n\n      for (var index = 0; index < _this._activeMeshes.length; index++) {\n        _this._activeMeshes.data[index]._freeze();\n      }\n\n      onSuccess && onSuccess();\n    });\n    return this;\n  };\n  /**\r\n   * Use this function to restart evaluating active meshes on every frame\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.unfreezeActiveMeshes = function () {\n    for (var index = 0; index < this.meshes.length; index++) {\n      var mesh = this.meshes[index];\n\n      if (mesh._internalAbstractMeshDataInfo) {\n        mesh._internalAbstractMeshDataInfo._isActive = false;\n      }\n    }\n\n    for (var index = 0; index < this._activeMeshes.length; index++) {\n      this._activeMeshes.data[index]._unFreeze();\n    }\n\n    this._activeMeshesFrozen = false;\n    return this;\n  };\n\n  Scene.prototype._evaluateActiveMeshes = function () {\n    if (this._activeMeshesFrozen && this._activeMeshes.length) {\n      if (!this._skipEvaluateActiveMeshesCompletely) {\n        var len_1 = this._activeMeshes.length;\n\n        for (var i = 0; i < len_1; i++) {\n          var mesh = this._activeMeshes.data[i];\n          mesh.computeWorldMatrix();\n        }\n      }\n\n      if (this._activeParticleSystems) {\n        var psLength = this._activeParticleSystems.length;\n\n        for (var i = 0; i < psLength; i++) {\n          this._activeParticleSystems.data[i].animate();\n        }\n      }\n\n      return;\n    }\n\n    if (!this.activeCamera) {\n      return;\n    }\n\n    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n\n    this.activeCamera._activeMeshes.reset();\n\n    this._activeMeshes.reset();\n\n    this._renderingManager.reset();\n\n    this._processedMaterials.reset();\n\n    this._activeParticleSystems.reset();\n\n    this._activeSkeletons.reset();\n\n    this._softwareSkinnedMeshes.reset();\n\n    for (var _i = 0, _a = this._beforeEvaluateActiveMeshStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action();\n    } // Determine mesh candidates\n\n\n    var meshes = this.getActiveMeshCandidates(); // Check each mesh\n\n    var len = meshes.length;\n\n    for (var i = 0; i < len; i++) {\n      var mesh = meshes.data[i];\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n\n      if (mesh.isBlocked) {\n        continue;\n      }\n\n      this._totalVertices.addCount(mesh.getTotalVertices(), false);\n\n      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {\n        continue;\n      }\n\n      mesh.computeWorldMatrix(); // Intersections\n\n      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n        this._meshesForIntersections.pushNoDuplicate(mesh);\n      } // Switch to current LOD\n\n\n      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n\n      if (meshToRender === undefined || meshToRender === null) {\n        continue;\n      } // Compute world matrix if LOD is billboard\n\n\n      if (meshToRender !== mesh && meshToRender.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n        meshToRender.computeWorldMatrix();\n      }\n\n      mesh._preActivate();\n\n      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n        this._activeMeshes.push(mesh);\n\n        this.activeCamera._activeMeshes.push(mesh);\n\n        if (meshToRender !== mesh) {\n          meshToRender._activate(this._renderId, false);\n        }\n\n        for (var _b = 0, _c = this._preActiveMeshStage; _b < _c.length; _b++) {\n          var step = _c[_b];\n          step.action(mesh);\n        }\n\n        if (mesh._activate(this._renderId, false)) {\n          if (!mesh.isAnInstance) {\n            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n          } else {\n            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n              meshToRender = mesh;\n            }\n          }\n\n          meshToRender._internalAbstractMeshDataInfo._isActive = true;\n\n          this._activeMesh(mesh, meshToRender);\n        }\n\n        mesh._postActivate();\n      }\n    }\n\n    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this); // Particle systems\n\n    if (this.particlesEnabled) {\n      this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n\n      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n        var particleSystem = this.particleSystems[particleIndex];\n\n        if (!particleSystem.isStarted() || !particleSystem.emitter) {\n          continue;\n        }\n\n        var emitter = particleSystem.emitter;\n\n        if (!emitter.position || emitter.isEnabled()) {\n          this._activeParticleSystems.push(particleSystem);\n\n          particleSystem.animate();\n\n          this._renderingManager.dispatchParticles(particleSystem);\n        }\n      }\n\n      this.onAfterParticlesRenderingObservable.notifyObservers(this);\n    }\n  };\n\n  Scene.prototype._activeMesh = function (sourceMesh, mesh) {\n    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n        mesh.skeleton.prepare();\n      }\n\n      if (!mesh.computeBonesUsingShaders) {\n        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n      }\n    }\n\n    if (mesh !== undefined && mesh !== null && mesh.subMeshes !== undefined && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {\n      var subMeshes = this.getActiveSubMeshCandidates(mesh);\n      var len = subMeshes.length;\n\n      for (var i = 0; i < len; i++) {\n        var subMesh = subMeshes.data[i];\n\n        this._evaluateSubMesh(subMesh, mesh, sourceMesh);\n      }\n    }\n  };\n  /**\r\n   * Update the transform matrix to update from the current active camera\r\n   * @param force defines a boolean used to force the update even if cache is up to date\r\n   */\n\n\n  Scene.prototype.updateTransformMatrix = function (force) {\n    if (!this.activeCamera) {\n      return;\n    }\n\n    this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n  };\n\n  Scene.prototype._bindFrameBuffer = function () {\n    if (this.activeCamera && this.activeCamera._multiviewTexture) {\n      this.activeCamera._multiviewTexture._bindFrameBuffer();\n    } else if (this.activeCamera && this.activeCamera.outputRenderTarget) {\n      var useMultiview = this.getEngine().getCaps().multiview && this.activeCamera.outputRenderTarget && this.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (useMultiview) {\n        this.activeCamera.outputRenderTarget._bindFrameBuffer();\n      } else {\n        var internalTexture = this.activeCamera.outputRenderTarget.getInternalTexture();\n\n        if (internalTexture) {\n          this.getEngine().bindFramebuffer(internalTexture);\n        } else {\n          Logger.Error(\"Camera contains invalid customDefaultRenderTarget\");\n        }\n      }\n    } else {\n      this.getEngine().restoreDefaultFramebuffer(); // Restore back buffer if needed\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._renderForCamera = function (camera, rigParent) {\n    if (camera && camera._skipRendering) {\n      return;\n    }\n\n    var engine = this._engine; // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n    this._activeCamera = camera;\n\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    } // Viewport\n\n\n    engine.setViewport(this.activeCamera.viewport); // Camera\n\n    this.resetCachedMaterial();\n    this._renderId++;\n    var useMultiview = this.getEngine().getCaps().multiview && camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1;\n\n    if (useMultiview) {\n      this.setTransformMatrix(camera._rigCameras[0].getViewMatrix(), camera._rigCameras[0].getProjectionMatrix(), camera._rigCameras[1].getViewMatrix(), camera._rigCameras[1].getProjectionMatrix());\n    } else {\n      this.updateTransformMatrix();\n    }\n\n    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera); // Meshes\n\n    this._evaluateActiveMeshes(); // Software skinning\n\n\n    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n      mesh.applySkeleton(mesh.skeleton);\n    } // Render targets\n\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n\n    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n    }\n\n    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n    } // Collects render targets from external components.\n\n\n    for (var _i = 0, _a = this._gatherActiveCameraRenderTargetsStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action(this._renderTargets);\n    }\n\n    var needRebind = false;\n\n    if (this.renderTargetsEnabled) {\n      this._intermediateRendering = true;\n\n      if (this._renderTargets.length > 0) {\n        Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n\n        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n          var renderTarget = this._renderTargets.data[renderIndex];\n\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n            needRebind = true;\n          }\n        }\n\n        Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        this._renderId++;\n      }\n\n      for (var _b = 0, _c = this._cameraDrawRenderTargetStage; _b < _c.length; _b++) {\n        var step = _c[_b];\n        needRebind = step.action(this.activeCamera) || needRebind;\n      }\n\n      this._intermediateRendering = false; // Need to bind if sub-camera has an outputRenderTarget eg. for webXR\n\n      if (this.activeCamera && this.activeCamera.outputRenderTarget) {\n        needRebind = true;\n      }\n    } // Restore framebuffer after rendering to targets\n\n\n    if (needRebind && !this.prePass) {\n      this._bindFrameBuffer();\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this); // Prepare Frame\n\n    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n      this.postProcessManager._prepareFrame();\n    } // Before Camera Draw\n\n\n    for (var _d = 0, _e = this._beforeCameraDrawStage; _d < _e.length; _d++) {\n      var step = _e[_d];\n      step.action(this.activeCamera);\n    } // Render\n\n\n    this.onBeforeDrawPhaseObservable.notifyObservers(this);\n\n    this._renderingManager.render(null, null, true, true);\n\n    this.onAfterDrawPhaseObservable.notifyObservers(this); // After Camera Draw\n\n    for (var _f = 0, _g = this._afterCameraDrawStage; _f < _g.length; _f++) {\n      var step = _g[_f];\n      step.action(this.activeCamera);\n    } // Finalize frame\n\n\n    if (this.postProcessManager && !camera._multiviewTexture) {\n      // if the camera has an output render target, render the post process to the render target\n      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.getInternalTexture() : undefined;\n\n      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n    } // Reset some special arrays\n\n\n    this._renderTargets.reset();\n\n    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n  };\n\n  Scene.prototype._processSubCameras = function (camera) {\n    if (camera.cameraRigMode === Camera.RIG_MODE_NONE || camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1 && this.getEngine().getCaps().multiview) {\n      this._renderForCamera(camera);\n\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n      return;\n    }\n\n    if (camera._useMultiviewToSingleView) {\n      this._renderMultiviewToSingleView(camera);\n    } else {\n      // rig cameras\n      for (var index = 0; index < camera._rigCameras.length; index++) {\n        this._renderForCamera(camera._rigCameras[index], camera);\n      }\n    } // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n\n    this._activeCamera = camera;\n    this.setTransformMatrix(this._activeCamera.getViewMatrix(), this._activeCamera.getProjectionMatrix());\n    this.onAfterRenderCameraObservable.notifyObservers(camera);\n  };\n\n  Scene.prototype._checkIntersections = function () {\n    for (var index = 0; index < this._meshesForIntersections.length; index++) {\n      var sourceMesh = this._meshesForIntersections.data[index];\n\n      if (!sourceMesh.actionManager) {\n        continue;\n      }\n\n      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n        var action = sourceMesh.actionManager.actions[actionIndex];\n\n        if (action.trigger === 12 || action.trigger === 13) {\n          var parameters = action.getTriggerParameter();\n          var otherMesh = parameters instanceof AbstractMesh ? parameters : parameters.mesh;\n          var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n\n          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n\n          if (areIntersecting && currentIntersectionInProgress === -1) {\n            if (action.trigger === 12) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            } else if (action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            }\n          } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n            //They intersected, and now they don't.\n            //is this trigger an exit trigger? execute an event.\n            if (action.trigger === 13) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n            } //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n\n\n            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function (parameter) {\n              var parameterMesh = parameter instanceof AbstractMesh ? parameter : parameter.mesh;\n              return otherMesh === parameterMesh;\n            }) || action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n            }\n          }\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._advancePhysicsEngineStep = function (step) {// Do nothing. Code will be replaced if physics engine component is referenced\n  };\n  /** @hidden */\n\n\n  Scene.prototype._animate = function () {// Nothing to do as long as Animatable have not been imported.\n  };\n  /** Execute all animations (for a frame) */\n\n\n  Scene.prototype.animate = function () {\n    if (this._engine.isDeterministicLockStep()) {\n      var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n\n      var defaultFrameTime = this._engine.getTimeStep();\n\n      var defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n      var stepsTaken = 0;\n\n      var maxSubSteps = this._engine.getLockstepMaxSteps();\n\n      var internalSteps = Math.floor(deltaTime / defaultFrameTime);\n      internalSteps = Math.min(internalSteps, maxSubSteps);\n\n      while (deltaTime > 0 && stepsTaken < internalSteps) {\n        this.onBeforeStepObservable.notifyObservers(this); // Animations\n\n        this._animationRatio = defaultFrameTime * defaultFPS;\n\n        this._animate();\n\n        this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(defaultFrameTime);\n        }\n\n        this.onAfterStepObservable.notifyObservers(this);\n        this._currentStepId++;\n        stepsTaken++;\n        deltaTime -= defaultFrameTime;\n      }\n\n      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n    } else {\n      // Animations\n      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n      this._animationRatio = deltaTime * (60.0 / 1000.0);\n\n      this._animate();\n\n      this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n      if (this.physicsEnabled) {\n        this._advancePhysicsEngineStep(deltaTime);\n      }\n    }\n  };\n  /**\r\n   * Render the scene\r\n   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\r\n   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\r\n   */\n\n\n  Scene.prototype.render = function (updateCameras, ignoreAnimations) {\n    if (updateCameras === void 0) {\n      updateCameras = true;\n    }\n\n    if (ignoreAnimations === void 0) {\n      ignoreAnimations = false;\n    }\n\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === -1) {\n      this._checkIsReady();\n    }\n\n    this._frameId++; // Register components that have been associated lately to the scene.\n\n    this._registerTransientComponents();\n\n    this._activeParticles.fetchNewFrame();\n\n    this._totalVertices.fetchNewFrame();\n\n    this._activeIndices.fetchNewFrame();\n\n    this._activeBones.fetchNewFrame();\n\n    this._meshesForIntersections.reset();\n\n    this.resetCachedMaterial();\n    this.onBeforeAnimationsObservable.notifyObservers(this); // Actions\n\n    if (this.actionManager) {\n      this.actionManager.processTrigger(11);\n    } // Animations\n\n\n    if (!ignoreAnimations) {\n      this.animate();\n    } // Before camera update steps\n\n\n    for (var _i = 0, _a = this._beforeCameraUpdateStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action();\n    } // Update Cameras\n\n\n    if (updateCameras) {\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n          var camera = this.activeCameras[cameraIndex];\n          camera.update();\n\n          if (camera.cameraRigMode !== Camera.RIG_MODE_NONE) {\n            // rig cameras\n            for (var index = 0; index < camera._rigCameras.length; index++) {\n              camera._rigCameras[index].update();\n            }\n          }\n        }\n      } else if (this.activeCamera) {\n        this.activeCamera.update();\n\n        if (this.activeCamera.cameraRigMode !== Camera.RIG_MODE_NONE) {\n          // rig cameras\n          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {\n            this.activeCamera._rigCameras[index].update();\n          }\n        }\n      }\n    } // Before render\n\n\n    this.onBeforeRenderObservable.notifyObservers(this); // Customs render targets\n\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    var engine = this.getEngine();\n    var currentActiveCamera = this.activeCamera;\n\n    if (this.renderTargetsEnabled) {\n      Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = true;\n\n      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n        var renderTarget = this.customRenderTargets[customIndex];\n\n        if (renderTarget._shouldRender()) {\n          this._renderId++;\n          this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n\n          if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n          } // Viewport\n\n\n          engine.setViewport(this.activeCamera.viewport); // Camera\n\n          this.updateTransformMatrix();\n          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n        }\n      }\n\n      Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = false;\n      this._renderId++;\n    } // Restore back buffer\n\n\n    this.activeCamera = currentActiveCamera;\n\n    if (this._activeCamera && this._activeCamera.cameraRigMode !== Camera.RIG_MODE_CUSTOM && !this.prePass) {\n      this._bindFrameBuffer();\n    }\n\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n\n    for (var _b = 0, _c = this._beforeClearStage; _b < _c.length; _b++) {\n      var step = _c[_b];\n      step.action();\n    } // Clear\n\n\n    if ((this.autoClearDepthAndStencil || this.autoClear) && !this.prePass) {\n      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n    } // Collects render targets from external components.\n\n\n    for (var _d = 0, _e = this._gatherRenderTargetsStage; _d < _e.length; _d++) {\n      var step = _e[_d];\n      step.action(this._renderTargets);\n    } // Multi-cameras?\n\n\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n        if (cameraIndex > 0) {\n          this._engine.clear(null, false, true, true);\n        }\n\n        this._processSubCameras(this.activeCameras[cameraIndex]);\n      }\n    } else {\n      if (!this.activeCamera) {\n        throw new Error(\"No camera defined\");\n      }\n\n      this._processSubCameras(this.activeCamera);\n    } // Intersection checks\n\n\n    this._checkIntersections(); // Executes the after render stage actions.\n\n\n    for (var _f = 0, _g = this._afterRenderStage; _f < _g.length; _f++) {\n      var step = _g[_f];\n      step.action();\n    } // After render\n\n\n    if (this.afterRender) {\n      this.afterRender();\n    }\n\n    this.onAfterRenderObservable.notifyObservers(this); // Cleaning\n\n    if (this._toBeDisposed.length) {\n      for (var index = 0; index < this._toBeDisposed.length; index++) {\n        var data = this._toBeDisposed[index];\n\n        if (data) {\n          data.dispose();\n        }\n      }\n\n      this._toBeDisposed = [];\n    }\n\n    if (this.dumpNextRenderTargets) {\n      this.dumpNextRenderTargets = false;\n    }\n\n    this._activeBones.addCount(0, true);\n\n    this._activeIndices.addCount(0, true);\n\n    this._activeParticles.addCount(0, true);\n  };\n  /**\r\n   * Freeze all materials\r\n   * A frozen material will not be updatable but should be faster to render\r\n   */\n\n\n  Scene.prototype.freezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].freeze();\n    }\n  };\n  /**\r\n   * Unfreeze all materials\r\n   * A frozen material will not be updatable but should be faster to render\r\n   */\n\n\n  Scene.prototype.unfreezeMaterials = function () {\n    for (var i = 0; i < this.materials.length; i++) {\n      this.materials[i].unfreeze();\n    }\n  };\n  /**\r\n   * Releases all held ressources\r\n   */\n\n\n  Scene.prototype.dispose = function () {\n    this.beforeRender = null;\n    this.afterRender = null;\n\n    if (EngineStore._LastCreatedScene === this) {\n      EngineStore._LastCreatedScene = null;\n    }\n\n    this.skeletons = [];\n    this.morphTargetManagers = [];\n    this._transientComponents = [];\n\n    this._isReadyForMeshStage.clear();\n\n    this._beforeEvaluateActiveMeshStage.clear();\n\n    this._evaluateSubMeshStage.clear();\n\n    this._preActiveMeshStage.clear();\n\n    this._cameraDrawRenderTargetStage.clear();\n\n    this._beforeCameraDrawStage.clear();\n\n    this._beforeRenderTargetDrawStage.clear();\n\n    this._beforeRenderingGroupDrawStage.clear();\n\n    this._beforeRenderingMeshStage.clear();\n\n    this._afterRenderingMeshStage.clear();\n\n    this._afterRenderingGroupDrawStage.clear();\n\n    this._afterCameraDrawStage.clear();\n\n    this._afterRenderTargetDrawStage.clear();\n\n    this._afterRenderStage.clear();\n\n    this._beforeCameraUpdateStage.clear();\n\n    this._beforeClearStage.clear();\n\n    this._gatherRenderTargetsStage.clear();\n\n    this._gatherActiveCameraRenderTargetsStage.clear();\n\n    this._pointerMoveStage.clear();\n\n    this._pointerDownStage.clear();\n\n    this._pointerUpStage.clear();\n\n    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {\n      var component = _a[_i];\n      component.dispose();\n    }\n\n    this.importedMeshesFiles = new Array();\n\n    if (this.stopAllAnimations) {\n      this.stopAllAnimations();\n    }\n\n    this.resetCachedMaterial(); // Smart arrays\n\n    if (this.activeCamera) {\n      this.activeCamera._activeMeshes.dispose();\n\n      this.activeCamera = null;\n    }\n\n    this._activeMeshes.dispose();\n\n    this._renderingManager.dispose();\n\n    this._processedMaterials.dispose();\n\n    this._activeParticleSystems.dispose();\n\n    this._activeSkeletons.dispose();\n\n    this._softwareSkinnedMeshes.dispose();\n\n    this._renderTargets.dispose();\n\n    this._registeredForLateAnimationBindings.dispose();\n\n    this._meshesForIntersections.dispose();\n\n    this._toBeDisposed = []; // Abort active requests\n\n    for (var _b = 0, _c = this._activeRequests; _b < _c.length; _b++) {\n      var request = _c[_b];\n      request.abort();\n    } // Events\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderTargetsRenderObservable.clear();\n    this.onAfterRenderTargetsRenderObservable.clear();\n    this.onAfterStepObservable.clear();\n    this.onBeforeStepObservable.clear();\n    this.onBeforeActiveMeshesEvaluationObservable.clear();\n    this.onAfterActiveMeshesEvaluationObservable.clear();\n    this.onBeforeParticlesRenderingObservable.clear();\n    this.onAfterParticlesRenderingObservable.clear();\n    this.onBeforeDrawPhaseObservable.clear();\n    this.onAfterDrawPhaseObservable.clear();\n    this.onBeforeAnimationsObservable.clear();\n    this.onAfterAnimationsObservable.clear();\n    this.onDataLoadedObservable.clear();\n    this.onBeforeRenderingGroupObservable.clear();\n    this.onAfterRenderingGroupObservable.clear();\n    this.onMeshImportedObservable.clear();\n    this.onBeforeCameraRenderObservable.clear();\n    this.onAfterCameraRenderObservable.clear();\n    this.onReadyObservable.clear();\n    this.onNewCameraAddedObservable.clear();\n    this.onCameraRemovedObservable.clear();\n    this.onNewLightAddedObservable.clear();\n    this.onLightRemovedObservable.clear();\n    this.onNewGeometryAddedObservable.clear();\n    this.onGeometryRemovedObservable.clear();\n    this.onNewTransformNodeAddedObservable.clear();\n    this.onTransformNodeRemovedObservable.clear();\n    this.onNewMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onNewSkeletonAddedObservable.clear();\n    this.onSkeletonRemovedObservable.clear();\n    this.onNewMaterialAddedObservable.clear();\n    this.onNewMultiMaterialAddedObservable.clear();\n    this.onMaterialRemovedObservable.clear();\n    this.onMultiMaterialRemovedObservable.clear();\n    this.onNewTextureAddedObservable.clear();\n    this.onTextureRemovedObservable.clear();\n    this.onPrePointerObservable.clear();\n    this.onPointerObservable.clear();\n    this.onPreKeyboardObservable.clear();\n    this.onKeyboardObservable.clear();\n    this.onActiveCameraChanged.clear();\n    this.detachControl(); // Detach cameras\n\n    var canvas = this._engine.getInputElement();\n\n    if (canvas) {\n      var index;\n\n      for (index = 0; index < this.cameras.length; index++) {\n        this.cameras[index].detachControl();\n      }\n    } // Release animation groups\n\n\n    while (this.animationGroups.length) {\n      this.animationGroups[0].dispose();\n    } // Release lights\n\n\n    while (this.lights.length) {\n      this.lights[0].dispose();\n    } // Release meshes\n\n\n    while (this.meshes.length) {\n      this.meshes[0].dispose(true);\n    }\n\n    while (this.transformNodes.length) {\n      this.transformNodes[0].dispose(true);\n    } // Release cameras\n\n\n    while (this.cameras.length) {\n      this.cameras[0].dispose();\n    } // Release materials\n\n\n    if (this._defaultMaterial) {\n      this._defaultMaterial.dispose();\n    }\n\n    while (this.multiMaterials.length) {\n      this.multiMaterials[0].dispose();\n    }\n\n    while (this.materials.length) {\n      this.materials[0].dispose();\n    } // Release particles\n\n\n    while (this.particleSystems.length) {\n      this.particleSystems[0].dispose();\n    } // Release postProcesses\n\n\n    while (this.postProcesses.length) {\n      this.postProcesses[0].dispose();\n    } // Release textures\n\n\n    while (this.textures.length) {\n      this.textures[0].dispose();\n    } // Release UBO\n\n\n    this._sceneUbo.dispose();\n\n    if (this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n    } // Post-processes\n\n\n    this.postProcessManager.dispose(); // Remove from engine\n\n    index = this._engine.scenes.indexOf(this);\n\n    if (index > -1) {\n      this._engine.scenes.splice(index, 1);\n    }\n\n    this._engine.wipeCaches(true);\n\n    this._isDisposed = true;\n  };\n\n  Object.defineProperty(Scene.prototype, \"isDisposed\", {\n    /**\r\n     * Gets if the scene is already disposed\r\n     */\n    get: function () {\n      return this._isDisposed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Call this function to reduce memory footprint of the scene.\r\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n   */\n\n  Scene.prototype.clearCachedVertexData = function () {\n    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n      var mesh = this.meshes[meshIndex];\n      var geometry = mesh.geometry;\n\n      if (geometry) {\n        geometry._indices = [];\n\n        for (var vbName in geometry._vertexBuffers) {\n          if (!geometry._vertexBuffers.hasOwnProperty(vbName)) {\n            continue;\n          }\n\n          geometry._vertexBuffers[vbName]._buffer._data = null;\n        }\n      }\n    }\n  };\n  /**\r\n   * This function will remove the local cached buffer data from texture.\r\n   * It will save memory but will prevent the texture from being rebuilt\r\n   */\n\n\n  Scene.prototype.cleanCachedTextureBuffer = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var baseTexture = _a[_i];\n      var buffer = baseTexture._buffer;\n\n      if (buffer) {\n        baseTexture._buffer = null;\n      }\n    }\n  };\n  /**\r\n   * Get the world extend vectors with an optional filter\r\n   *\r\n   * @param filterPredicate the predicate - which meshes should be included when calculating the world size\r\n   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\r\n   */\n\n\n  Scene.prototype.getWorldExtends = function (filterPredicate) {\n    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    filterPredicate = filterPredicate || function () {\n      return true;\n    };\n\n    this.meshes.filter(filterPredicate).forEach(function (mesh) {\n      mesh.computeWorldMatrix(true);\n\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n        return;\n      }\n\n      var boundingInfo = mesh.getBoundingInfo();\n      var minBox = boundingInfo.boundingBox.minimumWorld;\n      var maxBox = boundingInfo.boundingBox.maximumWorld;\n      Vector3.CheckExtends(minBox, min, max);\n      Vector3.CheckExtends(maxBox, min, max);\n    });\n    return {\n      min: min,\n      max: max\n    };\n  }; // Picking\n\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n   * @param camera defines the camera to use for the picking\r\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n   * @returns a Ray\r\n   */\n\n\n  Scene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n   * @param result defines the ray where to store the picking ray\r\n   * @param camera defines the camera to use for the picking\r\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace) {\n    if (cameraViewSpace === void 0) {\n      cameraViewSpace = false;\n    }\n\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param camera defines the camera to use for the picking\r\n   * @returns a Ray\r\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Creates a ray that can be used to pick in the scene\r\n   * @param x defines the x coordinate of the origin (on-screen)\r\n   * @param y defines the y coordinate of the origin (on-screen)\r\n   * @param result defines the ray where to store the picking ray\r\n   * @param camera defines the camera to use for the picking\r\n   * @returns the current scene\r\n   */\n\n\n  Scene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /** Launch a ray to try to pick a mesh in the scene\r\n   * @param x position on screen\r\n   * @param y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns a PickingInfo\r\n   */\n\n\n  Scene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n   * @param x position on screen\r\n   * @param y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n   */\n\n\n  Scene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n    // Dummy info if picking as not been imported\n    var pi = new PickingInfo();\n    pi._pickingUnavailable = true;\n    return pi;\n  };\n  /** Use the given ray to pick a mesh in the scene\r\n   * @param ray The ray to use to pick meshes\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns a PickingInfo\r\n   */\n\n\n  Scene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Launch a ray to try to pick a mesh in the scene\r\n   * @param x X position on screen\r\n   * @param y Y position on screen\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns an array of PickingInfo\r\n   */\n\n\n  Scene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Launch a ray to try to pick a mesh in the scene\r\n   * @param ray Ray to use\r\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns an array of PickingInfo\r\n   */\n\n\n  Scene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n    throw _DevTools.WarnImport(\"Ray\");\n  };\n  /**\r\n   * Force the value of meshUnderPointer\r\n   * @param mesh defines the mesh to use\r\n   * @param pointerId optional pointer id when using more than one pointer\r\n   */\n\n\n  Scene.prototype.setPointerOverMesh = function (mesh, pointerId) {\n    this._inputManager.setPointerOverMesh(mesh, pointerId);\n  };\n  /**\r\n   * Gets the mesh under the pointer\r\n   * @returns a Mesh or null if no mesh is under the pointer\r\n   */\n\n\n  Scene.prototype.getPointerOverMesh = function () {\n    return this._inputManager.getPointerOverMesh();\n  }; // Misc.\n\n  /** @hidden */\n\n\n  Scene.prototype._rebuildGeometries = function () {\n    for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {\n      var geometry = _a[_i];\n\n      geometry._rebuild();\n    }\n\n    for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {\n      var mesh = _c[_b];\n\n      mesh._rebuild();\n    }\n\n    if (this.postProcessManager) {\n      this.postProcessManager._rebuild();\n    }\n\n    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {\n      var component = _e[_d];\n      component.rebuild();\n    }\n\n    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {\n      var system = _g[_f];\n      system.rebuild();\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._rebuildTextures = function () {\n    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n      var texture = _a[_i];\n\n      texture._rebuild();\n    }\n\n    this.markAllMaterialsAsDirty(1);\n  }; // Tags\n\n\n  Scene.prototype._getByTags = function (list, tagsQuery, forEach) {\n    if (tagsQuery === undefined) {\n      // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n      return list;\n    }\n\n    var listByTags = [];\n\n    forEach = forEach || function (item) {\n      return;\n    };\n\n    for (var i in list) {\n      var item = list[i];\n\n      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n        listByTags.push(item);\n        forEach(item);\n      }\n    }\n\n    return listByTags;\n  };\n  /**\r\n   * Get a list of meshes by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Mesh\r\n   */\n\n\n  Scene.prototype.getMeshesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.meshes, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of cameras by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Camera\r\n   */\n\n\n  Scene.prototype.getCamerasByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.cameras, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of lights by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Light\r\n   */\n\n\n  Scene.prototype.getLightsByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.lights, tagsQuery, forEach);\n  };\n  /**\r\n   * Get a list of materials by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of Material\r\n   */\n\n\n  Scene.prototype.getMaterialByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n  };\n  /**\r\n   * Get a list of transform nodes by tags\r\n   * @param tagsQuery defines the tags query to use\r\n   * @param forEach defines a predicate used to filter results\r\n   * @returns an array of TransformNode\r\n   */\n\n\n  Scene.prototype.getTransformNodesByTags = function (tagsQuery, forEach) {\n    return this._getByTags(this.transformNodes, tagsQuery, forEach);\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  Scene.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n   */\n\n\n  Scene.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n  };\n  /**\r\n   * Gets the current auto clear configuration for one rendering group of the rendering\r\n   * manager.\r\n   * @param index the rendering group index to get the information for\r\n   * @returns The auto clear setup for the requested rendering group\r\n   */\n\n\n  Scene.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._renderingManager.getAutoClearDepthStencilSetup(index);\n  };\n\n  Object.defineProperty(Scene.prototype, \"blockMaterialDirtyMechanism\", {\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    get: function () {\n      return this._blockMaterialDirtyMechanism;\n    },\n    set: function (value) {\n      if (this._blockMaterialDirtyMechanism === value) {\n        return;\n      }\n\n      this._blockMaterialDirtyMechanism = value;\n\n      if (!value) {\n        // Do a complete update\n        this.markAllMaterialsAsDirty(63);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Will flag all materials as dirty to trigger new shader compilation\r\n   * @param flag defines the flag used to specify which material part must be marked as dirty\r\n   * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty\r\n   */\n\n  Scene.prototype.markAllMaterialsAsDirty = function (flag, predicate) {\n    if (this._blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {\n      var material = _a[_i];\n\n      if (predicate && !predicate(material)) {\n        continue;\n      }\n\n      material.markAsDirty(flag);\n    }\n  };\n  /** @hidden */\n\n\n  Scene.prototype._loadFile = function (url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = FileTools.LoadFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._loadFileAsync = function (url, onProgress, useOfflineSupport, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._loadFile(url, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (request, exception) {\n        reject(exception);\n      });\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._requestFile = function (url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    var _this = this;\n\n    var request = FileTools.RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._requestFileAsync = function (url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._requestFile(url, function (data) {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, function (error) {\n        reject(error);\n      }, onOpened);\n    });\n  };\n  /** @hidden */\n\n\n  Scene.prototype._readFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var _this = this;\n\n    var request = FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n\n    this._activeRequests.push(request);\n\n    request.onCompleteObservable.add(function (request) {\n      _this._activeRequests.splice(_this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  };\n  /** @hidden */\n\n\n  Scene.prototype._readFileAsync = function (file, onProgress, useArrayBuffer) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._readFile(file, function (data) {\n        resolve(data);\n      }, onProgress, useArrayBuffer, function (error) {\n        reject(error);\n      });\n    });\n  };\n  /** The fog is deactivated */\n\n\n  Scene.FOGMODE_NONE = 0;\n  /** The fog density is following an exponential function */\n\n  Scene.FOGMODE_EXP = 1;\n  /** The fog density is following an exponential function faster than FOGMODE_EXP */\n\n  Scene.FOGMODE_EXP2 = 2;\n  /** The fog density is following a linear function. */\n\n  Scene.FOGMODE_LINEAR = 3;\n  /**\r\n   * Gets or sets the minimum deltatime when deterministic lock step is enabled\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   */\n\n  Scene.MinDeltaTime = 1.0;\n  /**\r\n   * Gets or sets the maximum deltatime when deterministic lock step is enabled\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   */\n\n  Scene.MaxDeltaTime = 1000.0;\n  return Scene;\n}(AbstractScene);\n\nexport { Scene };","map":{"version":3,"sources":["../../sourceES6/core/scene.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"./types\";\r\nimport { Tools } from \"./Misc/tools\";\r\nimport { IAnimatable } from './Animations/animatable.interface';\r\nimport { PrecisionDate } from \"./Misc/precisionDate\";\r\nimport { Observable, Observer } from \"./Misc/observable\";\r\nimport { SmartArrayNoDuplicate, SmartArray, ISmartArrayLike } from \"./Misc/smartArray\";\r\nimport { StringDictionary } from \"./Misc/stringDictionary\";\r\nimport { Tags } from \"./Misc/tags\";\r\nimport { Vector2, Vector3, Matrix } from \"./Maths/math.vector\";\r\nimport { Geometry } from \"./Meshes/geometry\";\r\nimport { TransformNode } from \"./Meshes/transformNode\";\r\nimport { SubMesh } from \"./Meshes/subMesh\";\r\nimport { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport { Mesh } from \"./Meshes/mesh\";\r\nimport { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport { Bone } from \"./Bones/bone\";\r\nimport { Skeleton } from \"./Bones/skeleton\";\r\nimport { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport { Camera } from \"./Cameras/camera\";\r\nimport { AbstractScene } from \"./abstractScene\";\r\nimport { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport { Texture } from \"./Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"./Materials/Textures/renderTargetTexture\";\r\nimport { Material } from \"./Materials/material\";\r\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration\";\r\nimport { Effect } from \"./Materials/effect\";\r\nimport { UniformBuffer } from \"./Materials/uniformBuffer\";\r\nimport { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport { Light } from \"./Lights/light\";\r\nimport { PickingInfo } from \"./Collisions/pickingInfo\";\r\nimport { ICollisionCoordinator } from \"./Collisions/collisionCoordinator\";\r\nimport { PointerEventTypes, PointerInfoPre, PointerInfo } from \"./Events/pointerEvents\";\r\nimport { KeyboardInfoPre, KeyboardInfo } from \"./Events/keyboardEvents\";\r\nimport { ActionEvent } from \"./Actions/actionEvent\";\r\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager\";\r\nimport { IOfflineProvider } from \"./Offline/IOfflineProvider\";\r\nimport { RenderingGroupInfo, RenderingManager, IRenderingManagerAutoClearSetup } from \"./Rendering/renderingManager\";\r\nimport { ISceneComponent, ISceneSerializableComponent, Stage, SimpleStageAction, RenderTargetsStageAction, RenderTargetStageAction, MeshStageAction, EvaluateSubMeshStageAction, PreActiveMeshStageAction, CameraStageAction, RenderingGroupStageAction, RenderingMeshStageAction, PointerMoveStageAction, PointerUpDownStageAction, CameraStageFrameBufferAction } from \"./sceneComponent\";\r\nimport { Engine } from \"./Engines/engine\";\r\nimport { Node } from \"./node\";\r\nimport { MorphTarget } from \"./Morph/morphTarget\";\r\n\r\nimport { DomManagement } from \"./Misc/domManagement\";\r\nimport { Logger } from \"./Misc/logger\";\r\nimport { EngineStore } from \"./Engines/engineStore\";\r\nimport { AbstractActionManager } from './Actions/abstractActionManager';\r\nimport { _DevTools } from './Misc/devTools';\r\nimport { WebRequest } from './Misc/webRequest';\r\nimport { InputManager } from './Inputs/scene.inputManager';\r\nimport { PerfCounter } from './Misc/perfCounter';\r\nimport { IFileRequest } from './Misc/fileRequest';\r\nimport { Color4, Color3 } from './Maths/math.color';\r\nimport { Plane } from './Maths/math.plane';\r\nimport { Frustum } from './Maths/math.frustum';\r\nimport { UniqueIdGenerator } from './Misc/uniqueIdGenerator';\r\nimport { FileTools, LoadFileError, RequestFileError, ReadFileError } from './Misc/fileTools';\r\nimport { IClipPlanesHolder } from './Misc/interfaces/iClipPlanesHolder';\r\n\r\ndeclare type Ray = import(\"./Culling/ray\").Ray;\r\ndeclare type TrianglePickingPredicate = import(\"./Culling/ray\").TrianglePickingPredicate;\r\ndeclare type Animation = import(\"./Animations/animation\").Animation;\r\ndeclare type Animatable = import(\"./Animations/animatable\").Animatable;\r\ndeclare type AnimationGroup = import(\"./Animations/animationGroup\").AnimationGroup;\r\ndeclare type AnimationPropertiesOverride = import(\"./Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\r\ndeclare type Collider = import(\"./Collisions/collider\").Collider;\r\ndeclare type PostProcess = import(\"./PostProcesses/postProcess\").PostProcess;\r\n\r\n/**\r\n * Define an interface for all classes that will hold resources\r\n */\r\nexport interface IDisposable {\r\n    /**\r\n     * Releases all held resources\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/** Interface defining initialization parameters for Scene class */\r\nexport interface SceneOptions {\r\n    /**\r\n     * Defines that scene should keep up-to-date a map of geometry to enable fast look-up by uniqueId\r\n     * It will improve performance when the number of geometries becomes important.\r\n     */\r\n    useGeometryUniqueIdsMap?: boolean;\r\n\r\n    /**\r\n     * Defines that each material of the scene should keep up-to-date a map of referencing meshes for fast diposing\r\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\r\n     */\r\n    useMaterialMeshMap?: boolean;\r\n\r\n    /**\r\n     * Defines that each mesh of the scene should keep up-to-date a map of referencing cloned meshes for fast diposing\r\n     * It will improve performance when the number of mesh becomes important, but might consume a bit more memory\r\n     */\r\n    useClonedMeshMap?: boolean;\r\n\r\n    /** Defines if the creation of the scene should impact the engine (Eg. UtilityLayer's scene) */\r\n    virtual?: boolean;\r\n}\r\n\r\n/**\r\n * Represents a scene to be rendered by the engine.\r\n * @see https://doc.babylonjs.com/features/scene\r\n */\r\nexport class Scene extends AbstractScene implements IAnimatable, IClipPlanesHolder {\r\n    /** The fog is deactivated */\r\n    public static readonly FOGMODE_NONE = 0;\r\n    /** The fog density is following an exponential function */\r\n    public static readonly FOGMODE_EXP = 1;\r\n    /** The fog density is following an exponential function faster than FOGMODE_EXP */\r\n    public static readonly FOGMODE_EXP2 = 2;\r\n    /** The fog density is following a linear function. */\r\n    public static readonly FOGMODE_LINEAR = 3;\r\n\r\n    /**\r\n     * Gets or sets the minimum deltatime when deterministic lock step is enabled\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public static MinDeltaTime = 1.0;\r\n    /**\r\n     * Gets or sets the maximum deltatime when deterministic lock step is enabled\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public static MaxDeltaTime = 1000.0;\r\n\r\n    /**\r\n     * Factory used to create the default material.\r\n     * @param name The name of the material to create\r\n     * @param scene The scene to create the material for\r\n     * @returns The default material\r\n     */\r\n    public static DefaultMaterialFactory(scene: Scene): Material {\r\n        throw _DevTools.WarnImport(\"StandardMaterial\");\r\n    }\r\n\r\n    /**\r\n     * Factory used to create the a collision coordinator.\r\n     * @returns The collision coordinator\r\n     */\r\n    public static CollisionCoordinatorFactory(): ICollisionCoordinator {\r\n        throw _DevTools.WarnImport(\"DefaultCollisionCoordinator\");\r\n    }\r\n\r\n    // Members\r\n\r\n    /** @hidden */\r\n    public _inputManager = new InputManager(this);\r\n\r\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\r\n    public cameraToUseForPointers: Nullable<Camera> = null;\r\n\r\n    /** @hidden */\r\n    public readonly _isScene = true;\r\n\r\n    /** @hidden */\r\n    public _blockEntityCollection = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\r\n     */\r\n    public autoClear = true;\r\n    /**\r\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\r\n     */\r\n    public autoClearDepthAndStencil = true;\r\n    /**\r\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\r\n     */\r\n    public clearColor: Color4 = new Color4(0.2, 0.2, 0.3, 1.0);\r\n    /**\r\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\r\n     */\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * This is use to store the default BRDF lookup for PBR materials in your scene.\r\n     * It should only be one of the following (if not the default embedded one):\r\n     * * For uncorrelated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = false) : https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     * * For correlated BRDF (pbr.brdf.useEnergyConservation = false and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedBRDF.dds\r\n     * * For correlated multi scattering BRDF (pbr.brdf.useEnergyConservation = true and pbr.brdf.useSmithVisibilityHeightCorrelated = true) : https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * The material properties need to be setup according to the type of texture in use.\r\n     */\r\n    public environmentBRDFTexture: BaseTexture;\r\n\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        if (this._environmentTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._environmentTexture = value;\r\n        this.markAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _environmentIntensity: number = 1;\r\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentIntensity(): number {\r\n        return this._environmentIntensity;\r\n    }\r\n    /**\r\n     * Intensity of the environment in all pbr material.\r\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to set here than in all the materials.\r\n     */\r\n    public set environmentIntensity(value: number) {\r\n        if (this._environmentIntensity === value) {\r\n            return;\r\n        }\r\n\r\n        this._environmentIntensity = value;\r\n        this.markAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n    /**\r\n     * Default image processing configuration used either in the rendering\r\n     * Forward main pass or through the imageProcessingPostProcess if present.\r\n     * As in the majority of the scene they are the same (exception for multi camera),\r\n     * this is easier to reference from here than from all the materials and post process.\r\n     *\r\n     * No setter as we it is a shared configuration, you can set the values instead.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    private _forceWireframe = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\r\n     */\r\n    public set forceWireframe(value: boolean) {\r\n        if (this._forceWireframe === value) {\r\n            return;\r\n        }\r\n        this._forceWireframe = value;\r\n        this.markAllMaterialsAsDirty(16);\r\n    }\r\n    public get forceWireframe(): boolean {\r\n        return this._forceWireframe;\r\n    }\r\n\r\n    private _skipFrustumClipping = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\r\n     */\r\n    public set skipFrustumClipping(value: boolean) {\r\n        if (this._skipFrustumClipping === value) {\r\n            return;\r\n        }\r\n        this._skipFrustumClipping = value;\r\n    }\r\n    public get skipFrustumClipping(): boolean {\r\n        return this._skipFrustumClipping;\r\n    }\r\n\r\n    private _forcePointsCloud = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\r\n     */\r\n    public set forcePointsCloud(value: boolean) {\r\n        if (this._forcePointsCloud === value) {\r\n            return;\r\n        }\r\n        this._forcePointsCloud = value;\r\n        this.markAllMaterialsAsDirty(16);\r\n    }\r\n    public get forcePointsCloud(): boolean {\r\n        return this._forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if animations are enabled\r\n     */\r\n    public animationsEnabled = true;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\r\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\r\n     */\r\n    public useConstantAnimationDeltaTime = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\r\n     * Please note that it requires to run a ray cast through the scene on every frame\r\n     */\r\n    public constantlyUpdateMeshUnderPointer = false;\r\n\r\n    /**\r\n     * Defines the HTML cursor to use when hovering over interactive elements\r\n     */\r\n    public hoverCursor = \"pointer\";\r\n    /**\r\n     * Defines the HTML default cursor to use (empty by default)\r\n     */\r\n    public defaultCursor: string = \"\";\r\n    /**\r\n     * Defines whether cursors are handled by the scene.\r\n     */\r\n    public doNotHandleCursors = false;\r\n    /**\r\n     * This is used to call preventDefault() on pointer down\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\r\n    public preventDefaultOnPointerDown = true;\r\n\r\n    /**\r\n     * This is used to call preventDefault() on pointer up\r\n     * in order to block unwanted artifacts like system double clicks\r\n     */\r\n    public preventDefaultOnPointerUp = true;\r\n\r\n    // Metadata\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Gets the name of the plugin used to load this scene (null by default)\r\n     */\r\n    public loadingPluginName: string;\r\n\r\n    /**\r\n     * Use this array to add regular expressions used to disable offline support for specific urls\r\n     */\r\n    public disableOfflineSupportExceptionRules = new Array<RegExp>();\r\n\r\n    /**\r\n    * An event triggered when the scene is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<Scene>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed when this scene is disposed. */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the scene (right after animations and physics)\r\n    */\r\n    public onBeforeRenderObservable = new Observable<Scene>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed before rendering this scene */\r\n    public set beforeRender(callback: Nullable<() => void>) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        if (callback) {\r\n            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the scene\r\n    */\r\n    public onAfterRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\r\n    */\r\n    public onAfterRenderCameraObservable = new Observable<Camera>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>> = null;\r\n    /** Sets a function to be executed after rendering this scene */\r\n    public set afterRender(callback: Nullable<() => void>) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n\r\n        if (callback) {\r\n            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * An event triggered before animating the scene\r\n    */\r\n    public onBeforeAnimationsObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered after animations processing\r\n    */\r\n    public onAfterAnimationsObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered before draw calls are ready to be sent\r\n    */\r\n    public onBeforeDrawPhaseObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered after draw calls have been sent\r\n    */\r\n    public onAfterDrawPhaseObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when the scene is ready\r\n    */\r\n    public onReadyObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered before rendering a camera\r\n    */\r\n    public onBeforeCameraRenderObservable = new Observable<Camera>();\r\n\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /** Sets a function to be executed before rendering a camera*/\r\n    public set beforeCameraRender(callback: () => void) {\r\n        if (this._onBeforeCameraRenderObserver) {\r\n            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        }\r\n\r\n        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering a camera\r\n    */\r\n    public onAfterCameraRenderObservable = new Observable<Camera>();\r\n\r\n    private _onAfterCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /** Sets a function to be executed after rendering a camera*/\r\n    public set afterCameraRender(callback: () => void) {\r\n        if (this._onAfterCameraRenderObserver) {\r\n            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\r\n        }\r\n        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when active meshes evaluation is about to start\r\n    */\r\n    public onBeforeActiveMeshesEvaluationObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when active meshes evaluation is done\r\n    */\r\n    public onAfterActiveMeshesEvaluationObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when particles rendering is about to start\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\r\n    public onBeforeParticlesRenderingObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when particles rendering is done\r\n    * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\r\n    */\r\n    public onAfterParticlesRenderingObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\r\n    */\r\n    public onDataLoadedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when a camera is created\r\n    */\r\n    public onNewCameraAddedObservable = new Observable<Camera>();\r\n\r\n    /**\r\n    * An event triggered when a camera is removed\r\n    */\r\n    public onCameraRemovedObservable = new Observable<Camera>();\r\n\r\n    /**\r\n    * An event triggered when a light is created\r\n    */\r\n    public onNewLightAddedObservable = new Observable<Light>();\r\n\r\n    /**\r\n    * An event triggered when a light is removed\r\n    */\r\n    public onLightRemovedObservable = new Observable<Light>();\r\n\r\n    /**\r\n    * An event triggered when a geometry is created\r\n    */\r\n    public onNewGeometryAddedObservable = new Observable<Geometry>();\r\n\r\n    /**\r\n    * An event triggered when a geometry is removed\r\n    */\r\n    public onGeometryRemovedObservable = new Observable<Geometry>();\r\n\r\n    /**\r\n    * An event triggered when a transform node is created\r\n    */\r\n    public onNewTransformNodeAddedObservable = new Observable<TransformNode>();\r\n\r\n    /**\r\n    * An event triggered when a transform node is removed\r\n    */\r\n    public onTransformNodeRemovedObservable = new Observable<TransformNode>();\r\n\r\n    /**\r\n    * An event triggered when a mesh is created\r\n    */\r\n    public onNewMeshAddedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n    * An event triggered when a mesh is removed\r\n    */\r\n    public onMeshRemovedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when a skeleton is created\r\n     */\r\n    public onNewSkeletonAddedObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n    * An event triggered when a skeleton is removed\r\n    */\r\n    public onSkeletonRemovedObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n    * An event triggered when a material is created\r\n    */\r\n    public onNewMaterialAddedObservable = new Observable<Material>();\r\n\r\n    /**\r\n    * An event triggered when a multi material is created\r\n    */\r\n   public onNewMultiMaterialAddedObservable = new Observable<MultiMaterial>();\r\n\r\n    /**\r\n    * An event triggered when a material is removed\r\n    */\r\n    public onMaterialRemovedObservable = new Observable<Material>();\r\n\r\n    /**\r\n    * An event triggered when a multi material is removed\r\n    */\r\n    public onMultiMaterialRemovedObservable = new Observable<MultiMaterial>();\r\n\r\n    /**\r\n    * An event triggered when a texture is created\r\n    */\r\n    public onNewTextureAddedObservable = new Observable<BaseTexture>();\r\n\r\n    /**\r\n    * An event triggered when a texture is removed\r\n    */\r\n    public onTextureRemovedObservable = new Observable<BaseTexture>();\r\n\r\n    /**\r\n    * An event triggered when render targets are about to be rendered\r\n    * Can happen multiple times per frame.\r\n    */\r\n    public onBeforeRenderTargetsRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered when render targets were rendered.\r\n    * Can happen multiple times per frame.\r\n    */\r\n    public onAfterRenderTargetsRenderObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered before calculating deterministic simulation step\r\n    */\r\n    public onBeforeStepObservable = new Observable<Scene>();\r\n\r\n    /**\r\n    * An event triggered after calculating deterministic simulation step\r\n    */\r\n    public onAfterStepObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * An event triggered when the activeCamera property is updated\r\n     */\r\n    public onActiveCameraChanged = new Observable<Scene>();\r\n\r\n    /**\r\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\r\n    public onBeforeRenderingGroupObservable = new Observable<RenderingGroupInfo>();\r\n\r\n    /**\r\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\r\n     * The RenderinGroupInfo class contains all the information about the context in which the observable is called\r\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\r\n     */\r\n    public onAfterRenderingGroupObservable = new Observable<RenderingGroupInfo>();\r\n\r\n    /**\r\n     * This Observable will when a mesh has been imported into the scene.\r\n     */\r\n    public onMeshImportedObservable = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * This Observable will when an animation file has been imported into the scene.\r\n     */\r\n    public onAnimationFileImportedObservable = new Observable<Scene>();\r\n\r\n    /**\r\n     * Gets or sets a user defined funtion to select LOD from a mesh and a camera.\r\n     * By default this function is undefined and Babylon.js will select LOD based on distance to camera\r\n     */\r\n    public customLODSelector: (mesh: AbstractMesh, camera: Camera) => Nullable<AbstractMesh>;\r\n\r\n    // Animations\r\n\r\n    /** @hidden */\r\n    public _registeredForLateAnimationBindings = new SmartArrayNoDuplicate<any>(256);\r\n\r\n    // Pointers\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\r\n     */\r\n    public pointerDownPredicate: (Mesh: AbstractMesh) => boolean;\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\r\n     */\r\n    public pointerUpPredicate: (Mesh: AbstractMesh) => boolean;\r\n    /**\r\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\r\n     */\r\n    public pointerMovePredicate: (Mesh: AbstractMesh) => boolean;\r\n\r\n    /** Callback called when a pointer move is detected */\r\n    public onPointerMove: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer down is detected  */\r\n    public onPointerDown: (evt: PointerEvent, pickInfo: PickingInfo, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer up is detected  */\r\n    public onPointerUp: (evt: PointerEvent, pickInfo: Nullable<PickingInfo>, type: PointerEventTypes) => void;\r\n    /** Callback called when a pointer pick is detected */\r\n    public onPointerPick: (evt: PointerEvent, pickInfo: PickingInfo) => void;\r\n\r\n    /**\r\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\r\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\r\n     */\r\n    public onPrePointerObservable = new Observable<PointerInfoPre>();\r\n\r\n    /**\r\n     * Observable event triggered each time an input event is received from the rendering canvas\r\n     */\r\n    public onPointerObservable = new Observable<PointerInfo>();\r\n\r\n    /**\r\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return this._inputManager.unTranslatedPointer;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\r\n     */\r\n    public static get DragMovementThreshold() {\r\n        return InputManager.DragMovementThreshold;\r\n    }\r\n\r\n    public static set DragMovementThreshold(value: number) {\r\n        InputManager.DragMovementThreshold = value;\r\n    }\r\n\r\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\r\n     */\r\n    public static get LongPressDelay() {\r\n        return InputManager.LongPressDelay;\r\n    }\r\n\r\n    public static set LongPressDelay(value: number) {\r\n        InputManager.LongPressDelay = value;\r\n    }\r\n\r\n    /**\r\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\r\n     */\r\n    public static get DoubleClickDelay() {\r\n        return InputManager.DoubleClickDelay;\r\n    }\r\n\r\n    public static set DoubleClickDelay(value: number) {\r\n        InputManager.DoubleClickDelay = value;\r\n    }\r\n\r\n    /** If you need to check double click without raising a single click at first click, enable this flag */\r\n    public static get ExclusiveDoubleClickMode() {\r\n        return InputManager.ExclusiveDoubleClickMode;\r\n    }\r\n\r\n    public static set ExclusiveDoubleClickMode(value: boolean) {\r\n        InputManager.ExclusiveDoubleClickMode = value;\r\n    }\r\n\r\n    // Mirror\r\n    /** @hidden */\r\n    public _mirroredCameraPosition: Nullable<Vector3>;\r\n\r\n    // Keyboard\r\n\r\n    /**\r\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\r\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\r\n     */\r\n    public onPreKeyboardObservable = new Observable<KeyboardInfoPre>();\r\n\r\n    /**\r\n     * Observable event triggered each time an keyboard event is received from the hosting window\r\n     */\r\n    public onKeyboardObservable = new Observable<KeyboardInfo>();\r\n\r\n    // Coordinates system\r\n\r\n    private _useRightHandedSystem = false;\r\n    /**\r\n    * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\r\n    */\r\n    public set useRightHandedSystem(value: boolean) {\r\n        if (this._useRightHandedSystem === value) {\r\n            return;\r\n        }\r\n        this._useRightHandedSystem = value;\r\n        this.markAllMaterialsAsDirty(16);\r\n    }\r\n    public get useRightHandedSystem(): boolean {\r\n        return this._useRightHandedSystem;\r\n    }\r\n\r\n    // Deterministic lockstep\r\n    private _timeAccumulator: number = 0;\r\n    private _currentStepId: number = 0;\r\n    private _currentInternalStep: number = 0;\r\n\r\n    /**\r\n     * Sets the step Id used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @param newStepId defines the step Id\r\n     */\r\n    public setStepId(newStepId: number): void {\r\n        this._currentStepId = newStepId;\r\n    }\r\n\r\n    /**\r\n     * Gets the step Id used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns the step Id\r\n     */\r\n    public getStepId(): number {\r\n        return this._currentStepId;\r\n    }\r\n\r\n    /**\r\n     * Gets the internal step used by deterministic lock step\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns the internal step\r\n     */\r\n    public getInternalStep(): number {\r\n        return this._currentInternalStep;\r\n    }\r\n\r\n    // Fog\r\n\r\n    private _fogEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if fog is enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is true)\r\n    */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAllMaterialsAsDirty(16);\r\n    }\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    private _fogMode = Scene.FOGMODE_NONE;\r\n    /**\r\n    * Gets or sets the fog mode to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * | mode | value |\r\n    * | --- | --- |\r\n    * | FOGMODE_NONE | 0 |\r\n    * | FOGMODE_EXP | 1 |\r\n    * | FOGMODE_EXP2 | 2 |\r\n    * | FOGMODE_LINEAR | 3 |\r\n    */\r\n    public set fogMode(value: number) {\r\n        if (this._fogMode === value) {\r\n            return;\r\n        }\r\n        this._fogMode = value;\r\n        this.markAllMaterialsAsDirty(16);\r\n    }\r\n    public get fogMode(): number {\r\n        return this._fogMode;\r\n    }\r\n\r\n    /**\r\n    * Gets or sets the fog color to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is Color3(0.2, 0.2, 0.3))\r\n    */\r\n    public fogColor = new Color3(0.2, 0.2, 0.3);\r\n    /**\r\n    * Gets or sets the fog density to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0.1)\r\n    */\r\n    public fogDensity = 0.1;\r\n    /**\r\n    * Gets or sets the fog start distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 0)\r\n    */\r\n    public fogStart = 0;\r\n    /**\r\n    * Gets or sets the fog end distance to use\r\n    * @see https://doc.babylonjs.com/babylon101/environment#fog\r\n    * (Default is 1000)\r\n    */\r\n    public fogEnd = 1000.0;\r\n\r\n    /**\r\n    * Flag indicating that the frame buffer binding is handled by another component\r\n    */\r\n    public prePass: boolean = false;\r\n\r\n    // Lights\r\n    private _shadowsEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if shadows are enabled on this scene\r\n    */\r\n    public set shadowsEnabled(value: boolean) {\r\n        if (this._shadowsEnabled === value) {\r\n            return;\r\n        }\r\n        this._shadowsEnabled = value;\r\n        this.markAllMaterialsAsDirty(2);\r\n    }\r\n    public get shadowsEnabled(): boolean {\r\n        return this._shadowsEnabled;\r\n    }\r\n\r\n    private _lightsEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if lights are enabled on this scene\r\n    */\r\n    public set lightsEnabled(value: boolean) {\r\n        if (this._lightsEnabled === value) {\r\n            return;\r\n        }\r\n        this._lightsEnabled = value;\r\n        this.markAllMaterialsAsDirty(2);\r\n    }\r\n\r\n    public get lightsEnabled(): boolean {\r\n        return this._lightsEnabled;\r\n    }\r\n\r\n    /** All of the active cameras added to this scene. */\r\n    public activeCameras: Nullable<Camera[]> = new Array<Camera>();\r\n\r\n    /** @hidden */\r\n    public _activeCamera: Nullable<Camera>;\r\n    /** Gets or sets the current active camera */\r\n    public get activeCamera(): Nullable<Camera> {\r\n        return this._activeCamera;\r\n    }\r\n\r\n    public set activeCamera(value: Nullable<Camera>) {\r\n        if (value === this._activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this._activeCamera = value;\r\n        this.onActiveCameraChanged.notifyObservers(this);\r\n    }\r\n\r\n    private _defaultMaterial: Material;\r\n\r\n    /** The default material used on meshes when no material is affected */\r\n    public get defaultMaterial(): Material {\r\n        if (!this._defaultMaterial) {\r\n            this._defaultMaterial = Scene.DefaultMaterialFactory(this);\r\n        }\r\n\r\n        return this._defaultMaterial;\r\n    }\r\n\r\n    /** The default material used on meshes when no material is affected */\r\n    public set defaultMaterial(value: Material) {\r\n        this._defaultMaterial = value;\r\n    }\r\n\r\n    // Textures\r\n    private _texturesEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if textures are enabled on this scene\r\n    */\r\n    public set texturesEnabled(value: boolean) {\r\n        if (this._texturesEnabled === value) {\r\n            return;\r\n        }\r\n        this._texturesEnabled = value;\r\n        this.markAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    public get texturesEnabled(): boolean {\r\n        return this._texturesEnabled;\r\n    }\r\n\r\n    // Physics\r\n    /**\r\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\r\n     */\r\n    public physicsEnabled = true;\r\n\r\n    // Particles\r\n    /**\r\n    * Gets or sets a boolean indicating if particles are enabled on this scene\r\n    */\r\n    public particlesEnabled = true;\r\n\r\n    // Sprites\r\n    /**\r\n    * Gets or sets a boolean indicating if sprites are enabled on this scene\r\n    */\r\n    public spritesEnabled = true;\r\n\r\n    // Skeletons\r\n    private _skeletonsEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if skeletons are enabled on this scene\r\n    */\r\n    public set skeletonsEnabled(value: boolean) {\r\n        if (this._skeletonsEnabled === value) {\r\n            return;\r\n        }\r\n        this._skeletonsEnabled = value;\r\n        this.markAllMaterialsAsDirty(8);\r\n    }\r\n\r\n    public get skeletonsEnabled(): boolean {\r\n        return this._skeletonsEnabled;\r\n    }\r\n\r\n    // Lens flares\r\n    /**\r\n    * Gets or sets a boolean indicating if lens flares are enabled on this scene\r\n    */\r\n    public lensFlaresEnabled = true;\r\n\r\n    // Collisions\r\n    /**\r\n    * Gets or sets a boolean indicating if collisions are enabled on this scene\r\n    * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n    */\r\n    public collisionsEnabled = true;\r\n\r\n    private _collisionCoordinator: ICollisionCoordinator;\r\n\r\n    /** @hidden */\r\n    public get collisionCoordinator(): ICollisionCoordinator {\r\n        if (!this._collisionCoordinator) {\r\n            this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\r\n            this._collisionCoordinator.init(this);\r\n        }\r\n\r\n        return this._collisionCoordinator;\r\n    }\r\n\r\n    /**\r\n     * Defines the gravity applied to this scene (used only for collisions)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public gravity = new Vector3(0, -9.807, 0);\r\n\r\n    // Postprocesses\r\n    /**\r\n    * Gets or sets a boolean indicating if postprocesses are enabled on this scene\r\n    */\r\n    public postProcessesEnabled = true;\r\n    /**\r\n     * Gets the current postprocess manager\r\n     */\r\n    public postProcessManager: PostProcessManager;\r\n\r\n    // Customs render targets\r\n    /**\r\n    * Gets or sets a boolean indicating if render targets are enabled on this scene\r\n    */\r\n    public renderTargetsEnabled = true;\r\n    /**\r\n    * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\r\n    * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\r\n    */\r\n    public dumpNextRenderTargets = false;\r\n    /**\r\n     * The list of user defined render targets added to the scene\r\n     */\r\n    public customRenderTargets = new Array<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Defines if texture loading must be delayed\r\n     * If true, textures will only be loaded when they need to be rendered\r\n     */\r\n    public useDelayedTextureLoading: boolean;\r\n\r\n    /**\r\n     * Gets the list of meshes imported to the scene through SceneLoader\r\n     */\r\n    public importedMeshesFiles = new Array<String>();\r\n\r\n    // Probes\r\n    /**\r\n    * Gets or sets a boolean indicating if probes are enabled on this scene\r\n    */\r\n    public probesEnabled = true;\r\n\r\n    // Offline support\r\n    /**\r\n     * Gets or sets the current offline provider to use to store scene data\r\n     * @see https://doc.babylonjs.com/how_to/caching_resources_in_indexeddb\r\n     */\r\n    public offlineProvider: IOfflineProvider;\r\n\r\n    /**\r\n     * Gets or sets the action manager associated with the scene\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n    */\r\n    public actionManager: AbstractActionManager;\r\n\r\n    private _meshesForIntersections = new SmartArrayNoDuplicate<AbstractMesh>(256);\r\n\r\n    // Procedural textures\r\n    /**\r\n    * Gets or sets a boolean indicating if procedural textures are enabled on this scene\r\n    */\r\n    public proceduralTexturesEnabled = true;\r\n\r\n    // Private\r\n    private _engine: Engine;\r\n\r\n    // Performance counters\r\n    private _totalVertices = new PerfCounter();\r\n    /** @hidden */\r\n    public _activeIndices = new PerfCounter();\r\n    /** @hidden */\r\n    public _activeParticles = new PerfCounter();\r\n    /** @hidden */\r\n    public _activeBones = new PerfCounter();\r\n\r\n    private _animationRatio: number;\r\n\r\n    /** @hidden */\r\n    public _animationTimeLast: number;\r\n\r\n    /** @hidden */\r\n    public _animationTime: number = 0;\r\n\r\n    /**\r\n     * Gets or sets a general scale for animation speed\r\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\r\n     */\r\n    public animationTimeScale: number = 1;\r\n\r\n    /** @hidden */\r\n    public _cachedMaterial: Nullable<Material>;\r\n    /** @hidden */\r\n    public _cachedEffect: Nullable<Effect>;\r\n    /** @hidden */\r\n    public _cachedVisibility: Nullable<number>;\r\n\r\n    private _renderId = 0;\r\n    private _frameId = 0;\r\n    private _executeWhenReadyTimeoutId = -1;\r\n    private _intermediateRendering = false;\r\n\r\n    private _viewUpdateFlag = -1;\r\n    private _projectionUpdateFlag = -1;\r\n\r\n    /** @hidden */\r\n    public _toBeDisposed = new Array<Nullable<IDisposable>>(256);\r\n    private _activeRequests = new Array<IFileRequest>();\r\n\r\n    /** @hidden */\r\n    public _pendingData = new Array();\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\r\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\r\n     */\r\n    public dispatchAllSubMeshesOfActiveMeshes: boolean = false;\r\n    private _activeMeshes = new SmartArray<AbstractMesh>(256);\r\n    private _processedMaterials = new SmartArray<Material>(256);\r\n    private _renderTargets = new SmartArrayNoDuplicate<RenderTargetTexture>(256);\r\n    /** @hidden */\r\n    public _activeParticleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _activeSkeletons = new SmartArrayNoDuplicate<Skeleton>(32);\r\n    private _softwareSkinnedMeshes = new SmartArrayNoDuplicate<Mesh>(32);\r\n\r\n    private _renderingManager: RenderingManager;\r\n\r\n    /** @hidden */\r\n    public _activeAnimatables = new Array<Animatable>();\r\n\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _sceneUbo: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _viewMatrix: Matrix;\r\n    private _projectionMatrix: Matrix;\r\n    /** @hidden */\r\n    public _forcedViewPosition: Nullable<Vector3>;\r\n\r\n    /** @hidden */\r\n    public _frustumPlanes: Plane[];\r\n    /**\r\n     * Gets the list of frustum planes (built from the active camera)\r\n     */\r\n    public get frustumPlanes(): Plane[] {\r\n        return this._frustumPlanes;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\r\n     * This is useful if there are more lights that the maximum simulteanous authorized\r\n     */\r\n    public requireLightSorting = false;\r\n\r\n    /** @hidden */\r\n    public readonly useMaterialMeshMap: boolean;\r\n    /** @hidden */\r\n    public readonly useClonedMeshMap: boolean;\r\n\r\n    private _externalData: StringDictionary<Object>;\r\n    private _uid: Nullable<string>;\r\n\r\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\r\n    public _components: ISceneComponent[] = [];\r\n\r\n    /**\r\n     * @hidden\r\n     * Backing store of defined scene components.\r\n     */\r\n    public _serializableComponents: ISceneSerializableComponent[] = [];\r\n\r\n    /**\r\n     * List of components to register on the next registration step.\r\n     */\r\n    private _transientComponents: ISceneComponent[] = [];\r\n\r\n    /**\r\n     * Registers the transient components if needed.\r\n     */\r\n    private _registerTransientComponents(): void {\r\n        // Register components that have been associated lately to the scene.\r\n        if (this._transientComponents.length > 0) {\r\n            for (let component of this._transientComponents) {\r\n                component.register();\r\n            }\r\n            this._transientComponents = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Add a component to the scene.\r\n     * Note that the ccomponent could be registered on th next frame if this is called after\r\n     * the register component stage.\r\n     * @param component Defines the component to add to the scene\r\n     */\r\n    public _addComponent(component: ISceneComponent) {\r\n        this._components.push(component);\r\n        this._transientComponents.push(component);\r\n\r\n        const serializableComponent = component as ISceneSerializableComponent;\r\n        if (serializableComponent.addFromContainer && serializableComponent.serialize) {\r\n            this._serializableComponents.push(serializableComponent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Gets a component from the scene.\r\n     * @param name defines the name of the component to retrieve\r\n     * @returns the component or null if not present\r\n     */\r\n    public _getComponent(name: string): Nullable<ISceneComponent> {\r\n        for (let component of this._components) {\r\n            if (component.name === name) {\r\n                return component;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before camera updates.\r\n     */\r\n    public _beforeCameraUpdateStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before clear the canvas.\r\n     */\r\n    public _beforeClearStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions when collecting render targets for the frame.\r\n     */\r\n    public _gatherRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening for one camera in the frame.\r\n     */\r\n    public _gatherActiveCameraRenderTargetsStage = Stage.Create<RenderTargetsStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per mesh ready checks.\r\n     */\r\n    public _isReadyForMeshStage = Stage.Create<MeshStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening before evaluate active mesh checks.\r\n     */\r\n    public _beforeEvaluateActiveMeshStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the evaluate sub mesh checks.\r\n     */\r\n    public _evaluateSubMeshStage = Stage.Create<EvaluateSubMeshStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the active mesh stage.\r\n     */\r\n    public _preActiveMeshStage = Stage.Create<PreActiveMeshStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening during the per camera render target step.\r\n     */\r\n    public _cameraDrawRenderTargetStage = Stage.Create<CameraStageFrameBufferAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before the active camera is drawing.\r\n     */\r\n    public _beforeCameraDrawStage = Stage.Create<CameraStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a render target is drawing.\r\n     */\r\n    public _beforeRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a rendering group is drawing.\r\n     */\r\n    public _beforeRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just before a mesh is drawing.\r\n     */\r\n    public _beforeRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a mesh has been drawn.\r\n     */\r\n    public _afterRenderingMeshStage = Stage.Create<RenderingMeshStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a rendering group has been drawn.\r\n     */\r\n    public _afterRenderingGroupDrawStage = Stage.Create<RenderingGroupStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after the active camera has been drawn.\r\n     */\r\n    public _afterCameraDrawStage = Stage.Create<CameraStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after a render target has been drawn.\r\n     */\r\n    public _afterRenderTargetDrawStage = Stage.Create<RenderTargetStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening just after rendering all cameras and computing intersections.\r\n     */\r\n    public _afterRenderStage = Stage.Create<SimpleStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer move event happens.\r\n     */\r\n    public _pointerMoveStage = Stage.Create<PointerMoveStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer down event happens.\r\n     */\r\n    public _pointerDownStage = Stage.Create<PointerUpDownStageAction>();\r\n    /**\r\n     * @hidden\r\n     * Defines the actions happening when a pointer up event happens.\r\n     */\r\n    public _pointerUpStage = Stage.Create<PointerUpDownStageAction>();\r\n\r\n    /**\r\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\r\n     */\r\n    private geometriesByUniqueId: Nullable<{ [uniqueId: string]: number | undefined }> = null;\r\n\r\n    /**\r\n     * Creates a new Scene\r\n     * @param engine defines the engine to use to render this scene\r\n     * @param options defines the scene options\r\n     */\r\n    constructor(engine: Engine, options?: SceneOptions) {\r\n        super();\r\n\r\n        const fullOptions = {\r\n            useGeometryUniqueIdsMap: true,\r\n            useMaterialMeshMap: true,\r\n            useClonedMeshMap: true,\r\n            virtual: false,\r\n            ...options\r\n        };\r\n\r\n        this._engine = engine || EngineStore.LastCreatedEngine;\r\n        if (!fullOptions.virtual) {\r\n            EngineStore._LastCreatedScene = this;\r\n            this._engine.scenes.push(this);\r\n        }\r\n\r\n        this._uid = null;\r\n\r\n        this._renderingManager = new RenderingManager(this);\r\n\r\n        if (PostProcessManager) {\r\n            this.postProcessManager = new PostProcessManager(this);\r\n        }\r\n\r\n        if (DomManagement.IsWindowObjectExist()) {\r\n            this.attachControl();\r\n        }\r\n\r\n        // Uniform Buffer\r\n        this._createUbo();\r\n\r\n        // Default Image processing definition\r\n        if (ImageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n        }\r\n\r\n        this.setDefaultCandidateProviders();\r\n\r\n        if (fullOptions.useGeometryUniqueIdsMap) {\r\n            this.geometriesByUniqueId = {};\r\n        }\r\n\r\n        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\r\n        this.useClonedMeshMap = fullOptions.useClonedMeshMap;\r\n\r\n        if (!options || !options.virtual) {\r\n            this._engine.onNewSceneAddedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"Scene\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"Scene\";\r\n    }\r\n\r\n    private _defaultMeshCandidates: ISmartArrayLike<AbstractMesh> = {\r\n        data: [],\r\n        length: 0\r\n    };\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getDefaultMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        this._defaultMeshCandidates.data = this.meshes;\r\n        this._defaultMeshCandidates.length = this.meshes.length;\r\n        return this._defaultMeshCandidates;\r\n    }\r\n\r\n    private _defaultSubMeshCandidates: ISmartArrayLike<SubMesh> = {\r\n        data: [],\r\n        length: 0\r\n    };\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getDefaultSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        this._defaultSubMeshCandidates.data = mesh.subMeshes;\r\n        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\r\n        return this._defaultSubMeshCandidates;\r\n    }\r\n\r\n    /**\r\n     * Sets the default candidate providers for the scene.\r\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\r\n     * and getCollidingSubMeshCandidates to their default function\r\n     */\r\n    public setDefaultCandidateProviders(): void {\r\n        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\r\n\r\n        this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\r\n        this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\r\n        this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        return this._inputManager.meshUnderPointer;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\r\n    public get pointerX(): number {\r\n        return this._inputManager.pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._inputManager.pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\r\n    public get pointerY(): number {\r\n        return this._inputManager.pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._inputManager.pointerY = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached material (ie. the latest rendered one)\r\n     * @returns the cached material\r\n     */\r\n    public getCachedMaterial(): Nullable<Material> {\r\n        return this._cachedMaterial;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached effect (ie. the latest rendered one)\r\n     * @returns the cached effect\r\n     */\r\n    public getCachedEffect(): Nullable<Effect> {\r\n        return this._cachedEffect;\r\n    }\r\n\r\n    /**\r\n     * Gets the cached visibility state (ie. the latest rendered one)\r\n     * @returns the cached visibility state\r\n     */\r\n    public getCachedVisibility(): Nullable<number> {\r\n        return this._cachedVisibility;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\r\n     * @param material defines the current material\r\n     * @param effect defines the current effect\r\n     * @param visibility defines the current visibility state\r\n     * @returns true if one parameter is not cached\r\n     */\r\n    public isCachedMaterialInvalid(material: Material, effect: Effect, visibility: number = 1) {\r\n        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets the engine associated with the scene\r\n     * @returns an Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of vertices rendered per frame\r\n     * @returns the total number of vertices rendered per frame\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._totalVertices.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for total vertices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\r\n    public get totalVerticesPerfCounter(): PerfCounter {\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\r\n     * @returns the total number of active indices rendered per frame\r\n     */\r\n    public getActiveIndices(): number {\r\n        return this._activeIndices.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active indices\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\r\n    public get totalActiveIndicesPerfCounter(): PerfCounter {\r\n        return this._activeIndices;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active particles rendered per frame\r\n     * @returns the total number of active particles rendered per frame\r\n     */\r\n    public getActiveParticles(): number {\r\n        return this._activeParticles.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active particles\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\r\n    public get activeParticlesPerfCounter(): PerfCounter {\r\n        return this._activeParticles;\r\n    }\r\n\r\n    /**\r\n     * Gets the total number of active bones rendered per frame\r\n     * @returns the total number of active bones rendered per frame\r\n     */\r\n    public getActiveBones(): number {\r\n        return this._activeBones.current;\r\n    }\r\n\r\n    /**\r\n     * Gets the performance counter for active bones\r\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\r\n     */\r\n    public get activeBonesPerfCounter(): PerfCounter {\r\n        return this._activeBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the array of active meshes\r\n     * @returns an array of AbstractMesh\r\n     */\r\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\r\n        return this._activeMeshes;\r\n    }\r\n\r\n    /**\r\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\r\n     * @returns a number\r\n     */\r\n    public getAnimationRatio(): number {\r\n        return this._animationRatio !== undefined ? this._animationRatio : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique Id for the current render phase\r\n     * @returns a number\r\n     */\r\n    public getRenderId(): number {\r\n        return this._renderId;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique Id for the current frame\r\n     * @returns a number\r\n     */\r\n    public getFrameId(): number {\r\n        return this._frameId;\r\n    }\r\n\r\n    /** Call this function if you want to manually increment the render Id*/\r\n    public incrementRenderId(): void {\r\n        this._renderId++;\r\n    }\r\n\r\n    private _createUbo(): void {\r\n        this._sceneUbo = new UniformBuffer(this._engine, undefined, true);\r\n        this._sceneUbo.addUniform(\"viewProjection\", 16);\r\n        this._sceneUbo.addUniform(\"view\", 16);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\r\n        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): Scene {\r\n        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     * @returns the current scene\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): Scene {\r\n        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._inputManager.isPointerCaptured(pointerId);\r\n    }\r\n\r\n    /**\r\n    * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n    * @param attachUp defines if you want to attach events to pointerup\r\n    * @param attachDown defines if you want to attach events to pointerdown\r\n    * @param attachMove defines if you want to attach events to pointermove\r\n    */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true): void {\r\n        this._inputManager.attachControl(attachUp, attachDown, attachMove);\r\n    }\r\n\r\n    /** Detaches all event handlers*/\r\n    public detachControl() {\r\n        this._inputManager.detachControl();\r\n    }\r\n\r\n    /**\r\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\r\n     * Delay loaded resources are not taking in account\r\n     * @return true if all required resources are ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this._isDisposed) {\r\n            return false;\r\n        }\r\n\r\n        let index: number;\r\n        let engine = this.getEngine();\r\n\r\n        // Effects\r\n        if (!engine.areAllEffectsReady()) {\r\n            return false;\r\n        }\r\n\r\n        // Pending data\r\n        if (this._pendingData.length > 0) {\r\n            return false;\r\n        }\r\n\r\n        // Meshes\r\n        for (index = 0; index < this.meshes.length; index++) {\r\n            var mesh = this.meshes[index];\r\n\r\n            if (!mesh.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n                continue;\r\n            }\r\n\r\n            if (!mesh.isReady(true)) {\r\n                return false;\r\n            }\r\n\r\n            let hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && (<Mesh>mesh).instances.length > 0;\r\n            // Is Ready For Mesh\r\n            for (let step of this._isReadyForMeshStage) {\r\n                if (!step.action(mesh, hardwareInstancedRendering)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        for (index = 0; index < this.geometries.length; index++) {\r\n            var geometry = this.geometries[index];\r\n\r\n            if (geometry.delayLoadState === 2) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Post-processes\r\n        if (this.activeCameras && this.activeCameras.length > 0) {\r\n            for (var camera of this.activeCameras) {\r\n                if (!camera.isReady(true)) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (this.activeCamera) {\r\n            if (!this.activeCamera.isReady(true)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Particles\r\n        for (var particleSystem of this.particleSystems) {\r\n            if (!particleSystem.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** Resets all cached information relative to material (including effect and visibility) */\r\n    public resetCachedMaterial(): void {\r\n        this._cachedMaterial = null;\r\n        this._cachedEffect = null;\r\n        this._cachedVisibility = null;\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be called before every frame render\r\n     * @param func defines the function to register\r\n     */\r\n    public registerBeforeRender(func: () => void): void {\r\n        this.onBeforeRenderObservable.add(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function called before every frame render\r\n     * @param func defines the function to unregister\r\n     */\r\n    public unregisterBeforeRender(func: () => void): void {\r\n        this.onBeforeRenderObservable.removeCallback(func);\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be called after every frame render\r\n     * @param func defines the function to register\r\n     */\r\n    public registerAfterRender(func: () => void): void {\r\n        this.onAfterRenderObservable.add(func);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a function called after every frame render\r\n     * @param func defines the function to unregister\r\n     */\r\n    public unregisterAfterRender(func: () => void): void {\r\n        this.onAfterRenderObservable.removeCallback(func);\r\n    }\r\n\r\n    private _executeOnceBeforeRender(func: () => void): void {\r\n        let execFunc = () => {\r\n            func();\r\n            setTimeout(() => {\r\n                this.unregisterBeforeRender(execFunc);\r\n            });\r\n        };\r\n        this.registerBeforeRender(execFunc);\r\n    }\r\n\r\n    /**\r\n     * The provided function will run before render once and will be disposed afterwards.\r\n     * A timeout delay can be provided so that the function will be executed in N ms.\r\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\r\n     * @param func The function to be executed.\r\n     * @param timeout optional delay in ms\r\n     */\r\n    public executeOnceBeforeRender(func: () => void, timeout?: number): void {\r\n        if (timeout !== undefined) {\r\n            setTimeout(() => {\r\n                this._executeOnceBeforeRender(func);\r\n            }, timeout);\r\n        } else {\r\n            this._executeOnceBeforeRender(func);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _addPendingData(data: any): void {\r\n        this._pendingData.push(data);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _removePendingData(data: any): void {\r\n        var wasLoading = this.isLoading;\r\n        var index = this._pendingData.indexOf(data);\r\n\r\n        if (index !== -1) {\r\n            this._pendingData.splice(index, 1);\r\n        }\r\n\r\n        if (wasLoading && !this.isLoading) {\r\n            this.onDataLoadedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the number of items waiting to be loaded\r\n     * @returns the number of items waiting to be loaded\r\n     */\r\n    public getWaitingItemsCount(): number {\r\n        return this._pendingData.length;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean indicating if the scene is still loading data\r\n     */\r\n    public get isLoading(): boolean {\r\n        return this._pendingData.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Registers a function to be executed when the scene is ready\r\n     * @param {Function} func - the function to be executed\r\n     */\r\n    public executeWhenReady(func: () => void): void {\r\n        this.onReadyObservable.add(func);\r\n\r\n        if (this._executeWhenReadyTimeoutId !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\r\n            this._checkIsReady();\r\n        }, 150);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the scene is ready\r\n     * @returns A promise that resolves when the scene is ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.executeWhenReady(() => {\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkIsReady() {\r\n        this._registerTransientComponents();\r\n\r\n        if (this.isReady()) {\r\n            this.onReadyObservable.notifyObservers(this);\r\n\r\n            this.onReadyObservable.clear();\r\n            this._executeWhenReadyTimeoutId = -1;\r\n            return;\r\n        }\r\n\r\n        if (this._isDisposed) {\r\n            this.onReadyObservable.clear();\r\n            this._executeWhenReadyTimeoutId = -1;\r\n            return;\r\n        }\r\n\r\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\r\n            this._checkIsReady();\r\n        }, 150);\r\n    }\r\n\r\n    /**\r\n     * Gets all animatable attached to the scene\r\n     */\r\n    public get animatables(): Animatable[] {\r\n        return this._activeAnimatables;\r\n    }\r\n\r\n    /**\r\n     * Resets the last animation time frame.\r\n     * Useful to override when animations start running when loading a scene for the first time.\r\n     */\r\n    public resetLastAnimationTimeFrame(): void {\r\n        this._animationTimeLast = PrecisionDate.Now;\r\n    }\r\n\r\n    // Matrix\r\n\r\n    /**\r\n     * Gets the current view matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getViewMatrix(): Matrix {\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the current projection matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getProjectionMatrix(): Matrix {\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the current transform matrix\r\n     * @returns a Matrix made of View * Projection\r\n     */\r\n    public getTransformMatrix(): Matrix {\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the current transform matrix\r\n     * @param viewL defines the View matrix to use\r\n     * @param projectionL defines the Projection matrix to use\r\n     * @param viewR defines the right View matrix to use (if provided)\r\n     * @param projectionR defines the right Projection matrix to use (if provided)\r\n     */\r\n    public setTransformMatrix(viewL: Matrix, projectionL: Matrix, viewR?: Matrix, projectionR?: Matrix): void {\r\n        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        this._viewUpdateFlag = viewL.updateFlag;\r\n        this._projectionUpdateFlag = projectionL.updateFlag;\r\n        this._viewMatrix = viewL;\r\n        this._projectionMatrix = projectionL;\r\n\r\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\r\n\r\n        // Update frustum\r\n        if (!this._frustumPlanes) {\r\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\r\n        } else {\r\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\r\n        }\r\n\r\n        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\r\n            this._updateMultiviewUbo(viewR, projectionR);\r\n        } else if (this._sceneUbo.useUbo) {\r\n            this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\r\n            this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n            this._sceneUbo.update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the uniform buffer used to store scene data\r\n     * @returns a UniformBuffer\r\n     */\r\n    public getSceneUniformBuffer(): UniformBuffer {\r\n        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\r\n    }\r\n\r\n    /**\r\n     * Gets an unique (relatively to the current scene) Id\r\n     * @returns an unique number for the scene\r\n     */\r\n    public getUniqueId() {\r\n        return UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of scene's meshes\r\n     * @param newMesh defines the mesh to add\r\n     * @param recursive if all child meshes should also be added to the scene\r\n     */\r\n    public addMesh(newMesh: AbstractMesh, recursive = false) {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        this.meshes.push(newMesh);\r\n\r\n        newMesh._resyncLightSources();\r\n\r\n        if (!newMesh.parent) {\r\n            newMesh._addToSceneRootNodes();\r\n        }\r\n\r\n        this.onNewMeshAddedObservable.notifyObservers(newMesh);\r\n\r\n        if (recursive) {\r\n            newMesh.getChildMeshes().forEach((m) => {\r\n                this.addMesh(m);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh for the list of scene's meshes\r\n     * @param toRemove defines the mesh to remove\r\n     * @param recursive if all child meshes should also be removed from the scene\r\n     * @returns the index where the mesh was in the mesh list\r\n     */\r\n    public removeMesh(toRemove: AbstractMesh, recursive = false): number {\r\n        var index = this.meshes.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if mesh found\r\n            this.meshes[index] = this.meshes[this.meshes.length - 1];\r\n            this.meshes.pop();\r\n\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        this.onMeshRemovedObservable.notifyObservers(toRemove);\r\n        if (recursive) {\r\n            toRemove.getChildMeshes().forEach((m) => {\r\n                this.removeMesh(m);\r\n            });\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Add a transform node to the list of scene's transform nodes\r\n     * @param newTransformNode defines the transform node to add\r\n     */\r\n    public addTransformNode(newTransformNode: TransformNode) {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\r\n        this.transformNodes.push(newTransformNode);\r\n\r\n        if (!newTransformNode.parent) {\r\n            newTransformNode._addToSceneRootNodes();\r\n        }\r\n\r\n        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\r\n    }\r\n\r\n    /**\r\n     * Remove a transform node for the list of scene's transform nodes\r\n     * @param toRemove defines the transform node to remove\r\n     * @returns the index where the transform node was in the transform node list\r\n     */\r\n    public removeTransformNode(toRemove: TransformNode): number {\r\n        var index = toRemove._indexInSceneTransformNodesArray;\r\n        if (index !== -1) {\r\n            if (index !== this.transformNodes.length - 1) {\r\n                const lastNode = this.transformNodes[this.transformNodes.length - 1];\r\n                this.transformNodes[index] = lastNode;\r\n                lastNode._indexInSceneTransformNodesArray = index;\r\n            }\r\n\r\n            toRemove._indexInSceneTransformNodesArray = -1;\r\n            this.transformNodes.pop();\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n\r\n        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a skeleton for the list of scene's skeletons\r\n     * @param toRemove defines the skeleton to remove\r\n     * @returns the index where the skeleton was in the skeleton list\r\n     */\r\n    public removeSkeleton(toRemove: Skeleton): number {\r\n        var index = this.skeletons.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this.skeletons.splice(index, 1);\r\n            this.onSkeletonRemovedObservable.notifyObservers(toRemove);\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a morph target for the list of scene's morph targets\r\n     * @param toRemove defines the morph target to remove\r\n     * @returns the index where the morph target was in the morph target list\r\n     */\r\n    public removeMorphTargetManager(toRemove: MorphTargetManager): number {\r\n        var index = this.morphTargetManagers.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this.morphTargetManagers.splice(index, 1);\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a light for the list of scene's lights\r\n     * @param toRemove defines the light to remove\r\n     * @returns the index where the light was in the light list\r\n     */\r\n    public removeLight(toRemove: Light): number {\r\n        var index = this.lights.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from meshes\r\n            for (var mesh of this.meshes) {\r\n                mesh._removeLightSource(toRemove, false);\r\n            }\r\n\r\n            // Remove from the scene if mesh found\r\n            this.lights.splice(index, 1);\r\n            this.sortLightsByPriority();\r\n\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n        this.onLightRemovedObservable.notifyObservers(toRemove);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a camera for the list of scene's cameras\r\n     * @param toRemove defines the camera to remove\r\n     * @returns the index where the camera was in the camera list\r\n     */\r\n    public removeCamera(toRemove: Camera): number {\r\n        var index = this.cameras.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            // Remove from the scene if mesh found\r\n            this.cameras.splice(index, 1);\r\n            if (!toRemove.parent) {\r\n                toRemove._removeFromSceneRootNodes();\r\n            }\r\n        }\r\n        // Remove from activeCameras\r\n        if (this.activeCameras) {\r\n            var index2 = this.activeCameras.indexOf(toRemove);\r\n            if (index2 !== -1) {\r\n                // Remove from the scene if mesh found\r\n                this.activeCameras.splice(index2, 1);\r\n            }\r\n        }\r\n        // Reset the activeCamera\r\n        if (this.activeCamera === toRemove) {\r\n            if (this.cameras.length > 0) {\r\n                this.activeCamera = this.cameras[0];\r\n            } else {\r\n                this.activeCamera = null;\r\n            }\r\n        }\r\n        this.onCameraRemovedObservable.notifyObservers(toRemove);\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a particle system for the list of scene's particle systems\r\n     * @param toRemove defines the particle system to remove\r\n     * @returns the index where the particle system was in the particle system list\r\n     */\r\n    public removeParticleSystem(toRemove: IParticleSystem): number {\r\n        var index = this.particleSystems.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.particleSystems.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Remove a animation for the list of scene's animations\r\n     * @param toRemove defines the animation to remove\r\n     * @returns the index where the animation was in the animation list\r\n     */\r\n    public removeAnimation(toRemove: Animation): number {\r\n        var index = this.animations.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.animations.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Will stop the animation of the given target\r\n     * @param target - the target\r\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    public stopAnimation(target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        // Do nothing as code will be provided by animation component\r\n    }\r\n\r\n    /**\r\n     * Removes the given animation group from this scene.\r\n     * @param toRemove The animation group to remove\r\n     * @returns The index of the removed animation group\r\n     */\r\n    public removeAnimationGroup(toRemove: AnimationGroup): number {\r\n        var index = this.animationGroups.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.animationGroups.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given multi-material from this scene.\r\n     * @param toRemove The multi-material to remove\r\n     * @returns The index of the removed multi-material\r\n     */\r\n    public removeMultiMaterial(toRemove: MultiMaterial): number {\r\n        var index = this.multiMaterials.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given material from this scene.\r\n     * @param toRemove The material to remove\r\n     * @returns The index of the removed material\r\n     */\r\n    public removeMaterial(toRemove: Material): number {\r\n        var index = toRemove._indexInSceneMaterialArray;\r\n        if (index !== -1 && index < this.materials.length) {\r\n            if (index !== this.materials.length - 1) {\r\n                const lastMaterial = this.materials[this.materials.length - 1];\r\n                this.materials[index] = lastMaterial;\r\n                lastMaterial._indexInSceneMaterialArray = index;\r\n            }\r\n\r\n            toRemove._indexInSceneMaterialArray = -1;\r\n            this.materials.pop();\r\n        }\r\n\r\n        this.onMaterialRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given action manager from this scene.\r\n     * @param toRemove The action manager to remove\r\n     * @returns The index of the removed action manager\r\n     */\r\n    public removeActionManager(toRemove: AbstractActionManager): number {\r\n        var index = this.actionManagers.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.actionManagers.splice(index, 1);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Removes the given texture from this scene.\r\n     * @param toRemove The texture to remove\r\n     * @returns The index of the removed texture\r\n     */\r\n    public removeTexture(toRemove: BaseTexture): number {\r\n        var index = this.textures.indexOf(toRemove);\r\n        if (index !== -1) {\r\n            this.textures.splice(index, 1);\r\n        }\r\n        this.onTextureRemovedObservable.notifyObservers(toRemove);\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Adds the given light to this scene\r\n     * @param newLight The light to add\r\n     */\r\n    public addLight(newLight: Light): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.lights.push(newLight);\r\n        this.sortLightsByPriority();\r\n\r\n        if (!newLight.parent) {\r\n            newLight._addToSceneRootNodes();\r\n        }\r\n\r\n        // Add light to all meshes (To support if the light is removed and then re-added)\r\n        for (var mesh of this.meshes) {\r\n            if (mesh.lightSources.indexOf(newLight) === -1) {\r\n                mesh.lightSources.push(newLight);\r\n                mesh._resyncLightSources();\r\n            }\r\n        }\r\n\r\n        this.onNewLightAddedObservable.notifyObservers(newLight);\r\n    }\r\n\r\n    /**\r\n     * Sorts the list list based on light priorities\r\n     */\r\n    public sortLightsByPriority(): void {\r\n        if (this.requireLightSorting) {\r\n            this.lights.sort(Light.CompareLightsPriority);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given camera to this scene\r\n     * @param newCamera The camera to add\r\n     */\r\n    public addCamera(newCamera: Camera): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        this.cameras.push(newCamera);\r\n        this.onNewCameraAddedObservable.notifyObservers(newCamera);\r\n\r\n        if (!newCamera.parent) {\r\n            newCamera._addToSceneRootNodes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given skeleton to this scene\r\n     * @param newSkeleton The skeleton to add\r\n     */\r\n    public addSkeleton(newSkeleton: Skeleton): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.skeletons.push(newSkeleton);\r\n        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\r\n    }\r\n\r\n    /**\r\n     * Adds the given particle system to this scene\r\n     * @param newParticleSystem The particle system to add\r\n     */\r\n    public addParticleSystem(newParticleSystem: IParticleSystem): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.particleSystems.push(newParticleSystem);\r\n    }\r\n\r\n    /**\r\n     * Adds the given animation to this scene\r\n     * @param newAnimation The animation to add\r\n     */\r\n    public addAnimation(newAnimation: Animation): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.animations.push(newAnimation);\r\n    }\r\n\r\n    /**\r\n     * Adds the given animation group to this scene.\r\n     * @param newAnimationGroup The animation group to add\r\n     */\r\n    public addAnimationGroup(newAnimationGroup: AnimationGroup): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.animationGroups.push(newAnimationGroup);\r\n    }\r\n\r\n    /**\r\n     * Adds the given multi-material to this scene\r\n     * @param newMultiMaterial The multi-material to add\r\n     */\r\n    public addMultiMaterial(newMultiMaterial: MultiMaterial): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.multiMaterials.push(newMultiMaterial);\r\n        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\r\n    }\r\n\r\n    /**\r\n     * Adds the given material to this scene\r\n     * @param newMaterial The material to add\r\n     */\r\n    public addMaterial(newMaterial: Material): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        newMaterial._indexInSceneMaterialArray = this.materials.length;\r\n        this.materials.push(newMaterial);\r\n        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\r\n    }\r\n\r\n    /**\r\n     * Adds the given morph target to this scene\r\n     * @param newMorphTargetManager The morph target to add\r\n     */\r\n    public addMorphTargetManager(newMorphTargetManager: MorphTargetManager): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.morphTargetManagers.push(newMorphTargetManager);\r\n    }\r\n\r\n    /**\r\n     * Adds the given geometry to this scene\r\n     * @param newGeometry The geometry to add\r\n     */\r\n    public addGeometry(newGeometry: Geometry): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n\r\n        if (this.geometriesByUniqueId) {\r\n            this.geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\r\n        }\r\n\r\n        this.geometries.push(newGeometry);\r\n    }\r\n\r\n    /**\r\n     * Adds the given action manager to this scene\r\n     * @param newActionManager The action manager to add\r\n     */\r\n    public addActionManager(newActionManager: AbstractActionManager): void {\r\n        this.actionManagers.push(newActionManager);\r\n    }\r\n\r\n    /**\r\n     * Adds the given texture to this scene.\r\n     * @param newTexture The texture to add\r\n     */\r\n    public addTexture(newTexture: BaseTexture): void {\r\n        if (this._blockEntityCollection) {\r\n            return;\r\n        }\r\n        this.textures.push(newTexture);\r\n        this.onNewTextureAddedObservable.notifyObservers(newTexture);\r\n    }\r\n\r\n    /**\r\n     * Switch active camera\r\n     * @param newCamera defines the new active camera\r\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\r\n     */\r\n    public switchActiveCamera(newCamera: Camera, attachControl = true): void {\r\n        var canvas = this._engine.getInputElement();\r\n\r\n        if (!canvas) {\r\n            return;\r\n        }\r\n\r\n        if (this.activeCamera) {\r\n            this.activeCamera.detachControl();\r\n        }\r\n        this.activeCamera = newCamera;\r\n        if (attachControl) {\r\n            newCamera.attachControl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * sets the active camera of the scene using its ID\r\n     * @param id defines the camera's ID\r\n     * @return the new active camera or null if none found.\r\n     */\r\n    public setActiveCameraByID(id: string): Nullable<Camera> {\r\n        var camera = this.getCameraByID(id);\r\n\r\n        if (camera) {\r\n            this.activeCamera = camera;\r\n            return camera;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * sets the active camera of the scene using its name\r\n     * @param name defines the camera's name\r\n     * @returns the new active camera or null if none found.\r\n     */\r\n    public setActiveCameraByName(name: string): Nullable<Camera> {\r\n        var camera = this.getCameraByName(name);\r\n\r\n        if (camera) {\r\n            this.activeCamera = camera;\r\n            return camera;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get an animation group using its name\r\n     * @param name defines the material's name\r\n     * @return the animation group or null if none found.\r\n     */\r\n    public getAnimationGroupByName(name: string): Nullable<AnimationGroup> {\r\n        for (var index = 0; index < this.animationGroups.length; index++) {\r\n            if (this.animationGroups[index].name === name) {\r\n                return this.animationGroups[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a material using its unique id\r\n     * @param uniqueId defines the material's unique id\r\n     * @return the material or null if none found.\r\n     */\r\n    public getMaterialByUniqueID(uniqueId: number): Nullable<Material> {\r\n        for (var index = 0; index < this.materials.length; index++) {\r\n            if (this.materials[index].uniqueId === uniqueId) {\r\n                return this.materials[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get a material using its id\r\n     * @param id defines the material's ID\r\n     * @return the material or null if none found.\r\n     */\r\n    public getMaterialByID(id: string): Nullable<Material> {\r\n        for (var index = 0; index < this.materials.length; index++) {\r\n            if (this.materials[index].id === id) {\r\n                return this.materials[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last added material using a given id\r\n     * @param id defines the material's ID\r\n     * @return the last material with the given id or null if none found.\r\n     */\r\n    public getLastMaterialByID(id: string): Nullable<Material> {\r\n        for (var index = this.materials.length - 1; index >= 0; index--) {\r\n            if (this.materials[index].id === id) {\r\n                return this.materials[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a material using its name\r\n     * @param name defines the material's name\r\n     * @return the material or null if none found.\r\n     */\r\n    public getMaterialByName(name: string): Nullable<Material> {\r\n        for (var index = 0; index < this.materials.length; index++) {\r\n            if (this.materials[index].name === name) {\r\n                return this.materials[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get a texture using its unique id\r\n     * @param uniqueId defines the texture's unique id\r\n     * @return the texture or null if none found.\r\n     */\r\n    public getTextureByUniqueID(uniqueId: number): Nullable<BaseTexture> {\r\n        for (var index = 0; index < this.textures.length; index++) {\r\n            if (this.textures[index].uniqueId === uniqueId) {\r\n                return this.textures[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its id\r\n     * @param id defines the id to look for\r\n     * @returns the camera or null if not found\r\n     */\r\n    public getCameraByID(id: string): Nullable<Camera> {\r\n        for (var index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].id === id) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its unique id\r\n     * @param uniqueId defines the unique id to look for\r\n     * @returns the camera or null if not found\r\n     */\r\n    public getCameraByUniqueID(uniqueId: number): Nullable<Camera> {\r\n        for (var index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].uniqueId === uniqueId) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a camera using its name\r\n     * @param name defines the camera's name\r\n     * @return the camera or null if none found.\r\n     */\r\n    public getCameraByName(name: string): Nullable<Camera> {\r\n        for (var index = 0; index < this.cameras.length; index++) {\r\n            if (this.cameras[index].name === name) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a bone using its id\r\n     * @param id defines the bone's id\r\n     * @return the bone or null if not found\r\n     */\r\n    public getBoneByID(id: string): Nullable<Bone> {\r\n        for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\r\n            var skeleton = this.skeletons[skeletonIndex];\r\n            for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\r\n                if (skeleton.bones[boneIndex].id === id) {\r\n                    return skeleton.bones[boneIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * Gets a bone using its id\r\n    * @param name defines the bone's name\r\n    * @return the bone or null if not found\r\n    */\r\n    public getBoneByName(name: string): Nullable<Bone> {\r\n        for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\r\n            var skeleton = this.skeletons[skeletonIndex];\r\n            for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\r\n                if (skeleton.bones[boneIndex].name === name) {\r\n                    return skeleton.bones[boneIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its name\r\n     * @param name defines the the light's name\r\n     * @return the light or null if none found.\r\n     */\r\n    public getLightByName(name: string): Nullable<Light> {\r\n        for (var index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].name === name) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its id\r\n     * @param id defines the light's id\r\n     * @return the light or null if none found.\r\n     */\r\n    public getLightByID(id: string): Nullable<Light> {\r\n        for (var index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].id === id) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a light node using its scene-generated unique ID\r\n     * @param uniqueId defines the light's unique id\r\n     * @return the light or null if none found.\r\n     */\r\n    public getLightByUniqueID(uniqueId: number): Nullable<Light> {\r\n        for (var index = 0; index < this.lights.length; index++) {\r\n            if (this.lights[index].uniqueId === uniqueId) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a particle system by id\r\n     * @param id defines the particle system id\r\n     * @return the corresponding system or null if none found\r\n     */\r\n    public getParticleSystemByID(id: string): Nullable<IParticleSystem> {\r\n        for (var index = 0; index < this.particleSystems.length; index++) {\r\n            if (this.particleSystems[index].id === id) {\r\n                return this.particleSystems[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a geometry using its ID\r\n     * @param id defines the geometry's id\r\n     * @return the geometry or null if none found.\r\n     */\r\n    public getGeometryByID(id: string): Nullable<Geometry> {\r\n        for (var index = 0; index < this.geometries.length; index++) {\r\n            if (this.geometries[index].id === id) {\r\n                return this.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _getGeometryByUniqueID(uniqueId: number): Nullable<Geometry> {\r\n        if (this.geometriesByUniqueId) {\r\n            const index = this.geometriesByUniqueId[uniqueId];\r\n            if (index !== undefined) {\r\n                return this.geometries[index];\r\n            }\r\n        }\r\n        else {\r\n            for (var index = 0; index < this.geometries.length; index++) {\r\n                if (this.geometries[index].uniqueId === uniqueId) {\r\n                    return this.geometries[index];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Add a new geometry to this scene\r\n     * @param geometry defines the geometry to be added to the scene.\r\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\r\n     * @return a boolean defining if the geometry was added or not\r\n     */\r\n    public pushGeometry(geometry: Geometry, force?: boolean): boolean {\r\n        if (!force && this._getGeometryByUniqueID(geometry.uniqueId)) {\r\n            return false;\r\n        }\r\n\r\n        this.addGeometry(geometry);\r\n\r\n        this.onNewGeometryAddedObservable.notifyObservers(geometry);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes an existing geometry\r\n     * @param geometry defines the geometry to be removed from the scene\r\n     * @return a boolean defining if the geometry was removed or not\r\n     */\r\n    public removeGeometry(geometry: Geometry): boolean {\r\n        let index;\r\n        if (this.geometriesByUniqueId) {\r\n            index = this.geometriesByUniqueId[geometry.uniqueId];\r\n            if (index === undefined) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            index = this.geometries.indexOf(geometry);\r\n            if (index < 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (index !== this.geometries.length - 1) {\r\n            const lastGeometry = this.geometries[this.geometries.length - 1];\r\n            if (lastGeometry) {\r\n                this.geometries[index] = lastGeometry;\r\n                if (this.geometriesByUniqueId) {\r\n                    this.geometriesByUniqueId[lastGeometry.uniqueId] = index;\r\n                    this.geometriesByUniqueId[geometry.uniqueId] = undefined;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.geometries.pop();\r\n\r\n        this.onGeometryRemovedObservable.notifyObservers(geometry);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of geometries attached to the scene\r\n     * @returns an array of Geometry\r\n     */\r\n    public getGeometries(): Geometry[] {\r\n        return this.geometries;\r\n    }\r\n\r\n    /**\r\n     * Gets the first added mesh found of a given ID\r\n     * @param id defines the id to search for\r\n     * @return the mesh found or null if not found at all\r\n     */\r\n    public getMeshByID(id: string): Nullable<AbstractMesh> {\r\n        for (var index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of meshes using their id\r\n     * @param id defines the id to search for\r\n     * @returns a list of meshes\r\n     */\r\n    public getMeshesByID(id: string): Array<AbstractMesh> {\r\n        return this.meshes.filter(function(m) {\r\n            return m.id === id;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the first added transform node found of a given ID\r\n     * @param id defines the id to search for\r\n     * @return the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeByID(id: string): Nullable<TransformNode> {\r\n        for (var index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].id === id) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a transform node with its auto-generated unique id\r\n     * @param uniqueId efines the unique id to search for\r\n     * @return the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeByUniqueID(uniqueId: number): Nullable<TransformNode> {\r\n        for (var index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].uniqueId === uniqueId) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of transform nodes using their id\r\n     * @param id defines the id to search for\r\n     * @returns a list of transform nodes\r\n     */\r\n    public getTransformNodesByID(id: string): Array<TransformNode> {\r\n        return this.transformNodes.filter(function(m) {\r\n            return m.id === id;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a mesh with its auto-generated unique id\r\n     * @param uniqueId defines the unique id to search for\r\n     * @return the found mesh or null if not found at all.\r\n     */\r\n    public getMeshByUniqueID(uniqueId: number): Nullable<AbstractMesh> {\r\n        for (var index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].uniqueId === uniqueId) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last added mesh using a given id\r\n     * @param id defines the id to search for\r\n     * @return the found mesh or null if not found at all.\r\n     */\r\n    public getLastMeshByID(id: string): Nullable<AbstractMesh> {\r\n        for (var index = this.meshes.length - 1; index >= 0; index--) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a the last added node (Mesh, Camera, Light) using a given id\r\n     * @param id defines the id to search for\r\n     * @return the found node or null if not found at all\r\n     */\r\n    public getLastEntryByID(id: string): Nullable<Node> {\r\n        var index: number;\r\n        for (index = this.meshes.length - 1; index >= 0; index--) {\r\n            if (this.meshes[index].id === id) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.transformNodes.length - 1; index >= 0; index--) {\r\n            if (this.transformNodes[index].id === id) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.cameras.length - 1; index >= 0; index--) {\r\n            if (this.cameras[index].id === id) {\r\n                return this.cameras[index];\r\n            }\r\n        }\r\n\r\n        for (index = this.lights.length - 1; index >= 0; index--) {\r\n            if (this.lights[index].id === id) {\r\n                return this.lights[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a node (Mesh, Camera, Light) using a given id\r\n     * @param id defines the id to search for\r\n     * @return the found node or null if not found at all\r\n     */\r\n    public getNodeByID(id: string): Nullable<Node> {\r\n        const mesh = this.getMeshByID(id);\r\n        if (mesh) {\r\n            return mesh;\r\n        }\r\n\r\n        const transformNode = this.getTransformNodeByID(id);\r\n        if (transformNode) {\r\n            return transformNode;\r\n        }\r\n\r\n        const light = this.getLightByID(id);\r\n        if (light) {\r\n            return light;\r\n        }\r\n\r\n        const camera = this.getCameraByID(id);\r\n        if (camera) {\r\n            return camera;\r\n        }\r\n\r\n        const bone = this.getBoneByID(id);\r\n        if (bone) {\r\n            return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a node (Mesh, Camera, Light) using a given name\r\n     * @param name defines the name to search for\r\n     * @return the found node or null if not found at all.\r\n     */\r\n    public getNodeByName(name: string): Nullable<Node> {\r\n        const mesh = this.getMeshByName(name);\r\n        if (mesh) {\r\n            return mesh;\r\n        }\r\n\r\n        const transformNode = this.getTransformNodeByName(name);\r\n        if (transformNode) {\r\n            return transformNode;\r\n        }\r\n\r\n        const light = this.getLightByName(name);\r\n        if (light) {\r\n            return light;\r\n        }\r\n\r\n        const camera = this.getCameraByName(name);\r\n        if (camera) {\r\n            return camera;\r\n        }\r\n\r\n        const bone = this.getBoneByName(name);\r\n        if (bone) {\r\n            return bone;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a mesh using a given name\r\n     * @param name defines the name to search for\r\n     * @return the found mesh or null if not found at all.\r\n     */\r\n    public getMeshByName(name: string): Nullable<AbstractMesh> {\r\n        for (var index = 0; index < this.meshes.length; index++) {\r\n            if (this.meshes[index].name === name) {\r\n                return this.meshes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a transform node using a given name\r\n     * @param name defines the name to search for\r\n     * @return the found transform node or null if not found at all.\r\n     */\r\n    public getTransformNodeByName(name: string): Nullable<TransformNode> {\r\n        for (var index = 0; index < this.transformNodes.length; index++) {\r\n            if (this.transformNodes[index].name === name) {\r\n                return this.transformNodes[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given id (if many are found, this function will pick the last one)\r\n     * @param id defines the id to search for\r\n     * @return the found skeleton or null if not found at all.\r\n     */\r\n    public getLastSkeletonByID(id: string): Nullable<Skeleton> {\r\n        for (var index = this.skeletons.length - 1; index >= 0; index--) {\r\n            if (this.skeletons[index].id === id) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given auto generated unique id\r\n     * @param  uniqueId defines the unique id to search for\r\n     * @return the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonByUniqueId(uniqueId: number): Nullable<Skeleton> {\r\n        for (var index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].uniqueId === uniqueId) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\r\n     * @param id defines the id to search for\r\n     * @return the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonById(id: string): Nullable<Skeleton> {\r\n        for (var index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].id === id) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a skeleton using a given name\r\n     * @param name defines the name to search for\r\n     * @return the found skeleton or null if not found at all.\r\n     */\r\n    public getSkeletonByName(name: string): Nullable<Skeleton> {\r\n        for (var index = 0; index < this.skeletons.length; index++) {\r\n            if (this.skeletons[index].name === name) {\r\n                return this.skeletons[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\r\n     * @param id defines the id to search for\r\n     * @return the found morph target manager or null if not found at all.\r\n     */\r\n    public getMorphTargetManagerById(id: number): Nullable<MorphTargetManager> {\r\n        for (var index = 0; index < this.morphTargetManagers.length; index++) {\r\n            if (this.morphTargetManagers[index].uniqueId === id) {\r\n                return this.morphTargetManagers[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\r\n     * @param id defines the id to search for\r\n     * @return the found morph target or null if not found at all.\r\n     */\r\n    public getMorphTargetById(id: string): Nullable<MorphTarget> {\r\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\r\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\r\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\r\n                const target = morphTargetManager.getTarget(index);\r\n                if (target.id === id) {\r\n                    return target;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\r\n     * @param name defines the name to search for\r\n     * @return the found morph target or null if not found at all.\r\n     */\r\n    public getMorphTargetByName(name: string): Nullable<MorphTarget> {\r\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\r\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\r\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\r\n                const target = morphTargetManager.getTarget(index);\r\n                if (target.name === name) {\r\n                    return target;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\r\n     * @param name defines the name to search for\r\n     * @return the found post process or null if not found at all.\r\n     */\r\n    public getPostProcessByName(name: string): Nullable<PostProcess> {\r\n        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\r\n            const postProcess = this.postProcesses[postProcessIndex];\r\n            if (postProcess.name === name) {\r\n                return postProcess;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given mesh is active\r\n     * @param mesh defines the mesh to look for\r\n     * @returns true if the mesh is in the active list\r\n     */\r\n    public isActiveMesh(mesh: AbstractMesh): boolean {\r\n        return (this._activeMeshes.indexOf(mesh) !== -1);\r\n    }\r\n\r\n    /**\r\n     * Return a unique id as a string which can serve as an identifier for the scene\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = Tools.RandomId();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /**\r\n     * Add an externaly attached data from its key.\r\n     * This method call will fail and return false, if such key already exists.\r\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\r\n     * @param key the unique key that identifies the data\r\n     * @param data the data object to associate to the key for this Engine instance\r\n     * @return true if no such key were already present and the data was added successfully, false otherwise\r\n     */\r\n    public addExternalData<T>(key: string, data: T): boolean {\r\n        if (!this._externalData) {\r\n            this._externalData = new StringDictionary<Object>();\r\n        }\r\n        return this._externalData.add(key, data);\r\n    }\r\n\r\n    /**\r\n     * Get an externaly attached data from its key\r\n     * @param key the unique key that identifies the data\r\n     * @return the associated data, if present (can be null), or undefined if not present\r\n     */\r\n    public getExternalData<T>(key: string): Nullable<T> {\r\n        if (!this._externalData) {\r\n            return null;\r\n        }\r\n        return <T>this._externalData.get(key);\r\n    }\r\n\r\n    /**\r\n     * Get an externaly attached data from its key, create it using a factory if it's not already present\r\n     * @param key the unique key that identifies the data\r\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\r\n     * @return the associated data, can be null if the factory returned null.\r\n     */\r\n    public getOrAddExternalDataWithFactory<T>(key: string, factory: (k: string) => T): T {\r\n        if (!this._externalData) {\r\n            this._externalData = new StringDictionary<Object>();\r\n        }\r\n        return <T>this._externalData.getOrAddWithFactory(key, factory);\r\n    }\r\n\r\n    /**\r\n     * Remove an externaly attached data from the Engine instance\r\n     * @param key the unique key that identifies the data\r\n     * @return true if the data was successfully removed, false if it doesn't exist\r\n     */\r\n    public removeExternalData(key: string): boolean {\r\n        return this._externalData.remove(key);\r\n    }\r\n\r\n    private _evaluateSubMesh(subMesh: SubMesh, mesh: AbstractMesh, initialMesh: AbstractMesh): void {\r\n        if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\r\n            for (let step of this._evaluateSubMeshStage) {\r\n                step.action(mesh, subMesh);\r\n            }\r\n\r\n            const material = subMesh.getMaterial();\r\n            if (material !== null && material !== undefined) {\r\n                // Render targets\r\n                if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\r\n                    if (this._processedMaterials.indexOf(material) === -1) {\r\n                        this._processedMaterials.push(material);\r\n\r\n                        this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures!());\r\n                    }\r\n                }\r\n\r\n                // Dispatch\r\n                this._renderingManager.dispatch(subMesh, mesh, material);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the processed materials smart array preventing retention point in material dispose.\r\n     */\r\n    public freeProcessedMaterials(): void {\r\n        this._processedMaterials.dispose();\r\n    }\r\n\r\n    private _preventFreeActiveMeshesAndRenderingGroups = false;\r\n\r\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\r\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\r\n     * when disposing several meshes in a row or a hierarchy of meshes.\r\n     * When used, it is the responsability of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\r\n     */\r\n    public get blockfreeActiveMeshesAndRenderingGroups(): boolean {\r\n        return this._preventFreeActiveMeshesAndRenderingGroups;\r\n    }\r\n\r\n    public set blockfreeActiveMeshesAndRenderingGroups(value: boolean) {\r\n        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this.freeActiveMeshes();\r\n            this.freeRenderingGroups();\r\n        }\r\n\r\n        this._preventFreeActiveMeshesAndRenderingGroups = value;\r\n    }\r\n\r\n    /**\r\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\r\n     */\r\n    public freeActiveMeshes(): void {\r\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\r\n            return;\r\n        }\r\n\r\n        this._activeMeshes.dispose();\r\n        if (this.activeCamera && this.activeCamera._activeMeshes) {\r\n            this.activeCamera._activeMeshes.dispose();\r\n        }\r\n        if (this.activeCameras) {\r\n            for (let i = 0; i < this.activeCameras.length; i++) {\r\n                let activeCamera = this.activeCameras[i];\r\n                if (activeCamera && activeCamera._activeMeshes) {\r\n                    activeCamera._activeMeshes.dispose();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\r\n            return;\r\n        }\r\n\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n        if (this.textures) {\r\n            for (let i = 0; i < this.textures.length; i++) {\r\n                let texture = this.textures[i];\r\n                if (texture && (<RenderTargetTexture>texture).renderList) {\r\n                    (<RenderTargetTexture>texture).freeRenderingGroups();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _isInIntermediateRendering(): boolean {\r\n        return this._intermediateRendering;\r\n    }\r\n\r\n    /**\r\n     * Lambda returning the list of potentially active meshes.\r\n     */\r\n    public getActiveMeshCandidates: () => ISmartArrayLike<AbstractMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially active sub meshes.\r\n     */\r\n    public getActiveSubMeshCandidates: (mesh: AbstractMesh) => ISmartArrayLike<SubMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially intersecting sub meshes.\r\n     */\r\n    public getIntersectingSubMeshCandidates: (mesh: AbstractMesh, localRay: Ray) => ISmartArrayLike<SubMesh>;\r\n\r\n    /**\r\n     * Lambda returning the list of potentially colliding sub meshes.\r\n     */\r\n    public getCollidingSubMeshCandidates: (mesh: AbstractMesh, collider: Collider) => ISmartArrayLike<SubMesh>;\r\n\r\n    /** @hidden */\r\n    public _activeMeshesFrozen = false;\r\n    private _skipEvaluateActiveMeshesCompletely = false;\r\n\r\n    /**\r\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\r\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\r\n     * @param onSuccess optional success callback\r\n     * @param onError optional error callback\r\n     * @returns the current scene\r\n     */\r\n    public freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess?: () => void, onError?: (message: string) => void): Scene {\r\n        this.executeWhenReady(() => {\r\n            if (!this.activeCamera) {\r\n                onError && onError('No active camera found');\r\n                return;\r\n            }\r\n\r\n            if (!this._frustumPlanes) {\r\n                this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix());\r\n            }\r\n\r\n            this._evaluateActiveMeshes();\r\n            this._activeMeshesFrozen = true;\r\n            this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\r\n\r\n            for (var index = 0; index < this._activeMeshes.length; index++) {\r\n                this._activeMeshes.data[index]._freeze();\r\n            }\r\n            onSuccess && onSuccess();\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this function to restart evaluating active meshes on every frame\r\n     * @returns the current scene\r\n     */\r\n    public unfreezeActiveMeshes(): Scene {\r\n\r\n        for (var index = 0; index < this.meshes.length; index++) {\r\n            const mesh = this.meshes[index];\r\n            if (mesh._internalAbstractMeshDataInfo) {\r\n                mesh._internalAbstractMeshDataInfo._isActive = false;\r\n            }\r\n        }\r\n\r\n        for (var index = 0; index < this._activeMeshes.length; index++) {\r\n            this._activeMeshes.data[index]._unFreeze();\r\n        }\r\n\r\n        this._activeMeshesFrozen = false;\r\n        return this;\r\n    }\r\n\r\n    private _evaluateActiveMeshes(): void {\r\n        if (this._activeMeshesFrozen && this._activeMeshes.length) {\r\n\r\n            if (!this._skipEvaluateActiveMeshesCompletely) {\r\n                const len = this._activeMeshes.length;\r\n                for (let i = 0; i < len; i++) {\r\n                    let mesh = this._activeMeshes.data[i];\r\n                    mesh.computeWorldMatrix();\r\n                }\r\n            }\r\n\r\n            if (this._activeParticleSystems) {\r\n                const psLength = this._activeParticleSystems.length;\r\n                for (let i = 0; i < psLength; i++) {\r\n                    this._activeParticleSystems.data[i].animate();\r\n                }\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (!this.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\r\n\r\n        this.activeCamera._activeMeshes.reset();\r\n        this._activeMeshes.reset();\r\n        this._renderingManager.reset();\r\n        this._processedMaterials.reset();\r\n        this._activeParticleSystems.reset();\r\n        this._activeSkeletons.reset();\r\n        this._softwareSkinnedMeshes.reset();\r\n        for (let step of this._beforeEvaluateActiveMeshStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Determine mesh candidates\r\n        const meshes = this.getActiveMeshCandidates();\r\n\r\n        // Check each mesh\r\n        const len = meshes.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const mesh = meshes.data[i];\r\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\r\n            if (mesh.isBlocked) {\r\n                continue;\r\n            }\r\n\r\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\r\n\r\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {\r\n                continue;\r\n            }\r\n\r\n            mesh.computeWorldMatrix();\r\n\r\n            // Intersections\r\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\r\n                this._meshesForIntersections.pushNoDuplicate(mesh);\r\n            }\r\n\r\n            // Switch to current LOD\r\n            let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\r\n            mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\r\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\r\n            if (meshToRender === undefined || meshToRender === null) {\r\n                continue;\r\n            }\r\n\r\n            // Compute world matrix if LOD is billboard\r\n            if (meshToRender !== mesh && meshToRender.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n                meshToRender.computeWorldMatrix();\r\n            }\r\n\r\n            mesh._preActivate();\r\n\r\n            if (mesh.isVisible && mesh.visibility > 0 && ((mesh.layerMask & this.activeCamera.layerMask) !== 0) && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\r\n                this._activeMeshes.push(mesh);\r\n                this.activeCamera._activeMeshes.push(mesh);\r\n\r\n                if (meshToRender !== mesh) {\r\n                    meshToRender._activate(this._renderId, false);\r\n                }\r\n\r\n                for (let step of this._preActiveMeshStage) {\r\n                    step.action(mesh);\r\n                }\r\n\r\n                if (mesh._activate(this._renderId, false)) {\r\n                    if (!mesh.isAnInstance) {\r\n                        meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\r\n                    } else {\r\n                        if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                            meshToRender = mesh;\r\n                        }\r\n                    }\r\n                    meshToRender._internalAbstractMeshDataInfo._isActive = true;\r\n                    this._activeMesh(mesh, meshToRender);\r\n                }\r\n\r\n                mesh._postActivate();\r\n            }\r\n        }\r\n\r\n        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\r\n\r\n        // Particle systems\r\n        if (this.particlesEnabled) {\r\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\r\n            for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\r\n                var particleSystem = this.particleSystems[particleIndex];\r\n\r\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\r\n                    continue;\r\n                }\r\n\r\n                let emitter = <any>particleSystem.emitter;\r\n                if (!emitter.position || emitter.isEnabled()) {\r\n                    this._activeParticleSystems.push(particleSystem);\r\n                    particleSystem.animate();\r\n                    this._renderingManager.dispatchParticles(particleSystem);\r\n                }\r\n            }\r\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    private _activeMesh(sourceMesh: AbstractMesh, mesh: AbstractMesh): void {\r\n        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\r\n            if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\r\n                mesh.skeleton.prepare();\r\n            }\r\n\r\n            if (!mesh.computeBonesUsingShaders) {\r\n                this._softwareSkinnedMeshes.pushNoDuplicate(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        if (\r\n            mesh !== undefined && mesh !== null\r\n            && mesh.subMeshes !== undefined && mesh.subMeshes !== null && mesh.subMeshes.length > 0\r\n        ) {\r\n            const subMeshes = this.getActiveSubMeshCandidates(mesh);\r\n            const len = subMeshes.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const subMesh = subMeshes.data[i];\r\n                this._evaluateSubMesh(subMesh, mesh, sourceMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transform matrix to update from the current active camera\r\n     * @param force defines a boolean used to force the update even if cache is up to date\r\n     */\r\n    public updateTransformMatrix(force?: boolean): void {\r\n        if (!this.activeCamera) {\r\n            return;\r\n        }\r\n        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\r\n    }\r\n\r\n    private _bindFrameBuffer() {\r\n        if (this.activeCamera && this.activeCamera._multiviewTexture) {\r\n            this.activeCamera._multiviewTexture._bindFrameBuffer();\r\n        } else if (this.activeCamera && this.activeCamera.outputRenderTarget) {\r\n            var useMultiview = this.getEngine().getCaps().multiview && this.activeCamera.outputRenderTarget && this.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n            if (useMultiview) {\r\n                this.activeCamera.outputRenderTarget._bindFrameBuffer();\r\n            } else {\r\n                var internalTexture = this.activeCamera.outputRenderTarget.getInternalTexture();\r\n                if (internalTexture) {\r\n                    this.getEngine().bindFramebuffer(internalTexture);\r\n                } else {\r\n                    Logger.Error(\"Camera contains invalid customDefaultRenderTarget\");\r\n                }\r\n            }\r\n        } else {\r\n            this.getEngine().restoreDefaultFramebuffer(); // Restore back buffer if needed\r\n        }\r\n    }\r\n    /** @hidden */\r\n    public _allowPostProcessClearColor = true;\r\n    /** @hidden */\r\n    public _renderForCamera(camera: Camera, rigParent?: Camera): void {\r\n        if (camera && camera._skipRendering) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._engine;\r\n\r\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\r\n        this._activeCamera = camera;\r\n\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        // Viewport\r\n        engine.setViewport(this.activeCamera.viewport);\r\n\r\n        // Camera\r\n        this.resetCachedMaterial();\r\n        this._renderId++;\r\n\r\n        var useMultiview = this.getEngine().getCaps().multiview && camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1;\r\n        if (useMultiview) {\r\n            this.setTransformMatrix(camera._rigCameras[0].getViewMatrix(), camera._rigCameras[0].getProjectionMatrix(), camera._rigCameras[1].getViewMatrix(), camera._rigCameras[1].getProjectionMatrix());\r\n        } else {\r\n            this.updateTransformMatrix();\r\n        }\r\n\r\n        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\r\n\r\n        // Meshes\r\n        this._evaluateActiveMeshes();\r\n\r\n        // Software skinning\r\n        for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\r\n            var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\r\n\r\n            mesh.applySkeleton(<Skeleton>mesh.skeleton);\r\n        }\r\n\r\n        // Render targets\r\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\r\n            this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\r\n        }\r\n\r\n        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\r\n            this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\r\n        }\r\n\r\n        // Collects render targets from external components.\r\n        for (let step of this._gatherActiveCameraRenderTargetsStage) {\r\n            step.action(this._renderTargets);\r\n        }\r\n\r\n        let needRebind = false;\r\n        if (this.renderTargetsEnabled) {\r\n            this._intermediateRendering = true;\r\n\r\n            if (this._renderTargets.length > 0) {\r\n                Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\r\n                for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\r\n                    let renderTarget = this._renderTargets.data[renderIndex];\r\n                    if (renderTarget._shouldRender()) {\r\n                        this._renderId++;\r\n                        var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\r\n                        renderTarget.render((<boolean>hasSpecialRenderTargetCamera), this.dumpNextRenderTargets);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n                Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\r\n\r\n                this._renderId++;\r\n            }\r\n\r\n            for (let step of this._cameraDrawRenderTargetStage) {\r\n                needRebind = step.action(this.activeCamera) || needRebind;\r\n            }\r\n\r\n            this._intermediateRendering = false;\r\n\r\n            // Need to bind if sub-camera has an outputRenderTarget eg. for webXR\r\n            if (this.activeCamera && this.activeCamera.outputRenderTarget) {\r\n                needRebind = true;\r\n            }\r\n        }\r\n\r\n        // Restore framebuffer after rendering to targets\r\n        if (needRebind && !this.prePass) {\r\n            this._bindFrameBuffer();\r\n        }\r\n\r\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        // Prepare Frame\r\n        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\r\n            this.postProcessManager._prepareFrame();\r\n        }\r\n\r\n        // Before Camera Draw\r\n        for (let step of this._beforeCameraDrawStage) {\r\n            step.action(this.activeCamera);\r\n        }\r\n\r\n        // Render\r\n        this.onBeforeDrawPhaseObservable.notifyObservers(this);\r\n        this._renderingManager.render(null, null, true, true);\r\n        this.onAfterDrawPhaseObservable.notifyObservers(this);\r\n\r\n        // After Camera Draw\r\n        for (let step of this._afterCameraDrawStage) {\r\n            step.action(this.activeCamera);\r\n        }\r\n\r\n        // Finalize frame\r\n        if (this.postProcessManager && !camera._multiviewTexture) {\r\n            // if the camera has an output render target, render the post process to the render target\r\n            const texture = camera.outputRenderTarget ? camera.outputRenderTarget.getInternalTexture()! : undefined;\r\n            this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\r\n        }\r\n\r\n        // Reset some special arrays\r\n        this._renderTargets.reset();\r\n\r\n        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\r\n    }\r\n\r\n    private _processSubCameras(camera: Camera): void {\r\n        if (camera.cameraRigMode === Camera.RIG_MODE_NONE || (camera.outputRenderTarget && camera.outputRenderTarget.getViewCount() > 1 && this.getEngine().getCaps().multiview)) {\r\n            this._renderForCamera(camera);\r\n            this.onAfterRenderCameraObservable.notifyObservers(camera);\r\n            return;\r\n        }\r\n\r\n        if (camera._useMultiviewToSingleView) {\r\n            this._renderMultiviewToSingleView(camera);\r\n        } else {\r\n            // rig cameras\r\n            for (var index = 0; index < camera._rigCameras.length; index++) {\r\n                this._renderForCamera(camera._rigCameras[index], camera);\r\n            }\r\n        }\r\n\r\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\r\n        this._activeCamera = camera;\r\n        this.setTransformMatrix(this._activeCamera.getViewMatrix(), this._activeCamera.getProjectionMatrix());\r\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\r\n    }\r\n\r\n    private _checkIntersections(): void {\r\n        for (var index = 0; index < this._meshesForIntersections.length; index++) {\r\n            var sourceMesh = this._meshesForIntersections.data[index];\r\n\r\n            if (!sourceMesh.actionManager) {\r\n                continue;\r\n            }\r\n\r\n            for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\r\n                var action = sourceMesh.actionManager.actions[actionIndex];\r\n\r\n                if (action.trigger === 12 || action.trigger === 13) {\r\n                    var parameters = action.getTriggerParameter();\r\n                    var otherMesh = parameters instanceof AbstractMesh ? parameters : parameters.mesh;\r\n\r\n                    var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\r\n                    var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\r\n\r\n                    if (areIntersecting && currentIntersectionInProgress === -1) {\r\n                        if (action.trigger === 12) {\r\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\r\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\r\n                        } else if (action.trigger === 13) {\r\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\r\n                        }\r\n                    } else if (!areIntersecting && currentIntersectionInProgress > -1) {\r\n                        //They intersected, and now they don't.\r\n\r\n                        //is this trigger an exit trigger? execute an event.\r\n                        if (action.trigger === 13) {\r\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\r\n                        }\r\n\r\n                        //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\r\n                        if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {\r\n                            var parameterMesh = parameter instanceof AbstractMesh ? parameter : parameter.mesh;\r\n                            return otherMesh === parameterMesh;\r\n                        }) || action.trigger === 13) {\r\n                            sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _advancePhysicsEngineStep(step: number) {\r\n        // Do nothing. Code will be replaced if physics engine component is referenced\r\n    }\r\n\r\n    /**\r\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\r\n     */\r\n    public getDeterministicFrameTime: () => number = () => {\r\n        return this._engine.getTimeStep();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _animate(): void {\r\n        // Nothing to do as long as Animatable have not been imported.\r\n    }\r\n\r\n    /** Execute all animations (for a frame) */\r\n    public animate() {\r\n        if (this._engine.isDeterministicLockStep()) {\r\n            var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\r\n\r\n            let defaultFrameTime = this._engine.getTimeStep();\r\n            var defaultFPS = (1000.0 / defaultFrameTime) / 1000.0;\r\n\r\n            let stepsTaken = 0;\r\n\r\n            var maxSubSteps = this._engine.getLockstepMaxSteps();\r\n\r\n            var internalSteps = Math.floor(deltaTime / defaultFrameTime);\r\n            internalSteps = Math.min(internalSteps, maxSubSteps);\r\n\r\n            while (deltaTime > 0 && stepsTaken < internalSteps) {\r\n                this.onBeforeStepObservable.notifyObservers(this);\r\n\r\n                // Animations\r\n                this._animationRatio = defaultFrameTime * defaultFPS;\r\n                this._animate();\r\n                this.onAfterAnimationsObservable.notifyObservers(this);\r\n\r\n                // Physics\r\n                if (this.physicsEnabled) {\r\n                    this._advancePhysicsEngineStep(defaultFrameTime);\r\n                }\r\n\r\n                this.onAfterStepObservable.notifyObservers(this);\r\n                this._currentStepId++;\r\n\r\n                stepsTaken++;\r\n                deltaTime -= defaultFrameTime;\r\n\r\n            }\r\n\r\n            this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\r\n\r\n        }\r\n        else {\r\n            // Animations\r\n            var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\r\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\r\n            this._animate();\r\n            this.onAfterAnimationsObservable.notifyObservers(this);\r\n\r\n            // Physics\r\n            if (this.physicsEnabled) {\r\n                this._advancePhysicsEngineStep(deltaTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Render the scene\r\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\r\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\r\n     */\r\n    public render(updateCameras = true, ignoreAnimations = false): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === -1) {\r\n            this._checkIsReady();\r\n        }\r\n\r\n        this._frameId++;\r\n\r\n        // Register components that have been associated lately to the scene.\r\n        this._registerTransientComponents();\r\n\r\n        this._activeParticles.fetchNewFrame();\r\n        this._totalVertices.fetchNewFrame();\r\n        this._activeIndices.fetchNewFrame();\r\n        this._activeBones.fetchNewFrame();\r\n        this._meshesForIntersections.reset();\r\n        this.resetCachedMaterial();\r\n\r\n        this.onBeforeAnimationsObservable.notifyObservers(this);\r\n\r\n        // Actions\r\n        if (this.actionManager) {\r\n            this.actionManager.processTrigger(11);\r\n        }\r\n\r\n        // Animations\r\n        if (!ignoreAnimations) {\r\n            this.animate();\r\n        }\r\n\r\n        // Before camera update steps\r\n        for (let step of this._beforeCameraUpdateStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Update Cameras\r\n        if (updateCameras) {\r\n            if (this.activeCameras && this.activeCameras.length > 0) {\r\n                for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\r\n                    let camera = this.activeCameras[cameraIndex];\r\n                    camera.update();\r\n                    if (camera.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n                        // rig cameras\r\n                        for (var index = 0; index < camera._rigCameras.length; index++) {\r\n                            camera._rigCameras[index].update();\r\n                        }\r\n                    }\r\n                }\r\n            } else if (this.activeCamera) {\r\n                this.activeCamera.update();\r\n                if (this.activeCamera.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n                    // rig cameras\r\n                    for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {\r\n                        this.activeCamera._rigCameras[index].update();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Before render\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Customs render targets\r\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\r\n        var engine = this.getEngine();\r\n        var currentActiveCamera = this.activeCamera;\r\n        if (this.renderTargetsEnabled) {\r\n            Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\r\n            this._intermediateRendering = true;\r\n            for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\r\n                var renderTarget = this.customRenderTargets[customIndex];\r\n                if (renderTarget._shouldRender()) {\r\n                    this._renderId++;\r\n\r\n                    this.activeCamera = renderTarget.activeCamera || this.activeCamera;\r\n\r\n                    if (!this.activeCamera) {\r\n                        throw new Error(\"Active camera not set\");\r\n                    }\r\n\r\n                    // Viewport\r\n                    engine.setViewport(this.activeCamera.viewport);\r\n\r\n                    // Camera\r\n                    this.updateTransformMatrix();\r\n\r\n                    renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\r\n            this._intermediateRendering = false;\r\n            this._renderId++;\r\n        }\r\n\r\n        // Restore back buffer\r\n        this.activeCamera = currentActiveCamera;\r\n        if (this._activeCamera && this._activeCamera.cameraRigMode !== Camera.RIG_MODE_CUSTOM && !this.prePass) {\r\n            this._bindFrameBuffer();\r\n        }\r\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\r\n\r\n        for (let step of this._beforeClearStage) {\r\n            step.action();\r\n        }\r\n\r\n        // Clear\r\n        if ((this.autoClearDepthAndStencil || this.autoClear) && !this.prePass) {\r\n            this._engine.clear(this.clearColor,\r\n                this.autoClear || this.forceWireframe || this.forcePointsCloud,\r\n                this.autoClearDepthAndStencil,\r\n                this.autoClearDepthAndStencil);\r\n        }\r\n\r\n        // Collects render targets from external components.\r\n        for (let step of this._gatherRenderTargetsStage) {\r\n            step.action(this._renderTargets);\r\n        }\r\n\r\n        // Multi-cameras?\r\n        if (this.activeCameras && this.activeCameras.length > 0) {\r\n            for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\r\n                if (cameraIndex > 0) {\r\n                    this._engine.clear(null, false, true, true);\r\n                }\r\n\r\n                this._processSubCameras(this.activeCameras[cameraIndex]);\r\n            }\r\n        } else {\r\n            if (!this.activeCamera) {\r\n                throw new Error(\"No camera defined\");\r\n            }\r\n\r\n            this._processSubCameras(this.activeCamera);\r\n        }\r\n\r\n        // Intersection checks\r\n        this._checkIntersections();\r\n\r\n        // Executes the after render stage actions.\r\n        for (let step of this._afterRenderStage) {\r\n            step.action();\r\n        }\r\n\r\n        // After render\r\n        if (this.afterRender) {\r\n            this.afterRender();\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n\r\n        // Cleaning\r\n        if (this._toBeDisposed.length) {\r\n            for (var index = 0; index < this._toBeDisposed.length; index++) {\r\n                var data = this._toBeDisposed[index];\r\n                if (data) {\r\n                    data.dispose();\r\n                }\r\n            }\r\n\r\n            this._toBeDisposed = [];\r\n        }\r\n\r\n        if (this.dumpNextRenderTargets) {\r\n            this.dumpNextRenderTargets = false;\r\n        }\r\n\r\n        this._activeBones.addCount(0, true);\r\n        this._activeIndices.addCount(0, true);\r\n        this._activeParticles.addCount(0, true);\r\n    }\r\n\r\n    /**\r\n     * Freeze all materials\r\n     * A frozen material will not be updatable but should be faster to render\r\n     */\r\n    public freezeMaterials(): void {\r\n        for (var i = 0; i < this.materials.length; i++) {\r\n            this.materials[i].freeze();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unfreeze all materials\r\n     * A frozen material will not be updatable but should be faster to render\r\n     */\r\n    public unfreezeMaterials(): void {\r\n        for (var i = 0; i < this.materials.length; i++) {\r\n            this.materials[i].unfreeze();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all held ressources\r\n     */\r\n    public dispose(): void {\r\n        this.beforeRender = null;\r\n        this.afterRender = null;\r\n\r\n        if (EngineStore._LastCreatedScene === this) {\r\n            EngineStore._LastCreatedScene = null;\r\n        }\r\n\r\n        this.skeletons = [];\r\n        this.morphTargetManagers = [];\r\n        this._transientComponents = [];\r\n        this._isReadyForMeshStage.clear();\r\n        this._beforeEvaluateActiveMeshStage.clear();\r\n        this._evaluateSubMeshStage.clear();\r\n        this._preActiveMeshStage.clear();\r\n        this._cameraDrawRenderTargetStage.clear();\r\n        this._beforeCameraDrawStage.clear();\r\n        this._beforeRenderTargetDrawStage.clear();\r\n        this._beforeRenderingGroupDrawStage.clear();\r\n        this._beforeRenderingMeshStage.clear();\r\n        this._afterRenderingMeshStage.clear();\r\n        this._afterRenderingGroupDrawStage.clear();\r\n        this._afterCameraDrawStage.clear();\r\n        this._afterRenderTargetDrawStage.clear();\r\n        this._afterRenderStage.clear();\r\n        this._beforeCameraUpdateStage.clear();\r\n        this._beforeClearStage.clear();\r\n        this._gatherRenderTargetsStage.clear();\r\n        this._gatherActiveCameraRenderTargetsStage.clear();\r\n        this._pointerMoveStage.clear();\r\n        this._pointerDownStage.clear();\r\n        this._pointerUpStage.clear();\r\n\r\n        for (let component of this._components) {\r\n            component.dispose();\r\n        }\r\n\r\n        this.importedMeshesFiles = new Array<string>();\r\n\r\n        if (this.stopAllAnimations) {\r\n            this.stopAllAnimations();\r\n        }\r\n\r\n        this.resetCachedMaterial();\r\n\r\n        // Smart arrays\r\n        if (this.activeCamera) {\r\n            this.activeCamera._activeMeshes.dispose();\r\n            this.activeCamera = null;\r\n        }\r\n        this._activeMeshes.dispose();\r\n        this._renderingManager.dispose();\r\n        this._processedMaterials.dispose();\r\n        this._activeParticleSystems.dispose();\r\n        this._activeSkeletons.dispose();\r\n        this._softwareSkinnedMeshes.dispose();\r\n        this._renderTargets.dispose();\r\n        this._registeredForLateAnimationBindings.dispose();\r\n        this._meshesForIntersections.dispose();\r\n        this._toBeDisposed = [];\r\n\r\n        // Abort active requests\r\n        for (let request of this._activeRequests) {\r\n            request.abort();\r\n        }\r\n\r\n        // Events\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderTargetsRenderObservable.clear();\r\n        this.onAfterRenderTargetsRenderObservable.clear();\r\n        this.onAfterStepObservable.clear();\r\n        this.onBeforeStepObservable.clear();\r\n        this.onBeforeActiveMeshesEvaluationObservable.clear();\r\n        this.onAfterActiveMeshesEvaluationObservable.clear();\r\n        this.onBeforeParticlesRenderingObservable.clear();\r\n        this.onAfterParticlesRenderingObservable.clear();\r\n        this.onBeforeDrawPhaseObservable.clear();\r\n        this.onAfterDrawPhaseObservable.clear();\r\n        this.onBeforeAnimationsObservable.clear();\r\n        this.onAfterAnimationsObservable.clear();\r\n        this.onDataLoadedObservable.clear();\r\n        this.onBeforeRenderingGroupObservable.clear();\r\n        this.onAfterRenderingGroupObservable.clear();\r\n        this.onMeshImportedObservable.clear();\r\n        this.onBeforeCameraRenderObservable.clear();\r\n        this.onAfterCameraRenderObservable.clear();\r\n        this.onReadyObservable.clear();\r\n        this.onNewCameraAddedObservable.clear();\r\n        this.onCameraRemovedObservable.clear();\r\n        this.onNewLightAddedObservable.clear();\r\n        this.onLightRemovedObservable.clear();\r\n        this.onNewGeometryAddedObservable.clear();\r\n        this.onGeometryRemovedObservable.clear();\r\n        this.onNewTransformNodeAddedObservable.clear();\r\n        this.onTransformNodeRemovedObservable.clear();\r\n        this.onNewMeshAddedObservable.clear();\r\n        this.onMeshRemovedObservable.clear();\r\n        this.onNewSkeletonAddedObservable.clear();\r\n        this.onSkeletonRemovedObservable.clear();\r\n        this.onNewMaterialAddedObservable.clear();\r\n        this.onNewMultiMaterialAddedObservable.clear();\r\n        this.onMaterialRemovedObservable.clear();\r\n        this.onMultiMaterialRemovedObservable.clear();\r\n        this.onNewTextureAddedObservable.clear();\r\n        this.onTextureRemovedObservable.clear();\r\n        this.onPrePointerObservable.clear();\r\n        this.onPointerObservable.clear();\r\n        this.onPreKeyboardObservable.clear();\r\n        this.onKeyboardObservable.clear();\r\n        this.onActiveCameraChanged.clear();\r\n\r\n        this.detachControl();\r\n\r\n        // Detach cameras\r\n        var canvas = this._engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            var index;\r\n            for (index = 0; index < this.cameras.length; index++) {\r\n                this.cameras[index].detachControl();\r\n            }\r\n        }\r\n\r\n        // Release animation groups\r\n        while (this.animationGroups.length) {\r\n            this.animationGroups[0].dispose();\r\n        }\r\n\r\n        // Release lights\r\n        while (this.lights.length) {\r\n            this.lights[0].dispose();\r\n        }\r\n\r\n        // Release meshes\r\n        while (this.meshes.length) {\r\n            this.meshes[0].dispose(true);\r\n        }\r\n        while (this.transformNodes.length) {\r\n            this.transformNodes[0].dispose(true);\r\n        }\r\n\r\n        // Release cameras\r\n        while (this.cameras.length) {\r\n            this.cameras[0].dispose();\r\n        }\r\n\r\n        // Release materials\r\n        if (this._defaultMaterial) {\r\n            this._defaultMaterial.dispose();\r\n        }\r\n        while (this.multiMaterials.length) {\r\n            this.multiMaterials[0].dispose();\r\n        }\r\n        while (this.materials.length) {\r\n            this.materials[0].dispose();\r\n        }\r\n\r\n        // Release particles\r\n        while (this.particleSystems.length) {\r\n            this.particleSystems[0].dispose();\r\n        }\r\n\r\n        // Release postProcesses\r\n        while (this.postProcesses.length) {\r\n            this.postProcesses[0].dispose();\r\n        }\r\n\r\n        // Release textures\r\n        while (this.textures.length) {\r\n            this.textures[0].dispose();\r\n        }\r\n\r\n        // Release UBO\r\n        this._sceneUbo.dispose();\r\n\r\n        if (this._multiviewSceneUbo) {\r\n            this._multiviewSceneUbo.dispose();\r\n        }\r\n\r\n        // Post-processes\r\n        this.postProcessManager.dispose();\r\n\r\n        // Remove from engine\r\n        index = this._engine.scenes.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._engine.scenes.splice(index, 1);\r\n        }\r\n\r\n        this._engine.wipeCaches(true);\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Gets if the scene is already disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Call this function to reduce memory footprint of the scene.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedVertexData(): void {\r\n        for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n            var mesh = this.meshes[meshIndex];\r\n            var geometry = (<Mesh>mesh).geometry;\r\n\r\n            if (geometry) {\r\n                geometry._indices = [];\r\n\r\n                for (var vbName in geometry._vertexBuffers) {\r\n                    if (!geometry._vertexBuffers.hasOwnProperty(vbName)) {\r\n                        continue;\r\n                    }\r\n                    geometry._vertexBuffers[vbName]._buffer._data = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will remove the local cached buffer data from texture.\r\n     * It will save memory but will prevent the texture from being rebuilt\r\n     */\r\n    public cleanCachedTextureBuffer(): void {\r\n        for (var baseTexture of this.textures) {\r\n            let buffer = (<Texture>baseTexture)._buffer;\r\n\r\n            if (buffer) {\r\n                (<Texture>baseTexture)._buffer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world extend vectors with an optional filter\r\n     *\r\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\r\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\r\n     */\r\n    public getWorldExtends(filterPredicate?: (mesh: AbstractMesh) => boolean): { min: Vector3; max: Vector3 } {\r\n        var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n        filterPredicate = filterPredicate || (() => true);\r\n        this.meshes.filter(filterPredicate).forEach((mesh) => {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\r\n                return;\r\n            }\r\n\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n\r\n            var minBox = boundingInfo.boundingBox.minimumWorld;\r\n            var maxBox = boundingInfo.boundingBox.maximumWorld;\r\n\r\n            Vector3.CheckExtends(minBox, min, max);\r\n            Vector3.CheckExtends(maxBox, min, max);\r\n        });\r\n\r\n        return {\r\n            min: min,\r\n            max: max\r\n        };\r\n    }\r\n\r\n    // Picking\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n     * @param camera defines the camera to use for the picking\r\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n     * @returns a Ray\r\n     */\r\n    public createPickingRay(x: number, y: number, world: Matrix, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n     * @param result defines the ray where to store the picking ray\r\n     * @param camera defines the camera to use for the picking\r\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n     * @returns the current scene\r\n     */\r\n    public createPickingRayToRef(x: number, y: number, world: Matrix, result: Ray, camera: Nullable<Camera>, cameraViewSpace = false): Scene {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param camera defines the camera to use for the picking\r\n     * @returns a Ray\r\n     */\r\n    public createPickingRayInCameraSpace(x: number, y: number, camera?: Camera): Ray {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Creates a ray that can be used to pick in the scene\r\n     * @param x defines the x coordinate of the origin (on-screen)\r\n     * @param y defines the y coordinate of the origin (on-screen)\r\n     * @param result defines the ray where to store the picking ray\r\n     * @param camera defines the camera to use for the picking\r\n     * @returns the current scene\r\n     */\r\n    public createPickingRayInCameraSpaceToRef(x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /** Launch a ray to try to pick a mesh in the scene\r\n     * @param x position on screen\r\n     * @param y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns a PickingInfo\r\n     */\r\n    public pick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean,\r\n        fastCheck?: boolean, camera?: Nullable<Camera>,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<PickingInfo> {\r\n        // Dummy info if picking as not been imported\r\n        const pi = new PickingInfo();\r\n        pi._pickingUnavailable = true;\r\n        return pi;\r\n    }\r\n\r\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n     * @param x position on screen\r\n     * @param y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n     */\r\n    public pickWithBoundingInfo(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean,\r\n        fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n        // Dummy info if picking as not been imported\r\n        const pi = new PickingInfo();\r\n        pi._pickingUnavailable = true;\r\n        return pi;\r\n    }\r\n\r\n    /** Use the given ray to pick a mesh in the scene\r\n     * @param ray The ray to use to pick meshes\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns a PickingInfo\r\n     */\r\n    public pickWithRay(ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Launch a ray to try to pick a mesh in the scene\r\n     * @param x X position on screen\r\n     * @param y Y position on screen\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns an array of PickingInfo\r\n     */\r\n    public multiPick(x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera,\r\n        trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Launch a ray to try to pick a mesh in the scene\r\n     * @param ray Ray to use\r\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns an array of PickingInfo\r\n     */\r\n    public multiPickWithRay(ray: Ray, predicate: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n        throw _DevTools.WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh defines the mesh to use\r\n     * @param pointerId optional pointer id when using more than one pointer\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId?: number): void {\r\n        this._inputManager.setPointerOverMesh(mesh, pointerId);\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this._inputManager.getPointerOverMesh();\r\n    }\r\n\r\n    // Misc.\r\n    /** @hidden */\r\n    public _rebuildGeometries(): void {\r\n        for (var geometry of this.geometries) {\r\n            geometry._rebuild();\r\n        }\r\n\r\n        for (var mesh of this.meshes) {\r\n            mesh._rebuild();\r\n        }\r\n\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._rebuild();\r\n        }\r\n\r\n        for (let component of this._components) {\r\n            component.rebuild();\r\n        }\r\n\r\n        for (var system of this.particleSystems) {\r\n            system.rebuild();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuildTextures(): void {\r\n        for (var texture of this.textures) {\r\n            texture._rebuild();\r\n        }\r\n\r\n        this.markAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    // Tags\r\n    private _getByTags(list: any[], tagsQuery: string, forEach?: (item: any) => void): any[] {\r\n        if (tagsQuery === undefined) {\r\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\r\n            return list;\r\n        }\r\n\r\n        var listByTags = [];\r\n\r\n        forEach = forEach || ((item: any) => { return; });\r\n\r\n        for (var i in list) {\r\n            var item = list[i];\r\n            if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\r\n                listByTags.push(item);\r\n                forEach(item);\r\n            }\r\n        }\r\n\r\n        return listByTags;\r\n    }\r\n\r\n    /**\r\n     * Get a list of meshes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param forEach defines a predicate used to filter results\r\n     * @returns an array of Mesh\r\n     */\r\n    public getMeshesByTags(tagsQuery: string, forEach?: (mesh: AbstractMesh) => void): Mesh[] {\r\n        return this._getByTags(this.meshes, tagsQuery, forEach);\r\n    }\r\n\r\n    /**\r\n     * Get a list of cameras by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param forEach defines a predicate used to filter results\r\n     * @returns an array of Camera\r\n     */\r\n    public getCamerasByTags(tagsQuery: string, forEach?: (camera: Camera) => void): Camera[] {\r\n        return this._getByTags(this.cameras, tagsQuery, forEach);\r\n    }\r\n\r\n    /**\r\n     * Get a list of lights by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param forEach defines a predicate used to filter results\r\n     * @returns an array of Light\r\n     */\r\n    public getLightsByTags(tagsQuery: string, forEach?: (light: Light) => void): Light[] {\r\n        return this._getByTags(this.lights, tagsQuery, forEach);\r\n    }\r\n\r\n    /**\r\n     * Get a list of materials by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param forEach defines a predicate used to filter results\r\n     * @returns an array of Material\r\n     */\r\n    public getMaterialByTags(tagsQuery: string, forEach?: (material: Material) => void): Material[] {\r\n        return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\r\n    }\r\n\r\n    /**\r\n     * Get a list of transform nodes by tags\r\n     * @param tagsQuery defines the tags query to use\r\n     * @param forEach defines a predicate used to filter results\r\n     * @returns an array of TransformNode\r\n     */\r\n    public getTransformNodesByTags(tagsQuery: string, forEach?: (transform: TransformNode) => void): TransformNode[] {\r\n        return this._getByTags(this.transformNodes, tagsQuery, forEach);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null): void {\r\n\r\n        this._renderingManager.setRenderingOrder(renderingGroupId,\r\n            opaqueSortCompareFn,\r\n            alphaTestSortCompareFn,\r\n            transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean,\r\n        depth = true,\r\n        stencil = true): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._renderingManager.getAutoClearDepthStencilSetup(index);\r\n    }\r\n\r\n    private _blockMaterialDirtyMechanism = false;\r\n\r\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\r\n    public get blockMaterialDirtyMechanism(): boolean {\r\n        return this._blockMaterialDirtyMechanism;\r\n    }\r\n\r\n    public set blockMaterialDirtyMechanism(value: boolean) {\r\n        if (this._blockMaterialDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockMaterialDirtyMechanism = value;\r\n\r\n        if (!value) { // Do a complete update\r\n            this.markAllMaterialsAsDirty(63);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Will flag all materials as dirty to trigger new shader compilation\r\n     * @param flag defines the flag used to specify which material part must be marked as dirty\r\n     * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty\r\n     */\r\n    public markAllMaterialsAsDirty(flag: number, predicate?: (mat: Material) => boolean): void {\r\n        if (this._blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        for (var material of this.materials) {\r\n            if (predicate && !predicate(material)) {\r\n                continue;\r\n            }\r\n            material.markAsDirty(flag);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest {\r\n        const request = FileTools.LoadFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _loadFileAsync(url: string, onProgress?: (data: any) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadFile(url, (data) => {\r\n                resolve(data);\r\n            }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\r\n                reject(exception);\r\n            });\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _requestFile(url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest {\r\n        const request = FileTools.RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _requestFileAsync(url: string, onProgress?: (ev: ProgressEvent) => void, useOfflineSupport?: boolean, useArrayBuffer?: boolean, onOpened?: (request: WebRequest) => void): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._requestFile(url, (data) => {\r\n                resolve(data);\r\n            }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {\r\n                reject(error);\r\n            }, onOpened);\r\n        });\r\n    }\r\n\r\n    /** @hidden */\r\n    public _readFile(file: File, onSuccess: (data: string | ArrayBuffer) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest {\r\n        const request = FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\r\n        this._activeRequests.push(request);\r\n        request.onCompleteObservable.add((request) => {\r\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\r\n        });\r\n        return request;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _readFileAsync(file: File, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): Promise<string | ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            this._readFile(file, (data) => {\r\n                resolve(data);\r\n            }, onProgress, useArrayBuffer, (error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}