{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\nimport { Logger } from \"../../Misc/logger\";\n/**\r\n * Options for the controller physics feature\r\n */\n\nvar IWebXRControllerPhysicsOptions =\n/** @class */\nfunction () {\n  function IWebXRControllerPhysicsOptions() {}\n\n  return IWebXRControllerPhysicsOptions;\n}();\n\nexport { IWebXRControllerPhysicsOptions };\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\n\nvar WebXRControllerPhysics =\n/** @class */\nfunction (_super) {\n  __extends(WebXRControllerPhysics, _super);\n  /**\r\n   * Construct a new Controller Physics Feature\r\n   * @param _xrSessionManager the corresponding xr session manager\r\n   * @param _options options to create this feature with\r\n   */\n\n\n  function WebXRControllerPhysics(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n\n      if (!_this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      } // if no motion controller available, create impostors!\n\n\n      if (_this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(function (motionController) {\n          motionController.onModelLoadedObservable.addOnce(function () {\n            var impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, __assign({\n              mass: 0\n            }, _this._options.physicsProperties));\n            var controllerMesh = xrController.grip || xrController.pointer;\n            _this._controllers[xrController.uniqueId] = {\n              xrController: xrController,\n              impostor: impostor,\n              oldPos: controllerMesh.position.clone(),\n              oldRotation: controllerMesh.rotationQuaternion.clone()\n            };\n          });\n        });\n      } else {\n        var impostorType = _this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n        var impostorSize = _this._options.physicsProperties.impostorSize || 0.1;\n        var impostorMesh = SphereBuilder.CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n          diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n          diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n          diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n        });\n        impostorMesh.isVisible = _this._debugMode;\n        impostorMesh.isPickable = false;\n        impostorMesh.rotationQuaternion = new Quaternion();\n        var controllerMesh = xrController.grip || xrController.pointer;\n        impostorMesh.position.copyFrom(controllerMesh.position);\n        impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n        var impostor = new PhysicsImpostor(impostorMesh, impostorType, __assign({\n          mass: 0\n        }, _this._options.physicsProperties));\n        _this._controllers[xrController.uniqueId] = {\n          xrController: xrController,\n          impostor: impostor,\n          impostorMesh: impostorMesh\n        };\n      }\n    };\n\n    _this._controllers = {};\n    _this._debugMode = false;\n    _this._delta = 0;\n    _this._lastTimestamp = 0;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3();\n\n    if (!_this._options.physicsProperties) {\n      _this._options.physicsProperties = {};\n    }\n\n    return _this;\n  }\n  /**\r\n   * @hidden\r\n   * enable debugging - will show console outputs and the impostor mesh\r\n   */\n\n\n  WebXRControllerPhysics.prototype._enablePhysicsDebug = function () {\n    var _this = this;\n\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var controllerData = _this._controllers[controllerId];\n\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  };\n  /**\r\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n   * @param xrController the controller to add\r\n   */\n\n\n  WebXRControllerPhysics.prototype.addController = function (xrController) {\n    this._attachController(xrController);\n  };\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPhysics.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.xrInput) {\n      return true;\n    }\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    if (this._options.enableHeadsetImpostor) {\n      var params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      var impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = SphereBuilder.CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, __assign({\n        mass: 0\n      }, params));\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRControllerPhysics.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n\n    return true;\n  };\n  /**\r\n   * Get the headset impostor, if enabled\r\n   * @returns the impostor\r\n   */\n\n\n  WebXRControllerPhysics.prototype.getHeadsetImpostor = function () {\n    return this._headsetImpostor;\n  };\n  /**\r\n   * Get the physics impostor of a specific controller.\r\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n   * @param controller the controller or the controller id of which to get the impostor\r\n   * @returns the impostor or null\r\n   */\n\n\n  WebXRControllerPhysics.prototype.getImpostorForController = function (controller) {\n    var id = typeof controller === \"string\" ? controller : controller.uniqueId;\n\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  };\n  /**\r\n   * Update the physics properties provided in the constructor\r\n   * @param newProperties the new properties object\r\n   */\n\n\n  WebXRControllerPhysics.prototype.setPhysicsProperties = function (newProperties) {\n    this._options.physicsProperties = __assign(__assign({}, this._options.physicsProperties), newProperties);\n  };\n\n  WebXRControllerPhysics.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n\n    if (this._headsetMesh) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.position);\n\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      var controllerData = _this._controllers[controllerId];\n      var controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      var comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n      var comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n      controllerMesh.position.subtractToRef(comparedPosition, _this._tmpVector);\n\n      _this._tmpVector.scaleInPlace(1000 / _this._delta);\n\n      controllerData.impostor.setLinearVelocity(_this._tmpVector);\n\n      if (_this._debugMode) {\n        console.log(_this._tmpVector, \"linear\");\n      }\n\n      if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n        // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n        comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, _this._tmpQuaternion);\n        var len = Math.sqrt(_this._tmpQuaternion.x * _this._tmpQuaternion.x + _this._tmpQuaternion.y * _this._tmpQuaternion.y + _this._tmpQuaternion.z * _this._tmpQuaternion.z);\n\n        _this._tmpVector.set(_this._tmpQuaternion.x, _this._tmpQuaternion.y, _this._tmpQuaternion.z); // define a better epsilon\n\n\n        if (len < 0.001) {\n          _this._tmpVector.scaleInPlace(2);\n        } else {\n          var angle = 2 * Math.atan2(len, _this._tmpQuaternion.w);\n\n          _this._tmpVector.scaleInPlace(angle / (len * (_this._delta / 1000)));\n        }\n\n        controllerData.impostor.setAngularVelocity(_this._tmpVector);\n\n        if (_this._debugMode) {\n          console.log(_this._tmpVector, _this._tmpQuaternion, \"angular\");\n        }\n      }\n\n      comparedPosition.copyFrom(controllerMesh.position);\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    });\n  };\n\n  WebXRControllerPhysics.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the webxr specs version\r\n   */\n\n  WebXRControllerPhysics.Version = 1;\n  return WebXRControllerPhysics;\n}(WebXRAbstractFeature);\n\nexport { WebXRControllerPhysics }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRControllerPhysics(xrSessionManager, options);\n  };\n}, WebXRControllerPhysics.Version, true);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRControllerPhysics.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\r\nimport { WebXRInput } from \"../webXRInput\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { SphereBuilder } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options for the controller physics feature\r\n */\r\nexport class IWebXRControllerPhysicsOptions {\r\n    /**\r\n     * Should the headset get its own impostor\r\n     */\r\n    enableHeadsetImpostor?: boolean;\r\n    /**\r\n     * Optional parameters for the headset impostor\r\n     */\r\n    headsetImpostorParams?: {\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * The physics properties of the future impostors\r\n     */\r\n    physicsProperties?: {\r\n        /**\r\n         * If set to true, a mesh impostor will be created when the controller mesh was loaded\r\n         * Note that this requires a physics engine that supports mesh impostors!\r\n         */\r\n        useControllerMesh?: boolean;\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType?: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    public xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\r\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\r\n            Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\r\n        }\r\n        // if no motion controller available, create impostors!\r\n        if (this._options.physicsProperties!.useControllerMesh && xrController.inputSource.gamepad) {\r\n            xrController.onMotionControllerInitObservable.addOnce((motionController) => {\r\n                motionController.onModelLoadedObservable.addOnce(() => {\r\n                    const impostor = new PhysicsImpostor(motionController.rootMesh!, PhysicsImpostor.MeshImpostor, {\r\n                        mass: 0,\r\n                        ...this._options.physicsProperties,\r\n                    });\r\n                    const controllerMesh = xrController.grip || xrController.pointer;\r\n                    this._controllers[xrController.uniqueId] = {\r\n                        xrController,\r\n                        impostor,\r\n                        oldPos: controllerMesh.position.clone(),\r\n                        oldRotation: controllerMesh.rotationQuaternion!.clone(),\r\n                    };\r\n                });\r\n            });\r\n        } else {\r\n            const impostorType: number = this._options.physicsProperties!.impostorType || PhysicsImpostor.SphereImpostor;\r\n            const impostorSize: number | { width: number; height: number; depth: number } = this._options.physicsProperties!.impostorSize || 0.1;\r\n            const impostorMesh = SphereBuilder.CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            impostorMesh.isVisible = this._debugMode;\r\n            impostorMesh.isPickable = false;\r\n            impostorMesh.rotationQuaternion = new Quaternion();\r\n            const controllerMesh = xrController.grip || xrController.pointer;\r\n            impostorMesh.position.copyFrom(controllerMesh.position);\r\n            impostorMesh.rotationQuaternion!.copyFrom(controllerMesh.rotationQuaternion!);\r\n            const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\r\n                mass: 0,\r\n                ...this._options.physicsProperties,\r\n            });\r\n            this._controllers[xrController.uniqueId] = {\r\n                xrController,\r\n                impostor,\r\n                impostorMesh,\r\n            };\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [id: string]: {\r\n            xrController: WebXRInputSource;\r\n            impostorMesh?: AbstractMesh;\r\n            impostor: PhysicsImpostor;\r\n            oldPos?: Vector3;\r\n            oldSpeed?: Vector3;\r\n            oldRotation?: Quaternion;\r\n        };\r\n    } = {};\r\n    private _debugMode = false;\r\n    private _delta: number = 0;\r\n    private _headsetImpostor?: PhysicsImpostor;\r\n    private _headsetMesh?: AbstractMesh;\r\n    private _lastTimestamp: number = 0;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVector: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Construct a new Controller Physics Feature\r\n     * @param _xrSessionManager the corresponding xr session manager\r\n     * @param _options options to create this feature with\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPhysicsOptions) {\r\n        super(_xrSessionManager);\r\n        if (!this._options.physicsProperties) {\r\n            this._options.physicsProperties = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * enable debugging - will show console outputs and the impostor mesh\r\n     */\r\n    public _enablePhysicsDebug() {\r\n        this._debugMode = true;\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            if (controllerData.impostorMesh) {\r\n                controllerData.impostorMesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n     * @param xrController the controller to add\r\n     */\r\n    public addController(xrController: WebXRInputSource) {\r\n        this._attachController(xrController);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.xrInput) {\r\n            return true;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        if (this._options.enableHeadsetImpostor) {\r\n            const params = this._options.headsetImpostorParams || {\r\n                impostorType: PhysicsImpostor.SphereImpostor,\r\n                restitution: 0.8,\r\n                impostorSize: 0.3,\r\n            };\r\n            const impostorSize = params.impostorSize || 0.3;\r\n            this._headsetMesh = SphereBuilder.CreateSphere(\"headset-mesh\", {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            this._headsetMesh.rotationQuaternion = new Quaternion();\r\n            this._headsetMesh.isVisible = false;\r\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.dispose();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the headset impostor, if enabled\r\n     * @returns the impostor\r\n     */\r\n    public getHeadsetImpostor() {\r\n        return this._headsetImpostor;\r\n    }\r\n\r\n    /**\r\n     * Get the physics impostor of a specific controller.\r\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n     * @param controller the controller or the controller id of which to get the impostor\r\n     * @returns the impostor or null\r\n     */\r\n    public getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor> {\r\n        let id = typeof controller === \"string\" ? controller : controller.uniqueId;\r\n        if (this._controllers[id]) {\r\n            return this._controllers[id].impostor;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the physics properties provided in the constructor\r\n     * @param newProperties the new properties object\r\n     */\r\n    public setPhysicsProperties(newProperties: { impostorType?: number; impostorSize?: number | { width: number; height: number; depth: number }; friction?: number; restitution?: number }) {\r\n        this._options.physicsProperties = {\r\n            ...this._options.physicsProperties,\r\n            ...newProperties,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: any): void {\r\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\r\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.position);\r\n            this._headsetMesh.rotationQuaternion!.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n        }\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\r\n\r\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh!.position;\r\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh!.rotationQuaternion!;\r\n\r\n            controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\r\n            this._tmpVector.scaleInPlace(1000 / this._delta);\r\n            controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, \"linear\");\r\n            }\r\n\r\n            if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion!)) {\r\n                // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\r\n                comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion!, this._tmpQuaternion);\r\n                const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);\r\n                this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\r\n                // define a better epsilon\r\n                if (len < 0.001) {\r\n                    this._tmpVector.scaleInPlace(2);\r\n                } else {\r\n                    const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\r\n                    this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\r\n                }\r\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n                if (this._debugMode) {\r\n                    console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\r\n                }\r\n            }\r\n            comparedPosition.copyFrom(controllerMesh.position);\r\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion!);\r\n        });\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.impostorMesh) {\r\n            controllerData.impostorMesh.dispose();\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPhysics.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPhysics(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPhysics.Version,\r\n    true\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}