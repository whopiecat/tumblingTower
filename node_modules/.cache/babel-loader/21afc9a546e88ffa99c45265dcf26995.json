{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\nimport \"../../Engines/Extensions/engine.renderTarget\";\nimport \"../../Engines/Extensions/engine.renderTargetCube\";\nimport { Engine } from '../../Engines/engine';\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\n\nvar RenderTargetTexture =\n/** @class */\nfunction (_super) {\n  __extends(RenderTargetTexture, _super);\n  /**\r\n   * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse\r\n   * or used a shadow, depth texture...\r\n   * @param name The friendly name of the texture\r\n   * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n   * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.\r\n   * @param generateMipMaps True if mip maps need to be generated after render.\r\n   * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT\r\n   * @param type The type of the buffer in the RTT (int, half float, float...)\r\n   * @param isCube True if a cube texture needs to be created\r\n   * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)\r\n   * @param generateDepthBuffer True to generate a depth buffer\r\n   * @param generateStencilBuffer True to generate a stencil buffer\r\n   * @param isMulti True if multiple textures need to be created (Draw Buffers)\r\n   * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)\r\n   * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n   */\n\n\n  function RenderTargetTexture(name, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti, format, delayAllocation) {\n    if (doNotChangeAspectRatio === void 0) {\n      doNotChangeAspectRatio = true;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (isCube === void 0) {\n      isCube = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (generateDepthBuffer === void 0) {\n      generateDepthBuffer = true;\n    }\n\n    if (generateStencilBuffer === void 0) {\n      generateStencilBuffer = false;\n    }\n\n    if (isMulti === void 0) {\n      isMulti = false;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (delayAllocation === void 0) {\n      delayAllocation = false;\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n    /**\r\n     * Define if particles should be rendered in your texture.\r\n     */\n\n\n    _this.renderParticles = true;\n    /**\r\n     * Define if sprites should be rendered in your texture.\r\n     */\n\n    _this.renderSprites = false;\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\n\n    _this.ignoreCameraViewport = false;\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\n\n    _this.onBeforeBindObservable = new Observable();\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\n\n    _this.onAfterUnbindObservable = new Observable();\n    /**\r\n    * An event triggered before rendering the texture\r\n    */\n\n    _this.onBeforeRenderObservable = new Observable();\n    /**\r\n    * An event triggered after rendering the texture\r\n    */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\r\n    * An event triggered after the texture clear\r\n    */\n\n    _this.onClearObservable = new Observable();\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\n\n    _this.onResizeObservable = new Observable();\n    _this._currentRefreshId = -1;\n    _this._refreshRate = 1;\n    _this._samples = 1;\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    scene = _this.getScene();\n\n    if (!scene) {\n      return _this;\n    }\n\n    _this._coordinatesMode = Texture.PROJECTION_MODE;\n    _this.renderList = new Array();\n    _this.name = name;\n    _this.isRenderTarget = true;\n    _this._initialSizeParameter = size;\n\n    _this._processSizeParameter(size);\n\n    _this._resizeObserver = _this.getScene().getEngine().onResizeObservable.add(function () {});\n    _this._generateMipMaps = generateMipMaps ? true : false;\n    _this._doNotChangeAspectRatio = doNotChangeAspectRatio; // Rendering groups\n\n    _this._renderingManager = new RenderingManager(scene);\n    _this._renderingManager._useSceneAutoClearSetup = true;\n\n    if (isMulti) {\n      return _this;\n    }\n\n    _this._renderTargetOptions = {\n      generateMipMaps: generateMipMaps,\n      type: type,\n      format: format,\n      samplingMode: samplingMode,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer\n    };\n\n    if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {\n      _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n      _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    }\n\n    if (!delayAllocation) {\n      if (isCube) {\n        _this._texture = scene.getEngine().createRenderTargetCubeTexture(_this.getRenderSize(), _this._renderTargetOptions);\n        _this.coordinatesMode = Texture.INVCUBIC_MODE;\n        _this._textureMatrix = Matrix.Identity();\n      } else {\n        _this._texture = scene.getEngine().createRenderTargetTexture(_this._size, _this._renderTargetOptions);\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"renderList\", {\n    /**\r\n    * Use this list to define the list of mesh you want to render.\r\n    */\n    get: function () {\n      return this._renderList;\n    },\n    set: function (value) {\n      this._renderList = value;\n\n      if (this._renderList) {\n        this._hookArray(this._renderList);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RenderTargetTexture.prototype._hookArray = function (array) {\n    var _this = this;\n\n    var oldPush = array.push;\n\n    array.push = function () {\n      var items = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n      }\n\n      var wasEmpty = array.length === 0;\n      var result = oldPush.apply(array, items);\n\n      if (wasEmpty && _this.getScene()) {\n        _this.getScene().meshes.forEach(function (mesh) {\n          mesh._markSubMeshesAsLightDirty();\n        });\n      }\n\n      return result;\n    };\n\n    var oldSplice = array.splice;\n\n    array.splice = function (index, deleteCount) {\n      var deleted = oldSplice.apply(array, [index, deleteCount]);\n\n      if (array.length === 0) {\n        _this.getScene().meshes.forEach(function (mesh) {\n          mesh._markSubMeshesAsLightDirty();\n        });\n      }\n\n      return deleted;\n    };\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"onAfterUnbind\", {\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\n    set: function (callback) {\n      if (this._onAfterUnbindObserver) {\n        this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n      }\n\n      this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onBeforeRender\", {\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\n    set: function (callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onAfterRender\", {\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\n    set: function (callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"onClear\", {\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\n    set: function (callback) {\n      if (this._onClearObserver) {\n        this.onClearObservable.remove(this._onClearObserver);\n      }\n\n      this._onClearObserver = this.onClearObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"renderTargetOptions\", {\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\n    get: function () {\n      return this._renderTargetOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RenderTargetTexture.prototype._onRatioRescale = function () {\n    if (this._sizeRatio) {\n      this.resize(this._initialSizeParameter);\n    }\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"boundingBoxSize\", {\n    get: function () {\n      return this._boundingBoxSize;\n    },\n\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\n    set: function (value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RenderTargetTexture.prototype, \"depthStencilTexture\", {\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\n    get: function () {\n      var _a;\n\n      return ((_a = this.getInternalTexture()) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a depth stencil texture.\r\n   * This is only available in WebGL 2 or with the depth texture extension available.\r\n   * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode\r\n   * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture\r\n   * @param generateStencil Specifies whether or not a stencil should be allocated in the texture\r\n   */\n\n  RenderTargetTexture.prototype.createDepthStencilTexture = function (comparisonFunction, bilinearFiltering, generateStencil) {\n    if (comparisonFunction === void 0) {\n      comparisonFunction = 0;\n    }\n\n    if (bilinearFiltering === void 0) {\n      bilinearFiltering = true;\n    }\n\n    if (generateStencil === void 0) {\n      generateStencil = false;\n    }\n\n    var internalTexture = this.getInternalTexture();\n\n    if (!this.getScene() || !internalTexture) {\n      return;\n    }\n\n    var engine = this.getScene().getEngine();\n    internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering: bilinearFiltering,\n      comparisonFunction: comparisonFunction,\n      generateStencil: generateStencil,\n      isCube: this.isCube\n    });\n  };\n\n  RenderTargetTexture.prototype._processSizeParameter = function (size) {\n    if (size.ratio) {\n      this._sizeRatio = size.ratio;\n\n      var engine = this._getEngine();\n\n      this._size = {\n        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\n        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)\n      };\n    } else {\n      this._size = size;\n    }\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"samples\", {\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\n    get: function () {\n      return this._samples;\n    },\n    set: function (value) {\n      if (this._samples === value) {\n        return;\n      }\n\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the refresh counter of the texture and start bak from scratch.\r\n   * Could be useful to regenerate the texture if it is setup to render only once.\r\n   */\n\n  RenderTargetTexture.prototype.resetRefreshCounter = function () {\n    this._currentRefreshId = -1;\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"refreshRate\", {\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\n    get: function () {\n      return this._refreshRate;\n    },\n    set: function (value) {\n      this._refreshRate = value;\n      this.resetRefreshCounter();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Adds a post process to the render target rendering passes.\r\n   * @param postProcess define the post process to add\r\n   */\n\n  RenderTargetTexture.prototype.addPostProcess = function (postProcess) {\n    if (!this._postProcessManager) {\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      this._postProcessManager = new PostProcessManager(scene);\n      this._postProcesses = new Array();\n    }\n\n    this._postProcesses.push(postProcess);\n\n    this._postProcesses[0].autoClear = false;\n  };\n  /**\r\n   * Clear all the post processes attached to the render target\r\n   * @param dispose define if the cleared post processesshould also be disposed (false by default)\r\n   */\n\n\n  RenderTargetTexture.prototype.clearPostProcesses = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    if (!this._postProcesses) {\n      return;\n    }\n\n    if (dispose) {\n      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {\n        var postProcess = _a[_i];\n        postProcess.dispose();\n      }\n    }\n\n    this._postProcesses = [];\n  };\n  /**\r\n   * Remove one of the post process from the list of attached post processes to the texture\r\n   * @param postProcess define the post process to remove from the list\r\n   */\n\n\n  RenderTargetTexture.prototype.removePostProcess = function (postProcess) {\n    if (!this._postProcesses) {\n      return;\n    }\n\n    var index = this._postProcesses.indexOf(postProcess);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._postProcesses.splice(index, 1);\n\n    if (this._postProcesses.length > 0) {\n      this._postProcesses[0].autoClear = false;\n    }\n  };\n  /** @hidden */\n\n\n  RenderTargetTexture.prototype._shouldRender = function () {\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      return true;\n    }\n\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      return true;\n    }\n\n    this._currentRefreshId++;\n    return false;\n  };\n  /**\r\n   * Gets the actual render size of the texture.\r\n   * @returns the width of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderSize = function () {\n    return this.getRenderWidth();\n  };\n  /**\r\n   * Gets the actual render width of the texture.\r\n   * @returns the width of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderWidth = function () {\n    if (this._size.width) {\n      return this._size.width;\n    }\n\n    return this._size;\n  };\n  /**\r\n   * Gets the actual render height of the texture.\r\n   * @returns the height of the render size\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderHeight = function () {\n    if (this._size.width) {\n      return this._size.height;\n    }\n\n    return this._size;\n  };\n  /**\r\n   * Gets the actual number of layers of the texture.\r\n   * @returns the number of layers\r\n   */\n\n\n  RenderTargetTexture.prototype.getRenderLayers = function () {\n    var layers = this._size.layers;\n\n    if (layers) {\n      return layers;\n    }\n\n    return 0;\n  };\n\n  Object.defineProperty(RenderTargetTexture.prototype, \"canRescale\", {\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resize the texture using a ratio.\r\n   * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n   */\n\n  RenderTargetTexture.prototype.scale = function (ratio) {\n    var newSize = Math.max(1, this.getRenderSize() * ratio);\n    this.resize(newSize);\n  };\n  /**\r\n   * Get the texture reflection matrix used to rotate/transform the reflection.\r\n   * @returns the reflection matrix\r\n   */\n\n\n  RenderTargetTexture.prototype.getReflectionTextureMatrix = function () {\n    if (this.isCube) {\n      return this._textureMatrix;\n    }\n\n    return _super.prototype.getReflectionTextureMatrix.call(this);\n  };\n  /**\r\n   * Resize the texture to a new desired size.\r\n   * Be carrefull as it will recreate all the data in the new texture.\r\n   * @param size Define the new size. It can be:\r\n   *   - a number for squared texture,\r\n   *   - an object containing { width: number, height: number }\r\n   *   - or an object containing a ratio { ratio: number }\r\n   */\n\n\n  RenderTargetTexture.prototype.resize = function (size) {\n    var wasCube = this.isCube;\n    this.releaseInternalTexture();\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this._processSizeParameter(size);\n\n    if (wasCube) {\n      this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\n    } else {\n      this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\n    }\n\n    if (this.onResizeObservable.hasObservers()) {\n      this.onResizeObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Renders all the objects from the render list into the texture.\r\n   * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n   * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n   */\n\n\n  RenderTargetTexture.prototype.render = function (useCameraPostProcess, dumpForDebug) {\n    if (useCameraPostProcess === void 0) {\n      useCameraPostProcess = false;\n    }\n\n    if (dumpForDebug === void 0) {\n      dumpForDebug = false;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (this.useCameraPostProcesses !== undefined) {\n      useCameraPostProcess = this.useCameraPostProcesses;\n    }\n\n    if (this._waitingRenderList) {\n      this.renderList = [];\n\n      for (var index = 0; index < this._waitingRenderList.length; index++) {\n        var id = this._waitingRenderList[index];\n        var mesh_1 = scene.getMeshByID(id);\n\n        if (mesh_1) {\n          this.renderList.push(mesh_1);\n        }\n      }\n\n      this._waitingRenderList = undefined;\n    } // Is predicate defined?\n\n\n    if (this.renderListPredicate) {\n      if (this.renderList) {\n        this.renderList.length = 0; // Clear previous renderList\n      } else {\n        this.renderList = [];\n      }\n\n      var scene = this.getScene();\n\n      if (!scene) {\n        return;\n      }\n\n      var sceneMeshes = scene.meshes;\n\n      for (var index = 0; index < sceneMeshes.length; index++) {\n        var mesh = sceneMeshes[index];\n\n        if (this.renderListPredicate(mesh)) {\n          this.renderList.push(mesh);\n        }\n      }\n    }\n\n    this.onBeforeBindObservable.notifyObservers(this); // Set custom projection.\n    // Needs to be before binding to prevent changing the aspect ratio.\n\n    var camera;\n\n    if (this.activeCamera) {\n      camera = this.activeCamera;\n      engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());\n\n      if (this.activeCamera !== scene.activeCamera) {\n        scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\n      }\n    } else {\n      camera = scene.activeCamera;\n\n      if (camera) {\n        engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\n      }\n    }\n\n    this._defaultRenderListPrepared = false;\n\n    if (this.is2DArray) {\n      for (var layer = 0; layer < this.getRenderLayers(); layer++) {\n        this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n      }\n    } else if (this.isCube) {\n      for (var face = 0; face < 6; face++) {\n        this.renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\n        scene.incrementRenderId();\n        scene.resetCachedMaterial();\n      }\n    } else {\n      this.renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\n    }\n\n    this.onAfterUnbindObservable.notifyObservers(this);\n\n    if (scene.activeCamera) {\n      // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\n      if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {\n        scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\n      }\n\n      engine.setViewport(scene.activeCamera.viewport);\n    }\n\n    scene.resetCachedMaterial();\n  };\n\n  RenderTargetTexture.prototype._bestReflectionRenderTargetDimension = function (renderDimension, scale) {\n    var minimum = 128;\n    var x = renderDimension * scale;\n    var curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x)); // Ensure we don't exceed the render dimension (while staying POT)\n\n    return Math.min(Engine.FloorPOT(renderDimension), curved);\n  };\n\n  RenderTargetTexture.prototype._prepareRenderingManager = function (currentRenderList, currentRenderListLength, camera, checkLayerMask) {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    this._renderingManager.reset();\n\n    var sceneRenderId = scene.getRenderId();\n\n    for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\n      var mesh = currentRenderList[meshIndex];\n\n      if (mesh && !mesh.isBlocked) {\n        if (this.customIsReadyFunction) {\n          if (!this.customIsReadyFunction(mesh, this.refreshRate)) {\n            this.resetRefreshCounter();\n            continue;\n          }\n        } else if (!mesh.isReady(this.refreshRate === 0)) {\n          this.resetRefreshCounter();\n          continue;\n        }\n\n        if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {\n          mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, scene.activeCamera) : mesh.getLOD(scene.activeCamera);\n          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n        }\n\n        if (!mesh._internalAbstractMeshDataInfo._currentLOD) {\n          continue;\n        }\n\n        var meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;\n\n        meshToRender._preActivateForIntermediateRendering(sceneRenderId);\n\n        var isMasked = void 0;\n\n        if (checkLayerMask && camera) {\n          isMasked = (mesh.layerMask & camera.layerMask) === 0;\n        } else {\n          isMasked = false;\n        }\n\n        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\n          if (meshToRender !== mesh) {\n            meshToRender._activate(sceneRenderId, true);\n          }\n\n          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\n            if (!mesh.isAnInstance) {\n              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\n            } else {\n              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                meshToRender = mesh;\n              }\n            }\n\n            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\n\n            for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\n              var subMesh = meshToRender.subMeshes[subIndex];\n\n              this._renderingManager.dispatch(subMesh, meshToRender);\n            }\n          }\n        }\n      }\n    }\n\n    for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\n      var particleSystem = scene.particleSystems[particleIndex];\n      var emitter = particleSystem.emitter;\n\n      if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\n        continue;\n      }\n\n      if (currentRenderList.indexOf(emitter) >= 0) {\n        this._renderingManager.dispatchParticles(particleSystem);\n      }\n    }\n  };\n  /**\r\n   * @hidden\r\n   * @param faceIndex face index to bind to if this is a cubetexture\r\n   * @param layer defines the index of the texture to bind in the array\r\n   */\n\n\n  RenderTargetTexture.prototype._bindFrameBuffer = function (faceIndex, layer) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (this._texture) {\n      engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\n    }\n  };\n\n  RenderTargetTexture.prototype.unbindFrameBuffer = function (engine, faceIndex) {\n    var _this = this;\n\n    if (!this._texture) {\n      return;\n    }\n\n    engine.unBindFramebuffer(this._texture, this.isCube, function () {\n      _this.onAfterRenderObservable.notifyObservers(faceIndex);\n    });\n  };\n\n  RenderTargetTexture.prototype.renderToTarget = function (faceIndex, useCameraPostProcess, dumpForDebug, layer, camera) {\n    if (layer === void 0) {\n      layer = 0;\n    }\n\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var engine = scene.getEngine();\n\n    if (!this._texture) {\n      return;\n    } // Bind\n\n\n    if (this._postProcessManager) {\n      this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\n    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\n      this._bindFrameBuffer(faceIndex, layer);\n    }\n\n    if (this.is2DArray) {\n      this.onBeforeRenderObservable.notifyObservers(layer);\n    } else {\n      this.onBeforeRenderObservable.notifyObservers(faceIndex);\n    } // Get the list of meshes to render\n\n\n    var currentRenderList = null;\n    var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n    var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n\n    if (this.getCustomRenderList) {\n      currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\n    }\n\n    if (!currentRenderList) {\n      // No custom render list provided, we prepare the rendering for the default list, but check\n      // first if we did not already performed the preparation before so as to avoid re-doing it several times\n      if (!this._defaultRenderListPrepared) {\n        this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);\n\n        this._defaultRenderListPrepared = true;\n      }\n\n      currentRenderList = defaultRenderList;\n    } else {\n      // Prepare the rendering for the custom render list provided\n      this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);\n    } // Clear\n\n\n    if (this.onClearObservable.hasObservers()) {\n      this.onClearObservable.notifyObservers(engine);\n    } else {\n      engine.clear(this.clearColor || scene.clearColor, true, true, true);\n    }\n\n    if (!this._doNotChangeAspectRatio) {\n      scene.updateTransformMatrix(true);\n    } // Before Camera Draw\n\n\n    for (var _i = 0, _a = scene._beforeRenderTargetDrawStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      step.action(this);\n    } // Render\n\n\n    this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites); // After Camera Draw\n\n\n    for (var _b = 0, _c = scene._afterRenderTargetDrawStage; _b < _c.length; _b++) {\n      var step = _c[_b];\n      step.action(this);\n    }\n\n    if (this._postProcessManager) {\n      this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);\n    } else if (useCameraPostProcess) {\n      scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\n    }\n\n    if (!this._doNotChangeAspectRatio) {\n      scene.updateTransformMatrix(true);\n    } // Dump ?\n\n\n    if (dumpForDebug) {\n      Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\n    } // Unbind\n\n\n    if (!this.isCube || faceIndex === 5) {\n      if (this.isCube) {\n        if (faceIndex === 5) {\n          engine.generateMipMapsForCubemap(this._texture);\n        }\n      }\n\n      this.unbindFrameBuffer(engine, faceIndex);\n    } else {\n      this.onAfterRenderObservable.notifyObservers(faceIndex);\n    }\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  RenderTargetTexture.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   */\n\n\n  RenderTargetTexture.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n\n    this._renderingManager._useSceneAutoClearSetup = false;\n  };\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  RenderTargetTexture.prototype.clone = function () {\n    var textureSize = this.getSize();\n    var newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer); // Base texture\n\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level; // RenderTarget Texture\n\n    newTexture.coordinatesMode = this.coordinatesMode;\n\n    if (this.renderList) {\n      newTexture.renderList = this.renderList.slice(0);\n    }\n\n    return newTexture;\n  };\n  /**\r\n   * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n   * @returns The JSON representation of the texture\r\n   */\n\n\n  RenderTargetTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.renderTargetSize = this.getRenderSize();\n    serializationObject.renderList = [];\n\n    if (this.renderList) {\n      for (var index = 0; index < this.renderList.length; index++) {\n        serializationObject.renderList.push(this.renderList[index].id);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n   */\n\n\n  RenderTargetTexture.prototype.disposeFramebufferObjects = function () {\n    var objBuffer = this.getInternalTexture();\n    var scene = this.getScene();\n\n    if (objBuffer && scene) {\n      scene.getEngine()._releaseFramebufferObjects(objBuffer);\n    }\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  RenderTargetTexture.prototype.dispose = function () {\n    this.onResizeObservable.clear();\n    this.onClearObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onAfterUnbindObservable.clear();\n    this.onBeforeBindObservable.clear();\n    this.onBeforeRenderObservable.clear();\n\n    if (this._postProcessManager) {\n      this._postProcessManager.dispose();\n\n      this._postProcessManager = null;\n    }\n\n    this.clearPostProcesses(true);\n\n    if (this._resizeObserver) {\n      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n\n    this.renderList = null; // Remove from custom render targets\n\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    var index = scene.customRenderTargets.indexOf(this);\n\n    if (index >= 0) {\n      scene.customRenderTargets.splice(index, 1);\n    }\n\n    for (var _i = 0, _a = scene.cameras; _i < _a.length; _i++) {\n      var camera = _a[_i];\n      index = camera.customRenderTargets.indexOf(this);\n\n      if (index >= 0) {\n        camera.customRenderTargets.splice(index, 1);\n      }\n    }\n\n    if (this.depthStencilTexture) {\n      this.getScene().getEngine()._releaseTexture(this.depthStencilTexture);\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /** @hidden */\n\n\n  RenderTargetTexture.prototype._rebuild = function () {\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n\n    if (this._postProcessManager) {\n      this._postProcessManager._rebuild();\n    }\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention point in material dispose.\r\n   */\n\n\n  RenderTargetTexture.prototype.freeRenderingGroups = function () {\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n  };\n  /**\r\n   * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n   * @returns the view count\r\n   */\n\n\n  RenderTargetTexture.prototype.getViewCount = function () {\n    return 1;\n  };\n  /**\r\n   * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n   */\n\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;\n  /**\r\n   * The texture will only be rendered rendered every frame and is recomended for dynamic contents.\r\n   */\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;\n  /**\r\n   * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n   * the central point of your effect and can save a lot of performances.\r\n   */\n\n  RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;\n  return RenderTargetTexture;\n}(Texture);\n\nexport { RenderTargetTexture };\n\nTexture._CreateRenderTargetTexture = function (name, renderTargetSize, scene, generateMipMaps) {\n  return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/renderTargetTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { Nullable, Immutable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { RenderTargetCreationOptions } from \"../../Materials/Textures/renderTargetCreationOptions\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\r\n\r\n\r\nimport \"../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../Engines/Extensions/engine.renderTargetCube\";\r\nimport { Engine } from '../../Engines/engine';\r\n\r\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\r\nexport class RenderTargetTexture extends Texture {\r\n    /**\r\n     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = 0;\r\n    /**\r\n     * The texture will only be rendered rendered every frame and is recomended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = 1;\r\n    /**\r\n     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = 2;\r\n\r\n    /**\r\n    * Use this predicate to dynamically define the list of mesh you want to render.\r\n    * If set, the renderList property will be overwritten.\r\n    */\r\n    public renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;\r\n\r\n    private _renderList: Nullable<Array<AbstractMesh>>;\r\n    /**\r\n    * Use this list to define the list of mesh you want to render.\r\n    */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        this._renderList = value;\r\n\r\n        if (this._renderList) {\r\n            this._hookArray(this._renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the curent renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n    */\r\n    public getCustomRenderList: (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>;\r\n\r\n    private _hookArray(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            let wasEmpty = array.length === 0;\r\n\r\n            var result = oldPush.apply(array, items);\r\n\r\n            if (wasEmpty && this.getScene()) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            if (array.length === 0) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Define if particles should be rendered in your texture.\r\n     */\r\n    public renderParticles = true;\r\n    /**\r\n     * Define if sprites should be rendered in your texture.\r\n     */\r\n    public renderSprites = false;\r\n    /**\r\n     * Define the camera used to render the texture.\r\n     */\r\n    public activeCamera: Nullable<Camera>;\r\n    /**\r\n     * Override the mesh isReady function with your own one.\r\n     */\r\n    public customIsReadyFunction: (mesh: AbstractMesh, refreshRate: number) => boolean;\r\n    /**\r\n     * Override the render function of the texture with your own one.\r\n     */\r\n    public customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;\r\n    /**\r\n     * Define if camera post processes should be use while rendering the texture.\r\n     */\r\n    public useCameraPostProcesses: boolean;\r\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\r\n    public ignoreCameraViewport: boolean = false;\r\n\r\n    private _postProcessManager: Nullable<PostProcessManager>;\r\n    private _postProcesses: PostProcess[];\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onBeforeBindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onAfterUnbindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    private _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\r\n    public set onAfterUnbind(callback: () => void) {\r\n        if (this._onAfterUnbindObserver) {\r\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        }\r\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the texture\r\n    */\r\n    public onBeforeRenderObservable = new Observable<number>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\r\n    public set onBeforeRender(callback: (faceIndex: number) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the texture\r\n    */\r\n    public onAfterRenderObservable = new Observable<number>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\r\n    public set onAfterRender(callback: (faceIndex: number) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after the texture clear\r\n    */\r\n    public onClearObservable = new Observable<Engine>();\r\n\r\n    private _onClearObserver: Nullable<Observer<Engine>>;\r\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\r\n    public set onClear(callback: (Engine: Engine) => void) {\r\n        if (this._onClearObserver) {\r\n            this.onClearObservable.remove(this._onClearObserver);\r\n        }\r\n        this._onClearObserver = this.onClearObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\r\n    public onResizeObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Define the clear color of the Render Target if it should be different from the scene.\r\n     */\r\n    public clearColor: Color4;\r\n    protected _size: number | { width: number, height: number, layers?: number };\r\n    protected _initialSizeParameter: number | { width: number, height: number } | { ratio: number };\r\n    protected _sizeRatio: Nullable<number>;\r\n    /** @hidden */\r\n    public _generateMipMaps: boolean;\r\n    protected _renderingManager: RenderingManager;\r\n    /** @hidden */\r\n    public _waitingRenderList?: string[];\r\n    protected _doNotChangeAspectRatio: boolean;\r\n    protected _currentRefreshId = -1;\r\n    protected _refreshRate = 1;\r\n    protected _textureMatrix: Matrix;\r\n    protected _samples = 1;\r\n    protected _renderTargetOptions: RenderTargetCreationOptions;\r\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\r\n    public get renderTargetOptions(): RenderTargetCreationOptions {\r\n        return this._renderTargetOptions;\r\n    }\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        let scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(1);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\r\n    public get depthStencilTexture(): Nullable<InternalTexture> {\r\n        return this.getInternalTexture()?._depthStencilTexture || null;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse\r\n     * or used a shadow, depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.\r\n     * @param generateMipMaps True if mip maps need to be generated after render.\r\n     * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT\r\n     * @param type The type of the buffer in the RTT (int, half float, float...)\r\n     * @param isCube True if a cube texture needs to be created\r\n     * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)\r\n     * @param generateDepthBuffer True to generate a depth buffer\r\n     * @param generateStencilBuffer True to generate a stencil buffer\r\n     * @param isMulti True if multiple textures need to be created (Draw Buffers)\r\n     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(name: string, size: number | { width: number, height: number, layers?: number } | { ratio: number }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio: boolean = true, type: number = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false) {\r\n        super(null, scene, !generateMipMaps);\r\n        scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._coordinatesMode = Texture.PROJECTION_MODE;\r\n        this.renderList = new Array<AbstractMesh>();\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._initialSizeParameter = size;\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        this._resizeObserver = this.getScene()!.getEngine().onResizeObservable.add(() => {\r\n        });\r\n\r\n        this._generateMipMaps = generateMipMaps ? true : false;\r\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\r\n\r\n        // Rendering groups\r\n        this._renderingManager = new RenderingManager(scene);\r\n        this._renderingManager._useSceneAutoClearSetup = true;\r\n\r\n        if (isMulti) {\r\n            return;\r\n        }\r\n\r\n        this._renderTargetOptions = {\r\n            generateMipMaps: generateMipMaps,\r\n            type: type,\r\n            format: format,\r\n            samplingMode: samplingMode,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer\r\n        };\r\n\r\n        if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (!delayAllocation) {\r\n            if (isCube) {\r\n                this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\r\n                this._textureMatrix = Matrix.Identity();\r\n            } else {\r\n                this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a depth stencil texture.\r\n     * This is only available in WebGL 2 or with the depth texture extension available.\r\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode\r\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture\r\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture\r\n     */\r\n    public createDepthStencilTexture(comparisonFunction: number = 0, bilinearFiltering: boolean = true, generateStencil: boolean = false): void {\r\n        const internalTexture = this.getInternalTexture();\r\n        if (!this.getScene() || !internalTexture) {\r\n            return;\r\n        }\r\n\r\n        var engine = this.getScene()!.getEngine();\r\n        internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {\r\n            bilinearFiltering,\r\n            comparisonFunction,\r\n            generateStencil,\r\n            isCube: this.isCube\r\n        });\r\n    }\r\n\r\n    private _processSizeParameter(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        if ((<{ ratio: number }>size).ratio) {\r\n            this._sizeRatio = (<{ ratio: number }>size).ratio;\r\n            const engine = this._getEngine()!;\r\n            this._size = {\r\n                width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),\r\n                height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)\r\n            };\r\n        } else {\r\n            this._size = <number | { width: number, height: number, layers?: number }>size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._samples === value) {\r\n            return;\r\n        }\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Adds a post process to the render target rendering passes.\r\n     * @param postProcess define the post process to add\r\n     */\r\n    public addPostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcessManager) {\r\n            let scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            this._postProcessManager = new PostProcessManager(scene);\r\n            this._postProcesses = new Array<PostProcess>();\r\n        }\r\n\r\n        this._postProcesses.push(postProcess);\r\n        this._postProcesses[0].autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Clear all the post processes attached to the render target\r\n     * @param dispose define if the cleared post processesshould also be disposed (false by default)\r\n     */\r\n    public clearPostProcesses(dispose: boolean = false): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        if (dispose) {\r\n            for (var postProcess of this._postProcesses) {\r\n                postProcess.dispose();\r\n            }\r\n        }\r\n\r\n        this._postProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Remove one of the post process from the list of attached post processes to the texture\r\n     * @param postProcess define the post process to remove from the list\r\n     */\r\n    public removePostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        var index = this._postProcesses.indexOf(postProcess);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._postProcesses.splice(index, 1);\r\n\r\n        if (this._postProcesses.length > 0) {\r\n            this._postProcesses[0].autoClear = false;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (this._currentRefreshId === -1) { // At least render once\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render size of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderSize(): number {\r\n        return this.getRenderWidth();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render width of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderWidth(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).width;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render height of the texture.\r\n     * @returns the height of the render size\r\n     */\r\n    public getRenderHeight(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).height;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual number of layers of the texture.\r\n     * @returns the number of layers\r\n     */\r\n    public getRenderLayers(): number {\r\n        const layers = (<{ width: number, height: number, layers?: number }>this._size).layers;\r\n        if (layers) {\r\n            return layers;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture using a ratio.\r\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n     */\r\n    public scale(ratio: number): void {\r\n        var newSize = Math.max(1, this.getRenderSize() * ratio);\r\n\r\n        this.resize(newSize);\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        if (this.isCube) {\r\n            return this._textureMatrix;\r\n        }\r\n\r\n        return super.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to a new desired size.\r\n     * Be carrefull as it will recreate all the data in the new texture.\r\n     * @param size Define the new size. It can be:\r\n     *   - a number for squared texture,\r\n     *   - an object containing { width: number, height: number }\r\n     *   - or an object containing a ratio { ratio: number }\r\n     */\r\n    public resize(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        var wasCube = this.isCube;\r\n\r\n        this.releaseInternalTexture();\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        if (wasCube) {\r\n            this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n        } else {\r\n            this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n        }\r\n\r\n        if (this.onResizeObservable.hasObservers()) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    private _defaultRenderListPrepared: boolean;\r\n\r\n    /**\r\n     * Renders all the objects from the render list into the texture.\r\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (this.useCameraPostProcesses !== undefined) {\r\n            useCameraPostProcess = this.useCameraPostProcesses;\r\n        }\r\n\r\n        if (this._waitingRenderList) {\r\n            this.renderList = [];\r\n            for (var index = 0; index < this._waitingRenderList.length; index++) {\r\n                var id = this._waitingRenderList[index];\r\n                let mesh = scene.getMeshByID(id);\r\n                if (mesh) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n\r\n            this._waitingRenderList = undefined;\r\n        }\r\n\r\n        // Is predicate defined?\r\n        if (this.renderListPredicate) {\r\n            if (this.renderList) {\r\n                this.renderList.length = 0; // Clear previous renderList\r\n            } else {\r\n                this.renderList = [];\r\n            }\r\n\r\n            var scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n\r\n            var sceneMeshes = scene.meshes;\r\n\r\n            for (var index = 0; index < sceneMeshes.length; index++) {\r\n                var mesh = sceneMeshes[index];\r\n                if (this.renderListPredicate(mesh)) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        // Set custom projection.\r\n        // Needs to be before binding to prevent changing the aspect ratio.\r\n        let camera: Nullable<Camera>;\r\n        if (this.activeCamera) {\r\n            camera = this.activeCamera;\r\n            engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n\r\n            if (this.activeCamera !== scene.activeCamera) {\r\n                scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\r\n            }\r\n        }\r\n        else {\r\n            camera = scene.activeCamera;\r\n            if (camera) {\r\n                engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n            }\r\n        }\r\n\r\n        this._defaultRenderListPrepared = false;\r\n\r\n        if (this.is2DArray) {\r\n            for (let layer = 0; layer < this.getRenderLayers(); layer++) {\r\n                this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        }\r\n        else if (this.isCube) {\r\n            for (var face = 0; face < 6; face++) {\r\n                this.renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else {\r\n            this.renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n        }\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        if (scene.activeCamera) {\r\n            // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\r\n            if (scene.getEngine().scenes.length > 1 || (this.activeCamera && this.activeCamera !== scene.activeCamera)) {\r\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\r\n            }\r\n            engine.setViewport(scene.activeCamera.viewport);\r\n        }\r\n\r\n        scene.resetCachedMaterial();\r\n    }\r\n\r\n    private _bestReflectionRenderTargetDimension(renderDimension: number, scale: number): number {\r\n        let minimum = 128;\r\n        let x = renderDimension * scale;\r\n        let curved = Engine.NearestPOT(x + (minimum * minimum / (minimum + x)));\r\n\r\n        // Ensure we don't exceed the render dimension (while staying POT)\r\n        return Math.min(Engine.FloorPOT(renderDimension), curved);\r\n    }\r\n\r\n    private _prepareRenderingManager(currentRenderList: Array<AbstractMesh>, currentRenderListLength: number, camera: Nullable<Camera>, checkLayerMask: boolean): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._renderingManager.reset();\r\n\r\n        var sceneRenderId = scene.getRenderId();\r\n        for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\r\n            var mesh = currentRenderList[meshIndex];\r\n\r\n            if (mesh && !mesh.isBlocked) {\r\n                if (this.customIsReadyFunction) {\r\n                    if (!this.customIsReadyFunction(mesh, this.refreshRate)) {\r\n                        this.resetRefreshCounter();\r\n                        continue;\r\n                    }\r\n                }\r\n                else if (!mesh.isReady(this.refreshRate === 0)) {\r\n                    this.resetRefreshCounter();\r\n                    continue;\r\n                }\r\n\r\n                if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {\r\n                    mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, scene.activeCamera) : mesh.getLOD(scene.activeCamera);\r\n                    mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\r\n                }\r\n                if (!mesh._internalAbstractMeshDataInfo._currentLOD) {\r\n                    continue;\r\n                }\r\n\r\n                let meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;\r\n\r\n                meshToRender._preActivateForIntermediateRendering(sceneRenderId);\r\n\r\n                let isMasked;\r\n                if (checkLayerMask && camera) {\r\n                    isMasked = ((mesh.layerMask & camera.layerMask) === 0);\r\n                } else {\r\n                    isMasked = false;\r\n                }\r\n\r\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\r\n                    if (meshToRender !== mesh) {\r\n                        meshToRender._activate(sceneRenderId, true);\r\n                    }\r\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\r\n                        if (!mesh.isAnInstance) {\r\n                            meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\r\n                        } else {\r\n                            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\r\n                                meshToRender = mesh;\r\n                            }\r\n                        }\r\n                        meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;\r\n\r\n                        for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {\r\n                            var subMesh = meshToRender.subMeshes[subIndex];\r\n                            this._renderingManager.dispatch(subMesh, meshToRender);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\r\n            var particleSystem = scene.particleSystems[particleIndex];\r\n\r\n            let emitter: any = particleSystem.emitter;\r\n            if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (currentRenderList.indexOf(emitter) >= 0) {\r\n                this._renderingManager.dispatchParticles(particleSystem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @param faceIndex face index to bind to if this is a cubetexture\r\n     * @param layer defines the index of the texture to bind in the array\r\n     */\r\n    public _bindFrameBuffer(faceIndex: number = 0, layer = 0) {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n        if (this._texture) {\r\n            engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\r\n        }\r\n    }\r\n\r\n    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        engine.unBindFramebuffer(this._texture, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    private renderToTarget(faceIndex: number, useCameraPostProcess: boolean, dumpForDebug: boolean, layer = 0, camera: Nullable<Camera> = null): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        // Bind\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\r\n        }\r\n        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\r\n            this._bindFrameBuffer(faceIndex, layer);\r\n        }\r\n\r\n        if (this.is2DArray) {\r\n            this.onBeforeRenderObservable.notifyObservers(layer);\r\n        }\r\n        else {\r\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n\r\n        // Get the list of meshes to render\r\n        let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n        let defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\r\n        let defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\r\n\r\n        if (this.getCustomRenderList) {\r\n            currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\r\n        }\r\n\r\n        if (!currentRenderList) {\r\n            // No custom render list provided, we prepare the rendering for the default list, but check\r\n            // first if we did not already performed the preparation before so as to avoid re-doing it several times\r\n            if (!this._defaultRenderListPrepared) {\r\n                this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);\r\n                this._defaultRenderListPrepared = true;\r\n            }\r\n            currentRenderList = defaultRenderList;\r\n        } else {\r\n            // Prepare the rendering for the custom render list provided\r\n            this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);\r\n        }\r\n\r\n        // Clear\r\n        if (this.onClearObservable.hasObservers()) {\r\n            this.onClearObservable.notifyObservers(engine);\r\n        } else {\r\n            engine.clear(this.clearColor || scene.clearColor, true, true, true);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Before Camera Draw\r\n        for (let step of scene._beforeRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        // Render\r\n        this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\r\n\r\n        // After Camera Draw\r\n        for (let step of scene._afterRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);\r\n        }\r\n        else if (useCameraPostProcess) {\r\n            scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Dump ?\r\n        if (dumpForDebug) {\r\n            Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\r\n        }\r\n\r\n        // Unbind\r\n        if (!this.isCube || faceIndex === 5) {\r\n            if (this.isCube) {\r\n\r\n                if (faceIndex === 5) {\r\n                    engine.generateMipMapsForCubemap(this._texture);\r\n                }\r\n            }\r\n\r\n            this.unbindFrameBuffer(engine, faceIndex);\r\n\r\n        } else {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null): void {\r\n\r\n        this._renderingManager.setRenderingOrder(renderingGroupId,\r\n            opaqueSortCompareFn,\r\n            alphaTestSortCompareFn,\r\n            transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n        this._renderingManager._useSceneAutoClearSetup = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): RenderTargetTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new RenderTargetTexture(\r\n            this.name,\r\n            textureSize,\r\n            this.getScene(),\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._doNotChangeAspectRatio,\r\n            this._renderTargetOptions.type,\r\n            this.isCube,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer,\r\n            this._renderTargetOptions.generateStencilBuffer\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject = super.serialize();\r\n\r\n        serializationObject.renderTargetSize = this.getRenderSize();\r\n        serializationObject.renderList = [];\r\n\r\n        if (this.renderList) {\r\n            for (var index = 0; index < this.renderList.length; index++) {\r\n                serializationObject.renderList.push(this.renderList[index].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n     */\r\n    public disposeFramebufferObjects(): void {\r\n        let objBuffer = this.getInternalTexture();\r\n        let scene = this.getScene();\r\n        if (objBuffer && scene) {\r\n            scene.getEngine()._releaseFramebufferObjects(objBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.onResizeObservable.clear();\r\n        this.onClearObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onAfterUnbindObservable.clear();\r\n        this.onBeforeBindObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager.dispose();\r\n            this._postProcessManager = null;\r\n        }\r\n\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._resizeObserver) {\r\n            this.getScene()!.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this.renderList = null;\r\n\r\n        // Remove from custom render targets\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var index = scene.customRenderTargets.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        for (var camera of scene.cameras) {\r\n            index = camera.customRenderTargets.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                camera.customRenderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.depthStencilTexture) {\r\n            this.getScene()!.getEngine()._releaseTexture(this.depthStencilTexture);\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nTexture._CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => {\r\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}