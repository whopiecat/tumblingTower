{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { VideoTexture } from \"../Materials/Textures/videoTexture\";\nimport { TextureDome } from \"./textureDome\";\n/**\r\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\r\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\n\nvar VideoDome =\n/** @class */\nfunction (_super) {\n  __extends(VideoDome, _super);\n\n  function VideoDome() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(VideoDome.prototype, \"videoTexture\", {\n    /**\r\n     * Get the video texture associated with this video dome\r\n     */\n    get: function () {\n      return this._texture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(VideoDome.prototype, \"videoMode\", {\n    /**\r\n     * Get the video mode of this dome\r\n     */\n    get: function () {\n      return this.textureMode;\n    },\n\n    /**\r\n     * Set the video mode of this dome.\r\n     * @see textureMode\r\n     */\n    set: function (value) {\n      this.textureMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VideoDome.prototype._initTexture = function (urlsOrElement, scene, options) {\n    var _this = this;\n\n    var tempOptions = {\n      loop: options.loop,\n      autoPlay: options.autoPlay,\n      autoUpdateTexture: true,\n      poster: options.poster\n    };\n    var texture = new VideoTexture((this.name || \"videoDome\") + \"_texture\", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions); // optional configuration\n\n    if (options.clickToPlay) {\n      scene.onPointerUp = function () {\n        _this._texture.video.play();\n      };\n    }\n\n    return texture;\n  };\n  /**\r\n   * Define the video source as a Monoscopic panoramic 360 video.\r\n   */\n\n\n  VideoDome.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\n  /**\r\n   * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\r\n   */\n\n  VideoDome.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\n  /**\r\n   * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\r\n   */\n\n  VideoDome.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;\n  return VideoDome;\n}(TextureDome);\n\nexport { VideoDome };","map":{"version":3,"sources":["../../../sourceES6/core/Helpers/videoDome.ts"],"names":[],"mappings":";AACA,SAAS,OAAT,QAAwB,+BAAxB;AACA,SAAS,YAAT,QAAmD,oCAAnD;AACA,SAAS,WAAT,QAA4B,eAA5B;AAIA;;;;;;;AAMA,IAAA,SAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA+B,EAAA,SAAA,CAAA,SAAA,EAAA,MAAA,CAAA;;AAA/B,WAAA,SAAA,GAAA;;AA6CC;;AA5BG,EAAA,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAZ;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAMA,EAAA,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA,YAAA;AACI,aAAO,KAAK,WAAZ;AACH,KAFmB;;AAGpB;;;;SAIA,UAAqB,KAArB,EAAkC;AAC9B,WAAK,WAAL,GAAmB,KAAnB;AACH,KATmB;qBAAA;;AAAA,GAApB;;AAWU,EAAA,SAAA,CAAA,SAAA,CAAA,YAAA,GAAV,UAAuB,aAAvB,EAA4E,KAA5E,EAA0F,OAA1F,EAAsG;AAAtG,QAAA,KAAA,GAAA,IAAA;;AACI,QAAM,WAAW,GAAyB;AAAE,MAAA,IAAI,EAAE,OAAO,CAAC,IAAhB;AAAsB,MAAA,QAAQ,EAAE,OAAO,CAAC,QAAxC;AAAkD,MAAA,iBAAiB,EAAE,IAArE;AAA2E,MAAA,MAAM,EAAE,OAAO,CAAC;AAA3F,KAA1C;AACA,QAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,CAAC,KAAK,IAAL,IAAa,WAAd,IAA6B,UAA9C,EAA0D,aAA1D,EAAyE,KAAzE,EAAgF,OAAO,CAAC,eAAxF,EAAyG,KAAK,iBAA9G,EAAiI,OAAO,CAAC,sBAAzI,EAAiK,WAAjK,CAAhB,CAFkG,CAGlG;;AACA,QAAI,OAAO,CAAC,WAAZ,EAAyB;AACrB,MAAA,KAAK,CAAC,WAAN,GAAoB,YAAA;AAChB,QAAA,KAAI,CAAC,QAAL,CAAc,KAAd,CAAoB,IAApB;AACH,OAFD;AAGH;;AACD,WAAO,OAAP;AACH,GAVS;AAjCV;;;;;AAGuB,EAAA,SAAA,CAAA,eAAA,GAAkB,WAAW,CAAC,eAA9B;AACvB;;;;AAGuB,EAAA,SAAA,CAAA,cAAA,GAAiB,WAAW,CAAC,cAA7B;AACvB;;;;AAGuB,EAAA,SAAA,CAAA,eAAA,GAAkB,WAAW,CAAC,eAA9B;AAiC3B,SAAA,SAAA;AAAC,CA7CD,CAA+B,WAA/B,CAAA;;SAAa,S","sourcesContent":["import { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { VideoTexture, VideoTextureSettings } from \"../Materials/Textures/videoTexture\";\r\nimport { TextureDome } from \"./textureDome\";\r\n\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\n\r\n/**\r\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\r\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport class VideoDome extends TextureDome<VideoTexture> {\r\n    /**\r\n     * Define the video source as a Monoscopic panoramic 360 video.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\r\n    /**\r\n     * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;\r\n\r\n    /**\r\n     * Get the video texture associated with this video dome\r\n     */\r\n    public get videoTexture(): VideoTexture {\r\n        return this._texture;\r\n    }\r\n    /**\r\n     * Get the video mode of this dome\r\n     */\r\n    public get videoMode(): number {\r\n        return this.textureMode;\r\n    }\r\n    /**\r\n     * Set the video mode of this dome.\r\n     * @see textureMode\r\n     */\r\n    public set videoMode(value: number) {\r\n        this.textureMode = value;\r\n    }\r\n\r\n    protected _initTexture(urlsOrElement: string | string[] | HTMLVideoElement, scene: Scene, options: any): VideoTexture {\r\n        const tempOptions: VideoTextureSettings = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };\r\n        const texture = new VideoTexture((this.name || \"videoDome\") + \"_texture\", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions);\r\n        // optional configuration\r\n        if (options.clickToPlay) {\r\n            scene.onPointerUp = () => {\r\n                this._texture.video.play();\r\n            };\r\n        }\r\n        return texture;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}