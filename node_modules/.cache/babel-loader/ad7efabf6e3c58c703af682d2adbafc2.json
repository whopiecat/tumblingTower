{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Color3 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { GroundMesh } from \"../groundMesh\";\nimport { Tools } from \"../../Misc/tools\";\nimport { EngineStore } from '../../Engines/engineStore';\nimport { Epsilon } from '../../Maths/math.constants';\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\n\nVertexData.CreateGround = function (options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var width = options.width || 1;\n  var height = options.height || 1;\n  var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n\n  for (row = 0; row <= subdivisionsY; row++) {\n    for (col = 0; col <= subdivisionsX; col++) {\n      var position = new Vector3(col * width / subdivisionsX - width / 2.0, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2.0);\n      var normal = new Vector3(0, 1.0, 0);\n      positions.push(position.x, position.y, position.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\n    }\n  }\n\n  for (row = 0; row < subdivisionsY; row++) {\n    for (col = 0; col < subdivisionsX; col++) {\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + row * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n      indices.push(col + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nVertexData.CreateTiledGround = function (options) {\n  var xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n  var zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n  var xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n  var zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n  var subdivisions = options.subdivisions || {\n    w: 1,\n    h: 1\n  };\n  var precision = options.precision || {\n    w: 1,\n    h: 1\n  };\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var row, col, tileRow, tileCol;\n  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n  precision.w = precision.w < 1 ? 1 : precision.w;\n  precision.h = precision.h < 1 ? 1 : precision.h;\n  var tileSize = {\n    'w': (xmax - xmin) / subdivisions.w,\n    'h': (zmax - zmin) / subdivisions.h\n  };\n\n  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n    // Indices\n    var base = positions.length / 3;\n    var rowLength = precision.w + 1;\n\n    for (row = 0; row < precision.h; row++) {\n      for (col = 0; col < precision.w; col++) {\n        var square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n        indices.push(square[1]);\n        indices.push(square[2]);\n        indices.push(square[3]);\n        indices.push(square[0]);\n        indices.push(square[1]);\n        indices.push(square[3]);\n      }\n    } // Position, normals and uvs\n\n\n    var position = Vector3.Zero();\n    var normal = new Vector3(0, 1.0, 0);\n\n    for (row = 0; row <= precision.h; row++) {\n      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;\n\n      for (col = 0; col <= precision.w; col++) {\n        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;\n        position.y = 0;\n        positions.push(position.x, position.y, position.z);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(col / precision.w, row / precision.h);\n      }\n    }\n  }\n\n  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nVertexData.CreateGroundFromHeightMap = function (options) {\n  var indices = [];\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var row, col;\n  var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  var alphaFilter = options.alphaFilter || 0.0;\n  var invert = false;\n\n  if (options.minHeight > options.maxHeight) {\n    invert = true;\n    var temp = options.maxHeight;\n    options.maxHeight = options.minHeight;\n    options.minHeight = temp;\n  } // Vertices\n\n\n  for (row = 0; row <= options.subdivisions; row++) {\n    for (col = 0; col <= options.subdivisions; col++) {\n      var position = new Vector3(col * options.width / options.subdivisions - options.width / 2.0, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2.0); // Compute height\n\n      var heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;\n      var heightMapY = (1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;\n      var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n      var r = options.buffer[pos] / 255.0;\n      var g = options.buffer[pos + 1] / 255.0;\n      var b = options.buffer[pos + 2] / 255.0;\n      var a = options.buffer[pos + 3] / 255.0;\n\n      if (invert) {\n        r = 1.0 - r;\n        g = 1.0 - g;\n        b = 1.0 - b;\n      }\n\n      var gradient = r * filter.r + g * filter.g + b * filter.b; // If our alpha channel is not within our filter then we will assign a 'special' height\n      // Then when building the indices, we will ignore any vertex that is using the special height\n\n      if (a >= alphaFilter) {\n        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n      } else {\n        position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n      } // Add  vertex\n\n\n      positions.push(position.x, position.y, position.z);\n      normals.push(0, 0, 0);\n      uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n    }\n  } // Indices\n\n\n  for (row = 0; row < options.subdivisions; row++) {\n    for (col = 0; col < options.subdivisions; col++) {\n      // Calculate Indices\n      var idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n      var idx2 = col + 1 + row * (options.subdivisions + 1);\n      var idx3 = col + row * (options.subdivisions + 1);\n      var idx4 = col + (row + 1) * (options.subdivisions + 1); // Check that all indices are visible (based on our special height)\n      // Only display the vertex if all Indices are visible\n      // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n\n      var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n      var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n        indices.push(idx1);\n        indices.push(idx2);\n        indices.push(idx3);\n      }\n\n      var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n\n      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n        indices.push(idx4);\n        indices.push(idx1);\n        indices.push(idx3);\n      }\n    }\n  } // Normals\n\n\n  VertexData.ComputeNormals(positions, indices, normals); // Result\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    updatable: updatable\n  };\n  return GroundBuilder.CreateGround(name, options, scene);\n};\n\nMesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\n  var options = {\n    xmin: xmin,\n    zmin: zmin,\n    xmax: xmax,\n    zmax: zmax,\n    subdivisions: subdivisions,\n    precision: precision,\n    updatable: updatable\n  };\n  return GroundBuilder.CreateTiledGround(name, options, scene);\n};\n\nMesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\n  var options = {\n    width: width,\n    height: height,\n    subdivisions: subdivisions,\n    minHeight: minHeight,\n    maxHeight: maxHeight,\n    updatable: updatable,\n    onReady: onReady,\n    alphaFilter: alphaFilter\n  };\n  return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar GroundBuilder =\n/** @class */\nfunction () {\n  function GroundBuilder() {}\n  /**\r\n   * Creates a ground mesh\r\n   * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n   * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the ground mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n   */\n\n\n  GroundBuilder.CreateGround = function (name, options, scene) {\n    var ground = new GroundMesh(name, scene);\n\n    ground._setReady(false);\n\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    ground._width = options.width || 1;\n    ground._height = options.height || 1;\n    ground._maxX = ground._width / 2;\n    ground._maxZ = ground._height / 2;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    var vertexData = VertexData.CreateGround(options);\n    vertexData.applyToMesh(ground, options.updatable);\n\n    ground._setReady(true);\n\n    return ground;\n  };\n  /**\r\n   * Creates a tiled ground mesh\r\n   * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n   * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n   * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n   * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the tiled ground mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n   */\n\n\n  GroundBuilder.CreateTiledGround = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var tiledGround = new Mesh(name, scene);\n    var vertexData = VertexData.CreateTiledGround(options);\n    vertexData.applyToMesh(tiledGround, options.updatable);\n    return tiledGround;\n  };\n  /**\r\n   * Creates a ground mesh from a height map\r\n   * * The parameter `url` sets the URL of the height map image resource.\r\n   * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n   * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n   * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n   * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n   * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n   * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n   * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param url defines the url to the height map\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the ground mesh\r\n   * @see https://doc.babylonjs.com/babylon101/height_map\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n   */\n\n\n  GroundBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var width = options.width || 10.0;\n    var height = options.height || 10.0;\n    var subdivisions = options.subdivisions || 1 | 0;\n    var minHeight = options.minHeight || 0.0;\n    var maxHeight = options.maxHeight || 1.0;\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    var alphaFilter = options.alphaFilter || 0.0;\n    var updatable = options.updatable;\n    var onReady = options.onReady;\n    scene = scene || EngineStore.LastCreatedScene;\n    var ground = new GroundMesh(name, scene);\n    ground._subdivisionsX = subdivisions;\n    ground._subdivisionsY = subdivisions;\n    ground._width = width;\n    ground._height = height;\n    ground._maxX = ground._width / 2.0;\n    ground._maxZ = ground._height / 2.0;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n\n    ground._setReady(false);\n\n    var onload = function (img) {\n      var bufferWidth = img.width;\n      var bufferHeight = img.height; // Getting height map data\n\n      var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);\n      var context = canvas.getContext(\"2d\");\n\n      if (!context) {\n        throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\n      }\n\n      if (scene.isDisposed) {\n        return;\n      }\n\n      context.drawImage(img, 0, 0); // Create VertexData from map data\n      // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n\n      var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\n      var vertexData = VertexData.CreateGroundFromHeightMap({\n        width: width,\n        height: height,\n        subdivisions: subdivisions,\n        minHeight: minHeight,\n        maxHeight: maxHeight,\n        colorFilter: filter,\n        buffer: buffer,\n        bufferWidth: bufferWidth,\n        bufferHeight: bufferHeight,\n        alphaFilter: alphaFilter\n      });\n      vertexData.applyToMesh(ground, updatable); //execute ready callback, if set\n\n      if (onReady) {\n        onReady(ground);\n      }\n\n      ground._setReady(true);\n    };\n\n    Tools.LoadImage(url, onload, function () {}, scene.offlineProvider);\n    return ground;\n  };\n\n  return GroundBuilder;\n}();\n\nexport { GroundBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/groundBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from '../../types';\r\nimport { EngineStore } from '../../Engines/engineStore';\r\nimport { Epsilon } from '../../Maths/math.constants';\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\nVertexData.CreateGround = function(options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row: number, col: number;\r\n\r\n    var width: number = options.width || 1;\r\n    var height: number = options.height || 1;\r\n    var subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    var subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            var position = new Vector3((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));\r\n            var normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateTiledGround = function(options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; } }): VertexData {\r\n    var xmin = (options.xmin !== undefined && options.xmin !== null) ? options.xmin : -1.0;\r\n    var zmin = (options.zmin !== undefined && options.zmin !== null) ? options.zmin : -1.0;\r\n    var xmax = (options.xmax !== undefined && options.xmax !== null) ? options.xmax : 1.0;\r\n    var zmax = (options.zmax !== undefined && options.zmax !== null) ? options.zmax : 1.0;\r\n    var subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    var precision = options.precision || { w: 1, h: 1 };\r\n\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n    var row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;\r\n    subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;\r\n    precision.w = (precision.w < 1) ? 1 : precision.w;\r\n    precision.h = (precision.h < 1) ? 1 : precision.h;\r\n\r\n    var tileSize = {\r\n        'w': (xmax - xmin) / subdivisions.w,\r\n        'h': (zmax - zmin) / subdivisions.h\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        var base = positions.length / 3;\r\n        var rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                var square = [\r\n                    base + col + row * rowLength,\r\n                    base + (col + 1) + row * rowLength,\r\n                    base + (col + 1) + (row + 1) * rowLength,\r\n                    base + col + (row + 1) * rowLength\r\n                ];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        var position = Vector3.Zero();\r\n        var normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(\r\n                xmin + tileCol * tileSize.w,\r\n                zmin + tileRow * tileSize.h,\r\n                xmin + (tileCol + 1) * tileSize.w,\r\n                zmin + (tileRow + 1) * tileSize.h\r\n            );\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateGroundFromHeightMap = function(options: { width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, colorFilter: Color3, buffer: Uint8Array, bufferWidth: number, bufferHeight: number, alphaFilter: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row, col;\r\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    var alphaFilter = options.alphaFilter || 0.0;\r\n    var invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        let temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            var position = new Vector3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));\r\n\r\n            // Compute height\r\n            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            var r = options.buffer[pos] / 255.0;\r\n            var g = options.buffer[pos + 1] / 255.0;\r\n            var b = options.buffer[pos + 2] / 255.0;\r\n            var a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            var gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            }\r\n            else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            var idx1 = (col + 1 + (row + 1) * (options.subdivisions + 1));\r\n            var idx2 = (col + 1 + row * (options.subdivisions + 1));\r\n            var idx3 = (col + row * (options.subdivisions + 1));\r\n            var idx4 = (col + (row + 1) * (options.subdivisions + 1));\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (name: string, xmin: number, zmin: number, xmax: number, zmax: number, subdivisions: { w: number; h: number; }, precision: { w: number; h: number; }, scene: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        xmin: xmin,\r\n        zmin: zmin,\r\n        xmax: xmax,\r\n        zmax: zmax,\r\n        subdivisions: subdivisions,\r\n        precision: precision,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean, onReady?: (mesh: GroundMesh) => void, alphaFilter?: number): GroundMesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        minHeight: minHeight,\r\n        maxHeight: maxHeight,\r\n        updatable: updatable,\r\n        onReady: onReady,\r\n        alphaFilter: alphaFilter\r\n    };\r\n\r\n    return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class GroundBuilder {\r\n    /**\r\n     * Creates a ground mesh\r\n     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n     */\r\n    public static CreateGround(name: string, options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number, updatable?: boolean }, scene: any): Mesh {\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._setReady(false);\r\n        ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n        ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n        ground._width = options.width || 1;\r\n        ground._height = options.height || 1;\r\n        ground._maxX = ground._width / 2;\r\n        ground._maxZ = ground._height / 2;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        var vertexData = VertexData.CreateGround(options);\r\n\r\n        vertexData.applyToMesh(ground, options.updatable);\r\n\r\n        ground._setReady(true);\r\n\r\n        return ground;\r\n    }\r\n\r\n    /**\r\n     * Creates a tiled ground mesh\r\n     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tiled ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n     */\r\n    public static CreateTiledGround(name: string, options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; }, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var tiledGround = new Mesh(name, scene);\r\n\r\n        var vertexData = VertexData.CreateTiledGround(options);\r\n\r\n        vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n        return tiledGround;\r\n    }\r\n\r\n    /**\r\n     * Creates a ground mesh from a height map\r\n     * * The parameter `url` sets the URL of the height map image resource.\r\n     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to the height map\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n     */\r\n    public static CreateGroundFromHeightMap(name: string, url: string, options: { width?: number, height?: number, subdivisions?: number, minHeight?: number, maxHeight?: number, colorFilter?: Color3, alphaFilter?: number, updatable?: boolean, onReady?: (mesh: GroundMesh) => void }, scene: Nullable<Scene> = null): GroundMesh {\r\n        var width = options.width || 10.0;\r\n        var height = options.height || 10.0;\r\n        var subdivisions = options.subdivisions || 1 | 0;\r\n        var minHeight = options.minHeight || 0.0;\r\n        var maxHeight = options.maxHeight || 1.0;\r\n        var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n        var alphaFilter = options.alphaFilter || 0.0;\r\n        var updatable = options.updatable;\r\n        var onReady = options.onReady;\r\n\r\n        scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._subdivisionsX = subdivisions;\r\n        ground._subdivisionsY = subdivisions;\r\n        ground._width = width;\r\n        ground._height = height;\r\n        ground._maxX = ground._width / 2.0;\r\n        ground._maxZ = ground._height / 2.0;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        ground._setReady(false);\r\n\r\n        var onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            var bufferWidth = img.width;\r\n            var bufferHeight = img.height;\r\n\r\n            // Getting height map data\r\n            var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);\r\n            var context = canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\r\n            }\r\n\r\n            if (scene!.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            context.drawImage(img, 0, 0);\r\n\r\n            // Create VertexData from map data\r\n            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            var buffer = <Uint8Array>(<any>context.getImageData(0, 0, bufferWidth, bufferHeight).data);\r\n            var vertexData = VertexData.CreateGroundFromHeightMap({\r\n                width: width, height: height,\r\n                subdivisions: subdivisions,\r\n                minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,\r\n                buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight,\r\n                alphaFilter: alphaFilter\r\n            });\r\n\r\n            vertexData.applyToMesh(ground, updatable);\r\n\r\n            //execute ready callback, if set\r\n            if (onReady) {\r\n                onReady(ground);\r\n            }\r\n\r\n            ground._setReady(true);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, () => { }, scene.offlineProvider);\r\n\r\n        return ground;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}