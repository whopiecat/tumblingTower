{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\n\nVertexData.CreateLineSystem = function (options) {\n  var indices = [];\n  var positions = [];\n  var lines = options.lines;\n  var colors = options.colors;\n  var vertexColors = [];\n  var idx = 0;\n\n  for (var l = 0; l < lines.length; l++) {\n    var points = lines[l];\n\n    for (var index = 0; index < points.length; index++) {\n      positions.push(points[index].x, points[index].y, points[index].z);\n\n      if (colors) {\n        var color = colors[l];\n        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n      }\n\n      if (index > 0) {\n        indices.push(idx - 1);\n        indices.push(idx);\n      }\n\n      idx++;\n    }\n  }\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n\n  if (colors) {\n    vertexData.colors = vertexColors;\n  }\n\n  return vertexData;\n};\n\nVertexData.CreateDashedLines = function (options) {\n  var dashSize = options.dashSize || 3;\n  var gapSize = options.gapSize || 1;\n  var dashNb = options.dashNb || 200;\n  var points = options.points;\n  var positions = new Array();\n  var indices = new Array();\n  var curvect = Vector3.Zero();\n  var lg = 0;\n  var nb = 0;\n  var shft = 0;\n  var dashshft = 0;\n  var curshft = 0;\n  var idx = 0;\n  var i = 0;\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    lg += curvect.length();\n  }\n\n  shft = lg / dashNb;\n  dashshft = dashSize * shft / (dashSize + gapSize);\n\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    nb = Math.floor(curvect.length() / shft);\n    curvect.normalize();\n\n    for (var j = 0; j < nb; j++) {\n      curshft = shft * j;\n      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n      indices.push(idx, idx + 1);\n      idx += 2;\n    }\n  } // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  return vertexData;\n};\n\nMesh.CreateLines = function (name, points, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  if (updatable === void 0) {\n    updatable = false;\n  }\n\n  if (instance === void 0) {\n    instance = null;\n  }\n\n  var options = {\n    points: points,\n    updatable: updatable,\n    instance: instance\n  };\n  return LinesBuilder.CreateLines(name, options, scene);\n};\n\nMesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    points: points,\n    dashSize: dashSize,\n    gapSize: gapSize,\n    dashNb: dashNb,\n    updatable: updatable,\n    instance: instance\n  };\n  return LinesBuilder.CreateDashedLines(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar LinesBuilder =\n/** @class */\nfunction () {\n  function LinesBuilder() {}\n  /**\r\n   * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n   * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n   * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n   * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n   * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n   * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n   * @param name defines the name of the new line system\r\n   * @param options defines the options used to create the line system\r\n   * @param scene defines the hosting scene\r\n   * @returns a new line system mesh\r\n   */\n\n\n  LinesBuilder.CreateLineSystem = function (name, options, scene) {\n    var instance = options.instance;\n    var lines = options.lines;\n    var colors = options.colors;\n\n    if (instance) {\n      // lines update\n      var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n      var vertexColor;\n      var lineColors;\n\n      if (colors) {\n        vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n      }\n\n      var i = 0;\n      var c = 0;\n\n      for (var l = 0; l < lines.length; l++) {\n        var points = lines[l];\n\n        for (var p = 0; p < points.length; p++) {\n          positions[i] = points[p].x;\n          positions[i + 1] = points[p].y;\n          positions[i + 2] = points[p].z;\n\n          if (colors && vertexColor) {\n            lineColors = colors[l];\n            vertexColor[c] = lineColors[p].r;\n            vertexColor[c + 1] = lineColors[p].g;\n            vertexColor[c + 2] = lineColors[p].b;\n            vertexColor[c + 3] = lineColors[p].a;\n            c += 4;\n          }\n\n          i += 3;\n        }\n      }\n\n      instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n      if (colors && vertexColor) {\n        instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n      }\n\n      return instance;\n    } // line system creation\n\n\n    var useVertexColor = colors ? true : false;\n    var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\n    var vertexData = VertexData.CreateLineSystem(options);\n    vertexData.applyToMesh(lineSystem, options.updatable);\n    return lineSystem;\n  };\n  /**\r\n   * Creates a line mesh\r\n   * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n   * * The parameter `points` is an array successive Vector3\r\n   * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n   * * When updating an instance, remember that only point positions can change, not the number of points\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n   * @param name defines the name of the new line system\r\n   * @param options defines the options used to create the line system\r\n   * @param scene defines the hosting scene\r\n   * @returns a new line mesh\r\n   */\n\n\n  LinesBuilder.CreateLines = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var colors = options.colors ? [options.colors] : null;\n    var lines = LinesBuilder.CreateLineSystem(name, {\n      lines: [options.points],\n      updatable: options.updatable,\n      instance: options.instance,\n      colors: colors,\n      useVertexAlpha: options.useVertexAlpha\n    }, scene);\n    return lines;\n  };\n  /**\r\n   * Creates a dashed line mesh\r\n   * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n   * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n   * * The parameter `points` is an array successive Vector3\r\n   * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n   * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n   * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n   * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n   * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n   * * When updating an instance, remember that only point positions can change, not the number of points\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the dashed line mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n   */\n\n\n  LinesBuilder.CreateDashedLines = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var points = options.points;\n    var instance = options.instance;\n    var gapSize = options.gapSize || 1;\n    var dashSize = options.dashSize || 3;\n\n    if (instance) {\n      //  dashed lines update\n      var positionFunction = function (positions) {\n        var curvect = Vector3.Zero();\n        var nbSeg = positions.length / 6;\n        var lg = 0;\n        var nb = 0;\n        var shft = 0;\n        var dashshft = 0;\n        var curshft = 0;\n        var p = 0;\n        var i = 0;\n        var j = 0;\n\n        for (i = 0; i < points.length - 1; i++) {\n          points[i + 1].subtractToRef(points[i], curvect);\n          lg += curvect.length();\n        }\n\n        shft = lg / nbSeg;\n        var dashSize = instance._creationDataStorage.dashSize;\n        var gapSize = instance._creationDataStorage.gapSize;\n        dashshft = dashSize * shft / (dashSize + gapSize);\n\n        for (i = 0; i < points.length - 1; i++) {\n          points[i + 1].subtractToRef(points[i], curvect);\n          nb = Math.floor(curvect.length() / shft);\n          curvect.normalize();\n          j = 0;\n\n          while (j < nb && p < positions.length) {\n            curshft = shft * j;\n            positions[p] = points[i].x + curshft * curvect.x;\n            positions[p + 1] = points[i].y + curshft * curvect.y;\n            positions[p + 2] = points[i].z + curshft * curvect.z;\n            positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n            positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n            positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n            p += 6;\n            j++;\n          }\n        }\n\n        while (p < positions.length) {\n          positions[p] = points[i].x;\n          positions[p + 1] = points[i].y;\n          positions[p + 2] = points[i].z;\n          p += 3;\n        }\n      };\n\n      instance.updateMeshPositions(positionFunction, false);\n      return instance;\n    } // dashed lines creation\n\n\n    var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha);\n    var vertexData = VertexData.CreateDashedLines(options);\n    vertexData.applyToMesh(dashedLines, options.updatable);\n    dashedLines._creationDataStorage = new _CreationDataStorage();\n    dashedLines._creationDataStorage.dashSize = dashSize;\n    dashedLines._creationDataStorage.gapSize = gapSize;\n    return dashedLines;\n  };\n\n  return LinesBuilder;\n}();\n\nexport { LinesBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/linesBuilder.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,QAAwB,yBAAxB;AAEA,SAAS,oBAAT,EAA+B,IAA/B,QAA2C,SAA3C;AACA,SAAS,UAAT,QAA2B,oBAA3B;AAEA,SAAS,SAAT,QAA0B,wBAA1B;AAEA,SAAS,YAAT,QAA6B,qBAA7B;;AAEA,UAAU,CAAC,gBAAX,GAA8B,UAAS,OAAT,EAAuE;AACjG,MAAI,OAAO,GAAG,EAAd;AACA,MAAI,SAAS,GAAG,EAAhB;AACA,MAAI,KAAK,GAAG,OAAO,CAAC,KAApB;AACA,MAAI,MAAM,GAAG,OAAO,CAAC,MAArB;AACA,MAAI,YAAY,GAAG,EAAnB;AACA,MAAI,GAAG,GAAG,CAAV;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,QAAI,MAAM,GAAG,KAAK,CAAC,CAAD,CAAlB;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,MAAM,CAAC,MAAnC,EAA2C,KAAK,EAAhD,EAAoD;AAChD,MAAA,SAAS,CAAC,IAAV,CAAe,MAAM,CAAC,KAAD,CAAN,CAAc,CAA7B,EAAgC,MAAM,CAAC,KAAD,CAAN,CAAc,CAA9C,EAAiD,MAAM,CAAC,KAAD,CAAN,CAAc,CAA/D;;AACA,UAAI,MAAJ,EAAY;AACR,YAAI,KAAK,GAAG,MAAM,CAAC,CAAD,CAAlB;AACA,QAAA,YAAY,CAAC,IAAb,CAAkB,KAAK,CAAC,KAAD,CAAL,CAAa,CAA/B,EAAkC,KAAK,CAAC,KAAD,CAAL,CAAa,CAA/C,EAAkD,KAAK,CAAC,KAAD,CAAL,CAAa,CAA/D,EAAkE,KAAK,CAAC,KAAD,CAAL,CAAa,CAA/E;AACH;;AACD,UAAI,KAAK,GAAG,CAAZ,EAAe;AACX,QAAA,OAAO,CAAC,IAAR,CAAa,GAAG,GAAG,CAAnB;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,GAAb;AACH;;AACD,MAAA,GAAG;AACN;AACJ;;AACD,MAAI,UAAU,GAAG,IAAI,UAAJ,EAAjB;AACA,EAAA,UAAU,CAAC,OAAX,GAAqB,OAArB;AACA,EAAA,UAAU,CAAC,SAAX,GAAuB,SAAvB;;AACA,MAAI,MAAJ,EAAY;AACR,IAAA,UAAU,CAAC,MAAX,GAAoB,YAApB;AACH;;AACD,SAAO,UAAP;AACH,CA9BD;;AAgCA,UAAU,CAAC,iBAAX,GAA+B,UAAS,OAAT,EAA6F;AACxH,MAAI,QAAQ,GAAG,OAAO,CAAC,QAAR,IAAoB,CAAnC;AACA,MAAI,OAAO,GAAG,OAAO,CAAC,OAAR,IAAmB,CAAjC;AACA,MAAI,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,GAA/B;AACA,MAAI,MAAM,GAAG,OAAO,CAAC,MAArB;AAEA,MAAI,SAAS,GAAG,IAAI,KAAJ,EAAhB;AACA,MAAI,OAAO,GAAG,IAAI,KAAJ,EAAd;AAEA,MAAI,OAAO,GAAG,OAAO,CAAC,IAAR,EAAd;AACA,MAAI,EAAE,GAAG,CAAT;AACA,MAAI,EAAE,GAAG,CAAT;AACA,MAAI,IAAI,GAAG,CAAX;AACA,MAAI,QAAQ,GAAG,CAAf;AACA,MAAI,OAAO,GAAG,CAAd;AACA,MAAI,GAAG,GAAG,CAAV;AACA,MAAI,CAAC,GAAG,CAAR;;AACA,OAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC,EAAmC,CAAC,EAApC,EAAwC;AACpC,IAAA,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,CAAc,aAAd,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,OAAvC;AACA,IAAA,EAAE,IAAI,OAAO,CAAC,MAAR,EAAN;AACH;;AACD,EAAA,IAAI,GAAG,EAAE,GAAG,MAAZ;AACA,EAAA,QAAQ,GAAG,QAAQ,GAAG,IAAX,IAAmB,QAAQ,GAAG,OAA9B,CAAX;;AACA,OAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC,EAAmC,CAAC,EAApC,EAAwC;AACpC,IAAA,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,CAAc,aAAd,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,OAAvC;AACA,IAAA,EAAE,GAAG,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,MAAR,KAAmB,IAA9B,CAAL;AACA,IAAA,OAAO,CAAC,SAAR;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAApB,EAAwB,CAAC,EAAzB,EAA6B;AACzB,MAAA,OAAO,GAAG,IAAI,GAAG,CAAjB;AACA,MAAA,SAAS,CAAC,IAAV,CAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAA/C,EAAkD,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAAlF,EAAqF,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAArH;AACA,MAAA,SAAS,CAAC,IAAV,CAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAA5D,EAA+D,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAA5G,EAA+G,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAA5J;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,GAAb,EAAkB,GAAG,GAAG,CAAxB;AACA,MAAA,GAAG,IAAI,CAAP;AACH;AACJ,GAlCuH,CAoCxH;;;AACA,MAAI,UAAU,GAAG,IAAI,UAAJ,EAAjB;AACA,EAAA,UAAU,CAAC,SAAX,GAAuB,SAAvB;AACA,EAAA,UAAU,CAAC,OAAX,GAAqB,OAArB;AAEA,SAAO,UAAP;AACH,CA1CD;;AA4CA,IAAI,CAAC,WAAL,GAAmB,UAAC,IAAD,EAAe,MAAf,EAAkC,KAAlC,EAAiE,SAAjE,EAA6F,QAA7F,EAAiI;AAA/F,MAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,KAAA,GAAA,IAAA;AAA6B;;AAAE,MAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,SAAA,GAAA,KAAA;AAA0B;;AAAE,MAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,QAAA,GAAA,IAAA;AAAoC;;AAChJ,MAAI,OAAO,GAAG;AACV,IAAA,MAAM,EAAE,MADE;AAEV,IAAA,SAAS,EAAE,SAFD;AAGV,IAAA,QAAQ,EAAE;AAHA,GAAd;AAKA,SAAO,YAAY,CAAC,WAAb,CAAyB,IAAzB,EAA+B,OAA/B,EAAwC,KAAxC,CAAP;AACH,CAPD;;AASA,IAAI,CAAC,iBAAL,GAAyB,UAAC,IAAD,EAAe,MAAf,EAAkC,QAAlC,EAAoD,OAApD,EAAqE,MAArE,EAAqF,KAArF,EAAoH,SAApH,EAAyI,QAAzI,EAA6J;AAAxE,MAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,KAAA,GAAA,IAAA;AAA6B;;AACvI,MAAI,OAAO,GAAG;AACV,IAAA,MAAM,EAAE,MADE;AAEV,IAAA,QAAQ,EAAE,QAFA;AAGV,IAAA,OAAO,EAAE,OAHC;AAIV,IAAA,MAAM,EAAE,MAJE;AAKV,IAAA,SAAS,EAAE,SALD;AAMV,IAAA,QAAQ,EAAE;AANA,GAAd;AAQA,SAAO,YAAY,CAAC,iBAAb,CAA+B,IAA/B,EAAqC,OAArC,EAA8C,KAA9C,CAAP;AACH,CAVD;AAYA;;;;;AAGA,IAAA,YAAA;AAAA;AAAA,YAAA;AAAA,WAAA,YAAA,GAAA,CAuKC;AAtKG;;;;;;;;;;;;;;;;;;;AAiBc,EAAA,YAAA,CAAA,gBAAA,GAAd,UAA+B,IAA/B,EAA6C,OAA7C,EAA4L,KAA5L,EAAkN;AAC9M,QAAI,QAAQ,GAAG,OAAO,CAAC,QAAvB;AACA,QAAI,KAAK,GAAG,OAAO,CAAC,KAApB;AACA,QAAI,MAAM,GAAG,OAAO,CAAC,MAArB;;AAEA,QAAI,QAAJ,EAAc;AAAE;AACZ,UAAI,SAAS,GAAG,QAAQ,CAAC,eAAT,CAAyB,YAAY,CAAC,YAAtC,CAAhB;AACA,UAAI,WAAJ;AACA,UAAI,UAAJ;;AACA,UAAI,MAAJ,EAAY;AACR,QAAA,WAAW,GAAG,QAAQ,CAAC,eAAT,CAAyB,YAAY,CAAC,SAAtC,CAAd;AACH;;AACD,UAAI,CAAC,GAAG,CAAR;AACA,UAAI,CAAC,GAAG,CAAR;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,YAAI,MAAM,GAAG,KAAK,CAAC,CAAD,CAAlB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACpC,UAAA,SAAS,CAAC,CAAD,CAAT,GAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAzB;AACA,UAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAA7B;AACA,UAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAA7B;;AACA,cAAI,MAAM,IAAI,WAAd,EAA2B;AACvB,YAAA,UAAU,GAAG,MAAM,CAAC,CAAD,CAAnB;AACA,YAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,UAAU,CAAC,CAAD,CAAV,CAAc,CAA/B;AACA,YAAA,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,GAAqB,UAAU,CAAC,CAAD,CAAV,CAAc,CAAnC;AACA,YAAA,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,GAAqB,UAAU,CAAC,CAAD,CAAV,CAAc,CAAnC;AACA,YAAA,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,GAAqB,UAAU,CAAC,CAAD,CAAV,CAAc,CAAnC;AACA,YAAA,CAAC,IAAI,CAAL;AACH;;AACD,UAAA,CAAC,IAAI,CAAL;AACH;AACJ;;AACD,MAAA,QAAQ,CAAC,kBAAT,CAA4B,YAAY,CAAC,YAAzC,EAAuD,SAAvD,EAAkE,KAAlE,EAAyE,KAAzE;;AACA,UAAI,MAAM,IAAI,WAAd,EAA2B;AACvB,QAAA,QAAQ,CAAC,kBAAT,CAA4B,YAAY,CAAC,SAAzC,EAAoD,WAApD,EAAiE,KAAjE,EAAwE,KAAxE;AACH;;AACD,aAAO,QAAP;AACH,KApC6M,CAsC9M;;;AACA,QAAI,cAAc,GAAI,MAAD,GAAW,IAAX,GAAkB,KAAvC;AACA,QAAI,UAAU,GAAG,IAAI,SAAJ,CAAc,IAAd,EAAoB,KAApB,EAA2B,IAA3B,EAAiC,SAAjC,EAA4C,SAA5C,EAAuD,cAAvD,EAAuE,OAAO,CAAC,cAA/E,CAAjB;AACA,QAAI,UAAU,GAAG,UAAU,CAAC,gBAAX,CAA4B,OAA5B,CAAjB;AACA,IAAA,UAAU,CAAC,WAAX,CAAuB,UAAvB,EAAmC,OAAO,CAAC,SAA3C;AACA,WAAO,UAAP;AACH,GA5Ca;AA8Cd;;;;;;;;;;;;;;;;;;AAgBc,EAAA,YAAA,CAAA,WAAA,GAAd,UAA0B,IAA1B,EAAwC,OAAxC,EAA0K,KAA1K,EAAuM;AAA7B,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA6B;;AACnM,QAAI,MAAM,GAAI,OAAO,CAAC,MAAT,GAAmB,CAAC,OAAO,CAAC,MAAT,CAAnB,GAAsC,IAAnD;AACA,QAAI,KAAK,GAAG,YAAY,CAAC,gBAAb,CAA8B,IAA9B,EAAoC;AAAE,MAAA,KAAK,EAAE,CAAC,OAAO,CAAC,MAAT,CAAT;AAA2B,MAAA,SAAS,EAAE,OAAO,CAAC,SAA9C;AAAyD,MAAA,QAAQ,EAAE,OAAO,CAAC,QAA3E;AAAqF,MAAA,MAAM,EAAE,MAA7F;AAAqG,MAAA,cAAc,EAAE,OAAO,CAAC;AAA7H,KAApC,EAAmL,KAAnL,CAAZ;AACA,WAAO,KAAP;AACH,GAJa;AAMd;;;;;;;;;;;;;;;;;;;;AAkBc,EAAA,YAAA,CAAA,iBAAA,GAAd,UAAgC,IAAhC,EAA8C,OAA9C,EAAyM,KAAzM,EAAsO;AAA7B,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA6B;;AAClO,QAAI,MAAM,GAAG,OAAO,CAAC,MAArB;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,QAAvB;AACA,QAAI,OAAO,GAAG,OAAO,CAAC,OAAR,IAAmB,CAAjC;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,QAAR,IAAoB,CAAnC;;AAEA,QAAI,QAAJ,EAAc;AAAG;AACb,UAAI,gBAAgB,GAAG,UAAC,SAAD,EAAsB;AACzC,YAAI,OAAO,GAAG,OAAO,CAAC,IAAR,EAAd;AACA,YAAI,KAAK,GAAG,SAAS,CAAC,MAAV,GAAmB,CAA/B;AACA,YAAI,EAAE,GAAG,CAAT;AACA,YAAI,EAAE,GAAG,CAAT;AACA,YAAI,IAAI,GAAG,CAAX;AACA,YAAI,QAAQ,GAAG,CAAf;AACA,YAAI,OAAO,GAAG,CAAd;AACA,YAAI,CAAC,GAAG,CAAR;AACA,YAAI,CAAC,GAAG,CAAR;AACA,YAAI,CAAC,GAAG,CAAR;;AACA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC,EAAmC,CAAC,EAApC,EAAwC;AACpC,UAAA,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,CAAc,aAAd,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,OAAvC;AACA,UAAA,EAAE,IAAI,OAAO,CAAC,MAAR,EAAN;AACH;;AACD,QAAA,IAAI,GAAG,EAAE,GAAG,KAAZ;AACA,YAAI,QAAQ,GAAG,QAAS,CAAC,oBAAV,CAAgC,QAA/C;AACA,YAAI,OAAO,GAAG,QAAS,CAAC,oBAAV,CAAgC,OAA9C;AACA,QAAA,QAAQ,GAAG,QAAQ,GAAG,IAAX,IAAmB,QAAQ,GAAG,OAA9B,CAAX;;AACA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC,EAAmC,CAAC,EAApC,EAAwC;AACpC,UAAA,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,CAAc,aAAd,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,OAAvC;AACA,UAAA,EAAE,GAAG,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,MAAR,KAAmB,IAA9B,CAAL;AACA,UAAA,OAAO,CAAC,SAAR;AACA,UAAA,CAAC,GAAG,CAAJ;;AACA,iBAAO,CAAC,GAAG,EAAJ,IAAU,CAAC,GAAG,SAAS,CAAC,MAA/B,EAAuC;AACnC,YAAA,OAAO,GAAG,IAAI,GAAG,CAAjB;AACA,YAAA,SAAS,CAAC,CAAD,CAAT,GAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAA/C;AACA,YAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAAnD;AACA,YAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,OAAO,GAAG,OAAO,CAAC,CAAnD;AACA,YAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAAhE;AACA,YAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAAhE;AACA,YAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAAV,GAAc,CAAC,OAAO,GAAG,QAAX,IAAuB,OAAO,CAAC,CAAhE;AACA,YAAA,CAAC,IAAI,CAAL;AACA,YAAA,CAAC;AACJ;AACJ;;AACD,eAAO,CAAC,GAAG,SAAS,CAAC,MAArB,EAA6B;AACzB,UAAA,SAAS,CAAC,CAAD,CAAT,GAAe,MAAM,CAAC,CAAD,CAAN,CAAU,CAAzB;AACA,UAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAA7B;AACA,UAAA,SAAS,CAAC,CAAC,GAAG,CAAL,CAAT,GAAmB,MAAM,CAAC,CAAD,CAAN,CAAU,CAA7B;AACA,UAAA,CAAC,IAAI,CAAL;AACH;AACJ,OA1CD;;AA2CA,MAAA,QAAQ,CAAC,mBAAT,CAA6B,gBAA7B,EAA+C,KAA/C;AACA,aAAO,QAAP;AACH,KApDiO,CAqDlO;;;AACA,QAAI,WAAW,GAAG,IAAI,SAAJ,CAAc,IAAd,EAAoB,KAApB,EAA2B,IAA3B,EAAiC,SAAjC,EAA4C,SAA5C,EAAuD,SAAvD,EAAkE,OAAO,CAAC,cAA1E,CAAlB;AACA,QAAI,UAAU,GAAG,UAAU,CAAC,iBAAX,CAA6B,OAA7B,CAAjB;AACA,IAAA,UAAU,CAAC,WAAX,CAAuB,WAAvB,EAAoC,OAAO,CAAC,SAA5C;AAEA,IAAA,WAAW,CAAC,oBAAZ,GAAmC,IAAI,oBAAJ,EAAnC;AACA,IAAA,WAAW,CAAC,oBAAZ,CAAiC,QAAjC,GAA4C,QAA5C;AACA,IAAA,WAAW,CAAC,oBAAZ,CAAiC,OAAjC,GAA2C,OAA3C;AACA,WAAO,WAAP;AACH,GA9Da;;AA+DlB,SAAA,YAAA;AAAC,CAvKD,EAAA","sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\n\r\nVertexData.CreateLineSystem = function(options: { lines: Vector3[][], colors?: Nullable<Color4[][]> }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var lines = options.lines;\r\n    var colors = options.colors;\r\n    var vertexColors = [];\r\n    var idx = 0;\r\n\r\n    for (var l = 0; l < lines.length; l++) {\r\n        var points = lines[l];\r\n        for (var index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                var color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateDashedLines = function(options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number }): VertexData {\r\n    var dashSize = options.dashSize || 3;\r\n    var gapSize = options.gapSize || 1;\r\n    var dashNb = options.dashNb || 200;\r\n    var points = options.points;\r\n\r\n    var positions = new Array<number>();\r\n    var indices = new Array<number>();\r\n\r\n    var curvect = Vector3.Zero();\r\n    var lg = 0;\r\n    var nb = 0;\r\n    var shft = 0;\r\n    var dashshft = 0;\r\n    var curshft = 0;\r\n    var idx = 0;\r\n    var i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = dashSize * shft / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (var j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (name: string, points: Vector3[], dashSize: number, gapSize: number, dashNb: number, scene: Nullable<Scene> = null, updatable?: boolean, instance?: LinesMesh): LinesMesh => {\r\n    var options = {\r\n        points: points,\r\n        dashSize: dashSize,\r\n        gapSize: gapSize,\r\n        dashNb: dashNb,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateDashedLines(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class LinesBuilder {\r\n    /**\r\n     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line system mesh\r\n     */\r\n    public static CreateLineSystem(name: string, options: { lines: Vector3[][], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Nullable<Color4[][]>, useVertexAlpha?: boolean }, scene: Nullable<Scene>): LinesMesh {\r\n        var instance = options.instance;\r\n        var lines = options.lines;\r\n        var colors = options.colors;\r\n\r\n        if (instance) { // lines update\r\n            var positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n            var vertexColor;\r\n            var lineColors;\r\n            if (colors) {\r\n                vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n            }\r\n            var i = 0;\r\n            var c = 0;\r\n            for (var l = 0; l < lines.length; l++) {\r\n                var points = lines[l];\r\n                for (var p = 0; p < points.length; p++) {\r\n                    positions[i] = points[p].x;\r\n                    positions[i + 1] = points[p].y;\r\n                    positions[i + 2] = points[p].z;\r\n                    if (colors && vertexColor) {\r\n                        lineColors = colors[l];\r\n                        vertexColor[c] = lineColors[p].r;\r\n                        vertexColor[c + 1] = lineColors[p].g;\r\n                        vertexColor[c + 2] = lineColors[p].b;\r\n                        vertexColor[c + 3] = lineColors[p].a;\r\n                        c += 4;\r\n                    }\r\n                    i += 3;\r\n                }\r\n            }\r\n            instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n            if (colors && vertexColor) {\r\n                instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n            }\r\n            return instance;\r\n        }\r\n\r\n        // line system creation\r\n        var useVertexColor = (colors) ? true : false;\r\n        var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateLineSystem(options);\r\n        vertexData.applyToMesh(lineSystem, options.updatable);\r\n        return lineSystem;\r\n    }\r\n\r\n    /**\r\n     * Creates a line mesh\r\n     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line mesh\r\n     */\r\n    public static CreateLines(name: string, options: { points: Vector3[], updatable?: boolean, instance?: Nullable<LinesMesh>, colors?: Color4[], useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var colors = (options.colors) ? [options.colors] : null;\r\n        var lines = LinesBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha }, scene);\r\n        return lines;\r\n    }\r\n\r\n    /**\r\n     * Creates a dashed line mesh\r\n     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the dashed line mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n     */\r\n    public static CreateDashedLines(name: string, options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number, updatable?: boolean, instance?: LinesMesh, useVertexAlpha?: boolean }, scene: Nullable<Scene> = null): LinesMesh {\r\n        var points = options.points;\r\n        var instance = options.instance;\r\n        var gapSize = options.gapSize || 1;\r\n        var dashSize = options.dashSize || 3;\r\n\r\n        if (instance) {  //  dashed lines update\r\n            var positionFunction = (positions: FloatArray): void => {\r\n                var curvect = Vector3.Zero();\r\n                var nbSeg = positions.length / 6;\r\n                var lg = 0;\r\n                var nb = 0;\r\n                var shft = 0;\r\n                var dashshft = 0;\r\n                var curshft = 0;\r\n                var p = 0;\r\n                var i = 0;\r\n                var j = 0;\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    lg += curvect.length();\r\n                }\r\n                shft = lg / nbSeg;\r\n                let dashSize = instance!._creationDataStorage!.dashSize;\r\n                let gapSize = instance!._creationDataStorage!.gapSize;\r\n                dashshft = dashSize * shft / (dashSize + gapSize);\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    nb = Math.floor(curvect.length() / shft);\r\n                    curvect.normalize();\r\n                    j = 0;\r\n                    while (j < nb && p < positions.length) {\r\n                        curshft = shft * j;\r\n                        positions[p] = points[i].x + curshft * curvect.x;\r\n                        positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                        positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                        positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                        positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                        positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                        p += 6;\r\n                        j++;\r\n                    }\r\n                }\r\n                while (p < positions.length) {\r\n                    positions[p] = points[i].x;\r\n                    positions[p + 1] = points[i].y;\r\n                    positions[p + 2] = points[i].z;\r\n                    p += 3;\r\n                }\r\n            };\r\n            instance.updateMeshPositions(positionFunction, false);\r\n            return instance;\r\n        }\r\n        // dashed lines creation\r\n        var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha);\r\n        var vertexData = VertexData.CreateDashedLines(options);\r\n        vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n        dashedLines._creationDataStorage = new _CreationDataStorage();\r\n        dashedLines._creationDataStorage.dashSize = dashSize;\r\n        dashedLines._creationDataStorage.gapSize = gapSize;\r\n        return dashedLines;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}