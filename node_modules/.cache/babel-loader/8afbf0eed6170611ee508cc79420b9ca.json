{"ast":null,"code":"import { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\nimport { ActionEvent } from \"../Actions/actionEvent\";\nimport { Tools } from \"../Misc/tools\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\n/** @hidden */\n\nvar _ClickInfo =\n/** @class */\nfunction () {\n  function _ClickInfo() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n\n  Object.defineProperty(_ClickInfo.prototype, \"singleClick\", {\n    get: function () {\n      return this._singleClick;\n    },\n    set: function (b) {\n      this._singleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"doubleClick\", {\n    get: function () {\n      return this._doubleClick;\n    },\n    set: function (b) {\n      this._doubleClick = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"hasSwiped\", {\n    get: function () {\n      return this._hasSwiped;\n    },\n    set: function (b) {\n      this._hasSwiped = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(_ClickInfo.prototype, \"ignore\", {\n    get: function () {\n      return this._ignore;\n    },\n    set: function (b) {\n      this._ignore = b;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return _ClickInfo;\n}();\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\n\n\nvar InputManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new InputManager\r\n   * @param scene defines the hosting scene\r\n   */\n  function InputManager(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false; // Pointers\n\n    this._wheelEventName = \"\";\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = [];\n    this._keyboardIsAttached = false;\n    this._scene = scene;\n  }\n\n  Object.defineProperty(InputManager.prototype, \"meshUnderPointer\", {\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\n    get: function () {\n      return this._pointerOverMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n   * @param pointerId the pointer id to use\r\n   * @returns The mesh under this pointer id or null if not found\r\n   */\n\n  InputManager.prototype.getMeshUnderPointerByPointerId = function (pointerId) {\n    return this._meshUnderPointerId[pointerId];\n  };\n\n  Object.defineProperty(InputManager.prototype, \"unTranslatedPointer\", {\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     */\n    get: function () {\n      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerX\", {\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\n    get: function () {\n      return this._pointerX;\n    },\n    set: function (value) {\n      this._pointerX = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InputManager.prototype, \"pointerY\", {\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\n    get: function () {\n      return this._pointerY;\n    },\n    set: function (value) {\n      this._pointerY = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InputManager.prototype._updatePointerPosition = function (evt) {\n    var canvasRect = this._scene.getEngine().getInputElementClientRect();\n\n    if (!canvasRect) {\n      return;\n    }\n\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  };\n\n  InputManager.prototype._processPointerMove = function (pickResult, evt) {\n    var scene = this._scene;\n    var engine = scene.getEngine();\n    var canvas = engine.getInputElement();\n\n    if (!canvas) {\n      return;\n    }\n\n    canvas.tabIndex = engine.canvasTabIndex; // Restore pointer\n\n    if (!scene.doNotHandleCursors) {\n      canvas.style.cursor = scene.defaultCursor;\n    }\n\n    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;\n\n    if (isMeshPicked) {\n      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId);\n\n      if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {\n        if (!scene.doNotHandleCursors) {\n          if (this._pointerOverMesh.actionManager.hoverCursor) {\n            canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;\n          } else {\n            canvas.style.cursor = scene.hoverCursor;\n          }\n        }\n      }\n    } else {\n      scene.setPointerOverMesh(null, evt.pointerId);\n    }\n\n    for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {\n      var step = _a[_i];\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n\n    if (pickResult) {\n      var type = evt.type === this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n\n      if (scene.onPointerMove) {\n        scene.onPointerMove(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  }; // Pointers handling\n\n\n  InputManager.prototype._setRayOnPointerInfo = function (pointerInfo) {\n    var scene = this._scene;\n\n    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {\n      if (!pointerInfo.pickInfo.ray) {\n        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  };\n\n  InputManager.prototype._checkPrePointerObservable = function (pickResult, evt, type) {\n    var scene = this._scene;\n    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n\n    if (pickResult) {\n      pi.ray = pickResult.ray;\n    }\n\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Use this method to simulate a pointer move on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   */\n\n\n  InputManager.prototype.simulatePointerMove = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointermove\", pointerEventInit);\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n\n    this._processPointerMove(pickResult, evt);\n  };\n  /**\r\n   * Use this method to simulate a pointer down on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   */\n\n\n  InputManager.prototype.simulatePointerDown = function (pickResult, pointerEventInit) {\n    var evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n\n    this._processPointerDown(pickResult, evt);\n  };\n\n  InputManager.prototype._processPointerDown = function (pickResult, evt) {\n    var _this = this;\n\n    var scene = this._scene;\n\n    if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n\n      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 1:\n              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 2:\n              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n          }\n        }\n\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(function () {\n            var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function (mesh) {\n              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh == _this._pickedDownMesh;\n            }, false, scene.cameraToUseForPointers);\n\n            if (pickResult && pickResult.hit && pickResult.pickedMesh && actionManager) {\n              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager.LongPressDelay && !_this._isPointerSwiping()) {\n                _this._startingPointerTime = 0;\n                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n      }\n    }\n\n    if (pickResult) {\n      var type = PointerEventTypes.POINTERDOWN;\n\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n\n      if (scene.onPointerObservable.hasObservers()) {\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  InputManager.prototype._isPointerSwiping = function () {\n    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n  };\n  /**\r\n   * Use this method to simulate a pointer up on a mesh\r\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n   */\n\n\n  InputManager.prototype.simulatePointerUp = function (pickResult, pointerEventInit, doubleTap) {\n    var evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    var clickInfo = new _ClickInfo();\n\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n\n    this._processPointerUp(pickResult, evt, clickInfo);\n  };\n\n  InputManager.prototype._processPointerUp = function (pickResult, evt, clickInfo) {\n    var scene = this._scene;\n\n    if (pickResult && pickResult && pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {\n          var type_1 = PointerEventTypes.POINTERPICK;\n          var pi = new PointerInfo(type_1, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type_1);\n        }\n      }\n\n      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n        }\n\n        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {\n          var step = _a[_i];\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\n        }\n      }\n    }\n\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n\n    var type = 0;\n\n    if (scene.onPointerObservable.hasObservers()) {\n      if (!clickInfo.ignore && !clickInfo.hasSwiped) {\n        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n\n        if (type) {\n          var pi = new PointerInfo(type, evt, pickResult);\n\n          this._setRayOnPointerInfo(pi);\n\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n\n      if (!clickInfo.ignore) {\n        type = PointerEventTypes.POINTERUP;\n        var pi = new PointerInfo(type, evt, pickResult);\n\n        this._setRayOnPointerInfo(pi);\n\n        scene.onPointerObservable.notifyObservers(pi, type);\n      }\n    }\n\n    if (scene.onPointerUp && !clickInfo.ignore) {\n      scene.onPointerUp(evt, pickResult, type);\n    }\n  };\n  /**\r\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n   * @returns true if the pointer was captured\r\n   */\n\n\n  InputManager.prototype.isPointerCaptured = function (pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    }\n\n    return this._pointerCaptures[pointerId];\n  };\n  /**\r\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n   * @param attachUp defines if you want to attach events to pointerup\r\n   * @param attachDown defines if you want to attach events to pointerdown\r\n   * @param attachMove defines if you want to attach events to pointermove\r\n   * @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)\r\n   */\n\n\n  InputManager.prototype.attachControl = function (attachUp, attachDown, attachMove, elementToAttachTo) {\n    var _this = this;\n\n    if (attachUp === void 0) {\n      attachUp = true;\n    }\n\n    if (attachDown === void 0) {\n      attachDown = true;\n    }\n\n    if (attachMove === void 0) {\n      attachMove = true;\n    }\n\n    if (elementToAttachTo === void 0) {\n      elementToAttachTo = null;\n    }\n\n    var scene = this._scene;\n\n    if (!elementToAttachTo) {\n      elementToAttachTo = scene.getEngine().getInputElement();\n    }\n\n    if (!elementToAttachTo) {\n      return;\n    }\n\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n\n    this._alreadyAttachedTo = elementToAttachTo;\n    var engine = scene.getEngine();\n\n    this._initActionManager = function (act, clickInfo) {\n      if (!_this._meshPickProceed) {\n        var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n        _this._currentPickResult = pickResult;\n\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n\n        _this._meshPickProceed = true;\n      }\n\n      return act;\n    };\n\n    this._delayedSimpleClick = function (btn, clickInfo, cb) {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {\n        _this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._initClickEvent = function (obs1, obs2, evt, cb) {\n      var clickInfo = new _ClickInfo();\n      _this._currentPickResult = null;\n      var act = null;\n      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n      if (!checkPicking && AbstractActionManager) {\n        act = _this._initActionManager(act, clickInfo);\n\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n\n      var needToIgnoreNext = false;\n\n      if (checkPicking) {\n        var btn = evt.button;\n        clickInfo.hasSwiped = _this._isPointerSwiping();\n\n        if (!clickInfo.hasSwiped) {\n          var checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = _this._initActionManager(act, clickInfo);\n\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - _this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== _this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, _this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          } // at least one double click is required to be check and exclusive double click is enabled\n          else {\n              // wait that no double click has been raised during the double click delay\n              _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n              _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\n            }\n\n          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = _this._initActionManager(act, clickInfo);\n\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager.DoubleClickDelay && !_this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {\n                _this._previousStartingPointerTime = 0;\n                _this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n\n                if (InputManager.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {\n                  clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                }\n\n                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                cb(clickInfo, _this._currentPickResult);\n              } // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                  _this._doubleClickOccured = false;\n                  _this._previousStartingPointerTime = _this._startingPointerTime;\n                  _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                  _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                  _this._previousButtonPressed = btn;\n\n                  if (InputManager.ExclusiveDoubleClickMode) {\n                    if (_this._previousDelayedSimpleClickTimeout) {\n                      clearTimeout(_this._previousDelayedSimpleClickTimeout);\n                    }\n\n                    _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                    cb(clickInfo, _this._previousPickResult);\n                  } else {\n                    cb(clickInfo, _this._currentPickResult);\n                  }\n                }\n\n              needToIgnoreNext = true;\n            } // just the first click of the double has been raised\n            else {\n                _this._doubleClickOccured = false;\n                _this._previousStartingPointerTime = _this._startingPointerTime;\n                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                _this._previousButtonPressed = btn;\n              }\n          }\n        }\n      }\n\n      if (!needToIgnoreNext) {\n        cb(clickInfo, _this._currentPickResult);\n      }\n    };\n\n    this._onPointerMove = function (evt) {\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt); // PreObservable support\n\n\n      if (_this._checkPrePointerObservable(null, evt, evt.type === _this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() != null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers);\n\n      _this._processPointerMove(pickResult, evt);\n    };\n\n    this._onPointerDown = function (evt) {\n      _this._totalPointersPressed++;\n      _this._pickedDownMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._startingPointerPosition.x = _this._pointerX;\n      _this._startingPointerPosition.y = _this._pointerY;\n      _this._startingPointerTime = Date.now(); // PreObservable support\n\n      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      _this._pointerCaptures[evt.pointerId] = true;\n\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = function (mesh) {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      _this._pickedDownMesh = null;\n      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n\n      _this._processPointerDown(pickResult, evt);\n    };\n\n    this._onPointerUp = function (evt) {\n      if (_this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      _this._totalPointersPressed--;\n      _this._pickedUpMesh = null;\n      _this._meshPickProceed = false; // preserve compatibility with Safari when pointerId is not present\n\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n\n      _this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function (clickInfo, pickResult) {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          if (!clickInfo.ignore) {\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  return;\n                }\n              }\n\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  return;\n                }\n              }\n            }\n\n            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              return;\n            }\n          }\n        }\n\n        if (!_this._pointerCaptures[evt.pointerId]) {\n          return;\n        }\n\n        _this._pointerCaptures[evt.pointerId] = false;\n\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = function (mesh) {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        } // Meshes\n\n\n        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {\n          _this._initActionManager(null, clickInfo);\n        }\n\n        if (!pickResult) {\n          pickResult = _this._currentPickResult;\n        }\n\n        _this._processPointerUp(pickResult, evt, clickInfo);\n\n        _this._previousPickResult = _this._currentPickResult;\n      });\n    };\n\n    this._onKeyDown = function (evt) {\n      var type = KeyboardEventTypes.KEYDOWN;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnPointerObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    this._onKeyUp = function (evt) {\n      var type = KeyboardEventTypes.KEYUP;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnPointerObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        var pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    var attachedFunction = function () {\n      if (!elementToAttachTo || _this._keyboardIsAttached) {\n        return;\n      }\n\n      elementToAttachTo.addEventListener(\"keydown\", _this._onKeyDown, false);\n      elementToAttachTo.addEventListener(\"keyup\", _this._onKeyUp, false);\n      _this._keyboardIsAttached = true;\n    }; // Keyboard events\n\n\n    this._onCanvasFocusObserver = engine.onCanvasFocusObservable.add(function () {\n      if (document.activeElement === elementToAttachTo) {\n        attachedFunction();\n      }\n\n      return attachedFunction;\n    }());\n    this._onCanvasBlurObserver = engine.onCanvasBlurObservable.add(function () {\n      if (!elementToAttachTo) {\n        return;\n      }\n\n      elementToAttachTo.removeEventListener(\"keydown\", _this._onKeyDown);\n      elementToAttachTo.removeEventListener(\"keyup\", _this._onKeyUp);\n      _this._keyboardIsAttached = false;\n    });\n    attachedFunction(); // Pointer events\n\n    var eventPrefix = Tools.GetPointerPrefix(engine);\n\n    if (attachMove) {\n      elementToAttachTo.addEventListener(eventPrefix + \"move\", this._onPointerMove, false); // Wheel\n\n      this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n      : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n      : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\n      elementToAttachTo.addEventListener(this._wheelEventName, this._onPointerMove, false);\n    }\n\n    if (attachDown) {\n      elementToAttachTo.addEventListener(eventPrefix + \"down\", this._onPointerDown, false);\n    }\n\n    if (attachUp) {\n      var hostWindow = scene.getEngine().getHostWindow();\n\n      if (hostWindow) {\n        hostWindow.addEventListener(eventPrefix + \"up\", this._onPointerUp, false);\n      }\n    }\n\n    this._alreadyAttached = true;\n  };\n  /**\r\n   * Detaches all event handlers\r\n   */\n\n\n  InputManager.prototype.detachControl = function () {\n    var engine = this._scene.getEngine();\n\n    var eventPrefix = Tools.GetPointerPrefix(engine);\n\n    if (!this._alreadyAttachedTo) {\n      return;\n    }\n\n    if (!this._alreadyAttached) {\n      return;\n    } // Pointer\n\n\n    this._alreadyAttachedTo.removeEventListener(eventPrefix + \"move\", this._onPointerMove);\n\n    this._alreadyAttachedTo.removeEventListener(this._wheelEventName, this._onPointerMove);\n\n    this._alreadyAttachedTo.removeEventListener(eventPrefix + \"down\", this._onPointerDown);\n\n    window.removeEventListener(eventPrefix + \"up\", this._onPointerUp); // Blur / Focus\n\n    if (this._onCanvasBlurObserver) {\n      engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\n    }\n\n    if (this._onCanvasFocusObserver) {\n      engine.onCanvasFocusObservable.remove(this._onCanvasFocusObserver);\n    } // Keyboard\n\n\n    this._alreadyAttachedTo.removeEventListener(\"keydown\", this._onKeyDown);\n\n    this._alreadyAttachedTo.removeEventListener(\"keyup\", this._onKeyUp); // Cursor\n\n\n    if (!this._scene.doNotHandleCursors) {\n      this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n    }\n\n    this._alreadyAttached = false;\n  };\n  /**\r\n   * Force the value of meshUnderPointer\r\n   * @param mesh defines the mesh to use\r\n   * @param pointerId optional pointer id when using more than one pointer. Defaults to 0\r\n   */\n\n\n  InputManager.prototype.setPointerOverMesh = function (mesh, pointerId) {\n    if (pointerId === void 0) {\n      pointerId = 0;\n    } // Sanity check\n\n\n    if (pointerId < 0) {\n      pointerId = 0;\n    }\n\n    if (this._meshUnderPointerId[pointerId] === mesh) {\n      return;\n    }\n\n    var underPointerMesh = this._meshUnderPointerId[pointerId];\n    var actionManager;\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId: pointerId\n        }));\n      }\n    }\n\n    this._meshUnderPointerId[pointerId] = mesh;\n    this._pointerOverMesh = mesh;\n    underPointerMesh = this._meshUnderPointerId[pointerId];\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(9);\n\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId: pointerId\n        }));\n      }\n    }\n  };\n  /**\r\n   * Gets the mesh under the pointer\r\n   * @returns a Mesh or null if no mesh is under the pointer\r\n   */\n\n\n  InputManager.prototype.getPointerOverMesh = function () {\n    return this._pointerOverMesh;\n  };\n  /** The distance in pixel that you have to move to prevent some events */\n\n\n  InputManager.DragMovementThreshold = 10; // in pixels\n\n  /** Time in milliseconds to wait to raise long press events if button is still pressed */\n\n  InputManager.LongPressDelay = 500; // in milliseconds\n\n  /** Time in milliseconds with two consecutive clicks will be considered as a double click */\n\n  InputManager.DoubleClickDelay = 300; // in milliseconds\n\n  /** If you need to check double click without raising a single click at first click, enable this flag */\n\n  InputManager.ExclusiveDoubleClickMode = false;\n  return InputManager;\n}();\n\nexport { InputManager };","map":{"version":3,"sources":["../../../sourceES6/core/Inputs/scene.inputManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { Nullable } from \"../types\";\r\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/** @hidden */\r\nclass _ClickInfo {\r\n    private _singleClick = false;\r\n    private _doubleClick = false;\r\n    private _hasSwiped = false;\r\n    private _ignore = false;\r\n\r\n    public get singleClick(): boolean {\r\n        return this._singleClick;\r\n    }\r\n    public get doubleClick(): boolean {\r\n        return this._doubleClick;\r\n    }\r\n    public get hasSwiped(): boolean {\r\n        return this._hasSwiped;\r\n    }\r\n    public get ignore(): boolean {\r\n        return this._ignore;\r\n    }\r\n\r\n    public set singleClick(b: boolean) {\r\n        this._singleClick = b;\r\n    }\r\n    public set doubleClick(b: boolean) {\r\n        this._doubleClick = b;\r\n    }\r\n    public set hasSwiped(b: boolean) {\r\n        this._hasSwiped = b;\r\n    }\r\n    public set ignore(b: boolean) {\r\n        this._ignore = b;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\r\nexport class InputManager {\r\n    /** The distance in pixel that you have to move to prevent some events */\r\n    public static DragMovementThreshold = 10; // in pixels\r\n    /** Time in milliseconds to wait to raise long press events if button is still pressed */\r\n    public static LongPressDelay = 500; // in milliseconds\r\n    /** Time in milliseconds with two consecutive clicks will be considered as a double click */\r\n    public static DoubleClickDelay = 300; // in milliseconds\r\n    /** If you need to check double click without raising a single click at first click, enable this flag */\r\n    public static ExclusiveDoubleClickMode = false;\r\n\r\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\r\n    private _alreadyAttached = false;\r\n    private _alreadyAttachedTo: HTMLElement;\r\n\r\n    // Pointers\r\n    private _wheelEventName = \"\";\r\n    private _onPointerMove: (evt: PointerEvent) => void;\r\n    private _onPointerDown: (evt: PointerEvent) => void;\r\n    private _onPointerUp: (evt: PointerEvent) => void;\r\n\r\n    private _initClickEvent: (obs1: Observable<PointerInfoPre>, obs2: Observable<PointerInfo>, evt: PointerEvent, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _initActionManager: (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo) => Nullable<AbstractActionManager>;\r\n    private _delayedSimpleClick: (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _delayedSimpleClickTimeout: number;\r\n    private _previousDelayedSimpleClickTimeout: number;\r\n    private _meshPickProceed = false;\r\n\r\n    private _previousButtonPressed: number;\r\n    private _currentPickResult: Nullable<PickingInfo> = null;\r\n    private _previousPickResult: Nullable<PickingInfo> = null;\r\n    private _totalPointersPressed = 0;\r\n    private _doubleClickOccured = false;\r\n\r\n    private _pointerOverMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pickedDownMesh: Nullable<AbstractMesh>;\r\n    private _pickedUpMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pointerX: number = 0;\r\n    private _pointerY: number = 0;\r\n    private _unTranslatedPointerX: number;\r\n    private _unTranslatedPointerY: number;\r\n    private _startingPointerPosition = new Vector2(0, 0);\r\n    private _previousStartingPointerPosition = new Vector2(0, 0);\r\n    private _startingPointerTime = 0;\r\n    private _previousStartingPointerTime = 0;\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n\r\n    private _meshUnderPointerId: Nullable<AbstractMesh>[] = [];\r\n\r\n    // Keyboard\r\n    private _onKeyDown: (evt: KeyboardEvent) => void;\r\n    private _onKeyUp: (evt: KeyboardEvent) => void;\r\n    private _keyboardIsAttached = false;\r\n    private _onCanvasFocusObserver: Nullable<Observer<Engine>>;\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new InputManager\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n     * @param pointerId the pointer id to use\r\n     * @returns The mesh under this pointer id or null if not found\r\n     */\r\n    public getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh> {\r\n        return this._meshUnderPointerId[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     */\r\n    public get pointerX(): number {\r\n        return this._pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     */\r\n    public get pointerY(): number {\r\n        return this._pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._pointerY = value;\r\n    }\r\n\r\n    private _updatePointerPosition(evt: PointerEvent): void {\r\n        var canvasRect = this._scene.getEngine().getInputElementClientRect();\r\n\r\n        if (!canvasRect) {\r\n            return;\r\n        }\r\n\r\n        this._pointerX = evt.clientX - canvasRect.left;\r\n        this._pointerY = evt.clientY - canvasRect.top;\r\n\r\n        this._unTranslatedPointerX = this._pointerX;\r\n        this._unTranslatedPointerY = this._pointerY;\r\n    }\r\n\r\n    private _processPointerMove(pickResult: Nullable<PickingInfo>, evt: PointerEvent) {\r\n        let scene = this._scene;\r\n        let engine = scene.getEngine();\r\n        var canvas = engine.getInputElement();\r\n\r\n        if (!canvas) {\r\n            return;\r\n        }\r\n\r\n        canvas.tabIndex = engine.canvasTabIndex;\r\n\r\n        // Restore pointer\r\n        if (!scene.doNotHandleCursors) {\r\n            canvas.style.cursor = scene.defaultCursor;\r\n        }\r\n\r\n        var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverMesh(pickResult!.pickedMesh, evt.pointerId);\r\n\r\n            if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {\r\n                if (!scene.doNotHandleCursors) {\r\n                    if (this._pointerOverMesh.actionManager.hoverCursor) {\r\n                        canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;\r\n                    } else {\r\n                        canvas.style.cursor = scene.hoverCursor;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            scene.setPointerOverMesh(null, evt.pointerId);\r\n        }\r\n\r\n        for (let step of scene._pointerMoveStage) {\r\n            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\r\n        }\r\n\r\n        if (pickResult) {\r\n            let type = evt.type === this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\r\n\r\n            if (scene.onPointerMove) {\r\n                scene.onPointerMove(evt, pickResult, type);\r\n            }\r\n\r\n            if (scene.onPointerObservable.hasObservers()) {\r\n                let pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Pointers handling\r\n    private _setRayOnPointerInfo(pointerInfo: PointerInfo) {\r\n        let scene = this._scene;\r\n        if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {\r\n            if (!pointerInfo.pickInfo.ray) {\r\n                pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _checkPrePointerObservable(pickResult: Nullable<PickingInfo>, evt: PointerEvent, type: number) {\r\n        let scene = this._scene;\r\n        let pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n        if (pickResult) {\r\n            pi.ray = pickResult.ray;\r\n        }\r\n        scene.onPrePointerObservable.notifyObservers(pi, type);\r\n        if (pi.skipOnPointerObservable) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        let evt = new PointerEvent(\"pointermove\", pointerEventInit);\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\r\n            return;\r\n        }\r\n        this._processPointerMove(pickResult, evt);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        let evt = new PointerEvent(\"pointerdown\", pointerEventInit);\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerDown(pickResult, evt);\r\n    }\r\n\r\n    private _processPointerDown(pickResult: Nullable<PickingInfo>, evt: PointerEvent): void {\r\n        let scene = this._scene;\r\n        if (pickResult && pickResult.hit && pickResult.pickedMesh) {\r\n            this._pickedDownMesh = pickResult.pickedMesh;\r\n            var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager) {\r\n                if (actionManager.hasPickTriggers) {\r\n                    actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 1:\r\n                            actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 2:\r\n                            actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                if (actionManager.hasSpecificTrigger(8)) {\r\n                    window.setTimeout(() => {\r\n                        var pickResult = scene.pick(\r\n                            this._unTranslatedPointerX,\r\n                            this._unTranslatedPointerY,\r\n                            (mesh: AbstractMesh): boolean => <boolean>(mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh == this._pickedDownMesh),\r\n                            false,\r\n                            scene.cameraToUseForPointers\r\n                        );\r\n\r\n                        if (pickResult && pickResult.hit && pickResult.pickedMesh && actionManager) {\r\n                            if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\r\n                                this._startingPointerTime = 0;\r\n                                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            }\r\n                        }\r\n                    }, InputManager.LongPressDelay);\r\n                }\r\n            }\r\n        } else {\r\n            for (let step of scene._pointerDownStage) {\r\n                pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\r\n            }\r\n        }\r\n\r\n        if (pickResult) {\r\n            let type = PointerEventTypes.POINTERDOWN;\r\n\r\n            if (scene.onPointerDown) {\r\n                scene.onPointerDown(evt, pickResult, type);\r\n            }\r\n\r\n            if (scene.onPointerObservable.hasObservers()) {\r\n                let pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _isPointerSwiping(): boolean {\r\n        return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void {\r\n        let evt = new PointerEvent(\"pointerup\", pointerEventInit);\r\n        let clickInfo = new _ClickInfo();\r\n\r\n        if (doubleTap) {\r\n            clickInfo.doubleClick = true;\r\n        } else {\r\n            clickInfo.singleClick = true;\r\n        }\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerUp(pickResult, evt, clickInfo);\r\n    }\r\n\r\n    private _processPointerUp(pickResult: Nullable<PickingInfo>, evt: PointerEvent, clickInfo: _ClickInfo): void {\r\n        let scene = this._scene;\r\n        if (pickResult && pickResult && pickResult.pickedMesh) {\r\n            this._pickedUpMesh = pickResult.pickedMesh;\r\n            if (this._pickedDownMesh === this._pickedUpMesh) {\r\n                if (scene.onPointerPick) {\r\n                    scene.onPointerPick(evt, pickResult);\r\n                }\r\n                if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {\r\n                    let type = PointerEventTypes.POINTERPICK;\r\n                    let pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pi);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n            let actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager && !clickInfo.ignore) {\r\n                actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n\r\n                if (!clickInfo.hasSwiped && clickInfo.singleClick) {\r\n                    actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                }\r\n\r\n                let doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\r\n                if (clickInfo.doubleClick && doubleClickActionManager) {\r\n                    doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                }\r\n            }\r\n        } else {\r\n            if (!clickInfo.ignore) {\r\n                for (let step of scene._pointerUpStage) {\r\n                    pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\r\n            let pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\r\n            if (pickedDownActionManager) {\r\n                pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\r\n            }\r\n        }\r\n\r\n        let type = 0;\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            if (!clickInfo.ignore && !clickInfo.hasSwiped) {\r\n                if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                    type = PointerEventTypes.POINTERTAP;\r\n                } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                    type = PointerEventTypes.POINTERDOUBLETAP;\r\n                }\r\n                if (type) {\r\n                    let pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pi);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n\r\n            if (!clickInfo.ignore) {\r\n                type = PointerEventTypes.POINTERUP;\r\n\r\n                let pi = new PointerInfo(type, evt, pickResult);\r\n                this._setRayOnPointerInfo(pi);\r\n                scene.onPointerObservable.notifyObservers(pi, type);\r\n            }\r\n        }\r\n\r\n        if (scene.onPointerUp && !clickInfo.ignore) {\r\n            scene.onPointerUp(evt, pickResult, type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._pointerCaptures[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp defines if you want to attach events to pointerup\r\n     * @param attachDown defines if you want to attach events to pointerdown\r\n     * @param attachMove defines if you want to attach events to pointermove\r\n     * @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo: Nullable<HTMLElement> = null): void {\r\n        let scene = this._scene;\r\n\r\n        if (!elementToAttachTo) {\r\n            elementToAttachTo = scene.getEngine().getInputElement();\r\n        }\r\n\r\n        if (!elementToAttachTo) {\r\n            return;\r\n        }\r\n\r\n        if (this._alreadyAttached) {\r\n            this.detachControl();\r\n        }\r\n        this._alreadyAttachedTo = elementToAttachTo;\r\n        let engine = scene.getEngine();\r\n\r\n        this._initActionManager = (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo): Nullable<AbstractActionManager> => {\r\n            if (!this._meshPickProceed) {\r\n                let pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\r\n                this._currentPickResult = pickResult;\r\n                if (pickResult) {\r\n                    act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\r\n                }\r\n                this._meshPickProceed = true;\r\n            }\r\n            return act;\r\n        };\r\n\r\n        this._delayedSimpleClick = (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => {\r\n            // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\r\n            if ((Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured) || btn !== this._previousButtonPressed) {\r\n                this._doubleClickOccured = false;\r\n                clickInfo.singleClick = true;\r\n                clickInfo.ignore = false;\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._initClickEvent = (obs1: Observable<PointerInfoPre>, obs2: Observable<PointerInfo>, evt: PointerEvent, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void): void => {\r\n            let clickInfo = new _ClickInfo();\r\n            this._currentPickResult = null;\r\n            let act: Nullable<AbstractActionManager> = null;\r\n\r\n            let checkPicking =\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n            if (!checkPicking && AbstractActionManager) {\r\n                act = this._initActionManager(act, clickInfo);\r\n                if (act) {\r\n                    checkPicking = act.hasPickTriggers;\r\n                }\r\n            }\r\n\r\n            let needToIgnoreNext = false;\r\n\r\n            if (checkPicking) {\r\n                let btn = evt.button;\r\n                clickInfo.hasSwiped = this._isPointerSwiping();\r\n\r\n                if (!clickInfo.hasSwiped) {\r\n                    let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\r\n\r\n                    if (!checkSingleClickImmediately) {\r\n                        checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n\r\n                        if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\r\n                            act = this._initActionManager(act, clickInfo);\r\n                            if (act) {\r\n                                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (checkSingleClickImmediately) {\r\n                        // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\r\n                        if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\r\n                            clickInfo.singleClick = true;\r\n                            cb(clickInfo, this._currentPickResult);\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                    }\r\n                    // at least one double click is required to be check and exclusive double click is enabled\r\n                    else {\r\n                        // wait that no double click has been raised during the double click delay\r\n                        this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                        this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\r\n                    }\r\n\r\n                    let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n                    if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\r\n                        act = this._initActionManager(act, clickInfo);\r\n                        if (act) {\r\n                            checkDoubleClick = act.hasSpecificTrigger(6);\r\n                        }\r\n                    }\r\n                    if (checkDoubleClick) {\r\n                        // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\r\n                        if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\r\n                            // pointer has not moved for 2 clicks, it's a double click\r\n                            if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\r\n                                this._previousStartingPointerTime = 0;\r\n                                this._doubleClickOccured = true;\r\n                                clickInfo.doubleClick = true;\r\n                                clickInfo.ignore = false;\r\n                                if (InputManager.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout) {\r\n                                    clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                }\r\n                                this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                                cb(clickInfo, this._currentPickResult);\r\n                            }\r\n                            // if the two successive clicks are too far, it's just two simple clicks\r\n                            else {\r\n                                this._doubleClickOccured = false;\r\n                                this._previousStartingPointerTime = this._startingPointerTime;\r\n                                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                                this._previousButtonPressed = btn;\r\n                                if (InputManager.ExclusiveDoubleClickMode) {\r\n                                    if (this._previousDelayedSimpleClickTimeout) {\r\n                                        clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                    }\r\n                                    this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n\r\n                                    cb(clickInfo, this._previousPickResult);\r\n                                } else {\r\n                                    cb(clickInfo, this._currentPickResult);\r\n                                }\r\n                            }\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                        // just the first click of the double has been raised\r\n                        else {\r\n                            this._doubleClickOccured = false;\r\n                            this._previousStartingPointerTime = this._startingPointerTime;\r\n                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                            this._previousButtonPressed = btn;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!needToIgnoreNext) {\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._onPointerMove = (evt: PointerEvent) => {\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, evt.type === this._wheelEventName ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.pointerMovePredicate) {\r\n                scene.pointerMovePredicate = (mesh: AbstractMesh): boolean =>\r\n                    mesh.isPickable &&\r\n                    mesh.isVisible &&\r\n                    mesh.isReady() &&\r\n                    mesh.isEnabled() &&\r\n                    (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() != null) &&\r\n                    (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n            }\r\n\r\n            // Meshes\r\n            var pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers);\r\n\r\n            this._processPointerMove(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerDown = (evt: PointerEvent) => {\r\n            this._totalPointersPressed++;\r\n            this._pickedDownMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._startingPointerPosition.x = this._pointerX;\r\n            this._startingPointerPosition.y = this._pointerY;\r\n            this._startingPointerTime = Date.now();\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            this._pointerCaptures[evt.pointerId] = true;\r\n\r\n            if (!scene.pointerDownPredicate) {\r\n                scene.pointerDownPredicate = (mesh: AbstractMesh): boolean => {\r\n                    return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n                };\r\n            }\r\n\r\n            // Meshes\r\n            this._pickedDownMesh = null;\r\n            var pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\r\n\r\n            this._processPointerDown(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerUp = (evt: PointerEvent) => {\r\n            if (this._totalPointersPressed === 0) {\r\n                // We are attaching the pointer up to windows because of a bug in FF\r\n                return; // So we need to test it the pointer down was pressed before.\r\n            }\r\n\r\n            this._totalPointersPressed--;\r\n            this._pickedUpMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => {\r\n                // PreObservable support\r\n                if (scene.onPrePointerObservable.hasObservers()) {\r\n                    if (!clickInfo.ignore) {\r\n                        if (!clickInfo.hasSwiped) {\r\n                            if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._pointerCaptures[evt.pointerId]) {\r\n                    return;\r\n                }\r\n\r\n                this._pointerCaptures[evt.pointerId] = false;\r\n                if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                    return;\r\n                }\r\n\r\n                if (!scene.pointerUpPredicate) {\r\n                    scene.pointerUpPredicate = (mesh: AbstractMesh): boolean => {\r\n                        return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n                    };\r\n                }\r\n\r\n                // Meshes\r\n                if (!this._meshPickProceed && ((AbstractActionManager && AbstractActionManager.HasTriggers) || scene.onPointerObservable.hasObservers())) {\r\n                    this._initActionManager(null, clickInfo);\r\n                }\r\n                if (!pickResult) {\r\n                    pickResult = this._currentPickResult;\r\n                }\r\n\r\n                this._processPointerUp(pickResult, evt, clickInfo);\r\n\r\n                this._previousPickResult = this._currentPickResult;\r\n            });\r\n        };\r\n\r\n        this._onKeyDown = (evt: KeyboardEvent) => {\r\n            let type = KeyboardEventTypes.KEYDOWN;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                let pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnPointerObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                let pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        this._onKeyUp = (evt: KeyboardEvent) => {\r\n            let type = KeyboardEventTypes.KEYUP;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                let pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnPointerObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                let pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        let attachedFunction = () => {\r\n            if (!elementToAttachTo || this._keyboardIsAttached) {\r\n                return;\r\n            }\r\n            elementToAttachTo.addEventListener(\"keydown\", this._onKeyDown, false);\r\n            elementToAttachTo.addEventListener(\"keyup\", this._onKeyUp, false);\r\n            this._keyboardIsAttached = true;\r\n        };\r\n\r\n        // Keyboard events\r\n        this._onCanvasFocusObserver = engine.onCanvasFocusObservable.add(\r\n            (() => {\r\n\r\n                if (document.activeElement === elementToAttachTo) {\r\n                    attachedFunction();\r\n                }\r\n                return attachedFunction;\r\n            })()\r\n        );\r\n\r\n        this._onCanvasBlurObserver = engine.onCanvasBlurObservable.add(() => {\r\n            if (!elementToAttachTo) {\r\n                return;\r\n            }\r\n            elementToAttachTo.removeEventListener(\"keydown\", this._onKeyDown);\r\n            elementToAttachTo.removeEventListener(\"keyup\", this._onKeyUp);\r\n            this._keyboardIsAttached = false;\r\n        });\r\n\r\n        attachedFunction();\r\n\r\n        // Pointer events\r\n        var eventPrefix = Tools.GetPointerPrefix(engine);\r\n\r\n        if (attachMove) {\r\n            elementToAttachTo.addEventListener(eventPrefix + \"move\", <any>this._onPointerMove, false);\r\n\r\n            // Wheel\r\n            this._wheelEventName =\r\n                \"onwheel\" in document.createElement(\"div\")\r\n                    ? \"wheel\" // Modern browsers support \"wheel\"\r\n                    : (<any>document).onmousewheel !== undefined\r\n                    ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\r\n                    : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n            elementToAttachTo.addEventListener(this._wheelEventName, <any>this._onPointerMove, false);\r\n        }\r\n\r\n        if (attachDown) {\r\n            elementToAttachTo.addEventListener(eventPrefix + \"down\", <any>this._onPointerDown, false);\r\n        }\r\n\r\n        if (attachUp) {\r\n            let hostWindow = scene.getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                hostWindow.addEventListener(eventPrefix + \"up\", <any>this._onPointerUp, false);\r\n            }\r\n        }\r\n        this._alreadyAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Detaches all event handlers\r\n     */\r\n    public detachControl() {\r\n        const engine = this._scene.getEngine();\r\n        const eventPrefix = Tools.GetPointerPrefix(engine);\r\n\r\n        if (!this._alreadyAttachedTo) {\r\n            return;\r\n        }\r\n\r\n        if (!this._alreadyAttached) {\r\n            return;\r\n        }\r\n\r\n        // Pointer\r\n        this._alreadyAttachedTo.removeEventListener(eventPrefix + \"move\", <any>this._onPointerMove);\r\n        this._alreadyAttachedTo.removeEventListener(this._wheelEventName, <any>this._onPointerMove);\r\n        this._alreadyAttachedTo.removeEventListener(eventPrefix + \"down\", <any>this._onPointerDown);\r\n        window.removeEventListener(eventPrefix + \"up\", <any>this._onPointerUp);\r\n\r\n        // Blur / Focus\r\n        if (this._onCanvasBlurObserver) {\r\n            engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n        }\r\n\r\n        if (this._onCanvasFocusObserver) {\r\n            engine.onCanvasFocusObservable.remove(this._onCanvasFocusObserver);\r\n        }\r\n\r\n        // Keyboard\r\n        this._alreadyAttachedTo.removeEventListener(\"keydown\", this._onKeyDown);\r\n        this._alreadyAttachedTo.removeEventListener(\"keyup\", this._onKeyUp);\r\n\r\n        // Cursor\r\n        if (!this._scene.doNotHandleCursors) {\r\n            this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\r\n        }\r\n\r\n        this._alreadyAttached = false;\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh defines the mesh to use\r\n     * @param pointerId optional pointer id when using more than one pointer. Defaults to 0\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId: number = 0): void {\r\n        // Sanity check\r\n        if (pointerId < 0) {\r\n            pointerId = 0;\r\n        }\r\n        if (this._meshUnderPointerId[pointerId] === mesh) {\r\n            return;\r\n        }\r\n\r\n        let underPointerMesh = this._meshUnderPointerId[pointerId];\r\n\r\n        let actionManager: Nullable<AbstractActionManager>;\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(10);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, undefined, { pointerId }));\r\n            }\r\n        }\r\n\r\n        this._meshUnderPointerId[pointerId] = mesh;\r\n        this._pointerOverMesh = mesh;\r\n\r\n        underPointerMesh = this._meshUnderPointerId[pointerId];\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(9);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(9, ActionEvent.CreateNew(underPointerMesh, undefined, { pointerId }));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this._pointerOverMesh;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}