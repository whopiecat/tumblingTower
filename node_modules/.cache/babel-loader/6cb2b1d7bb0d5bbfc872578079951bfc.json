{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh\";\nimport { VertexBuffer, Buffer } from './buffer';\nimport { Matrix, Vector3, TmpVectors } from '../Maths/math.vector';\n\nMesh.prototype.thinInstanceAdd = function (matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n\n  var index = this._thinInstanceDataStorage.instancesCount;\n\n  if (Array.isArray(matrix)) {\n    for (var i = 0; i < matrix.length; ++i) {\n      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n    }\n  } else {\n    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n  }\n\n  return index;\n};\n\nMesh.prototype.thinInstanceAddSelf = function (refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\n\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n  this.removeVerticesData(kind);\n\n  this._thinInstanceInitializeUserStorage();\n\n  this._userThinInstanceBuffersStorage.strides[kind] = stride;\n  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n\n  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\n\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n  matrix.copyToArray(matrixData, index * 16);\n\n  if (this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n  }\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(\"matrix\");\n\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n\n  return true;\n};\n\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh) {\n  if (refresh === void 0) {\n    refresh = true;\n  }\n\n  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n\n  this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n\n\n  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n\n  if (refresh) {\n    this.thinInstanceBufferUpdated(kind);\n  }\n\n  return true;\n};\n\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n  get: function () {\n    return this._thinInstanceDataStorage.instancesCount;\n  },\n  set: function (value) {\n    var _a, _b;\n\n    var numMaxInstances = ((_b = (_a = this._thinInstanceDataStorage.matrixData) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) / 16;\n\n    if (value <= numMaxInstances) {\n      this._thinInstanceDataStorage.instancesCount = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride, staticBuffer) {\n  var _a, _b;\n\n  if (stride === void 0) {\n    stride = 0;\n  }\n\n  if (staticBuffer === void 0) {\n    staticBuffer = false;\n  }\n\n  stride = stride || 16;\n\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n    this._thinInstanceDataStorage.matrixData = buffer;\n    this._thinInstanceDataStorage.worldMatrices = null;\n\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n      var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, stride, false, true);\n      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\n\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    } else {\n      this._thinInstanceDataStorage.instancesCount = 0;\n\n      if (!this.doNotSyncBoundingInfo) {\n        // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n        this.refreshBoundingInfo(true);\n      }\n    }\n  } else {\n    if (buffer === null) {\n      if ((_b = this._userThinInstanceBuffersStorage) === null || _b === void 0 ? void 0 : _b.data[kind]) {\n        this.removeVerticesData(kind);\n        delete this._userThinInstanceBuffersStorage.data[kind];\n        delete this._userThinInstanceBuffersStorage.strides[kind];\n        delete this._userThinInstanceBuffersStorage.sizes[kind];\n        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n      }\n    } else {\n      this._thinInstanceInitializeUserStorage();\n\n      this._userThinInstanceBuffersStorage.data[kind] = buffer;\n      this._userThinInstanceBuffersStorage.strides[kind] = stride;\n      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n  var _a;\n\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n  }\n};\n\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n  var _a;\n\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n    }\n  } else if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n  }\n};\n\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return [];\n  }\n\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (!this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices = new Array();\n\n    for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n    }\n  }\n\n  return this._thinInstanceDataStorage.worldMatrices;\n};\n\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo) {\n  if (forceRefreshParentInfo === void 0) {\n    forceRefreshParentInfo = false;\n  }\n\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return;\n  }\n\n  var vectors = this._thinInstanceDataStorage.boundingVectors;\n\n  if (forceRefreshParentInfo) {\n    vectors.length = 0;\n    this.refreshBoundingInfo(true);\n  }\n\n  var boundingInfo = this.getBoundingInfo();\n  var matrixData = this._thinInstanceDataStorage.matrixData;\n\n  if (vectors.length === 0) {\n    for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n      vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n    }\n  }\n\n  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n\n  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n\n  for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n\n    for (var v = 0; v < vectors.length; ++v) {\n      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n    }\n  }\n\n  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n\n  this._updateBoundingInfo();\n};\n\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances) {\n  var _a, _b;\n\n  if (numInstances === void 0) {\n    numInstances = 1;\n  }\n\n  var kindIsMatrix = kind === \"matrix\";\n\n  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n    return;\n  }\n\n  var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n  var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n  var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n  var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n  var newSize = currentSize;\n\n  while (newSize < bufferSize) {\n    newSize *= 2;\n  }\n\n  if (!data || currentSize != newSize) {\n    if (!data) {\n      data = new Float32Array(newSize);\n    } else {\n      var newData = new Float32Array(newSize);\n      newData.set(data, 0);\n      data = newData;\n    }\n\n    if (kindIsMatrix) {\n      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n      var matrixBuffer = new Buffer(this.getEngine(), data, true, stride, false, true);\n      this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\n      this._thinInstanceDataStorage.matrixData = data;\n      this._thinInstanceDataStorage.matrixBufferSize = newSize;\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\n      this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\n    } else {\n      (_b = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();\n      this._userThinInstanceBuffersStorage.data[kind] = data;\n      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\n\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n  if (!this._userThinInstanceBuffersStorage) {\n    this._userThinInstanceBuffersStorage = {\n      data: {},\n      sizes: {},\n      vertexBuffers: {},\n      strides: {}\n    };\n  }\n};\n\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n  var _a;\n\n  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {\n    this._thinInstanceDataStorage.matrixBuffer.dispose();\n\n    this._thinInstanceDataStorage.matrixBuffer = null;\n  }\n};","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/thinInstanceMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh, _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from './buffer';\r\nimport { Matrix, Vector3, TmpVectors } from '../Maths/math.vector';\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>,  stride: number, staticBuffer: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @return an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo: boolean): void;\r\n\r\n        /** @hidden */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @hidden */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances: number): void;\r\n\r\n        /** @hidden */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: {[key: string]: Float32Array},\r\n            sizes: {[key: string]: number},\r\n            vertexBuffers: {[key: string]: Nullable<VertexBuffer>},\r\n            strides: {[key: string]: number}\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], (i === matrix.length - 1) && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function(refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function(kind: string, stride: number): void {\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function(index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function(kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function(this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function(this: Mesh, value: number) {\r\n        const numMaxInstances = (this._thinInstanceDataStorage.matrixData?.length ?? 0) / 16;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function(kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = false): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n\r\n            const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, stride, false, true);\r\n\r\n            this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\r\n\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo(true);\r\n            }\r\n        }\r\n    } else {\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function(kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer!.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n        }\r\n    } else if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function(kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function(): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = new Array<Matrix>();\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(true);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function(kind: string, numInstances: number = 1) {\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n\r\n            const matrixBuffer = new Buffer(this.getEngine(), data, true, stride, false, true);\r\n\r\n            this._thinInstanceDataStorage.matrixBuffer = matrixBuffer;\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world0\", 0, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world1\", 4, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world2\", 8, 4));\r\n            this.setVerticesBuffer(matrixBuffer.createVertexBuffer(\"world3\", 12, 4));\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function() {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function() {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}