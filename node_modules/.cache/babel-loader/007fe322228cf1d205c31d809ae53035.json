{"ast":null,"code":"import { VertexBuffer } from \"./buffer\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { extractMinAndMaxIndexed } from '../Maths/math.functions';\n/**\r\n * Defines a subdivision inside a mesh\r\n */\n\nvar SubMesh =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new submesh\r\n   * @param materialIndex defines the material index to use\r\n   * @param verticesStart defines vertex index start\r\n   * @param verticesCount defines vertices count\r\n   * @param indexStart defines index start\r\n   * @param indexCount defines indices count\r\n   * @param mesh defines the parent mesh\r\n   * @param renderingMesh defines an optional rendering mesh\r\n   * @param createBoundingBox defines if bounding box should be created for this submesh\r\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n   */\n  function SubMesh(\n  /** the material index to use */\n  materialIndex,\n  /** vertex index start */\n  verticesStart,\n  /** vertices count */\n  verticesCount,\n  /** index start */\n  indexStart,\n  /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    if (addToMesh === void 0) {\n      addToMesh = true;\n    }\n\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    /** @hidden */\n\n    this._materialDefines = null;\n    /** @hidden */\n\n    this._materialEffect = null;\n    /** @hidden */\n\n    this._effectOverride = null;\n    /** @hidden */\n\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @hidden */\n\n    this._lastColliderWorldVertices = null;\n    /** @hidden */\n\n    this._lastColliderTransformMatrix = null;\n    /** @hidden */\n\n    this._renderId = 0;\n    /** @hidden */\n\n    this._alphaIndex = 0;\n    /** @hidden */\n\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(SubMesh.prototype, \"materialDefines\", {\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\n    get: function () {\n      return this._materialDefines;\n    },\n\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\n    set: function (defines) {\n      this._materialDefines = defines;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SubMesh.prototype, \"effect\", {\n    /**\r\n     * Gets associated effect\r\n     */\n    get: function () {\n      var _a;\n\n      return (_a = this._effectOverride) !== null && _a !== void 0 ? _a : this._materialEffect;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets associated effect (effect used to render this submesh)\r\n   * @param effect defines the effect to associate with\r\n   * @param defines defines the set of defines used to compile this effect\r\n   */\n\n  SubMesh.prototype.setEffect = function (effect, defines) {\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (this._materialEffect === effect) {\n      if (!effect) {\n        this._materialDefines = null;\n      }\n\n      return;\n    }\n\n    this._materialDefines = defines;\n    this._materialEffect = effect;\n  };\n  /**\r\n   * Add a new submesh to a mesh\r\n   * @param materialIndex defines the material index to use\r\n   * @param verticesStart defines vertex index start\r\n   * @param verticesCount defines vertices count\r\n   * @param indexStart defines index start\r\n   * @param indexCount defines indices count\r\n   * @param mesh defines the parent mesh\r\n   * @param renderingMesh defines an optional rendering mesh\r\n   * @param createBoundingBox defines if bounding box should be created for this submesh\r\n   * @returns the new submesh\r\n   */\n\n\n  SubMesh.AddToMesh = function (materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {\n    if (createBoundingBox === void 0) {\n      createBoundingBox = true;\n    }\n\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  };\n\n  Object.defineProperty(SubMesh.prototype, \"IsGlobal\", {\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\n    get: function () {\n      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the submesh BoudingInfo object\r\n   * @returns current bounding info (or mesh's one if the submesh is global)\r\n   */\n\n  SubMesh.prototype.getBoundingInfo = function () {\n    if (this.IsGlobal) {\n      return this._mesh.getBoundingInfo();\n    }\n\n    return this._boundingInfo;\n  };\n  /**\r\n   * Sets the submesh BoundingInfo\r\n   * @param boundingInfo defines the new bounding info to use\r\n   * @returns the SubMesh\r\n   */\n\n\n  SubMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n  /**\r\n   * Returns the mesh of the current submesh\r\n   * @return the parent mesh\r\n   */\n\n\n  SubMesh.prototype.getMesh = function () {\n    return this._mesh;\n  };\n  /**\r\n   * Returns the rendering mesh of the submesh\r\n   * @returns the rendering mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getRenderingMesh = function () {\n    return this._renderingMesh;\n  };\n  /**\r\n   * Returns the replacement mesh of the submesh\r\n   * @returns the replacement mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getReplacementMesh = function () {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  };\n  /**\r\n   * Returns the effective mesh of the submesh\r\n   * @returns the effective mesh (could be different from parent mesh)\r\n   */\n\n\n  SubMesh.prototype.getEffectiveMesh = function () {\n    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  };\n  /**\r\n   * Returns the submesh material\r\n   * @returns null or the current material\r\n   */\n\n\n  SubMesh.prototype.getMaterial = function () {\n    var rootMaterial = this._renderingMesh.material;\n\n    if (rootMaterial === null || rootMaterial === undefined) {\n      return this._mesh.getScene().defaultMaterial;\n    } else if (this._IsMultiMaterial(rootMaterial)) {\n      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this._materialDefines = null;\n      }\n\n      return effectiveMaterial;\n    }\n\n    return rootMaterial;\n  };\n\n  SubMesh.prototype._IsMultiMaterial = function (material) {\n    return material.getSubMaterial !== undefined;\n  }; // Methods\n\n  /**\r\n   * Sets a new updated BoundingInfo object to the submesh\r\n   * @param data defines an optional position array to use to determine the bounding info\r\n   * @returns the SubMesh\r\n   */\n\n\n  SubMesh.prototype.refreshBoundingInfo = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    this._lastColliderWorldVertices = null;\n\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n\n    var indices = this._renderingMesh.getIndices();\n\n    var extend; //is this the only submesh?\n\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      var boundingInfo = this._renderingMesh.getBoundingInfo(); //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n\n\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._checkCollision = function (collider) {\n    var boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  };\n  /**\r\n   * Updates the submesh BoundingInfo\r\n   * @param world defines the world matrix to use to update the bounding info\r\n   * @returns the submesh\r\n   */\n\n\n  SubMesh.prototype.updateBoundingInfo = function (world) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n\n    return this;\n  };\n  /**\r\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n   * @param frustumPlanes defines the frustum planes\r\n   * @returns true if the submesh is intersecting with the frustum\r\n   */\n\n\n  SubMesh.prototype.isInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  };\n  /**\r\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n   * @param frustumPlanes defines the frustum planes\r\n   * @returns true if the submesh is inside the frustum\r\n   */\n\n\n  SubMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\r\n   * Renders the submesh\r\n   * @param enableAlphaMode defines if alpha needs to be used\r\n   * @returns the submesh\r\n   */\n\n\n  SubMesh.prototype.render = function (enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n\n    return this;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  SubMesh.prototype._getLinesIndexBuffer = function (indices, engine) {\n    if (!this._linesIndexBuffer) {\n      var linesIndices = [];\n\n      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n\n    return this._linesIndexBuffer;\n  };\n  /**\r\n   * Checks if the submesh intersects with a ray\r\n   * @param ray defines the ray to test\r\n   * @returns true is the passed ray intersects the submesh bounding box\r\n   */\n\n\n  SubMesh.prototype.canIntersects = function (ray) {\n    var boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  };\n  /**\r\n   * Intersects current submesh with a ray\r\n   * @param ray defines the ray to test\r\n   * @param positions defines mesh's positions array\r\n   * @param indices defines mesh's indices array\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @returns intersection info or null if no intersection\r\n   */\n\n\n  SubMesh.prototype.intersects = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var material = this.getMaterial();\n\n    if (!material) {\n      return null;\n    }\n\n    var step = 3;\n    var checkStopper = false;\n\n    switch (material.fillMode) {\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n\n      default:\n        break;\n    } // LineMesh first as it's also a Mesh...\n\n\n    if (this._mesh.getClassName() === \"InstancedLinesMesh\" || this._mesh.getClassName() === \"LinesMesh\") {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      var p0 = positions[indices[index]];\n      var p1 = positions[indices[index + 1]];\n      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectUnIndexedLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n    var intersectInfo = null; // Line test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectTriangles = function (ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    var faceID = -1;\n\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += step) {\n      faceID++;\n      var indexA = indices[index];\n      var indexB = indices[index + 1];\n      var indexC = indices[index + 2];\n\n      if (checkStopper && indexC === 0xFFFFFFFF) {\n        index += 2;\n        continue;\n      }\n\n      var p0 = positions[indexA];\n      var p1 = positions[indexB];\n      var p2 = positions[indexC];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceID;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._intersectUnIndexedTriangles = function (ray, positions, indices, fastCheck, trianglePredicate) {\n    var intersectInfo = null; // Triangles test\n\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      var p0 = positions[index];\n      var p1 = positions[index + 1];\n      var p2 = positions[index + 2];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  };\n  /** @hidden */\n\n\n  SubMesh.prototype._rebuild = function () {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }; // Clone\n\n  /**\r\n   * Creates a new submesh from the passed mesh\r\n   * @param newMesh defines the new hosting mesh\r\n   * @param newRenderingMesh defines an optional rendering mesh\r\n   * @returns the new submesh\r\n   */\n\n\n  SubMesh.prototype.clone = function (newMesh, newRenderingMesh) {\n    var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n\n    if (!this.IsGlobal) {\n      var boundingInfo = this.getBoundingInfo();\n\n      if (!boundingInfo) {\n        return result;\n      }\n\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n\n    return result;\n  }; // Dispose\n\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SubMesh.prototype.dispose = function () {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n\n      this._linesIndexBuffer = null;\n    } // Remove from mesh\n\n\n    var index = this._mesh.subMeshes.indexOf(this);\n\n    this._mesh.subMeshes.splice(index, 1);\n  };\n  /**\r\n   * Gets the class name\r\n   * @returns the string \"SubMesh\".\r\n   */\n\n\n  SubMesh.prototype.getClassName = function () {\n    return \"SubMesh\";\n  }; // Statics\n\n  /**\r\n   * Creates a new submesh from indices data\r\n   * @param materialIndex the index of the main mesh material\r\n   * @param startIndex the index where to start the copy in the mesh indices array\r\n   * @param indexCount the number of indices to copy then from the startIndex\r\n   * @param mesh the main mesh to create the submesh from\r\n   * @param renderingMesh the optional rendering mesh\r\n   * @returns a new submesh\r\n   */\n\n\n  SubMesh.CreateFromIndices = function (materialIndex, startIndex, indexCount, mesh, renderingMesh) {\n    var minVertexIndex = Number.MAX_VALUE;\n    var maxVertexIndex = -Number.MAX_VALUE;\n    var whatWillRender = renderingMesh || mesh;\n    var indices = whatWillRender.getIndices();\n\n    for (var index = startIndex; index < startIndex + indexCount; index++) {\n      var vertexIndex = indices[index];\n\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);\n  };\n\n  return SubMesh;\n}();\n\nexport { SubMesh };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/subMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"./buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport { ICullable, BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { DataBuffer } from './dataBuffer';\r\nimport { extractMinAndMaxIndexed } from '../Maths/math.functions';\r\nimport { Plane } from '../Maths/math.plane';\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type MaterialDefines = import(\"../Materials/materialDefines\").MaterialDefines;\r\ndeclare type MultiMaterial = import(\"../Materials/multiMaterial\").MultiMaterial;\r\ndeclare type AbstractMesh = import(\"./abstractMesh\").AbstractMesh;\r\ndeclare type Mesh = import(\"./mesh\").Mesh;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    /** @hidden */\r\n    public _materialDefines: Nullable<MaterialDefines> = null;\r\n    /** @hidden */\r\n    public _materialEffect: Nullable<Effect> = null;\r\n    /** @hidden */\r\n    public _effectOverride: Nullable<Effect> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._materialDefines;\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        this._materialDefines = defines;\r\n    }\r\n\r\n    /**\r\n     * Gets associated effect\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._effectOverride ?? this._materialEffect;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<MaterialDefines> = null) {\r\n        if (this._materialEffect === effect) {\r\n            if (!effect) {\r\n                this._materialDefines = null;\r\n            }\r\n            return;\r\n        }\r\n        this._materialDefines = defines;\r\n        this._materialEffect = effect;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @hidden */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @hidden */\r\n    public _trianglePlanes: Plane[];\r\n    /** @hidden */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n\r\n    /** @hidden */\r\n    public _renderId = 0;\r\n    /** @hidden */\r\n    public _alphaIndex: number = 0;\r\n    /** @hidden */\r\n    public _distanceToCamera: number = 0;\r\n    /** @hidden */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox: boolean = true): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox: boolean = true, addToMesh = true) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    public get IsGlobal(): boolean {\r\n        return (this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices());\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoudingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @return the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(): Nullable<Material> {\r\n        var rootMaterial = this._renderingMesh.material;\r\n\r\n        if (rootMaterial === null || rootMaterial === undefined) {\r\n            return this._mesh.getScene().defaultMaterial;\r\n        } else if (this._IsMultiMaterial(rootMaterial)) {\r\n            var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this._materialDefines = null;\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _IsMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        var indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        var extend: { minimum: Vector3, maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            let boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            var linesIndices = [];\r\n\r\n            for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1],\r\n                    indices[index + 1], indices[index + 2],\r\n                    indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case 3:\r\n            case 4:\r\n            case 5:\r\n            case 6:\r\n            case 8:\r\n                return null;\r\n            case 7:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (this._mesh.getClassName() === \"InstancedLinesMesh\" || this._mesh.getClassName() === \"LinesMesh\") {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        }\r\n        else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            var p0 = positions[indices[index]];\r\n            var p1 = positions[indices[index + 1]];\r\n\r\n            var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            var p0 = positions[index];\r\n            var p1 = positions[index + 1];\r\n\r\n            var length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectTriangles(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        step: number, checkStopper: boolean,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceID = -1;\r\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += step) {\r\n            faceID++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xFFFFFFFF) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            var p0 = positions[indexA];\r\n            var p1 = positions[indexB];\r\n            var p2 = positions[indexC];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceID;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    private _intersectUnIndexedTriangles(ray: Ray, positions: Vector3[], indices: IndicesArray,\r\n        fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            var p0 = positions[index];\r\n            var p1 = positions[index + 1];\r\n            var p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\r\n                continue;\r\n            }\r\n\r\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            let boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        var index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(materialIndex: number, startIndex: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh): SubMesh {\r\n        var minVertexIndex = Number.MAX_VALUE;\r\n        var maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = (renderingMesh || mesh);\r\n        var indices = whatWillRender!.getIndices()!;\r\n\r\n        for (var index = startIndex; index < startIndex + indexCount; index++) {\r\n            var vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}