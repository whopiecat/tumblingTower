{"ast":null,"code":"import { Vector3 } from \"../../../Maths/math\";\nimport { Scalar } from \"../../../Maths/math.scalar\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\nimport \"../../../Shaders/hdrFiltering.vertex\";\nimport \"../../../Shaders/hdrFiltering.fragment\";\nimport { Logger } from '../../../Misc/logger';\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\n\nvar HDRFiltering =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates HDR filter for reflection maps\r\n   *\r\n   * @param engine Thin engine\r\n   * @param options Options\r\n   */\n  function HDRFiltering(engine, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._lodGenerationOffset = 0;\n    this._lodGenerationScale = 0.8;\n    /**\r\n     * Quality switch for prefiltering. Should be set to `4096` unless\r\n     * you care about baking speed.\r\n     */\n\n    this.quality = 4096;\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\n\n    this.hdrScale = 1; // pass\n\n    this._engine = engine;\n    this.hdrScale = options.hdrScale || this.hdrScale;\n    this.quality = options.hdrScale || this.quality;\n  }\n\n  HDRFiltering.prototype._createRenderTarget = function (size) {\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else if (this._engine.getCaps().textureFloatRender) {\n      textureType = 1;\n    }\n\n    var texture = this._engine.createRenderTargetCubeTexture(size, {\n      format: 5,\n      type: textureType,\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samplingMode: 1\n    });\n\n    this._engine.updateTextureWrappingMode(texture, 0, 0, 0);\n\n    this._engine.updateTextureSamplingMode(3, texture, true);\n\n    return texture;\n  };\n\n  HDRFiltering.prototype._prefilterInternal = function (texture) {\n    var width = texture.getSize().width;\n    var mipmapsCount = Math.round(Scalar.Log2(width)) + 1;\n    var effect = this._effectWrapper.effect;\n\n    var outputTexture = this._createRenderTarget(width);\n\n    this._effectRenderer.setViewport();\n\n    var intTexture = texture.getInternalTexture();\n\n    if (intTexture) {\n      // Just in case generate fresh clean mips.\n      this._engine.updateTextureSamplingMode(3, intTexture, true);\n    }\n\n    this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n    var directions = [[new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)]];\n    effect.setFloat(\"hdrScale\", this.hdrScale);\n    effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n    effect.setTexture(\"inputTexture\", texture);\n\n    for (var face = 0; face < 6; face++) {\n      effect.setVector3(\"up\", directions[face][0]);\n      effect.setVector3(\"right\", directions[face][1]);\n      effect.setVector3(\"front\", directions[face][2]);\n\n      for (var lod = 0; lod < mipmapsCount; lod++) {\n        this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n\n        var alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n\n        if (lod === 0) {\n          alpha = 0;\n        }\n\n        effect.setFloat(\"alphaG\", alpha);\n\n        this._effectRenderer.draw();\n      }\n    } // Cleanup\n\n\n    this._effectRenderer.restoreStates();\n\n    this._engine.restoreDefaultFramebuffer();\n\n    this._engine._releaseFramebufferObjects(outputTexture);\n\n    this._engine._releaseTexture(texture._texture); // Internal Swap\n\n\n    outputTexture._swapAndDie(texture._texture);\n\n    texture._prefiltered = true;\n    return texture;\n  };\n\n  HDRFiltering.prototype._createEffect = function (texture, onCompiled) {\n    var defines = [];\n\n    if (texture.gammaSpace) {\n      defines.push(\"#define GAMMA_INPUT\");\n    }\n\n    defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n\n    var effectWrapper = new EffectWrapper({\n      engine: this._engine,\n      name: \"hdrFiltering\",\n      vertexShader: \"hdrFiltering\",\n      fragmentShader: \"hdrFiltering\",\n      samplerNames: [\"inputTexture\"],\n      uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n      useShaderStore: true,\n      defines: defines,\n      onCompiled: onCompiled\n    });\n    return effectWrapper;\n  };\n  /**\r\n   * Get a value indicating if the filter is ready to be used\r\n   * @param texture Texture to filter\r\n   * @returns true if the filter is ready\r\n   */\n\n\n  HDRFiltering.prototype.isReady = function (texture) {\n    return texture.isReady() && this._effectWrapper.effect.isReady();\n  };\n  /**\r\n    * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n    * Prefiltering will be invoked at the end of next rendering pass.\r\n    * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n    * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n    * @param texture Texture to filter\r\n    * @param onFinished Callback when filtering is done\r\n    * @return Promise called when prefiltering is done\r\n    */\n\n\n  HDRFiltering.prototype.prefilter = function (texture, onFinished) {\n    var _this = this;\n\n    if (onFinished === void 0) {\n      onFinished = null;\n    }\n\n    if (this._engine.webGLVersion === 1) {\n      Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n      return;\n    }\n\n    return new Promise(function (resolve) {\n      _this._effectRenderer = new EffectRenderer(_this._engine);\n      _this._effectWrapper = _this._createEffect(texture);\n\n      _this._effectWrapper.effect.executeWhenCompiled(function () {\n        _this._prefilterInternal(texture);\n\n        _this._effectRenderer.dispose();\n\n        _this._effectWrapper.dispose();\n\n        resolve();\n\n        if (onFinished) {\n          onFinished();\n        }\n      });\n    });\n  };\n\n  return HDRFiltering;\n}();\n\nexport { HDRFiltering };","map":{"version":3,"sources":["../../../../../sourceES6/core/Materials/Textures/Filtering/hdrFiltering.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"../../../Maths/math\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { InternalTexture } from \"../internalTexture\";\r\nimport { BaseTexture } from \"../baseTexture\";\r\nimport { ThinEngine } from \"../../../Engines/thinEngine\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\r\nimport { Nullable } from '../../../types';\r\n\r\nimport \"../../../Shaders/hdrFiltering.vertex\";\r\nimport \"../../../Shaders/hdrFiltering.fragment\";\r\nimport { Logger } from '../../../Misc/logger';\r\n\r\n/**\r\n * Options for texture filtering\r\n */\r\ninterface IHDRFilteringOptions {\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    hdrScale?: number;\r\n\r\n    /**\r\n     * Quality of the filter. Should be `4096` for prefiltering\r\n     */\r\n    quality?: number;\r\n}\r\n\r\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\r\nexport class HDRFiltering {\r\n\r\n    private _engine: ThinEngine;\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    private _lodGenerationOffset: number = 0;\r\n    private _lodGenerationScale: number = 0.8;\r\n\r\n    /**\r\n     * Quality switch for prefiltering. Should be set to `4096` unless\r\n     * you care about baking speed.\r\n     */\r\n    public quality: number = 4096;\r\n\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    public hdrScale: number = 1;\r\n\r\n    /**\r\n     * Instantiates HDR filter for reflection maps\r\n     *\r\n     * @param engine Thin engine\r\n     * @param options Options\r\n     */\r\n    constructor(engine: ThinEngine, options: IHDRFilteringOptions = {}) {\r\n        // pass\r\n        this._engine = engine;\r\n        this.hdrScale = options.hdrScale || this.hdrScale;\r\n        this.quality = options.hdrScale || this.quality;\r\n    }\r\n\r\n    private _createRenderTarget(size: number): InternalTexture {\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = 2;\r\n        }\r\n        else if (this._engine.getCaps().textureFloatRender) {\r\n            textureType = 1;\r\n        }\r\n\r\n        const texture = this._engine.createRenderTargetCubeTexture(size, {\r\n            format: 5,\r\n            type: textureType,\r\n            generateMipMaps: false,\r\n            generateDepthBuffer: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: 1\r\n        });\r\n        this._engine.updateTextureWrappingMode(texture,\r\n            0,\r\n            0,\r\n            0);\r\n\r\n        this._engine.updateTextureSamplingMode(3, texture, true);\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _prefilterInternal(texture: BaseTexture): BaseTexture {\r\n        const width = texture.getSize().width;\r\n        const mipmapsCount = Math.round(Scalar.Log2(width)) + 1;\r\n\r\n        const effect = this._effectWrapper.effect;\r\n        const outputTexture = this._createRenderTarget(width);\r\n        this._effectRenderer.setViewport();\r\n\r\n        const intTexture = texture.getInternalTexture();\r\n        if (intTexture) {\r\n            // Just in case generate fresh clean mips.\r\n            this._engine.updateTextureSamplingMode(3, intTexture, true);\r\n        }\r\n\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        const directions = [\r\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\r\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\r\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\r\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\r\n        ];\r\n\r\n        effect.setFloat(\"hdrScale\", this.hdrScale);\r\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\r\n        effect.setTexture(\"inputTexture\", texture);\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            effect.setVector3(\"up\", directions[face][0]);\r\n            effect.setVector3(\"right\", directions[face][1]);\r\n            effect.setVector3(\"front\", directions[face][2]);\r\n\r\n            for (let lod = 0; lod < mipmapsCount; lod++) {\r\n\r\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\r\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\r\n                if (lod === 0) {\r\n                    alpha = 0;\r\n                }\r\n\r\n                effect.setFloat(\"alphaG\", alpha);\r\n\r\n                this._effectRenderer.draw();\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.restoreDefaultFramebuffer();\r\n        this._engine._releaseFramebufferObjects(outputTexture);\r\n        this._engine._releaseTexture(texture._texture!);\r\n\r\n        // Internal Swap\r\n        outputTexture._swapAndDie(texture._texture!);\r\n\r\n        texture._prefiltered = true;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _createEffect(texture: BaseTexture, onCompiled?: Nullable<(effect: Effect) => void>): EffectWrapper {\r\n        const defines = [];\r\n        if (texture.gammaSpace) {\r\n            defines.push(\"#define GAMMA_INPUT\");\r\n        }\r\n\r\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            name: \"hdrFiltering\",\r\n            vertexShader: \"hdrFiltering\",\r\n            fragmentShader: \"hdrFiltering\",\r\n            samplerNames: [\"inputTexture\"],\r\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\r\n            useShaderStore: true,\r\n            defines,\r\n            onCompiled: onCompiled\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the filter is ready to be used\r\n     * @param texture Texture to filter\r\n     * @returns true if the filter is ready\r\n     */\r\n    public isReady(texture: BaseTexture) {\r\n        return (texture.isReady() && this._effectWrapper.effect.isReady());\r\n    }\r\n\r\n    /**\r\n      * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n      * Prefiltering will be invoked at the end of next rendering pass.\r\n      * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n      * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n      * @param texture Texture to filter\r\n      * @param onFinished Callback when filtering is done\r\n      * @return Promise called when prefiltering is done\r\n      */\r\n    public prefilter(texture: BaseTexture, onFinished: Nullable<() => void> = null) {\r\n        if (this._engine.webGLVersion === 1) {\r\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n            return;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            this._effectRenderer = new EffectRenderer(this._engine);\r\n            this._effectWrapper = this._createEffect(texture);\r\n            this._effectWrapper.effect.executeWhenCompiled(() => {\r\n                this._prefilterInternal(texture);\r\n                this._effectRenderer.dispose();\r\n                this._effectWrapper.dispose();\r\n                resolve();\r\n                if (onFinished) {\r\n                    onFinished();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}