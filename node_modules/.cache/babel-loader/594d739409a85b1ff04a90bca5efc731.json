{"ast":null,"code":"/**\r\n * Scalar computation library\r\n */\nvar Scalar =\n/** @class */\nfunction () {\n  function Scalar() {}\n  /**\r\n   * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n   * @param a number\r\n   * @param b number\r\n   * @param epsilon (default = 1.401298E-45)\r\n   * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n   */\n\n\n  Scalar.WithinEpsilon = function (a, b, epsilon) {\n    if (epsilon === void 0) {\n      epsilon = 1.401298E-45;\n    }\n\n    var num = a - b;\n    return -epsilon <= num && num <= epsilon;\n  };\n  /**\r\n   * Returns a string : the upper case translation of the number i to hexadecimal.\r\n   * @param i number\r\n   * @returns the upper case translation of the number i to hexadecimal.\r\n   */\n\n\n  Scalar.ToHex = function (i) {\n    var str = i.toString(16);\n\n    if (i <= 15) {\n      return (\"0\" + str).toUpperCase();\n    }\n\n    return str.toUpperCase();\n  };\n  /**\r\n   * Returns -1 if value is negative and +1 is value is positive.\r\n   * @param value the value\r\n   * @returns the value itself if it's equal to zero.\r\n   */\n\n\n  Scalar.Sign = function (value) {\n    value = +value; // convert to a number\n\n    if (value === 0 || isNaN(value)) {\n      return value;\n    }\n\n    return value > 0 ? 1 : -1;\n  };\n  /**\r\n   * Returns the value itself if it's between min and max.\r\n   * Returns min if the value is lower than min.\r\n   * Returns max if the value is greater than max.\r\n   * @param value the value to clmap\r\n   * @param min the min value to clamp to (default: 0)\r\n   * @param max the max value to clamp to (default: 1)\r\n   * @returns the clamped value\r\n   */\n\n\n  Scalar.Clamp = function (value, min, max) {\n    if (min === void 0) {\n      min = 0;\n    }\n\n    if (max === void 0) {\n      max = 1;\n    }\n\n    return Math.min(max, Math.max(min, value));\n  };\n  /**\r\n   * the log2 of value.\r\n   * @param value the value to compute log2 of\r\n   * @returns the log2 of value.\r\n   */\n\n\n  Scalar.Log2 = function (value) {\n    return Math.log(value) * Math.LOG2E;\n  };\n  /**\r\n  * Loops the value, so that it is never larger than length and never smaller than 0.\r\n  *\r\n  * This is similar to the modulo operator but it works with floating point numbers.\r\n  * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n  * With t = 5 and length = 2.5, the result would be 0.0.\r\n  * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n  * @param value the value\r\n  * @param length the length\r\n  * @returns the looped value\r\n  */\n\n\n  Scalar.Repeat = function (value, length) {\n    return value - Math.floor(value / length) * length;\n  };\n  /**\r\n   * Normalize the value between 0.0 and 1.0 using min and max values\r\n   * @param value value to normalize\r\n   * @param min max to normalize between\r\n   * @param max min to normalize between\r\n   * @returns the normalized value\r\n   */\n\n\n  Scalar.Normalize = function (value, min, max) {\n    return (value - min) / (max - min);\n  };\n  /**\r\n  * Denormalize the value from 0.0 and 1.0 using min and max values\r\n  * @param normalized value to denormalize\r\n  * @param min max to denormalize between\r\n  * @param max min to denormalize between\r\n  * @returns the denormalized value\r\n  */\n\n\n  Scalar.Denormalize = function (normalized, min, max) {\n    return normalized * (max - min) + min;\n  };\n  /**\r\n  * Calculates the shortest difference between two given angles given in degrees.\r\n  * @param current current angle in degrees\r\n  * @param target target angle in degrees\r\n  * @returns the delta\r\n  */\n\n\n  Scalar.DeltaAngle = function (current, target) {\n    var num = Scalar.Repeat(target - current, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return num;\n  };\n  /**\r\n  * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n  * @param tx value\r\n  * @param length length\r\n  * @returns The returned value will move back and forth between 0 and length\r\n  */\n\n\n  Scalar.PingPong = function (tx, length) {\n    var t = Scalar.Repeat(tx, length * 2.0);\n    return length - Math.abs(t - length);\n  };\n  /**\r\n  * Interpolates between min and max with smoothing at the limits.\r\n  *\r\n  * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n  * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n  * @param from from\r\n  * @param to to\r\n  * @param tx value\r\n  * @returns the smooth stepped value\r\n  */\n\n\n  Scalar.SmoothStep = function (from, to, tx) {\n    var t = Scalar.Clamp(tx);\n    t = -2.0 * t * t * t + 3.0 * t * t;\n    return to * t + from * (1.0 - t);\n  };\n  /**\r\n  * Moves a value current towards target.\r\n  *\r\n  * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n  * Negative values of maxDelta pushes the value away from target.\r\n  * @param current current value\r\n  * @param target target value\r\n  * @param maxDelta max distance to move\r\n  * @returns resulting value\r\n  */\n\n\n  Scalar.MoveTowards = function (current, target, maxDelta) {\n    var result = 0;\n\n    if (Math.abs(target - current) <= maxDelta) {\n      result = target;\n    } else {\n      result = current + Scalar.Sign(target - current) * maxDelta;\n    }\n\n    return result;\n  };\n  /**\r\n  * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n  *\r\n  * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n  *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n  * @param current current value\r\n  * @param target target value\r\n  * @param maxDelta max distance to move\r\n  * @returns resulting angle\r\n  */\n\n\n  Scalar.MoveTowardsAngle = function (current, target, maxDelta) {\n    var num = Scalar.DeltaAngle(current, target);\n    var result = 0;\n\n    if (-maxDelta < num && num < maxDelta) {\n      result = target;\n    } else {\n      target = current + num;\n      result = Scalar.MoveTowards(current, target, maxDelta);\n    }\n\n    return result;\n  };\n  /**\r\n   * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n   * @param start start value\r\n   * @param end target value\r\n   * @param amount amount to lerp between\r\n   * @returns the lerped value\r\n   */\n\n\n  Scalar.Lerp = function (start, end, amount) {\n    return start + (end - start) * amount;\n  };\n  /**\r\n  * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n  * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n  * @param start start value\r\n  * @param end target value\r\n  * @param amount amount to lerp between\r\n  * @returns the lerped value\r\n  */\n\n\n  Scalar.LerpAngle = function (start, end, amount) {\n    var num = Scalar.Repeat(end - start, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return start + num * Scalar.Clamp(amount);\n  };\n  /**\r\n  * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n  * @param a start value\r\n  * @param b target value\r\n  * @param value value between a and b\r\n  * @returns the inverseLerp value\r\n  */\n\n\n  Scalar.InverseLerp = function (a, b, value) {\n    var result = 0;\n\n    if (a != b) {\n      result = Scalar.Clamp((value - a) / (b - a));\n    } else {\n      result = 0.0;\n    }\n\n    return result;\n  };\n  /**\r\n   * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n   * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n   * @param value1 spline value\r\n   * @param tangent1 spline value\r\n   * @param value2 spline value\r\n   * @param tangent2 spline value\r\n   * @param amount input value\r\n   * @returns hermite result\r\n   */\n\n\n  Scalar.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n    var squared = amount * amount;\n    var cubed = amount * squared;\n    var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    var part2 = -2.0 * cubed + 3.0 * squared;\n    var part3 = cubed - 2.0 * squared + amount;\n    var part4 = cubed - squared;\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n  };\n  /**\r\n  * Returns a random float number between and min and max values\r\n  * @param min min value of random\r\n  * @param max max value of random\r\n  * @returns random value\r\n  */\n\n\n  Scalar.RandomRange = function (min, max) {\n    if (min === max) {\n      return min;\n    }\n\n    return Math.random() * (max - min) + min;\n  };\n  /**\r\n  * This function returns percentage of a number in a given range.\r\n  *\r\n  * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n  * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n  * @param number to convert to percentage\r\n  * @param min min range\r\n  * @param max max range\r\n  * @returns the percentage\r\n  */\n\n\n  Scalar.RangeToPercent = function (number, min, max) {\n    return (number - min) / (max - min);\n  };\n  /**\r\n  * This function returns number that corresponds to the percentage in a given range.\r\n  *\r\n  * PercentToRange(0.34,0,100) will return 34.\r\n  * @param percent to convert to number\r\n  * @param min min range\r\n  * @param max max range\r\n  * @returns the number\r\n  */\n\n\n  Scalar.PercentToRange = function (percent, min, max) {\n    return (max - min) * percent + min;\n  };\n  /**\r\n   * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n   * @param angle The angle to normalize in radian.\r\n   * @return The converted angle.\r\n   */\n\n\n  Scalar.NormalizeRadians = function (angle) {\n    // More precise but slower version kept for reference.\n    // angle = angle % Tools.TwoPi;\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n    //if (angle > Math.PI) {\n    //\tangle -= Tools.TwoPi;\n    //}\n    angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n    return angle;\n  };\n  /**\r\n   * Two pi constants convenient for computation.\r\n   */\n\n\n  Scalar.TwoPi = Math.PI * 2;\n  return Scalar;\n}();\n\nexport { Scalar };","map":{"version":3,"sources":["../../../sourceES6/core/Maths/math.scalar.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Scalar computation library\r\n */\r\nexport class Scalar {\r\n\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    public static TwoPi: number = Math.PI * 2;\r\n\r\n    /**\r\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     * @param a number\r\n     * @param b number\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     */\r\n    public static WithinEpsilon(a: number, b: number, epsilon: number = 1.401298E-45): boolean {\r\n        var num = a - b;\r\n        return -epsilon <= num && num <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Returns a string : the upper case translation of the number i to hexadecimal.\r\n     * @param i number\r\n     * @returns the upper case translation of the number i to hexadecimal.\r\n     */\r\n    public static ToHex(i: number): string {\r\n        var str = i.toString(16);\r\n\r\n        if (i <= 15) {\r\n            return (\"0\" + str).toUpperCase();\r\n        }\r\n\r\n        return str.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    public static Sign(value: number): number {\r\n        value = +value; // convert to a number\r\n\r\n        if (value === 0 || isNaN(value)) {\r\n            return value;\r\n        }\r\n\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the value itself if it's between min and max.\r\n     * Returns min if the value is lower than min.\r\n     * Returns max if the value is greater than max.\r\n     * @param value the value to clmap\r\n     * @param min the min value to clamp to (default: 0)\r\n     * @param max the max value to clamp to (default: 1)\r\n     * @returns the clamped value\r\n     */\r\n    public static Clamp(value: number, min = 0, max = 1): number {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static Log2(value: number): number {\r\n        return Math.log(value) * Math.LOG2E;\r\n    }\r\n\r\n    /**\r\n    * Loops the value, so that it is never larger than length and never smaller than 0.\r\n    *\r\n    * This is similar to the modulo operator but it works with floating point numbers.\r\n    * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n    * With t = 5 and length = 2.5, the result would be 0.0.\r\n    * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n    * @param value the value\r\n    * @param length the length\r\n    * @returns the looped value\r\n    */\r\n    public static Repeat(value: number, length: number): number {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n\r\n    /**\r\n     * Normalize the value between 0.0 and 1.0 using min and max values\r\n     * @param value value to normalize\r\n     * @param min max to normalize between\r\n     * @param max min to normalize between\r\n     * @returns the normalized value\r\n     */\r\n    public static Normalize(value: number, min: number, max: number): number {\r\n        return (value - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n    * Denormalize the value from 0.0 and 1.0 using min and max values\r\n    * @param normalized value to denormalize\r\n    * @param min max to denormalize between\r\n    * @param max min to denormalize between\r\n    * @returns the denormalized value\r\n    */\r\n    public static Denormalize(normalized: number, min: number, max: number): number {\r\n        return (normalized * (max - min) + min);\r\n    }\r\n\r\n    /**\r\n    * Calculates the shortest difference between two given angles given in degrees.\r\n    * @param current current angle in degrees\r\n    * @param target target angle in degrees\r\n    * @returns the delta\r\n    */\r\n    public static DeltaAngle(current: number, target: number): number {\r\n        var num: number = Scalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n    * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n    * @param tx value\r\n    * @param length length\r\n    * @returns The returned value will move back and forth between 0 and length\r\n    */\r\n    public static PingPong(tx: number, length: number): number {\r\n        var t: number = Scalar.Repeat(tx, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n\r\n    /**\r\n    * Interpolates between min and max with smoothing at the limits.\r\n    *\r\n    * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n    * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n    * @param from from\r\n    * @param to to\r\n    * @param tx value\r\n    * @returns the smooth stepped value\r\n    */\r\n    public static SmoothStep(from: number, to: number, tx: number): number {\r\n        var t: number = Scalar.Clamp(tx);\r\n        t = -2.0 * t * t * t + 3.0 * t * t;\r\n        return to * t + from * (1.0 - t);\r\n    }\r\n\r\n    /**\r\n    * Moves a value current towards target.\r\n    *\r\n    * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n    * Negative values of maxDelta pushes the value away from target.\r\n    * @param current current value\r\n    * @param target target value\r\n    * @param maxDelta max distance to move\r\n    * @returns resulting value\r\n    */\r\n    public static MoveTowards(current: number, target: number, maxDelta: number): number {\r\n        var result: number = 0;\r\n        if (Math.abs(target - current) <= maxDelta) {\r\n            result = target;\r\n        } else {\r\n            result = current + Scalar.Sign(target - current) * maxDelta;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n    *\r\n    * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n    *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n    * @param current current value\r\n    * @param target target value\r\n    * @param maxDelta max distance to move\r\n    * @returns resulting angle\r\n    */\r\n    public static MoveTowardsAngle(current: number, target: number, maxDelta: number): number {\r\n        var num: number = Scalar.DeltaAngle(current, target);\r\n        var result: number = 0;\r\n        if (-maxDelta < num && num < maxDelta) {\r\n            result = target;\r\n        } else {\r\n            target = current + num;\r\n            result = Scalar.MoveTowards(current, target, maxDelta);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static Lerp(start: number, end: number, amount: number): number {\r\n        return start + ((end - start) * amount);\r\n    }\r\n\r\n    /**\r\n    * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n    * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n    * @param start start value\r\n    * @param end target value\r\n    * @param amount amount to lerp between\r\n    * @returns the lerped value\r\n    */\r\n    public static LerpAngle(start: number, end: number, amount: number): number {\r\n        var num: number = Scalar.Repeat(end - start, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return start + num * Scalar.Clamp(amount);\r\n    }\r\n\r\n    /**\r\n    * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n    * @param a start value\r\n    * @param b target value\r\n    * @param value value between a and b\r\n    * @returns the inverseLerp value\r\n    */\r\n    public static InverseLerp(a: number, b: number, value: number): number {\r\n        var result: number = 0;\r\n        if (a != b) {\r\n            result = Scalar.Clamp((value - a) / (b - a));\r\n        } else {\r\n            result = 0.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n     * @param value1 spline value\r\n     * @param tangent1 spline value\r\n     * @param value2 spline value\r\n     * @param tangent2 spline value\r\n     * @param amount input value\r\n     * @returns hermite result\r\n     */\r\n    public static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n\r\n        return (((value1 * part1) + (value2 * part2)) + (tangent1 * part3)) + (tangent2 * part4);\r\n    }\r\n\r\n    /**\r\n    * Returns a random float number between and min and max values\r\n    * @param min min value of random\r\n    * @param max max value of random\r\n    * @returns random value\r\n    */\r\n    public static RandomRange(min: number, max: number): number {\r\n        if (min === max) { return min; }\r\n        return ((Math.random() * (max - min)) + min);\r\n    }\r\n\r\n    /**\r\n    * This function returns percentage of a number in a given range.\r\n    *\r\n    * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n    * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n    * @param number to convert to percentage\r\n    * @param min min range\r\n    * @param max max range\r\n    * @returns the percentage\r\n    */\r\n    public static RangeToPercent(number: number, min: number, max: number): number {\r\n        return ((number - min) / (max - min));\r\n    }\r\n\r\n    /**\r\n    * This function returns number that corresponds to the percentage in a given range.\r\n    *\r\n    * PercentToRange(0.34,0,100) will return 34.\r\n    * @param percent to convert to number\r\n    * @param min min range\r\n    * @param max max range\r\n    * @returns the number\r\n    */\r\n    public static PercentToRange(percent: number, min: number, max: number): number {\r\n        return ((max - min) * percent + min);\r\n    }\r\n\r\n    /**\r\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n     * @param angle The angle to normalize in radian.\r\n     * @return The converted angle.\r\n     */\r\n    public static NormalizeRadians(angle: number): number {\r\n        // More precise but slower version kept for reference.\r\n        // angle = angle % Tools.TwoPi;\r\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n        //if (angle > Math.PI) {\r\n        //\tangle -= Tools.TwoPi;\r\n        //}\r\n\r\n        angle -= (Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi));\r\n\r\n        return angle;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}