{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { UniformBuffer } from \"./uniformBuffer\";\nimport { Logger } from \"../Misc/logger\";\nimport { Plane } from '../Maths/math.plane';\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\n\nvar Material =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a material instance\r\n   * @param name defines the name of the material\r\n   * @param scene defines the scene to reference\r\n   * @param doNotAdd specifies if the material should be added to the scene\r\n   */\n  function Material(name, scene, doNotAdd) {\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\n    this.shadowDepthWrapper = null;\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\n\n    this.allowShaderHotSwapping = true;\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\n\n    this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    this.reservedDataStore = null;\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\n\n    this.checkReadyOnEveryCall = false;\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\n\n    this.checkReadyOnlyOnce = false;\n    /**\r\n     * The state of the material\r\n     */\n\n    this.state = \"\";\n    /**\r\n     * The alpha value of the material\r\n     */\n\n    this._alpha = 1.0;\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\n\n    this._backFaceCulling = true;\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\n\n    this.onCompiled = null;\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\n\n    this.onError = null;\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\n\n    this.getRenderTargetTextures = null;\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\n\n    this.doNotSerialize = false;\n    /**\r\n     * @hidden\r\n     */\n\n    this._storeEffectOnSubMeshes = false;\n    /**\r\n     * Stores the animations for the material\r\n     */\n\n    this.animations = null;\n    /**\r\n    * An event triggered when the material is disposed\r\n    */\n\n    this.onDisposeObservable = new Observable();\n    /**\r\n     * An observer which watches for dispose events\r\n     */\n\n    this._onDisposeObserver = null;\n    this._onUnBindObservable = null;\n    /**\r\n     * An observer which watches for bind events\r\n     */\n\n    this._onBindObserver = null;\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\n\n    this._alphaMode = 2;\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\n\n    this._needDepthPrePass = false;\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\n\n    this.disableDepthWrite = false;\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\n\n    this.disableColorWrite = false;\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\n\n    this.forceDepthWrite = false;\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\n\n    this.depthFunction = 0;\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\n\n    this.separateCullingPass = false;\n    /**\r\n     * Stores the state specifing if fog should be enabled\r\n     */\n\n    this._fogEnabled = true;\n    /**\r\n     * Stores the size of points\r\n     */\n\n    this.pointSize = 1.0;\n    /**\r\n     * Stores the z offset value\r\n     */\n\n    this.zOffset = 0;\n    /**\r\n     * @hidden\r\n     * Stores the effects for the material\r\n     */\n\n    this._effect = null;\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\n\n    this._useUBO = false;\n    /**\r\n     * Stores the fill mode state\r\n     */\n\n    this._fillMode = Material.TriangleFillMode;\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\n\n    this._cachedDepthWriteState = false;\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\n\n    this._cachedColorWriteState = false;\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\n\n    this._cachedDepthFunctionState = 0;\n    /** @hidden */\n\n    this._indexInSceneMaterialArray = -1;\n    /** @hidden */\n\n    this.meshMap = null;\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\n\n    this._forceAlphaTest = false;\n    /**\r\n     * The transparency mode of the material.\r\n     */\n\n    this._transparencyMode = null;\n    this.name = name;\n    var idSubscript = 1;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.id = name || Tools.RandomId();\n\n    while (this._scene.getMaterialByID(this.id)) {\n      this.id = name + \" \" + idSubscript++;\n    }\n\n    this.uniqueId = this._scene.getUniqueId();\n\n    if (this._scene.useRightHandedSystem) {\n      this.sideOrientation = Material.ClockWiseSideOrientation;\n    } else {\n      this.sideOrientation = Material.CounterClockWiseSideOrientation;\n    }\n\n    this._uniformBuffer = new UniformBuffer(this._scene.getEngine());\n    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\n\n    if (!doNotAdd) {\n      this._scene.addMaterial(this);\n    }\n\n    if (this._scene.useMaterialMeshMap) {\n      this.meshMap = {};\n    }\n  }\n\n  Object.defineProperty(Material.prototype, \"canRenderToMRT\", {\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\n    get: function () {\n      // By default, shaders are not compatible with MRTs\n      // Base classes should override that if their shader supports MRT\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alpha\", {\n    /**\r\n     * Gets the alpha value of the material\r\n     */\n    get: function () {\n      return this._alpha;\n    },\n\n    /**\r\n     * Sets the alpha value of the material\r\n     */\n    set: function (value) {\n      if (this._alpha === value) {\n        return;\n      }\n\n      this._alpha = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"backFaceCulling\", {\n    /**\r\n     * Gets the back-face culling state\r\n     */\n    get: function () {\n      return this._backFaceCulling;\n    },\n\n    /**\r\n     * Sets the back-face culling state\r\n     */\n    set: function (value) {\n      if (this._backFaceCulling === value) {\n        return;\n      }\n\n      this._backFaceCulling = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"hasRenderTargetTextures\", {\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onDispose\", {\n    /**\r\n     * Called during a dispose event\r\n     */\n    set: function (callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBindObservable\", {\n    /**\r\n    * An event triggered when the material is bound\r\n    */\n    get: function () {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onBind\", {\n    /**\r\n     * Called during a bind event\r\n     */\n    set: function (callback) {\n      if (this._onBindObserver) {\n        this.onBindObservable.remove(this._onBindObserver);\n      }\n\n      this._onBindObserver = this.onBindObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onUnBindObservable\", {\n    /**\r\n    * An event triggered when the material is unbound\r\n    */\n    get: function () {\n      if (!this._onUnBindObservable) {\n        this._onUnBindObservable = new Observable();\n      }\n\n      return this._onUnBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"onEffectCreatedObservable\", {\n    /**\r\n    * An event triggered when the effect is (re)created\r\n    */\n    get: function () {\n      if (!this._onEffectCreatedObservable) {\n        this._onEffectCreatedObservable = new Observable();\n      }\n\n      return this._onEffectCreatedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"alphaMode\", {\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\n    get: function () {\n      return this._alphaMode;\n    },\n\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\n    set: function (value) {\n      if (this._alphaMode === value) {\n        return;\n      }\n\n      this._alphaMode = value;\n      this.markAsDirty(Material.TextureDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"needDepthPrePass\", {\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\n    get: function () {\n      return this._needDepthPrePass;\n    },\n\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\n    set: function (value) {\n      if (this._needDepthPrePass === value) {\n        return;\n      }\n\n      this._needDepthPrePass = value;\n\n      if (this._needDepthPrePass) {\n        this.checkReadyOnEveryCall = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fogEnabled\", {\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\n    get: function () {\n      return this._fogEnabled;\n    },\n\n    /**\r\n     * Sets the state for enabling fog\r\n     */\n    set: function (value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"wireframe\", {\n    get: function () {\n      switch (this._fillMode) {\n        case Material.WireFrameFillMode:\n        case Material.LineListDrawMode:\n        case Material.LineLoopDrawMode:\n        case Material.LineStripDrawMode:\n          return true;\n      }\n\n      return this._scene.forceWireframe;\n    },\n\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\n    set: function (value) {\n      this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"pointsCloud\", {\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\n    get: function () {\n      switch (this._fillMode) {\n        case Material.PointFillMode:\n        case Material.PointListDrawMode:\n          return true;\n      }\n\n      return this._scene.forcePointsCloud;\n    },\n\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\n    set: function (value) {\n      this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"fillMode\", {\n    /**\r\n     * Gets the material fill mode\r\n     */\n    get: function () {\n      return this._fillMode;\n    },\n\n    /**\r\n     * Sets the material fill mode\r\n     */\n    set: function (value) {\n      if (this._fillMode === value) {\n        return;\n      }\n\n      this._fillMode = value;\n      this.markAsDirty(Material.MiscDirtyFlag);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a string representation of the current material\r\n   * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n   * @returns a string with material information\r\n   */\n\n  Material.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n\n    if (fullDetails) {}\n\n    return ret;\n  };\n  /**\r\n   * Gets the class name of the material\r\n   * @returns a string with the class name of the material\r\n   */\n\n\n  Material.prototype.getClassName = function () {\n    return \"Material\";\n  };\n\n  Object.defineProperty(Material.prototype, \"isFrozen\", {\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\n    get: function () {\n      return this.checkReadyOnlyOnce;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Locks updates for the material\r\n   */\n\n  Material.prototype.freeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = true;\n  };\n  /**\r\n   * Unlocks updates for the material\r\n   */\n\n\n  Material.prototype.unfreeze = function () {\n    this.markDirty();\n    this.checkReadyOnlyOnce = false;\n  };\n  /**\r\n   * Specifies if the material is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param useInstances specifies if instances should be used\r\n   * @returns a boolean indicating if the material is ready to be used\r\n   */\n\n\n  Material.prototype.isReady = function (mesh, useInstances) {\n    return true;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param subMesh defines which submesh to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  Material.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    return false;\n  };\n  /**\r\n   * Returns the material effect\r\n   * @returns the effect associated with the material\r\n   */\n\n\n  Material.prototype.getEffect = function () {\n    return this._effect;\n  };\n  /**\r\n   * Returns the current scene\r\n   * @returns a Scene\r\n   */\n\n\n  Material.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(Material.prototype, \"transparencyMode\", {\n    /**\r\n     * Gets the current transparency mode.\r\n     */\n    get: function () {\n      return this._transparencyMode;\n    },\n\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\n    set: function (value) {\n      if (this._transparencyMode === value) {\n        return;\n      }\n\n      this._transparencyMode = value;\n      this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\n\n      this._markAllSubMeshesAsTexturesAndMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Material.prototype, \"_disableAlphaBlending\", {\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\n    get: function () {\n      return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha blend mode.\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n  Material.prototype.needAlphaBlending = function () {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n\n    return this.alpha < 1.0;\n  };\n  /**\r\n   * Specifies if the mesh will require alpha blending\r\n   * @param mesh defines the mesh to check\r\n   * @returns a boolean specifying if alpha blending is needed for the mesh\r\n   */\n\n\n  Material.prototype.needAlphaBlendingForMesh = function (mesh) {\n    if (this._disableAlphaBlending && mesh.visibility >= 1.0) {\n      return false;\n    }\n\n    return this.needAlphaBlending() || mesh.visibility < 1.0 || mesh.hasVertexAlpha;\n  };\n  /**\r\n   * Specifies whether or not this material should be rendered in alpha test mode.\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  Material.prototype.needAlphaTesting = function () {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Specifies if material alpha testing should be turned on for the mesh\r\n   * @param mesh defines the mesh to check\r\n   */\n\n\n  Material.prototype._shouldTurnAlphaTestOn = function (mesh) {\n    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\n  };\n  /**\r\n   * Gets the texture used for the alpha test\r\n   * @returns the texture to use for alpha testing\r\n   */\n\n\n  Material.prototype.getAlphaTestTexture = function () {\n    return null;\n  };\n  /**\r\n   * Marks the material to indicate that it needs to be re-calculated\r\n   */\n\n\n  Material.prototype.markDirty = function () {\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n      var mesh = meshes_1[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh.effect) {\n          continue;\n        }\n\n        subMesh.effect._wasPreviouslyReady = false;\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Material.prototype._preBind = function (effect, overrideOrientation) {\n    if (overrideOrientation === void 0) {\n      overrideOrientation = null;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\n    var reverse = orientation === Material.ClockWiseSideOrientation;\n    engine.enableEffect(effect ? effect : this._effect);\n    engine.setState(this.backFaceCulling, this.zOffset, false, reverse);\n    return reverse;\n  };\n  /**\r\n   * Binds the material to the mesh\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh to bind the material to\r\n   */\n\n\n  Material.prototype.bind = function (world, mesh) {};\n  /**\r\n   * Binds the submesh to the material\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  Material.prototype.bindForSubMesh = function (world, mesh, subMesh) {};\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   */\n\n\n  Material.prototype.bindOnlyWorldMatrix = function (world) {};\n  /**\r\n   * Binds the scene's uniform buffer to the effect.\r\n   * @param effect defines the effect to bind to the scene uniform buffer\r\n   * @param sceneUbo defines the uniform buffer storing scene data\r\n   */\n\n\n  Material.prototype.bindSceneUniformBuffer = function (effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n  };\n  /**\r\n   * Binds the view matrix to the effect\r\n   * @param effect defines the effect to bind the view matrix to\r\n   */\n\n\n  Material.prototype.bindView = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n    } else {\n      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n    }\n  };\n  /**\r\n   * Binds the view projection matrix to the effect\r\n   * @param effect defines the effect to bind the view projection matrix to\r\n   */\n\n\n  Material.prototype.bindViewProjection = function (effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n    } else {\n      this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n    }\n  };\n  /**\r\n   * Processes to execute after binding the material to a mesh\r\n   * @param mesh defines the rendered mesh\r\n   */\n\n\n  Material.prototype._afterBind = function (mesh) {\n    this._scene._cachedMaterial = this;\n\n    if (mesh) {\n      this._scene._cachedVisibility = mesh.visibility;\n    } else {\n      this._scene._cachedVisibility = 1;\n    }\n\n    if (this._onBindObservable && mesh) {\n      this._onBindObservable.notifyObservers(mesh);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthWriteState = engine.getDepthWrite();\n      engine.setDepthWrite(false);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      this._cachedColorWriteState = engine.getColorWrite();\n      engine.setColorWrite(false);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\n      engine.setDepthFunction(this.depthFunction);\n    }\n  };\n  /**\r\n   * Unbinds the material from the mesh\r\n   */\n\n\n  Material.prototype.unbind = function () {\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.notifyObservers(this);\n    }\n\n    if (this.depthFunction !== 0) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthFunction(this._cachedDepthFunctionState);\n    }\n\n    if (this.disableDepthWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setDepthWrite(this._cachedDepthWriteState);\n    }\n\n    if (this.disableColorWrite) {\n      var engine = this._scene.getEngine();\n\n      engine.setColorWrite(this._cachedColorWriteState);\n    }\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  Material.prototype.getActiveTextures = function () {\n    return [];\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  Material.prototype.hasTexture = function (texture) {\n    return false;\n  };\n  /**\r\n   * Makes a duplicate of the material, and gives it a new name\r\n   * @param name defines the new name for the duplicated material\r\n   * @returns the cloned material\r\n   */\n\n\n  Material.prototype.clone = function (name) {\n    return null;\n  };\n  /**\r\n   * Gets the meshes bound to the material\r\n   * @returns an array of meshes bound to the material\r\n   */\n\n\n  Material.prototype.getBindedMeshes = function () {\n    var _this = this;\n\n    if (this.meshMap) {\n      var result = new Array();\n\n      for (var meshId in this.meshMap) {\n        var mesh = this.meshMap[meshId];\n\n        if (mesh) {\n          result.push(mesh);\n        }\n      }\n\n      return result;\n    } else {\n      var meshes = this._scene.meshes;\n      return meshes.filter(function (mesh) {\n        return mesh.material === _this;\n      });\n    }\n  };\n  /**\r\n   * Force shader compilation\r\n   * @param mesh defines the mesh associated with this material\r\n   * @param onCompiled defines a function to execute once the material is compiled\r\n   * @param options defines the options to configure the compilation\r\n   * @param onError defines a function to execute if the material fails compiling\r\n   */\n\n\n  Material.prototype.forceCompilation = function (mesh, onCompiled, options, onError) {\n    var _this = this;\n\n    var localOptions = __assign({\n      clipPlane: false,\n      useInstances: false\n    }, options);\n\n    var scene = this.getScene();\n    var currentHotSwapingState = this.allowShaderHotSwapping;\n    this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\n\n    var checkReady = function () {\n      if (!_this._scene || !_this._scene.getEngine()) {\n        return;\n      }\n\n      var clipPlaneState = scene.clipPlane;\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = new Plane(0, 0, 0, 1);\n      }\n\n      if (_this._storeEffectOnSubMeshes) {\n        var allDone = true,\n            lastError = null;\n\n        if (mesh.subMeshes) {\n          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\n\n          if (tempSubMesh._materialDefines) {\n            tempSubMesh._materialDefines._renderId = -1;\n          }\n\n          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\n            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\n              lastError = tempSubMesh.effect.getCompilationError();\n            } else {\n              allDone = false;\n              setTimeout(checkReady, 16);\n            }\n          }\n        }\n\n        if (allDone) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (lastError) {\n            if (onError) {\n              onError(lastError);\n            }\n          }\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        }\n      } else {\n        if (_this.isReady()) {\n          _this.allowShaderHotSwapping = currentHotSwapingState;\n\n          if (onCompiled) {\n            onCompiled(_this);\n          }\n        } else {\n          setTimeout(checkReady, 16);\n        }\n      }\n\n      if (localOptions.clipPlane) {\n        scene.clipPlane = clipPlaneState;\n      }\n    };\n\n    checkReady();\n  };\n  /**\r\n   * Force shader compilation\r\n   * @param mesh defines the mesh that will use this material\r\n   * @param options defines additional options for compiling the shaders\r\n   * @returns a promise that resolves when the compilation completes\r\n   */\n\n\n  Material.prototype.forceCompilationAsync = function (mesh, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.forceCompilation(mesh, function () {\n        resolve();\n      }, options, function (reason) {\n        reject(reason);\n      });\n    });\n  };\n  /**\r\n   * Marks a define in the material to indicate that it needs to be re-computed\r\n   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n   */\n\n\n  Material.prototype.markAsDirty = function (flag) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    Material._DirtyCallbackArray.length = 0;\n\n    if (flag & Material.TextureDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\n    }\n\n    if (flag & Material.LightDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\n    }\n\n    if (flag & Material.FresnelDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\n    }\n\n    if (flag & Material.AttributesDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\n    }\n\n    if (flag & Material.MiscDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\n    }\n\n    if (flag & Material.PrePassDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\n    }\n\n    if (Material._DirtyCallbackArray.length) {\n      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\n    }\n\n    this.getScene().resetCachedMaterial();\n  };\n  /**\r\n   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n   * @param func defines a function which checks material defines against the submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsDirty = function (func) {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var meshes = this.getScene().meshes;\n\n    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {\n      var mesh = meshes_2[_i];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {\n        var subMesh = _b[_a];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh._materialDefines) {\n          continue;\n        }\n\n        func(subMesh._materialDefines);\n      }\n    }\n  };\n  /**\r\n   * Indicates that the scene should check if the rendering now needs a prepass\r\n   */\n\n\n  Material.prototype._markScenePrePassDirty = function () {\n    if (this.getScene().blockMaterialDirtyMechanism) {\n      return;\n    }\n\n    var prePassRenderer = this.getScene().enablePrePassRenderer();\n\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  };\n  /**\r\n   * Indicates that we need to re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAllDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\n  };\n  /**\r\n   * Indicates that image processing needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsImageProcessingDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\n  };\n  /**\r\n   * Indicates that textures need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\n  };\n  /**\r\n   * Indicates that fresnel needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\n  };\n  /**\r\n   * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that lights need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsLightsDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\n  };\n  /**\r\n   * Indicates that attributes need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsAttributesDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\n  };\n  /**\r\n   * Indicates that misc needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that prepass needs to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsPrePassDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  };\n  /**\r\n   * Indicates that textures and misc need to be re-calculated for all submeshes\r\n   */\n\n\n  Material.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function () {\n    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  Material.prototype.setPrePassRenderer = function (prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  Material.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    var scene = this.getScene(); // Animations\n\n    scene.stopAnimation(this);\n    scene.freeProcessedMaterials(); // Remove from scene\n\n    scene.removeMaterial(this);\n\n    if (notBoundToMesh !== true) {\n      // Remove from meshes\n      if (this.meshMap) {\n        for (var meshId in this.meshMap) {\n          var mesh = this.meshMap[meshId];\n\n          if (mesh) {\n            mesh.material = null; // will set the entry in the map to undefined\n\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      } else {\n        var meshes = scene.meshes;\n\n        for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {\n          var mesh = meshes_3[_i];\n\n          if (mesh.material === this && !mesh.sourceMesh) {\n            mesh.material = null;\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      }\n    }\n\n    this._uniformBuffer.dispose(); // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n\n\n    if (forceDisposeEffect && this._effect) {\n      if (!this._storeEffectOnSubMeshes) {\n        this._effect.dispose();\n      }\n\n      this._effect = null;\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n\n    if (this._onBindObservable) {\n      this._onBindObservable.clear();\n    }\n\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.clear();\n    }\n\n    if (this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable.clear();\n    }\n  };\n  /** @hidden */\n\n\n  Material.prototype.releaseVertexArrayObject = function (mesh, forceDisposeEffect) {\n    if (mesh.geometry) {\n      var geometry = mesh.geometry;\n\n      if (this._storeEffectOnSubMeshes) {\n        for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {\n          var subMesh = _a[_i];\n\n          geometry._releaseVertexArrayObject(subMesh._materialEffect);\n\n          if (forceDisposeEffect && subMesh._materialEffect) {\n            subMesh._materialEffect.dispose();\n          }\n        }\n      } else {\n        geometry._releaseVertexArrayObject(this._effect);\n      }\n    }\n  };\n  /**\r\n   * Serializes this material\r\n   * @returns the serialized material object\r\n   */\n\n\n  Material.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Creates a material from parsed material data\r\n   * @param parsedMaterial defines parsed material data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures\r\n   * @returns a new material\r\n   */\n\n\n  Material.Parse = function (parsedMaterial, scene, rootUrl) {\n    if (!parsedMaterial.customType) {\n      parsedMaterial.customType = \"BABYLON.StandardMaterial\";\n    } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n      parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n\n      if (!BABYLON.LegacyPBRMaterial) {\n        Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n        return null;\n      }\n    }\n\n    var materialType = Tools.Instantiate(parsedMaterial.customType);\n    return materialType.Parse(parsedMaterial, scene, rootUrl);\n  };\n  /**\r\n   * Returns the triangle fill mode\r\n   */\n\n\n  Material.TriangleFillMode = 0;\n  /**\r\n   * Returns the wireframe mode\r\n   */\n\n  Material.WireFrameFillMode = 1;\n  /**\r\n   * Returns the point fill mode\r\n   */\n\n  Material.PointFillMode = 2;\n  /**\r\n   * Returns the point list draw mode\r\n   */\n\n  Material.PointListDrawMode = 3;\n  /**\r\n   * Returns the line list draw mode\r\n   */\n\n  Material.LineListDrawMode = 4;\n  /**\r\n   * Returns the line loop draw mode\r\n   */\n\n  Material.LineLoopDrawMode = 5;\n  /**\r\n   * Returns the line strip draw mode\r\n   */\n\n  Material.LineStripDrawMode = 6;\n  /**\r\n   * Returns the triangle strip draw mode\r\n   */\n\n  Material.TriangleStripDrawMode = 7;\n  /**\r\n   * Returns the triangle fan draw mode\r\n   */\n\n  Material.TriangleFanDrawMode = 8;\n  /**\r\n   * Stores the clock-wise side orientation\r\n   */\n\n  Material.ClockWiseSideOrientation = 0;\n  /**\r\n   * Stores the counter clock-wise side orientation\r\n   */\n\n  Material.CounterClockWiseSideOrientation = 1;\n  /**\r\n   * The dirty texture flag value\r\n   */\n\n  Material.TextureDirtyFlag = 1;\n  /**\r\n   * The dirty light flag value\r\n   */\n\n  Material.LightDirtyFlag = 2;\n  /**\r\n   * The dirty fresnel flag value\r\n   */\n\n  Material.FresnelDirtyFlag = 4;\n  /**\r\n   * The dirty attribute flag value\r\n   */\n\n  Material.AttributesDirtyFlag = 8;\n  /**\r\n   * The dirty misc flag value\r\n   */\n\n  Material.MiscDirtyFlag = 16;\n  /**\r\n   * The dirty prepass flag value\r\n   */\n\n  Material.PrePassDirtyFlag = 32;\n  /**\r\n   * The all dirty flag value\r\n   */\n\n  Material.AllDirtyFlag = 63;\n  /**\r\n   * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n   */\n\n  Material.MATERIAL_OPAQUE = 0;\n  /**\r\n   * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n   */\n\n  Material.MATERIAL_ALPHATEST = 1;\n  /**\r\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   */\n\n  Material.MATERIAL_ALPHABLEND = 2;\n  /**\r\n   * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n   * They are also discarded below the alpha cutoff threshold to improve performances.\r\n   */\n\n  Material.MATERIAL_ALPHATESTANDBLEND = 3;\n  /**\r\n   * The Whiteout method is used to blend normals.\r\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\n  /**\r\n   * The Reoriented Normal Mapping method is used to blend normals.\r\n   * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n   */\n\n  Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;\n\n  Material._AllDirtyCallBack = function (defines) {\n    return defines.markAllAsDirty();\n  };\n\n  Material._ImageProcessingDirtyCallBack = function (defines) {\n    return defines.markAsImageProcessingDirty();\n  };\n\n  Material._TextureDirtyCallBack = function (defines) {\n    return defines.markAsTexturesDirty();\n  };\n\n  Material._FresnelDirtyCallBack = function (defines) {\n    return defines.markAsFresnelDirty();\n  };\n\n  Material._MiscDirtyCallBack = function (defines) {\n    return defines.markAsMiscDirty();\n  };\n\n  Material._PrePassDirtyCallBack = function (defines) {\n    return defines.markAsPrePassDirty();\n  };\n\n  Material._LightsDirtyCallBack = function (defines) {\n    return defines.markAsLightDirty();\n  };\n\n  Material._AttributeDirtyCallBack = function (defines) {\n    return defines.markAsAttributesDirty();\n  };\n\n  Material._FresnelAndMiscDirtyCallBack = function (defines) {\n    Material._FresnelDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._TextureAndMiscDirtyCallBack = function (defines) {\n    Material._TextureDirtyCallBack(defines);\n\n    Material._MiscDirtyCallBack(defines);\n  };\n\n  Material._DirtyCallbackArray = [];\n\n  Material._RunDirtyCallBacks = function (defines) {\n    for (var _i = 0, _a = Material._DirtyCallbackArray; _i < _a.length; _i++) {\n      var cb = _a[_i];\n      cb(defines);\n    }\n  };\n\n  __decorate([serialize()], Material.prototype, \"id\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"name\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"state\", void 0);\n\n  __decorate([serialize(\"alpha\")], Material.prototype, \"_alpha\", void 0);\n\n  __decorate([serialize(\"backFaceCulling\")], Material.prototype, \"_backFaceCulling\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"sideOrientation\", void 0);\n\n  __decorate([serialize(\"alphaMode\")], Material.prototype, \"_alphaMode\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"_needDepthPrePass\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"disableColorWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"forceDepthWrite\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"depthFunction\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"separateCullingPass\", void 0);\n\n  __decorate([serialize(\"fogEnabled\")], Material.prototype, \"_fogEnabled\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointSize\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"zOffset\", void 0);\n\n  __decorate([serialize()], Material.prototype, \"pointsCloud\", null);\n\n  __decorate([serialize()], Material.prototype, \"fillMode\", null);\n\n  __decorate([serialize()], Material.prototype, \"transparencyMode\", null);\n\n  return Material;\n}();\n\nexport { Material };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/material.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observer, Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Geometry } from \"../Meshes/geometry\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport { Effect } from \"./effect\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialDefines } from \"./materialDefines\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { IInspectable } from '../Misc/iInspectable';\r\nimport { Plane } from '../Maths/math.plane';\r\nimport { ShadowDepthWrapper } from './shadowDepthWrapper';\r\n\r\ndeclare type PrePassRenderer = import(\"../Rendering/prePassRenderer\").PrePassRenderer;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type InstancedMesh = import('../Meshes/instancedMesh').InstancedMesh;\r\n\r\ndeclare var BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(shaderType: string, code: string) => string>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = 0;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = 1;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = 2;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = 3;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = 4;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = 5;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = 6;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = 7;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = 8;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = 0;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = 1;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = 1;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = 2;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = 4;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = 8;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = 16;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = 32;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = 63;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: MaterialDefines | string[], attributes?: string[], options?: ICustomShaderNameResolveOptions) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT() : boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n        this._alpha = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the back-face culling state\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the back-face culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: number;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n    * An event triggered when the material is disposed\r\n    */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n    * An event triggered when the material is bound\r\n    */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the material is unbound\r\n    */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect, subMesh: Nullable<SubMesh>}>>;\r\n\r\n    /**\r\n    * An event triggered when the effect is (re)created\r\n    */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect, subMesh: Nullable<SubMesh>}> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{effect: Effect, subMesh: Nullable<SubMesh>}>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = 2;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifing if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = (value ? Material.WireFrameFillMode : Material.TriangleFillMode);\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = (value ? Material.PointFillMode : Material.TriangleFillMode);\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Stores the effects for the material\r\n     */\r\n    public _effect: Nullable<Effect> = null;\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     */\r\n    protected _uniformBuffer: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @hidden */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     */\r\n    constructor(name: string, scene: Scene, doNotAdd?: boolean) {\r\n        this.name = name;\r\n        let idSubscript = 1;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        this.id = name || Tools.RandomId();\r\n        while (this._scene.getMaterialByID(this.id)) {\r\n            this.id = name + \" \" + idSubscript++;\r\n        }\r\n\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        if (this._scene.useRightHandedSystem) {\r\n            this.sideOrientation = Material.ClockWiseSideOrientation;\r\n        } else {\r\n            this.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n        }\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine());\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name;\r\n        if (fullDetails) {\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    protected _forceAlphaTest = false;\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._forceAlphaTest = (value === Material.MATERIAL_ALPHATESTANDBLEND);\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return (this._transparencyMode === Material.MATERIAL_OPAQUE ||\r\n                this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return (this.alpha < 1.0);\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._disableAlphaBlending && mesh.visibility >= 1.0) {\r\n            return false;\r\n        }\r\n\r\n        return this.needAlphaBlending() || (mesh.visibility < 1.0) || mesh.hasVertexAlpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     */\r\n    protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean {\r\n        return (!this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting());\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     */\r\n    public markDirty(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (var mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (var subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.effect) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.effect._wasPreviouslyReady = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preBind(effect?: Effect, overrideOrientation: Nullable<number> = null): boolean {\r\n        var engine = this._scene.getEngine();\r\n\r\n        var orientation = (overrideOrientation == null) ? this.sideOrientation : overrideOrientation;\r\n        var reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._effect);\r\n        engine.setState(this.backFaceCulling, this.zOffset, false, reverse);\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n    }\r\n\r\n    /**\r\n     * Binds the scene's uniform buffer to the effect.\r\n     * @param effect defines the effect to bind to the scene uniform buffer\r\n     * @param sceneUbo defines the uniform buffer storing scene data\r\n     */\r\n    public bindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n        sceneUbo.bindToEffect(effect, \"Scene\");\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection matrix to the effect\r\n     * @param effect defines the effect to bind the view projection matrix to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n        } else {\r\n            this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     */\r\n    protected _afterBind(mesh?: Mesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            var engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            var engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            var engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            var engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            var engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            var engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            var result = new Array<AbstractMesh>();\r\n            for (let meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>, onError?: (reason: string) => void): void {\r\n        let localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options\r\n        };\r\n\r\n        var scene = this.getScene();\r\n        let currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        var checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            var clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                var allDone = true, lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    let tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh._materialDefines) {\r\n                        tempSubMesh._materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n                else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(mesh, () => {\r\n                resolve();\r\n            }, options, (reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    }\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    }\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = this.getScene().meshes;\r\n        for (var mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (var subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh._materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                func(subMesh._materialDefines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (let meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    if (mesh) {\r\n                        mesh.material = null; // will set the entry in the map to undefined\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const meshes = scene.meshes;\r\n                for (let mesh of meshes) {\r\n                    if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n                        mesh.material = null;\r\n                        this.releaseVertexArrayObject(mesh, forceDisposeEffect);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (forceDisposeEffect && this._effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._effect.dispose();\r\n            }\r\n\r\n            this._effect = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    private releaseVertexArrayObject(mesh: AbstractMesh, forceDisposeEffect?: boolean) {\r\n        if ((<Mesh>mesh).geometry) {\r\n            var geometry = <Geometry>((<Mesh>mesh).geometry);\r\n            if (this._storeEffectOnSubMeshes) {\r\n                for (var subMesh of mesh.subMeshes) {\r\n                    geometry._releaseVertexArrayObject(subMesh._materialEffect);\r\n                    if (forceDisposeEffect && subMesh._materialEffect) {\r\n                        subMesh._materialEffect.dispose();\r\n                    }\r\n                }\r\n            } else {\r\n                geometry._releaseVertexArrayObject(this._effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        }\r\n        else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        var materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        return materialType.Parse(parsedMaterial, scene, rootUrl);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}