{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { _DevTools } from '../Misc/devTools';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n     * Type of sub emitter\r\n     */\n\nexport var SubEmitterType;\n\n(function (SubEmitterType) {\n  /**\r\n   * Attached to the particle over it's lifetime\r\n   */\n  SubEmitterType[SubEmitterType[\"ATTACHED\"] = 0] = \"ATTACHED\";\n  /**\r\n   * Created when the particle dies\r\n   */\n\n  SubEmitterType[SubEmitterType[\"END\"] = 1] = \"END\";\n})(SubEmitterType || (SubEmitterType = {}));\n/**\r\n * Sub emitter class used to emit particles from an existing particle\r\n */\n\n\nvar SubEmitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a sub emitter\r\n   * @param particleSystem the particle system to be used by the sub emitter\r\n   */\n  function SubEmitter(\n  /**\r\n   * the particle system to be used by the sub emitter\r\n   */\n  particleSystem) {\n    this.particleSystem = particleSystem;\n    /**\r\n     * Type of the submitter (Default: END)\r\n     */\n\n    this.type = SubEmitterType.END;\n    /**\r\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\r\n     * Note: This only is supported when using an emitter of type Mesh\r\n     */\n\n    this.inheritDirection = false;\n    /**\r\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\r\n     */\n\n    this.inheritedVelocityAmount = 0; // Create mesh as emitter to support rotation\n\n    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {\n      var internalClass = _TypeStore.GetClass(\"BABYLON.AbstractMesh\");\n\n      particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\n    } // Automatically dispose of subemitter when system is disposed\n\n\n    particleSystem.onDisposeObservable.add(function () {\n      if (particleSystem.emitter && particleSystem.emitter.dispose) {\n        particleSystem.emitter.dispose();\n      }\n    });\n  }\n  /**\r\n   * Clones the sub emitter\r\n   * @returns the cloned sub emitter\r\n   */\n\n\n  SubEmitter.prototype.clone = function () {\n    // Clone particle system\n    var emitter = this.particleSystem.emitter;\n\n    if (!emitter) {\n      emitter = new Vector3();\n    } else if (emitter instanceof Vector3) {\n      emitter = emitter.clone();\n    } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\n      var internalClass = _TypeStore.GetClass(\"BABYLON.Mesh\");\n\n      emitter = new internalClass(\"\", emitter.getScene());\n      emitter.isVisible = false;\n    }\n\n    var clone = new SubEmitter(this.particleSystem.clone(\"\", emitter)); // Clone properties\n\n    clone.particleSystem.name += \"Clone\";\n    clone.type = this.type;\n    clone.inheritDirection = this.inheritDirection;\n    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    clone.particleSystem._disposeEmitterOnDispose = true;\n    clone.particleSystem.disposeOnStop = true;\n    return clone;\n  };\n  /**\r\n   * Serialize current object to a JSON object\r\n   * @returns the serialized object\r\n   */\n\n\n  SubEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.type;\n    serializationObject.inheritDirection = this.inheritDirection;\n    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\n    serializationObject.particleSystem = this.particleSystem.serialize();\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  SubEmitter._ParseParticleSystem = function (system, sceneOrEngine, rootUrl) {\n    throw _DevTools.WarnImport(\"ParseParticle\");\n  };\n  /**\r\n   * Creates a new SubEmitter from a serialized JSON version\r\n   * @param serializationObject defines the JSON object to read from\r\n   * @param sceneOrEngine defines the hosting scene or the hosting engine\r\n   * @param rootUrl defines the rootUrl for data loading\r\n   * @returns a new SubEmitter\r\n   */\n\n\n  SubEmitter.Parse = function (serializationObject, sceneOrEngine, rootUrl) {\n    var system = serializationObject.particleSystem;\n    var subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl));\n    subEmitter.type = serializationObject.type;\n    subEmitter.inheritDirection = serializationObject.inheritDirection;\n    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\n    subEmitter.particleSystem._isSubEmitter = true;\n    return subEmitter;\n  };\n  /** Release associated resources */\n\n\n  SubEmitter.prototype.dispose = function () {\n    this.particleSystem.dispose();\n  };\n\n  return SubEmitter;\n}();\n\nexport { SubEmitter };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/subEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3 } from \"../Maths/math.vector\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type ParticleSystem = import(\"../Particles/particleSystem\").ParticleSystem;\r\n\r\n/**\r\n     * Type of sub emitter\r\n     */\r\nexport enum SubEmitterType {\r\n    /**\r\n     * Attached to the particle over it's lifetime\r\n     */\r\n    ATTACHED,\r\n    /**\r\n     * Created when the particle dies\r\n     */\r\n    END\r\n}\r\n\r\n/**\r\n * Sub emitter class used to emit particles from an existing particle\r\n */\r\nexport class SubEmitter {\r\n    /**\r\n     * Type of the submitter (Default: END)\r\n     */\r\n    public type = SubEmitterType.END;\r\n    /**\r\n     * If the particle should inherit the direction from the particle it's attached to. (+Y will face the direction the particle is moving) (Default: false)\r\n     * Note: This only is supported when using an emitter of type Mesh\r\n     */\r\n    public inheritDirection = false;\r\n    /**\r\n     * How much of the attached particles speed should be added to the sub emitted particle (default: 0)\r\n     */\r\n    public inheritedVelocityAmount = 0;\r\n    /**\r\n     * Creates a sub emitter\r\n     * @param particleSystem the particle system to be used by the sub emitter\r\n     */\r\n    constructor(\r\n        /**\r\n         * the particle system to be used by the sub emitter\r\n         */\r\n        public particleSystem: ParticleSystem\r\n    ) {\r\n        // Create mesh as emitter to support rotation\r\n        if (!particleSystem.emitter || !(<AbstractMesh>particleSystem.emitter).dispose) {\r\n            const internalClass = _TypeStore.GetClass(\"BABYLON.AbstractMesh\");\r\n            particleSystem.emitter = new internalClass(\"SubemitterSystemEmitter\", particleSystem.getScene());\r\n        }\r\n\r\n        // Automatically dispose of subemitter when system is disposed\r\n        particleSystem.onDisposeObservable.add(() => {\r\n            if (particleSystem.emitter && (<AbstractMesh>particleSystem.emitter).dispose) {\r\n                (<AbstractMesh>particleSystem.emitter).dispose();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Clones the sub emitter\r\n     * @returns the cloned sub emitter\r\n     */\r\n    public clone(): SubEmitter {\r\n        // Clone particle system\r\n        var emitter = this.particleSystem.emitter;\r\n        if (!emitter) {\r\n            emitter = new Vector3();\r\n        } else if (emitter instanceof Vector3) {\r\n            emitter = emitter.clone();\r\n        } else if (emitter.getClassName().indexOf(\"Mesh\") !== -1) {\r\n            const internalClass = _TypeStore.GetClass(\"BABYLON.Mesh\");\r\n            emitter = new internalClass(\"\", emitter.getScene());\r\n            (emitter! as any).isVisible = false;\r\n        }\r\n        var clone = new SubEmitter(this.particleSystem.clone(\"\", emitter));\r\n\r\n        // Clone properties\r\n        clone.particleSystem.name += \"Clone\";\r\n        clone.type = this.type;\r\n        clone.inheritDirection = this.inheritDirection;\r\n        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n\r\n        clone.particleSystem._disposeEmitterOnDispose = true;\r\n        clone.particleSystem.disposeOnStop = true;\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serialize current object to a JSON object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        let serializationObject: any = {};\r\n\r\n        serializationObject.type = this.type;\r\n        serializationObject.inheritDirection = this.inheritDirection;\r\n        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;\r\n        serializationObject.particleSystem = this.particleSystem.serialize();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _ParseParticleSystem(system: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): ParticleSystem {\r\n        throw _DevTools.WarnImport(\"ParseParticle\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new SubEmitter from a serialized JSON version\r\n     * @param serializationObject defines the JSON object to read from\r\n     * @param sceneOrEngine defines the hosting scene or the hosting engine\r\n     * @param rootUrl defines the rootUrl for data loading\r\n     * @returns a new SubEmitter\r\n     */\r\n    public static Parse(serializationObject: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string): SubEmitter {\r\n        let system = serializationObject.particleSystem;\r\n        let subEmitter = new SubEmitter(SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl));\r\n        subEmitter.type = serializationObject.type;\r\n        subEmitter.inheritDirection = serializationObject.inheritDirection;\r\n        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;\r\n        subEmitter.particleSystem._isSubEmitter = true;\r\n\r\n        return subEmitter;\r\n    }\r\n\r\n    /** Release associated resources */\r\n    public dispose() {\r\n        this.particleSystem.dispose();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}