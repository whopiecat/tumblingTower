{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\nimport { Observable } from '../../Misc/observable';\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\n\nexport var NodeMaterialConnectionPointCompatibilityStates;\n\n(function (NodeMaterialConnectionPointCompatibilityStates) {\n  /** Points are compatibles */\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"Compatible\"] = 0] = \"Compatible\";\n  /** Points are incompatible because of their types */\n\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TypeIncompatible\"] = 1] = \"TypeIncompatible\";\n  /** Points are incompatible because of their targets (vertex vs fragment) */\n\n  NodeMaterialConnectionPointCompatibilityStates[NodeMaterialConnectionPointCompatibilityStates[\"TargetIncompatible\"] = 2] = \"TargetIncompatible\";\n})(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));\n/**\r\n * Defines the direction of a connection point\r\n */\n\n\nexport var NodeMaterialConnectionPointDirection;\n\n(function (NodeMaterialConnectionPointDirection) {\n  /** Input */\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Input\"] = 0] = \"Input\";\n  /** Output */\n\n  NodeMaterialConnectionPointDirection[NodeMaterialConnectionPointDirection[\"Output\"] = 1] = \"Output\";\n})(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));\n/**\r\n * Defines a connection point for a block\r\n */\n\n\nvar NodeMaterialConnectionPoint =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new connection point\r\n   * @param name defines the connection point name\r\n   * @param ownerBlock defines the block hosting this connection point\r\n   * @param direction defines the direction of the connection point\r\n   */\n  function NodeMaterialConnectionPoint(name, ownerBlock, direction) {\n    /** @hidden */\n    this._connectedPoint = null;\n    this._endpoints = new Array();\n    /** @hidden */\n\n    this._typeConnectionSource = null;\n    /** @hidden */\n\n    this._linkedConnectionSource = null;\n    /** @hidden */\n\n    this._acceptedConnectionPointType = null;\n    this._type = NodeMaterialBlockConnectionPointTypes.Float;\n    /** @hidden */\n\n    this._enforceAssociatedVariableName = false;\n    /** Indicates that this connection point needs dual validation before being connected to another point */\n\n    this.needDualDirectionValidation = false;\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\n\n    this.acceptedConnectionPointTypes = new Array();\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\n\n    this.excludedConnectionPointTypes = new Array();\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\n\n    this.onConnectionObservable = new Observable();\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\n\n    this.isExposedOnFrame = false;\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\n\n    this.exposedPortPosition = -1;\n    /** @hidden */\n\n    this._prioritizeVertex = false;\n    this._target = NodeMaterialBlockTargets.VertexAndFragment;\n    this._ownerBlock = ownerBlock;\n    this.name = name;\n    this._direction = direction;\n  }\n  /**\r\n   * Checks if two types are equivalent\r\n   * @param type1 type 1 to check\r\n   * @param type2 type 2 to check\r\n   * @returns true if both types are equivalent, else false\r\n   */\n\n\n  NodeMaterialConnectionPoint.AreEquivalentTypes = function (type1, type2) {\n    switch (type1) {\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\n            return true;\n          }\n\n          break;\n        }\n\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        {\n          if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\n            return true;\n          }\n\n          break;\n        }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"direction\", {\n    /** Gets the direction of the point */\n    get: function () {\n      return this._direction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"associatedVariableName\", {\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\n    get: function () {\n      if (this._ownerBlock.isInput) {\n        return this._ownerBlock.associatedVariableName;\n      }\n\n      if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\n        return this._connectedPoint.associatedVariableName;\n      }\n\n      return this._associatedVariableName;\n    },\n    set: function (value) {\n      this._associatedVariableName = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"innerType\", {\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\n    get: function () {\n      if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n        return this.type;\n      }\n\n      return this._type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"type\", {\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\n    get: function () {\n      if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n        if (this._ownerBlock.isInput) {\n          return this._ownerBlock.type;\n        }\n\n        if (this._connectedPoint) {\n          return this._connectedPoint.type;\n        }\n\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\n          return this._linkedConnectionSource.type;\n        }\n      }\n\n      if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput && this._typeConnectionSource) {\n        return this._typeConnectionSource.type;\n      }\n\n      return this._type;\n    },\n    set: function (value) {\n      this._type = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"target\", {\n    /** Gets or sets the target of that connection point */\n    get: function () {\n      if (!this._prioritizeVertex || !this._ownerBlock) {\n        return this._target;\n      }\n\n      if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\n        return this._target;\n      }\n\n      if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n        return NodeMaterialBlockTargets.Fragment;\n      }\n\n      return NodeMaterialBlockTargets.Vertex;\n    },\n    set: function (value) {\n      this._target = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnected\", {\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\n    get: function () {\n      return this.connectedPoint !== null || this.hasEndpoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedToInputBlock\", {\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\n    get: function () {\n      return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectInputBlock\", {\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\n    get: function () {\n      if (!this.isConnectedToInputBlock) {\n        return null;\n      }\n\n      return this.connectedPoint.ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectedPoint\", {\n    /** Get the other side of the connection (if any) */\n    get: function () {\n      return this._connectedPoint;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"ownerBlock\", {\n    /** Get the block that owns this connection point */\n    get: function () {\n      return this._ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"sourceBlock\", {\n    /** Get the block connected on the other side of this connection (if any) */\n    get: function () {\n      if (!this._connectedPoint) {\n        return null;\n      }\n\n      return this._connectedPoint.ownerBlock;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"connectedBlocks\", {\n    /** Get the block connected on the endpoints of this connection (if any) */\n    get: function () {\n      if (this._endpoints.length === 0) {\n        return [];\n      }\n\n      return this._endpoints.map(function (e) {\n        return e.ownerBlock;\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"endpoints\", {\n    /** Gets the list of connected endpoints */\n    get: function () {\n      return this._endpoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"hasEndpoints\", {\n    /** Gets a boolean indicating if that output point is connected to at least one input */\n    get: function () {\n      return this._endpoints && this._endpoints.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedInVertexShader\", {\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\n    get: function () {\n      if (this.target === NodeMaterialBlockTargets.Vertex) {\n        return true;\n      }\n\n      if (!this.hasEndpoints) {\n        return false;\n      }\n\n      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {\n        var endpoint = _a[_i];\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\n          return true;\n        }\n\n        if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          if (endpoint.ownerBlock.outputs.some(function (o) {\n            return o.isConnectedInVertexShader;\n          })) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialConnectionPoint.prototype, \"isConnectedInFragmentShader\", {\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\n    get: function () {\n      if (this.target === NodeMaterialBlockTargets.Fragment) {\n        return true;\n      }\n\n      if (!this.hasEndpoints) {\n        return false;\n      }\n\n      for (var _i = 0, _a = this._endpoints; _i < _a.length; _i++) {\n        var endpoint = _a[_i];\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n          return true;\n        }\n\n        if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          if (endpoint.ownerBlock.outputs.some(function (o) {\n            return o.isConnectedInFragmentShader;\n          })) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a block suitable to be used as an input for this input point.\r\n   * If null is returned, a block based on the point type will be created.\r\n   * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n   */\n\n  NodeMaterialConnectionPoint.prototype.createCustomInputBlock = function () {\n    return null;\n  };\n  /**\r\n   * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n   * @returns the class name\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.getClassName = function () {\n    return \"NodeMaterialConnectionPoint\";\n  };\n  /**\r\n   * Gets a boolean indicating if the current point can be connected to another point\r\n   * @param connectionPoint defines the other connection point\r\n   * @returns a boolean\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.canConnectTo = function (connectionPoint) {\n    return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  };\n  /**\r\n   * Gets a number indicating if the current point can be connected to another point\r\n   * @param connectionPoint defines the other connection point\r\n   * @returns a number defining the compatibility state\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.checkCompatibilityState = function (connectionPoint) {\n    var ownerBlock = this._ownerBlock;\n\n    if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      // Let's check we are not going reverse\n      var otherBlock = connectionPoint.ownerBlock;\n\n      if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\n        return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n      }\n\n      for (var _i = 0, _a = otherBlock.outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (output.isConnectedInVertexShader) {\n          return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\n        }\n      }\n    }\n\n    if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n      // Equivalents\n      if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      } // Accepted types\n\n\n      if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n      } else {\n        return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\n      }\n    } // Excluded\n\n\n    if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {\n      return 1;\n    }\n\n    return NodeMaterialConnectionPointCompatibilityStates.Compatible;\n  };\n  /**\r\n   * Connect this point to another connection point\r\n   * @param connectionPoint defines the other connection point\r\n   * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n   * @returns the current connection point\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.connectTo = function (connectionPoint, ignoreConstraints) {\n    if (ignoreConstraints === void 0) {\n      ignoreConstraints = false;\n    }\n\n    if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\n      throw \"Cannot connect these two connectors.\";\n    }\n\n    this._endpoints.push(connectionPoint);\n\n    connectionPoint._connectedPoint = this;\n    this._enforceAssociatedVariableName = false;\n    this.onConnectionObservable.notifyObservers(connectionPoint);\n    connectionPoint.onConnectionObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Disconnect this point from one of his endpoint\r\n   * @param endpoint defines the other connection point\r\n   * @returns the current connection point\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.disconnectFrom = function (endpoint) {\n    var index = this._endpoints.indexOf(endpoint);\n\n    if (index === -1) {\n      return this;\n    }\n\n    this._endpoints.splice(index, 1);\n\n    endpoint._connectedPoint = null;\n    this._enforceAssociatedVariableName = false;\n    endpoint._enforceAssociatedVariableName = false;\n    return this;\n  };\n  /**\r\n   * Serializes this point in a JSON representation\r\n   * @param isInput defines if the connection point is an input (default is true)\r\n   * @returns the serialized point object\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.serialize = function (isInput) {\n    if (isInput === void 0) {\n      isInput = true;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.displayName = this.displayName;\n\n    if (isInput && this.connectedPoint) {\n      serializationObject.inputName = this.name;\n      serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\n      serializationObject.targetConnectionName = this.connectedPoint.name;\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n\n    if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\n      serializationObject.isExposedOnFrame = true;\n      serializationObject.exposedPortPosition = this.exposedPortPosition;\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Release resources\r\n   */\n\n\n  NodeMaterialConnectionPoint.prototype.dispose = function () {\n    this.onConnectionObservable.clear();\n  };\n\n  return NodeMaterialConnectionPoint;\n}();\n\nexport { NodeMaterialConnectionPoint };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Node/nodeMaterialBlockConnectionPoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\r\nimport { Nullable } from '../../types';\r\nimport { InputBlock } from './Blocks/Input/inputBlock';\r\nimport { Observable } from '../../Misc/observable';\r\n\r\ndeclare type NodeMaterialBlock = import(\"./nodeMaterialBlock\").NodeMaterialBlock;\r\n\r\n/**\r\n * Enum used to define the compatibility state between two connection points\r\n */\r\nexport enum NodeMaterialConnectionPointCompatibilityStates {\r\n    /** Points are compatibles */\r\n    Compatible,\r\n    /** Points are incompatible because of their types */\r\n    TypeIncompatible,\r\n    /** Points are incompatible because of their targets (vertex vs fragment) */\r\n    TargetIncompatible\r\n}\r\n\r\n/**\r\n * Defines the direction of a connection point\r\n */\r\nexport enum NodeMaterialConnectionPointDirection {\r\n    /** Input */\r\n    Input,\r\n    /** Output */\r\n    Output\r\n}\r\n\r\n/**\r\n * Defines a connection point for a block\r\n */\r\nexport class NodeMaterialConnectionPoint {\r\n\r\n    /**\r\n     * Checks if two types are equivalent\r\n     * @param type1 type 1 to check\r\n     * @param type2 type 2 to check\r\n     * @returns true if both types are equivalent, else false\r\n     */\r\n    public static AreEquivalentTypes(type1: number, type2: number): boolean {\r\n        switch (type1) {\r\n            case NodeMaterialBlockConnectionPointTypes.Vector3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Vector4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color3: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n            case NodeMaterialBlockConnectionPointTypes.Color4: {\r\n                if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    return true;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _ownerBlock: NodeMaterialBlock;\r\n    /** @hidden */\r\n    public _connectedPoint: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _endpoints = new Array<NodeMaterialConnectionPoint>();\r\n    private _associatedVariableName: string;\r\n    private _direction: NodeMaterialConnectionPointDirection;\r\n\r\n    /** @hidden */\r\n    public _typeConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    /** @hidden */\r\n    public _acceptedConnectionPointType: Nullable<NodeMaterialConnectionPoint> = null;\r\n\r\n    private _type = NodeMaterialBlockConnectionPointTypes.Float;\r\n\r\n    /** @hidden */\r\n    public _enforceAssociatedVariableName = false;\r\n\r\n    /** Gets the direction of the point */\r\n    public get direction() {\r\n        return this._direction;\r\n    }\r\n\r\n    /** Indicates that this connection point needs dual validation before being connected to another point */\r\n    public needDualDirectionValidation: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the additional types supported by this connection point\r\n     */\r\n    public acceptedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Gets or sets the additional types excluded by this connection point\r\n     */\r\n    public excludedConnectionPointTypes = new Array<NodeMaterialBlockConnectionPointTypes>();\r\n\r\n    /**\r\n     * Observable triggered when this point is connected\r\n     */\r\n    public onConnectionObservable = new Observable<NodeMaterialConnectionPoint>();\r\n\r\n    /**\r\n     * Gets or sets the associated variable name in the shader\r\n     */\r\n    public get associatedVariableName(): string {\r\n        if (this._ownerBlock.isInput) {\r\n            return (this._ownerBlock as InputBlock).associatedVariableName;\r\n        }\r\n\r\n        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {\r\n            return this._connectedPoint.associatedVariableName;\r\n        }\r\n\r\n        return this._associatedVariableName;\r\n    }\r\n\r\n    public set associatedVariableName(value: string) {\r\n        this._associatedVariableName = value;\r\n    }\r\n\r\n    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */\r\n    public get innerType() {\r\n        if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n            return this.type;\r\n        }\r\n        return this._type;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point type (default is float)\r\n     */\r\n    public get type(): NodeMaterialBlockConnectionPointTypes {\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            if (this._ownerBlock.isInput) {\r\n                return (this._ownerBlock as InputBlock).type;\r\n            }\r\n\r\n            if (this._connectedPoint) {\r\n                return this._connectedPoint.type;\r\n            }\r\n\r\n            if (this._linkedConnectionSource && this._linkedConnectionSource.isConnected) {\r\n                return this._linkedConnectionSource.type;\r\n            }\r\n        }\r\n\r\n        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput && this._typeConnectionSource) {\r\n            return this._typeConnectionSource.type;\r\n        }\r\n\r\n        return this._type;\r\n    }\r\n\r\n    public set type(value: NodeMaterialBlockConnectionPointTypes) {\r\n        this._type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the connection point name\r\n     */\r\n    public displayName: string;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point can be omitted\r\n     */\r\n    public isOptional: boolean;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this connection point is exposed on a frame\r\n     */\r\n    public isExposedOnFrame: boolean =  false;\r\n\r\n    /**\r\n     * Gets or sets number indicating the position that the port is exposed to on a frame\r\n     */\r\n    public exposedPortPosition: number = -1;\r\n\r\n    /**\r\n     * Gets or sets a string indicating that this uniform must be defined under a #ifdef\r\n     */\r\n    public define: string;\r\n\r\n    /** @hidden */\r\n    public _prioritizeVertex = false;\r\n\r\n    private _target: NodeMaterialBlockTargets = NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n    /** Gets or sets the target of that connection point */\r\n    public get target(): NodeMaterialBlockTargets {\r\n        if (!this._prioritizeVertex || !this._ownerBlock) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {\r\n            return this._target;\r\n        }\r\n\r\n        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock\r\n     */\r\n    public get isConnected(): boolean {\r\n        return this.connectedPoint !== null || this.hasEndpoints;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the current point is connected to an input block\r\n     */\r\n    public get isConnectedToInputBlock(): boolean {\r\n        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets a the connected input block (if any)\r\n     */\r\n    public get connectInputBlock(): Nullable<InputBlock> {\r\n        if (!this.isConnectedToInputBlock) {\r\n            return null;\r\n        }\r\n\r\n        return this.connectedPoint!.ownerBlock as InputBlock;\r\n    }\r\n\r\n    /** Get the other side of the connection (if any) */\r\n    public get connectedPoint(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._connectedPoint;\r\n    }\r\n\r\n    /** Get the block that owns this connection point */\r\n    public get ownerBlock(): NodeMaterialBlock {\r\n        return this._ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the other side of this connection (if any) */\r\n    public get sourceBlock(): Nullable<NodeMaterialBlock> {\r\n        if (!this._connectedPoint) {\r\n            return null;\r\n        }\r\n\r\n        return this._connectedPoint.ownerBlock;\r\n    }\r\n\r\n    /** Get the block connected on the endpoints of this connection (if any) */\r\n    public get connectedBlocks(): Array<NodeMaterialBlock> {\r\n        if (this._endpoints.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return this._endpoints.map((e) => e.ownerBlock);\r\n    }\r\n\r\n    /** Gets the list of connected endpoints */\r\n    public get endpoints() {\r\n        return this._endpoints;\r\n    }\r\n\r\n    /** Gets a boolean indicating if that output point is connected to at least one input */\r\n    public get hasEndpoints(): boolean {\r\n        return this._endpoints && this._endpoints.length > 0;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the vertex shader */\r\n    public get isConnectedInVertexShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (var endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.target === NodeMaterialBlockTargets.Vertex) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Gets a boolean indicating that this connection will be used in the fragment shader */\r\n    public get isConnectedInFragmentShader(): boolean {\r\n        if (this.target === NodeMaterialBlockTargets.Fragment) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.hasEndpoints) {\r\n            return false;\r\n        }\r\n\r\n        for (var endpoint of this._endpoints) {\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n                return true;\r\n            }\r\n\r\n            if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Creates a block suitable to be used as an input for this input point.\r\n     * If null is returned, a block based on the point type will be created.\r\n     * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input\r\n     */\r\n    public createCustomInputBlock(): Nullable<[NodeMaterialBlock, string]> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new connection point\r\n     * @param name defines the connection point name\r\n     * @param ownerBlock defines the block hosting this connection point\r\n     * @param direction defines the direction of the connection point\r\n     */\r\n    public constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection) {\r\n        this._ownerBlock = ownerBlock;\r\n        this.name = name;\r\n        this._direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialConnectionPoint\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterialConnectionPoint\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a boolean\r\n     */\r\n    public canConnectTo(connectionPoint: NodeMaterialConnectionPoint) {\r\n        return this.checkCompatibilityState(connectionPoint) === NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Gets a number indicating if the current point can be connected to another point\r\n     * @param connectionPoint defines the other connection point\r\n     * @returns a number defining the compatibility state\r\n     */\r\n    public checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates {\r\n        const ownerBlock = this._ownerBlock;\r\n\r\n        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            // Let's check we are not going reverse\r\n            const otherBlock = connectionPoint.ownerBlock;\r\n\r\n            if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n            }\r\n\r\n            for (var output of otherBlock.outputs) {\r\n                if (output.isConnectedInVertexShader) {\r\n                    return NodeMaterialConnectionPointCompatibilityStates.TargetIncompatible;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n            // Equivalents\r\n            if (NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            }\r\n\r\n            // Accepted types\r\n            if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 ||\r\n                connectionPoint._acceptedConnectionPointType && NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type))\r\n            {\r\n                return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n            } else {\r\n                return NodeMaterialConnectionPointCompatibilityStates.TypeIncompatible;\r\n            }\r\n        }\r\n\r\n        // Excluded\r\n        if ((connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1)) {\r\n            return 1;\r\n        }\r\n\r\n        return NodeMaterialConnectionPointCompatibilityStates.Compatible;\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another connection point\r\n     * @param connectionPoint defines the other connection point\r\n     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)\r\n     * @returns the current connection point\r\n     */\r\n    public connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints = false): NodeMaterialConnectionPoint {\r\n        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {\r\n            throw \"Cannot connect these two connectors.\";\r\n        }\r\n\r\n        this._endpoints.push(connectionPoint);\r\n        connectionPoint._connectedPoint = this;\r\n\r\n        this._enforceAssociatedVariableName = false;\r\n\r\n        this.onConnectionObservable.notifyObservers(connectionPoint);\r\n        connectionPoint.onConnectionObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disconnect this point from one of his endpoint\r\n     * @param endpoint defines the other connection point\r\n     * @returns the current connection point\r\n     */\r\n    public disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint {\r\n        let index = this._endpoints.indexOf(endpoint);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._endpoints.splice(index, 1);\r\n        endpoint._connectedPoint = null;\r\n        this._enforceAssociatedVariableName = false;\r\n        endpoint._enforceAssociatedVariableName = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this point in a JSON representation\r\n     * @param isInput defines if the connection point is an input (default is true)\r\n     * @returns the serialized point object\r\n     */\r\n    public serialize(isInput = true): any {\r\n        let serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.displayName = this.displayName;\r\n\r\n        if (isInput && this.connectedPoint) {\r\n            serializationObject.inputName = this.name;\r\n            serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;\r\n            serializationObject.targetConnectionName = this.connectedPoint.name;\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {\r\n            serializationObject.isExposedOnFrame = true;\r\n            serializationObject.exposedPortPosition = this.exposedPortPosition;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        this.onConnectionObservable.clear();\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}