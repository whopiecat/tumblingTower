{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { Vector3 } from \"../../Maths/math.vector\";\nimport { Color3, Color4 } from \"../../Maths/math.color\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Geometry } from \"../../Meshes/geometry\";\nimport { TransformNode } from \"../../Meshes/transformNode\";\nimport { Material } from \"../../Materials/material\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\nimport { Light } from \"../../Lights/light\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\nimport { AbstractScene } from \"../../abstractScene\";\nimport { AssetContainer } from \"../../assetContainer\";\nimport { ActionManager } from \"../../Actions/actionManager\";\nimport { Skeleton } from \"../../Bones/skeleton\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin\";\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin\";\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\nimport { _TypeStore } from '../../Misc/typeStore';\nimport { Tools } from '../../Misc/tools';\nimport { StringTools } from '../../Misc/stringTools';\nimport { PostProcess } from '../../PostProcesses/postProcess';\n/** @hidden */\n\nexport var _BabylonLoaderRegistered = true;\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\n\nvar BabylonFileLoaderConfiguration =\n/** @class */\nfunction () {\n  function BabylonFileLoaderConfiguration() {}\n  /**\r\n   * The loader does not allow injecting custom physix engine into the plugins.\r\n   * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n   * So you could set this variable to your engine import to make it work.\r\n   */\n\n\n  BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\n  return BabylonFileLoaderConfiguration;\n}();\n\nexport { BabylonFileLoaderConfiguration };\n\nvar parseMaterialById = function (id, parsedData, scene, rootUrl) {\n  for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {\n    var parsedMaterial = parsedData.materials[index];\n\n    if (parsedMaterial.id === id) {\n      return Material.Parse(parsedMaterial, scene, rootUrl);\n    }\n  }\n\n  return null;\n};\n\nvar isDescendantOf = function (mesh, names, hierarchyIds) {\n  for (var i in names) {\n    if (mesh.name === names[i]) {\n      hierarchyIds.push(mesh.id);\n      return true;\n    }\n  }\n\n  if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n    hierarchyIds.push(mesh.id);\n    return true;\n  }\n\n  return false;\n};\n\nvar logOperation = function (operation, producer) {\n  return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n};\n\nvar loadDetailLevels = function (scene, mesh) {\n  var mastermesh = mesh; // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n  // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n\n  if (mesh._waitingData.lods) {\n    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n      var lodmeshes = mesh._waitingData.lods.ids;\n      var wasenabled = mastermesh.isEnabled(false);\n\n      if (mesh._waitingData.lods.distances) {\n        var distances = mesh._waitingData.lods.distances;\n\n        if (distances.length >= lodmeshes.length) {\n          var culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n          mastermesh.setEnabled(false);\n\n          for (var index = 0; index < lodmeshes.length; index++) {\n            var lodid = lodmeshes[index];\n            var lodmesh = scene.getMeshByID(lodid);\n\n            if (lodmesh != null) {\n              mastermesh.addLODLevel(distances[index], lodmesh);\n            }\n          }\n\n          if (culling > 0) {\n            mastermesh.addLODLevel(culling, null);\n          }\n\n          if (wasenabled === true) {\n            mastermesh.setEnabled(true);\n          }\n        } else {\n          Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n        }\n      }\n    }\n\n    mesh._waitingData.lods = null;\n  }\n};\n\nvar loadAssetContainer = function (scene, data, rootUrl, onError, addToScene) {\n  if (addToScene === void 0) {\n    addToScene = false;\n  }\n\n  var container = new AssetContainer(scene); // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n  // when SceneLoader.debugLogging = true (default), or exception encountered.\n  // Everything stored in var log instead of writing separate lines to support only writing in exception,\n  // and avoid problems with multiple concurrent .babylon loads.\n\n  var log = \"importScene has failed JSON parse\";\n\n  try {\n    var parsedData = JSON.parse(data);\n    log = \"\";\n    var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n    var index;\n    var cache; // Environment texture\n\n    if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n      // PBR needed for both HDR texture (gamma space) & a sky box\n      var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n\n      if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n        var hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n        var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);\n\n        if (parsedData.environmentTextureRotationY) {\n          hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n        }\n\n        scene.environmentTexture = hdrTexture;\n      } else {\n        if (StringTools.EndsWith(parsedData.environmentTexture, \".env\")) {\n          var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\n\n          if (parsedData.environmentTextureRotationY) {\n            compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = compressedTexture;\n        } else {\n          var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\n\n          if (parsedData.environmentTextureRotationY) {\n            cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n\n          scene.environmentTexture = cubeTexture;\n        }\n      }\n\n      if (parsedData.createDefaultSkybox === true) {\n        var skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n        var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n      }\n\n      container.environmentTexture = scene.environmentTexture;\n    } // Environment Intensity\n\n\n    if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n      scene.environmentIntensity = parsedData.environmentIntensity;\n    } // Lights\n\n\n    if (parsedData.lights !== undefined && parsedData.lights !== null) {\n      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n        var parsedLight = parsedData.lights[index];\n        var light = Light.Parse(parsedLight, scene);\n\n        if (light) {\n          container.lights.push(light);\n          log += index === 0 ? \"\\n\\tLights:\" : \"\";\n          log += \"\\n\\t\\t\" + light.toString(fullDetails);\n        }\n      }\n    } // Reflection probes\n\n\n    if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n        var parsedReflectionProbe = parsedData.reflectionProbes[index];\n        var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n\n        if (reflectionProbe) {\n          container.reflectionProbes.push(reflectionProbe);\n          log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n          log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n        }\n      }\n    } // Animations\n\n\n    if (parsedData.animations !== undefined && parsedData.animations !== null) {\n      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n        var parsedAnimation = parsedData.animations[index];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          var animation = internalClass.Parse(parsedAnimation);\n          scene.animations.push(animation);\n          container.animations.push(animation);\n          log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n          log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n        }\n      }\n    } // Materials\n\n\n    if (parsedData.materials !== undefined && parsedData.materials !== null) {\n      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        var parsedMaterial = parsedData.materials[index];\n        var mat = Material.Parse(parsedMaterial, scene, rootUrl);\n\n        if (mat) {\n          container.materials.push(mat);\n          log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n          log += \"\\n\\t\\t\" + mat.toString(fullDetails); // Textures\n\n          var textures = mat.getActiveTextures();\n          textures.forEach(function (t) {\n            if (container.textures.indexOf(t) == -1) {\n              container.textures.push(t);\n            }\n          });\n        }\n      }\n    }\n\n    if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n        var parsedMultiMaterial = parsedData.multiMaterials[index];\n        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n        container.multiMaterials.push(mmat);\n        log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n        log += \"\\n\\t\\t\" + mmat.toString(fullDetails); // Textures\n\n        var textures = mmat.getActiveTextures();\n        textures.forEach(function (t) {\n          if (container.textures.indexOf(t) == -1) {\n            container.textures.push(t);\n          }\n        });\n      }\n    } // Morph targets\n\n\n    if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n      for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n        var managerData = _a[_i];\n        container.morphTargetManagers.push(MorphTargetManager.Parse(managerData, scene));\n      }\n    } // Skeletons\n\n\n    if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n        var parsedSkeleton = parsedData.skeletons[index];\n        var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n        container.skeletons.push(skeleton);\n        log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n        log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n      }\n    } // Geometries\n\n\n    var geometries = parsedData.geometries;\n\n    if (geometries !== undefined && geometries !== null) {\n      var addedGeometry = new Array(); // VertexData\n\n      var vertexData = geometries.vertexData;\n\n      if (vertexData !== undefined && vertexData !== null) {\n        for (index = 0, cache = vertexData.length; index < cache; index++) {\n          var parsedVertexData = vertexData[index];\n          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n        }\n      }\n\n      addedGeometry.forEach(function (g) {\n        if (g) {\n          container.geometries.push(g);\n        }\n      });\n    } // Transform nodes\n\n\n    if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n        var parsedTransformNode = parsedData.transformNodes[index];\n        var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n        container.transformNodes.push(node);\n      }\n    } // Meshes\n\n\n    if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n        var parsedMesh = parsedData.meshes[index];\n        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n        container.meshes.push(mesh);\n\n        if (mesh.hasInstances) {\n          for (var _b = 0, _c = mesh.instances; _b < _c.length; _b++) {\n            var instance = _c[_b];\n            container.meshes.push(instance);\n          }\n        }\n\n        log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n      }\n    } // Cameras\n\n\n    if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n        var parsedCamera = parsedData.cameras[index];\n        var camera = Camera.Parse(parsedCamera, scene);\n        container.cameras.push(camera);\n        log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n      }\n    } // Postprocesses\n\n\n    if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n        var parsedPostProcess = parsedData.postProcesses[index];\n        var postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n\n        if (postProcess) {\n          container.postProcesses.push(postProcess);\n          log += index === 0 ? \"\\n\\Postprocesses:\" : \"\";\n          log += \"\\n\\t\\t\" + postProcess.toString();\n        }\n      }\n    } // Animation Groups\n\n\n    if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n        var parsedAnimationGroup = parsedData.animationGroups[index];\n        var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n        container.animationGroups.push(animationGroup);\n        log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n        log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n      }\n    } // Browsing all the graph to connect the dots\n\n\n    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n      var camera = scene.cameras[index];\n\n      if (camera._waitingParentId) {\n        camera.parent = scene.getLastEntryByID(camera._waitingParentId);\n        camera._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light_1 = scene.lights[index];\n\n      if (light_1 && light_1._waitingParentId) {\n        light_1.parent = scene.getLastEntryByID(light_1._waitingParentId);\n        light_1._waitingParentId = null;\n      }\n    } // Connect parents & children and parse actions and lods\n\n\n    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n      var transformNode = scene.transformNodes[index];\n\n      if (transformNode._waitingParentId) {\n        transformNode.parent = scene.getLastEntryByID(transformNode._waitingParentId);\n        transformNode._waitingParentId = null;\n      }\n    }\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingParentId) {\n        mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);\n        mesh._waitingParentId = null;\n      }\n\n      if (mesh._waitingData.lods) {\n        loadDetailLevels(scene, mesh);\n      }\n    } // link skeleton transform nodes\n\n\n    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n      var skeleton = scene.skeletons[index];\n\n      if (skeleton._hasWaitingData) {\n        if (skeleton.bones != null) {\n          skeleton.bones.forEach(function (bone) {\n            if (bone._waitingTransformNodeId) {\n              var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);\n\n              if (linkTransformNode) {\n                bone.linkTransformNode(linkTransformNode);\n              }\n\n              bone._waitingTransformNodeId = null;\n            }\n          });\n        }\n\n        if (skeleton._waitingOverrideMeshId) {\n          skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\n          skeleton._waitingOverrideMeshId = null;\n        }\n\n        skeleton._hasWaitingData = null;\n      }\n    } // freeze world matrix application\n\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var currentMesh = scene.meshes[index];\n\n      if (currentMesh._waitingData.freezeWorldMatrix) {\n        currentMesh.freezeWorldMatrix();\n        currentMesh._waitingData.freezeWorldMatrix = null;\n      } else {\n        currentMesh.computeWorldMatrix(true);\n      }\n    } // Lights exclusions / inclusions\n\n\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      var light_2 = scene.lights[index]; // Excluded check\n\n      if (light_2._excludedMeshesIds.length > 0) {\n        for (var excludedIndex = 0; excludedIndex < light_2._excludedMeshesIds.length; excludedIndex++) {\n          var excludedMesh = scene.getMeshByID(light_2._excludedMeshesIds[excludedIndex]);\n\n          if (excludedMesh) {\n            light_2.excludedMeshes.push(excludedMesh);\n          }\n        }\n\n        light_2._excludedMeshesIds = [];\n      } // Included check\n\n\n      if (light_2._includedOnlyMeshesIds.length > 0) {\n        for (var includedOnlyIndex = 0; includedOnlyIndex < light_2._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n          var includedOnlyMesh = scene.getMeshByID(light_2._includedOnlyMeshesIds[includedOnlyIndex]);\n\n          if (includedOnlyMesh) {\n            light_2.includedOnlyMeshes.push(includedOnlyMesh);\n          }\n        }\n\n        light_2._includedOnlyMeshesIds = [];\n      }\n    }\n\n    AbstractScene.Parse(parsedData, scene, container, rootUrl); // Actions (scene) Done last as it can access other objects.\n\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      var mesh = scene.meshes[index];\n\n      if (mesh._waitingData.actions) {\n        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n        mesh._waitingData.actions = null;\n      }\n    }\n\n    if (parsedData.actions !== undefined && parsedData.actions !== null) {\n      ActionManager.Parse(parsedData.actions, null, scene);\n    }\n  } catch (err) {\n    var msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n    if (onError) {\n      onError(msg, err);\n    } else {\n      Logger.Log(msg);\n      throw err;\n    }\n  } finally {\n    if (!addToScene) {\n      container.removeAllFromScene();\n    }\n\n    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n      Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n    }\n  }\n\n  return container;\n};\n\nSceneLoader.RegisterPlugin({\n  name: \"babylon.js\",\n  extensions: \".babylon\",\n  canDirectLoad: function (data) {\n    if (data.indexOf(\"babylon\") !== -1) {\n      // We consider that the producer string is filled\n      return true;\n    }\n\n    return false;\n  },\n  importMesh: function (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    var log = \"importMesh has failed JSON parse\";\n\n    try {\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n\n      if (!meshesNames) {\n        meshesNames = null;\n      } else if (!Array.isArray(meshesNames)) {\n        meshesNames = [meshesNames];\n      }\n\n      var hierarchyIds = new Array();\n\n      if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n        var loadedSkeletonsIds = [];\n        var loadedMaterialsIds = [];\n        var index;\n        var cache;\n\n        for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n          var parsedMesh = parsedData.meshes[index];\n\n          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n            if (meshesNames !== null) {\n              // Remove found mesh name from list.\n              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n            } //Geometry?\n\n\n            if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n              //does the file contain geometries?\n              if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                //find the correct geometry and add it to the scene\n                var found = false;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(function (geometryType) {\n                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                    return;\n                  } else {\n                    parsedData.geometries[geometryType].forEach(function (parsedGeometryData) {\n                      if (parsedGeometryData.id === parsedMesh.geometryId) {\n                        switch (geometryType) {\n                          case \"vertexData\":\n                            Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                            break;\n                        }\n\n                        found = true;\n                      }\n                    });\n                  }\n                });\n\n                if (found === false) {\n                  Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                }\n              }\n            } // Material ?\n\n\n            if (parsedMesh.materialId) {\n              var materialFound = loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1;\n\n              if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                  var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n\n                  if (parsedMultiMaterial.id === parsedMesh.materialId) {\n                    for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {\n                      var subMatId = parsedMultiMaterial.materials[matIndex];\n                      loadedMaterialsIds.push(subMatId);\n                      var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);\n\n                      if (mat) {\n                        log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                      }\n                    }\n\n                    loadedMaterialsIds.push(parsedMultiMaterial.id);\n                    var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n\n                    if (mmat) {\n                      materialFound = true;\n                      log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                    }\n\n                    break;\n                  }\n                }\n              }\n\n              if (materialFound === false) {\n                loadedMaterialsIds.push(parsedMesh.materialId);\n                var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);\n\n                if (!mat) {\n                  Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                } else {\n                  log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                }\n              }\n            } // Skeleton ?\n\n\n            if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n              var skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n\n              if (skeletonAlreadyLoaded === false) {\n                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                  var parsedSkeleton = parsedData.skeletons[skeletonIndex];\n\n                  if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                    var skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                    skeletons.push(skeleton);\n                    loadedSkeletonsIds.push(parsedSkeleton.id);\n                    log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                  }\n                }\n              }\n            } // Morph targets ?\n\n\n            if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n              for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n                var managerData = _a[_i];\n                MorphTargetManager.Parse(managerData, scene);\n              }\n            }\n\n            var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n            meshes.push(mesh);\n            log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n          }\n        } // Connecting parents and lods\n\n\n        var currentMesh;\n\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingParentId) {\n            currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);\n            currentMesh._waitingParentId = null;\n          }\n\n          if (currentMesh._waitingData.lods) {\n            loadDetailLevels(scene, currentMesh);\n          }\n        } // link skeleton transform nodes\n\n\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n          var skeleton = scene.skeletons[index];\n\n          if (skeleton._hasWaitingData) {\n            if (skeleton.bones != null) {\n              skeleton.bones.forEach(function (bone) {\n                if (bone._waitingTransformNodeId) {\n                  var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId);\n\n                  if (linkTransformNode) {\n                    bone.linkTransformNode(linkTransformNode);\n                  }\n\n                  bone._waitingTransformNodeId = null;\n                }\n              });\n            }\n\n            if (skeleton._waitingOverrideMeshId) {\n              skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\n              skeleton._waitingOverrideMeshId = null;\n            }\n\n            skeleton._hasWaitingData = null;\n          }\n        } // freeze and compute world matrix application\n\n\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n\n          if (currentMesh._waitingData.freezeWorldMatrix) {\n            currentMesh.freezeWorldMatrix();\n            currentMesh._waitingData.freezeWorldMatrix = null;\n          } else {\n            currentMesh.computeWorldMatrix(true);\n          }\n        }\n      } // Particles\n\n\n      if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        var parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n        if (parser) {\n          for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            var parsedParticleSystem = parsedData.particleSystems[index];\n\n            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n            }\n          }\n        }\n      }\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  load: function (scene, data, rootUrl, onError) {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    var log = \"importScene has failed JSON parse\";\n\n    try {\n      var parsedData = JSON.parse(data);\n      log = \"\"; // Scene\n\n      if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n      }\n\n      if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n        scene.autoClear = parsedData.autoClear;\n      }\n\n      if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n        scene.clearColor = Color4.FromArray(parsedData.clearColor);\n      }\n\n      if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n      }\n\n      if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n        scene.gravity = Vector3.FromArray(parsedData.gravity);\n      } // Fog\n\n\n      if (parsedData.fogMode && parsedData.fogMode !== 0) {\n        scene.fogMode = parsedData.fogMode;\n        scene.fogColor = Color3.FromArray(parsedData.fogColor);\n        scene.fogStart = parsedData.fogStart;\n        scene.fogEnd = parsedData.fogEnd;\n        scene.fogDensity = parsedData.fogDensity;\n        log += \"\\tFog mode for scene:  \";\n\n        switch (scene.fogMode) {\n          // getters not compiling, so using hardcoded\n          case 1:\n            log += \"exp\\n\";\n            break;\n\n          case 2:\n            log += \"exp2\\n\";\n            break;\n\n          case 3:\n            log += \"linear\\n\";\n            break;\n        }\n      } //Physics\n\n\n      if (parsedData.physicsEnabled) {\n        var physicsPlugin;\n\n        if (parsedData.physicsEngine === \"cannon\") {\n          physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"oimo\") {\n          physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"ammo\") {\n          physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n        }\n\n        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\"; //else - default engine, which is currently oimo\n\n        var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n        scene.enablePhysics(physicsGravity, physicsPlugin);\n      } // Metadata\n\n\n      if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n        scene.metadata = parsedData.metadata;\n      } //collisions, if defined. otherwise, default is true\n\n\n      if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n        scene.collisionsEnabled = parsedData.collisionsEnabled;\n      }\n\n      var container = loadAssetContainer(scene, data, rootUrl, onError, true);\n\n      if (!container) {\n        return false;\n      }\n\n      if (parsedData.autoAnimate) {\n        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n      }\n\n      if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n        scene.setActiveCameraByID(parsedData.activeCameraID);\n      } // Finish\n\n\n      return true;\n    } catch (err) {\n      var msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n\n    return false;\n  },\n  loadAssetContainer: function (scene, data, rootUrl, onError) {\n    var container = loadAssetContainer(scene, data, rootUrl, onError);\n    return container;\n  }\n});","map":{"version":3,"sources":["../../../../sourceES6/core/Loading/Plugins/babylonFileLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Geometry } from \"../../Meshes/geometry\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { MultiMaterial } from \"../../Materials/multiMaterial\";\r\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture\";\r\nimport { AnimationGroup } from \"../../Animations/animationGroup\";\r\nimport { Light } from \"../../Lights/light\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\nimport { AssetContainer } from \"../../assetContainer\";\r\nimport { ActionManager } from \"../../Actions/actionManager\";\r\nimport { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../../Bones/skeleton\";\r\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager\";\r\nimport { CannonJSPlugin } from \"../../Physics/Plugins/cannonJSPlugin\";\r\nimport { OimoJSPlugin } from \"../../Physics/Plugins/oimoJSPlugin\";\r\nimport { AmmoJSPlugin } from \"../../Physics/Plugins/ammoJSPlugin\";\r\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe\";\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { Tools } from '../../Misc/tools';\r\nimport { StringTools } from '../../Misc/stringTools';\r\nimport { PostProcess } from '../../PostProcesses/postProcess';\r\n\r\n/** @hidden */\r\nexport var _BabylonLoaderRegistered = true;\r\n\r\n/**\r\n * Helps setting up some configuration for the babylon file loader.\r\n */\r\nexport class BabylonFileLoaderConfiguration {\r\n    /**\r\n     * The loader does not allow injecting custom physix engine into the plugins.\r\n     * Unfortunately in ES6, we need to manually inject them into the plugin.\r\n     * So you could set this variable to your engine import to make it work.\r\n     */\r\n    public static LoaderInjectedPhysicsEngine: any = undefined;\r\n}\r\n\r\nvar parseMaterialById = (id: string, parsedData: any, scene: Scene, rootUrl: string) => {\r\n    for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n        var parsedMaterial = parsedData.materials[index];\r\n        if (parsedMaterial.id === id) {\r\n            return Material.Parse(parsedMaterial, scene, rootUrl);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nvar isDescendantOf = (mesh: any, names: Array<any>, hierarchyIds: Array<number>) => {\r\n    for (var i in names) {\r\n        if (mesh.name === names[i]) {\r\n            hierarchyIds.push(mesh.id);\r\n            return true;\r\n        }\r\n    }\r\n    if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {\r\n        hierarchyIds.push(mesh.id);\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nvar logOperation = (operation: string, producer: { file: string, name: string, version: string, exporter_version: string }) => {\r\n    return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\r\n};\r\n\r\nvar loadDetailLevels = (scene: Scene, mesh: AbstractMesh) => {\r\n    const mastermesh: Mesh = mesh as Mesh;\r\n\r\n    // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\r\n    // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\r\n    if (mesh._waitingData.lods) {\r\n        if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\r\n            const lodmeshes: string[] = mesh._waitingData.lods.ids;\r\n            const wasenabled: boolean = mastermesh.isEnabled(false);\r\n            if (mesh._waitingData.lods.distances) {\r\n                const distances: number[] = mesh._waitingData.lods.distances;\r\n                if (distances.length >= lodmeshes.length) {\r\n                    const culling: number = (distances.length > lodmeshes.length) ? distances[distances.length - 1] : 0;\r\n                    mastermesh.setEnabled(false);\r\n                    for (let index = 0; index < lodmeshes.length; index++) {\r\n                        const lodid: string = lodmeshes[index];\r\n                        const lodmesh: Mesh = scene.getMeshByID(lodid) as Mesh;\r\n                        if (lodmesh != null) {\r\n                            mastermesh.addLODLevel(distances[index], lodmesh);\r\n                        }\r\n                    }\r\n                    if (culling > 0) {\r\n                        mastermesh.addLODLevel(culling, null);\r\n                    }\r\n                    if (wasenabled === true) {\r\n                        mastermesh.setEnabled(true);\r\n                    }\r\n                } else {\r\n                    Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n        mesh._waitingData.lods = null;\r\n    }\r\n};\r\n\r\nvar loadAssetContainer = (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void, addToScene = false): AssetContainer => {\r\n    var container = new AssetContainer(scene);\r\n\r\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n    // and avoid problems with multiple concurrent .babylon loads.\r\n    var log = \"importScene has failed JSON parse\";\r\n    try {\r\n        var parsedData = JSON.parse(data);\r\n        log = \"\";\r\n        var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n\r\n        var index: number;\r\n        var cache: number;\r\n\r\n        // Environment texture\r\n        if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\r\n            // PBR needed for both HDR texture (gamma space) & a sky box\r\n            var isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\r\n            if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\r\n                var hdrSize: number = (parsedData.environmentTextureSize) ? parsedData.environmentTextureSize : 128;\r\n                var hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR);\r\n                if (parsedData.environmentTextureRotationY) {\r\n                    hdrTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                }\r\n                scene.environmentTexture = hdrTexture;\r\n            } else {\r\n                if (StringTools.EndsWith(parsedData.environmentTexture, \".env\")) {\r\n                    var compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        compressedTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = compressedTexture;\r\n                } else {\r\n                    var cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene);\r\n                    if (parsedData.environmentTextureRotationY) {\r\n                        cubeTexture.rotationY = parsedData.environmentTextureRotationY;\r\n                    }\r\n                    scene.environmentTexture = cubeTexture;\r\n                }\r\n            }\r\n            if (parsedData.createDefaultSkybox === true) {\r\n                var skyboxScale = (scene.activeCamera !== undefined && scene.activeCamera !== null) ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\r\n                var skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\r\n                scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\r\n            }\r\n            container.environmentTexture = scene.environmentTexture;\r\n        }\r\n\r\n        // Environment Intensity\r\n        if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\r\n            scene.environmentIntensity = parsedData.environmentIntensity;\r\n        }\r\n\r\n        // Lights\r\n        if (parsedData.lights !== undefined && parsedData.lights !== null) {\r\n            for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\r\n                var parsedLight = parsedData.lights[index];\r\n                var light = Light.Parse(parsedLight, scene);\r\n                if (light) {\r\n                    container.lights.push(light);\r\n                    log += (index === 0 ? \"\\n\\tLights:\" : \"\");\r\n                    log += \"\\n\\t\\t\" + light.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\r\n            for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\r\n                var parsedReflectionProbe = parsedData.reflectionProbes[index];\r\n                var reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\r\n                if (reflectionProbe) {\r\n                    container.reflectionProbes.push(reflectionProbe);\r\n                    log += (index === 0 ? \"\\n\\tReflection Probes:\" : \"\");\r\n                    log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (parsedData.animations !== undefined && parsedData.animations !== null) {\r\n            for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\r\n                var parsedAnimation = parsedData.animations[index];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    let animation = internalClass.Parse(parsedAnimation);\r\n                    scene.animations.push(animation);\r\n                    container.animations.push(animation);\r\n                    log += (index === 0 ? \"\\n\\tAnimations:\" : \"\");\r\n                    log += \"\\n\\t\\t\" + animation.toString(fullDetails);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        if (parsedData.materials !== undefined && parsedData.materials !== null) {\r\n            for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\r\n                var parsedMaterial = parsedData.materials[index];\r\n                var mat = Material.Parse(parsedMaterial, scene, rootUrl);\r\n                if (mat) {\r\n                    container.materials.push(mat);\r\n                    log += (index === 0 ? \"\\n\\tMaterials:\" : \"\");\r\n                    log += \"\\n\\t\\t\" + mat.toString(fullDetails);\r\n\r\n                    // Textures\r\n                    var textures = mat.getActiveTextures();\r\n                    textures.forEach((t) => {\r\n                        if (container.textures.indexOf(t) == -1) {\r\n                            container.textures.push(t);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n            for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\r\n                var parsedMultiMaterial = parsedData.multiMaterials[index];\r\n                var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                container.multiMaterials.push(mmat);\r\n\r\n                log += (index === 0 ? \"\\n\\tMultiMaterials:\" : \"\");\r\n                log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\r\n\r\n                // Textures\r\n                var textures = mmat.getActiveTextures();\r\n                textures.forEach((t) => {\r\n                    if (container.textures.indexOf(t) == -1) {\r\n                        container.textures.push(t);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Morph targets\r\n        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n            for (var managerData of parsedData.morphTargetManagers) {\r\n                container.morphTargetManagers.push(MorphTargetManager.Parse(managerData, scene));\r\n            }\r\n        }\r\n\r\n        // Skeletons\r\n        if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n            for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\r\n                var parsedSkeleton = parsedData.skeletons[index];\r\n                var skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                container.skeletons.push(skeleton);\r\n                log += (index === 0 ? \"\\n\\tSkeletons:\" : \"\");\r\n                log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        var geometries = parsedData.geometries;\r\n        if (geometries !== undefined && geometries !== null) {\r\n            var addedGeometry = new Array<Nullable<Geometry>>();\r\n\r\n            // VertexData\r\n            var vertexData = geometries.vertexData;\r\n            if (vertexData !== undefined && vertexData !== null) {\r\n                for (index = 0, cache = vertexData.length; index < cache; index++) {\r\n                    var parsedVertexData = vertexData[index];\r\n                    addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\r\n                }\r\n            }\r\n\r\n            addedGeometry.forEach((g) => {\r\n                if (g) {\r\n                    container.geometries.push(g);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Transform nodes\r\n        if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\r\n            for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\r\n                var parsedTransformNode = parsedData.transformNodes[index];\r\n                var node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\r\n                container.transformNodes.push(node);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n            for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                var parsedMesh = parsedData.meshes[index];\r\n                var mesh = <AbstractMesh>Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                container.meshes.push(mesh);\r\n                if (mesh.hasInstances) {\r\n                    for (var instance of (mesh as Mesh).instances) {\r\n                        container.meshes.push(instance);\r\n                    }\r\n                }\r\n                log += (index === 0 ? \"\\n\\tMeshes:\" : \"\");\r\n                log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\r\n            for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\r\n                var parsedCamera = parsedData.cameras[index];\r\n                var camera = Camera.Parse(parsedCamera, scene);\r\n                container.cameras.push(camera);\r\n                log += (index === 0 ? \"\\n\\tCameras:\" : \"\");\r\n                log += \"\\n\\t\\t\" + camera.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Postprocesses\r\n        if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\r\n            for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\r\n                var parsedPostProcess = parsedData.postProcesses[index];\r\n                var postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\r\n                if (postProcess) {\r\n                    container.postProcesses.push(postProcess);\r\n                    log += (index === 0 ? \"\\n\\Postprocesses:\" : \"\");\r\n                    log += \"\\n\\t\\t\" + postProcess.toString();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animation Groups\r\n        if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\r\n            for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\r\n                var parsedAnimationGroup = parsedData.animationGroups[index];\r\n                var animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\r\n                container.animationGroups.push(animationGroup);\r\n                log += (index === 0 ? \"\\n\\tAnimationGroups:\" : \"\");\r\n                log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\r\n            }\r\n        }\r\n\r\n        // Browsing all the graph to connect the dots\r\n        for (index = 0, cache = scene.cameras.length; index < cache; index++) {\r\n            var camera = scene.cameras[index];\r\n            if (camera._waitingParentId) {\r\n                camera.parent = scene.getLastEntryByID(camera._waitingParentId);\r\n                camera._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            let light = scene.lights[index];\r\n            if (light && light._waitingParentId) {\r\n                light.parent = scene.getLastEntryByID(light._waitingParentId);\r\n                light._waitingParentId = null;\r\n            }\r\n        }\r\n\r\n        // Connect parents & children and parse actions and lods\r\n        for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\r\n            var transformNode = scene.transformNodes[index];\r\n            if (transformNode._waitingParentId) {\r\n                transformNode.parent = scene.getLastEntryByID(transformNode._waitingParentId);\r\n                transformNode._waitingParentId = null;\r\n            }\r\n        }\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            var mesh = scene.meshes[index];\r\n            if (mesh._waitingParentId) {\r\n                mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);\r\n                mesh._waitingParentId = null;\r\n            }\r\n            if (mesh._waitingData.lods) {\r\n                loadDetailLevels(scene, mesh);\r\n            }\r\n        }\r\n\r\n        // link skeleton transform nodes\r\n        for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n            var skeleton = scene.skeletons[index];\r\n            if (skeleton._hasWaitingData) {\r\n                if (skeleton.bones != null) {\r\n                    skeleton.bones.forEach((bone) => {\r\n                        if (bone._waitingTransformNodeId) {\r\n                            var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId) as TransformNode;\r\n                            if (linkTransformNode) {\r\n                                bone.linkTransformNode(linkTransformNode);\r\n                            }\r\n                            bone._waitingTransformNodeId = null;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (skeleton._waitingOverrideMeshId) {\r\n                    skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\r\n                    skeleton._waitingOverrideMeshId = null;\r\n                }\r\n                skeleton._hasWaitingData = null;\r\n            }\r\n        }\r\n\r\n        // freeze world matrix application\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            var currentMesh = scene.meshes[index];\r\n            if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                currentMesh.freezeWorldMatrix();\r\n                currentMesh._waitingData.freezeWorldMatrix = null;\r\n            } else {\r\n                currentMesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        // Lights exclusions / inclusions\r\n        for (index = 0, cache = scene.lights.length; index < cache; index++) {\r\n            let light = scene.lights[index];\r\n            // Excluded check\r\n            if (light._excludedMeshesIds.length > 0) {\r\n                for (var excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\r\n                    var excludedMesh = scene.getMeshByID(light._excludedMeshesIds[excludedIndex]);\r\n\r\n                    if (excludedMesh) {\r\n                        light.excludedMeshes.push(excludedMesh);\r\n                    }\r\n                }\r\n\r\n                light._excludedMeshesIds = [];\r\n            }\r\n\r\n            // Included check\r\n            if (light._includedOnlyMeshesIds.length > 0) {\r\n                for (var includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\r\n                    var includedOnlyMesh = scene.getMeshByID(light._includedOnlyMeshesIds[includedOnlyIndex]);\r\n\r\n                    if (includedOnlyMesh) {\r\n                        light.includedOnlyMeshes.push(includedOnlyMesh);\r\n                    }\r\n                }\r\n\r\n                light._includedOnlyMeshesIds = [];\r\n            }\r\n        }\r\n\r\n        AbstractScene.Parse(parsedData, scene, container, rootUrl);\r\n\r\n        // Actions (scene) Done last as it can access other objects.\r\n        for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n            var mesh = scene.meshes[index];\r\n            if (mesh._waitingData.actions) {\r\n                ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\r\n                mesh._waitingData.actions = null;\r\n            }\r\n        }\r\n        if (parsedData.actions !== undefined && parsedData.actions !== null) {\r\n            ActionManager.Parse(parsedData.actions, null, scene);\r\n        }\r\n    } catch (err) {\r\n        let msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n        if (onError) {\r\n            onError(msg, err);\r\n        } else {\r\n            Logger.Log(msg);\r\n            throw err;\r\n        }\r\n    } finally {\r\n        if (!addToScene) {\r\n            container.removeAllFromScene();\r\n        }\r\n        if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n            Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n        }\r\n    }\r\n\r\n    return container;\r\n};\r\n\r\nSceneLoader.RegisterPlugin({\r\n    name: \"babylon.js\",\r\n    extensions: \".babylon\",\r\n    canDirectLoad: (data: string) => {\r\n        if (data.indexOf(\"babylon\") !== -1) { // We consider that the producer string is filled\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n    importMesh: (meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], onError?: (message: string, exception?: any) => void): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        var log = \"importMesh has failed JSON parse\";\r\n        try {\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n            var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\r\n            if (!meshesNames) {\r\n                meshesNames = null;\r\n            } else if (!Array.isArray(meshesNames)) {\r\n                meshesNames = [meshesNames];\r\n            }\r\n\r\n            var hierarchyIds = new Array<number>();\r\n            if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\r\n                var loadedSkeletonsIds = [];\r\n                var loadedMaterialsIds = [];\r\n                var index: number;\r\n                var cache: number;\r\n                for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\r\n                    var parsedMesh = parsedData.meshes[index];\r\n\r\n                    if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\r\n                        if (meshesNames !== null) {\r\n                            // Remove found mesh name from list.\r\n                            delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\r\n                        }\r\n\r\n                        //Geometry?\r\n                        if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\r\n                            //does the file contain geometries?\r\n                            if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\r\n                                //find the correct geometry and add it to the scene\r\n                                var found: boolean = false;\r\n                                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach((geometryType: string) => {\r\n                                    if (found === true || !parsedData.geometries[geometryType] || !(Array.isArray(parsedData.geometries[geometryType]))) {\r\n                                        return;\r\n                                    } else {\r\n                                        parsedData.geometries[geometryType].forEach((parsedGeometryData: any) => {\r\n                                            if (parsedGeometryData.id === parsedMesh.geometryId) {\r\n                                                switch (geometryType) {\r\n                                                    case \"vertexData\":\r\n                                                        Geometry.Parse(parsedGeometryData, scene, rootUrl);\r\n                                                        break;\r\n                                                }\r\n                                                found = true;\r\n                                            }\r\n                                        });\r\n\r\n                                    }\r\n                                });\r\n                                if (found === false) {\r\n                                    Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Material ?\r\n                        if (parsedMesh.materialId) {\r\n                            var materialFound = (loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1);\r\n                            if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\r\n                                for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\r\n                                    var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\r\n                                    if (parsedMultiMaterial.id === parsedMesh.materialId) {\r\n                                        for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {\r\n                                            var subMatId = parsedMultiMaterial.materials[matIndex];\r\n                                            loadedMaterialsIds.push(subMatId);\r\n                                            var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);\r\n                                            if (mat) {\r\n                                                log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\r\n                                            }\r\n                                        }\r\n                                        loadedMaterialsIds.push(parsedMultiMaterial.id);\r\n                                        var mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\r\n                                        if (mmat) {\r\n                                            materialFound = true;\r\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (materialFound === false) {\r\n                                loadedMaterialsIds.push(parsedMesh.materialId);\r\n                                var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);\r\n                                if (!mat) {\r\n                                    Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\r\n                                } else {\r\n                                    log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Skeleton ?\r\n                        if (parsedMesh.skeletonId > -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\r\n                            var skeletonAlreadyLoaded = (loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1);\r\n                            if (skeletonAlreadyLoaded === false) {\r\n                                for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\r\n                                    var parsedSkeleton = parsedData.skeletons[skeletonIndex];\r\n                                    if (parsedSkeleton.id === parsedMesh.skeletonId) {\r\n                                        var skeleton = Skeleton.Parse(parsedSkeleton, scene);\r\n                                        skeletons.push(skeleton);\r\n                                        loadedSkeletonsIds.push(parsedSkeleton.id);\r\n                                        log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Morph targets ?\r\n                        if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\r\n                            for (var managerData of parsedData.morphTargetManagers) {\r\n                                MorphTargetManager.Parse(managerData, scene);\r\n                            }\r\n                        }\r\n\r\n                        var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\r\n                        meshes.push(mesh);\r\n                        log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\r\n                    }\r\n                }\r\n\r\n                // Connecting parents and lods\r\n                var currentMesh: AbstractMesh;\r\n                for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingParentId) {\r\n                        currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);\r\n                        currentMesh._waitingParentId = null;\r\n                    }\r\n                    if (currentMesh._waitingData.lods) {\r\n                        loadDetailLevels(scene, currentMesh);\r\n                    }\r\n                }\r\n\r\n                // link skeleton transform nodes\r\n                for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\r\n                    var skeleton = scene.skeletons[index];\r\n                    if (skeleton._hasWaitingData) {\r\n                        if (skeleton.bones != null) {\r\n                            skeleton.bones.forEach((bone) => {\r\n                                if (bone._waitingTransformNodeId) {\r\n                                    var linkTransformNode = scene.getLastEntryByID(bone._waitingTransformNodeId) as TransformNode;\r\n                                    if (linkTransformNode) {\r\n                                        bone.linkTransformNode(linkTransformNode);\r\n                                    }\r\n                                    bone._waitingTransformNodeId = null;\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        if (skeleton._waitingOverrideMeshId) {\r\n                            skeleton.overrideMesh = scene.getMeshByID(skeleton._waitingOverrideMeshId);\r\n                            skeleton._waitingOverrideMeshId = null;\r\n                        }\r\n\r\n                        skeleton._hasWaitingData = null;\r\n                    }\r\n                }\r\n\r\n                // freeze and compute world matrix application\r\n                for (index = 0, cache = scene.meshes.length; index < cache; index++) {\r\n                    currentMesh = scene.meshes[index];\r\n                    if (currentMesh._waitingData.freezeWorldMatrix) {\r\n                        currentMesh.freezeWorldMatrix();\r\n                        currentMesh._waitingData.freezeWorldMatrix = null;\r\n                    } else {\r\n                        currentMesh.computeWorldMatrix(true);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Particles\r\n            if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n                let parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n                if (parser) {\r\n                    for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n                        var parsedParticleSystem = parsedData.particleSystems[index];\r\n                        if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\r\n                            particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n\r\n        } catch (err) {\r\n            let msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n    load: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean => {\r\n        // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\r\n        // when SceneLoader.debugLogging = true (default), or exception encountered.\r\n        // Everything stored in var log instead of writing separate lines to support only writing in exception,\r\n        // and avoid problems with multiple concurrent .babylon loads.\r\n        var log = \"importScene has failed JSON parse\";\r\n        try {\r\n            var parsedData = JSON.parse(data);\r\n            log = \"\";\r\n\r\n            // Scene\r\n            if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\r\n                scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\r\n            }\r\n            if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\r\n                scene.autoClear = parsedData.autoClear;\r\n            }\r\n            if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\r\n                scene.clearColor = Color4.FromArray(parsedData.clearColor);\r\n            }\r\n            if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\r\n                scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\r\n            }\r\n            if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\r\n                scene.gravity = Vector3.FromArray(parsedData.gravity);\r\n            }\r\n\r\n            // Fog\r\n            if (parsedData.fogMode && parsedData.fogMode !== 0) {\r\n                scene.fogMode = parsedData.fogMode;\r\n                scene.fogColor = Color3.FromArray(parsedData.fogColor);\r\n                scene.fogStart = parsedData.fogStart;\r\n                scene.fogEnd = parsedData.fogEnd;\r\n                scene.fogDensity = parsedData.fogDensity;\r\n                log += \"\\tFog mode for scene:  \";\r\n                switch (scene.fogMode) {\r\n                    // getters not compiling, so using hardcoded\r\n                    case 1: log += \"exp\\n\"; break;\r\n                    case 2: log += \"exp2\\n\"; break;\r\n                    case 3: log += \"linear\\n\"; break;\r\n                }\r\n            }\r\n\r\n            //Physics\r\n            if (parsedData.physicsEnabled) {\r\n                var physicsPlugin;\r\n                if (parsedData.physicsEngine === \"cannon\") {\r\n                    physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"oimo\") {\r\n                    physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\r\n                } else if (parsedData.physicsEngine === \"ammo\") {\r\n                    physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\r\n                }\r\n                log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\r\n                //else - default engine, which is currently oimo\r\n                var physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\r\n                scene.enablePhysics(physicsGravity, physicsPlugin);\r\n            }\r\n\r\n            // Metadata\r\n            if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\r\n                scene.metadata = parsedData.metadata;\r\n            }\r\n\r\n            //collisions, if defined. otherwise, default is true\r\n            if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\r\n                scene.collisionsEnabled = parsedData.collisionsEnabled;\r\n            }\r\n\r\n            var container = loadAssetContainer(scene, data, rootUrl, onError, true);\r\n            if (!container) {\r\n                return false;\r\n            }\r\n\r\n            if (parsedData.autoAnimate) {\r\n                scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\r\n            }\r\n\r\n            if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\r\n                scene.setActiveCameraByID(parsedData.activeCameraID);\r\n            }\r\n\r\n            // Finish\r\n            return true;\r\n        } catch (err) {\r\n            let msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\r\n            if (onError) {\r\n                onError(msg, err);\r\n            } else {\r\n                Logger.Log(msg);\r\n                throw err;\r\n            }\r\n        } finally {\r\n            if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\r\n                Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n    loadAssetContainer: (scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer => {\r\n        var container = loadAssetContainer(scene, data, rootUrl, onError);\r\n        return container;\r\n    }\r\n});\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}