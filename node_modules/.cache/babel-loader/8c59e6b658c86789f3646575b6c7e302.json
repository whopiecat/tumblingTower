{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\"; // This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\n\nvar Levenshtein;\n\n(function (Levenshtein) {\n  /**\r\n   * Alphabet from which to construct sequences to be compared using Levenshtein\r\n   * distance.\r\n   */\n  var Alphabet =\n  /** @class */\n  function () {\n    /**\r\n     * Create a new Alphabet.\r\n     * @param characters characters of the alphabet\r\n     * @param charToInsertionCost function mapping characters to insertion costs\r\n     * @param charToDeletionCost function mapping characters to deletion costs\r\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n     */\n    function Alphabet(characters, charToInsertionCost, charToDeletionCost, charsToSubstitutionCost) {\n      if (charToInsertionCost === void 0) {\n        charToInsertionCost = null;\n      }\n\n      if (charToDeletionCost === void 0) {\n        charToDeletionCost = null;\n      }\n\n      if (charsToSubstitutionCost === void 0) {\n        charsToSubstitutionCost = null;\n      }\n\n      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : function () {\n        return 1;\n      };\n      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : function () {\n        return 1;\n      };\n      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : function (a, b) {\n        return a === b ? 0 : 1;\n      };\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      var c;\n\n      for (var outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n\n        this._characterToIdx.set(c, outerIdx);\n\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n\n        for (var innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\r\n     * Serialize the Alphabet to JSON string.\r\n     * @returns JSON serialization\r\n     */\n\n\n    Alphabet.prototype.serialize = function () {\n      var jsonObject = {};\n      var characters = new Array(this._characterToIdx.size);\n\n      this._characterToIdx.forEach(function (v, k) {\n        characters[v] = k;\n      });\n\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    };\n    /**\r\n     * Parse an Alphabet from a JSON serialization.\r\n     * @param json JSON string to deserialize\r\n     * @returns deserialized Alphabet\r\n     */\n\n\n    Alphabet.Deserialize = function (json) {\n      var jsonObject = JSON.parse(json);\n      var alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    };\n    /**\r\n     * Get the index (internally-assigned number) for a character.\r\n     * @param char character\r\n     * @returns index\r\n     */\n\n\n    Alphabet.prototype.getCharacterIdx = function (char) {\n      return this._characterToIdx.get(char);\n    };\n    /**\r\n     * Get the insertion cost of a character from its index.\r\n     * @param idx character index\r\n     * @returns insertion cost\r\n     */\n\n\n    Alphabet.prototype.getInsertionCost = function (idx) {\n      return this._insertionCosts[idx];\n    };\n    /**\r\n     * Get the deletion cost of a character from its index.\r\n     * @param idx character index\r\n     * @returns deletion cost\r\n     */\n\n\n    Alphabet.prototype.getDeletionCost = function (idx) {\n      return this._deletionCosts[idx];\n    };\n    /**\r\n     * Gets the cost to substitute two characters. NOTE: this cost is\r\n     * required to be bi-directional, meaning it cannot matter which of\r\n     * the provided characters is being removed and which is being inserted.\r\n     * @param idx1 the first character index\r\n     * @param idx2 the second character index\r\n     * @returns substitution cost\r\n     */\n\n\n    Alphabet.prototype.getSubstitutionCost = function (idx1, idx2) {\n      var min = Math.min(idx1, idx2);\n      var max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    };\n\n    return Alphabet;\n  }();\n\n  Levenshtein.Alphabet = Alphabet;\n  /**\r\n   * Character sequence intended to be compared against other Sequences created\r\n   * with the same Alphabet in order to compute Levenshtein distance.\r\n   */\n\n  var Sequence =\n  /** @class */\n  function () {\n    /**\r\n     * Create a new Sequence.\r\n     * @param characters characters in the new Sequence\r\n     * @param alphabet Alphabet, which must include all used characters\r\n     */\n    function Sequence(characters, alphabet) {\n      var _this = this;\n\n      if (characters.length > Sequence.MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence.MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n\n      this._alphabet = alphabet;\n      this._characters = characters.map(function (c) {\n        return _this._alphabet.getCharacterIdx(c);\n      });\n    }\n    /**\r\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n     * from which this Sequence was created; Alphabet must be independently\r\n     * serialized.\r\n     * @returns JSON string\r\n     */\n\n\n    Sequence.prototype.serialize = function () {\n      return JSON.stringify(this._characters);\n    };\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the Sequence was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation of Sequence\r\n     * @param alphabet Alphabet from which Sequence was originally created\r\n     * @returns Sequence\r\n     */\n\n\n    Sequence.Deserialize = function (json, alphabet) {\n      var sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    };\n    /**\r\n     * Get the distance between this Sequence and another.\r\n     * @param other sequence to compare to\r\n     * @returns Levenshtein distance\r\n     */\n\n\n    Sequence.prototype.distance = function (other) {\n      return Sequence._distance(this, other);\n    };\n    /**\r\n     * Compute the Levenshtein distance between two Sequences.\r\n     * @param a first Sequence\r\n     * @param b second Sequence\r\n     * @returns Levenshtein distance\r\n     */\n\n\n    Sequence._distance = function (a, b) {\n      var alphabet = a._alphabet;\n\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n\n      var aChars = a._characters;\n      var bChars = b._characters;\n      var aLength = aChars.length;\n      var bLength = bChars.length;\n      var costMatrix = Sequence._costMatrix;\n      costMatrix[0][0] = 0;\n\n      for (var idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n\n      for (var idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n\n      for (var aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (var bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._insertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._deletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._substitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._insertionCost, Sequence._deletionCost, Sequence._substitutionCost);\n        }\n      }\n\n      return costMatrix[aLength][bLength];\n    }; // Scratch values\n\n\n    Sequence.MAX_SEQUENCE_LENGTH = 256;\n    Sequence._costMatrix = __spreadArrays(Array(Sequence.MAX_SEQUENCE_LENGTH + 1)).map(function (n) {\n      return new Array(Sequence.MAX_SEQUENCE_LENGTH + 1);\n    });\n    return Sequence;\n  }();\n\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\n\n\nvar Trajectory =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new empty Trajectory.\r\n   * @param segmentLength radius of discretization for Trajectory points\r\n   */\n  function Trajectory(segmentLength) {\n    if (segmentLength === void 0) {\n      segmentLength = 0.01;\n    }\n\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns serialized JSON string\r\n   */\n\n\n  Trajectory.prototype.serialize = function () {\n    return JSON.stringify(this);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json serialized JSON string\r\n   * @returns deserialized Trajectory\r\n   */\n\n\n  Trajectory.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(function (pt) {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  };\n  /**\r\n   * Get the length of the Trajectory.\r\n   * @returns length of the Trajectory\r\n   */\n\n\n  Trajectory.prototype.getLength = function () {\n    return this._points.length * this._segmentLength;\n  };\n  /**\r\n   * Append a new point to the Trajectory.\r\n   * NOTE: This implementation has many allocations.\r\n   * @param point point to append to the Trajectory\r\n   */\n\n\n  Trajectory.prototype.add = function (point) {\n    var _this = this;\n\n    var numPoints = this._points.length;\n\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      var getT = function () {\n        return _this._segmentLength / Vector3.Distance(_this._points[numPoints - 1], point);\n      };\n\n      for (var t = getT(); t <= 1.0; t = getT()) {\n        var newPoint = this._points[numPoints - 1].scale(1.0 - t);\n\n        point.scaleAndAddToRef(t, newPoint);\n\n        this._points.push(newPoint);\n\n        ++numPoints;\n      }\n    }\n  };\n  /**\r\n   * Create a new Trajectory with a segment length chosen to make it\r\n   * probable that the new Trajectory will have a specified number of\r\n   * segments. This operation is imprecise.\r\n   * @param targetResolution number of segments desired\r\n   * @returns new Trajectory with approximately the requested number of segments\r\n   */\n\n\n  Trajectory.prototype.resampleAtTargetResolution = function (targetResolution) {\n    var resampled = new Trajectory(this.getLength() / targetResolution);\n\n    this._points.forEach(function (pt) {\n      resampled.add(pt);\n    });\n\n    return resampled;\n  };\n  /**\r\n   * Convert Trajectory segments into tokenized representation. This\r\n   * representation is an array of numbers where each nth number is the\r\n   * index of the token which is most similar to the nth segment of the\r\n   * Trajectory.\r\n   * @param tokens list of vectors which serve as discrete tokens\r\n   * @returns list of indices of most similar token per segment\r\n   */\n\n\n  Trajectory.prototype.tokenize = function (tokens) {\n    var tokenization = [];\n    var segmentDir = new Vector3();\n\n    for (var idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._transformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._tokenizeSegment(segmentDir, tokens));\n      }\n    }\n\n    return tokenization;\n  };\n  /**\r\n   * Transform the rotation (i.e., direction) of a segment to isolate\r\n   * the relative transformation represented by the segment. This operation\r\n   * may or may not succeed due to singularities in the equations that define\r\n   * motion relativity in this context.\r\n   * @param priorVec the origin of the prior segment\r\n   * @param fromVec the origin of the current segment\r\n   * @param toVec the destination of the current segment\r\n   * @param result reference to output variable\r\n   * @returns whether or not transformation was successful\r\n   */\n\n\n  Trajectory._transformSegmentDirToRef = function (priorVec, fromVec, toVec, result) {\n    var DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._forwardDir);\n\n    Trajectory._forwardDir.normalize();\n\n    fromVec.scaleToRef(-1, Trajectory._inverseFromVec);\n\n    Trajectory._inverseFromVec.normalize();\n\n    if (Math.abs(Vector3.Dot(Trajectory._forwardDir, Trajectory._inverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n\n    Vector3.CrossToRef(Trajectory._forwardDir, Trajectory._inverseFromVec, Trajectory._upDir);\n\n    Trajectory._upDir.normalize();\n\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._upDir, Trajectory._lookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._fromToVec);\n\n    Trajectory._fromToVec.normalize();\n\n    Vector3.TransformNormalToRef(Trajectory._fromToVec, Trajectory._lookMatrix, result);\n    return true;\n  };\n  /**\r\n   * Determine which token vector is most similar to the\r\n   * segment vector.\r\n   * @param segment segment vector\r\n   * @param tokens token vector list\r\n   * @returns index of the most similar token to the segment\r\n   */\n\n\n  Trajectory._tokenizeSegment = function (segment, tokens) {\n    Trajectory._bestMatch = 0;\n    Trajectory._score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._bestScore = Trajectory._score;\n\n    for (var idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._score = Vector3.Dot(segment, tokens[idx]);\n\n      if (Trajectory._score > Trajectory._bestScore) {\n        Trajectory._bestMatch = idx;\n        Trajectory._bestScore = Trajectory._score;\n      }\n    }\n\n    return Trajectory._bestMatch;\n  };\n\n  Trajectory._forwardDir = new Vector3();\n  Trajectory._inverseFromVec = new Vector3();\n  Trajectory._upDir = new Vector3();\n  Trajectory._fromToVec = new Vector3();\n  Trajectory._lookMatrix = new Matrix();\n  return Trajectory;\n}();\n\nexport { Trajectory };\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\n\nvar Vector3Alphabet =\n/** @class */\nfunction () {\n  function Vector3Alphabet(size) {\n    this.chars = new Array(size);\n  }\n  /**\r\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n   * optimize-from-random strategy to space points around the unit sphere\r\n   * surface as a simple alternative to really doing the math to tile the\r\n   * sphere.\r\n   * @param alphabetSize size of the desired alphabet\r\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n   * @param startingStepSize distance factor to move points in early optimization iterations\r\n   * @param endingStepSize distance factor to move points in late optimization iterations\r\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n   */\n\n\n  Vector3Alphabet.Generate = function (alphabetSize, iterations, startingStepSize, endingStepSize, fixedValues) {\n    if (alphabetSize === void 0) {\n      alphabetSize = 64;\n    }\n\n    if (iterations === void 0) {\n      iterations = 256;\n    }\n\n    if (startingStepSize === void 0) {\n      startingStepSize = 0.1;\n    }\n\n    if (endingStepSize === void 0) {\n      endingStepSize = 0.001;\n    }\n\n    if (fixedValues === void 0) {\n      fixedValues = [];\n    }\n\n    var EPSILON = 0.001;\n    var EPSILON_SQUARED = EPSILON * EPSILON;\n    var alphabet = new Vector3Alphabet(alphabetSize);\n\n    for (var idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n\n    for (var idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n\n    var stepSize;\n    var distSq;\n    var force = new Vector3();\n    var scratch = new Vector3();\n\n    var lerp = function (l, r, t) {\n      return (1.0 - t) * l + t * r;\n    };\n\n    for (var iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n\n      var _loop_1 = function (idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(function (pt) {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      };\n\n      for (var idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        _loop_1(idx);\n      }\n    }\n\n    return alphabet;\n  };\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  Vector3Alphabet.prototype.serialize = function () {\n    return JSON.stringify(this.chars);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json JSON serialization\r\n   * @returns deserialized Vector3Alphabet\r\n   */\n\n\n  Vector3Alphabet.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var alphabet = new Vector3Alphabet(jsonObject.length);\n\n    for (var idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n\n    return alphabet;\n  };\n\n  return Vector3Alphabet;\n}();\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\n\n\nvar TrajectoryDescriptor =\n/** @class */\nfunction () {\n  function TrajectoryDescriptor() {\n    this._sequences = [];\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryDescriptor.prototype.serialize = function () {\n    return JSON.stringify(this._sequences.map(function (sequence) {\n      return sequence.serialize();\n    }));\n  };\n  /**\r\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n   * from which the descriptor was originally created, which must be serialized and\r\n   * deserialized independently so that it can be passed in here.\r\n   * @param json JSON serialization\r\n   * @param alphabet Alphabet from which descriptor was originally created\r\n   * @returns deserialized TrajectoryDescriptor\r\n   */\n\n\n  TrajectoryDescriptor.Deserialize = function (json, alphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(function (s) {\n      return Levenshtein.Sequence.Deserialize(s, alphabet);\n    });\n    return descriptor;\n  };\n  /**\r\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n   * to the provided alphabets.\r\n   * @param trajectory Trajectory to be described\r\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n   * @returns TrajectoryDescriptor describing provided Trajectory\r\n   */\n\n\n  TrajectoryDescriptor.CreateFromTrajectory = function (trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._getTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  };\n  /**\r\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n   * NOTE: This function exists to support an outdated serialization mechanism and should\r\n   * be deleted if it is no longer useful.\r\n   * @param pyramid tokenization pyramid\r\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n   */\n\n\n  TrajectoryDescriptor.CreateFromTokenizationPyramid = function (pyramid, levenshteinAlphabet) {\n    var descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(function (tokens) {\n      return new Levenshtein.Sequence(tokens, levenshteinAlphabet);\n    });\n    return descriptor;\n  };\n  /**\r\n   * Create the tokenization pyramid for the provided Trajectory according to the given\r\n   * Vector3Alphabet.\r\n   * @param trajectory Trajectory to be tokenized\r\n   * @param alphabet Vector3Alphabet containing tokens\r\n   * @param targetResolution finest resolution of descriptor\r\n   * @returns tokenization pyramid for Trajectory\r\n   */\n\n\n  TrajectoryDescriptor._getTokenizationPyramid = function (trajectory, alphabet, targetResolution) {\n    if (targetResolution === void 0) {\n      targetResolution = TrajectoryDescriptor.FINEST_DESCRIPTOR_RESOLUTION;\n    }\n\n    var pyramid = [];\n\n    for (var res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n\n    return pyramid;\n  };\n  /**\r\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n   * essentially a similarity score and does not directly represent Euclidean distance,\r\n   * edit distance, or any other formal distance metric.\r\n   * @param other TrajectoryDescriptor from which to determine distance\r\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n   */\n\n\n  TrajectoryDescriptor.prototype.distance = function (other) {\n    var totalDistance = 0;\n    var weight;\n\n    for (var idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n\n    return totalDistance;\n  };\n\n  TrajectoryDescriptor.FINEST_DESCRIPTOR_RESOLUTION = 32;\n  return TrajectoryDescriptor;\n}();\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\n\n\nvar TrajectoryClass =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new DescribedTrajectory.\r\n   * @param descriptors currently-known TrajectoryDescriptors, if any\r\n   */\n  function TrajectoryClass(descriptors) {\n    if (descriptors === void 0) {\n      descriptors = [];\n    }\n\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n\n    this._refreshDescription();\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryClass.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(function (desc) {\n      return desc.serialize();\n    });\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  };\n  /**\r\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n   * from which the descriptors were originally created, which must be serialized and\r\n   * deserialized independently so that it can be passed in here.\r\n   * @param json JSON string representation\r\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n   * @returns deserialized TrajectoryDescriptor\r\n   */\n\n\n  TrajectoryClass.Deserialize = function (json, alphabet) {\n    var jsonObject = JSON.parse(json);\n    var described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(function (s) {\n      return TrajectoryDescriptor.Deserialize(s, alphabet);\n    });\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  };\n  /**\r\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n   * this same DescribedTrajectory.\r\n   * @param descriptor descriptor to be added\r\n   */\n\n\n  TrajectoryClass.prototype.add = function (descriptor) {\n    this._descriptors.push(descriptor);\n\n    this._refreshDescription();\n  };\n  /**\r\n   * Compute the cost, which is inversely related to the likelihood that the provided\r\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n   * the class represented by this DescribedTrajectory.\r\n   * @param descriptor the descriptor to be costed\r\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimiliarity\r\n   */\n\n\n  TrajectoryClass.prototype.getMatchCost = function (descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  };\n  /**\r\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n   * descriptor which is a member of this collection. This is an alternative way of\r\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n   * @param descriptor the descriptor to find the minimum distance to\r\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n   */\n\n\n  TrajectoryClass.prototype.getMatchMinimumDistance = function (descriptor) {\n    return Math.min.apply(Math, this._descriptors.map(function (desc) {\n      return desc.distance(descriptor);\n    }));\n  };\n  /**\r\n   * Refreshes the internal representation of this DescribedTrajectory.\r\n   */\n\n\n  TrajectoryClass.prototype._refreshDescription = function () {\n    var _this = this;\n\n    this._centroidIdx = -1;\n    var sum;\n\n    var distances = this._descriptors.map(function (a) {\n      sum = 0;\n\n      _this._descriptors.forEach(function (b) {\n        sum += a.distance(b);\n      });\n\n      return sum;\n    });\n\n    for (var idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n\n    this._averageDistance = 0;\n\n    this._descriptors.forEach(function (desc) {\n      _this._averageDistance += desc.distance(_this._descriptors[_this._centroidIdx]);\n    });\n\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass.MIN_AVERAGE_DISTANCE);\n    }\n  };\n\n  TrajectoryClass.MIN_AVERAGE_DISTANCE = 1;\n  return TrajectoryClass;\n}();\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\n\n\nvar TrajectoryClassifier =\n/** @class */\nfunction () {\n  function TrajectoryClassifier() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\r\n   * Serialize to JSON.\r\n   * @returns JSON serialization\r\n   */\n\n\n  TrajectoryClassifier.prototype.serialize = function () {\n    var jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n\n    this._nameToDescribedTrajectory.forEach(function (described, name) {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n\n    return JSON.stringify(jsonObject);\n  };\n  /**\r\n   * Deserialize from JSON.\r\n   * @param json JSON serialization\r\n   * @returns deserialized TrajectorySet\r\n   */\n\n\n  TrajectoryClassifier.Deserialize = function (json) {\n    var jsonObject = JSON.parse(json);\n    var classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n\n    for (var idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n\n    return classifier;\n  };\n  /**\r\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n   * VERY naive, need to be generating these things from known\r\n   * sets. Better version later, probably eliminating this one.\r\n   * @returns auto-generated TrajectorySet\r\n   */\n\n\n  TrajectoryClassifier.Generate = function () {\n    var vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    var charIdxs = new Array(vecs.chars.length);\n\n    for (var idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n\n    var alphabet = new Levenshtein.Alphabet(charIdxs, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (idx) {\n      return idx === 0 ? 0 : 1;\n    }, function (a, b) {\n      return Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1);\n    });\n    var trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  };\n  /**\r\n   * Add a new Trajectory to the set with a given name.\r\n   * @param trajectory new Trajectory to be added\r\n   * @param classification name to which to add the Trajectory\r\n   */\n\n\n  TrajectoryClassifier.prototype.addTrajectoryToClassification = function (trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  };\n  /**\r\n   * Remove a known named trajectory and all Trajectories associated with it.\r\n   * @param classification name to remove\r\n   * @returns whether anything was removed\r\n   */\n\n\n  TrajectoryClassifier.prototype.deleteClassification = function (classification) {\n    return this._nameToDescribedTrajectory.delete(classification);\n  };\n  /**\r\n   * Attempt to recognize a Trajectory from among all the classifications\r\n   * already known to the classifier.\r\n   * @param trajectory Trajectory to be recognized\r\n   * @returns classification of Trajectory if recognized, null otherwise\r\n   */\n\n\n  TrajectoryClassifier.prototype.classifyTrajectory = function (trajectory) {\n    var _this = this;\n\n    var descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    var allowableMatches = [];\n\n    this._nameToDescribedTrajectory.forEach(function (trajectoryClass, classification) {\n      if (trajectoryClass.getMatchCost(descriptor) < _this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n\n    var bestIdx = 0;\n\n    var bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n\n    var match;\n\n    for (var idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n\n    return allowableMatches[bestIdx];\n  };\n\n  return TrajectoryClassifier;\n}();\n\nexport { TrajectoryClassifier };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/trajectoryClassifier.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepImmutable, Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\n\r\n// This implementation was based on the original MIT-licensed TRACE repository\r\n// from https://github.com/septagon/TRACE.\r\n\r\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\r\nnamespace Levenshtein {\r\n    /**\r\n     * Alphabet from which to construct sequences to be compared using Levenshtein\r\n     * distance.\r\n     */\r\n    export class Alphabet<T> {\r\n        private _characterToIdx: Map<T, number>;\r\n        private _insertionCosts: number[];\r\n        private _deletionCosts: number[];\r\n        private _substitutionCosts: number[][];\r\n\r\n        /**\r\n         * Serialize the Alphabet to JSON string.\r\n         * @returns JSON serialization\r\n         */\r\n        public serialize(): string {\r\n            let jsonObject: any = {};\r\n\r\n            let characters = new Array<T>(this._characterToIdx.size);\r\n            this._characterToIdx.forEach((v, k) => {\r\n                characters[v] = k;\r\n            });\r\n            jsonObject[\"characters\"] = characters;\r\n\r\n            jsonObject[\"insertionCosts\"] = this._insertionCosts;\r\n            jsonObject[\"deletionCosts\"] = this._deletionCosts;\r\n            jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\r\n\r\n            return JSON.stringify(jsonObject);\r\n        }\r\n\r\n        /**\r\n         * Parse an Alphabet from a JSON serialization.\r\n         * @param json JSON string to deserialize\r\n         * @returns deserialized Alphabet\r\n         */\r\n        public static Deserialize<T>(json: string): Alphabet<T> {\r\n            let jsonObject = JSON.parse(json);\r\n            let alphabet = new Alphabet(jsonObject[\"characters\"] as T[]);\r\n            alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\r\n            alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\r\n            alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\r\n            return alphabet;\r\n        }\r\n\r\n        /**\r\n         * Create a new Alphabet.\r\n         * @param characters characters of the alphabet\r\n         * @param charToInsertionCost function mapping characters to insertion costs\r\n         * @param charToDeletionCost function mapping characters to deletion costs\r\n         * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n         */\r\n        public constructor(\r\n            characters: Array<T>,\r\n            charToInsertionCost: Nullable<(char: T) => number> = null,\r\n            charToDeletionCost: Nullable<(char: T) => number> = null,\r\n            charsToSubstitutionCost: Nullable<(outChar: T, inChar: T) => number> = null) {\r\n\r\n            charToInsertionCost = charToInsertionCost ?? (() => 1);\r\n            charToDeletionCost = charToDeletionCost ?? (() => 1);\r\n            charsToSubstitutionCost = charsToSubstitutionCost ?? ((a: T, b: T) => a === b ? 0 : 1);\r\n\r\n            this._characterToIdx = new Map<T, number>();\r\n            this._insertionCosts = new Array<number>(characters.length);\r\n            this._deletionCosts = new Array<number>(characters.length);\r\n            this._substitutionCosts = new Array<Array<number>>(characters.length);\r\n\r\n            let c: T;\r\n            for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\r\n                c = characters[outerIdx];\r\n                this._characterToIdx.set(c, outerIdx);\r\n                this._insertionCosts[outerIdx] = charToInsertionCost(c);\r\n                this._deletionCosts[outerIdx] = charToDeletionCost(c);\r\n\r\n                this._substitutionCosts[outerIdx] = new Array<number>(characters.length);\r\n                for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\r\n                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Get the index (internally-assigned number) for a character.\r\n         * @param char character\r\n         * @returns index\r\n         */\r\n        public getCharacterIdx(char: T): number {\r\n            return this._characterToIdx.get(char)!;\r\n        }\r\n\r\n        /**\r\n         * Get the insertion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns insertion cost\r\n         */\r\n        public getInsertionCost(idx: number): number {\r\n            return this._insertionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Get the deletion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns deletion cost\r\n         */\r\n        public getDeletionCost(idx: number): number {\r\n            return this._deletionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Gets the cost to substitute two characters. NOTE: this cost is\r\n         * required to be bi-directional, meaning it cannot matter which of\r\n         * the provided characters is being removed and which is being inserted.\r\n         * @param idx1 the first character index\r\n         * @param idx2 the second character index\r\n         * @returns substitution cost\r\n         */\r\n        public getSubstitutionCost(idx1: number, idx2: number): number {\r\n            let min = Math.min(idx1, idx2);\r\n            let max = Math.max(idx1, idx2);\r\n\r\n            return this._substitutionCosts[min][max];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Character sequence intended to be compared against other Sequences created\r\n     * with the same Alphabet in order to compute Levenshtein distance.\r\n     */\r\n    export class Sequence<T> {\r\n        private _alphabet: Alphabet<T>;\r\n        private _characters: number[];\r\n\r\n        // Scratch values\r\n        private static readonly MAX_SEQUENCE_LENGTH = 256;\r\n        private static _costMatrix =\r\n            [...Array(Sequence.MAX_SEQUENCE_LENGTH + 1)].map((n) => new Array<number>(Sequence.MAX_SEQUENCE_LENGTH + 1));\r\n        private static _insertionCost: number;\r\n        private static _deletionCost: number;\r\n        private static _substitutionCost: number;\r\n\r\n        /**\r\n         * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n         * from which this Sequence was created; Alphabet must be independently\r\n         * serialized.\r\n         * @returns JSON string\r\n         */\r\n        public serialize(): string {\r\n            return JSON.stringify(this._characters);\r\n        }\r\n\r\n        /**\r\n         * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n         * from which the Sequence was originally created, which must be serialized and\r\n         * deserialized independently so that it can be passed in here.\r\n         * @param json JSON string representation of Sequence\r\n         * @param alphabet Alphabet from which Sequence was originally created\r\n         * @returns Sequence\r\n         */\r\n        public static Deserialize<T>(json: string, alphabet: Alphabet<T>): Sequence<T> {\r\n            let sequence = new Sequence([], alphabet);\r\n            sequence._characters = JSON.parse(json);\r\n            return sequence;\r\n        }\r\n\r\n        /**\r\n         * Create a new Sequence.\r\n         * @param characters characters in the new Sequence\r\n         * @param alphabet Alphabet, which must include all used characters\r\n         */\r\n        public constructor(characters: T[], alphabet: Alphabet<T>) {\r\n            if (characters.length > Sequence.MAX_SEQUENCE_LENGTH) {\r\n                throw new Error(\"Sequences longer than \" + Sequence.MAX_SEQUENCE_LENGTH + \" not supported.\");\r\n            }\r\n            this._alphabet = alphabet;\r\n            this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));\r\n        }\r\n\r\n        /**\r\n         * Get the distance between this Sequence and another.\r\n         * @param other sequence to compare to\r\n         * @returns Levenshtein distance\r\n         */\r\n        public distance(other: Sequence<T>): number {\r\n            return Sequence._distance<T>(this, other);\r\n        }\r\n\r\n        /**\r\n         * Compute the Levenshtein distance between two Sequences.\r\n         * @param a first Sequence\r\n         * @param b second Sequence\r\n         * @returns Levenshtein distance\r\n         */\r\n        private static _distance<T>(a: Sequence<T>, b: Sequence<T>): number {\r\n            const alphabet = a._alphabet;\r\n            if (alphabet !== b._alphabet) {\r\n                throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\r\n            }\r\n            const aChars = a._characters;\r\n            const bChars = b._characters;\r\n            const aLength = aChars.length;\r\n            const bLength = bChars.length;\r\n\r\n            let costMatrix = Sequence._costMatrix;\r\n            costMatrix[0][0] = 0;\r\n            for (let idx = 0; idx < aLength; ++idx) {\r\n                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\r\n            }\r\n            for (let idx = 0; idx < bLength; ++idx) {\r\n                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\r\n            }\r\n\r\n            for (let aIdx = 0; aIdx < aLength; ++aIdx) {\r\n                for (let bIdx = 0; bIdx < bLength; ++bIdx) {\r\n                    Sequence._insertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\r\n                    Sequence._deletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\r\n                    Sequence._substitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\r\n\r\n                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(\r\n                        Sequence._insertionCost,\r\n                        Sequence._deletionCost,\r\n                        Sequence._substitutionCost);\r\n                }\r\n            }\r\n\r\n            return costMatrix[aLength][bLength];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\r\nexport class Trajectory {\r\n    private _points: Vector3[];\r\n    private readonly _segmentLength: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns serialized JSON string\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json serialized JSON string\r\n     * @returns deserialized Trajectory\r\n     */\r\n    public static Deserialize(json: string): Trajectory {\r\n        let jsonObject = JSON.parse(json);\r\n        let trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\r\n        trajectory._points = jsonObject[\"_points\"].map((pt: any) => {\r\n            return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\r\n        });\r\n        return trajectory;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty Trajectory.\r\n     * @param segmentLength radius of discretization for Trajectory points\r\n     */\r\n    public constructor(segmentLength: number = 0.01) {\r\n        this._points = [];\r\n        this._segmentLength = segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Get the length of the Trajectory.\r\n     * @returns length of the Trajectory\r\n     */\r\n    public getLength(): number {\r\n        return this._points.length * this._segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Append a new point to the Trajectory.\r\n     * NOTE: This implementation has many allocations.\r\n     * @param point point to append to the Trajectory\r\n     */\r\n    public add(point: DeepImmutable<Vector3>): void {\r\n        let numPoints = this._points.length;\r\n        if (numPoints === 0) {\r\n            this._points.push(point.clone());\r\n        } else {\r\n            const getT = () =>\r\n                this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\r\n            for (let t = getT(); t <= 1.0; t = getT()) {\r\n                let newPoint = this._points[numPoints - 1].scale(1.0 - t);\r\n                point.scaleAndAddToRef(t, newPoint);\r\n                this._points.push(newPoint);\r\n                ++numPoints;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new Trajectory with a segment length chosen to make it\r\n     * probable that the new Trajectory will have a specified number of\r\n     * segments. This operation is imprecise.\r\n     * @param targetResolution number of segments desired\r\n     * @returns new Trajectory with approximately the requested number of segments\r\n     */\r\n    public resampleAtTargetResolution(targetResolution: number): Trajectory {\r\n        var resampled = new Trajectory(this.getLength() / targetResolution);\r\n        this._points.forEach((pt) => {\r\n            resampled.add(pt);\r\n        });\r\n        return resampled;\r\n    }\r\n\r\n    /**\r\n     * Convert Trajectory segments into tokenized representation. This\r\n     * representation is an array of numbers where each nth number is the\r\n     * index of the token which is most similar to the nth segment of the\r\n     * Trajectory.\r\n     * @param tokens list of vectors which serve as discrete tokens\r\n     * @returns list of indices of most similar token per segment\r\n     */\r\n    public tokenize(tokens: DeepImmutable<Vector3[]>): number[] {\r\n        let tokenization: number[] = [];\r\n\r\n        let segmentDir = new Vector3();\r\n        for (let idx = 2; idx < this._points.length; ++idx) {\r\n            if (Trajectory._transformSegmentDirToRef(\r\n                    this._points[idx - 2],\r\n                    this._points[idx - 1],\r\n                    this._points[idx],\r\n                    segmentDir)) {\r\n\r\n                tokenization.push(Trajectory._tokenizeSegment(segmentDir, tokens));\r\n            }\r\n        }\r\n\r\n        return tokenization;\r\n    }\r\n\r\n    private static _forwardDir = new Vector3();\r\n    private static _inverseFromVec = new Vector3();\r\n    private static _upDir = new Vector3();\r\n    private static _fromToVec = new Vector3();\r\n    private static _lookMatrix = new Matrix();\r\n\r\n    /**\r\n     * Transform the rotation (i.e., direction) of a segment to isolate\r\n     * the relative transformation represented by the segment. This operation\r\n     * may or may not succeed due to singularities in the equations that define\r\n     * motion relativity in this context.\r\n     * @param priorVec the origin of the prior segment\r\n     * @param fromVec the origin of the current segment\r\n     * @param toVec the destination of the current segment\r\n     * @param result reference to output variable\r\n     * @returns whether or not transformation was successful\r\n     */\r\n    private static _transformSegmentDirToRef(\r\n        priorVec: DeepImmutable<Vector3>,\r\n        fromVec: DeepImmutable<Vector3>,\r\n        toVec: DeepImmutable<Vector3>,\r\n        result: Vector3): boolean {\r\n\r\n        const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\r\n\r\n        fromVec.subtractToRef(priorVec, Trajectory._forwardDir);\r\n        Trajectory._forwardDir.normalize();\r\n        fromVec.scaleToRef(-1, Trajectory._inverseFromVec);\r\n        Trajectory._inverseFromVec.normalize();\r\n\r\n        if (Math.abs(Vector3.Dot(Trajectory._forwardDir, Trajectory._inverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(Trajectory._forwardDir, Trajectory._inverseFromVec, Trajectory._upDir);\r\n        Trajectory._upDir.normalize();\r\n        Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._upDir, Trajectory._lookMatrix);\r\n        toVec.subtractToRef(fromVec, Trajectory._fromToVec);\r\n        Trajectory._fromToVec.normalize();\r\n        Vector3.TransformNormalToRef(Trajectory._fromToVec, Trajectory._lookMatrix, result);\r\n        return true;\r\n    }\r\n\r\n    private static _bestMatch: number;\r\n    private static _score: number;\r\n    private static _bestScore: number;\r\n\r\n    /**\r\n     * Determine which token vector is most similar to the\r\n     * segment vector.\r\n     * @param segment segment vector\r\n     * @param tokens token vector list\r\n     * @returns index of the most similar token to the segment\r\n     */\r\n    private static _tokenizeSegment(\r\n        segment: DeepImmutable<Vector3>,\r\n        tokens: DeepImmutable<Vector3[]>): number {\r\n\r\n        Trajectory._bestMatch = 0;\r\n        Trajectory._score = Vector3.Dot(segment, tokens[0]);\r\n        Trajectory._bestScore = Trajectory._score;\r\n        for (let idx = 1; idx < tokens.length; ++idx) {\r\n            Trajectory._score = Vector3.Dot(segment, tokens[idx]);\r\n            if (Trajectory._score > Trajectory._bestScore) {\r\n                Trajectory._bestMatch = idx;\r\n                Trajectory._bestScore = Trajectory._score;\r\n            }\r\n        }\r\n\r\n        return Trajectory._bestMatch;\r\n    }\r\n}\r\n\r\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\r\nclass Vector3Alphabet {\r\n\r\n    /**\r\n     * Characters in the alphabet.\r\n     * NOTE: There is no reason for this property to exist and this class should just extend\r\n     * Array<Vector3>, except that doing so produces bizarre build-time errors indicating that\r\n     * the ES5 library itself fails its own TypeDoc validation.\r\n     */\r\n    public chars: Vector3[];\r\n\r\n    /**\r\n     * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n     * optimize-from-random strategy to space points around the unit sphere\r\n     * surface as a simple alternative to really doing the math to tile the\r\n     * sphere.\r\n     * @param alphabetSize size of the desired alphabet\r\n     * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n     * @param startingStepSize distance factor to move points in early optimization iterations\r\n     * @param endingStepSize distance factor to move points in late optimization iterations\r\n     * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n     */\r\n    public static Generate(\r\n        alphabetSize: number = 64,\r\n        iterations: number = 256,\r\n        startingStepSize: number = 0.1,\r\n        endingStepSize: number = 0.001,\r\n        fixedValues: DeepImmutable<Vector3[]> = []): Vector3Alphabet {\r\n\r\n        const EPSILON = 0.001;\r\n        const EPSILON_SQUARED = EPSILON * EPSILON;\r\n\r\n        let alphabet = new Vector3Alphabet(alphabetSize);\r\n        for (let idx = 0; idx < alphabetSize; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(\r\n                Math.random() - 0.5,\r\n                Math.random() - 0.5,\r\n                Math.random() - 0.5);\r\n            alphabet.chars[idx].normalize();\r\n        }\r\n\r\n        for (let idx = 0; idx < fixedValues.length; ++idx) {\r\n            alphabet.chars[idx].copyFrom(fixedValues[idx]);\r\n        }\r\n\r\n        let stepSize: number;\r\n        let distSq: number;\r\n        let force = new Vector3();\r\n        let scratch = new Vector3();\r\n        const lerp = (l: number, r: number, t: number) => (1.0 - t) * l + t * r;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\r\n            for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\r\n                force.copyFromFloats(0, 0, 0);\r\n                alphabet.chars.forEach((pt) => {\r\n                    alphabet.chars[idx].subtractToRef(pt, scratch);\r\n                    distSq = scratch.lengthSquared();\r\n                    if (distSq > EPSILON_SQUARED) {\r\n                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\r\n                    }\r\n                });\r\n                force.scaleInPlace(stepSize);\r\n                alphabet.chars[idx].addInPlace(force);\r\n                alphabet.chars[idx].normalize();\r\n            }\r\n        }\r\n\r\n        return alphabet;\r\n    }\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this.chars);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized Vector3Alphabet\r\n     */\r\n    public static Deserialize(json: string): Vector3Alphabet {\r\n        let jsonObject = JSON.parse(json);\r\n        let alphabet = new Vector3Alphabet(jsonObject.length);\r\n        for (let idx = 0; idx < jsonObject.length; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(\r\n                jsonObject[idx][\"_x\"],\r\n                jsonObject[idx][\"_y\"],\r\n                jsonObject[idx][\"_z\"]);\r\n        }\r\n        return alphabet;\r\n    }\r\n\r\n    private constructor(size: number) {\r\n        this.chars = new Array(size);\r\n    }\r\n}\r\n\r\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\r\nclass TrajectoryDescriptor {\r\n    private static readonly FINEST_DESCRIPTOR_RESOLUTION = 32;\r\n\r\n    private _sequences: Levenshtein.Sequence<number>[];\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptor was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON serialization\r\n     * @param alphabet Alphabet from which descriptor was originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        let descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences =\r\n            (JSON.parse(json) as string[]).map(\r\n                (s) => Levenshtein.Sequence.Deserialize(s, alphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n     * to the provided alphabets.\r\n     * @param trajectory Trajectory to be described\r\n     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing provided Trajectory\r\n     */\r\n    public static CreateFromTrajectory(\r\n        trajectory: Trajectory,\r\n        vector3Alphabet: Vector3Alphabet,\r\n        levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n\r\n        return TrajectoryDescriptor.CreateFromTokenizationPyramid(\r\n            TrajectoryDescriptor._getTokenizationPyramid(trajectory, vector3Alphabet),\r\n            levenshteinAlphabet);\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n     * NOTE: This function exists to support an outdated serialization mechanism and should\r\n     * be deleted if it is no longer useful.\r\n     * @param pyramid tokenization pyramid\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n     */\r\n    public static CreateFromTokenizationPyramid(\r\n        pyramid: number[][],\r\n        levenshteinAlphabet: Levenshtein.Alphabet<number>) : TrajectoryDescriptor {\r\n\r\n        let descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence<number>(tokens, levenshteinAlphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    private constructor() {\r\n        this._sequences = [];\r\n    }\r\n\r\n    /**\r\n     * Create the tokenization pyramid for the provided Trajectory according to the given\r\n     * Vector3Alphabet.\r\n     * @param trajectory Trajectory to be tokenized\r\n     * @param alphabet Vector3Alphabet containing tokens\r\n     * @param targetResolution finest resolution of descriptor\r\n     * @returns tokenization pyramid for Trajectory\r\n     */\r\n    private static _getTokenizationPyramid(\r\n        trajectory: Trajectory,\r\n        alphabet: Vector3Alphabet,\r\n        targetResolution: number = TrajectoryDescriptor.FINEST_DESCRIPTOR_RESOLUTION): number[][] {\r\n\r\n        let pyramid: number[][] = [];\r\n        for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\r\n            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\r\n        }\r\n        return pyramid;\r\n    }\r\n\r\n    /**\r\n     * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n     * essentially a similarity score and does not directly represent Euclidean distance,\r\n     * edit distance, or any other formal distance metric.\r\n     * @param other TrajectoryDescriptor from which to determine distance\r\n     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n     */\r\n    public distance(other: TrajectoryDescriptor): number {\r\n        let totalDistance = 0;\r\n        let weight: number;\r\n        for (let idx = 0; idx < this._sequences.length; ++idx) {\r\n            weight = Math.pow(2, idx);\r\n            totalDistance += (weight * this._sequences[idx].distance(other._sequences[idx]));\r\n        }\r\n        return totalDistance;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\r\nclass TrajectoryClass {\r\n    private static readonly MIN_AVERAGE_DISTANCE = 1;\r\n\r\n    private _descriptors: TrajectoryDescriptor[];\r\n    private _centroidIdx: number;\r\n    private _averageDistance: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        let jsonObject: any = {};\r\n        jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());\r\n        jsonObject.centroidIdx = this._centroidIdx;\r\n        jsonObject.averageDistance = this._averageDistance;\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptors were originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation\r\n     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryClass {\r\n        let jsonObject = JSON.parse(json);\r\n        let described = new TrajectoryClass();\r\n        described._descriptors = jsonObject.descriptors.map((s: string) => TrajectoryDescriptor.Deserialize(s, alphabet));\r\n        described._centroidIdx = jsonObject.centroidIdx;\r\n        described._averageDistance = jsonObject.averageDistance;\r\n        return described;\r\n    }\r\n\r\n    /**\r\n     * Create a new DescribedTrajectory.\r\n     * @param descriptors currently-known TrajectoryDescriptors, if any\r\n     */\r\n    public constructor(descriptors: TrajectoryDescriptor[] = []) {\r\n        this._descriptors = descriptors;\r\n        this._centroidIdx = -1;\r\n        this._averageDistance = 0;\r\n\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n     * this same DescribedTrajectory.\r\n     * @param descriptor descriptor to be added\r\n     */\r\n    public add(descriptor: TrajectoryDescriptor): void {\r\n        this._descriptors.push(descriptor);\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Compute the cost, which is inversely related to the likelihood that the provided\r\n     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n     * the class represented by this DescribedTrajectory.\r\n     * @param descriptor the descriptor to be costed\r\n     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimiliarity\r\n     */\r\n    public getMatchCost(descriptor: TrajectoryDescriptor): number {\r\n        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n     * descriptor which is a member of this collection. This is an alternative way of\r\n     * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n     * @param descriptor the descriptor to find the minimum distance to\r\n     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n     */\r\n    public getMatchMinimumDistance(descriptor: TrajectoryDescriptor): number {\r\n        return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the internal representation of this DescribedTrajectory.\r\n     */\r\n    private _refreshDescription(): void {\r\n\r\n        this._centroidIdx = -1;\r\n        let sum: number;\r\n        let distances = this._descriptors.map((a) => {\r\n            sum = 0;\r\n            this._descriptors.forEach((b) => {\r\n                sum += a.distance(b);\r\n            });\r\n            return sum;\r\n        });\r\n        for (let idx = 0; idx < distances.length; ++idx) {\r\n            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\r\n                this._centroidIdx = idx;\r\n            }\r\n        }\r\n\r\n        this._averageDistance = 0;\r\n        this._descriptors.forEach((desc) => {\r\n            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\r\n        });\r\n        if (this._descriptors.length > 0) {\r\n            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass.MIN_AVERAGE_DISTANCE);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\r\nexport class TrajectoryClassifier {\r\n    private _maximumAllowableMatchCost: number = 4;\r\n    private _vector3Alphabet: Vector3Alphabet;\r\n    private _levenshteinAlphabet: Levenshtein.Alphabet<number>;\r\n    private _nameToDescribedTrajectory: Map<string, TrajectoryClass>;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        let jsonObject: any = {};\r\n        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\r\n        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\r\n        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\r\n        jsonObject.nameToDescribedTrajectory = [];\r\n        this._nameToDescribedTrajectory.forEach((described, name) => {\r\n            jsonObject.nameToDescribedTrajectory.push(name);\r\n            jsonObject.nameToDescribedTrajectory.push(described.serialize());\r\n        });\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized TrajectorySet\r\n     */\r\n    public static Deserialize(json: string): TrajectoryClassifier {\r\n        let jsonObject = JSON.parse(json);\r\n        let classifier = new TrajectoryClassifier();\r\n        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\r\n        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\r\n        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize<number>(jsonObject.levenshteinAlphabet);\r\n        for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\r\n            classifier._nameToDescribedTrajectory.set(\r\n                jsonObject.nameToDescribedTrajectory[idx],\r\n                TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\r\n        }\r\n        return classifier;\r\n    }\r\n\r\n    /**\r\n     * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n     * VERY naive, need to be generating these things from known\r\n     * sets. Better version later, probably eliminating this one.\r\n     * @returns auto-generated TrajectorySet\r\n     */\r\n    public static Generate(): TrajectoryClassifier {\r\n        let vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\r\n\r\n        const charIdxs = new Array(vecs.chars.length);\r\n        for (let idx = 0; idx < charIdxs.length; ++idx) {\r\n            charIdxs[idx] = idx;\r\n        }\r\n\r\n        let alphabet = new Levenshtein.Alphabet<number>(\r\n            charIdxs,\r\n            (idx) => idx === 0 ? 0 : 1,\r\n            (idx) => idx === 0 ? 0 : 1,\r\n            (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));\r\n\r\n        let trajectorySet = new TrajectoryClassifier();\r\n        trajectorySet._vector3Alphabet = vecs;\r\n        trajectorySet._levenshteinAlphabet = alphabet;\r\n        return trajectorySet;\r\n    }\r\n\r\n    private constructor() {\r\n        this._nameToDescribedTrajectory = new Map<string, TrajectoryClass>();\r\n    }\r\n\r\n    /**\r\n     * Add a new Trajectory to the set with a given name.\r\n     * @param trajectory new Trajectory to be added\r\n     * @param classification name to which to add the Trajectory\r\n     */\r\n    public addTrajectoryToClassification(trajectory: Trajectory, classification: string): void {\r\n        if (!this._nameToDescribedTrajectory.has(classification)) {\r\n            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\r\n        }\r\n\r\n        this._nameToDescribedTrajectory.get(classification)!.add(\r\n            TrajectoryDescriptor.CreateFromTrajectory(\r\n                trajectory,\r\n                this._vector3Alphabet,\r\n                this._levenshteinAlphabet));\r\n    }\r\n\r\n    /**\r\n     * Remove a known named trajectory and all Trajectories associated with it.\r\n     * @param classification name to remove\r\n     * @returns whether anything was removed\r\n     */\r\n    public deleteClassification(classification: string): boolean {\r\n        return this._nameToDescribedTrajectory.delete(classification);\r\n    }\r\n\r\n    /**\r\n     * Attempt to recognize a Trajectory from among all the classifications\r\n     * already known to the classifier.\r\n     * @param trajectory Trajectory to be recognized\r\n     * @returns classification of Trajectory if recognized, null otherwise\r\n     */\r\n    public classifyTrajectory(trajectory: Trajectory): Nullable<string> {\r\n        let descriptor = TrajectoryDescriptor.CreateFromTrajectory(\r\n            trajectory,\r\n            this._vector3Alphabet,\r\n            this._levenshteinAlphabet);\r\n\r\n        let allowableMatches: string[] = [];\r\n        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\r\n            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\r\n                allowableMatches.push(classification);\r\n            }\r\n        });\r\n\r\n        if (allowableMatches.length === 0) {\r\n\r\n            return null;\r\n        }\r\n\r\n        let bestIdx = 0;\r\n        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx])!.getMatchMinimumDistance(descriptor);\r\n        let match: number;\r\n        for (let idx = 0; idx < allowableMatches.length; ++idx) {\r\n            match = this._nameToDescribedTrajectory.get(allowableMatches[idx])!.getMatchMinimumDistance(descriptor);\r\n            if (match < bestMatch) {\r\n                bestMatch = match;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        return allowableMatches[bestIdx];\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}