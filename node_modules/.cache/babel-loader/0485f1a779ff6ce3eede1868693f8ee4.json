{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { Observable } from \"../Misc/observable\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { HemisphericLight } from '../Lights/hemisphericLight';\nimport { Vector3 } from '../Maths/math.vector';\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * Renders a layer on top of an existing scene\r\n */\n\nvar UtilityLayerRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a UtilityLayerRenderer\r\n   * @param originalScene the original scene that will be rendered on top of\r\n   * @param handleEvents boolean indicating if the utility layer should handle events\r\n   */\n  function UtilityLayerRenderer(\n  /** the original scene that will be rendered on top of */\n  originalScene, handleEvents) {\n    var _this = this;\n\n    if (handleEvents === void 0) {\n      handleEvents = true;\n    }\n\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\n\n    this.pickUtilitySceneFirst = true;\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n    */\n\n    this.shouldRender = true;\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\n\n    this.onlyCheckPointerDownEvents = true;\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\n\n    this.processAllEvents = false;\n    /**\r\n     * Observable raised when the pointer move from the utility layer scene to the main scene\r\n     */\n\n    this.onPointerOutObservable = new Observable(); // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false; // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n\n    this.utilityLayerScene.detachControl();\n\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(function (prePointerInfo, eventState) {\n        if (!_this.utilityLayerScene.activeCamera) {\n          return;\n        }\n\n        if (!_this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n\n        _this.utilityLayerScene.pointerX = originalScene.pointerX;\n        _this.utilityLayerScene.pointerY = originalScene.pointerY;\n        var pointerEvent = prePointerInfo.event;\n\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          _this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n\n        var utilityScenePick = prePointerInfo.ray ? _this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : _this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);\n\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        } // always fire the prepointer oversvable\n\n\n        _this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo); // allow every non pointer down event to flow to the utility layer\n\n\n        if (_this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent.pointerId]) {\n            _this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n\n          return;\n        }\n\n        if (_this.utilityLayerScene.autoClearDepthAndStencil || _this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);\n          var pointerEvent_1 = prePointerInfo.event; // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                _this._pointerCaptures[pointerEvent_1.pointerId] = true;\n              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1); // If a previous utility layer set this, do not unset this\n\n\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && utilityScenePick.distance > originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n\n                delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n              }\n            }\n\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent_1.pointerId]) {\n              _this._pointerCaptures[pointerEvent_1.pointerId] = false;\n            }\n          }\n        }\n      }); // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    } // Render directly on top of existing scene without clearing\n\n\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add(function (camera) {\n      // Only render when the render camera finishes rendering\n      if (_this.shouldRender && camera == _this.getRenderCamera()) {\n        _this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function () {\n      _this.dispose();\n    });\n\n    this._updateCamera();\n  }\n  /**\r\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n   * @returns the camera that is used when rendering the utility layer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.getRenderCamera = function (getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      var activeCam = void 0;\n\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n\n      return activeCam;\n    }\n  };\n  /**\r\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n   * @param cam the camera that should be used when rendering the utility layer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.setRenderCamera = function (cam) {\n    this._renderCamera = cam;\n  };\n  /**\r\n   * @hidden\r\n   * Light which used by gizmos to get light shading\r\n   */\n\n\n  UtilityLayerRenderer.prototype._getSharedGizmoLight = function () {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n\n    return this._sharedGizmoLight;\n  };\n\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultUtilityLayer\", {\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\n    get: function () {\n      if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          UtilityLayerRenderer._DefaultUtilityLayer = null;\n        });\n      }\n\n      return UtilityLayerRenderer._DefaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(UtilityLayerRenderer, \"DefaultKeepDepthUtilityLayer\", {\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\n    get: function () {\n      if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n        });\n      }\n\n      return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  UtilityLayerRenderer.prototype._notifyObservers = function (prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  };\n  /**\r\n   * Renders the utility layers scene on top of the original scene\r\n   */\n\n\n  UtilityLayerRenderer.prototype.render = function () {\n    this._updateCamera();\n\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      var oldScene = this.utilityLayerScene.activeCamera.getScene();\n      var camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n\n      this.utilityLayerScene.render(false); // Reset camera's scene back to original\n\n      camera._scene = oldScene;\n\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  };\n  /**\r\n   * Disposes of the renderer\r\n   */\n\n\n  UtilityLayerRenderer.prototype.dispose = function () {\n    this.onPointerOutObservable.clear();\n\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n\n    this.utilityLayerScene.dispose();\n  };\n\n  UtilityLayerRenderer.prototype._updateCamera = function () {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  };\n\n  UtilityLayerRenderer._DefaultUtilityLayer = null;\n  UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n  return UtilityLayerRenderer;\n}();\n\nexport { UtilityLayerRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/utilityLayerRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from '../Lights/hemisphericLight';\r\nimport { Vector3 } from '../Maths/math.vector';\r\nimport { Camera } from '../Cameras/camera';\r\nimport { Color3 } from '../Maths/math.color';\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    private static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>(this.originalScene.activeCamera!);\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n    */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Observable raised when the pointer move from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo, eventState) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.processAllEvents) {\r\n                    if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERUP\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERDOWN\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                var utilityScenePick = prePointerInfo.ray ? this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer oversvable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                    let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance > originalScenePick.distance)) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: PointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            var oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            var camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}