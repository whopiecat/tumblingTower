{"ast":null,"code":"import { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/outline.fragment\";\nimport \"../Shaders/outline.vertex\";\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\n\nScene.prototype.getOutlineRenderer = function () {\n  if (!this._outlineRenderer) {\n    this._outlineRenderer = new OutlineRenderer(this);\n  }\n\n  return this._outlineRenderer;\n};\n\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n  get: function () {\n    return this._renderOutline;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOutline = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n  get: function () {\n    return this._renderOverlay;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n\n    this._renderOverlay = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * This class is responsible to draw bothe outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\n\nvar OutlineRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new outline renderer. (There could be only one per scene).\r\n   * @param scene Defines the scene it belongs to\r\n   */\n  function OutlineRenderer(scene) {\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\n    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n    /**\r\n     * Defines a zOffset to prevent zFighting between the overlay and the mesh.\r\n     */\n\n    this.zOffset = 1;\n    this.scene = scene;\n    this._engine = scene.getEngine();\n\n    this.scene._addComponent(this);\n  }\n  /**\r\n   * Register the component to one instance of a scene.\r\n   */\n\n\n  OutlineRenderer.prototype.register = function () {\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  OutlineRenderer.prototype.rebuild = function () {// Nothing to do here.\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  OutlineRenderer.prototype.dispose = function () {// Nothing to do here.\n  };\n  /**\r\n   * Renders the outline in the canvas.\r\n   * @param subMesh Defines the sumesh to render\r\n   * @param batch Defines the batch of meshes in case of instances\r\n   * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n   */\n\n\n  OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay) {\n    var _this = this;\n\n    if (useOverlay === void 0) {\n      useOverlay = false;\n    }\n\n    var scene = this.scene;\n    var engine = scene.getEngine();\n    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\n\n    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n      return;\n    }\n\n    var ownerMesh = subMesh.getMesh();\n    var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n    var renderingMesh = subMesh.getRenderingMesh();\n    var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n    var material = subMesh.getMaterial();\n\n    if (!material || !scene.activeCamera) {\n      return;\n    }\n\n    engine.enableEffect(this._effect); // Logarithmic depth\n\n    if (material.useLogarithmicDepth) {\n      this._effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n\n    this._effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n\n    this._effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n\n    this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n    this._effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix()); // Bones\n\n\n    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n      this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n    } // Morph targets\n\n\n    MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);\n\n    renderingMesh._bind(subMesh, this._effect, material.fillMode); // Alpha test\n\n\n    if (material && material.needAlphaTesting()) {\n      var alphaTexture = material.getAlphaTestTexture();\n\n      if (alphaTexture) {\n        this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n        this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n      }\n    }\n\n    engine.setZOffset(-this.zOffset);\n\n    renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n      _this._effect.setMatrix(\"world\", world);\n    });\n\n    engine.setZOffset(0);\n  };\n  /**\r\n   * Returns whether or not the outline renderer is ready for a given submesh.\r\n   * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n   * @param subMesh Defines the submesh to check readyness for\r\n   * @param useInstances Defines wheter wee are trying to render instances or not\r\n   * @returns true if ready otherwise false\r\n   */\n\n\n  OutlineRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    var mesh = subMesh.getMesh();\n    var material = subMesh.getMaterial();\n\n    if (material) {\n      // Alpha test\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      } //Logarithmic depth\n\n\n      if (material.useLogarithmicDepth) {\n        defines.push(\"#define LOGARITHMICDEPTH\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this.scene.getEngine().createEffect(\"outline\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n\n  OutlineRenderer.prototype._beforeRenderingMesh = function (mesh, subMesh, batch) {\n    // Outline - step 1\n    this._savedDepthWrite = this._engine.getDepthWrite();\n\n    if (mesh.renderOutline) {\n      var material = subMesh.getMaterial();\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.cacheStencilState(); // Draw only to stencil buffer for the original mesh\n        // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n\n\n        this._engine.setDepthWrite(false);\n\n        this._engine.setColorWrite(false);\n\n        this._engine.setStencilBuffer(true);\n\n        this._engine.setStencilOperationPass(7681);\n\n        this._engine.setStencilFunction(519);\n\n        this._engine.setStencilMask(OutlineRenderer._StencilReference);\n\n        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n\n        this.render(subMesh, batch,\n        /* This sets offset to 0 */\n        true);\n\n        this._engine.setColorWrite(true);\n\n        this._engine.setStencilFunction(517);\n      } // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n\n\n      this._engine.setDepthWrite(false);\n\n      this.render(subMesh, batch);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.restoreStencilState();\n      }\n    }\n  };\n\n  OutlineRenderer.prototype._afterRenderingMesh = function (mesh, subMesh, batch) {\n    // Overlay\n    if (mesh.renderOverlay) {\n      var currentMode = this._engine.getAlphaMode();\n\n      var alphaBlendState = this._engine.alphaState.alphaBlend;\n\n      this._engine.setAlphaMode(2);\n\n      this.render(subMesh, batch, true);\n\n      this._engine.setAlphaMode(currentMode);\n\n      this._engine.setDepthWrite(this._savedDepthWrite);\n\n      this._engine.alphaState.alphaBlend = alphaBlendState;\n    } // Outline - step 2\n\n\n    if (mesh.renderOutline && this._savedDepthWrite) {\n      this._engine.setDepthWrite(true);\n\n      this._engine.setColorWrite(false);\n\n      this.render(subMesh, batch);\n\n      this._engine.setColorWrite(true);\n    }\n  };\n  /**\r\n   * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n   */\n\n\n  OutlineRenderer._StencilReference = 0x04;\n  return OutlineRenderer;\n}();\n\nexport { OutlineRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/outlineRenderer.ts"],"names":[],"mappings":"AAAA,SAAS,YAAT,QAA6B,kBAA7B;AAEA,SAA0B,IAA1B,QAAsC,gBAAtC;AACA,SAAS,KAAT,QAAsB,UAAtB;AAGA,SAA0B,uBAA1B,QAAyD,mBAAzD;AAEA,SAAS,cAAT,QAA+B,6BAA/B;AAEA,OAAO,6BAAP;AACA,OAAO,2BAAP;AAeA;;;;;AAIA,KAAK,CAAC,SAAN,CAAgB,kBAAhB,GAAqC,YAAA;AACjC,MAAI,CAAC,KAAK,gBAAV,EAA4B;AACxB,SAAK,gBAAL,GAAwB,IAAI,eAAJ,CAAoB,IAApB,CAAxB;AACH;;AACD,SAAO,KAAK,gBAAZ;AACH,CALD;;AA2BA,MAAM,CAAC,cAAP,CAAsB,IAAI,CAAC,SAA3B,EAAsC,eAAtC,EAAuD;AACnD,EAAA,GAAG,EAAE,YAAA;AACD,WAAO,KAAK,cAAZ;AACH,GAHkD;AAInD,EAAA,GAAG,EAAE,UAAqB,KAArB,EAAmC;AACpC,QAAI,KAAJ,EAAW;AACP;AACA,WAAK,QAAL,GAAgB,kBAAhB;AACH;;AACD,SAAK,cAAL,GAAsB,KAAtB;AACH,GAVkD;AAWnD,EAAA,UAAU,EAAE,IAXuC;AAYnD,EAAA,YAAY,EAAE;AAZqC,CAAvD;AAeA,MAAM,CAAC,cAAP,CAAsB,IAAI,CAAC,SAA3B,EAAsC,eAAtC,EAAuD;AACnD,EAAA,GAAG,EAAE,YAAA;AACD,WAAO,KAAK,cAAZ;AACH,GAHkD;AAInD,EAAA,GAAG,EAAE,UAAqB,KAArB,EAAmC;AACpC,QAAI,KAAJ,EAAW;AACP;AACA,WAAK,QAAL,GAAgB,kBAAhB;AACH;;AACD,SAAK,cAAL,GAAsB,KAAtB;AACH,GAVkD;AAWnD,EAAA,UAAU,EAAE,IAXuC;AAYnD,EAAA,YAAY,EAAE;AAZqC,CAAvD;AAeA;;;;;AAIA,IAAA,eAAA;AAAA;AAAA,YAAA;AAyBI;;;;AAIA,WAAA,eAAA,CAAY,KAAZ,EAAwB;AAxBxB;;;AAGO,SAAA,IAAA,GAAO,uBAAuB,CAAC,oBAA/B;AAOP;;;;AAGO,SAAA,OAAA,GAAU,CAAV;AAYH,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,OAAL,GAAe,KAAK,CAAC,SAAN,EAAf;;AACA,SAAK,KAAL,CAAW,aAAX,CAAyB,IAAzB;AACH;AAED;;;;;AAGO,EAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,SAAK,KAAL,CAAW,yBAAX,CAAqC,YAArC,CAAkD,uBAAuB,CAAC,gCAA1E,EAA4G,IAA5G,EAAkH,KAAK,oBAAvH;;AACA,SAAK,KAAL,CAAW,wBAAX,CAAoC,YAApC,CAAiD,uBAAuB,CAAC,+BAAzE,EAA0G,IAA1G,EAAgH,KAAK,mBAArH;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACI;AACH,GAFM;AAIP;;;;;AAGO,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACI;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,eAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,OAAd,EAAgC,KAAhC,EAAwD,UAAxD,EAAmF;AAAnF,QAAA,KAAA,GAAA,IAAA;;AAAwD,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAA,KAAA;AAA2B;;AAC/E,QAAI,KAAK,GAAG,KAAK,KAAjB;AACA,QAAI,MAAM,GAAG,KAAK,CAAC,SAAN,EAAb;AAEA,QAAI,0BAA0B,GAAI,MAAM,CAAC,OAAP,GAAiB,eAAlB,KAAuC,KAAK,CAAC,gBAAN,CAAuB,OAAO,CAAC,GAA/B,MAAwC,IAAxC,IAAgD,KAAK,CAAC,gBAAN,CAAuB,OAAO,CAAC,GAA/B,MAAwC,SAAxF,IAAqG,OAAO,CAAC,gBAAR,GAA2B,gBAAvK,CAAjC;;AAEA,QAAI,CAAC,KAAK,OAAL,CAAa,OAAb,EAAsB,0BAAtB,CAAL,EAAwD;AACpD;AACH;;AAED,QAAI,SAAS,GAAG,OAAO,CAAC,OAAR,EAAhB;AACA,QAAI,eAAe,GAAG,SAAS,CAAC,6BAAV,CAAwC,iBAAxC,GAA4D,SAA5D,GAAwE,IAA9F;AACA,QAAI,aAAa,GAAG,OAAO,CAAC,gBAAR,EAApB;AACA,QAAI,aAAa,GAAG,eAAe,GAAG,eAAH,GAAqB,aAAxD;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,WAAR,EAAf;;AAEA,QAAI,CAAC,QAAD,IAAa,CAAC,KAAK,CAAC,YAAxB,EAAsC;AAClC;AACH;;AAED,IAAA,MAAM,CAAC,YAAP,CAAoB,KAAK,OAAzB,EApB+E,CAsB/E;;AACA,QAAU,QAAS,CAAC,mBAApB,EAAyC;AACrC,WAAK,OAAL,CAAa,QAAb,CAAsB,0BAAtB,EAAkD,OAAO,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,YAAN,CAAmB,IAAnB,GAA0B,GAAnC,IAA0C,IAAI,CAAC,GAAtD,CAAlD;AACH;;AAED,SAAK,OAAL,CAAa,QAAb,CAAsB,QAAtB,EAAgC,UAAU,GAAG,CAAH,GAAO,aAAa,CAAC,YAA/D;;AACA,SAAK,OAAL,CAAa,SAAb,CAAuB,OAAvB,EAAgC,UAAU,GAAG,aAAa,CAAC,YAAjB,GAAgC,aAAa,CAAC,YAAxF,EAAsG,UAAU,GAAG,aAAa,CAAC,YAAjB,GAAgC,QAAQ,CAAC,KAAzJ;;AACA,SAAK,OAAL,CAAa,SAAb,CAAuB,gBAAvB,EAAyC,KAAK,CAAC,kBAAN,EAAzC;;AACA,SAAK,OAAL,CAAa,SAAb,CAAuB,OAAvB,EAAgC,aAAa,CAAC,cAAd,EAAhC,EA9B+E,CAgC/E;;;AACA,QAAI,aAAa,CAAC,QAAd,IAA0B,aAAa,CAAC,wBAAxC,IAAoE,aAAa,CAAC,QAAtF,EAAgG;AAC5F,WAAK,OAAL,CAAa,WAAb,CAAyB,QAAzB,EAAmC,aAAa,CAAC,QAAd,CAAuB,oBAAvB,CAA4C,aAA5C,CAAnC;AACH,KAnC8E,CAqC/E;;;AACA,IAAA,cAAc,CAAC,yBAAf,CAAyC,aAAzC,EAAwD,KAAK,OAA7D;;AAEA,IAAA,aAAa,CAAC,KAAd,CAAoB,OAApB,EAA6B,KAAK,OAAlC,EAA2C,QAAQ,CAAC,QAApD,EAxC+E,CA0C/E;;;AACA,QAAI,QAAQ,IAAI,QAAQ,CAAC,gBAAT,EAAhB,EAA6C;AACzC,UAAI,YAAY,GAAG,QAAQ,CAAC,mBAAT,EAAnB;;AACA,UAAI,YAAJ,EAAkB;AACd,aAAK,OAAL,CAAa,UAAb,CAAwB,gBAAxB,EAA0C,YAA1C;;AACA,aAAK,OAAL,CAAa,SAAb,CAAuB,eAAvB,EAAwC,YAAY,CAAC,gBAAb,EAAxC;AACH;AACJ;;AAED,IAAA,MAAM,CAAC,UAAP,CAAkB,CAAC,KAAK,OAAxB;;AACA,IAAA,aAAa,CAAC,iBAAd,CAAgC,aAAhC,EAA+C,OAA/C,EAAwD,KAAK,OAA7D,EAAsE,QAAQ,CAAC,QAA/E,EAAyF,KAAzF,EAAgG,0BAAhG,EACI,UAAC,UAAD,EAAa,KAAb,EAAkB;AAAO,MAAA,KAAI,CAAC,OAAL,CAAa,SAAb,CAAuB,OAAvB,EAAgC,KAAhC;AAAyC,KADtE;;AAGA,IAAA,MAAM,CAAC,UAAP,CAAkB,CAAlB;AACH,GAxDM;AA0DP;;;;;;;;;AAOO,EAAA,eAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,OAAf,EAAiC,YAAjC,EAAsD;AAClD,QAAI,OAAO,GAAG,EAAd;AACA,QAAI,OAAO,GAAG,CAAC,YAAY,CAAC,YAAd,EAA4B,YAAY,CAAC,UAAzC,CAAd;AAEA,QAAI,IAAI,GAAG,OAAO,CAAC,OAAR,EAAX;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,WAAR,EAAf;;AAEA,QAAI,QAAJ,EAAc;AACV;AACA,UAAI,QAAQ,CAAC,gBAAT,EAAJ,EAAiC;AAC7B,QAAA,OAAO,CAAC,IAAR,CAAa,mBAAb;;AACA,YAAI,IAAI,CAAC,qBAAL,CAA2B,YAAY,CAAC,MAAxC,CAAJ,EAAqD;AACjD,UAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,MAA1B;AACA,UAAA,OAAO,CAAC,IAAR,CAAa,aAAb;AACH;;AACD,YAAI,IAAI,CAAC,qBAAL,CAA2B,YAAY,CAAC,OAAxC,CAAJ,EAAsD;AAClD,UAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,OAA1B;AACA,UAAA,OAAO,CAAC,IAAR,CAAa,aAAb;AACH;AACJ,OAZS,CAaV;;;AACA,UAAU,QAAS,CAAC,mBAApB,EAAyC;AACrC,QAAA,OAAO,CAAC,IAAR,CAAa,0BAAb;AACH;AACJ,KAxBiD,CAyBlD;;;AACA,QAAI,IAAI,CAAC,QAAL,IAAiB,IAAI,CAAC,wBAA1B,EAAoD;AAChD,MAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,mBAA1B;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,mBAA1B;;AACA,UAAI,IAAI,CAAC,kBAAL,GAA0B,CAA9B,EAAiC;AAC7B,QAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,wBAA1B;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,YAAY,CAAC,wBAA1B;AACH;;AACD,MAAA,OAAO,CAAC,IAAR,CAAa,kCAAkC,IAAI,CAAC,kBAApD;AACA,MAAA,OAAO,CAAC,IAAR,CAAa,2BAA2B,IAAI,CAAC,QAAL,GAAgB,IAAI,CAAC,QAAL,CAAc,KAAd,CAAoB,MAApB,GAA6B,CAA7C,GAAiD,CAA5E,CAAb;AACH,KATD,MASO;AACH,MAAA,OAAO,CAAC,IAAR,CAAa,gCAAb;AACH,KArCiD,CAuClD;;;AACA,QAAM,kBAAkB,GAAI,IAAa,CAAC,kBAA1C;AACA,QAAI,mBAAmB,GAAG,CAA1B;;AACA,QAAI,kBAAJ,EAAwB;AACpB,UAAI,kBAAkB,CAAC,cAAnB,GAAoC,CAAxC,EAA2C;AACvC,QAAA,mBAAmB,GAAG,kBAAkB,CAAC,cAAzC;AAEA,QAAA,OAAO,CAAC,IAAR,CAAa,sBAAb;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,mCAAmC,mBAAhD;AAEA,QAAA,cAAc,CAAC,2CAAf,CAA2D,OAA3D,EAAoE,IAApE,EAA0E,mBAA1E;AACH;AACJ,KAnDiD,CAqDlD;;;AACA,QAAI,YAAJ,EAAkB;AACd,MAAA,OAAO,CAAC,IAAR,CAAa,mBAAb;AACA,MAAA,cAAc,CAAC,0BAAf,CAA0C,OAA1C;;AACA,UAAI,OAAO,CAAC,gBAAR,GAA2B,gBAA/B,EAAiD;AAC7C,QAAA,OAAO,CAAC,IAAR,CAAa,wBAAb;AACH;AACJ,KA5DiD,CA8DlD;;;AACA,QAAI,IAAI,GAAG,OAAO,CAAC,IAAR,CAAa,IAAb,CAAX;;AACA,QAAI,KAAK,cAAL,KAAwB,IAA5B,EAAkC;AAC9B,WAAK,cAAL,GAAsB,IAAtB;AACA,WAAK,OAAL,GAAe,KAAK,KAAL,CAAW,SAAX,GAAuB,YAAvB,CAAoC,SAApC,EACX,OADW,EAEX,CAAC,OAAD,EAAU,QAAV,EAAoB,gBAApB,EAAsC,eAAtC,EAAuD,QAAvD,EAAiE,OAAjE,EAA0E,0BAA1E,EAAsG,uBAAtG,CAFW,EAGX,CAAC,gBAAD,CAHW,EAGS,IAHT,EAIX,SAJW,EAIA,SAJA,EAIW,SAJX,EAKX;AAAE,QAAA,2BAA2B,EAAE;AAA/B,OALW,CAAf;AAMH;;AAED,WAAO,KAAK,OAAL,CAAa,OAAb,EAAP;AACH,GA3EM;;AA6EC,EAAA,eAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,IAA7B,EAAyC,OAAzC,EAA2D,KAA3D,EAAiF;AAC7E;AACA,SAAK,gBAAL,GAAwB,KAAK,OAAL,CAAa,aAAb,EAAxB;;AACA,QAAI,IAAI,CAAC,aAAT,EAAwB;AACpB,UAAI,QAAQ,GAAG,OAAO,CAAC,WAAR,EAAf;;AACA,UAAI,QAAQ,IAAI,QAAQ,CAAC,wBAAT,CAAkC,IAAlC,CAAhB,EAAyD;AACrD,aAAK,OAAL,CAAa,iBAAb,GADqD,CAErD;AACA;;;AACA,aAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B;;AACA,aAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B;;AACA,aAAK,OAAL,CAAa,gBAAb,CAA8B,IAA9B;;AACA,aAAK,OAAL,CAAa,uBAAb,CAAqC,IAArC;;AACA,aAAK,OAAL,CAAa,kBAAb,CAAgC,GAAhC;;AACA,aAAK,OAAL,CAAa,cAAb,CAA4B,eAAe,CAAC,iBAA5C;;AACA,aAAK,OAAL,CAAa,2BAAb,CAAyC,eAAe,CAAC,iBAAzD;;AACA,aAAK,MAAL,CAAY,OAAZ,EAAqB,KAArB;AAA4B;AAA4B,YAAxD;;AAEA,aAAK,OAAL,CAAa,aAAb,CAA2B,IAA3B;;AACA,aAAK,OAAL,CAAa,kBAAb,CAAgC,GAAhC;AACH,OAjBmB,CAmBpB;;;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B;;AACA,WAAK,MAAL,CAAY,OAAZ,EAAqB,KAArB;;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,KAAK,gBAAhC;;AAEA,UAAI,QAAQ,IAAI,QAAQ,CAAC,wBAAT,CAAkC,IAAlC,CAAhB,EAAyD;AACrD,aAAK,OAAL,CAAa,mBAAb;AACH;AACJ;AACJ,GA/BO;;AAiCA,EAAA,eAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,IAA5B,EAAwC,OAAxC,EAA0D,KAA1D,EAAgF;AAC5E;AACA,QAAI,IAAI,CAAC,aAAT,EAAwB;AACpB,UAAI,WAAW,GAAG,KAAK,OAAL,CAAa,YAAb,EAAlB;;AACA,UAAI,eAAe,GAAG,KAAK,OAAL,CAAa,UAAb,CAAwB,UAA9C;;AACA,WAAK,OAAL,CAAa,YAAb,CAA0B,CAA1B;;AACA,WAAK,MAAL,CAAY,OAAZ,EAAqB,KAArB,EAA4B,IAA5B;;AACA,WAAK,OAAL,CAAa,YAAb,CAA0B,WAA1B;;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,KAAK,gBAAhC;;AACA,WAAK,OAAL,CAAa,UAAb,CAAwB,UAAxB,GAAqC,eAArC;AACH,KAV2E,CAY5E;;;AACA,QAAI,IAAI,CAAC,aAAL,IAAsB,KAAK,gBAA/B,EAAiD;AAC7C,WAAK,OAAL,CAAa,aAAb,CAA2B,IAA3B;;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,KAA3B;;AACA,WAAK,MAAL,CAAY,OAAZ,EAAqB,KAArB;;AACA,WAAK,OAAL,CAAa,aAAb,CAA2B,IAA3B;AACH;AACJ,GAnBO;AA9OR;;;;;AAGe,EAAA,eAAA,CAAA,iBAAA,GAAoB,IAApB;AA+PnB,SAAA,eAAA;AAAC,CAnQD,EAAA;;SAAa,e","sourcesContent":["import { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { _InstancesBatch, Mesh } from \"../Meshes/mesh\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Shaders/outline.fragment\";\r\nimport \"../Shaders/outline.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _outlineRenderer: OutlineRenderer;\r\n\r\n        /**\r\n         * Gets the outline renderer associated with the scene\r\n         * @returns a OutlineRenderer\r\n         */\r\n        getOutlineRenderer(): OutlineRenderer;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\r\nScene.prototype.getOutlineRenderer = function(): OutlineRenderer {\r\n    if (!this._outlineRenderer) {\r\n        this._outlineRenderer = new OutlineRenderer(this);\r\n    }\r\n    return this._outlineRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden (Backing field) */\r\n        _renderOutline: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the outline must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#3\r\n         */\r\n        renderOutline: boolean;\r\n\r\n        /** @hidden (Backing field) */\r\n        _renderOverlay: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the overlay must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#2\r\n         */\r\n        renderOverlay: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\r\n    get: function(this: Mesh) {\r\n        return this._renderOutline;\r\n    },\r\n    set: function(this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOutline = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\r\n    get: function(this: Mesh) {\r\n        return this._renderOverlay;\r\n    },\r\n    set: function(this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOverlay = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\n/**\r\n * This class is responsible to draw bothe outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\r\nexport class OutlineRenderer implements ISceneComponent {\r\n    /**\r\n     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n     */\r\n    private static _StencilReference = 0x04;\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    public name = SceneComponentConstants.NAME_OUTLINERENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Defines a zOffset to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffset = 1;\r\n\r\n    private _engine: Engine;\r\n    private _effect: Effect;\r\n    private _cachedDefines: string;\r\n    private _savedDepthWrite: boolean;\r\n\r\n    /**\r\n     * Instantiates a new outline renderer. (There could be only one per scene).\r\n     * @param scene Defines the scene it belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this.scene._addComponent(this);\r\n    }\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Renders the outline in the canvas.\r\n     * @param subMesh Defines the sumesh to render\r\n     * @param batch Defines the batch of meshes in case of instances\r\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n     */\r\n    public render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay: boolean = false): void {\r\n        var scene = this.scene;\r\n        var engine = scene.getEngine();\r\n\r\n        var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n            return;\r\n        }\r\n\r\n        var ownerMesh = subMesh.getMesh();\r\n        var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\r\n        var renderingMesh = subMesh.getRenderingMesh();\r\n        var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\r\n        var material = subMesh.getMaterial();\r\n\r\n        if (!material || !scene.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        engine.enableEffect(this._effect);\r\n\r\n        // Logarithmic depth\r\n        if ((<any>material).useLogarithmicDepth) {\r\n            this._effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n\r\n        this._effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\r\n        this._effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\r\n        this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n        this._effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n\r\n        // Bones\r\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n            this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n        }\r\n\r\n        // Morph targets\r\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);\r\n\r\n        renderingMesh._bind(subMesh, this._effect, material.fillMode);\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting()) {\r\n            var alphaTexture = material.getAlphaTestTexture();\r\n            if (alphaTexture) {\r\n                this._effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n            }\r\n        }\r\n\r\n        engine.setZOffset(-this.zOffset);\r\n        renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering,\r\n            (isInstance, world) => { this._effect.setMatrix(\"world\", world); });\r\n\r\n        engine.setZOffset(0);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the outline renderer is ready for a given submesh.\r\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n     * @param subMesh Defines the submesh to check readyness for\r\n     * @param useInstances Defines wheter wee are trying to render instances or not\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        var defines = [];\r\n        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n        var mesh = subMesh.getMesh();\r\n        var material = subMesh.getMaterial();\r\n\r\n        if (material) {\r\n            // Alpha test\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    attribs.push(VertexBuffer.UVKind);\r\n                    defines.push(\"#define UV1\");\r\n                }\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                    attribs.push(VertexBuffer.UV2Kind);\r\n                    defines.push(\"#define UV2\");\r\n                }\r\n            }\r\n            //Logarithmic depth\r\n            if ((<any>material).useLogarithmicDepth) {\r\n                defines.push(\"#define LOGARITHMICDEPTH\");\r\n            }\r\n        }\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effect = this.scene.getEngine().createEffect(\"outline\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\"],\r\n                [\"diffuseSampler\"], join,\r\n                undefined, undefined, undefined,\r\n                { maxSimultaneousMorphTargets: numMorphInfluencers });\r\n        }\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    private _beforeRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Outline - step 1\r\n        this._savedDepthWrite = this._engine.getDepthWrite();\r\n        if (mesh.renderOutline) {\r\n            var material = subMesh.getMaterial();\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.cacheStencilState();\r\n                // Draw only to stencil buffer for the original mesh\r\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\r\n                this._engine.setDepthWrite(false);\r\n                this._engine.setColorWrite(false);\r\n                this._engine.setStencilBuffer(true);\r\n                this._engine.setStencilOperationPass(7681);\r\n                this._engine.setStencilFunction(519);\r\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\r\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\r\n                this.render(subMesh, batch, /* This sets offset to 0 */ true);\r\n\r\n                this._engine.setColorWrite(true);\r\n                this._engine.setStencilFunction(517);\r\n            }\r\n\r\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\r\n            this._engine.setDepthWrite(false);\r\n            this.render(subMesh, batch);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.restoreStencilState();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Overlay\r\n        if (mesh.renderOverlay) {\r\n            var currentMode = this._engine.getAlphaMode();\r\n            let alphaBlendState = this._engine.alphaState.alphaBlend;\r\n            this._engine.setAlphaMode(2);\r\n            this.render(subMesh, batch, true);\r\n            this._engine.setAlphaMode(currentMode);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n            this._engine.alphaState.alphaBlend = alphaBlendState;\r\n        }\r\n\r\n        // Outline - step 2\r\n        if (mesh.renderOutline && this._savedDepthWrite) {\r\n            this._engine.setDepthWrite(true);\r\n            this._engine.setColorWrite(false);\r\n            this.render(subMesh, batch);\r\n            this._engine.setColorWrite(true);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}