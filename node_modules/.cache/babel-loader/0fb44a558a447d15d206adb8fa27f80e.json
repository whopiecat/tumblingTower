{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess\";\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\nimport { serialize, SerializationHelper } from '../Misc/decorators';\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\nimport \"../Shaders/screenSpaceReflection.fragment\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n */\n\nvar ScreenSpaceReflectionPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(ScreenSpaceReflectionPostProcess, _super);\n  /**\r\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n   * @param name The name of the effect.\r\n   * @param scene The scene containing the objects to calculate reflections.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass.\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n   */\n\n\n  function ScreenSpaceReflectionPostProcess(name, scene, options, camera, samplingMode, engine, reusable, textureType, blockCompilation, forceGeometryBuffer) {\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (blockCompilation === void 0) {\n      blockCompilation = false;\n    }\n\n    if (forceGeometryBuffer === void 0) {\n      forceGeometryBuffer = true;\n    }\n\n    var _this = _super.call(this, name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"step\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation) || this;\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\n\n\n    _this.threshold = 1.2;\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\n\n    _this.strength = 1;\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\n\n    _this.reflectionSpecularFalloffExponent = 3;\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\n\n    _this.step = 1.0;\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\n\n    _this.roughnessFactor = 0.2;\n    _this._forceGeometryBuffer = false;\n    _this._enableSmoothReflections = false;\n    _this._reflectionSamples = 64;\n    _this._smoothSteps = 5;\n    _this._forceGeometryBuffer = forceGeometryBuffer;\n\n    if (_this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      var geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n          _this._geometryBufferRenderer = geometryBufferRenderer;\n        }\n      }\n    } else {\n      _this._prePassRenderer = scene.enablePrePassRenderer();\n\n      _this._prePassRenderer.markAsDirty();\n\n      _this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n\n    _this._updateEffectDefines(); // On apply, send uniforms\n\n\n    _this.onApply = function (effect) {\n      var geometryBufferRenderer = _this._geometryBufferRenderer;\n      var prePassRenderer = _this._prePassRenderer;\n\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n\n      if (geometryBufferRenderer) {\n        // Samplers\n        var positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        var roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else {\n        // Samplers\n        var positionIndex = prePassRenderer.getIndex(1);\n        var roughnessIndex = prePassRenderer.getIndex(3);\n        var normalIndex = prePassRenderer.getIndex(5);\n        effect.setTexture(\"normalSampler\", prePassRenderer.prePassRT.textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.prePassRT.textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.prePassRT.textures[roughnessIndex]);\n      } // Uniforms\n\n\n      var camera = scene.activeCamera;\n\n      if (!camera) {\n        return;\n      }\n\n      var viewMatrix = camera.getViewMatrix();\n      var projectionMatrix = camera.getProjectionMatrix();\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", _this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", _this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", _this.strength);\n      effect.setFloat(\"step\", _this.step);\n      effect.setFloat(\"roughnessFactor\", _this.roughnessFactor);\n    };\n\n    return _this;\n  }\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n   */\n\n\n  ScreenSpaceReflectionPostProcess.prototype.getClassName = function () {\n    return \"ScreenSpaceReflectionPostProcess\";\n  };\n\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", {\n    /**\r\n     * Gets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\n    get: function () {\n      return this._enableSmoothReflections;\n    },\n\n    /**\r\n     * Sets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\n    set: function (enabled) {\n      if (enabled === this._enableSmoothReflections) {\n        return;\n      }\n\n      this._enableSmoothReflections = enabled;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", {\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\n    get: function () {\n      return this._reflectionSamples;\n    },\n\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\n    set: function (samples) {\n      if (samples === this._reflectionSamples) {\n        return;\n      }\n\n      this._reflectionSamples = samples;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", {\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\n    get: function () {\n      return this._smoothSteps;\n    },\n\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\n    set: function (steps) {\n      if (steps === this._smoothSteps) {\n        return;\n      }\n\n      this._smoothSteps = steps;\n\n      this._updateEffectDefines();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ScreenSpaceReflectionPostProcess.prototype._updateEffectDefines = function () {\n    var defines = [];\n\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n\n      if (this._prePassRenderer) {\n        defines.push(\"#define PREPASS_LAYOUT\");\n      }\n    }\n\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  };\n  /** @hidden */\n\n\n  ScreenSpaceReflectionPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n\n  __decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\n\n  return ScreenSpaceReflectionPostProcess;\n}(PostProcess);\n\nexport { ScreenSpaceReflectionPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.ScreenSpaceReflectionPostProcess\"] = ScreenSpaceReflectionPostProcess;","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/screenSpaceReflectionPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PostProcess, PostProcessOptions } from \"./postProcess\";\r\n\r\nimport { GeometryBufferRenderer } from '../Rendering/geometryBufferRenderer';\r\nimport { serialize, SerializationHelper } from '../Misc/decorators';\r\nimport { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\r\n\r\nimport \"../Shaders/screenSpaceReflection.fragment\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n */\r\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\r\n    @serialize()\r\n    public threshold: number = 1.2;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\r\n    @serialize()\r\n    public strength: number = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent: number = 3;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\r\n    @serialize()\r\n    public step: number = 1.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor: number = 0.2;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private _geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n    private _prePassRenderer: PrePassRenderer;\r\n    private _enableSmoothReflections: boolean = false;\r\n    private _reflectionSamples: number = 64;\r\n    private _smoothSteps: number = 5;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ScreenSpaceReflectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to calculate reflections.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType: number = 0, blockCompilation = false, forceGeometryBuffer = true) {\r\n        super(name, \"screenSpaceReflection\", [\r\n            \"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"step\", \"roughnessFactor\"\r\n        ], [\r\n            \"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"\r\n        ], options, camera, samplingMode, engine, reusable,\r\n        \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\",\r\n        textureType, undefined, null, blockCompilation);\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this._forceGeometryBuffer) {\r\n            // Get geometry buffer renderer and update effect\r\n            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n            if (geometryBufferRenderer) {\r\n                if (geometryBufferRenderer.isSupported) {\r\n                    geometryBufferRenderer.enablePosition = true;\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n                    this._geometryBufferRenderer = geometryBufferRenderer;\r\n                }\r\n            }\r\n        } else {\r\n            this._prePassRenderer = <PrePassRenderer>scene.enablePrePassRenderer();\r\n            this._prePassRenderer.markAsDirty();\r\n            this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\r\n        }\r\n\r\n        this._updateEffectDefines();\r\n\r\n        // On apply, send uniforms\r\n        this.onApply = (effect: Effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                // Samplers\r\n                const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n            } else {\r\n                // Samplers\r\n                const positionIndex = prePassRenderer.getIndex(1);\r\n                const roughnessIndex = prePassRenderer.getIndex(3);\r\n                const normalIndex = prePassRenderer.getIndex(5);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.prePassRT.textures[normalIndex]);\r\n                effect.setTexture(\"positionSampler\", prePassRenderer.prePassRT.textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.prePassRT.textures[roughnessIndex]);\r\n            }\r\n\r\n            // Uniforms\r\n            const camera = scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix();\r\n            const projectionMatrix = camera.getProjectionMatrix();\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setFloat(\"threshold\", this.threshold);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"step\", this.step);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    @serialize()\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    /**\r\n     * Sets wether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    @serialize()\r\n    public get reflectionSamples(): number {\r\n        return this._reflectionSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    public set reflectionSamples(samples: number) {\r\n        if (samples === this._reflectionSamples) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionSamples = samples;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    @serialize()\r\n    public get smoothSteps(): number {\r\n        return this._smoothSteps;\r\n    }\r\n\r\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    public set smoothSteps(steps: number) {\r\n        if (steps === this._smoothSteps) {\r\n            return;\r\n        }\r\n\r\n        this._smoothSteps = steps;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n            if (this._prePassRenderer) {\r\n                defines.push(\"#define PREPASS_LAYOUT\");\r\n            }\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\r\n        }\r\n\r\n        defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\r\n        defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\r\n\r\n        this.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(() => {\r\n            return new ScreenSpaceReflectionPostProcess(\r\n                parsedPostProcess.name, scene,\r\n                parsedPostProcess.options, targetCamera,\r\n                parsedPostProcess.renderTargetSamplingMode,\r\n                scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\r\n        }, parsedPostProcess, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ScreenSpaceReflectionPostProcess\"] = ScreenSpaceReflectionPostProcess;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}