{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector\";\nimport { Scalar } from \"../../../Maths/math.scalar\";\nimport { Texture } from \"../../../Materials/Textures/texture\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\nimport { _TypeStore } from '../../../Misc/typeStore';\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess\";\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\nimport \"../../../Shaders/standard.fragment\";\n/**\r\n * Standard rendering pipeline\r\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline\r\n */\n\nvar StandardRenderingPipeline =\n/** @class */\nfunction (_super) {\n  __extends(StandardRenderingPipeline, _super);\n  /**\r\n   * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n   * @constructor\r\n   * @param name The rendering pipeline name\r\n   * @param scene The scene linked to this pipeline\r\n   * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n   * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\r\n   * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n   */\n\n\n  function StandardRenderingPipeline(name, scene, ratio, originalPostProcess, cameras) {\n    if (originalPostProcess === void 0) {\n      originalPostProcess = null;\n    }\n\n    var _this = _super.call(this, scene.getEngine(), name) || this;\n    /**\r\n     * Post-process used to down scale an image x4\r\n     */\n\n\n    _this.downSampleX4PostProcess = null;\n    /**\r\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\r\n     */\n\n    _this.brightPassPostProcess = null;\n    /**\r\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\r\n     */\n\n    _this.blurHPostProcesses = [];\n    /**\r\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\r\n     */\n\n    _this.blurVPostProcesses = [];\n    /**\r\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\r\n     */\n\n    _this.textureAdderPostProcess = null;\n    /**\r\n     * Post-process used to create volumetric lighting effect\r\n     */\n\n    _this.volumetricLightPostProcess = null;\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\r\n     */\n\n    _this.volumetricLightSmoothXPostProcess = null;\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\r\n     */\n\n    _this.volumetricLightSmoothYPostProcess = null;\n    /**\r\n     * Post-process used to merge the volumetric light effect and the real scene color\r\n     */\n\n    _this.volumetricLightMergePostProces = null;\n    /**\r\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\r\n     */\n\n    _this.volumetricLightFinalPostProcess = null;\n    /**\r\n     * Base post-process used to calculate the average luminance of the final image for HDR\r\n     */\n\n    _this.luminancePostProcess = null;\n    /**\r\n     * Post-processes used to create down sample post-processes in order to get\r\n     * the average luminance of the final image for HDR\r\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\r\n     */\n\n    _this.luminanceDownSamplePostProcesses = [];\n    /**\r\n     * Post-process used to create a HDR effect (light adaptation)\r\n     */\n\n    _this.hdrPostProcess = null;\n    /**\r\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\r\n     */\n\n    _this.textureAdderFinalPostProcess = null;\n    /**\r\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\r\n     */\n\n    _this.lensFlareFinalPostProcess = null;\n    /**\r\n     * Post-process used to merge the final HDR post-process and the real scene color\r\n     */\n\n    _this.hdrFinalPostProcess = null;\n    /**\r\n     * Post-process used to create a lens flare effect\r\n     */\n\n    _this.lensFlarePostProcess = null;\n    /**\r\n     * Post-process that merges the result of the lens flare post-process and the real scene color\r\n     */\n\n    _this.lensFlareComposePostProcess = null;\n    /**\r\n     * Post-process used to create a motion blur effect\r\n     */\n\n    _this.motionBlurPostProcess = null;\n    /**\r\n     * Post-process used to create a depth of field effect\r\n     */\n\n    _this.depthOfFieldPostProcess = null;\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.\r\n     */\n\n    _this.fxaaPostProcess = null;\n    /**\r\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\r\n     */\n\n    _this.screenSpaceReflectionPostProcess = null; // Values\n\n    /**\r\n     * Represents the brightness threshold in order to configure the illuminated surfaces\r\n     */\n\n    _this.brightThreshold = 1.0;\n    /**\r\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\r\n     */\n\n    _this.blurWidth = 512.0;\n    /**\r\n     * Sets if the blur for highlighted surfaces must be only horizontal\r\n     */\n\n    _this.horizontalBlur = false;\n    /**\r\n     * Texture used typically to simulate \"dirty\" on camera lens\r\n     */\n\n    _this.lensTexture = null;\n    /**\r\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\r\n     */\n\n    _this.volumetricLightCoefficient = 0.2;\n    /**\r\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\r\n     */\n\n    _this.volumetricLightPower = 4.0;\n    /**\r\n     * Used the set the blur intensity to smooth the volumetric lights\r\n     */\n\n    _this.volumetricLightBlurScale = 64.0;\n    /**\r\n     * Light (spot or directional) used to generate the volumetric lights rays\r\n     * The source light must have a shadow generate so the pipeline can get its\r\n     * depth map\r\n     */\n\n    _this.sourceLight = null;\n    /**\r\n     * For eye adaptation, represents the minimum luminance the eye can see\r\n     */\n\n    _this.hdrMinimumLuminance = 1.0;\n    /**\r\n     * For eye adaptation, represents the decrease luminance speed\r\n     */\n\n    _this.hdrDecreaseRate = 0.5;\n    /**\r\n     * For eye adaptation, represents the increase luminance speed\r\n     */\n\n    _this.hdrIncreaseRate = 0.5;\n    /**\r\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\r\n     */\n\n    _this.lensColorTexture = null;\n    /**\r\n     * The overall strengh for the lens flare effect\r\n     */\n\n    _this.lensFlareStrength = 20.0;\n    /**\r\n     * Dispersion coefficient for lens flare ghosts\r\n     */\n\n    _this.lensFlareGhostDispersal = 1.4;\n    /**\r\n     * Main lens flare halo width\r\n     */\n\n    _this.lensFlareHaloWidth = 0.7;\n    /**\r\n     * Based on the lens distortion effect, defines how much the lens flare result\r\n     * is distorted\r\n     */\n\n    _this.lensFlareDistortionStrength = 16.0;\n    /**\r\n     * Configures the blur intensity used for for lens flare (halo)\r\n     */\n\n    _this.lensFlareBlurWidth = 512.0;\n    /**\r\n     * Lens star texture must be used to simulate rays on the flares and is available\r\n     * in the documentation\r\n     */\n\n    _this.lensStarTexture = null;\n    /**\r\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\r\n     * flare effect by taking account of the dirt texture\r\n     */\n\n    _this.lensFlareDirtTexture = null;\n    /**\r\n     * Represents the focal length for the depth of field effect\r\n     */\n\n    _this.depthOfFieldDistance = 10.0;\n    /**\r\n     * Represents the blur intensity for the blurred part of the depth of field effect\r\n     */\n\n    _this.depthOfFieldBlurWidth = 64.0;\n    /**\r\n     * List of animations for the pipeline (IAnimatable implementation)\r\n     */\n\n    _this.animations = [];\n    _this._currentDepthOfFieldSource = null;\n    _this._fixedExposure = 1.0;\n    _this._currentExposure = 1.0;\n    _this._hdrAutoExposure = false;\n    _this._hdrCurrentLuminance = 1.0;\n    _this._motionStrength = 1.0;\n    _this._isObjectBasedMotionBlur = false;\n    _this._camerasToBeAttached = []; // Getters and setters\n\n    _this._bloomEnabled = false;\n    _this._depthOfFieldEnabled = false;\n    _this._vlsEnabled = false;\n    _this._lensFlareEnabled = false;\n    _this._hdrEnabled = false;\n    _this._motionBlurEnabled = false;\n    _this._fxaaEnabled = false;\n    _this._screenSpaceReflectionsEnabled = false;\n    _this._motionBlurSamples = 64.0;\n    _this._volumetricLightStepsCount = 50.0;\n    _this._samples = 1;\n    _this._cameras = cameras || scene.cameras;\n    _this._cameras = _this._cameras.slice();\n    _this._camerasToBeAttached = _this._cameras.slice(); // Initialize\n\n    _this._scene = scene;\n    _this._basePostProcess = originalPostProcess;\n    _this._ratio = ratio; // Misc\n\n    _this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2; // Finish\n\n    scene.postProcessRenderPipelineManager.addPipeline(_this);\n\n    _this._buildPipeline();\n\n    return _this;\n  }\n\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"exposure\", {\n    /**\r\n     * Gets the overall exposure used by the pipeline\r\n     */\n    get: function () {\n      return this._fixedExposure;\n    },\n\n    /**\r\n     * Sets the overall exposure used by the pipeline\r\n     */\n    set: function (value) {\n      this._fixedExposure = value;\n      this._currentExposure = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"hdrAutoExposure\", {\n    /**\r\n     * Gets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\n    get: function () {\n      return this._hdrAutoExposure;\n    },\n\n    /**\r\n     * Sets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\n    set: function (value) {\n      this._hdrAutoExposure = value;\n\n      if (this.hdrPostProcess) {\n        var defines = [\"#define HDR\"];\n\n        if (value) {\n          defines.push(\"#define AUTO_EXPOSURE\");\n        }\n\n        this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"motionStrength\", {\n    /**\r\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\n    get: function () {\n      return this._motionStrength;\n    },\n\n    /**\r\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\n    set: function (strength) {\n      this._motionStrength = strength;\n\n      if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.motionStrength = strength;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", {\n    /**\r\n     * Gets wether or not the motion blur post-process is object based or screen based.\r\n     */\n    get: function () {\n      return this._isObjectBasedMotionBlur;\n    },\n\n    /**\r\n     * Sets wether or not the motion blur post-process should be object based or screen based\r\n     */\n    set: function (value) {\n      var shouldRebuild = this._isObjectBasedMotionBlur !== value;\n      this._isObjectBasedMotionBlur = value;\n\n      if (shouldRebuild) {\n        this._buildPipeline();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"BloomEnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the bloom pipeline is enabled\r\n     */\n    get: function () {\n      return this._bloomEnabled;\n    },\n    set: function (enabled) {\n      if (this._bloomEnabled === enabled) {\n        return;\n      }\n\n      this._bloomEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the depth of field pipeline is enabed\r\n     */\n    get: function () {\n      return this._depthOfFieldEnabled;\n    },\n    set: function (enabled) {\n      if (this._depthOfFieldEnabled === enabled) {\n        return;\n      }\n\n      this._depthOfFieldEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"LensFlareEnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the lens flare pipeline is enabed\r\n     */\n    get: function () {\n      return this._lensFlareEnabled;\n    },\n    set: function (enabled) {\n      if (this._lensFlareEnabled === enabled) {\n        return;\n      }\n\n      this._lensFlareEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"HDREnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the HDR pipeline is enabled\r\n     */\n    get: function () {\n      return this._hdrEnabled;\n    },\n    set: function (enabled) {\n      if (this._hdrEnabled === enabled) {\n        return;\n      }\n\n      this._hdrEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"VLSEnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the volumetric lights scattering effect is enabled\r\n     */\n    get: function () {\n      return this._vlsEnabled;\n    },\n    set: function (enabled) {\n      if (this._vlsEnabled === enabled) {\n        return;\n      }\n\n      if (enabled) {\n        var geometry = this._scene.enableGeometryBufferRenderer();\n\n        if (!geometry) {\n          Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n          return;\n        }\n      }\n\n      this._vlsEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", {\n    /**\r\n     * @ignore\r\n     * Specifies if the motion blur effect is enabled\r\n     */\n    get: function () {\n      return this._motionBlurEnabled;\n    },\n    set: function (enabled) {\n      if (this._motionBlurEnabled === enabled) {\n        return;\n      }\n\n      this._motionBlurEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"fxaaEnabled\", {\n    /**\r\n     * Specifies if anti-aliasing is enabled\r\n     */\n    get: function () {\n      return this._fxaaEnabled;\n    },\n    set: function (enabled) {\n      if (this._fxaaEnabled === enabled) {\n        return;\n      }\n\n      this._fxaaEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", {\n    /**\r\n     * Specifies if screen space reflections are enabled.\r\n     */\n    get: function () {\n      return this._screenSpaceReflectionsEnabled;\n    },\n    set: function (enabled) {\n      if (this._screenSpaceReflectionsEnabled === enabled) {\n        return;\n      }\n\n      this._screenSpaceReflectionsEnabled = enabled;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", {\n    /**\r\n     * Specifies the number of steps used to calculate the volumetric lights\r\n     * Typically in interval [50, 200]\r\n     */\n    get: function () {\n      return this._volumetricLightStepsCount;\n    },\n    set: function (count) {\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\n      }\n\n      this._volumetricLightStepsCount = count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"motionBlurSamples\", {\n    /**\r\n     * Specifies the number of samples used for the motion blur effect\r\n     * Typically in interval [16, 64]\r\n     */\n    get: function () {\n      return this._motionBlurSamples;\n    },\n    set: function (samples) {\n      if (this.motionBlurPostProcess) {\n        if (this._isObjectBasedMotionBlur) {\n          this.motionBlurPostProcess.motionBlurSamples = samples;\n        } else {\n          this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\n        }\n      }\n\n      this._motionBlurSamples = samples;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StandardRenderingPipeline.prototype, \"samples\", {\n    /**\r\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\n    get: function () {\n      return this._samples;\n    },\n    set: function (sampleCount) {\n      if (this._samples === sampleCount) {\n        return;\n      }\n\n      this._samples = sampleCount;\n\n      this._buildPipeline();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StandardRenderingPipeline.prototype._buildPipeline = function () {\n    var _this = this;\n\n    var ratio = this._ratio;\n    var scene = this._scene;\n\n    this._disposePostProcesses();\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras); // get back cameras to be used to reattach pipeline\n\n\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n\n    this._reset(); // Create pass post-process\n\n\n    if (this._screenSpaceReflectionsEnabled) {\n      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\"HDRPass\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n      this.screenSpaceReflectionPostProcess.onApplyObservable.add(function () {\n        _this._currentDepthOfFieldSource = _this.screenSpaceReflectionPostProcess;\n      });\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", function () {\n        return _this.screenSpaceReflectionPostProcess;\n      }, true));\n    }\n\n    if (!this._basePostProcess) {\n      this.originalPostProcess = new PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\n    } else {\n      this.originalPostProcess = this._basePostProcess;\n    }\n\n    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\n    this.originalPostProcess.onApplyObservable.add(function () {\n      _this._currentDepthOfFieldSource = _this.originalPostProcess;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", function () {\n      return _this.originalPostProcess;\n    }, true));\n\n    if (this._bloomEnabled) {\n      // Create down sample X4 post-process\n      this._createDownSampleX4PostProcess(scene, ratio / 4); // Create bright pass post-process\n\n\n      this._createBrightPassPostProcess(scene, ratio / 4); // Create gaussian blur post-processes (down sampling blurs)\n\n\n      this._createBlurPostProcesses(scene, ratio / 4, 1); // Create texture adder post-process\n\n\n      this._createTextureAdderPostProcess(scene, ratio); // Create depth-of-field source post-process\n\n\n      this.textureAdderFinalPostProcess = new PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", function () {\n        return _this.textureAdderFinalPostProcess;\n      }, true));\n    }\n\n    if (this._vlsEnabled) {\n      // Create volumetric light\n      this._createVolumetricLightPostProcess(scene, ratio); // Create volumetric light final post-process\n\n\n      this.volumetricLightFinalPostProcess = new PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", function () {\n        return _this.volumetricLightFinalPostProcess;\n      }, true));\n    }\n\n    if (this._lensFlareEnabled) {\n      // Create lens flare post-process\n      this._createLensFlarePostProcess(scene, ratio); // Create depth-of-field source post-process post lens-flare and disable it now\n\n\n      this.lensFlareFinalPostProcess = new PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", function () {\n        return _this.lensFlareFinalPostProcess;\n      }, true));\n    }\n\n    if (this._hdrEnabled) {\n      // Create luminance\n      this._createLuminancePostProcesses(scene, this._floatTextureType); // Create HDR\n\n\n      this._createHdrPostProcess(scene, ratio); // Create depth-of-field source post-process post hdr and disable it now\n\n\n      this.hdrFinalPostProcess = new PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", function () {\n        return _this.hdrFinalPostProcess;\n      }, true));\n    }\n\n    if (this._depthOfFieldEnabled) {\n      // Create gaussian blur used by depth-of-field\n      this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\"); // Create depth-of-field post-process\n\n\n      this._createDepthOfFieldPostProcess(scene, ratio);\n    }\n\n    if (this._motionBlurEnabled) {\n      // Create motion blur post-process\n      this._createMotionBlurPostProcess(scene, ratio);\n    }\n\n    if (this._fxaaEnabled) {\n      // Create fxaa post-process\n      this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRFxaa\", function () {\n        return _this.fxaaPostProcess;\n      }, true));\n    }\n\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n\n    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n  }; // Down Sample X4 Post-Processs\n\n\n  StandardRenderingPipeline.prototype._createDownSampleX4PostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var downSampleX4Offsets = new Array(32);\n    this.downSampleX4PostProcess = new PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", this._floatTextureType);\n\n    this.downSampleX4PostProcess.onApply = function (effect) {\n      var id = 0;\n      var width = _this.downSampleX4PostProcess.width;\n      var height = _this.downSampleX4PostProcess.height;\n\n      for (var i = -2; i < 2; i++) {\n        for (var j = -2; j < 2; j++) {\n          downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\n          downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\n          id += 2;\n        }\n      }\n\n      effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", function () {\n      return _this.downSampleX4PostProcess;\n    }, true));\n  }; // Brightpass Post-Process\n\n\n  StandardRenderingPipeline.prototype._createBrightPassPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var brightOffsets = new Array(8);\n    this.brightPassPostProcess = new PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", this._floatTextureType);\n\n    this.brightPassPostProcess.onApply = function (effect) {\n      var sU = 1.0 / _this.brightPassPostProcess.width;\n      var sV = 1.0 / _this.brightPassPostProcess.height;\n      brightOffsets[0] = -0.5 * sU;\n      brightOffsets[1] = 0.5 * sV;\n      brightOffsets[2] = 0.5 * sU;\n      brightOffsets[3] = 0.5 * sV;\n      brightOffsets[4] = -0.5 * sU;\n      brightOffsets[5] = -0.5 * sV;\n      brightOffsets[6] = 0.5 * sU;\n      brightOffsets[7] = -0.5 * sV;\n      effect.setArray2(\"dsOffsets\", brightOffsets);\n      effect.setFloat(\"brightThreshold\", _this.brightThreshold);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", function () {\n      return _this.brightPassPostProcess;\n    }, true));\n  }; // Create blur H&V post-processes\n\n\n  StandardRenderingPipeline.prototype._createBlurPostProcesses = function (scene, ratio, indice, blurWidthKey) {\n    var _this = this;\n\n    if (blurWidthKey === void 0) {\n      blurWidthKey = \"blurWidth\";\n    }\n\n    var engine = scene.getEngine();\n    var blurX = new BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    var blurY = new BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    blurX.onActivateObservable.add(function () {\n      var dw = blurX.width / engine.getRenderWidth();\n      blurX.kernel = _this[blurWidthKey] * dw;\n    });\n    blurY.onActivateObservable.add(function () {\n      var dw = blurY.height / engine.getRenderHeight();\n      blurY.kernel = _this.horizontalBlur ? 64 * dw : _this[blurWidthKey] * dw;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, function () {\n      return blurX;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, function () {\n      return blurY;\n    }, true));\n    this.blurHPostProcesses.push(blurX);\n    this.blurVPostProcesses.push(blurY);\n  }; // Create texture adder post-process\n\n\n  StandardRenderingPipeline.prototype._createTextureAdderPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.textureAdderPostProcess = new PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", this._floatTextureType);\n\n    this.textureAdderPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"otherSampler\", _this._vlsEnabled ? _this._currentDepthOfFieldSource : _this.originalPostProcess);\n      effect.setTexture(\"lensSampler\", _this.lensTexture);\n      effect.setFloat(\"exposure\", _this._currentExposure);\n      _this._currentDepthOfFieldSource = _this.textureAdderFinalPostProcess;\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", function () {\n      return _this.textureAdderPostProcess;\n    }, true));\n  };\n\n  StandardRenderingPipeline.prototype._createVolumetricLightPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var geometryRenderer = scene.enableGeometryBufferRenderer();\n    geometryRenderer.enablePosition = true;\n    var geometry = geometryRenderer.getGBuffer(); // Base post-process\n\n    this.volumetricLightPostProcess = new PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n    var depthValues = Vector2.Zero();\n\n    this.volumetricLightPostProcess.onApply = function (effect) {\n      if (_this.sourceLight && _this.sourceLight.getShadowGenerator() && _this._scene.activeCamera) {\n        var generator = _this.sourceLight.getShadowGenerator();\n\n        effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\n        effect.setTexture(\"positionSampler\", geometry.textures[2]);\n        effect.setColor3(\"sunColor\", _this.sourceLight.diffuse);\n        effect.setVector3(\"sunDirection\", _this.sourceLight.getShadowDirection());\n        effect.setVector3(\"cameraPosition\", _this._scene.activeCamera.globalPosition);\n        effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\n        effect.setFloat(\"scatteringCoefficient\", _this.volumetricLightCoefficient);\n        effect.setFloat(\"scatteringPower\", _this.volumetricLightPower);\n        depthValues.x = _this.sourceLight.getDepthMinZ(_this._scene.activeCamera);\n        depthValues.y = _this.sourceLight.getDepthMaxZ(_this._scene.activeCamera);\n        effect.setVector2(\"depthValues\", depthValues);\n      }\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", function () {\n      return _this.volumetricLightPostProcess;\n    }, true)); // Smooth\n\n    this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\"); // Merge\n\n\n    this.volumetricLightMergePostProces = new PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\n\n    this.volumetricLightMergePostProces.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"originalSampler\", _this._bloomEnabled ? _this.textureAdderFinalPostProcess : _this.originalPostProcess);\n      _this._currentDepthOfFieldSource = _this.volumetricLightFinalPostProcess;\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", function () {\n      return _this.volumetricLightMergePostProces;\n    }, true));\n  }; // Create luminance\n\n\n  StandardRenderingPipeline.prototype._createLuminancePostProcesses = function (scene, textureType) {\n    var _this = this; // Create luminance\n\n\n    var size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\n    this.luminancePostProcess = new PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], {\n      width: size,\n      height: size\n    }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\n    var offsets = [];\n\n    this.luminancePostProcess.onApply = function (effect) {\n      var sU = 1.0 / _this.luminancePostProcess.width;\n      var sV = 1.0 / _this.luminancePostProcess.height;\n      offsets[0] = -0.5 * sU;\n      offsets[1] = 0.5 * sV;\n      offsets[2] = 0.5 * sU;\n      offsets[3] = 0.5 * sV;\n      offsets[4] = -0.5 * sU;\n      offsets[5] = -0.5 * sV;\n      offsets[6] = 0.5 * sU;\n      offsets[7] = -0.5 * sV;\n      effect.setArray2(\"lumOffsets\", offsets);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", function () {\n      return _this.luminancePostProcess;\n    }, true)); // Create down sample luminance\n\n    for (var i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\n      var size = Math.pow(3, i);\n      var defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n\n      if (i === 0) {\n        defines += \"#define FINAL_DOWN_SAMPLER\";\n      }\n\n      var postProcess = new PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], {\n        width: size,\n        height: size\n      }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\n      this.luminanceDownSamplePostProcesses.push(postProcess);\n    } // Create callbacks and add effects\n\n\n    var lastLuminance = this.luminancePostProcess;\n    this.luminanceDownSamplePostProcesses.forEach(function (pp, index) {\n      var downSampleOffsets = new Array(18);\n\n      pp.onApply = function (effect) {\n        if (!lastLuminance) {\n          return;\n        }\n\n        var id = 0;\n\n        for (var x = -1; x < 2; x++) {\n          for (var y = -1; y < 2; y++) {\n            downSampleOffsets[id] = x / lastLuminance.width;\n            downSampleOffsets[id + 1] = y / lastLuminance.height;\n            id += 2;\n          }\n        }\n\n        effect.setArray2(\"dsOffsets\", downSampleOffsets);\n        effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\n\n        if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n          lastLuminance = _this.luminancePostProcess;\n        } else {\n          lastLuminance = pp;\n        }\n      };\n\n      if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n        pp.onAfterRender = function () {\n          var pixel = scene.getEngine().readPixels(0, 0, 1, 1);\n          var bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n          _this._hdrCurrentLuminance = (pixel[0] * bit_shift.x + pixel[1] * bit_shift.y + pixel[2] * bit_shift.z + pixel[3] * bit_shift.w) / 100.0;\n        };\n      }\n\n      _this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, function () {\n        return pp;\n      }, true));\n    });\n  }; // Create HDR post-process\n\n\n  StandardRenderingPipeline.prototype._createHdrPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    var defines = [\"#define HDR\"];\n\n    if (this._hdrAutoExposure) {\n      defines.push(\"#define AUTO_EXPOSURE\");\n    }\n\n    this.hdrPostProcess = new PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join(\"\\n\"), 0);\n    var outputLiminance = 1;\n    var time = 0;\n    var lastTime = 0;\n\n    this.hdrPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"textureAdderSampler\", _this._currentDepthOfFieldSource);\n      time += scene.getEngine().getDeltaTime();\n\n      if (outputLiminance < 0) {\n        outputLiminance = _this._hdrCurrentLuminance;\n      } else {\n        var dt = (lastTime - time) / 1000.0;\n\n        if (_this._hdrCurrentLuminance < outputLiminance + _this.hdrDecreaseRate * dt) {\n          outputLiminance += _this.hdrDecreaseRate * dt;\n        } else if (_this._hdrCurrentLuminance > outputLiminance - _this.hdrIncreaseRate * dt) {\n          outputLiminance -= _this.hdrIncreaseRate * dt;\n        } else {\n          outputLiminance = _this._hdrCurrentLuminance;\n        }\n      }\n\n      if (_this.hdrAutoExposure) {\n        _this._currentExposure = _this._fixedExposure / outputLiminance;\n      } else {\n        outputLiminance = Scalar.Clamp(outputLiminance, _this.hdrMinimumLuminance, 1e20);\n        effect.setFloat(\"averageLuminance\", outputLiminance);\n      }\n\n      lastTime = time;\n      _this._currentDepthOfFieldSource = _this.hdrFinalPostProcess;\n    };\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDR\", function () {\n      return _this.hdrPostProcess;\n    }, true));\n  }; // Create lens flare post-process\n\n\n  StandardRenderingPipeline.prototype._createLensFlarePostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.lensFlarePostProcess = new PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", function () {\n      return _this.lensFlarePostProcess;\n    }, true));\n\n    this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\n\n    this.lensFlareComposePostProcess = new PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", function () {\n      return _this.lensFlareComposePostProcess;\n    }, true));\n    var resolution = new Vector2(0, 0); // Lens flare\n\n    this.lensFlarePostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"textureSampler\", _this._bloomEnabled ? _this.blurHPostProcesses[0] : _this.originalPostProcess);\n      effect.setTexture(\"lensColorSampler\", _this.lensColorTexture);\n      effect.setFloat(\"strength\", _this.lensFlareStrength);\n      effect.setFloat(\"ghostDispersal\", _this.lensFlareGhostDispersal);\n      effect.setFloat(\"haloWidth\", _this.lensFlareHaloWidth); // Shift\n\n      resolution.x = _this.lensFlarePostProcess.width;\n      resolution.y = _this.lensFlarePostProcess.height;\n      effect.setVector2(\"resolution\", resolution);\n      effect.setFloat(\"distortionStrength\", _this.lensFlareDistortionStrength);\n    }; // Compose\n\n\n    var scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    var scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    this.lensFlareComposePostProcess.onApply = function (effect) {\n      if (!_this._scene.activeCamera) {\n        return;\n      }\n\n      effect.setTextureFromPostProcess(\"otherSampler\", _this.lensFlarePostProcess);\n      effect.setTexture(\"lensDirtSampler\", _this.lensFlareDirtTexture);\n      effect.setTexture(\"lensStarSampler\", _this.lensStarTexture); // Lens start rotation matrix\n\n      var camerax = _this._scene.activeCamera.getViewMatrix().getRow(0);\n\n      var cameraz = _this._scene.activeCamera.getViewMatrix().getRow(2);\n\n      var camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\n      camRot *= 4.0;\n      var starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n      var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\n      effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\n      _this._currentDepthOfFieldSource = _this.lensFlareFinalPostProcess;\n    };\n  }; // Create depth-of-field post-process\n\n\n  StandardRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    this.depthOfFieldPostProcess = new PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", 0);\n\n    this.depthOfFieldPostProcess.onApply = function (effect) {\n      effect.setTextureFromPostProcess(\"otherSampler\", _this._currentDepthOfFieldSource);\n      effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n      effect.setFloat(\"distance\", _this.depthOfFieldDistance);\n    }; // Add to pipeline\n\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", function () {\n      return _this.depthOfFieldPostProcess;\n    }, true));\n  }; // Create motion blur post-process\n\n\n  StandardRenderingPipeline.prototype._createMotionBlurPostProcess = function (scene, ratio) {\n    var _this = this;\n\n    if (this._isObjectBasedMotionBlur) {\n      var mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      mb.motionStrength = this.motionStrength;\n      mb.motionBlurSamples = this.motionBlurSamples;\n      this.motionBlurPostProcess = mb;\n    } else {\n      this.motionBlurPostProcess = new PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), 0);\n      var motionScale = 0;\n      var prevViewProjection = Matrix.Identity();\n      var invViewProjection = Matrix.Identity();\n      var viewProjection = Matrix.Identity();\n      var screenSize = Vector2.Zero();\n\n      this.motionBlurPostProcess.onApply = function (effect) {\n        viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\n        viewProjection.invertToRef(invViewProjection);\n        effect.setMatrix(\"inverseViewProjection\", invViewProjection);\n        effect.setMatrix(\"prevViewProjection\", prevViewProjection);\n        prevViewProjection = viewProjection;\n        screenSize.x = _this.motionBlurPostProcess.width;\n        screenSize.y = _this.motionBlurPostProcess.height;\n        effect.setVector2(\"screenSize\", screenSize);\n        motionScale = scene.getEngine().getFps() / 60.0;\n        effect.setFloat(\"motionScale\", motionScale);\n        effect.setFloat(\"motionStrength\", _this.motionStrength);\n        effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n      };\n    }\n\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", function () {\n      return _this.motionBlurPostProcess;\n    }, true));\n  };\n\n  StandardRenderingPipeline.prototype._getDepthTexture = function () {\n    if (this._scene.getEngine().getCaps().drawBuffersExtension) {\n      var renderer = this._scene.enableGeometryBufferRenderer();\n\n      return renderer.getGBuffer().textures[0];\n    }\n\n    return this._scene.enableDepthRenderer().getDepthMap();\n  };\n\n  StandardRenderingPipeline.prototype._disposePostProcesses = function () {\n    for (var i = 0; i < this._cameras.length; i++) {\n      var camera = this._cameras[i];\n\n      if (this.originalPostProcess) {\n        this.originalPostProcess.dispose(camera);\n      }\n\n      if (this.screenSpaceReflectionPostProcess) {\n        this.screenSpaceReflectionPostProcess.dispose(camera);\n      }\n\n      if (this.downSampleX4PostProcess) {\n        this.downSampleX4PostProcess.dispose(camera);\n      }\n\n      if (this.brightPassPostProcess) {\n        this.brightPassPostProcess.dispose(camera);\n      }\n\n      if (this.textureAdderPostProcess) {\n        this.textureAdderPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightSmoothXPostProcess) {\n        this.volumetricLightSmoothXPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightSmoothYPostProcess) {\n        this.volumetricLightSmoothYPostProcess.dispose(camera);\n      }\n\n      if (this.volumetricLightMergePostProces) {\n        this.volumetricLightMergePostProces.dispose(camera);\n      }\n\n      if (this.volumetricLightFinalPostProcess) {\n        this.volumetricLightFinalPostProcess.dispose(camera);\n      }\n\n      if (this.lensFlarePostProcess) {\n        this.lensFlarePostProcess.dispose(camera);\n      }\n\n      if (this.lensFlareComposePostProcess) {\n        this.lensFlareComposePostProcess.dispose(camera);\n      }\n\n      for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\n        this.luminanceDownSamplePostProcesses[j].dispose(camera);\n      }\n\n      if (this.luminancePostProcess) {\n        this.luminancePostProcess.dispose(camera);\n      }\n\n      if (this.hdrPostProcess) {\n        this.hdrPostProcess.dispose(camera);\n      }\n\n      if (this.hdrFinalPostProcess) {\n        this.hdrFinalPostProcess.dispose(camera);\n      }\n\n      if (this.depthOfFieldPostProcess) {\n        this.depthOfFieldPostProcess.dispose(camera);\n      }\n\n      if (this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.dispose(camera);\n      }\n\n      if (this.fxaaPostProcess) {\n        this.fxaaPostProcess.dispose(camera);\n      }\n\n      for (var j = 0; j < this.blurHPostProcesses.length; j++) {\n        this.blurHPostProcesses[j].dispose(camera);\n      }\n\n      for (var j = 0; j < this.blurVPostProcesses.length; j++) {\n        this.blurVPostProcesses[j].dispose(camera);\n      }\n    }\n\n    this.originalPostProcess = null;\n    this.downSampleX4PostProcess = null;\n    this.brightPassPostProcess = null;\n    this.textureAdderPostProcess = null;\n    this.textureAdderFinalPostProcess = null;\n    this.volumetricLightPostProcess = null;\n    this.volumetricLightSmoothXPostProcess = null;\n    this.volumetricLightSmoothYPostProcess = null;\n    this.volumetricLightMergePostProces = null;\n    this.volumetricLightFinalPostProcess = null;\n    this.lensFlarePostProcess = null;\n    this.lensFlareComposePostProcess = null;\n    this.luminancePostProcess = null;\n    this.hdrPostProcess = null;\n    this.hdrFinalPostProcess = null;\n    this.depthOfFieldPostProcess = null;\n    this.motionBlurPostProcess = null;\n    this.fxaaPostProcess = null;\n    this.screenSpaceReflectionPostProcess = null;\n    this.luminanceDownSamplePostProcesses = [];\n    this.blurHPostProcesses = [];\n    this.blurVPostProcesses = [];\n  };\n  /**\r\n   * Dispose of the pipeline and stop all post processes\r\n   */\n\n\n  StandardRenderingPipeline.prototype.dispose = function () {\n    this._disposePostProcesses();\n\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Serialize the rendering pipeline (Used when exporting)\r\n   * @returns the serialized object\r\n   */\n\n\n  StandardRenderingPipeline.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n\n    if (this.sourceLight) {\n      serializationObject.sourceLightId = this.sourceLight.id;\n    }\n\n    if (this.screenSpaceReflectionPostProcess) {\n      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\n    }\n\n    serializationObject.customType = \"StandardRenderingPipeline\";\n    return serializationObject;\n  };\n  /**\r\n   * Parse the serialized pipeline\r\n   * @param source Source pipeline.\r\n   * @param scene The scene to load the pipeline to.\r\n   * @param rootUrl The URL of the serialized pipeline.\r\n   * @returns An instantiated pipeline from the serialized object.\r\n   */\n\n\n  StandardRenderingPipeline.Parse = function (source, scene, rootUrl) {\n    var p = SerializationHelper.Parse(function () {\n      return new StandardRenderingPipeline(source._name, scene, source._ratio);\n    }, source, scene, rootUrl);\n\n    if (source.sourceLightId) {\n      p.sourceLight = scene.getLightByID(source.sourceLightId);\n    }\n\n    if (source.screenSpaceReflectionPostProcess) {\n      SerializationHelper.Parse(function () {\n        return p.screenSpaceReflectionPostProcess;\n      }, source.screenSpaceReflectionPostProcess, scene, rootUrl);\n    }\n\n    return p;\n  };\n  /**\r\n   * Luminance steps\r\n   */\n\n\n  StandardRenderingPipeline.LuminanceSteps = 6;\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"brightThreshold\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"blurWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"horizontalBlur\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"exposure\", null);\n\n  __decorate([serializeAsTexture(\"lensTexture\")], StandardRenderingPipeline.prototype, \"lensTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightCoefficient\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightPower\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightBlurScale\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrMinimumLuminance\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrDecreaseRate\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrIncreaseRate\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrAutoExposure\", null);\n\n  __decorate([serializeAsTexture(\"lensColorTexture\")], StandardRenderingPipeline.prototype, \"lensColorTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareStrength\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareGhostDispersal\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareHaloWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareDistortionStrength\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareBlurWidth\", void 0);\n\n  __decorate([serializeAsTexture(\"lensStarTexture\")], StandardRenderingPipeline.prototype, \"lensStarTexture\", void 0);\n\n  __decorate([serializeAsTexture(\"lensFlareDirtTexture\")], StandardRenderingPipeline.prototype, \"lensFlareDirtTexture\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldDistance\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldBlurWidth\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"motionStrength\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"_ratio\", void 0);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"BloomEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"LensFlareEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"HDREnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"VLSEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"fxaaEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"motionBlurSamples\", null);\n\n  __decorate([serialize()], StandardRenderingPipeline.prototype, \"samples\", null);\n\n  return StandardRenderingPipeline;\n}(PostProcessRenderPipeline);\n\nexport { StandardRenderingPipeline };\n_TypeStore.RegisteredTypes[\"BABYLON.StandardRenderingPipeline\"] = StandardRenderingPipeline;","map":{"version":3,"sources":["../../../../../sourceES6/core/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../../types\";\r\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport { IAnimatable } from '../../../Animations/animatable.interface';\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport { Camera } from \"../../../Cameras/camera\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport { IDisposable } from \"../../../scene\";\r\nimport { SpotLight } from \"../../../Lights/spotLight\";\r\nimport { DirectionalLight } from \"../../../Lights/directionalLight\";\r\nimport { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer\";\r\nimport { Scene } from \"../../../scene\";\r\n\r\nimport { _TypeStore } from '../../../Misc/typeStore';\r\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess\";\r\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess\";\r\n\r\ndeclare type Animation = import(\"../../../Animations/animation\").Animation;\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport \"../../../Shaders/standard.fragment\";\r\n/**\r\n * Standard rendering pipeline\r\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n * @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline\r\n */\r\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    /**\r\n    * Public members\r\n    */\r\n    // Post-processes\r\n    /**\r\n     * Post-process which contains the original scene color before the pipeline applies all the effects\r\n     */\r\n    public originalPostProcess: Nullable<PostProcess>;\r\n    /**\r\n     * Post-process used to down scale an image x4\r\n     */\r\n    public downSampleX4PostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\r\n     */\r\n    public brightPassPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\r\n     */\r\n    public blurHPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\r\n     */\r\n    public blurVPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\r\n     */\r\n    public textureAdderPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Post-process used to create volumetric lighting effect\r\n     */\r\n    public volumetricLightPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\r\n     */\r\n    public volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\r\n     */\r\n    public volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the volumetric light effect and the real scene color\r\n     */\r\n    public volumetricLightMergePostProces: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\r\n     */\r\n    public volumetricLightFinalPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Base post-process used to calculate the average luminance of the final image for HDR\r\n     */\r\n    public luminancePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-processes used to create down sample post-processes in order to get\r\n     * the average luminance of the final image for HDR\r\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\r\n     */\r\n    public luminanceDownSamplePostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to create a HDR effect (light adaptation)\r\n     */\r\n    public hdrPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\r\n     */\r\n    public textureAdderFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\r\n     */\r\n    public lensFlareFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the final HDR post-process and the real scene color\r\n     */\r\n    public hdrFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a lens flare effect\r\n     */\r\n    public lensFlarePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process that merges the result of the lens flare post-process and the real scene color\r\n     */\r\n    public lensFlareComposePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a motion blur effect\r\n     */\r\n    public motionBlurPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a depth of field effect\r\n     */\r\n    public depthOfFieldPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.\r\n     */\r\n    public fxaaPostProcess: Nullable<FxaaPostProcess> = null;\r\n    /**\r\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\r\n     */\r\n    public screenSpaceReflectionPostProcess: Nullable<ScreenSpaceReflectionPostProcess> = null;\r\n\r\n    // Values\r\n\r\n    /**\r\n     * Represents the brightness threshold in order to configure the illuminated surfaces\r\n     */\r\n    @serialize()\r\n    public brightThreshold: number = 1.0;\r\n\r\n    /**\r\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\r\n     */\r\n    @serialize()\r\n    public blurWidth: number = 512.0;\r\n    /**\r\n     * Sets if the blur for highlighted surfaces must be only horizontal\r\n     */\r\n    @serialize()\r\n    public horizontalBlur: boolean = false;\r\n\r\n    /**\r\n     * Gets the overall exposure used by the pipeline\r\n     */\r\n    @serialize()\r\n    public get exposure(): number {\r\n        return this._fixedExposure;\r\n    }\r\n    /**\r\n     * Sets the overall exposure used by the pipeline\r\n     */\r\n    public set exposure(value: number) {\r\n        this._fixedExposure = value;\r\n        this._currentExposure = value;\r\n    }\r\n\r\n    /**\r\n     * Texture used typically to simulate \"dirty\" on camera lens\r\n     */\r\n    @serializeAsTexture(\"lensTexture\")\r\n    public lensTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\r\n     */\r\n    @serialize()\r\n    public volumetricLightCoefficient: number = 0.2;\r\n    /**\r\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\r\n     */\r\n    @serialize()\r\n    public volumetricLightPower: number = 4.0;\r\n    /**\r\n     * Used the set the blur intensity to smooth the volumetric lights\r\n     */\r\n    @serialize()\r\n    public volumetricLightBlurScale: number = 64.0;\r\n    /**\r\n     * Light (spot or directional) used to generate the volumetric lights rays\r\n     * The source light must have a shadow generate so the pipeline can get its\r\n     * depth map\r\n     */\r\n    public sourceLight: Nullable<SpotLight | DirectionalLight> = null;\r\n\r\n    /**\r\n     * For eye adaptation, represents the minimum luminance the eye can see\r\n     */\r\n    @serialize()\r\n    public hdrMinimumLuminance: number = 1.0;\r\n    /**\r\n     * For eye adaptation, represents the decrease luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrDecreaseRate: number = 0.5;\r\n    /**\r\n     * For eye adaptation, represents the increase luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrIncreaseRate: number = 0.5;\r\n    /**\r\n     * Gets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    @serialize()\r\n    public get hdrAutoExposure(): boolean {\r\n        return this._hdrAutoExposure;\r\n    }\r\n    /**\r\n     * Sets wether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    public set hdrAutoExposure(value: boolean) {\r\n        this._hdrAutoExposure = value;\r\n        if (this.hdrPostProcess) {\r\n            const defines = [\"#define HDR\"];\r\n            if (value) {\r\n                defines.push(\"#define AUTO_EXPOSURE\");\r\n            }\r\n            this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\r\n     */\r\n    @serializeAsTexture(\"lensColorTexture\")\r\n    public lensColorTexture: Nullable<Texture> = null;\r\n    /**\r\n     * The overall strengh for the lens flare effect\r\n     */\r\n    @serialize()\r\n    public lensFlareStrength: number = 20.0;\r\n    /**\r\n     * Dispersion coefficient for lens flare ghosts\r\n     */\r\n    @serialize()\r\n    public lensFlareGhostDispersal: number = 1.4;\r\n    /**\r\n     * Main lens flare halo width\r\n     */\r\n    @serialize()\r\n    public lensFlareHaloWidth: number = 0.7;\r\n    /**\r\n     * Based on the lens distortion effect, defines how much the lens flare result\r\n     * is distorted\r\n     */\r\n    @serialize()\r\n    public lensFlareDistortionStrength: number = 16.0;\r\n    /**\r\n     * Configures the blur intensity used for for lens flare (halo)\r\n     */\r\n    @serialize()\r\n    public lensFlareBlurWidth: number = 512.0;\r\n    /**\r\n     * Lens star texture must be used to simulate rays on the flares and is available\r\n     * in the documentation\r\n     */\r\n    @serializeAsTexture(\"lensStarTexture\")\r\n    public lensStarTexture: Nullable<Texture> = null;\r\n    /**\r\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\r\n     * flare effect by taking account of the dirt texture\r\n     */\r\n    @serializeAsTexture(\"lensFlareDirtTexture\")\r\n    public lensFlareDirtTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the focal length for the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldDistance: number = 10.0;\r\n    /**\r\n     * Represents the blur intensity for the blurred part of the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldBlurWidth: number = 64.0;\r\n\r\n    /**\r\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    @serialize()\r\n    public get motionStrength(): number {\r\n        return this._motionStrength;\r\n    }\r\n    /**\r\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    public set motionStrength(strength: number) {\r\n        this._motionStrength = strength;\r\n\r\n        if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\r\n            (this.motionBlurPostProcess as MotionBlurPostProcess).motionStrength = strength;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets wether or not the motion blur post-process is object based or screen based.\r\n     */\r\n    @serialize()\r\n    public get objectBasedMotionBlur(): boolean {\r\n        return this._isObjectBasedMotionBlur;\r\n    }\r\n    /**\r\n     * Sets wether or not the motion blur post-process should be object based or screen based\r\n     */\r\n    public set objectBasedMotionBlur(value: boolean) {\r\n        const shouldRebuild = this._isObjectBasedMotionBlur !== value;\r\n        this._isObjectBasedMotionBlur = value;\r\n\r\n        if (shouldRebuild) {\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * List of animations for the pipeline (IAnimatable implementation)\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n    * Private members\r\n    */\r\n    private _scene: Scene;\r\n    private _currentDepthOfFieldSource: Nullable<PostProcess> = null;\r\n    private _basePostProcess: Nullable<PostProcess>;\r\n\r\n    private _fixedExposure: number = 1.0;\r\n    private _currentExposure: number = 1.0;\r\n    private _hdrAutoExposure: boolean = false;\r\n    private _hdrCurrentLuminance: number = 1.0;\r\n    private _motionStrength: number = 1.0;\r\n    private _isObjectBasedMotionBlur: boolean = false;\r\n\r\n    private _floatTextureType: number;\r\n\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n\r\n    @serialize()\r\n    private _ratio: number;\r\n\r\n    // Getters and setters\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _vlsEnabled: boolean = false;\r\n    private _lensFlareEnabled: boolean = false;\r\n    private _hdrEnabled: boolean = false;\r\n    private _motionBlurEnabled: boolean = false;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _screenSpaceReflectionsEnabled: boolean = false;\r\n\r\n    private _motionBlurSamples: number = 64.0;\r\n    private _volumetricLightStepsCount: number = 50.0;\r\n    private _samples: number = 1;\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the bloom pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get BloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    public set BloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._bloomEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the depth of field pipeline is enabed\r\n     */\r\n    @serialize()\r\n    public get DepthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set DepthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._depthOfFieldEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the lens flare pipeline is enabed\r\n     */\r\n    @serialize()\r\n    public get LensFlareEnabled(): boolean {\r\n        return this._lensFlareEnabled;\r\n    }\r\n\r\n    public set LensFlareEnabled(enabled: boolean) {\r\n        if (this._lensFlareEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._lensFlareEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the HDR pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get HDREnabled(): boolean {\r\n        return this._hdrEnabled;\r\n    }\r\n\r\n    public set HDREnabled(enabled: boolean) {\r\n        if (this._hdrEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._hdrEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the volumetric lights scattering effect is enabled\r\n     */\r\n    @serialize()\r\n    public get VLSEnabled(): boolean {\r\n        return this._vlsEnabled;\r\n    }\r\n\r\n    public set VLSEnabled(enabled) {\r\n        if (this._vlsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        if (enabled) {\r\n            var geometry = this._scene.enableGeometryBufferRenderer();\r\n            if (!geometry) {\r\n                Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._vlsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the motion blur effect is enabled\r\n     */\r\n    @serialize()\r\n    public get MotionBlurEnabled(): boolean {\r\n        return this._motionBlurEnabled;\r\n    }\r\n\r\n    public set MotionBlurEnabled(enabled: boolean) {\r\n        if (this._motionBlurEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._motionBlurEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if anti-aliasing is enabled\r\n     */\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._fxaaEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if screen space reflections are enabled.\r\n     */\r\n    @serialize()\r\n    public get screenSpaceReflectionsEnabled(): boolean {\r\n        return this._screenSpaceReflectionsEnabled;\r\n    }\r\n\r\n    public set screenSpaceReflectionsEnabled(enabled: boolean) {\r\n        if (this._screenSpaceReflectionsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._screenSpaceReflectionsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of steps used to calculate the volumetric lights\r\n     * Typically in interval [50, 200]\r\n     */\r\n    @serialize()\r\n    public get volumetricLightStepsCount(): number {\r\n        return this._volumetricLightStepsCount;\r\n    }\r\n\r\n    public set volumetricLightStepsCount(count: number) {\r\n        if (this.volumetricLightPostProcess) {\r\n            this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\r\n        }\r\n\r\n        this._volumetricLightStepsCount = count;\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of samples used for the motion blur effect\r\n     * Typically in interval [16, 64]\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    public set motionBlurSamples(samples: number) {\r\n        if (this.motionBlurPostProcess) {\r\n            if (this._isObjectBasedMotionBlur) {\r\n                (this.motionBlurPostProcess as MotionBlurPostProcess).motionBlurSamples = samples;\r\n            } else {\r\n                this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\r\n            }\r\n        }\r\n\r\n        this._motionBlurSamples = samples;\r\n    }\r\n\r\n    /**\r\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n\r\n        this._samples = sampleCount;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n     * @constructor\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n     */\r\n    constructor(name: string, scene: Scene, ratio: number, originalPostProcess: Nullable<PostProcess> = null, cameras?: Camera[]) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        this._basePostProcess = originalPostProcess;\r\n        this._ratio = ratio;\r\n\r\n        // Misc\r\n        this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2;\r\n\r\n        // Finish\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    private _buildPipeline(): void {\r\n        var ratio = this._ratio;\r\n        var scene = this._scene;\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n\r\n        // Create pass post-process\r\n        if (this._screenSpaceReflectionsEnabled) {\r\n            this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\"HDRPass\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\r\n            this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\r\n                this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\r\n            });\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\r\n        }\r\n\r\n        if (!this._basePostProcess) {\r\n            this.originalPostProcess = new PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\r\n        }\r\n        else {\r\n            this.originalPostProcess = this._basePostProcess;\r\n        }\r\n\r\n        this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\r\n        this.originalPostProcess.onApplyObservable.add(() => {\r\n            this._currentDepthOfFieldSource = this.originalPostProcess;\r\n        });\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\r\n\r\n        if (this._bloomEnabled) {\r\n            // Create down sample X4 post-process\r\n            this._createDownSampleX4PostProcess(scene, ratio / 4);\r\n\r\n            // Create bright pass post-process\r\n            this._createBrightPassPostProcess(scene, ratio / 4);\r\n\r\n            // Create gaussian blur post-processes (down sampling blurs)\r\n            this._createBlurPostProcesses(scene, ratio / 4, 1);\r\n\r\n            // Create texture adder post-process\r\n            this._createTextureAdderPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process\r\n            this.textureAdderFinalPostProcess = new PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", () => { return this.textureAdderFinalPostProcess; }, true));\r\n        }\r\n\r\n        if (this._vlsEnabled) {\r\n            // Create volumetric light\r\n            this._createVolumetricLightPostProcess(scene, ratio);\r\n\r\n            // Create volumetric light final post-process\r\n            this.volumetricLightFinalPostProcess = new PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", () => { return this.volumetricLightFinalPostProcess; }, true));\r\n        }\r\n\r\n        if (this._lensFlareEnabled) {\r\n            // Create lens flare post-process\r\n            this._createLensFlarePostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post lens-flare and disable it now\r\n            this.lensFlareFinalPostProcess = new PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", () => { return this.lensFlareFinalPostProcess; }, true));\r\n        }\r\n\r\n        if (this._hdrEnabled) {\r\n            // Create luminance\r\n            this._createLuminancePostProcesses(scene, this._floatTextureType);\r\n\r\n            // Create HDR\r\n            this._createHdrPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post hdr and disable it now\r\n            this.hdrFinalPostProcess = new PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", () => { return this.hdrFinalPostProcess; }, true));\r\n        }\r\n\r\n        if (this._depthOfFieldEnabled) {\r\n            // Create gaussian blur used by depth-of-field\r\n            this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\r\n\r\n            // Create depth-of-field post-process\r\n            this._createDepthOfFieldPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._motionBlurEnabled) {\r\n            // Create motion blur post-process\r\n            this._createMotionBlurPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._fxaaEnabled) {\r\n            // Create fxaa post-process\r\n            this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRFxaa\", () => { return this.fxaaPostProcess; }, true));\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n    }\r\n\r\n    // Down Sample X4 Post-Processs\r\n    private _createDownSampleX4PostProcess(scene: Scene, ratio: number): void {\r\n        var downSampleX4Offsets = new Array<number>(32);\r\n        this.downSampleX4PostProcess = new PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", this._floatTextureType);\r\n\r\n        this.downSampleX4PostProcess.onApply = (effect: Effect) => {\r\n            var id = 0;\r\n            let width = (<PostProcess>this.downSampleX4PostProcess).width;\r\n            let height = (<PostProcess>this.downSampleX4PostProcess).height;\r\n\r\n            for (var i = -2; i < 2; i++) {\r\n                for (var j = -2; j < 2; j++) {\r\n                    downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\r\n                    downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\r\n                    id += 2;\r\n                }\r\n            }\r\n\r\n            effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", () => { return this.downSampleX4PostProcess; }, true));\r\n    }\r\n\r\n    // Brightpass Post-Process\r\n    private _createBrightPassPostProcess(scene: Scene, ratio: number): void {\r\n        var brightOffsets = new Array<number>(8);\r\n        this.brightPassPostProcess = new PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", this._floatTextureType);\r\n\r\n        this.brightPassPostProcess.onApply = (effect: Effect) => {\r\n            var sU = (1.0 / (<PostProcess>this.brightPassPostProcess).width);\r\n            var sV = (1.0 / (<PostProcess>this.brightPassPostProcess).height);\r\n\r\n            brightOffsets[0] = -0.5 * sU;\r\n            brightOffsets[1] = 0.5 * sV;\r\n            brightOffsets[2] = 0.5 * sU;\r\n            brightOffsets[3] = 0.5 * sV;\r\n            brightOffsets[4] = -0.5 * sU;\r\n            brightOffsets[5] = -0.5 * sV;\r\n            brightOffsets[6] = 0.5 * sU;\r\n            brightOffsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"dsOffsets\", brightOffsets);\r\n            effect.setFloat(\"brightThreshold\", this.brightThreshold);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", () => { return this.brightPassPostProcess; }, true));\r\n    }\r\n\r\n    // Create blur H&V post-processes\r\n    private _createBlurPostProcesses(scene: Scene, ratio: number, indice: number, blurWidthKey: string = \"blurWidth\"): void {\r\n        var engine = scene.getEngine();\r\n\r\n        var blurX = new BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new Vector2(1, 0), (<any>this)[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\r\n        var blurY = new BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new Vector2(0, 1), (<any>this)[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\r\n\r\n        blurX.onActivateObservable.add(() => {\r\n            let dw = blurX.width / engine.getRenderWidth();\r\n            blurX.kernel = (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        blurY.onActivateObservable.add(() => {\r\n            let dw = blurY.height / engine.getRenderHeight();\r\n            blurY.kernel = this.horizontalBlur ? 64 * dw : (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, () => { return blurX; }, true));\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, () => { return blurY; }, true));\r\n\r\n        this.blurHPostProcesses.push(blurX);\r\n        this.blurVPostProcesses.push(blurY);\r\n    }\r\n\r\n    // Create texture adder post-process\r\n    private _createTextureAdderPostProcess(scene: Scene, ratio: number): void {\r\n        this.textureAdderPostProcess = new PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", this._floatTextureType);\r\n        this.textureAdderPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\r\n            effect.setTexture(\"lensSampler\", this.lensTexture);\r\n\r\n            effect.setFloat(\"exposure\", this._currentExposure);\r\n\r\n            this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", () => { return this.textureAdderPostProcess; }, true));\r\n    }\r\n\r\n    private _createVolumetricLightPostProcess(scene: Scene, ratio: number): void {\r\n        var geometryRenderer = <GeometryBufferRenderer>scene.enableGeometryBufferRenderer();\r\n        geometryRenderer.enablePosition = true;\r\n\r\n        var geometry = geometryRenderer.getGBuffer();\r\n\r\n        // Base post-process\r\n        this.volumetricLightPostProcess = new PostProcess(\"HDRVLS\", \"standard\",\r\n            [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"],\r\n            [\"shadowMapSampler\", \"positionSampler\"],\r\n            ratio / 8,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\r\n\r\n        var depthValues = Vector2.Zero();\r\n\r\n        this.volumetricLightPostProcess.onApply = (effect: Effect) => {\r\n            if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\r\n                var generator = this.sourceLight.getShadowGenerator()!;\r\n\r\n                effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\r\n                effect.setTexture(\"positionSampler\", geometry.textures[2]);\r\n\r\n                effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\r\n                effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\r\n\r\n                effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\r\n                effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\r\n\r\n                effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\r\n                effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\r\n\r\n                depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\r\n                depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\r\n                effect.setVector2(\"depthValues\", depthValues);\r\n            }\r\n        };\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", () => { return this.volumetricLightPostProcess; }, true));\r\n\r\n        // Smooth\r\n        this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\r\n\r\n        // Merge\r\n        this.volumetricLightMergePostProces = new PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\r\n\r\n        this.volumetricLightMergePostProces.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\r\n\r\n            this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", () => { return this.volumetricLightMergePostProces; }, true));\r\n    }\r\n\r\n    // Create luminance\r\n    private _createLuminancePostProcesses(scene: Scene, textureType: number): void {\r\n        // Create luminance\r\n        var size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\r\n        this.luminancePostProcess = new PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\r\n\r\n        var offsets: number[] = [];\r\n        this.luminancePostProcess.onApply = (effect: Effect) => {\r\n            var sU = (1.0 / (<PostProcess>this.luminancePostProcess).width);\r\n            var sV = (1.0 / (<PostProcess>this.luminancePostProcess).height);\r\n\r\n            offsets[0] = -0.5 * sU;\r\n            offsets[1] = 0.5 * sV;\r\n            offsets[2] = 0.5 * sU;\r\n            offsets[3] = 0.5 * sV;\r\n            offsets[4] = -0.5 * sU;\r\n            offsets[5] = -0.5 * sV;\r\n            offsets[6] = 0.5 * sU;\r\n            offsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"lumOffsets\", offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", () => { return this.luminancePostProcess; }, true));\r\n\r\n        // Create down sample luminance\r\n        for (var i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\r\n            var size = Math.pow(3, i);\r\n\r\n            var defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\r\n            if (i === 0) {\r\n                defines += \"#define FINAL_DOWN_SAMPLER\";\r\n            }\r\n\r\n            var postProcess = new PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], { width: size, height: size }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\r\n            this.luminanceDownSamplePostProcesses.push(postProcess);\r\n        }\r\n\r\n        // Create callbacks and add effects\r\n        var lastLuminance: Nullable<PostProcess> = this.luminancePostProcess;\r\n\r\n        this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\r\n            var downSampleOffsets = new Array<number>(18);\r\n\r\n            pp.onApply = (effect: Effect) => {\r\n                if (!lastLuminance) {\r\n                    return;\r\n                }\r\n\r\n                var id = 0;\r\n                for (var x = -1; x < 2; x++) {\r\n                    for (var y = -1; y < 2; y++) {\r\n                        downSampleOffsets[id] = x / lastLuminance.width;\r\n                        downSampleOffsets[id + 1] = y / lastLuminance.height;\r\n                        id += 2;\r\n                    }\r\n                }\r\n\r\n                effect.setArray2(\"dsOffsets\", downSampleOffsets);\r\n                effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\r\n\r\n                if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                    lastLuminance = this.luminancePostProcess;\r\n                } else {\r\n                    lastLuminance = pp;\r\n                }\r\n            };\r\n\r\n            if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                pp.onAfterRender = () => {\r\n                    var pixel = scene.getEngine().readPixels(0, 0, 1, 1);\r\n                    var bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n                    this._hdrCurrentLuminance = (pixel[0] * bit_shift.x + pixel[1] * bit_shift.y + pixel[2] * bit_shift.z + pixel[3] * bit_shift.w) / 100.0;\r\n                };\r\n            }\r\n\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, () => { return pp; }, true));\r\n        });\r\n    }\r\n\r\n    // Create HDR post-process\r\n    private _createHdrPostProcess(scene: Scene, ratio: number): void {\r\n        const defines = [\"#define HDR\"];\r\n        if (this._hdrAutoExposure) {\r\n            defines.push(\"#define AUTO_EXPOSURE\");\r\n        }\r\n        this.hdrPostProcess = new PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join(\"\\n\"), 0);\r\n\r\n        var outputLiminance = 1;\r\n        var time = 0;\r\n        var lastTime = 0;\r\n\r\n        this.hdrPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\r\n\r\n            time += scene.getEngine().getDeltaTime();\r\n\r\n            if (outputLiminance < 0) {\r\n                outputLiminance = this._hdrCurrentLuminance;\r\n            } else {\r\n                var dt = (lastTime - time) / 1000.0;\r\n\r\n                if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\r\n                    outputLiminance += this.hdrDecreaseRate * dt;\r\n                }\r\n                else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\r\n                    outputLiminance -= this.hdrIncreaseRate * dt;\r\n                }\r\n                else {\r\n                    outputLiminance = this._hdrCurrentLuminance;\r\n                }\r\n            }\r\n\r\n            if (this.hdrAutoExposure) {\r\n                this._currentExposure = this._fixedExposure / outputLiminance;\r\n            } else {\r\n                outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\r\n                effect.setFloat(\"averageLuminance\", outputLiminance);\r\n            }\r\n\r\n            lastTime = time;\r\n\r\n            this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDR\", () => { return this.hdrPostProcess; }, true));\r\n    }\r\n\r\n    // Create lens flare post-process\r\n    private _createLensFlarePostProcess(scene: Scene, ratio: number): void {\r\n        this.lensFlarePostProcess = new PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", 0);\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", () => { return this.lensFlarePostProcess; }, true));\r\n\r\n        this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\r\n\r\n        this.lensFlareComposePostProcess = new PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", 0);\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", () => { return this.lensFlareComposePostProcess; }, true));\r\n\r\n        var resolution = new Vector2(0, 0);\r\n\r\n        // Lens flare\r\n        this.lensFlarePostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\r\n            effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\r\n            effect.setFloat(\"strength\", this.lensFlareStrength);\r\n            effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\r\n            effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\r\n\r\n            // Shift\r\n            resolution.x = (<PostProcess>this.lensFlarePostProcess).width;\r\n            resolution.y = (<PostProcess>this.lensFlarePostProcess).height;\r\n            effect.setVector2(\"resolution\", resolution);\r\n\r\n            effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\r\n        };\r\n\r\n        // Compose\r\n        var scaleBias1 = Matrix.FromValues(\r\n            2.0, 0.0, -1.0, 0.0,\r\n            0.0, 2.0, -1.0, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0\r\n        );\r\n\r\n        var scaleBias2 = Matrix.FromValues(\r\n            0.5, 0.0, 0.5, 0.0,\r\n            0.0, 0.5, 0.5, 0.0,\r\n            0.0, 0.0, 1.0, 0.0,\r\n            0.0, 0.0, 0.0, 1.0\r\n        );\r\n\r\n        this.lensFlareComposePostProcess.onApply = (effect: Effect) => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\r\n            effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\r\n            effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\r\n\r\n            // Lens start rotation matrix\r\n            var camerax = (<Vector4>this._scene.activeCamera.getViewMatrix().getRow(0));\r\n            var cameraz = (<Vector4>this._scene.activeCamera.getViewMatrix().getRow(2));\r\n            var camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\r\n            camRot *= 4.0;\r\n\r\n            var starRotation = Matrix.FromValues(\r\n                Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0,\r\n                Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0,\r\n                0.0, 0.0, 1.0, 0.0,\r\n                0.0, 0.0, 0.0, 1.0\r\n            );\r\n\r\n            var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\r\n\r\n            effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\r\n\r\n            this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\r\n        };\r\n    }\r\n\r\n    // Create depth-of-field post-process\r\n    private _createDepthOfFieldPostProcess(scene: Scene, ratio: number): void {\r\n        this.depthOfFieldPostProcess = new PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", 0);\r\n        this.depthOfFieldPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\r\n            effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n\r\n            effect.setFloat(\"distance\", this.depthOfFieldDistance);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", () => { return this.depthOfFieldPostProcess; }, true));\r\n    }\r\n\r\n    // Create motion blur post-process\r\n    private _createMotionBlurPostProcess(scene: Scene, ratio: number): void {\r\n        if (this._isObjectBasedMotionBlur) {\r\n            const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\r\n            mb.motionStrength = this.motionStrength;\r\n            mb.motionBlurSamples = this.motionBlurSamples;\r\n            this.motionBlurPostProcess = mb;\r\n        } else {\r\n            this.motionBlurPostProcess = new PostProcess(\"HDRMotionBlur\", \"standard\",\r\n                [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"],\r\n                [\"depthSampler\"],\r\n                ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), 0);\r\n\r\n            var motionScale: number = 0;\r\n            var prevViewProjection = Matrix.Identity();\r\n            var invViewProjection = Matrix.Identity();\r\n            var viewProjection = Matrix.Identity();\r\n            var screenSize = Vector2.Zero();\r\n\r\n            this.motionBlurPostProcess.onApply = (effect: Effect) => {\r\n                viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\r\n\r\n                viewProjection.invertToRef(invViewProjection);\r\n                effect.setMatrix(\"inverseViewProjection\", invViewProjection);\r\n\r\n                effect.setMatrix(\"prevViewProjection\", prevViewProjection);\r\n                prevViewProjection = viewProjection;\r\n\r\n                screenSize.x = (<PostProcess>this.motionBlurPostProcess).width;\r\n                screenSize.y = (<PostProcess>this.motionBlurPostProcess).height;\r\n                effect.setVector2(\"screenSize\", screenSize);\r\n\r\n                motionScale = scene.getEngine().getFps() / 60.0;\r\n                effect.setFloat(\"motionScale\", motionScale);\r\n                effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n                effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n            };\r\n        }\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", () => { return this.motionBlurPostProcess; }, true));\r\n    }\r\n\r\n    private _getDepthTexture(): Texture {\r\n        if (this._scene.getEngine().getCaps().drawBuffersExtension) {\r\n            let renderer = <GeometryBufferRenderer>this._scene.enableGeometryBufferRenderer();\r\n            return renderer.getGBuffer().textures[0];\r\n        }\r\n\r\n        return this._scene.enableDepthRenderer().getDepthMap();\r\n    }\r\n\r\n    private _disposePostProcesses(): void {\r\n        for (var i = 0; i < this._cameras.length; i++) {\r\n            var camera = this._cameras[i];\r\n\r\n            if (this.originalPostProcess) { this.originalPostProcess.dispose(camera); }\r\n            if (this.screenSpaceReflectionPostProcess) { this.screenSpaceReflectionPostProcess.dispose(camera); }\r\n\r\n            if (this.downSampleX4PostProcess) { this.downSampleX4PostProcess.dispose(camera); }\r\n            if (this.brightPassPostProcess) { this.brightPassPostProcess.dispose(camera); }\r\n            if (this.textureAdderPostProcess) { this.textureAdderPostProcess.dispose(camera); }\r\n\r\n            if (this.volumetricLightPostProcess) { this.volumetricLightPostProcess.dispose(camera); }\r\n            if (this.volumetricLightSmoothXPostProcess) { this.volumetricLightSmoothXPostProcess.dispose(camera); }\r\n            if (this.volumetricLightSmoothYPostProcess) { this.volumetricLightSmoothYPostProcess.dispose(camera); }\r\n            if (this.volumetricLightMergePostProces) { this.volumetricLightMergePostProces.dispose(camera); }\r\n            if (this.volumetricLightFinalPostProcess) { this.volumetricLightFinalPostProcess.dispose(camera); }\r\n\r\n            if (this.lensFlarePostProcess) { this.lensFlarePostProcess.dispose(camera); }\r\n            if (this.lensFlareComposePostProcess) { this.lensFlareComposePostProcess.dispose(camera); }\r\n\r\n            for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\r\n                this.luminanceDownSamplePostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            if (this.luminancePostProcess) { this.luminancePostProcess.dispose(camera); }\r\n            if (this.hdrPostProcess) { this.hdrPostProcess.dispose(camera); }\r\n            if (this.hdrFinalPostProcess) { this.hdrFinalPostProcess.dispose(camera); }\r\n\r\n            if (this.depthOfFieldPostProcess) { this.depthOfFieldPostProcess.dispose(camera); }\r\n\r\n            if (this.motionBlurPostProcess) { this.motionBlurPostProcess.dispose(camera); }\r\n\r\n            if (this.fxaaPostProcess) { this.fxaaPostProcess.dispose(camera); }\r\n\r\n            for (var j = 0; j < this.blurHPostProcesses.length; j++) {\r\n                this.blurHPostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            for (var j = 0; j < this.blurVPostProcesses.length; j++) {\r\n                this.blurVPostProcesses[j].dispose(camera);\r\n            }\r\n        }\r\n\r\n        this.originalPostProcess = null;\r\n        this.downSampleX4PostProcess = null;\r\n        this.brightPassPostProcess = null;\r\n        this.textureAdderPostProcess = null;\r\n        this.textureAdderFinalPostProcess = null;\r\n        this.volumetricLightPostProcess = null;\r\n        this.volumetricLightSmoothXPostProcess = null;\r\n        this.volumetricLightSmoothYPostProcess = null;\r\n        this.volumetricLightMergePostProces = null;\r\n        this.volumetricLightFinalPostProcess = null;\r\n        this.lensFlarePostProcess = null;\r\n        this.lensFlareComposePostProcess = null;\r\n        this.luminancePostProcess = null;\r\n        this.hdrPostProcess = null;\r\n        this.hdrFinalPostProcess = null;\r\n        this.depthOfFieldPostProcess = null;\r\n        this.motionBlurPostProcess = null;\r\n        this.fxaaPostProcess = null;\r\n        this.screenSpaceReflectionPostProcess = null;\r\n\r\n        this.luminanceDownSamplePostProcesses = [];\r\n        this.blurHPostProcesses = [];\r\n        this.blurVPostProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this._disposePostProcesses();\r\n\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        if (this.sourceLight) {\r\n            serializationObject.sourceLightId = this.sourceLight.id;\r\n        }\r\n\r\n        if (this.screenSpaceReflectionPostProcess) {\r\n            serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\r\n        }\r\n\r\n        serializationObject.customType = \"StandardRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline {\r\n        var p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\r\n\r\n        if (source.sourceLightId) {\r\n            p.sourceLight = <SpotLight | DirectionalLight>scene.getLightByID(source.sourceLightId);\r\n        }\r\n\r\n        if (source.screenSpaceReflectionPostProcess) {\r\n            SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Luminance steps\r\n     */\r\n    public static LuminanceSteps: number = 6;\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.StandardRenderingPipeline\"] = StandardRenderingPipeline;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}