{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { ThinEngine } from \"../../Engines/thinEngine\";\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Logger } from '../../Misc/logger';\nimport { FileTools } from '../../Misc/fileTools';\n\nThinEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown);\n  internalTexture.isCube = true;\n\n  if (this.webGLVersion === 1) {\n    Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\n    return internalTexture;\n  }\n\n  var internalOptions = __assign({\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false\n  }, options);\n\n  var gl = this._gl;\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\n\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction); // Create the depth/stencil buffer\n\n\n  for (var face = 0; face < 6; face++) {\n    if (internalOptions.generateStencil) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\n    }\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  return internalTexture;\n};\n\nThinEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var onload = function (data) {\n    loadedFiles[index] = data;\n    loadedFiles._internalCount++;\n\n    if (loadedFiles._internalCount === 6) {\n      onfinish(loadedFiles);\n    }\n  };\n\n  var onerror = function (request, exception) {\n    if (onErrorCallBack && request) {\n      onErrorCallBack(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  this._loadFile(url, onload, undefined, undefined, true, onerror);\n};\n\nThinEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedFiles = [];\n  loadedFiles._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\n  }\n};\n\nThinEngine.prototype._cascadeLoadImgs = function (scene, onfinish, files, onError, mimeType) {\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  var loadedImages = [];\n  loadedImages._internalCount = 0;\n\n  for (var index = 0; index < 6; index++) {\n    this._partialLoadImg(files[index], index, loadedImages, scene, onfinish, onError, mimeType);\n  }\n};\n\nThinEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, onfinish, onErrorCallBack, mimeType) {\n  if (onErrorCallBack === void 0) {\n    onErrorCallBack = null;\n  }\n\n  var img;\n\n  var onload = function () {\n    if (img) {\n      loadedImages[index] = img;\n      loadedImages._internalCount++;\n\n      if (scene) {\n        scene._removePendingData(img);\n      }\n    }\n\n    if (loadedImages._internalCount === 6) {\n      onfinish(loadedImages);\n    }\n  };\n\n  var onerror = function (message, exception) {\n    if (scene) {\n      scene._removePendingData(img);\n    }\n\n    if (onErrorCallBack) {\n      onErrorCallBack(message, exception);\n    }\n  };\n\n  img = FileTools.LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\n\n  if (scene && img) {\n    scene._addPendingData(img);\n  }\n};\n\nThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap) {\n  var gl = this._gl;\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  texture.samplingMode = loadMipmap ? 3 : 2;\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n};\n\nThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, loaderOptions) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (forcedExtension === void 0) {\n    forcedExtension = null;\n  }\n\n  if (createPolynomials === void 0) {\n    createPolynomials = false;\n  }\n\n  if (lodScale === void 0) {\n    lodScale = 0;\n  }\n\n  if (lodOffset === void 0) {\n    lodOffset = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = null;\n  }\n\n  var gl = this._gl;\n  var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n  texture.isCube = true;\n  texture.url = rootUrl;\n  texture.generateMipMaps = !noMipmap;\n  texture._lodGenerationScale = lodScale;\n  texture._lodGenerationOffset = lodOffset;\n\n  if (!this._doNotHandleContextLost) {\n    texture._extension = forcedExtension;\n    texture._files = files;\n  }\n\n  var originalRootUrl = rootUrl;\n\n  if (this._transformTextureUrl && !fallback) {\n    rootUrl = this._transformTextureUrl(rootUrl);\n  }\n\n  var lastDot = rootUrl.lastIndexOf('.');\n  var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n  var loader = null;\n\n  for (var _i = 0, _a = ThinEngine._TextureLoaders; _i < _a.length; _i++) {\n    var availableLoader = _a[_i];\n\n    if (availableLoader.canLoad(extension)) {\n      loader = availableLoader;\n      break;\n    }\n  }\n\n  var onInternalError = function (request, exception) {\n    if (rootUrl === originalRootUrl) {\n      if (onError && request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    } else {\n      // fall back to the original url if the transformed url fails to load\n      Logger.Warn(\"Failed to load \" + rootUrl + \", falling back to the \" + originalRootUrl);\n\n      _this.createCubeTexture(originalRootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, loaderOptions);\n    }\n  };\n\n  if (loader) {\n    var onloaddata_1 = function (data) {\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\n    };\n\n    if (files && files.length === 6) {\n      if (loader.supportCascades) {\n        this._cascadeLoadFiles(scene, function (images) {\n          return onloaddata_1(images.map(function (image) {\n            return new Uint8Array(image);\n          }));\n        }, files, onError);\n      } else {\n        if (onError) {\n          onError(\"Textures type does not support cascades.\");\n        } else {\n          Logger.Warn(\"Texture loader does not support cascades.\");\n        }\n      }\n    } else {\n      this._loadFile(rootUrl, function (data) {\n        return onloaddata_1(new Uint8Array(data));\n      }, undefined, undefined, true, onInternalError);\n    }\n  } else {\n    if (!files) {\n      throw new Error(\"Cannot load cubemap because files were not defined\");\n    }\n\n    this._cascadeLoadImgs(scene, function (imgs) {\n      var width = _this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize) : imgs[0].width;\n      var height = width;\n      var faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      _this._unpackFlipY(false);\n\n      var internalFormat = format ? _this._getInternalFormat(format) : _this._gl.RGBA;\n\n      for (var index = 0; index < faces.length; index++) {\n        if (imgs[index].width !== width || imgs[index].height !== height) {\n          _this._prepareWorkingCanvas();\n\n          if (!_this._workingCanvas || !_this._workingContext) {\n            Logger.Warn(\"Cannot create canvas to resize texture.\");\n            return;\n          }\n\n          _this._workingCanvas.width = width;\n          _this._workingCanvas.height = height;\n\n          _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n\n          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);\n        } else {\n          gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, imgs[index]);\n        }\n      }\n\n      if (!noMipmap) {\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n      }\n\n      _this._setCubeMapTextureParams(texture, !noMipmap);\n\n      texture.width = width;\n      texture.height = height;\n      texture.isReady = true;\n\n      if (format) {\n        texture.format = format;\n      }\n\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n\n      if (onLoad) {\n        onLoad();\n      }\n    }, files, onError);\n  }\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Extensions/engine.cubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { Nullable } from '../../types';\r\nimport { Scene } from '../../scene';\r\nimport { IInternalTextureLoader } from '../../Materials/Textures/internalTextureLoader';\r\nimport { FileTools } from '../../Misc/fileTools';\r\nimport { DepthTextureCreationOptions } from '../depthTextureCreationOptions';\r\nimport { IWebRequest } from '../../Misc/interfaces/iWebRequest';\r\n\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a depth stencil cube texture.\r\n         * This is only available in WebGL 2.\r\n         * @param size The size of face edge in the cube texture.\r\n         * @param options The options defining the cube texture.\r\n         * @returns The cube texture\r\n         */\r\n        _createDepthStencilCubeTexture(size: number, options: DepthTextureCreationOptions): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n         * @param loaderOptions options to be passed to the loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean | undefined,\r\n            onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined, forcedExtension: any, createPolynomials: boolean, lodScale: number, lodOffset: number, fallback: Nullable<InternalTexture>, loaderOptions: any): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined, forcedExtension: any): InternalTexture;\r\n\r\n        /**\r\n         * Creates a cube texture\r\n         * @param rootUrl defines the url where the files to load is located\r\n         * @param scene defines the current scene\r\n         * @param files defines the list of files to load (1 per face)\r\n         * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n         * @param onLoad defines an optional callback raised when the texture is loaded\r\n         * @param onError defines an optional callback raised if there is an issue to load the texture\r\n         * @param format defines the format of the data\r\n         * @param forcedExtension defines the extension to use to pick the right loader\r\n         * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n         * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n         * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createCubeTexture(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>, onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined, forcedExtension: any, createPolynomials: boolean, lodScale: number, lodOffset: number): InternalTexture;\r\n\r\n        /** @hidden */\r\n        _partialLoadFile(url: string, index: number, loadedFiles: ArrayBuffer[], onfinish: (files: ArrayBuffer[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @hidden */\r\n        _cascadeLoadImgs(scene: Nullable<Scene>, onfinish: (images: HTMLImageElement[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>, mimeType?: string): void;\r\n\r\n        /** @hidden */\r\n        _partialLoadImg(url: string, index: number, loadedImages: HTMLImageElement[], scene: Nullable<Scene>, onfinish: (images: HTMLImageElement[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void>, mimeType?: string): void;\r\n\r\n        /**\r\n         * @hidden\r\n         */\r\n        _setCubeMapTextureParams(texture: InternalTexture, loadMipmap: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype._createDepthStencilCubeTexture = function(size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown);\r\n    internalTexture.isCube = true;\r\n\r\n    if (this.webGLVersion === 1) {\r\n        Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\r\n        return internalTexture;\r\n    }\r\n\r\n    var internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        ...options\r\n    };\r\n\r\n    var gl = this._gl;\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\r\n\r\n    this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\r\n\r\n    // Create the depth/stencil buffer\r\n    for (var face = 0; face < 6; face++) {\r\n        if (internalOptions.generateStencil) {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\r\n        }\r\n        else {\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\r\n        }\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nThinEngine.prototype._partialLoadFile = function(url: string, index: number, loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null): void {\r\n    var onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadFiles = function(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void> = null): void {\r\n    var loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._cascadeLoadImgs = function(scene: Nullable<Scene>,\r\n    onfinish: (images: HTMLImageElement[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void> = null, mimeType?: string) {\r\n\r\n    var loadedImages: HTMLImageElement[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._partialLoadImg = function(url: string, index: number, loadedImages: HTMLImageElement[], scene: Nullable<Scene>,\r\n    onfinish: (images: HTMLImageElement[]) => void, onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null, mimeType?: string) {\r\n\r\n    var img: Nullable<HTMLImageElement>;\r\n\r\n    var onload = () => {\r\n        if (img) {\r\n            loadedImages[index] = img;\r\n            (<any>loadedImages)._internalCount++;\r\n\r\n            if (scene) {\r\n                scene._removePendingData(img);\r\n            }\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6) {\r\n            onfinish(loadedImages);\r\n        }\r\n    };\r\n\r\n    var onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene._removePendingData(img);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    img = FileTools.LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene && img) {\r\n        scene._addPendingData(img);\r\n    }\r\n};\r\n\r\nThinEngine.prototype._setCubeMapTextureParams = function(texture: InternalTexture, loadMipmap: boolean): void {\r\n    var gl = this._gl;\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    texture.samplingMode = loadMipmap ? 3 : 2;\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n};\r\n\r\nThinEngine.prototype.createCubeTexture = function(rootUrl: string, scene: Nullable<Scene>, files: Nullable<string[]>, noMipmap?: boolean, onLoad: Nullable<(data?: any) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null, format?: number, forcedExtension: any = null, createPolynomials: boolean = false, lodScale: number = 0,\r\n        lodOffset: number = 0, fallback: Nullable<InternalTexture> = null, loaderOptions?: any): InternalTexture\r\n{\r\n    const gl = this._gl;\r\n\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const lastDot = rootUrl.lastIndexOf('.');\r\n    const extension = forcedExtension ? forcedExtension : (lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\");\r\n\r\n    let loader: Nullable<IInternalTextureLoader> = null;\r\n    for (let availableLoader of ThinEngine._TextureLoaders) {\r\n        if (availableLoader.canLoad(extension)) {\r\n            loader = availableLoader;\r\n            break;\r\n        }\r\n    }\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (onError && request) {\r\n                onError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        }\r\n        else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTexture(originalRootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, loaderOptions);\r\n        }\r\n    };\r\n\r\n    if (loader) {\r\n        const onloaddata = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            loader!.loadCubeData(data, texture, createPolynomials, onLoad, onError);\r\n        };\r\n        if (files && files.length === 6) {\r\n            if (loader.supportCascades) {\r\n                this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);\r\n            }\r\n            else {\r\n                if (onError) {\r\n                    onError(\"Textures type does not support cascades.\");\r\n                } else {\r\n                    Logger.Warn(\"Texture loader does not support cascades.\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n        }\r\n    }\r\n    else {\r\n        if (!files) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(scene, (imgs) => {\r\n            const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\r\n            const height = width;\r\n\r\n            const faces = [\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n                gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z\r\n            ];\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const internalFormat = format ? this._getInternalFormat(format) : this._gl.RGBA;\r\n            for (var index = 0; index < faces.length; index++) {\r\n                if (imgs[index].width !== width || imgs[index].height !== height) {\r\n\r\n                    this._prepareWorkingCanvas();\r\n\r\n                    if (!this._workingCanvas || !this._workingContext) {\r\n                        Logger.Warn(\"Cannot create canvas to resize texture.\");\r\n                        return;\r\n                    }\r\n                    this._workingCanvas.width = width;\r\n                    this._workingCanvas.height = height;\r\n\r\n                    this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\r\n                    gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, this._workingCanvas);\r\n                } else {\r\n                    gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, imgs[index]);\r\n                }\r\n            }\r\n\r\n            if (!noMipmap) {\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            }\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n\r\n            texture.width = width;\r\n            texture.height = height;\r\n            texture.isReady = true;\r\n            if (format) {\r\n                texture.format = format;\r\n            }\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        }, files, onError);\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}