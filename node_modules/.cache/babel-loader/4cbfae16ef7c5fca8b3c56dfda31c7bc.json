{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Tools } from \"./tools\";\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video\r\n */\n\nvar VideoRecorder =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n   * @param engine Defines the BabylonJS Engine you wish to record.\r\n   * @param options Defines options that can be used to customize the capture.\r\n   */\n  function VideoRecorder(engine, options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (!VideoRecorder.IsSupported(engine)) {\n      throw \"Your browser does not support recording so far.\";\n    }\n\n    var canvas = engine.getRenderingCanvas();\n\n    if (!canvas) {\n      throw \"The babylon engine must have a canvas to be recorded\";\n    }\n\n    this._canvas = canvas;\n    this._canvas.isRecording = false;\n    this._options = __assign(__assign({}, VideoRecorder._defaultOptions), options);\n\n    var stream = this._canvas.captureStream(this._options.fps);\n\n    if (this._options.audioTracks) {\n      for (var _i = 0, _a = this._options.audioTracks; _i < _a.length; _i++) {\n        var track = _a[_i];\n        stream.addTrack(track);\n      }\n    }\n\n    this._mediaRecorder = new MediaRecorder(stream, {\n      mimeType: this._options.mimeType\n    });\n    this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\n    this._mediaRecorder.onerror = this._handleError.bind(this);\n    this._mediaRecorder.onstop = this._handleStop.bind(this);\n  }\n  /**\r\n   * Returns whether or not the VideoRecorder is available in your browser.\r\n   * @param engine Defines the Babylon Engine.\r\n   * @returns true if supported otherwise false.\r\n   */\n\n\n  VideoRecorder.IsSupported = function (engine) {\n    var canvas = engine.getRenderingCanvas();\n    return !!canvas && typeof canvas.captureStream === \"function\";\n  };\n\n  Object.defineProperty(VideoRecorder.prototype, \"isRecording\", {\n    /**\r\n     * True when a recording is already in progress.\r\n     */\n    get: function () {\n      return !!this._canvas && this._canvas.isRecording;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n   */\n\n  VideoRecorder.prototype.stopRecording = function () {\n    if (!this._canvas || !this._mediaRecorder) {\n      return;\n    }\n\n    if (!this.isRecording) {\n      return;\n    }\n\n    this._canvas.isRecording = false;\n\n    this._mediaRecorder.stop();\n  };\n  /**\r\n   * Starts recording the canvas for a max duration specified in parameters.\r\n   * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n   * If null no automatic download will start and you can rely on the promise to get the data back.\r\n   * @param maxDuration Defines the maximum recording time in seconds.\r\n   * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n   * @return A promise callback at the end of the recording with the video data in Blob.\r\n   */\n\n\n  VideoRecorder.prototype.startRecording = function (fileName, maxDuration) {\n    var _this = this;\n\n    if (fileName === void 0) {\n      fileName = \"babylonjs.webm\";\n    }\n\n    if (maxDuration === void 0) {\n      maxDuration = 7;\n    }\n\n    if (!this._canvas || !this._mediaRecorder) {\n      throw \"Recorder has already been disposed\";\n    }\n\n    if (this.isRecording) {\n      throw \"Recording already in progress\";\n    }\n\n    if (maxDuration > 0) {\n      setTimeout(function () {\n        _this.stopRecording();\n      }, maxDuration * 1000);\n    }\n\n    this._fileName = fileName;\n    this._recordedChunks = [];\n    this._resolve = null;\n    this._reject = null;\n    this._canvas.isRecording = true;\n\n    this._mediaRecorder.start(this._options.recordChunckSize);\n\n    return new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  };\n  /**\r\n   * Releases internal resources used during the recording.\r\n   */\n\n\n  VideoRecorder.prototype.dispose = function () {\n    this._canvas = null;\n    this._mediaRecorder = null;\n    this._recordedChunks = [];\n    this._fileName = null;\n    this._resolve = null;\n    this._reject = null;\n  };\n\n  VideoRecorder.prototype._handleDataAvailable = function (event) {\n    if (event.data.size > 0) {\n      this._recordedChunks.push(event.data);\n    }\n  };\n\n  VideoRecorder.prototype._handleError = function (event) {\n    this.stopRecording();\n\n    if (this._reject) {\n      this._reject(event.error);\n    } else {\n      throw new event.error();\n    }\n  };\n\n  VideoRecorder.prototype._handleStop = function () {\n    this.stopRecording();\n    var superBuffer = new Blob(this._recordedChunks);\n\n    if (this._resolve) {\n      this._resolve(superBuffer);\n    }\n\n    window.URL.createObjectURL(superBuffer);\n\n    if (this._fileName) {\n      Tools.Download(superBuffer, this._fileName);\n    }\n  };\n\n  VideoRecorder._defaultOptions = {\n    mimeType: \"video/webm\",\n    fps: 25,\n    recordChunckSize: 3000\n  };\n  return VideoRecorder;\n}();\n\nexport { VideoRecorder };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/videoRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\ninterface MediaRecorder {\r\n    /** Starts recording */\r\n    start(timeSlice: number): void;\r\n    /** Stops recording */\r\n    stop(): void;\r\n\r\n    /** Event raised when an error arised. */\r\n    onerror: (event: ErrorEvent) => void;\r\n    /** Event raised when the recording stops. */\r\n    onstop: (event: Event) => void;\r\n    /** Event raised when a new chunk of data is available and should be tracked. */\r\n    ondataavailable: (event: Event) => void;\r\n}\r\n\r\ninterface MediaRecorderOptions {\r\n    /** The mime type you want to use as the recording container for the new MediaRecorder. */\r\n    mimeType?: string;\r\n    /** The chosen bitrate for the audio component of the media. */\r\n    audioBitsPerSecond?: number;\r\n    /** The chosen bitrate for the video component of the media. */\r\n    videoBitsPerSecond?: number;\r\n    /** The chosen bitrate for the audio and video components of the media. This can be specified instead of the above two properties.\r\n     * If this is specified along with one or the other of the above properties, this will be used for the one that isn't specified. */\r\n    bitsPerSecond?: number;\r\n}\r\n\r\ninterface MediaRecorderConstructor {\r\n    /**\r\n     * A reference to the prototype.\r\n     */\r\n    readonly prototype: MediaRecorder;\r\n\r\n    /**\r\n     * Creates a new MediaRecorder.\r\n     * @param stream Defines the stream to record.\r\n     * @param options Defines the options for the recorder available in the type MediaRecorderOptions.\r\n     */\r\n    new(stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;\r\n}\r\n\r\n/**\r\n * MediaRecoreder object available in some browsers.\r\n */\r\ndeclare var MediaRecorder: MediaRecorderConstructor;\r\n\r\n/**\r\n * This represents the different options available for the video capture.\r\n */\r\nexport interface VideoRecorderOptions {\r\n    /** Defines the mime type of the video. */\r\n    mimeType: string;\r\n    /** Defines the FPS the video should be recorded at. */\r\n    fps: number;\r\n    /** Defines the chunk size for the recording data. */\r\n    recordChunckSize: number;\r\n    /** The audio tracks to attach to the recording. */\r\n    audioTracks?: MediaStreamTrack[];\r\n}\r\n\r\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/render_scene_on_a_video\r\n */\r\nexport class VideoRecorder {\r\n\r\n    private static readonly _defaultOptions = {\r\n        mimeType: \"video/webm\",\r\n        fps: 25,\r\n        recordChunckSize: 3000\r\n    };\r\n\r\n    /**\r\n     * Returns whether or not the VideoRecorder is available in your browser.\r\n     * @param engine Defines the Babylon Engine.\r\n     * @returns true if supported otherwise false.\r\n     */\r\n    public static IsSupported(engine: Engine): boolean {\r\n        const canvas = engine.getRenderingCanvas();\r\n        return (!!canvas && typeof (<any>canvas).captureStream === \"function\");\r\n    }\r\n\r\n    private readonly _options: VideoRecorderOptions;\r\n    private _canvas: Nullable<HTMLCanvasElement>;\r\n    private _mediaRecorder: Nullable<MediaRecorder>;\r\n\r\n    private _recordedChunks: any[];\r\n    private _fileName: Nullable<string>;\r\n    private _resolve: Nullable<(blob: Blob) => void>;\r\n    private _reject: Nullable<(error: any) => void>;\r\n\r\n    /**\r\n     * True when a recording is already in progress.\r\n     */\r\n    public get isRecording(): boolean {\r\n        return !!this._canvas && this._canvas.isRecording;\r\n    }\r\n\r\n    /**\r\n     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n     * @param engine Defines the BabylonJS Engine you wish to record.\r\n     * @param options Defines options that can be used to customize the capture.\r\n     */\r\n    constructor(engine: Engine, options: Nullable<VideoRecorderOptions> = null) {\r\n        if (!VideoRecorder.IsSupported(engine)) {\r\n            throw \"Your browser does not support recording so far.\";\r\n        }\r\n\r\n        const canvas = engine.getRenderingCanvas();\r\n        if (!canvas) {\r\n            throw \"The babylon engine must have a canvas to be recorded\";\r\n        }\r\n\r\n        this._canvas = canvas;\r\n        this._canvas.isRecording = false;\r\n\r\n        this._options = {\r\n            ...VideoRecorder._defaultOptions,\r\n            ...options\r\n        };\r\n\r\n        const stream = this._canvas.captureStream(this._options.fps);\r\n        if (this._options.audioTracks) {\r\n            for (let track of this._options.audioTracks) {\r\n                stream.addTrack(track);\r\n            }\r\n        }\r\n\r\n        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });\r\n        this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\r\n        this._mediaRecorder.onerror = this._handleError.bind(this);\r\n        this._mediaRecorder.onstop = this._handleStop.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n     */\r\n    public stopRecording(): void {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isRecording) {\r\n            return;\r\n        }\r\n\r\n        this._canvas.isRecording = false;\r\n        this._mediaRecorder.stop();\r\n    }\r\n\r\n    /**\r\n     * Starts recording the canvas for a max duration specified in parameters.\r\n     * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n     * If null no automatic download will start and you can rely on the promise to get the data back.\r\n     * @param maxDuration Defines the maximum recording time in seconds.\r\n     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n     * @return A promise callback at the end of the recording with the video data in Blob.\r\n     */\r\n    public startRecording(fileName: Nullable<string> = \"babylonjs.webm\", maxDuration = 7): Promise<Blob> {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            throw \"Recorder has already been disposed\";\r\n        }\r\n\r\n        if (this.isRecording) {\r\n            throw \"Recording already in progress\";\r\n        }\r\n\r\n        if (maxDuration > 0) {\r\n            setTimeout(() => {\r\n                this.stopRecording();\r\n            }, maxDuration * 1000);\r\n        }\r\n\r\n        this._fileName = fileName;\r\n        this._recordedChunks = [];\r\n        this._resolve = null;\r\n        this._reject = null;\r\n\r\n        this._canvas.isRecording = true;\r\n        this._mediaRecorder.start(this._options.recordChunckSize);\r\n\r\n        return new Promise<Blob>((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases internal resources used during the recording.\r\n     */\r\n    public dispose() {\r\n        this._canvas = null;\r\n        this._mediaRecorder = null;\r\n\r\n        this._recordedChunks = [];\r\n        this._fileName = null;\r\n        this._resolve = null;\r\n        this._reject = null;\r\n    }\r\n\r\n    private _handleDataAvailable(event: any): void {\r\n        if (event.data.size > 0) {\r\n            this._recordedChunks.push(event.data);\r\n        }\r\n    }\r\n\r\n    private _handleError(event: ErrorEvent): void {\r\n        this.stopRecording();\r\n\r\n        if (this._reject) {\r\n            this._reject(event.error);\r\n        }\r\n        else {\r\n            throw new event.error();\r\n        }\r\n    }\r\n\r\n    private _handleStop(): void {\r\n        this.stopRecording();\r\n\r\n        const superBuffer = new Blob(this._recordedChunks);\r\n        if (this._resolve) {\r\n            this._resolve(superBuffer);\r\n        }\r\n\r\n        window.URL.createObjectURL(superBuffer);\r\n\r\n        if (this._fileName) {\r\n            Tools.Download(superBuffer, this._fileName);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}