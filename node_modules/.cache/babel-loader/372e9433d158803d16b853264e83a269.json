{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { VertexBuffer } from '../Meshes/buffer';\nimport { Viewport } from '../Maths/math.viewport';\nimport { Observable } from '../Misc/observable';\nimport { Effect } from './effect'; // Prevents ES6 Crash if not imported.\n\nimport \"../Shaders/postprocess.vertex\";\n/**\r\n * Helper class to render one or more effects.\r\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\r\n */\n\nvar EffectRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an effect renderer\r\n   * @param engine the engine to use for rendering\r\n   * @param options defines the options of the effect renderer\r\n   */\n  function EffectRenderer(engine, options) {\n    var _a;\n\n    if (options === void 0) {\n      options = EffectRenderer._DefaultOptions;\n    }\n\n    this.engine = engine;\n    this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n    options = __assign(__assign({}, EffectRenderer._DefaultOptions), options);\n    this._vertexBuffers = (_a = {}, _a[VertexBuffer.PositionKind] = new VertexBuffer(engine, options.positions, VertexBuffer.PositionKind, false, false, 2), _a);\n    this._indexBuffer = engine.createIndexBuffer(options.indices);\n  }\n  /**\r\n   * Sets the current viewport in normalized coordinates 0-1\r\n   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\r\n   */\n\n\n  EffectRenderer.prototype.setViewport = function (viewport) {\n    if (viewport === void 0) {\n      viewport = this._fullscreenViewport;\n    }\n\n    this.engine.setViewport(viewport);\n  };\n  /**\r\n   * Binds the embedded attributes buffer to the effect.\r\n   * @param effect Defines the effect to bind the attributes for\r\n   */\n\n\n  EffectRenderer.prototype.bindBuffers = function (effect) {\n    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n  };\n  /**\r\n   * Sets the current effect wrapper to use during draw.\r\n   * The effect needs to be ready before calling this api.\r\n   * This also sets the default full screen position attribute.\r\n   * @param effectWrapper Defines the effect to draw with\r\n   */\n\n\n  EffectRenderer.prototype.applyEffectWrapper = function (effectWrapper) {\n    this.engine.depthCullingState.depthTest = false;\n    this.engine.stencilState.stencilTest = false;\n    this.engine.enableEffect(effectWrapper.effect);\n    this.bindBuffers(effectWrapper.effect);\n    effectWrapper.onApplyObservable.notifyObservers({});\n  };\n  /**\r\n   * Restores engine states\r\n   */\n\n\n  EffectRenderer.prototype.restoreStates = function () {\n    this.engine.depthCullingState.depthTest = true;\n    this.engine.stencilState.stencilTest = true;\n  };\n  /**\r\n   * Draws a full screen quad.\r\n   */\n\n\n  EffectRenderer.prototype.draw = function () {\n    this.engine.drawElementsType(0, 0, 6);\n  };\n\n  EffectRenderer.prototype.isRenderTargetTexture = function (texture) {\n    return texture.renderList !== undefined;\n  };\n  /**\r\n   * renders one or more effects to a specified texture\r\n   * @param effectWrapper the effect to renderer\r\n   * @param outputTexture texture to draw to, if null it will render to the screen.\r\n   */\n\n\n  EffectRenderer.prototype.render = function (effectWrapper, outputTexture) {\n    if (outputTexture === void 0) {\n      outputTexture = null;\n    } // Ensure effect is ready\n\n\n    if (!effectWrapper.effect.isReady()) {\n      return;\n    } // Reset state\n\n\n    this.setViewport();\n    var out = outputTexture === null ? null : this.isRenderTargetTexture(outputTexture) ? outputTexture.getInternalTexture() : outputTexture;\n\n    if (out) {\n      this.engine.bindFramebuffer(out);\n    }\n\n    this.applyEffectWrapper(effectWrapper);\n    this.draw();\n\n    if (out) {\n      this.engine.unBindFramebuffer(out);\n    }\n\n    this.restoreStates();\n  };\n  /**\r\n   * Disposes of the effect renderer\r\n   */\n\n\n  EffectRenderer.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      delete this._vertexBuffers[VertexBuffer.PositionKind];\n    }\n\n    if (this._indexBuffer) {\n      this.engine._releaseBuffer(this._indexBuffer);\n    }\n  }; // Fullscreen quad buffers by default.\n\n\n  EffectRenderer._DefaultOptions = {\n    positions: [1, 1, -1, 1, -1, -1, 1, -1],\n    indices: [0, 1, 2, 0, 2, 3]\n  };\n  return EffectRenderer;\n}();\n\nexport { EffectRenderer };\n/**\r\n * Wraps an effect to be used for rendering\r\n */\n\nvar EffectWrapper =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an effect to be renderer\r\n   * @param creationOptions options to create the effect\r\n   */\n  function EffectWrapper(creationOptions) {\n    var _this = this;\n    /**\r\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\r\n     */\n\n\n    this.onApplyObservable = new Observable();\n    var effectCreationOptions;\n    var uniformNames = creationOptions.uniformNames || [];\n\n    if (creationOptions.vertexShader) {\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertexSource: creationOptions.vertexShader,\n        spectorName: creationOptions.name || \"effectWrapper\"\n      };\n    } else {\n      // Default scale to use in post process vertex shader.\n      uniformNames.push(\"scale\");\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertex: \"postprocess\",\n        spectorName: creationOptions.name || \"effectWrapper\"\n      }; // Sets the default scale to identity for the post process vertex shader.\n\n      this.onApplyObservable.add(function () {\n        _this.effect.setFloat2(\"scale\", 1, 1);\n      });\n    }\n\n    var defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\n\n    if (creationOptions.useShaderStore) {\n      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\n\n      if (!effectCreationOptions.vertex) {\n        effectCreationOptions.vertex = effectCreationOptions.vertexSource;\n      }\n\n      delete effectCreationOptions.fragmentSource;\n      delete effectCreationOptions.vertexSource;\n      this.effect = creationOptions.engine.createEffect(effectCreationOptions.spectorName, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, defines, undefined, creationOptions.onCompiled);\n    } else {\n      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, undefined, creationOptions.onCompiled);\n    }\n  }\n  /**\r\n  * Disposes of the effect wrapper\r\n  */\n\n\n  EffectWrapper.prototype.dispose = function () {\n    this.effect.dispose();\n  };\n\n  return EffectWrapper;\n}();\n\nexport { EffectWrapper };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/effectRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from '../types';\r\nimport { InternalTexture } from './Textures/internalTexture';\r\nimport { RenderTargetTexture } from './Textures/renderTargetTexture';\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\nimport { VertexBuffer } from '../Meshes/buffer';\r\nimport { Viewport } from '../Maths/math.viewport';\r\n\r\nimport { Observable } from '../Misc/observable';\r\nimport { Effect } from './effect';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\n\r\n// Prevents ES6 Crash if not imported.\r\nimport \"../Shaders/postprocess.vertex\";\r\n\r\n/**\r\n * Effect Render Options\r\n */\r\nexport interface IEffectRendererOptions {\r\n    /**\r\n     * Defines the vertices positions.\r\n     */\r\n    positions?: number[];\r\n    /**\r\n     * Defines the indices.\r\n     */\r\n    indices?: number[];\r\n}\r\n\r\n/**\r\n * Helper class to render one or more effects.\r\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\r\n */\r\nexport class EffectRenderer {\r\n    // Fullscreen quad buffers by default.\r\n    private static _DefaultOptions: IEffectRendererOptions = {\r\n        positions: [1, 1, -1, 1, -1, -1, 1, -1],\r\n        indices: [0, 1, 2, 0, 2, 3],\r\n    };\r\n\r\n    private _vertexBuffers: {[key: string]: VertexBuffer};\r\n    private _indexBuffer: DataBuffer;\r\n\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n\r\n    /**\r\n     * Creates an effect renderer\r\n     * @param engine the engine to use for rendering\r\n     * @param options defines the options of the effect renderer\r\n     */\r\n    constructor(private engine: ThinEngine, options: IEffectRendererOptions = EffectRenderer._DefaultOptions) {\r\n        options = {\r\n            ...EffectRenderer._DefaultOptions,\r\n            ...options,\r\n        };\r\n\r\n        this._vertexBuffers = {\r\n            [VertexBuffer.PositionKind]: new VertexBuffer(engine, options.positions!, VertexBuffer.PositionKind, false, false, 2),\r\n        };\r\n        this._indexBuffer = engine.createIndexBuffer(options.indices!);\r\n    }\r\n\r\n    /**\r\n     * Sets the current viewport in normalized coordinates 0-1\r\n     * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\r\n     */\r\n    public setViewport(viewport = this._fullscreenViewport): void {\r\n        this.engine.setViewport(viewport);\r\n    }\r\n\r\n    /**\r\n     * Binds the embedded attributes buffer to the effect.\r\n     * @param effect Defines the effect to bind the attributes for\r\n     */\r\n    public bindBuffers(effect: Effect): void {\r\n        this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n    }\r\n\r\n    /**\r\n     * Sets the current effect wrapper to use during draw.\r\n     * The effect needs to be ready before calling this api.\r\n     * This also sets the default full screen position attribute.\r\n     * @param effectWrapper Defines the effect to draw with\r\n     */\r\n    public applyEffectWrapper(effectWrapper: EffectWrapper): void {\r\n        this.engine.depthCullingState.depthTest = false;\r\n        this.engine.stencilState.stencilTest = false;\r\n        this.engine.enableEffect(effectWrapper.effect);\r\n        this.bindBuffers(effectWrapper.effect);\r\n        effectWrapper.onApplyObservable.notifyObservers({});\r\n    }\r\n\r\n    /**\r\n     * Restores engine states\r\n     */\r\n    public restoreStates(): void {\r\n        this.engine.depthCullingState.depthTest = true;\r\n        this.engine.stencilState.stencilTest = true;\r\n    }\r\n\r\n    /**\r\n     * Draws a full screen quad.\r\n     */\r\n    public draw(): void {\r\n        this.engine.drawElementsType(0, 0, 6);\r\n    }\r\n\r\n    private isRenderTargetTexture(texture: InternalTexture | RenderTargetTexture): texture is RenderTargetTexture  {\r\n        return (texture as RenderTargetTexture).renderList !== undefined;\r\n    }\r\n\r\n    /**\r\n     * renders one or more effects to a specified texture\r\n     * @param effectWrapper the effect to renderer\r\n     * @param outputTexture texture to draw to, if null it will render to the screen.\r\n     */\r\n    public render(effectWrapper: EffectWrapper, outputTexture: Nullable<InternalTexture | RenderTargetTexture> = null) {\r\n        // Ensure effect is ready\r\n        if (!effectWrapper.effect.isReady()) {\r\n            return;\r\n        }\r\n\r\n        // Reset state\r\n        this.setViewport();\r\n\r\n        const out = outputTexture === null ? null : this.isRenderTargetTexture(outputTexture) ? outputTexture.getInternalTexture()! : outputTexture;\r\n\r\n        if (out) {\r\n            this.engine.bindFramebuffer(out);\r\n        }\r\n\r\n        this.applyEffectWrapper(effectWrapper);\r\n\r\n        this.draw();\r\n\r\n        if (out) {\r\n            this.engine.unBindFramebuffer(out);\r\n        }\r\n\r\n        this.restoreStates();\r\n    }\r\n\r\n    /**\r\n     * Disposes of the effect renderer\r\n     */\r\n    dispose() {\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            delete this._vertexBuffers[VertexBuffer.PositionKind];\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this.engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to create an EffectWrapper\r\n */\r\ninterface EffectWrapperCreationOptions {\r\n    /**\r\n     * Engine to use to create the effect\r\n     */\r\n    engine: ThinEngine;\r\n    /**\r\n     * Fragment shader for the effect\r\n     */\r\n    fragmentShader: string;\r\n    /**\r\n     * Use the shader store instead of direct source code\r\n     */\r\n    useShaderStore?: boolean;\r\n    /**\r\n     * Vertex shader for the effect\r\n     */\r\n    vertexShader?: string;\r\n    /**\r\n     * Attributes to use in the shader\r\n     */\r\n    attributeNames?: Array<string>;\r\n    /**\r\n     * Uniforms to use in the shader\r\n     */\r\n    uniformNames?: Array<string>;\r\n    /**\r\n     * Texture sampler names to use in the shader\r\n     */\r\n    samplerNames?: Array<string>;\r\n    /**\r\n      * Defines to use in the shader\r\n      */\r\n    defines?: Array<string>;\r\n    /**\r\n      * Callback when effect is compiled\r\n      */\r\n    onCompiled?: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * The friendly name of the effect displayed in Spector.\r\n     */\r\n    name?: string;\r\n}\r\n\r\n/**\r\n * Wraps an effect to be used for rendering\r\n */\r\nexport class EffectWrapper {\r\n    /**\r\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\r\n     */\r\n    public onApplyObservable = new Observable<{}>();\r\n    /**\r\n     * The underlying effect\r\n     */\r\n    public effect: Effect;\r\n\r\n    /**\r\n     * Creates an effect to be renderer\r\n     * @param creationOptions options to create the effect\r\n     */\r\n    constructor(creationOptions: EffectWrapperCreationOptions) {\r\n        let effectCreationOptions: any;\r\n        const uniformNames = creationOptions.uniformNames || [];\r\n\r\n        if (creationOptions.vertexShader) {\r\n            effectCreationOptions = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertexSource: creationOptions.vertexShader,\r\n                spectorName: creationOptions.name || \"effectWrapper\"\r\n            };\r\n        }\r\n        else {\r\n            // Default scale to use in post process vertex shader.\r\n            uniformNames.push(\"scale\");\r\n\r\n            effectCreationOptions = {\r\n                fragmentSource: creationOptions.fragmentShader,\r\n                vertex: \"postprocess\",\r\n                spectorName: creationOptions.name || \"effectWrapper\"\r\n            };\r\n\r\n            // Sets the default scale to identity for the post process vertex shader.\r\n            this.onApplyObservable.add(() => {\r\n                this.effect.setFloat2(\"scale\", 1, 1);\r\n            });\r\n        }\r\n\r\n        const defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\r\n\r\n        if (creationOptions.useShaderStore) {\r\n            effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\r\n            if (!effectCreationOptions.vertex) {\r\n                effectCreationOptions.vertex = effectCreationOptions.vertexSource;\r\n            }\r\n\r\n            delete effectCreationOptions.fragmentSource;\r\n            delete effectCreationOptions.vertexSource;\r\n\r\n            this.effect = creationOptions.engine.createEffect(effectCreationOptions.spectorName,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled\r\n            );\r\n        } else {\r\n            this.effect = new Effect(effectCreationOptions,\r\n                creationOptions.attributeNames || [\"position\"],\r\n                uniformNames,\r\n                creationOptions.samplerNames,\r\n                creationOptions.engine,\r\n                defines,\r\n                undefined,\r\n                creationOptions.onCompiled,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Disposes of the effect wrapper\r\n    */\r\n    public dispose() {\r\n        this.effect.dispose();\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}