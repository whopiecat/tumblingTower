{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { HemisphericLight } from '../Lights/hemisphericLight';\nimport { DirectionalLight } from '../Lights/directionalLight';\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\nimport { HemisphereBuilder } from '../Meshes/Builders/hemisphereBuilder';\nimport { SpotLight } from '../Lights/spotLight';\nimport { TransformNode } from '../Meshes/transformNode';\nimport { PointerEventTypes } from '../Events/pointerEvents';\nimport { Observable } from \"../Misc/observable\";\n/**\r\n * Gizmo that enables viewing a light\r\n */\n\nvar LightGizmo =\n/** @class */\nfunction (_super) {\n  __extends(LightGizmo, _super);\n  /**\r\n   * Creates a LightGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   */\n\n\n  function LightGizmo(gizmoLayer) {\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._cachedPosition = new Vector3();\n    _this._cachedForward = new Vector3(0, 0, 1);\n    _this._pointerObserver = null;\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\n\n    _this.onClickedObservable = new Observable();\n    _this._light = null;\n    _this.attachedMesh = new AbstractMesh(\"\", _this.gizmoLayer.utilityLayerScene);\n    _this._attachedMeshParent = new TransformNode(\"parent\", _this.gizmoLayer.utilityLayerScene);\n    _this.attachedMesh.parent = _this._attachedMeshParent;\n    _this._material = new StandardMaterial(\"light\", _this.gizmoLayer.utilityLayerScene);\n    _this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    _this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this._light) {\n        return;\n      }\n\n      _this._isHovered = !!(pointerInfo.pickInfo && _this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n\n      if (_this._isHovered && pointerInfo.event.button === 0) {\n        _this.onClickedObservable.notifyObservers(_this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n    return _this;\n  }\n\n  Object.defineProperty(LightGizmo.prototype, \"light\", {\n    get: function () {\n      return this._light;\n    },\n\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\n    set: function (light) {\n      var _this = this;\n\n      this._light = light;\n\n      if (light) {\n        // Create the mesh for the given light type\n        if (this._lightMesh) {\n          this._lightMesh.dispose();\n        }\n\n        if (light instanceof HemisphericLight) {\n          this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof DirectionalLight) {\n          this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else if (light instanceof SpotLight) {\n          this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n        } else {\n          this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n        }\n\n        this._lightMesh.getChildMeshes(false).forEach(function (m) {\n          m.material = _this._material;\n        });\n\n        this._lightMesh.parent = this._rootMesh; // Add lighting to the light gizmo\n\n        var gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n\n        gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n        this._lightMesh.rotationQuaternion = new Quaternion();\n\n        if (!this.attachedMesh.reservedDataStore) {\n          this.attachedMesh.reservedDataStore = {};\n        }\n\n        this.attachedMesh.reservedDataStore.lightGizmo = this;\n\n        if (light.parent) {\n          this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n        } // Get update position and direction if the light has it\n\n\n        if (light.position) {\n          this.attachedMesh.position.copyFrom(light.position);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedPosition.copyFrom(this.attachedMesh.position);\n        }\n\n        if (light.direction) {\n          this.attachedMesh.setDirection(light.direction);\n          this.attachedMesh.computeWorldMatrix(true);\n\n          this._cachedForward.copyFrom(this.attachedMesh.forward);\n        }\n\n        this._update();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightGizmo.prototype, \"material\", {\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\n    get: function () {\n      return this._material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @hidden\r\n   * Updates the gizmo to match the attached mesh's position/rotation\r\n   */\n\n  LightGizmo.prototype._update = function () {\n    _super.prototype._update.call(this);\n\n    if (!this._light) {\n      return;\n    }\n\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    }\n\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        this._light.position.copyFrom(this.attachedMesh.position);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        this._light.direction.copyFrom(this.attachedMesh.forward);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      }\n    }\n  };\n  /**\r\n   * Disposes of the light gizmo\r\n   */\n\n\n  LightGizmo.prototype.dispose = function () {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n\n    this._material.dispose();\n\n    _super.prototype.dispose.call(this);\n\n    this._attachedMeshParent.dispose();\n  };\n\n  LightGizmo._CreateHemisphericLightMesh = function (scene) {\n    var root = new Mesh(\"hemisphereLight\", scene);\n    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n\n    var lines = this._CreateLightLines(3, scene);\n\n    lines.parent = root;\n    lines.position.z - 0.15;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreatePointLightMesh = function (scene) {\n    var root = new Mesh(\"pointLight\", scene);\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n\n    var lines = this._CreateLightLines(5, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateSpotLightMesh = function (scene) {\n    var root = new Mesh(\"spotLight\", scene);\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n\n    var lines = this._CreateLightLines(2, scene);\n\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  };\n\n  LightGizmo._CreateDirectionalLightMesh = function (scene) {\n    var root = new Mesh(\"directionalLight\", scene);\n    var mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    var sphere = SphereBuilder.CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    var line = Mesh.CreateCylinder(root.name, 6, 0.3, 0.3, 6, 1, scene);\n    line.parent = mesh;\n    var left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    var right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    var arrowHead = Mesh.CreateCylinder(root.name, 1, 0, 0.6, 6, 1, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    var left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    var right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }; // Static helper methods\n\n\n  LightGizmo._Scale = 0.007;\n  /**\r\n   * Creates the lines for a light mesh\r\n   */\n\n  LightGizmo._CreateLightLines = function (levels, scene) {\n    var distFromSphere = 1.2;\n    var root = new Mesh(\"root\", scene);\n    root.rotation.x = Math.PI / 2; // Create the top line, this will be cloned for all other lines\n\n    var linePivot = new Mesh(\"linePivot\", scene);\n    linePivot.parent = root;\n    var line = Mesh.CreateCylinder(\"line\", 2, 0.2, 0.3, 6, 1, scene);\n    line.position.y = line.scaling.y / 2 + distFromSphere;\n    line.parent = linePivot;\n\n    if (levels < 2) {\n      return linePivot;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"lineParentClone\");\n      l.rotation.z = Math.PI / 4;\n      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l.getChildMeshes()[0].scaling.y = 0.5;\n      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 3) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"linePivotClone\");\n      l.rotation.z = Math.PI / 2;\n      l.rotation.y = Math.PI / 2 * i;\n    }\n\n    if (levels < 4) {\n      return root;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var l = linePivot.clone(\"linePivotClone\");\n      l.rotation.z = Math.PI + Math.PI / 4;\n      l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n      l.getChildMeshes()[0].scaling.y = 0.5;\n      l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n      l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n    }\n\n    if (levels < 5) {\n      return root;\n    }\n\n    var l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI;\n    return root;\n  };\n\n  return LightGizmo;\n}(Gizmo);\n\nexport { LightGizmo };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/lightGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\n\r\nimport { StandardMaterial } from '../Materials/standardMaterial';\r\nimport { Light } from '../Lights/light';\r\nimport { Scene } from '../scene';\r\nimport { HemisphericLight } from '../Lights/hemisphericLight';\r\nimport { DirectionalLight } from '../Lights/directionalLight';\r\nimport { SphereBuilder } from '../Meshes/Builders/sphereBuilder';\r\nimport { HemisphereBuilder } from '../Meshes/Builders/hemisphereBuilder';\r\nimport { SpotLight } from '../Lights/spotLight';\r\nimport { TransformNode } from '../Meshes/transformNode';\r\nimport { PointerEventTypes, PointerInfo } from '../Events/pointerEvents';\r\nimport { Observer, Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Gizmo that enables viewing a light\r\n */\r\nexport class LightGizmo extends Gizmo {\r\n    private _lightMesh: Mesh;\r\n    private _material: StandardMaterial;\r\n    private _cachedPosition = new Vector3();\r\n    private _cachedForward = new Vector3(0, 0, 1);\r\n    private _attachedMeshParent: TransformNode;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\r\n    public onClickedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * Creates a LightGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n        super(gizmoLayer);\r\n        this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\r\n        this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\r\n\r\n        this.attachedMesh.parent = this._attachedMeshParent;\r\n        this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\r\n        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n        this._material.specularColor = new Color3(0.1, 0.1, 0.1);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this._light) {\r\n                return;\r\n            }\r\n\r\n            this._isHovered = !!(pointerInfo.pickInfo && (this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1));\r\n            if (this._isHovered && pointerInfo.event.button === 0) {\r\n                this.onClickedObservable.notifyObservers(this._light);\r\n            }\r\n        }, PointerEventTypes.POINTERDOWN);\r\n    }\r\n    private _light: Nullable<Light> = null;\r\n\r\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\r\n    public set light(light: Nullable<Light>) {\r\n        this._light = light;\r\n        if (light) {\r\n            // Create the mesh for the given light type\r\n            if (this._lightMesh) {\r\n                this._lightMesh.dispose();\r\n            }\r\n\r\n            if (light instanceof HemisphericLight) {\r\n                this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof DirectionalLight) {\r\n                this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof SpotLight) {\r\n                this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else {\r\n                this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            }\r\n            this._lightMesh.getChildMeshes(false).forEach((m) => {\r\n                m.material = this._material;\r\n            });\r\n            this._lightMesh.parent = this._rootMesh;\r\n\r\n            // Add lighting to the light gizmo\r\n            var gizmoLight = this.gizmoLayer._getSharedGizmoLight();\r\n            gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\r\n\r\n            this._lightMesh.rotationQuaternion = new Quaternion();\r\n\r\n            if (!this.attachedMesh!.reservedDataStore) {\r\n                this.attachedMesh!.reservedDataStore = {};\r\n            }\r\n            this.attachedMesh!.reservedDataStore.lightGizmo = this;\r\n\r\n            if (light.parent) {\r\n                this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\r\n            }\r\n\r\n            // Get update position and direction if the light has it\r\n            if ((light as any).position) {\r\n                this.attachedMesh!.position.copyFrom((light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n            if ((light as any).direction) {\r\n                this.attachedMesh!.setDirection((light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n\r\n            this._update();\r\n        }\r\n    }\r\n    public get light() {\r\n        return this._light;\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        super._update();\r\n        if (!this._light) {\r\n            return;\r\n        }\r\n\r\n        if (this._light.parent) {\r\n            this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\r\n        }\r\n\r\n        if ((this._light as any).position) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (!this.attachedMesh!.position.equals(this._cachedPosition)) {\r\n                // update light to match gizmo\r\n                (this._light as any).position.copyFrom(this.attachedMesh!.position);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            } else {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.position.copyFrom((this._light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n\r\n        }\r\n        if ((this._light as any).direction) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (Vector3.DistanceSquared(this.attachedMesh!.forward, this._cachedForward) > 0.0001) {\r\n                // update light to match gizmo\r\n                (this._light as any).direction.copyFrom(this.attachedMesh!.forward);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            } else if (Vector3.DistanceSquared(this.attachedMesh!.forward, (this._light as any).direction) > 0.0001) {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.setDirection((this._light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Static helper methods\r\n    private static _Scale = 0.007;\r\n\r\n    /**\r\n     * Creates the lines for a light mesh\r\n     */\r\n    private static _CreateLightLines = (levels: number, scene: Scene) => {\r\n        var distFromSphere = 1.2;\r\n\r\n        var root = new Mesh(\"root\", scene);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        // Create the top line, this will be cloned for all other lines\r\n        var linePivot = new Mesh(\"linePivot\", scene);\r\n        linePivot.parent = root;\r\n        var line = Mesh.CreateCylinder(\"line\", 2, 0.2, 0.3, 6, 1, scene);\r\n        line.position.y = line.scaling.y / 2 + distFromSphere;\r\n        line.parent = linePivot;\r\n\r\n        if (levels < 2) {\r\n            return linePivot;\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n            var l = linePivot.clone(\"lineParentClone\")!;\r\n            l.rotation.z = Math.PI / 4;\r\n            l.rotation.y = (Math.PI / 2) + (Math.PI / 2 * i);\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 3) {\r\n            return root;\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n            var l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI / 2;\r\n            l.rotation.y = (Math.PI / 2 * i);\r\n        }\r\n\r\n        if (levels < 4) {\r\n            return root;\r\n        }\r\n        for (var i = 0; i < 4; i++) {\r\n            var l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI + (Math.PI / 4);\r\n            l.rotation.y = (Math.PI / 2) + (Math.PI / 2 * i);\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 5) {\r\n            return root;\r\n        }\r\n        var l = linePivot.clone(\"linePivotClone\");\r\n        l.rotation.z = Math.PI;\r\n\r\n        return root;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the light gizmo\r\n     */\r\n    public dispose() {\r\n        this.onClickedObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this._material.dispose();\r\n        super.dispose();\r\n        this._attachedMeshParent.dispose();\r\n    }\r\n\r\n    private static _CreateHemisphericLightMesh(scene: Scene) {\r\n        var root = new Mesh(\"hemisphereLight\", scene);\r\n        var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        hemisphere.position.z = -0.15;\r\n        hemisphere.rotation.x = Math.PI / 2;\r\n        hemisphere.parent = root;\r\n\r\n        var lines = this._CreateLightLines(3, scene);\r\n        lines.parent = root;\r\n        lines.position.z - 0.15;\r\n\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreatePointLightMesh(scene: Scene) {\r\n        var root = new Mesh(\"pointLight\", scene);\r\n        var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.rotation.x = Math.PI / 2;\r\n        sphere.parent = root;\r\n\r\n        var lines = this._CreateLightLines(5, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateSpotLightMesh(scene: Scene) {\r\n        var root = new Mesh(\"spotLight\", scene);\r\n        var sphere = SphereBuilder.CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.parent = root;\r\n\r\n        var hemisphere = HemisphereBuilder.CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);\r\n        hemisphere.parent = root;\r\n        hemisphere.rotation.x = -Math.PI / 2;\r\n\r\n        var lines = this._CreateLightLines(2, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateDirectionalLightMesh(scene: Scene) {\r\n        var root = new Mesh(\"directionalLight\", scene);\r\n\r\n        var mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n        var sphere = SphereBuilder.CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);\r\n        sphere.parent = mesh;\r\n\r\n        var line = Mesh.CreateCylinder(root.name, 6, 0.3, 0.3, 6, 1, scene);\r\n        line.parent = mesh;\r\n\r\n        var left = line.clone(root.name)!;\r\n        left.scaling.y = 0.5;\r\n        left.position.x += 1.25;\r\n\r\n        var right = line.clone(root.name)!;\r\n        right.scaling.y = 0.5;\r\n        right.position.x += -1.25;\r\n\r\n        var arrowHead = Mesh.CreateCylinder(root.name, 1, 0, 0.6, 6, 1, scene);\r\n        arrowHead.position.y += 3;\r\n        arrowHead.parent = mesh;\r\n\r\n        var left = arrowHead.clone(root.name);\r\n        left.position.y = 1.5;\r\n        left.position.x += 1.25;\r\n\r\n        var right = arrowHead.clone(root.name);\r\n        right.position.y = 1.5;\r\n        right.position.x += -1.25;\r\n\r\n        mesh.scaling.scaleInPlace(LightGizmo._Scale);\r\n        mesh.rotation.z = Math.PI / 2;\r\n        mesh.rotation.y = Math.PI / 2;\r\n        return root;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}