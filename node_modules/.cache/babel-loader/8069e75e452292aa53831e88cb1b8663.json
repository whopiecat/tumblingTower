{"ast":null,"code":"import { Vector3, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color4 } from '../Maths/math.color';\nimport { Logger } from '../Misc/logger';\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\n\nvar VertexData =\n/** @class */\nfunction () {\n  function VertexData() {}\n  /**\r\n   * Uses the passed data array to set the set the values for the specified kind of data\r\n   * @param data a linear array of floating numbers\r\n   * @param kind the type of data that is being set, eg positions, colors etc\r\n   */\n\n\n  VertexData.prototype.set = function (data, kind) {\n    if (!data.length) {\n      Logger.Warn(\"Setting vertex data kind '\" + kind + \"' with an empty array\");\n    }\n\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  };\n  /**\r\n   * Associates the vertexData to the passed Mesh.\r\n   * Sets it as updatable or not (default `false`)\r\n   * @param mesh the mesh the vertexData is applied to\r\n   * @param updatable when used and having the value true allows new data to update the vertexData\r\n   * @returns the VertexData\r\n   */\n\n\n  VertexData.prototype.applyToMesh = function (mesh, updatable) {\n    this._applyTo(mesh, updatable);\n\n    return this;\n  };\n  /**\r\n   * Associates the vertexData to the passed Geometry.\r\n   * Sets it as updatable or not (default `false`)\r\n   * @param geometry the geometry the vertexData is applied to\r\n   * @param updatable when used and having the value true allows new data to update the vertexData\r\n   * @returns VertexData\r\n   */\n\n\n  VertexData.prototype.applyToGeometry = function (geometry, updatable) {\n    this._applyTo(geometry, updatable);\n\n    return this;\n  };\n  /**\r\n   * Updates the associated mesh\r\n   * @param mesh the mesh to be updated\r\n   * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n   * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false\r\n   * @returns VertexData\r\n   */\n\n\n  VertexData.prototype.updateMesh = function (mesh) {\n    this._update(mesh);\n\n    return this;\n  };\n  /**\r\n   * Updates the associated geometry\r\n   * @param geometry the geometry to be updated\r\n   * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n   * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false\r\n   * @returns VertexData.\r\n   */\n\n\n  VertexData.prototype.updateGeometry = function (geometry) {\n    this._update(geometry);\n\n    return this;\n  };\n\n  VertexData.prototype._applyTo = function (meshOrGeometry, updatable) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (this.positions) {\n      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n    }\n\n    if (this.normals) {\n      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n    }\n\n    if (this.tangents) {\n      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n    }\n\n    if (this.uvs) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n    }\n\n    if (this.uvs2) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n    }\n\n    if (this.uvs3) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n    }\n\n    if (this.uvs4) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n    }\n\n    if (this.uvs5) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n    }\n\n    if (this.uvs6) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n    }\n\n    if (this.colors) {\n      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n    }\n\n    if (this.matricesIndices) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n    }\n\n    if (this.matricesWeights) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n    }\n\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n    }\n\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n    }\n\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null, updatable);\n    } else {\n      meshOrGeometry.setIndices([], null);\n    }\n\n    return this;\n  };\n\n  VertexData.prototype._update = function (meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n\n    return this;\n  };\n  /**\r\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n   * @param matrix the transforming matrix\r\n   * @returns the VertexData\r\n   */\n\n\n  VertexData.prototype.transform = function (matrix) {\n    var flip = matrix.determinant() < 0;\n    var transformed = Vector3.Zero();\n    var index;\n\n    if (this.positions) {\n      var position = Vector3.Zero();\n\n      for (index = 0; index < this.positions.length; index += 3) {\n        Vector3.FromArrayToRef(this.positions, index, position);\n        Vector3.TransformCoordinatesToRef(position, matrix, transformed);\n        this.positions[index] = transformed.x;\n        this.positions[index + 1] = transformed.y;\n        this.positions[index + 2] = transformed.z;\n      }\n    }\n\n    if (this.normals) {\n      var normal = Vector3.Zero();\n\n      for (index = 0; index < this.normals.length; index += 3) {\n        Vector3.FromArrayToRef(this.normals, index, normal);\n        Vector3.TransformNormalToRef(normal, matrix, transformed);\n        this.normals[index] = transformed.x;\n        this.normals[index + 1] = transformed.y;\n        this.normals[index + 2] = transformed.z;\n      }\n    }\n\n    if (this.tangents) {\n      var tangent = Vector4.Zero();\n      var tangentTransformed = Vector4.Zero();\n\n      for (index = 0; index < this.tangents.length; index += 4) {\n        Vector4.FromArrayToRef(this.tangents, index, tangent);\n        Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);\n        this.tangents[index] = tangentTransformed.x;\n        this.tangents[index + 1] = tangentTransformed.y;\n        this.tangents[index + 2] = tangentTransformed.z;\n        this.tangents[index + 3] = tangentTransformed.w;\n      }\n    }\n\n    if (flip && this.indices) {\n      for (index = 0; index < this.indices.length; index += 3) {\n        var tmp = this.indices[index + 1];\n        this.indices[index + 1] = this.indices[index + 2];\n        this.indices[index + 2] = tmp;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Merges the passed VertexData into the current one\r\n   * @param other the VertexData to be merged into the current one\r\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n   * @returns the modified VertexData\r\n   */\n\n\n  VertexData.prototype.merge = function (other, use32BitsIndices) {\n    if (use32BitsIndices === void 0) {\n      use32BitsIndices = false;\n    }\n\n    this._validate();\n\n    other._validate();\n\n    if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n      throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n    }\n\n    if (other.indices) {\n      if (!this.indices) {\n        this.indices = [];\n      }\n\n      var offset = this.positions ? this.positions.length / 3 : 0;\n      var isSrcTypedArray = this.indices.BYTES_PER_ELEMENT !== undefined;\n\n      if (isSrcTypedArray) {\n        var len = this.indices.length + other.indices.length;\n        var temp = use32BitsIndices || this.indices instanceof Uint32Array ? new Uint32Array(len) : new Uint16Array(len);\n        temp.set(this.indices);\n        var decal = this.indices.length;\n\n        for (var index = 0; index < other.indices.length; index++) {\n          temp[decal + index] = other.indices[index] + offset;\n        }\n\n        this.indices = temp;\n      } else {\n        for (var index = 0; index < other.indices.length; index++) {\n          this.indices.push(other.indices[index] + offset);\n        }\n      }\n    }\n\n    this.positions = this._mergeElement(this.positions, other.positions);\n    this.normals = this._mergeElement(this.normals, other.normals);\n    this.tangents = this._mergeElement(this.tangents, other.tangents);\n    this.uvs = this._mergeElement(this.uvs, other.uvs);\n    this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);\n    this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);\n    this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);\n    this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);\n    this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);\n    this.colors = this._mergeElement(this.colors, other.colors);\n    this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);\n    this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);\n    this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);\n    this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);\n    return this;\n  };\n\n  VertexData.prototype._mergeElement = function (source, other) {\n    if (!source) {\n      return other;\n    }\n\n    if (!other) {\n      return source;\n    }\n\n    var len = other.length + source.length;\n    var isSrcTypedArray = source instanceof Float32Array;\n    var isOthTypedArray = other instanceof Float32Array; // use non-loop method when the source is Float32Array\n\n    if (isSrcTypedArray) {\n      var ret32 = new Float32Array(len);\n      ret32.set(source);\n      ret32.set(other, source.length);\n      return ret32; // source is number[], when other is also use concat\n    } else if (!isOthTypedArray) {\n      return source.concat(other); // source is a number[], but other is a Float32Array, loop required\n    } else {\n      var ret = source.slice(0); // copy source to a separate array\n\n      for (var i = 0, len = other.length; i < len; i++) {\n        ret.push(other[i]);\n      }\n\n      return ret;\n    }\n  };\n\n  VertexData.prototype._validate = function () {\n    if (!this.positions) {\n      throw new Error(\"Positions are required\");\n    }\n\n    var getElementCount = function (kind, values) {\n      var stride = VertexBuffer.DeduceStride(kind);\n\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n\n      return values.length / stride;\n    };\n\n    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n\n    var validateElementCount = function (kind, values) {\n      var elementCount = getElementCount(kind, values);\n\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  };\n  /**\r\n   * Serializes the VertexData\r\n   * @returns a serialized object\r\n   */\n\n\n  VertexData.prototype.serialize = function () {\n    var serializationObject = this.serialize();\n\n    if (this.positions) {\n      serializationObject.positions = this.positions;\n    }\n\n    if (this.normals) {\n      serializationObject.normals = this.normals;\n    }\n\n    if (this.tangents) {\n      serializationObject.tangents = this.tangents;\n    }\n\n    if (this.uvs) {\n      serializationObject.uvs = this.uvs;\n    }\n\n    if (this.uvs2) {\n      serializationObject.uvs2 = this.uvs2;\n    }\n\n    if (this.uvs3) {\n      serializationObject.uvs3 = this.uvs3;\n    }\n\n    if (this.uvs4) {\n      serializationObject.uvs4 = this.uvs4;\n    }\n\n    if (this.uvs5) {\n      serializationObject.uvs5 = this.uvs5;\n    }\n\n    if (this.uvs6) {\n      serializationObject.uvs6 = this.uvs6;\n    }\n\n    if (this.colors) {\n      serializationObject.colors = this.colors;\n    }\n\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = this.matricesIndices;\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = this.matricesWeights;\n    }\n\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n    }\n\n    serializationObject.indices = this.indices;\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Extracts the vertexData from a mesh\r\n   * @param mesh the mesh from which to extract the VertexData\r\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n   * @returns the object VertexData associated to the passed mesh\r\n   */\n\n\n  VertexData.ExtractFromMesh = function (mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  };\n  /**\r\n   * Extracts the vertexData from the geometry\r\n   * @param geometry the geometry from which to extract the VertexData\r\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false\r\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n   * @returns the object VertexData associated to the passed mesh\r\n   */\n\n\n  VertexData.ExtractFromGeometry = function (geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  };\n\n  VertexData._ExtractFrom = function (meshOrGeometry, copyWhenShared, forceCopy) {\n    var result = new VertexData();\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  };\n  /**\r\n   * Creates the VertexData for a Ribbon\r\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n    * * pathArray array of paths, each of which an array of successive Vector3\r\n    * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n    * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n    * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n    * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n    * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n    * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n   * @returns the VertexData of the ribbon\r\n   */\n\n\n  VertexData.CreateRibbon = function (options) {\n    throw _DevTools.WarnImport(\"ribbonBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a box\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n    * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n    * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n    * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n    * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n    * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateBox = function (options) {\n    throw _DevTools.WarnImport(\"boxBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a tiled box\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n    * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n    * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateTiledBox = function (options) {\n    throw _DevTools.WarnImport(\"tiledBoxBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a tiled plane\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * pattern a limited pattern arrangement depending on the number\r\n    * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n    * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n    * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the tiled plane\r\n   */\n\n\n  VertexData.CreateTiledPlane = function (options) {\n    throw _DevTools.WarnImport(\"tiledPlaneBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * segments sets the number of horizontal strips optional, default 32\r\n    * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n    * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n    * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n    * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n    * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n    * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the ellipsoid\r\n   */\n\n\n  VertexData.CreateSphere = function (options) {\n    throw _DevTools.WarnImport(\"sphereBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a cylinder, cone or prism\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * height sets the height (y direction) of the cylinder, optional, default 2\r\n    * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n    * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n    * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n    * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n    * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n    * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n    * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n    * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n    * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false\r\n    * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the cylinder, cone or prism\r\n   */\n\n\n  VertexData.CreateCylinder = function (options) {\n    throw _DevTools.WarnImport(\"cylinderBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a torus\r\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n    * * diameter the diameter of the torus, optional default 1\r\n    * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n    * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the torus\r\n   */\n\n\n  VertexData.CreateTorus = function (options) {\n    throw _DevTools.WarnImport(\"torusBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the LineSystem\r\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n   *  - lines an array of lines, each line being an array of successive Vector3\r\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n   * @returns the VertexData of the LineSystem\r\n   */\n\n\n  VertexData.CreateLineSystem = function (options) {\n    throw _DevTools.WarnImport(\"linesBuilder\");\n  };\n  /**\r\n   * Create the VertexData for a DashedLines\r\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n   *  - points an array successive Vector3\r\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n   *  - dashNb the intended total number of dashes, optional, default 200\r\n   * @returns the VertexData for the DashedLines\r\n   */\n\n\n  VertexData.CreateDashedLines = function (options) {\n    throw _DevTools.WarnImport(\"linesBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a Ground\r\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n   *  - width the width (x direction) of the ground, optional, default 1\r\n   *  - height the height (z direction) of the ground, optional, default 1\r\n   *  - subdivisions the number of subdivisions per side, optional, default 1\r\n   * @returns the VertexData of the Ground\r\n   */\n\n\n  VertexData.CreateGround = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n    * * xmin the ground minimum X coordinate, optional, default -1\r\n    * * zmin the ground minimum Z coordinate, optional, default -1\r\n    * * xmax the ground maximum X coordinate, optional, default 1\r\n    * * zmax the ground maximum Z coordinate, optional, default 1\r\n    * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n    * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n   * @returns the VertexData of the TiledGround\r\n   */\n\n\n  VertexData.CreateTiledGround = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the Ground designed from a heightmap\r\n   * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap\r\n    * * width the width (x direction) of the ground\r\n    * * height the height (z direction) of the ground\r\n    * * subdivisions the number of subdivisions per side\r\n    * * minHeight the minimum altitude on the ground, optional, default 0\r\n    * * maxHeight the maximum altitude on the ground, optional default 1\r\n    * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n    * * buffer the array holding the image color data\r\n    * * bufferWidth the width of image\r\n    * * bufferHeight the height of image\r\n    * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n   * @returns the VertexData of the Ground designed from a heightmap\r\n   */\n\n\n  VertexData.CreateGroundFromHeightMap = function (options) {\n    throw _DevTools.WarnImport(\"groundBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for a Plane\r\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n    * * size sets the width and height of the plane to the value of size, optional default 1\r\n    * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n    * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreatePlane = function (options) {\n    throw _DevTools.WarnImport(\"planeBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the Disc or regular Polygon\r\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n    * * radius the radius of the disc, optional default 0.5\r\n    * * tessellation the number of polygon sides, optional, default 64\r\n    * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the box\r\n   */\n\n\n  VertexData.CreateDisc = function (options) {\n    throw _DevTools.WarnImport(\"discBuilder\");\n  };\n  /**\r\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n   * All parameters are provided by MeshBuilder.CreatePolygon as needed\r\n   * @param polygon a mesh built from polygonTriangulation.build()\r\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n   * @returns the VertexData of the Polygon\r\n   */\n\n\n  VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _DevTools.WarnImport(\"polygonBuilder\");\n  };\n  /**\r\n   * Creates the VertexData of the IcoSphere\r\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n    * * radius the radius of the IcoSphere, optional default 1\r\n    * * radiusX allows stretching in the x direction, optional, default radius\r\n    * * radiusY allows stretching in the y direction, optional, default radius\r\n    * * radiusZ allows stretching in the z direction, optional, default radius\r\n    * * flat when true creates a flat shaded mesh, optional, default true\r\n    * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the IcoSphere\r\n   */\n\n\n  VertexData.CreateIcoSphere = function (options) {\n    throw _DevTools.WarnImport(\"icoSphereBuilder\");\n  }; // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n\n  /**\r\n   * Creates the VertexData for a Polyhedron\r\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n   * * type provided types are:\r\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n   * * size the size of the IcoSphere, optional default 1\r\n   * * sizeX allows stretching in the x direction, optional, default size\r\n   * * sizeY allows stretching in the y direction, optional, default size\r\n   * * sizeZ allows stretching in the z direction, optional, default size\r\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n   * * flat when true creates a flat shaded mesh, optional, default true\r\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the Polyhedron\r\n   */\n\n\n  VertexData.CreatePolyhedron = function (options) {\n    throw _DevTools.WarnImport(\"polyhedronBuilder\");\n  }; //\n\n  /**\r\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n   * @returns the VertexData of the Capsule\r\n   */\n\n\n  VertexData.CreateCapsule = function (options) {\n    if (options === void 0) {\n      options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6\n      };\n    }\n\n    throw _DevTools.WarnImport(\"capsuleBuilder\");\n  }; // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n\n  /**\r\n   * Creates the VertexData for a TorusKnot\r\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n    * * radius the radius of the torus knot, optional, default 2\r\n    * * tube the thickness of the tube, optional, default 0.5\r\n    * * radialSegments the number of sides on each tube segments, optional, default 32\r\n    * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n    * * p the number of windings around the z axis, optional,  default 2\r\n    * * q the number of windings around the x axis, optional,  default 3\r\n    * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n    * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n    * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @returns the VertexData of the Torus Knot\r\n   */\n\n\n  VertexData.CreateTorusKnot = function (options) {\n    throw _DevTools.WarnImport(\"torusKnotBuilder\");\n  }; // Tools\n\n  /**\r\n   * Compute normals for given positions and indices\r\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n    * * facetNormals : optional array of facet normals (vector3)\r\n    * * facetPositions : optional array of facet positions (vector3)\r\n    * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n    * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n    * * bInfo : optional bounding info, required for facetPartitioning computation\r\n    * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n    * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation\r\n    * * useRightHandedSystem: optional boolean to for right handed system computation\r\n    * * depthSort : optional boolean to enable the facet depth sort computation\r\n    * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n    * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n   */\n\n\n  VertexData.ComputeNormals = function (positions, indices, normals, options) {\n    // temporary scalar variables\n    var index = 0; // facet index\n\n    var p1p2x = 0.0; // p1p2 vector x coordinate\n\n    var p1p2y = 0.0; // p1p2 vector y coordinate\n\n    var p1p2z = 0.0; // p1p2 vector z coordinate\n\n    var p3p2x = 0.0; // p3p2 vector x coordinate\n\n    var p3p2y = 0.0; // p3p2 vector y coordinate\n\n    var p3p2z = 0.0; // p3p2 vector z coordinate\n\n    var faceNormalx = 0.0; // facet normal x coordinate\n\n    var faceNormaly = 0.0; // facet normal y coordinate\n\n    var faceNormalz = 0.0; // facet normal z coordinate\n\n    var length = 0.0; // facet normal length before normalization\n\n    var v1x = 0; // vector1 x index in the positions array\n\n    var v1y = 0; // vector1 y index in the positions array\n\n    var v1z = 0; // vector1 z index in the positions array\n\n    var v2x = 0; // vector2 x index in the positions array\n\n    var v2y = 0; // vector2 y index in the positions array\n\n    var v2z = 0; // vector2 z index in the positions array\n\n    var v3x = 0; // vector3 x index in the positions array\n\n    var v3y = 0; // vector3 y index in the positions array\n\n    var v3z = 0; // vector3 z index in the positions array\n\n    var computeFacetNormals = false;\n    var computeFacetPositions = false;\n    var computeFacetPartitioning = false;\n    var computeDepthSort = false;\n    var faceNormalSign = 1;\n    var ratio = 0;\n    var distanceTo = null;\n\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n\n        var depthSortedFacets = options.depthSortedFacets;\n      }\n    } // facetPartitioning reinit if needed\n\n\n    var xSubRatio = 0;\n    var ySubRatio = 0;\n    var zSubRatio = 0;\n    var subSq = 0;\n\n    if (computeFacetPartitioning && options && options.bbSize) {\n      var ox = 0; // X partitioning index for facet position\n\n      var oy = 0; // Y partinioning index for facet position\n\n      var oz = 0; // Z partinioning index for facet position\n\n      var b1x = 0; // X partitioning index for facet v1 vertex\n\n      var b1y = 0; // Y partitioning index for facet v1 vertex\n\n      var b1z = 0; // z partitioning index for facet v1 vertex\n\n      var b2x = 0; // X partitioning index for facet v2 vertex\n\n      var b2y = 0; // Y partitioning index for facet v2 vertex\n\n      var b2z = 0; // Z partitioning index for facet v2 vertex\n\n      var b3x = 0; // X partitioning index for facet v3 vertex\n\n      var b3y = 0; // Y partitioning index for facet v3 vertex\n\n      var b3z = 0; // Z partitioning index for facet v3 vertex\n\n      var block_idx_o = 0; // facet barycenter block index\n\n      var block_idx_v1 = 0; // v1 vertex block index\n\n      var block_idx_v2 = 0; // v2 vertex block index\n\n      var block_idx_v3 = 0; // v3 vertex block index\n\n      var bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    } // reset the normals\n\n\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    } // Loop : 1 indice triplet = 1 facet\n\n\n    var nbFaces = indices.length / 3 | 0;\n\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z]; // compute the face normal with the cross product\n\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x); // normalize this normal and store it in the array facetData\n\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array(); // push each facet index in each block containing the vertex\n\n        options.facetPartitioning[block_idx_v1].push(index);\n\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n\n      if (computeDepthSort && options && options.facetPositions) {\n        var dsf = depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      } // compute the normals anyway\n\n\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    } // last normalization of each normal\n\n\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  };\n  /** @hidden */\n\n\n  VertexData._ComputeSides = function (sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    var li = indices.length;\n    var ln = normals.length;\n    var i;\n    var n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n\n      case VertexData.BACKSIDE:\n        var tmp; // indices\n\n        for (i = 0; i < li; i += 3) {\n          tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        } // normals\n\n\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n\n        break;\n\n      case VertexData.DOUBLESIDE:\n        // positions\n        var lp = positions.length;\n        var l = lp / 3;\n\n        for (var p = 0; p < lp; p++) {\n          positions[lp + p] = positions[p];\n        } // indices\n\n\n        for (i = 0; i < li; i += 3) {\n          indices[i + li] = indices[i + 2] + l;\n          indices[i + 1 + li] = indices[i + 1] + l;\n          indices[i + 2 + li] = indices[i] + l;\n        } // normals\n\n\n        for (n = 0; n < ln; n++) {\n          normals[ln + n] = -normals[n];\n        } // uvs\n\n\n        var lu = uvs.length;\n        var u = 0;\n\n        for (u = 0; u < lu; u++) {\n          uvs[u + lu] = uvs[u];\n        }\n\n        frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n        backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n        u = 0;\n\n        for (i = 0; i < lu / 2; i++) {\n          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n          u += 2;\n        }\n\n        break;\n    }\n  };\n  /**\r\n   * Applies VertexData created from the imported parameters to the geometry\r\n   * @param parsedVertexData the parsed data from an imported file\r\n   * @param geometry the geometry to apply the VertexData to\r\n   */\n\n\n  VertexData.ImportVertexData = function (parsedVertexData, geometry) {\n    var vertexData = new VertexData(); // positions\n\n    var positions = parsedVertexData.positions;\n\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    } // normals\n\n\n    var normals = parsedVertexData.normals;\n\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    } // tangents\n\n\n    var tangents = parsedVertexData.tangents;\n\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    } // uvs\n\n\n    var uvs = parsedVertexData.uvs;\n\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    } // uv2s\n\n\n    var uv2s = parsedVertexData.uv2s;\n\n    if (uv2s) {\n      vertexData.set(uv2s, VertexBuffer.UV2Kind);\n    } // uv3s\n\n\n    var uv3s = parsedVertexData.uv3s;\n\n    if (uv3s) {\n      vertexData.set(uv3s, VertexBuffer.UV3Kind);\n    } // uv4s\n\n\n    var uv4s = parsedVertexData.uv4s;\n\n    if (uv4s) {\n      vertexData.set(uv4s, VertexBuffer.UV4Kind);\n    } // uv5s\n\n\n    var uv5s = parsedVertexData.uv5s;\n\n    if (uv5s) {\n      vertexData.set(uv5s, VertexBuffer.UV5Kind);\n    } // uv6s\n\n\n    var uv6s = parsedVertexData.uv6s;\n\n    if (uv6s) {\n      vertexData.set(uv6s, VertexBuffer.UV6Kind);\n    } // colors\n\n\n    var colors = parsedVertexData.colors;\n\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n    } // matricesIndices\n\n\n    var matricesIndices = parsedVertexData.matricesIndices;\n\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    } // matricesWeights\n\n\n    var matricesWeights = parsedVertexData.matricesWeights;\n\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    } // indices\n\n\n    var indices = parsedVertexData.indices;\n\n    if (indices) {\n      vertexData.indices = indices;\n    }\n\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  };\n  /**\r\n   * Mesh side orientation : usually the external or front surface\r\n   */\n\n\n  VertexData.FRONTSIDE = 0;\n  /**\r\n   * Mesh side orientation : usually the internal or back surface\r\n   */\n\n  VertexData.BACKSIDE = 1;\n  /**\r\n   * Mesh side orientation : both internal and external or front and back surfaces\r\n   */\n\n  VertexData.DOUBLESIDE = 2;\n  /**\r\n   * Mesh side orientation : by default, `FRONTSIDE`\r\n   */\n\n  VertexData.DEFAULTSIDE = 0;\n  return VertexData;\n}();\n\nexport { VertexData };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/mesh.vertexData.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { Color4, Color3 } from '../Maths/math.color';\r\nimport { Logger } from '../Misc/logger';\r\n\r\ndeclare type Geometry = import(\"../Meshes/geometry\").Geometry;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\nimport { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @param updateExtends when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n     * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @param updateExtends when true BoundingInfo will be renewed when and if position kind is updated, optional with default false\r\n     * @param makeItUnique when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private _applyTo(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        var flip = matrix.determinant() < 0;\r\n        var transformed = Vector3.Zero();\r\n        var index: number;\r\n        if (this.positions) {\r\n            var position = Vector3.Zero();\r\n\r\n            for (index = 0; index < this.positions.length; index += 3) {\r\n                Vector3.FromArrayToRef(this.positions, index, position);\r\n\r\n                Vector3.TransformCoordinatesToRef(position, matrix, transformed);\r\n                this.positions[index] = transformed.x;\r\n                this.positions[index + 1] = transformed.y;\r\n                this.positions[index + 2] = transformed.z;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            var normal = Vector3.Zero();\r\n\r\n            for (index = 0; index < this.normals.length; index += 3) {\r\n                Vector3.FromArrayToRef(this.normals, index, normal);\r\n\r\n                Vector3.TransformNormalToRef(normal, matrix, transformed);\r\n                this.normals[index] = transformed.x;\r\n                this.normals[index + 1] = transformed.y;\r\n                this.normals[index + 2] = transformed.z;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            var tangent = Vector4.Zero();\r\n            var tangentTransformed = Vector4.Zero();\r\n\r\n            for (index = 0; index < this.tangents.length; index += 4) {\r\n                Vector4.FromArrayToRef(this.tangents, index, tangent);\r\n\r\n                Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);\r\n                this.tangents[index] = tangentTransformed.x;\r\n                this.tangents[index + 1] = tangentTransformed.y;\r\n                this.tangents[index + 2] = tangentTransformed.z;\r\n                this.tangents[index + 3] = tangentTransformed.w;\r\n            }\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            for (index = 0; index < this.indices!.length; index += 3) {\r\n                let tmp = this.indices[index + 1];\r\n                this.indices[index + 1] = this.indices[index + 2];\r\n                this.indices[index + 2] = tmp;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param other the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(other: VertexData, use32BitsIndices = false): VertexData {\r\n        this._validate();\r\n        other._validate();\r\n\r\n        if (!this.normals !== !other.normals ||\r\n            !this.tangents !== !other.tangents ||\r\n            !this.uvs !== !other.uvs ||\r\n            !this.uvs2 !== !other.uvs2 ||\r\n            !this.uvs3 !== !other.uvs3 ||\r\n            !this.uvs4 !== !other.uvs4 ||\r\n            !this.uvs5 !== !other.uvs5 ||\r\n            !this.uvs6 !== !other.uvs6 ||\r\n            !this.colors !== !other.colors ||\r\n            !this.matricesIndices !== !other.matricesIndices ||\r\n            !this.matricesWeights !== !other.matricesWeights ||\r\n            !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n            !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\r\n            throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n        }\r\n\r\n        if (other.indices) {\r\n            if (!this.indices) {\r\n                this.indices = [];\r\n            }\r\n\r\n            var offset = this.positions ? this.positions.length / 3 : 0;\r\n\r\n            var isSrcTypedArray = (<any>this.indices).BYTES_PER_ELEMENT !== undefined;\r\n\r\n            if (isSrcTypedArray) {\r\n                var len = this.indices.length + other.indices.length;\r\n                var temp = use32BitsIndices || this.indices instanceof Uint32Array ? new Uint32Array(len) : new Uint16Array(len);\r\n                temp.set(this.indices);\r\n\r\n                let decal = this.indices.length;\r\n                for (var index = 0; index < other.indices.length; index++) {\r\n                    temp[decal + index] = other.indices[index] + offset;\r\n                }\r\n\r\n                this.indices = temp;\r\n            } else {\r\n                for (var index = 0; index < other.indices.length; index++) {\r\n                    (<number[]>this.indices).push(other.indices[index] + offset);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.positions = this._mergeElement(this.positions, other.positions);\r\n        this.normals = this._mergeElement(this.normals, other.normals);\r\n        this.tangents = this._mergeElement(this.tangents, other.tangents);\r\n        this.uvs = this._mergeElement(this.uvs, other.uvs);\r\n        this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);\r\n        this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);\r\n        this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);\r\n        this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);\r\n        this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);\r\n        this.colors = this._mergeElement(this.colors, other.colors);\r\n        this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);\r\n        this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);\r\n        this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);\r\n        this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);\r\n        return this;\r\n    }\r\n\r\n    private _mergeElement(source: Nullable<FloatArray>, other: Nullable<FloatArray>): Nullable<FloatArray> {\r\n        if (!source) {\r\n            return other;\r\n        }\r\n\r\n        if (!other) {\r\n            return source;\r\n        }\r\n\r\n        var len = other.length + source.length;\r\n        var isSrcTypedArray = source instanceof Float32Array;\r\n        var isOthTypedArray = other instanceof Float32Array;\r\n\r\n        // use non-loop method when the source is Float32Array\r\n        if (isSrcTypedArray) {\r\n            var ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            ret32.set(other, source.length);\r\n            return ret32;\r\n\r\n            // source is number[], when other is also use concat\r\n        } else if (!isOthTypedArray) {\r\n            return (<number[]>source).concat(<number[]>other);\r\n\r\n            // source is a number[], but other is a Float32Array, loop required\r\n        } else {\r\n            var ret = (<number[]>source).slice(0); // copy source to a separate array\r\n            for (var i = 0, len = other.length; i < len; i++) {\r\n                ret.push(other[i]);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new Error(\"Positions are required\");\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if ((values.length % stride) !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) { validateElementCount(VertexBuffer.NormalKind, this.normals); }\r\n        if (this.tangents) { validateElementCount(VertexBuffer.TangentKind, this.tangents); }\r\n        if (this.uvs) { validateElementCount(VertexBuffer.UVKind, this.uvs); }\r\n        if (this.uvs2) { validateElementCount(VertexBuffer.UV2Kind, this.uvs2); }\r\n        if (this.uvs3) { validateElementCount(VertexBuffer.UV3Kind, this.uvs3); }\r\n        if (this.uvs4) { validateElementCount(VertexBuffer.UV4Kind, this.uvs4); }\r\n        if (this.uvs5) { validateElementCount(VertexBuffer.UV5Kind, this.uvs5); }\r\n        if (this.uvs6) { validateElementCount(VertexBuffer.UV6Kind, this.uvs6); }\r\n        if (this.colors) { validateElementCount(VertexBuffer.ColorKind, this.colors); }\r\n        if (this.matricesIndices) { validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices); }\r\n        if (this.matricesWeights) { validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights); }\r\n        if (this.matricesIndicesExtra) { validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra); }\r\n        if (this.matricesWeightsExtra) { validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra); }\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = this.serialize();\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = this.positions;\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = this.normals;\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = this.tangents;\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = this.uvs;\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = this.uvs2;\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = this.uvs3;\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = this.uvs4;\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = this.uvs5;\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = this.uvs6;\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = this.colors;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = this.matricesIndices;\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = this.matricesWeights;\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\r\n        }\r\n\r\n        serializationObject.indices = this.indices;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        var result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n      * * pathArray array of paths, each of which an array of successive Vector3\r\n      * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n      * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n      * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n      * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n      * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n      * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @returns the VertexData of the ribbon\r\n     */\r\n    public static CreateRibbon(options: { pathArray: Vector3[][], closeArray?: boolean, closePath?: boolean, offset?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, invertUV?: boolean, uvs?: Vector2[], colors?: Color4[] }): VertexData {\r\n        throw _DevTools.WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n      * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n      * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n      * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n      * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n      * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateBox(options: { size?: number, width?: number, height?: number, depth?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n      * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n      * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateTiledBox(options: { pattern?: number, width?: number, height?: number, depth?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, alignHorizontal?: number, alignVertical?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * pattern a limited pattern arrangement depending on the number\r\n      * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n      * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n      * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the tiled plane\r\n     */\r\n    public static CreateTiledPlane(options: { pattern?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, size?: number, width?: number, height?: number, alignHorizontal?: number, alignVertical?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * segments sets the number of horizontal strips optional, default 32\r\n      * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n      * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n      * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n      * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n      * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n      * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the ellipsoid\r\n     */\r\n    public static CreateSphere(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * height sets the height (y direction) of the cylinder, optional, default 2\r\n      * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n      * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n      * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n      * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n      * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n      * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n      * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n      * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n      * * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false\r\n      * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     */\r\n    public static CreateCylinder(options: { height?: number, diameterTop?: number, diameterBottom?: number, diameter?: number, tessellation?: number, subdivisions?: number, arc?: number, faceColors?: Color4[], faceUV?: Vector4[], hasRings?: boolean, enclose?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n      * * diameter the diameter of the torus, optional default 1\r\n      * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n      * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the torus\r\n     */\r\n    public static CreateTorus(options: { diameter?: number, thickness?: number, tessellation?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @returns the VertexData of the LineSystem\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][], colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _DevTools.WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @returns the VertexData for the DashedLines\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[], dashSize?: number, gapSize?: number, dashNb?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @returns the VertexData of the Ground\r\n     */\r\n    public static CreateGround(options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n      * * xmin the ground minimum X coordinate, optional, default -1\r\n      * * zmin the ground minimum Z coordinate, optional, default -1\r\n      * * xmax the ground maximum X coordinate, optional, default 1\r\n      * * zmax the ground maximum Z coordinate, optional, default 1\r\n      * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n      * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @returns the VertexData of the TiledGround\r\n     */\r\n    public static CreateTiledGround(options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; } }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap\r\n      * * width the width (x direction) of the ground\r\n      * * height the height (z direction) of the ground\r\n      * * subdivisions the number of subdivisions per side\r\n      * * minHeight the minimum altitude on the ground, optional, default 0\r\n      * * maxHeight the maximum altitude on the ground, optional default 1\r\n      * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n      * * buffer the array holding the image color data\r\n      * * bufferWidth the width of image\r\n      * * bufferHeight the height of image\r\n      * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     */\r\n    public static CreateGroundFromHeightMap(options: { width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, colorFilter: Color3, buffer: Uint8Array, bufferWidth: number, bufferHeight: number, alphaFilter: number }): VertexData {\r\n        throw _DevTools.WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n      * * size sets the width and height of the plane to the value of size, optional default 1\r\n      * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n      * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreatePlane(options: { size?: number, width?: number, height?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n      * * radius the radius of the disc, optional default 0.5\r\n      * * tessellation the number of polygon sides, optional, default 64\r\n      * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the box\r\n     */\r\n    public static CreateDisc(options: { radius?: number, tessellation?: number, arc?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by MeshBuilder.CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _DevTools.WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n      * * radius the radius of the IcoSphere, optional default 1\r\n      * * radiusX allows stretching in the x direction, optional, default radius\r\n      * * radiusY allows stretching in the y direction, optional, default radius\r\n      * * radiusZ allows stretching in the z direction, optional, default radius\r\n      * * flat when true creates a flat shaded mesh, optional, default true\r\n      * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the IcoSphere\r\n     */\r\n    public static CreateIcoSphere(options: { radius?: number, radiusX?: number, radiusY?: number, radiusZ?: number, flat?: boolean, subdivisions?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Polyhedron\r\n     */\r\n    public static CreatePolyhedron(options: { type?: number, size?: number, sizeX?: number, sizeY?: number, sizeZ?: number, custom?: any, faceUV?: Vector4[], faceColors?: Color4[], flat?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    //\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     */\r\n    public static CreateCapsule(options: ICreateCapsuleOptions = {\r\n        orientation : Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6\r\n    }): VertexData {\r\n        throw _DevTools.WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n      * * radius the radius of the torus knot, optional, default 2\r\n      * * tube the thickness of the tube, optional, default 0.5\r\n      * * radialSegments the number of sides on each tube segments, optional, default 32\r\n      * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n      * * p the number of windings around the z axis, optional,  default 2\r\n      * * q the number of windings around the x axis, optional,  default 3\r\n      * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n      * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n      * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @returns the VertexData of the Torus Knot\r\n     */\r\n    public static CreateTorusKnot(options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n        throw _DevTools.WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n      * * facetNormals : optional array of facet normals (vector3)\r\n      * * facetPositions : optional array of facet positions (vector3)\r\n      * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n      * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n      * * bInfo : optional bounding info, required for facetPartitioning computation\r\n      * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n      * * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation\r\n      * * useRightHandedSystem: optional boolean to for right handed system computation\r\n      * * depthSort : optional boolean to enable the facet depth sort computation\r\n      * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n      * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     */\r\n    public static ComputeNormals(positions: any, indices: any, normals: any,\r\n        options?: {\r\n            facetNormals?: any, facetPositions?: any, facetPartitioning?: any, ratio?: number, bInfo?: any, bbSize?: Vector3, subDiv?: any,\r\n            useRightHandedSystem?: boolean, depthSort?: boolean, distanceTo?: Vector3, depthSortedFacets?: any\r\n        }): void {\r\n\r\n        // temporary scalar variables\r\n        var index = 0;                      // facet index\r\n        var p1p2x = 0.0;                    // p1p2 vector x coordinate\r\n        var p1p2y = 0.0;                    // p1p2 vector y coordinate\r\n        var p1p2z = 0.0;                    // p1p2 vector z coordinate\r\n        var p3p2x = 0.0;                    // p3p2 vector x coordinate\r\n        var p3p2y = 0.0;                    // p3p2 vector y coordinate\r\n        var p3p2z = 0.0;                    // p3p2 vector z coordinate\r\n        var faceNormalx = 0.0;              // facet normal x coordinate\r\n        var faceNormaly = 0.0;              // facet normal y coordinate\r\n        var faceNormalz = 0.0;              // facet normal z coordinate\r\n        var length = 0.0;                   // facet normal length before normalization\r\n        var v1x = 0;                        // vector1 x index in the positions array\r\n        var v1y = 0;                        // vector1 y index in the positions array\r\n        var v1z = 0;                        // vector1 z index in the positions array\r\n        var v2x = 0;                        // vector2 x index in the positions array\r\n        var v2y = 0;                        // vector2 y index in the positions array\r\n        var v2z = 0;                        // vector2 z index in the positions array\r\n        var v3x = 0;                        // vector3 x index in the positions array\r\n        var v3y = 0;                        // vector3 y index in the positions array\r\n        var v3z = 0;                        // vector3 z index in the positions array\r\n        var computeFacetNormals = false;\r\n        var computeFacetPositions = false;\r\n        var computeFacetPartitioning = false;\r\n        var computeDepthSort = false;\r\n        var faceNormalSign = 1;\r\n        let ratio = 0;\r\n        var distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = (options.facetNormals) ? true : false;\r\n            computeFacetPositions = (options.facetPositions) ? true : false;\r\n            computeFacetPartitioning = (options.facetPartitioning) ? true : false;\r\n            faceNormalSign = (options.useRightHandedSystem === true) ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = (options.depthSort) ? true : false;\r\n            distanceTo = <Vector3>(options.distanceTo);\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n                var depthSortedFacets = options.depthSortedFacets;\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            var ox = 0;                 // X partitioning index for facet position\r\n            var oy = 0;                 // Y partinioning index for facet position\r\n            var oz = 0;                 // Z partinioning index for facet position\r\n            var b1x = 0;                // X partitioning index for facet v1 vertex\r\n            var b1y = 0;                // Y partitioning index for facet v1 vertex\r\n            var b1z = 0;                // z partitioning index for facet v1 vertex\r\n            var b2x = 0;                // X partitioning index for facet v2 vertex\r\n            var b2y = 0;                // Y partitioning index for facet v2 vertex\r\n            var b2z = 0;                // Z partitioning index for facet v2 vertex\r\n            var b3x = 0;                // X partitioning index for facet v3 vertex\r\n            var b3y = 0;                // Y partitioning index for facet v3 vertex\r\n            var b3z = 0;                // Z partitioning index for facet v3 vertex\r\n            var block_idx_o = 0;        // facet barycenter block index\r\n            var block_idx_v1 = 0;       // v1 vertex block index\r\n            var block_idx_v2 = 0;       // v2 vertex block index\r\n            var block_idx_v3 = 0;       // v3 vertex block index\r\n\r\n            var bbSizeMax = (options.bbSize.x > options.bbSize.y) ? options.bbSize.x : options.bbSize.y;\r\n            bbSizeMax = (bbSizeMax > options.bbSize.z) ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\r\n            ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\r\n            zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        var nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x];          // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = (length === 0) ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                var dsf = depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx;                         // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = (length === 0) ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _ComputeSides(sideOrientation: number, positions: FloatArray, indices: FloatArray, normals: FloatArray, uvs: FloatArray, frontUVs?: Vector4, backUVs?: Vector4) {\r\n        var li: number = indices.length;\r\n        var ln: number = normals.length;\r\n        var i: number;\r\n        var n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                var tmp: number;\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE:\r\n                // positions\r\n                var lp: number = positions.length;\r\n                var l: number = lp / 3;\r\n                for (var p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                var lu: number = uvs.length;\r\n                var u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        var vertexData = new VertexData();\r\n\r\n        // positions\r\n        var positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        var normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        var tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        var uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        var uv2s = parsedVertexData.uv2s;\r\n        if (uv2s) {\r\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        var uv3s = parsedVertexData.uv3s;\r\n        if (uv3s) {\r\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        var uv4s = parsedVertexData.uv4s;\r\n        if (uv4s) {\r\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        var uv5s = parsedVertexData.uv5s;\r\n        if (uv5s) {\r\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        var uv6s = parsedVertexData.uv6s;\r\n        if (uv6s) {\r\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        var colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        var matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        var matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        var indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}