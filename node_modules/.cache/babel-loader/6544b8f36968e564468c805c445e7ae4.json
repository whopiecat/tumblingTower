{"ast":null,"code":"import { Tools } from \"../../Misc/tools\";\nimport { WorkerPool } from '../../Misc/workerPool';\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\n\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(function (resolve) {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(function (module) {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\n\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData) {\n  var buffer = new decoderModule.DecoderBuffer();\n  buffer.Init(dataView, dataView.byteLength);\n  var decoder = new decoderModule.Decoder();\n  var geometry;\n  var status;\n\n  try {\n    var type = decoder.GetEncodedGeometryType(buffer);\n\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        geometry = new decoderModule.Mesh();\n        status = decoder.DecodeBufferToMesh(buffer, geometry);\n        break;\n\n      case decoderModule.POINT_CLOUD:\n        geometry = new decoderModule.PointCloud();\n        status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type \" + type);\n    }\n\n    if (!status.ok() || !geometry.ptr) {\n      throw new Error(status.error_msg());\n    }\n\n    if (type === decoderModule.TRIANGULAR_MESH) {\n      var numFaces = geometry.num_faces();\n      var numIndices = numFaces * 3;\n      var byteLength = numIndices * 4;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n        var indices = new Uint32Array(numIndices);\n        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n        onIndicesData(indices);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    }\n\n    var processAttribute = function (kind, attribute) {\n      var numComponents = attribute.num_components();\n      var numPoints = geometry.num_points();\n      var numValues = numPoints * numComponents;\n      var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n\n      var ptr = decoderModule._malloc(byteLength);\n\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n        var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n\n        if (kind === \"color\" && numComponents === 3) {\n          var babylonData = new Float32Array(numPoints * 4);\n\n          for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n            babylonData[i + 0] = values[j + 0];\n            babylonData[i + 1] = values[j + 1];\n            babylonData[i + 2] = values[j + 2];\n            babylonData[i + 3] = 1;\n          }\n\n          onAttributeData(kind, babylonData);\n        } else {\n          var babylonData = new Float32Array(numValues);\n          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n          onAttributeData(kind, babylonData);\n        }\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n\n    if (attributes) {\n      for (var kind in attributes) {\n        var id = attributes[kind];\n        var attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        processAttribute(kind, attribute);\n      }\n    } else {\n      var nativeAttributeTypes = {\n        \"position\": \"POSITION\",\n        \"normal\": \"NORMAL\",\n        \"color\": \"COLOR\",\n        \"uv\": \"TEX_COORD\"\n      };\n\n      for (var kind in nativeAttributeTypes) {\n        var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n\n        if (id !== -1) {\n          var attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(kind, attribute);\n        }\n      }\n    }\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(buffer);\n  }\n}\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\n\n\nfunction worker() {\n  var decoderPromise;\n\n  onmessage = function (event) {\n    var data = event.data;\n\n    switch (data.id) {\n      case \"init\":\n        {\n          var decoder = data.decoder;\n\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n\n          postMessage(\"done\");\n          break;\n        }\n\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n\n          decoderPromise.then(function (decoder) {\n            decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\n              postMessage({\n                id: \"indices\",\n                value: indices\n              }, [indices.buffer]);\n            }, function (kind, data) {\n              postMessage({\n                id: kind,\n                value: data\n              }, [data.buffer]);\n            });\n            postMessage(\"done\");\n          });\n          break;\n        }\n    }\n  };\n}\n\nfunction getAbsoluteUrl(url) {\n  if (typeof document !== \"object\" || typeof url !== \"string\") {\n    return url;\n  }\n\n  return Tools.GetAbsoluteUrl(url);\n}\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\n\n\nvar DracoCompression =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n   */\n  function DracoCompression(numWorkers) {\n    if (numWorkers === void 0) {\n      numWorkers = DracoCompression.DefaultNumWorkers;\n    }\n\n    var decoder = DracoCompression.Configuration.decoder;\n    var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n      url: decoder.wasmUrl,\n      wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\n    } : {\n      url: decoder.fallbackUrl,\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n\n    if (numWorkers && typeof Worker === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        var workerContent = decodeMesh + \"(\" + worker + \")()\";\n        var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        var workerPromises = new Array(numWorkers);\n\n        for (var i = 0; i < workerPromises.length; i++) {\n          workerPromises[i] = new Promise(function (resolve, reject) {\n            var worker = new Worker(workerBlobUrl);\n\n            var onError = function (error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n\n            var onMessage = function (message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: getAbsoluteUrl(decoderInfo.url),\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        }\n\n        return Promise.all(workerPromises).then(function (workers) {\n          return new WorkerPool(workers);\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n\n        return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n\n  Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\n    get: function () {\n      var decoder = DracoCompression.Configuration.decoder;\n      return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  DracoCompression.GetDefaultNumWorkers = function () {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    } // Use 50% of the available logical processors but capped at 4.\n\n\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  };\n\n  Object.defineProperty(DracoCompression, \"Default\", {\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\n    get: function () {\n      if (!DracoCompression._Default) {\n        DracoCompression._Default = new DracoCompression();\n      }\n\n      return DracoCompression._Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stop all async operations and release resources.\r\n   */\n\n  DracoCompression.prototype.dispose = function () {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(function (workerPool) {\n        workerPool.dispose();\n      });\n    }\n\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  };\n  /**\r\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n   * @returns a promise that resolves when ready\r\n   */\n\n\n  DracoCompression.prototype.whenReadyAsync = function () {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function () {});\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function () {});\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n    * Decode Draco compressed mesh data to vertex data.\r\n    * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n    * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n    * @returns A promise that resolves with the decoded vertex data\r\n    */\n\n\n  DracoCompression.prototype.decodeMeshAsync = function (data, attributes) {\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(function (workerPool) {\n        return new Promise(function (resolve, reject) {\n          workerPool.push(function (worker, onComplete) {\n            var vertexData = new VertexData();\n\n            var onError = function (error) {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n\n            var onMessage = function (message) {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(vertexData);\n                onComplete();\n              } else if (message.data.id === \"indices\") {\n                vertexData.indices = message.data.value;\n              } else {\n                vertexData.set(message.data.value, message.data.id);\n              }\n            };\n\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            var dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(function (decoder) {\n        var vertexData = new VertexData();\n        decodeMesh(decoder.module, dataView, attributes, function (indices) {\n          vertexData.indices = indices;\n        }, function (kind, data) {\n          vertexData.set(data, kind);\n        });\n        return vertexData;\n      });\n    }\n\n    throw new Error(\"Draco decoder module is not available\");\n  };\n  /**\r\n   * The configuration. Defaults to the following urls:\r\n   * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n   * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n   * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n   */\n\n\n  DracoCompression.Configuration = {\n    decoder: {\n      wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n      wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n      fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n    }\n  };\n  /**\r\n   * Default number of workers to create when creating the draco compression object.\r\n   */\n\n  DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\n  DracoCompression._Default = null;\n  return DracoCompression;\n}();\n\nexport { DracoCompression };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Compression/dracoCompression.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../../Misc/tools\";\r\nimport { WorkerPool } from '../../Misc/workerPool';\r\nimport { Nullable } from \"../../types\";\r\nimport { IDisposable } from \"../../scene\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\n\r\ndeclare var DracoDecoderModule: any;\r\ndeclare var WebAssembly: any;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<any> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module: any) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(decoderModule: any, dataView: ArrayBufferView, attributes: { [kind: string]: number } | undefined, onIndicesData: (data: Uint32Array) => void, onAttributeData: (kind: string, data: Float32Array) => void): void {\r\n    const buffer = new decoderModule.DecoderBuffer();\r\n    buffer.Init(dataView, dataView.byteLength);\r\n\r\n    const decoder = new decoderModule.Decoder();\r\n    let geometry: any;\r\n    let status: any;\r\n\r\n    try {\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH:\r\n                geometry = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\r\n                break;\r\n            case decoderModule.POINT_CLOUD:\r\n                geometry = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n        }\r\n\r\n        if (!status.ok() || !geometry.ptr) {\r\n            throw new Error(status.error_msg());\r\n        }\r\n\r\n        if (type === decoderModule.TRIANGULAR_MESH) {\r\n            const numFaces = geometry.num_faces();\r\n            const numIndices = numFaces * 3;\r\n            const byteLength = numIndices * 4;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\r\n                const indices = new Uint32Array(numIndices);\r\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                onIndicesData(indices);\r\n            }\r\n            finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        }\r\n\r\n        const processAttribute = (kind: string, attribute: any) => {\r\n            var numComponents = attribute.num_components();\r\n            var numPoints = geometry.num_points();\r\n            var numValues = numPoints * numComponents;\r\n            var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n            var ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\r\n                const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\r\n                if (kind === \"color\" && numComponents === 3) {\r\n                    const babylonData = new Float32Array(numPoints * 4);\r\n                    for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\r\n                        babylonData[i + 0] = values[j + 0];\r\n                        babylonData[i + 1] = values[j + 1];\r\n                        babylonData[i + 2] = values[j + 2];\r\n                        babylonData[i + 3] = 1;\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n                else {\r\n                    const babylonData = new Float32Array(numValues);\r\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n            }\r\n            finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(kind, attribute);\r\n            }\r\n        }\r\n        else {\r\n            const nativeAttributeTypes: { [kind: string]: string } = {\r\n                \"position\": \"POSITION\",\r\n                \"normal\": \"NORMAL\",\r\n                \"color\": \"COLOR\",\r\n                \"uv\": \"TEX_COORD\"\r\n            };\r\n\r\n            for (const kind in nativeAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(kind, attribute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        decoderModule.destroy(decoder);\r\n        decoderModule.destroy(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const data = event.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                const decoder = data.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage(\"done\");\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    decodeMesh(decoder, data.dataView, data.attributes, (indices) => {\r\n                        postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\r\n                    }, (kind, data) => {\r\n                        postMessage({ id: kind, value: data }, [data.buffer]);\r\n                    });\r\n                    postMessage(\"done\");\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nfunction getAbsoluteUrl<T>(url: T): T | string {\r\n    if (typeof document !== \"object\" || typeof url !== \"string\") {\r\n        return url;\r\n    }\r\n\r\n    return Tools.GetAbsoluteUrl(url);\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<WorkerPool>;\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined, wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            (decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") ? {\r\n                url: decoder.wasmUrl,\r\n                wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\r\n            } : {\r\n                url: decoder.fallbackUrl,\r\n                wasmBinaryPromise: Promise.resolve(undefined)\r\n            };\r\n\r\n        if (numWorkers && typeof Worker === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const workerPromises = new Array<Promise<Worker>>(numWorkers);\r\n                for (let i = 0; i < workerPromises.length; i++) {\r\n                    workerPromises[i] = new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: getAbsoluteUrl(decoderInfo.url),\r\n                                wasmBinary: decoderWasmBinary,\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n\r\n                return Promise.all(workerPromises).then((workers) => {\r\n                    return new WorkerPool(workers);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => { });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => { });\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n      * Decode Draco compressed mesh data to vertex data.\r\n      * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n      * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n      * @returns A promise that resolves with the decoded vertex data\r\n      */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<VertexData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const vertexData = new VertexData();\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(vertexData);\r\n                                onComplete();\r\n                            }\r\n                            else if (message.data.id === \"indices\") {\r\n                                vertexData.indices = message.data.value;\r\n                            }\r\n                            else {\r\n                                vertexData.set(message.data.value, message.data.id);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                const vertexData = new VertexData();\r\n                decodeMesh(decoder.module, dataView, attributes, (indices) => {\r\n                    vertexData.indices = indices;\r\n                }, (kind, data) => {\r\n                    vertexData.set(data, kind);\r\n                });\r\n                return vertexData;\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}