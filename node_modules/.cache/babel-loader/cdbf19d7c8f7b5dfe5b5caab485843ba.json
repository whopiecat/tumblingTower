{"ast":null,"code":"/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\nvar PostProcessRenderPipelineManager =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a PostProcessRenderPipelineManager\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n   */\n  function PostProcessRenderPipelineManager() {\n    this._renderPipelines = {};\n  }\n\n  Object.defineProperty(PostProcessRenderPipelineManager.prototype, \"supportedPipelines\", {\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\n    get: function () {\n      var result = [];\n\n      for (var renderPipelineName in this._renderPipelines) {\n        if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\n          var pipeline = this._renderPipelines[renderPipelineName];\n\n          if (pipeline.isSupported) {\n            result.push(pipeline);\n          }\n        }\n      }\n\n      return result;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Adds a pipeline to the manager\r\n   * @param renderPipeline The pipeline to add\r\n   */\n\n  PostProcessRenderPipelineManager.prototype.addPipeline = function (renderPipeline) {\n    this._renderPipelines[renderPipeline._name] = renderPipeline;\n  };\n  /**\r\n   * Attaches a camera to the pipeline\r\n   * @param renderPipelineName The name of the pipeline to attach to\r\n   * @param cameras the camera to attach\r\n   * @param unique if the camera can be attached multiple times to the pipeline\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.attachCamerasToRenderPipeline = function (renderPipelineName, cameras, unique) {\n    if (unique === void 0) {\n      unique = false;\n    }\n\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._attachCameras(cameras, unique);\n  };\n  /**\r\n   * Detaches a camera from the pipeline\r\n   * @param renderPipelineName The name of the pipeline to detach from\r\n   * @param cameras the camera to detach\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.detachCamerasFromRenderPipeline = function (renderPipelineName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._detachCameras(cameras);\n  };\n  /**\r\n   * Enables an effect by name on a pipeline\r\n   * @param renderPipelineName the name of the pipeline to enable the effect in\r\n   * @param renderEffectName the name of the effect to enable\r\n   * @param cameras the cameras that the effect should be enabled on\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.enableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._enableEffect(renderEffectName, cameras);\n  };\n  /**\r\n   * Disables an effect by name on a pipeline\r\n   * @param renderPipelineName the name of the pipeline to disable the effect in\r\n   * @param renderEffectName the name of the effect to disable\r\n   * @param cameras the cameras that the effect should be disabled on\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.disableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n    var renderPipeline = this._renderPipelines[renderPipelineName];\n\n    if (!renderPipeline) {\n      return;\n    }\n\n    renderPipeline._disableEffect(renderEffectName, cameras);\n  };\n  /**\r\n   * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.update = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n\n        if (!pipeline.isSupported) {\n          pipeline.dispose();\n          delete this._renderPipelines[renderPipelineName];\n        } else {\n          pipeline._update();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipelineManager.prototype._rebuild = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n\n        pipeline._rebuild();\n      }\n    }\n  };\n  /**\r\n   * Disposes of the manager and pipelines\r\n   */\n\n\n  PostProcessRenderPipelineManager.prototype.dispose = function () {\n    for (var renderPipelineName in this._renderPipelines) {\n      if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\n        var pipeline = this._renderPipelines[renderPipelineName];\n        pipeline.dispose();\n      }\n    }\n  };\n\n  return PostProcessRenderPipelineManager;\n}();\n\nexport { PostProcessRenderPipelineManager };","map":{"version":3,"sources":["../../../../sourceES6/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Camera } from \"../../Cameras/camera\";\r\nimport { PostProcessRenderPipeline } from \"./postProcessRenderPipeline\";\r\n/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\r\nexport class PostProcessRenderPipelineManager {\r\n    private _renderPipelines: { [Key: string]: PostProcessRenderPipeline };\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipelineManager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n     */\r\n    constructor() {\r\n        this._renderPipelines = {};\r\n    }\r\n\r\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\r\n    public get supportedPipelines(): PostProcessRenderPipeline[] {\r\n        let result = [];\r\n\r\n        for (var renderPipelineName in this._renderPipelines) {\r\n            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\r\n                var pipeline = this._renderPipelines[renderPipelineName];\r\n                if (pipeline.isSupported) {\r\n                    result.push(pipeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a pipeline to the manager\r\n     * @param renderPipeline The pipeline to add\r\n     */\r\n    public addPipeline(renderPipeline: PostProcessRenderPipeline): void {\r\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\r\n    }\r\n\r\n    /**\r\n     * Attaches a camera to the pipeline\r\n     * @param renderPipelineName The name of the pipeline to attach to\r\n     * @param cameras the camera to attach\r\n     * @param unique if the camera can be attached multiple times to the pipeline\r\n     */\r\n    public attachCamerasToRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera, unique: boolean = false): void {\r\n        var renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._attachCameras(cameras, unique);\r\n    }\r\n\r\n    /**\r\n     * Detaches a camera from the pipeline\r\n     * @param renderPipelineName The name of the pipeline to detach from\r\n     * @param cameras the camera to detach\r\n     */\r\n    public detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: any | Camera[] | Camera): void {\r\n        var renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._detachCameras(cameras);\r\n    }\r\n\r\n    /**\r\n     * Enables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to enable the effect in\r\n     * @param renderEffectName the name of the effect to enable\r\n     * @param cameras the cameras that the effect should be enabled on\r\n     */\r\n    public enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        var renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._enableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Disables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to disable the effect in\r\n     * @param renderEffectName the name of the effect to disable\r\n     * @param cameras the cameras that the effect should be disabled on\r\n     */\r\n    public disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: any | Camera[] | Camera): void {\r\n        var renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._disableEffect(renderEffectName, cameras);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n     */\r\n    public update(): void {\r\n        for (var renderPipelineName in this._renderPipelines) {\r\n            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\r\n                var pipeline = this._renderPipelines[renderPipelineName];\r\n                if (!pipeline.isSupported) {\r\n                    pipeline.dispose();\r\n                    delete this._renderPipelines[renderPipelineName];\r\n                } else {\r\n                    pipeline._update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        for (var renderPipelineName in this._renderPipelines) {\r\n            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\r\n                var pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the manager and pipelines\r\n     */\r\n    public dispose(): void {\r\n        for (var renderPipelineName in this._renderPipelines) {\r\n            if (this._renderPipelines.hasOwnProperty(renderPipelineName)) {\r\n                var pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}