{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n */\n\nvar AutoRotationBehavior =\n/** @class */\nfunction () {\n  function AutoRotationBehavior() {\n    this._zoomStopsAnimation = false;\n    this._idleRotationSpeed = 0.05;\n    this._idleRotationWaitTime = 2000;\n    this._idleRotationSpinupTime = 2000;\n    this._isPointerDown = false;\n    this._lastFrameTime = null;\n    this._lastInteractionTime = -Infinity;\n    this._cameraRotationSpeed = 0;\n    this._lastFrameRadius = 0;\n  }\n\n  Object.defineProperty(AutoRotationBehavior.prototype, \"name\", {\n    /**\r\n     * Gets the name of the behavior.\r\n     */\n    get: function () {\n      return \"AutoRotation\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"zoomStopsAnimation\", {\n    /**\r\n    * Gets the flag that indicates if user zooming should stop animation.\r\n    */\n    get: function () {\n      return this._zoomStopsAnimation;\n    },\n\n    /**\r\n    * Sets the flag that indicates if user zooming should stop animation.\r\n    */\n    set: function (flag) {\n      this._zoomStopsAnimation = flag;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpeed\", {\n    /**\r\n    * Gets the default speed at which the camera rotates around the model.\r\n    */\n    get: function () {\n      return this._idleRotationSpeed;\n    },\n\n    /**\r\n    * Sets the default speed at which the camera rotates around the model.\r\n    */\n    set: function (speed) {\n      this._idleRotationSpeed = speed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationWaitTime\", {\n    /**\r\n    * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n    */\n    get: function () {\n      return this._idleRotationWaitTime;\n    },\n\n    /**\r\n    * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n    */\n    set: function (time) {\n      this._idleRotationWaitTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"idleRotationSpinupTime\", {\n    /**\r\n    * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n    */\n    get: function () {\n      return this._idleRotationSpinupTime;\n    },\n\n    /**\r\n    * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n    */\n    set: function (time) {\n      this._idleRotationSpinupTime = time;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AutoRotationBehavior.prototype, \"rotationInProgress\", {\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\n    get: function () {\n      return Math.abs(this._cameraRotationSpeed) > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initializes the behavior.\r\n   */\n\n  AutoRotationBehavior.prototype.init = function () {// Do notihng\n  };\n  /**\r\n   * Attaches the behavior to its arc rotate camera.\r\n   * @param camera Defines the camera to attach the behavior to\r\n   */\n\n\n  AutoRotationBehavior.prototype.attach = function (camera) {\n    var _this = this;\n\n    this._attachedCamera = camera;\n\n    var scene = this._attachedCamera.getScene();\n\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(function (pointerInfoPre) {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        _this._isPointerDown = true;\n        return;\n      }\n\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        _this._isPointerDown = false;\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(function () {\n      var now = PrecisionDate.Now;\n      var dt = 0;\n\n      if (_this._lastFrameTime != null) {\n        dt = now - _this._lastFrameTime;\n      }\n\n      _this._lastFrameTime = now; // Stop the animation if there is user interaction and the animation should stop for this interaction\n\n      _this._applyUserInteraction();\n\n      var timeToRotation = now - _this._lastInteractionTime - _this._idleRotationWaitTime;\n      var scale = Math.max(Math.min(timeToRotation / _this._idleRotationSpinupTime, 1), 0);\n      _this._cameraRotationSpeed = _this._idleRotationSpeed * scale; // Step camera rotation by rotation speed\n\n      if (_this._attachedCamera) {\n        _this._attachedCamera.alpha -= _this._cameraRotationSpeed * (dt / 1000);\n      }\n    });\n  };\n  /**\r\n   * Detaches the behavior from its current arc rotate camera.\r\n   */\n\n\n  AutoRotationBehavior.prototype.detach = function () {\n    if (!this._attachedCamera) {\n      return;\n    }\n\n    var scene = this._attachedCamera.getScene();\n\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n\n    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n\n    this._attachedCamera = null;\n  };\n  /**\r\n   * Returns true if user is scrolling.\r\n   * @return true if user is scrolling.\r\n   */\n\n\n  AutoRotationBehavior.prototype._userIsZooming = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    return this._attachedCamera.inertialRadiusOffset !== 0;\n  };\n\n  AutoRotationBehavior.prototype._shouldAnimationStopForInteraction = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    var zoomHasHitLimit = false;\n\n    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\n      zoomHasHitLimit = true;\n    } // Update the record of previous radius - works as an approx. indicator of hitting radius limits\n\n\n    this._lastFrameRadius = this._attachedCamera.radius;\n    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\n  };\n  /**\r\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n   */\n\n\n  AutoRotationBehavior.prototype._applyUserInteraction = function () {\n    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\n      this._lastInteractionTime = PrecisionDate.Now;\n    }\n  }; // Tools\n\n\n  AutoRotationBehavior.prototype._userIsMoving = function () {\n    if (!this._attachedCamera) {\n      return false;\n    }\n\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  };\n\n  return AutoRotationBehavior;\n}();\n\nexport { AutoRotationBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Cameras/autoRotationBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Behavior } from \"../../Behaviors/behavior\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { PointerInfoPre, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    /**\r\n    * Sets the flag that indicates if user zooming should stop animation.\r\n    */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n    * Gets the flag that indicates if user zooming should stop animation.\r\n    */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n    * Sets the default speed at which the camera rotates around the model.\r\n    */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n    * Gets the default speed at which the camera rotates around the model.\r\n    */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n    * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n    */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n    * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n    */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n    * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n    */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n    * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n    */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do notihng\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        let scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            let now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            let timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            let scale = Math.max(Math.min(timeToRotation / (this._idleRotationSpinupTime), 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        let scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @return true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        var zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}