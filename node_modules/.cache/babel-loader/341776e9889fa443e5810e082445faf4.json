{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { RibbonBuilder } from \"./ribbonBuilder\";\n\nMesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\n  var options = {\n    shape: shape,\n    radius: radius,\n    tessellation: tessellation,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return LatheBuilder.CreateLathe(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar LatheBuilder =\n/** @class */\nfunction () {\n  function LatheBuilder() {}\n  /**\r\n   * Creates lathe mesh.\r\n   * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n   * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n   * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n   * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n   * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n   * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n   * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the lathe mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\r\n   */\n\n\n  LatheBuilder.CreateLathe = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc : 1.0;\n    var closed = options.closed === undefined ? true : options.closed;\n    var shape = options.shape;\n    var radius = options.radius || 1;\n    var tessellation = options.tessellation || 64;\n    var clip = options.clip || 0;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    var cap = options.cap || Mesh.NO_CAP;\n    var pi2 = Math.PI * 2;\n    var paths = new Array();\n    var invertUV = options.invertUV || false;\n    var i = 0;\n    var p = 0;\n    var step = pi2 / tessellation * arc;\n    var rotated;\n    var path = new Array();\n\n    for (i = 0; i <= tessellation - clip; i++) {\n      var path = [];\n\n      if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\n        path.push(new Vector3(0, shape[0].y, 0));\n        path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n      }\n\n      for (p = 0; p < shape.length; p++) {\n        rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n        path.push(rotated);\n      }\n\n      if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\n        path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n        path.push(new Vector3(0, shape[shape.length - 1].y, 0));\n      }\n\n      paths.push(path);\n    } // lathe ribbon\n\n\n    var lathe = RibbonBuilder.CreateRibbon(name, {\n      pathArray: paths,\n      closeArray: closed,\n      sideOrientation: sideOrientation,\n      updatable: updatable,\n      invertUV: invertUV,\n      frontUVs: options.frontUVs,\n      backUVs: options.backUVs\n    }, scene);\n    return lathe;\n  };\n\n  return LatheBuilder;\n}();\n\nexport { LatheBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/latheBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Nullable } from '../../types';\r\n\r\nMesh.CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return LatheBuilder.CreateLathe(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class LatheBuilder {\r\n    /**\r\n     * Creates lathe mesh.\r\n     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n     * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n     * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n     * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n     * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n     * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the lathe mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\r\n     */\r\n    public static CreateLathe(name: string, options: { shape: Vector3[], radius?: number, tessellation?: number, clip?: number, arc?: number, closed?: boolean, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, cap?: number, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var arc: number = options.arc ? ((options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc) : 1.0;\r\n        var closed: boolean = (options.closed === undefined) ? true : options.closed;\r\n        var shape = options.shape;\r\n        var radius = options.radius || 1;\r\n        var tessellation = options.tessellation || 64;\r\n        var clip = options.clip || 0;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var cap = options.cap || Mesh.NO_CAP;\r\n        var pi2 = Math.PI * 2;\r\n        var paths = new Array();\r\n        var invertUV = options.invertUV || false;\r\n\r\n        var i = 0;\r\n        var p = 0;\r\n        var step = pi2 / tessellation * arc;\r\n        var rotated;\r\n        var path = new Array<Vector3>();\r\n        for (i = 0; i <= tessellation - clip; i++) {\r\n            var path: Vector3[] = [];\r\n            if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n                path.push(new Vector3(0, shape[0].y, 0));\r\n                path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n            }\r\n            for (p = 0; p < shape.length; p++) {\r\n                rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n                path.push(rotated);\r\n            }\r\n            if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n                path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n                path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n            }\r\n            paths.push(path);\r\n        }\r\n\r\n        // lathe ribbon\r\n        var lathe = RibbonBuilder.CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\r\n        return lathe;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}