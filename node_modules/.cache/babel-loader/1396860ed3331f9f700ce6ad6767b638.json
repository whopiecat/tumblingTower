{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\nimport { Scalar } from \"../../Maths/math.scalar\";\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\n\nvar ConeParticleEmitter =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance ConeParticleEmitter\r\n   * @param radius the radius of the emission cone (1 by default)\r\n   * @param angle the cone base angle (PI by default)\r\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n   */\n  function ConeParticleEmitter(radius, angle,\n  /** defines how much to randomize the particle direction [0-1] (default is 0) */\n  directionRandomizer) {\n    if (radius === void 0) {\n      radius = 1;\n    }\n\n    if (angle === void 0) {\n      angle = Math.PI;\n    }\n\n    if (directionRandomizer === void 0) {\n      directionRandomizer = 0;\n    }\n\n    this.directionRandomizer = directionRandomizer;\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\n\n    this.radiusRange = 1;\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\n\n    this.heightRange = 1;\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\n\n    this.emitFromSpawnPointOnly = false;\n    this.angle = angle;\n    this.radius = radius;\n  }\n\n  Object.defineProperty(ConeParticleEmitter.prototype, \"radius\", {\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\n    get: function () {\n      return this._radius;\n    },\n    set: function (value) {\n      this._radius = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConeParticleEmitter.prototype, \"angle\", {\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\n    get: function () {\n      return this._angle;\n    },\n    set: function (value) {\n      this._angle = value;\n\n      this._buildHeight();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ConeParticleEmitter.prototype._buildHeight = function () {\n    if (this._angle !== 0) {\n      this._height = this._radius / Math.tan(this._angle / 2);\n    } else {\n      this._height = 1;\n    }\n  };\n  /**\r\n   * Called by the particle System when the direction is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param directionToUpdate is the direction vector to update with the result\r\n   * @param particle is the particle we are computed the direction for\r\n   * @param isLocal defines if the direction should be set in local space\r\n   */\n\n\n  ConeParticleEmitter.prototype.startDirectionFunction = function (worldMatrix, directionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n    } else {\n      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n    }\n\n    var randX = Scalar.RandomRange(0, this.directionRandomizer);\n    var randY = Scalar.RandomRange(0, this.directionRandomizer);\n    var randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n    directionToUpdate.normalize();\n  };\n  /**\r\n   * Called by the particle System when the position is computed for the created particle.\r\n   * @param worldMatrix is the world matrix of the particle system\r\n   * @param positionToUpdate is the position vector to update with the result\r\n   * @param particle is the particle we are computed the position for\r\n   * @param isLocal defines if the position should be set in local space\r\n   */\n\n\n  ConeParticleEmitter.prototype.startPositionFunction = function (worldMatrix, positionToUpdate, particle, isLocal) {\n    var s = Scalar.RandomRange(0, Math.PI * 2);\n    var h;\n\n    if (!this.emitFromSpawnPointOnly) {\n      h = Scalar.RandomRange(0, this.heightRange); // Better distribution in a cone at normal angles.\n\n      h = 1 - h * h;\n    } else {\n      h = 0.0001;\n    }\n\n    var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n    radius = radius * h;\n    var randX = radius * Math.sin(s);\n    var randZ = radius * Math.cos(s);\n    var randY = h * this._height;\n\n    if (isLocal) {\n      positionToUpdate.x = randX;\n      positionToUpdate.y = randY;\n      positionToUpdate.z = randZ;\n      return;\n    }\n\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  };\n  /**\r\n   * Clones the current emitter and returns a copy of it\r\n   * @returns the new emitter\r\n   */\n\n\n  ConeParticleEmitter.prototype.clone = function () {\n    var newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  };\n  /**\r\n   * Called by the GPUParticleSystem to setup the update shader\r\n   * @param effect defines the update shader\r\n   */\n\n\n  ConeParticleEmitter.prototype.applyToShader = function (effect) {\n    effect.setFloat2(\"radius\", this._radius, this.radiusRange);\n    effect.setFloat(\"coneAngle\", this._angle);\n    effect.setFloat2(\"height\", this._height, this.heightRange);\n    effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  };\n  /**\r\n   * Returns a string to use to update the GPU particles update shader\r\n   * @returns a string containng the defines string\r\n   */\n\n\n  ConeParticleEmitter.prototype.getEffectDefines = function () {\n    var defines = \"#define CONEEMITTER\";\n\n    if (this.emitFromSpawnPointOnly) {\n      defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n    }\n\n    return defines;\n  };\n  /**\r\n   * Returns the string \"ConeParticleEmitter\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  ConeParticleEmitter.prototype.getClassName = function () {\n    return \"ConeParticleEmitter\";\n  };\n  /**\r\n   * Serializes the particle system to a JSON object.\r\n   * @returns the JSON object\r\n   */\n\n\n  ConeParticleEmitter.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this._radius;\n    serializationObject.angle = this._angle;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.heightRange = this.heightRange;\n    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n    return serializationObject;\n  };\n  /**\r\n   * Parse properties from a JSON object\r\n   * @param serializationObject defines the JSON object\r\n   */\n\n\n  ConeParticleEmitter.prototype.parse = function (serializationObject) {\n    this.radius = serializationObject.radius;\n    this.angle = serializationObject.angle;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n    this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n    this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n  };\n\n  return ConeParticleEmitter;\n}();\n\nexport { ConeParticleEmitter };","map":{"version":3,"sources":["../../../../sourceES6/core/Particles/EmitterTypes/coneParticleEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Effect } from \"../../Materials/effect\";\r\nimport { Particle } from \"../../Particles/particle\";\r\nimport { IParticleEmitterType } from \"./IParticleEmitterType\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\r\nexport class ConeParticleEmitter implements IParticleEmitterType {\r\n    private _radius: number;\r\n    private _angle: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public radiusRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public heightRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\r\n    public emitFromSpawnPointOnly = false;\r\n\r\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    private _buildHeight() {\r\n        if (this._angle !== 0) {\r\n            this._height = this._radius / Math.tan(this._angle / 2);\r\n        }\r\n        else {\r\n            this._height = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConeParticleEmitter\r\n     * @param radius the radius of the emission cone (1 by default)\r\n     * @param angle the cone base angle (PI by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n     */\r\n    constructor(radius = 1, angle = Math.PI,\r\n        /** defines how much to randomize the particle direction [0-1] (default is 0) */\r\n        public directionRandomizer = 0) {\r\n        this.angle = angle;\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition!).normalize();\r\n        }\r\n        else {\r\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\r\n        }\r\n\r\n        var randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        var randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        var randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\r\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\r\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\r\n        directionToUpdate.normalize();\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        var s = Scalar.RandomRange(0, Math.PI * 2);\r\n        var h: number;\r\n\r\n        if (!this.emitFromSpawnPointOnly) {\r\n            h = Scalar.RandomRange(0, this.heightRange);\r\n            // Better distribution in a cone at normal angles.\r\n            h = 1 - h * h;\r\n        } else {\r\n            h = 0.0001;\r\n        }\r\n        var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\r\n        radius = radius * h;\r\n\r\n        var randX = radius * Math.sin(s);\r\n        var randZ = radius * Math.cos(s);\r\n        var randY = h * this._height;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): ConeParticleEmitter {\r\n        let newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param effect defines the update shader\r\n     */\r\n    public applyToShader(effect: Effect): void {\r\n        effect.setFloat2(\"radius\", this._radius, this.radiusRange);\r\n        effect.setFloat(\"coneAngle\", this._angle);\r\n        effect.setFloat2(\"height\", this._height, this.heightRange);\r\n        effect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containng the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        let defines = \"#define CONEEMITTER\";\r\n\r\n        if (this.emitFromSpawnPointOnly) {\r\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\r\n        }\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ConeParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ConeParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this._radius;\r\n        serializationObject.angle = this._angle;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.heightRange = this.heightRange;\r\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.angle = serializationObject.angle;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n\r\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\r\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\r\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}