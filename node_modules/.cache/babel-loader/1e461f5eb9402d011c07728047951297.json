{"ast":null,"code":"/**\r\n * Class used to inline functions in shader code\r\n*/\nvar ShaderCodeInliner =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the inliner\r\n   * @param sourceCode shader code source to inline\r\n   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n   */\n  function ShaderCodeInliner(sourceCode, numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n    /** Gets or sets the debug mode */\n\n\n    this.debug = false;\n    this._sourceCode = sourceCode;\n    this._numMaxIterations = numMaxIterations;\n    this._functionDescr = [];\n    this.inlineToken = \"#define inline\";\n  }\n\n  Object.defineProperty(ShaderCodeInliner.prototype, \"code\", {\n    /** Gets the code after the inlining process */\n    get: function () {\n      return this._sourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Start the processing of the shader code\r\n   */\n\n  ShaderCodeInliner.prototype.processCode = function () {\n    if (this.debug) {\n      console.log(\"Start inlining process (code size=\" + this._sourceCode.length + \")...\");\n    }\n\n    this._collectFunctions();\n\n    this._processInlining(this._numMaxIterations);\n\n    if (this.debug) {\n      console.log(\"End of inlining process.\");\n    }\n  };\n\n  ShaderCodeInliner.prototype._collectFunctions = function () {\n    var startIndex = 0;\n\n    while (startIndex < this._sourceCode.length) {\n      // locate the function to inline and extract its name\n      var inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\n\n      if (inlineTokenIndex < 0) {\n        break;\n      }\n\n      var funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\n\n      if (funcParamsStartIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not find the opening parenthesis after the token. startIndex=\" + startIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n\n      if (!funcNameMatch) {\n        if (this.debug) {\n          console.warn(\"Could not extract the name/type of the function from: \" + this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var _a = [funcNameMatch[3], funcNameMatch[4]],\n          funcType = _a[0],\n          funcName = _a[1]; // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\n\n      var funcParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, funcParamsStartIndex);\n\n      if (funcParamsEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the parameters the function '\" + funcName + \"' (type=\" + funcType + \"). funcParamsStartIndex=\" + funcParamsStartIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex); // extract the body of the function (with the curly brackets)\n\n\n      var funcBodyStartIndex = this._skipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\n\n      if (funcBodyStartIndex === this._sourceCode.length) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\" + funcName + \"' (type=\" + funcType + \"). funcParamsEndIndex=\" + funcParamsEndIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBodyEndIndex = this._extractBetweenMarkers('{', '}', this._sourceCode, funcBodyStartIndex);\n\n      if (funcBodyEndIndex < 0) {\n        if (this.debug) {\n          console.warn(\"Could not extract the body of the function '\" + funcName + \"' (type=\" + funcType + \"). funcBodyStartIndex=\" + funcBodyStartIndex);\n        }\n\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n\n      var funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1); // process the parameters: extract each names\n\n\n      var params = this._removeComments(funcParams).split(\",\");\n\n      var paramNames = [];\n\n      for (var p = 0; p < params.length; ++p) {\n        var param = params[p].trim();\n        var idx = param.lastIndexOf(\" \");\n\n        if (idx >= 0) {\n          paramNames.push(param.substring(idx + 1));\n        }\n      }\n\n      if (funcType !== 'void') {\n        // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\n        paramNames.push('return');\n      } // collect the function\n\n\n      this._functionDescr.push({\n        \"name\": funcName,\n        \"type\": funcType,\n        \"parameters\": paramNames,\n        \"body\": funcBody,\n        \"callIndex\": 0\n      });\n\n      startIndex = funcBodyEndIndex + 1; // remove the function from the source code\n\n      var partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\n      var partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\n      this._sourceCode = partBefore + partAfter;\n      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\n    }\n\n    if (this.debug) {\n      console.log(\"Collect functions: \" + this._functionDescr.length + \" functions found. functionDescr=\", this._functionDescr);\n    }\n  };\n\n  ShaderCodeInliner.prototype._processInlining = function (numMaxIterations) {\n    if (numMaxIterations === void 0) {\n      numMaxIterations = 20;\n    }\n\n    while (numMaxIterations-- >= 0) {\n      if (!this._replaceFunctionCallsByCode()) {\n        break;\n      }\n    }\n\n    if (this.debug) {\n      console.log(\"numMaxIterations is \" + numMaxIterations + \" after inlining process\");\n    }\n\n    return numMaxIterations >= 0;\n  };\n\n  ShaderCodeInliner.prototype._extractBetweenMarkers = function (markerOpen, markerClose, block, startIndex) {\n    var currPos = startIndex,\n        openMarkers = 0,\n        waitForChar = '';\n\n    while (currPos < block.length) {\n      var currChar = block.charAt(currPos);\n\n      if (!waitForChar) {\n        switch (currChar) {\n          case markerOpen:\n            openMarkers++;\n            break;\n\n          case markerClose:\n            openMarkers--;\n            break;\n\n          case '\"':\n          case \"'\":\n          case \"`\":\n            waitForChar = currChar;\n            break;\n\n          case '/':\n            if (currPos + 1 < block.length) {\n              var nextChar = block.charAt(currPos + 1);\n\n              if (nextChar === '/') {\n                waitForChar = '\\n';\n              } else if (nextChar === '*') {\n                waitForChar = '*/';\n              }\n            }\n\n            break;\n        }\n      } else {\n        if (currChar === waitForChar) {\n          if (waitForChar === '\"' || waitForChar === \"'\") {\n            block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\n          } else {\n            waitForChar = '';\n          }\n        } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\n          block.charAt(currPos + 1) === '/' && (waitForChar = '');\n\n          if (waitForChar === '') {\n            currPos++;\n          }\n        }\n      }\n\n      currPos++;\n\n      if (openMarkers === 0) {\n        break;\n      }\n    }\n\n    return openMarkers === 0 ? currPos - 1 : -1;\n  };\n\n  ShaderCodeInliner.prototype._skipWhitespaces = function (s, index) {\n    while (index < s.length) {\n      var c = s[index];\n\n      if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== '\\u000a' && c !== '\\u00a0') {\n        break;\n      }\n\n      index++;\n    }\n\n    return index;\n  };\n\n  ShaderCodeInliner.prototype._removeComments = function (block) {\n    var currPos = 0,\n        waitForChar = '',\n        inComments = false,\n        s = [];\n\n    while (currPos < block.length) {\n      var currChar = block.charAt(currPos);\n\n      if (!waitForChar) {\n        switch (currChar) {\n          case '\"':\n          case \"'\":\n          case \"`\":\n            waitForChar = currChar;\n            break;\n\n          case '/':\n            if (currPos + 1 < block.length) {\n              var nextChar = block.charAt(currPos + 1);\n\n              if (nextChar === '/') {\n                waitForChar = '\\n';\n                inComments = true;\n              } else if (nextChar === '*') {\n                waitForChar = '*/';\n                inComments = true;\n              }\n            }\n\n            break;\n        }\n\n        if (!inComments) {\n          s.push(currChar);\n        }\n      } else {\n        if (currChar === waitForChar) {\n          if (waitForChar === '\"' || waitForChar === \"'\") {\n            block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\n            s.push(currChar);\n          } else {\n            waitForChar = '';\n            inComments = false;\n          }\n        } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\n          block.charAt(currPos + 1) === '/' && (waitForChar = '');\n\n          if (waitForChar === '') {\n            inComments = false;\n            currPos++;\n          }\n        } else {\n          if (!inComments) {\n            s.push(currChar);\n          }\n        }\n      }\n\n      currPos++;\n    }\n\n    return s.join('');\n  };\n\n  ShaderCodeInliner.prototype._replaceFunctionCallsByCode = function () {\n    var doAgain = false;\n\n    for (var _i = 0, _a = this._functionDescr; _i < _a.length; _i++) {\n      var func = _a[_i];\n      var name_1 = func.name,\n          type = func.type,\n          parameters = func.parameters,\n          body = func.body;\n      var startIndex = 0;\n\n      while (startIndex < this._sourceCode.length) {\n        // Look for the function name in the source code\n        var functionCallIndex = this._sourceCode.indexOf(name_1, startIndex);\n\n        if (functionCallIndex < 0) {\n          break;\n        } // Find the opening parenthesis\n\n\n        var callParamsStartIndex = this._skipWhitespaces(this._sourceCode, functionCallIndex + name_1.length);\n\n        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== '(') {\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        } // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\n\n\n        var callParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, callParamsStartIndex);\n\n        if (callParamsEndIndex < 0) {\n          if (this.debug) {\n            console.warn(\"Could not extract the parameters of the function call. Function '\" + name_1 + \"' (type=\" + type + \"). callParamsStartIndex=\" + callParamsStartIndex);\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        var callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex); // process the parameter call: extract each names\n\n\n        var params = this._removeComments(callParams).split(\",\");\n\n        var paramNames = [];\n\n        for (var p = 0; p < params.length; ++p) {\n          var param = params[p].trim();\n          paramNames.push(param);\n        }\n\n        var retParamName = type !== 'void' ? name_1 + '_' + func.callIndex++ : null;\n\n        if (retParamName) {\n          paramNames.push(retParamName + ' =');\n        }\n\n        if (paramNames.length !== parameters.length) {\n          if (this.debug) {\n            console.warn(\"Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '\" + name_1 + \"' (type=\" + type + \"). function parameters=\" + parameters + \", call parameters=\" + paramNames);\n          }\n\n          startIndex = functionCallIndex + name_1.length;\n          continue;\n        }\n\n        startIndex = callParamsEndIndex + 1; // replace the function call by the body function\n\n        var funcBody = this._replaceNames(body, parameters, paramNames);\n\n        var partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\n        var partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\n\n        if (retParamName) {\n          // case where the function returns a value. We generate:\n          // FUNCTYPE retParamName;\n          // {function body}\n          // and replace the function call by retParamName\n          var injectDeclarationIndex = this._findBackward(this._sourceCode, functionCallIndex - 1, '\\n');\n\n          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\n\n          var partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\n\n          this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\" + name_1 + \"' (type=\" + type + \"). injectDeclarationIndex=\" + injectDeclarationIndex);\n          }\n        } else {\n          // simple case where the return value of the function is \"void\"\n          this._sourceCode = partBefore + funcBody + partAfter;\n          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\n\n          if (this.debug) {\n            console.log(\"Replace function call by code. Function '\" + name_1 + \"' (type=\" + type + \"). functionCallIndex=\" + functionCallIndex);\n          }\n        }\n\n        doAgain = true;\n      }\n    }\n\n    return doAgain;\n  };\n\n  ShaderCodeInliner.prototype._findBackward = function (s, index, c) {\n    while (index >= 0 && s.charAt(index) !== c) {\n      index--;\n    }\n\n    return index;\n  };\n\n  ShaderCodeInliner.prototype._escapeRegExp = function (s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  };\n\n  ShaderCodeInliner.prototype._replaceNames = function (code, sources, destinations) {\n    for (var i = 0; i < sources.length; ++i) {\n      var source = new RegExp(this._escapeRegExp(sources[i]), 'g'),\n          destination = destinations[i];\n      code = code.replace(source, destination);\n    }\n\n    return code;\n  };\n\n  ShaderCodeInliner._RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\n  return ShaderCodeInliner;\n}();\n\nexport { ShaderCodeInliner };","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Processors/shaderCodeInliner.ts"],"names":[],"mappings":"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","sourcesContent":["interface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n*/\r\nexport class ShaderCodeInliner {\r\n\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            console.log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            console.log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = this._skipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = this._extractBetweenMarkers('{', '}', this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = this._removeComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== 'void') {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push('return');\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                \"name\": funcName,\r\n                \"type\": funcType,\r\n                \"parameters\": paramNames,\r\n                \"body\": funcBody,\r\n                \"callIndex\": 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _extractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n        let currPos = startIndex,\r\n            openMarkers = 0,\r\n            waitForChar = '';\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case markerOpen:\r\n                        openMarkers++;\r\n                        break;\r\n                    case markerClose:\r\n                        openMarkers--;\r\n                        break;\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                    } else {\r\n                        waitForChar = '';\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        currPos++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++ ;\r\n            if (openMarkers === 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return openMarkers === 0 ? currPos - 1 : -1;\r\n    }\r\n\r\n    private _skipWhitespaces(s: string, index: number): number {\r\n        while (index < s.length) {\r\n            const c = s[index];\r\n            if (c !== ' ' && c !== '\\n' && c !== '\\r' && c !== '\\t' && c !== '\\u000a' && c !== '\\u00a0') {\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    private _removeComments(block: string): string {\r\n        let currPos = 0,\r\n            waitForChar = '',\r\n            inComments = false,\r\n            s = [];\r\n\r\n        while (currPos < block.length) {\r\n            let currChar = block.charAt(currPos);\r\n\r\n            if (!waitForChar) {\r\n                switch (currChar) {\r\n                    case '\"':\r\n                    case \"'\":\r\n                    case \"`\":\r\n                        waitForChar = currChar;\r\n                        break;\r\n                    case '/':\r\n                        if (currPos + 1 < block.length) {\r\n                            const nextChar = block.charAt(currPos + 1);\r\n                            if (nextChar === '/') {\r\n                                waitForChar = '\\n';\r\n                                inComments = true;\r\n                            } else if (nextChar === '*') {\r\n                                waitForChar = '*/';\r\n                                inComments = true;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            } else {\r\n                if (currChar === waitForChar) {\r\n                    if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                        block.charAt(currPos - 1) !== '\\\\' && (waitForChar = '');\r\n                        s.push(currChar);\r\n                    } else {\r\n                        waitForChar = '';\r\n                        inComments = false;\r\n                    }\r\n                } else if (waitForChar === '*/' && currChar === '*' && currPos + 1 < block.length) {\r\n                    block.charAt(currPos + 1) === '/' && (waitForChar = '');\r\n                    if (waitForChar === '') {\r\n                        inComments = false;\r\n                        currPos++;\r\n                    }\r\n                } else {\r\n                    if (!inComments) {\r\n                        s.push(currChar);\r\n                    }\r\n                }\r\n            }\r\n\r\n            currPos++ ;\r\n        }\r\n\r\n        return s.join('');\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = this._skipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== '(') {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = this._extractBetweenMarkers('(', ')', this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        console.warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n                const params = this._removeComments(callParams).split(\",\");\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== 'void' ? name + '_' + (func.callIndex++) : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + ' =');\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        console.warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                let partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = this._findBackward(this._sourceCode, functionCallIndex - 1, '\\n');\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    let partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}`);\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _findBackward(s: string, index: number, c: string): number {\r\n        while (index >= 0 && s.charAt(index) !== c) {\r\n            index--;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    private _escapeRegExp(s: string): string {\r\n        return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(this._escapeRegExp(sources[i]), 'g'),\r\n                  destination = destinations[i];\r\n\r\n            code = code.replace(source, destination);\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}