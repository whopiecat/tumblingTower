{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { Vector2 } from \"../../Maths/math.vector\";\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\n/**\r\n * Define the code related to the anisotropic parameters of the pbr material.\r\n */\n\nvar PBRAnisotropicConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of anisotropy configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   */\n  function PBRAnisotropicConfiguration(markAllSubMeshesAsTexturesDirty) {\n    this._isEnabled = false;\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\n\n    this.isEnabled = false;\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\n\n    this.intensity = 1;\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"strectching\" the highlights along the tangents.\r\n     */\n\n    this.direction = new Vector2(1, 0);\n    this._texture = null;\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\n\n    this.texture = null;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n  }\n  /** @hidden */\n\n\n  PBRAnisotropicConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param mesh the mesh we are preparing the defines for.\r\n   * @param scene defines the scene the material belongs to.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.prepareDefines = function (defines, mesh, scene) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param isFrozen defines wether the material is frozen or not.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen) {\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      } // Anisotropy\n\n\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRAnisotropicConfiguration\"\r\n  */\n\n\n  PBRAnisotropicConfiguration.prototype.getClassName = function () {\n    return \"PBRAnisotropicConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vAnisotropy\", \"vAnisotropyInfos\", \"anisotropyMatrix\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRAnisotropicConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vAnisotropy\", 3);\n    uniformBuffer.addUniform(\"vAnisotropyInfos\", 2);\n    uniformBuffer.addUniform(\"anisotropyMatrix\", 16);\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRAnisotropicConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"anisotropySampler\");\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param anisotropicConfiguration define the config where to copy the info\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.copyTo = function (anisotropicConfiguration) {\n    SerializationHelper.Clone(function () {\n      return anisotropicConfiguration;\n    }, this);\n  };\n  /**\r\n   * Serializes this anisotropy configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRAnisotropicConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n\n  __decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n\n  return PBRAnisotropicConfiguration;\n}();\n\nexport { PBRAnisotropicConfiguration };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/PBR/pbrAnisotropicConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["import { SerializationHelper, serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { Scene } from \"../../scene\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"../../types\";\r\nimport { IAnimatable } from '../../Animations/animatable.interface';\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialAnisotropicDefines {\r\n    ANISOTROPIC: boolean;\r\n    ANISOTROPIC_TEXTURE: boolean;\r\n    ANISOTROPIC_TEXTUREDIRECTUV: number;\r\n    MAINUV1: boolean;\r\n\r\n    _areTexturesDirty: boolean;\r\n    _needUVs: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the anisotropic parameters of the pbr material.\r\n */\r\nexport class PBRAnisotropicConfiguration {\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"strectching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new istance of anisotropy configuration.\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param mesh the mesh we are preparing the defines for.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialAnisotropicDefines, mesh: AbstractMesh, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines wether the material is frozen or not.\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void {\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name of the texture useful for serialization or dynamic coding.\r\n    * @returns \"PBRAnisotropicConfiguration\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public static AddFallbacks(defines: IMaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"vAnisotropy\", \"vAnisotropyInfos\", \"anisotropyMatrix\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vAnisotropy\", 3);\r\n        uniformBuffer.addUniform(\"vAnisotropyInfos\", 2);\r\n        uniformBuffer.addUniform(\"anisotropyMatrix\", 16);\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param anisotropicConfiguration define the config where to copy the info\r\n     */\r\n    public copyTo(anisotropicConfiguration: PBRAnisotropicConfiguration): void {\r\n        SerializationHelper.Clone(() => anisotropicConfiguration, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this anisotropy configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}