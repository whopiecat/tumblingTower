{"ast":null,"code":"import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\n/**\r\n * Represents one particle of a points cloud system.\r\n */\n\nvar CloudPoint =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Point Cloud object.\r\n   * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n   * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n   * @param group (PointsGroup) is the group the particle belongs to\r\n   * @param groupId (integer) is the group identifier in the PCS.\r\n   * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n   * @param pcs defines the PCS it is associated to\r\n   */\n  function CloudPoint(particleIndex, group, groupId, idxInGroup, pcs) {\n    /**\r\n     * particle global index\r\n     */\n    this.idx = 0;\n    /**\r\n     * The color of the particle\r\n     */\n\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\r\n     * The world space position of the particle.\r\n     */\n\n    this.position = Vector3.Zero();\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\n\n    this.rotation = Vector3.Zero();\n    /**\r\n     * The uv of the particle.\r\n     */\n\n    this.uv = new Vector2(0.0, 0.0);\n    /**\r\n     * The current speed of the particle.\r\n     */\n\n    this.velocity = Vector3.Zero();\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\n\n    this.pivot = Vector3.Zero();\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\n\n    this.translateFromPivot = false;\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\n\n    this._pos = 0;\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\n\n    this._ind = 0;\n    /**\r\n     * Group id of this particle\r\n     */\n\n    this.groupId = 0;\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\n\n    this.idxInGroup = 0;\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\n\n    this._stillInvisible = false;\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\n\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\n\n    this.parentId = null;\n    /**\r\n     * @hidden Internal global position in the PCS.\r\n     */\n\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this._group = group;\n    this.groupId = groupId;\n    this.idxInGroup = idxInGroup;\n    this._pcs = pcs;\n  }\n\n  Object.defineProperty(CloudPoint.prototype, \"size\", {\n    /**\r\n     * get point size\r\n     */\n    get: function () {\n      return this.size;\n    },\n\n    /**\r\n     * Set point size\r\n     */\n    set: function (scale) {\n      this.size = scale;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CloudPoint.prototype, \"quaternion\", {\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    get: function () {\n      return this.rotationQuaternion;\n    },\n\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\n    set: function (q) {\n      this.rotationQuaternion = q;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns a boolean. True if the particle intersects a mesh, else false\r\n   * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n   * @param target is the object (point or mesh) what the intersection is computed against\r\n   * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bouding sphere is used\r\n   * @returns true if it intersects\r\n   */\n\n  CloudPoint.prototype.intersectsMesh = function (target, isSphere) {\n    if (!target._boundingInfo) {\n      return false;\n    }\n\n    isSphere = isSphere ? isSphere : false;\n\n    if (isSphere) {\n      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n    } else {\n      var maxX = 0;\n      var minX = 0;\n      var maxY = 0;\n      var minY = 0;\n      var maxZ = 0;\n      var minZ = 0;\n      maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;\n      minX = target.getBoundingInfo().boundingBox.minimumWorld.x;\n      maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;\n      minY = target.getBoundingInfo().boundingBox.minimumWorld.y;\n      maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;\n      minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;\n      var x = this.position.x + this._pcs.mesh.position.x;\n      var y = this.position.y + this._pcs.mesh.position.y;\n      var z = this.position.z + this._pcs.mesh.position.z;\n      return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n  };\n  /**\r\n   * get the rotation matrix of the particle\r\n   * @hidden\r\n   */\n\n\n  CloudPoint.prototype.getRotationMatrix = function (m) {\n    var quaternion;\n\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      var rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n\n    quaternion.toRotationMatrix(m);\n  };\n\n  return CloudPoint;\n}();\n\nexport { CloudPoint };\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\n\nvar PointsGroup =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n   * PCS internal tool, don't use it manually.\r\n   * @hidden\r\n   */\n  function PointsGroup(id, posFunction) {\n    this.groupID = id;\n    this._positionFunction = posFunction;\n  }\n\n  return PointsGroup;\n}();\n\nexport { PointsGroup };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/cloudPoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Color4, Vector2, Vector3, TmpVectors, Matrix, Quaternion } from \"../Maths/math\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { PointsCloudSystem } from \"./pointsCloudSystem\";\r\n/**\r\n * Represents one particle of a points cloud system.\r\n */\r\nexport class CloudPoint {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The uv of the particle.\r\n     */\r\n    public uv: Nullable<Vector2> = new Vector2(0.0, 0.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @hidden\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @hidden Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * Group this particle belongs to\r\n     */\r\n    public _group: PointsGroup;\r\n    /**\r\n     * Group id of this particle\r\n     */\r\n    public groupId: number = 0;\r\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\r\n    public idxInGroup: number = 0;\r\n    /**\r\n     * @hidden Particle BoundingInfo object (Internal use)\r\n     */\r\n    public _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @hidden Reference to the PCS that the particle belongs to (Internal use)\r\n     */\r\n    public _pcs: PointsCloudSystem;\r\n    /**\r\n     * @hidden Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @hidden Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * @hidden Internal global position in the PCS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a Point Cloud object.\r\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n     * @param group (PointsGroup) is the group the particle belongs to\r\n     * @param groupId (integer) is the group identifier in the PCS.\r\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n     * @param pcs defines the PCS it is associated to\r\n     */\r\n    constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem) {\r\n        this.idx = particleIndex;\r\n        this._group = group;\r\n        this.groupId = groupId;\r\n        this.idxInGroup = idxInGroup;\r\n        this._pcs = pcs;\r\n    }\r\n\r\n    /**\r\n     * get point size\r\n     */\r\n    public get size(): Vector3 {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Set point size\r\n     */\r\n    public set size(scale: Vector3) {\r\n        this.size = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects a mesh, else false\r\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n     * @param target is the object (point or mesh) what the intersection is computed against\r\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bouding sphere is used\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh, isSphere: boolean): boolean {\r\n        if (!target._boundingInfo) {\r\n            return false;\r\n        }\r\n        isSphere = isSphere ? isSphere : false;\r\n\r\n        if (isSphere) {\r\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\r\n        }\r\n        else {\r\n            let maxX = 0;\r\n            let minX = 0;\r\n            let maxY = 0;\r\n            let minY = 0;\r\n            let maxZ = 0;\r\n            let minZ = 0;\r\n            maxX = target.getBoundingInfo().boundingBox.maximumWorld.x;\r\n            minX = target.getBoundingInfo().boundingBox.minimumWorld.x;\r\n            maxY = target.getBoundingInfo().boundingBox.maximumWorld.y;\r\n            minY = target.getBoundingInfo().boundingBox.minimumWorld.y;\r\n            maxZ = target.getBoundingInfo().boundingBox.maximumWorld.z;\r\n            minZ = target.getBoundingInfo().boundingBox.minimumWorld.z;\r\n\r\n            let x = this.position.x + this._pcs.mesh.position.x;\r\n            let y = this.position.y + this._pcs.mesh.position.y;\r\n            let z = this.position.z + this._pcs.mesh.position.z;\r\n            return minX <= x  &&  x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @hidden\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        }\r\n        else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\r\nexport class PointsGroup {\r\n    /**\r\n     * The group id\r\n     * @hidden\r\n     */\r\n    public groupID: number;\r\n    /**\r\n     * image data for group (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImageData: Nullable<ArrayBufferView>;\r\n    /**\r\n     * Image Width (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImgWidth: number;\r\n    /**\r\n     * Image Height (internal use)\r\n     * @hidden\r\n     */\r\n    public _groupImgHeight: number;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @hidden\r\n     */\r\n    public _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;\r\n    /**\r\n     * density per facet for surface points\r\n     * @hidden\r\n     */\r\n    public _groupDensity: number[];\r\n    /**\r\n     * Only when points are colored by texture carries pointer to texture list array\r\n     * @hidden\r\n     */\r\n    public _textureNb: number;\r\n\r\n    /**\r\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n     * PCS internal tool, don't use it manually.\r\n     * @hidden\r\n     */\r\n    constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>) {\r\n        this.groupID = id;\r\n        this._positionFunction = posFunction;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}