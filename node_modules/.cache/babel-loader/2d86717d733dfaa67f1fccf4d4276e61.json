{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { Collider } from \"./collider\";\n/** @hidden */\n\nvar DefaultCollisionCoordinator =\n/** @class */\nfunction () {\n  function DefaultCollisionCoordinator() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n\n  DefaultCollisionCoordinator.prototype.getNewPosition = function (position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n\n    this._finalPosition.multiplyInPlace(collider._radius); //run the callback\n\n\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  };\n\n  DefaultCollisionCoordinator.prototype.createCollider = function () {\n    return new Collider();\n  };\n\n  DefaultCollisionCoordinator.prototype.init = function (scene) {\n    this._scene = scene;\n  };\n\n  DefaultCollisionCoordinator.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {\n    if (excludedMesh === void 0) {\n      excludedMesh = null;\n    }\n\n    var closeDistance = Engine.CollisionsEpsilon * 10.0;\n\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    } // Check if this is a mesh else camera or -1\n\n\n    var collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n\n    collider._initialize(position, velocity, closeDistance); // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n\n\n    var meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n\n    for (var index = 0; index < meshes.length; index++) {\n      var mesh = meshes[index];\n\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n\n    collider._retry++;\n\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  };\n\n  return DefaultCollisionCoordinator;\n}();\n\nexport { DefaultCollisionCoordinator };\n\nScene.CollisionCoordinatorFactory = function () {\n  return new DefaultCollisionCoordinator();\n};","map":{"version":3,"sources":["../../../sourceES6/core/Collisions/collisionCoordinator.ts"],"names":[],"mappings":"AACA,SAAS,KAAT,QAAsB,UAAtB;AACA,SAAS,OAAT,QAAwB,sBAAxB;AACA,SAAS,MAAT,QAAuB,mBAAvB;AACA,SAAS,QAAT,QAAyB,YAAzB;AAUA;;AACA,IAAA,2BAAA;AAAA;AAAA,YAAA;AAAA,WAAA,2BAAA,GAAA;AAIY,SAAA,eAAA,GAAkB,OAAO,CAAC,IAAR,EAAlB;AACA,SAAA,eAAA,GAAkB,OAAO,CAAC,IAAR,EAAlB;AAEA,SAAA,cAAA,GAAiB,OAAO,CAAC,IAAR,EAAjB;AAiEX;;AA/DU,EAAA,2BAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,QAAtB,EAAyC,YAAzC,EAAgE,QAAhE,EAAoF,YAApF,EAA0G,YAA1G,EAAsI,aAAtI,EAAmP,cAAnP,EAAyQ;AACrQ,IAAA,QAAQ,CAAC,WAAT,CAAqB,QAAQ,CAAC,OAA9B,EAAuC,KAAK,eAA5C;AACA,IAAA,YAAY,CAAC,WAAb,CAAyB,QAAQ,CAAC,OAAlC,EAA2C,KAAK,eAAhD;AACA,IAAA,QAAQ,CAAC,YAAT,GAAwB,IAAxB;AACA,IAAA,QAAQ,CAAC,MAAT,GAAkB,CAAlB;AACA,IAAA,QAAQ,CAAC,gBAAT,GAA4B,KAAK,eAAjC;AACA,IAAA,QAAQ,CAAC,gBAAT,GAA4B,KAAK,eAAjC;;AACA,SAAK,iBAAL,CAAuB,KAAK,eAA5B,EAA6C,KAAK,eAAlD,EAAmE,QAAnE,EAA6E,YAA7E,EAA2F,KAAK,cAAhG,EAAgH,YAAhH;;AAEA,SAAK,cAAL,CAAoB,eAApB,CAAoC,QAAQ,CAAC,OAA7C,EATqQ,CAUrQ;;;AACA,IAAA,aAAa,CAAC,cAAD,EAAiB,KAAK,cAAtB,EAAsC,QAAQ,CAAC,YAA/C,CAAb;AACH,GAZM;;AAcA,EAAA,2BAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,WAAO,IAAI,QAAJ,EAAP;AACH,GAFM;;AAIA,EAAA,2BAAA,CAAA,SAAA,CAAA,IAAA,GAAP,UAAY,KAAZ,EAAwB;AACpB,SAAK,MAAL,GAAc,KAAd;AACH,GAFM;;AAIC,EAAA,2BAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,QAA1B,EAA6C,QAA7C,EAAgE,QAAhE,EAAoF,YAApF,EAA0G,aAA1G,EAAkI,YAAlI,EAA6K;AAA3C,QAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,YAAA,GAAA,IAAA;AAA2C;;AACzK,QAAI,aAAa,GAAG,MAAM,CAAC,iBAAP,GAA2B,IAA/C;;AAEA,QAAI,QAAQ,CAAC,MAAT,IAAmB,YAAvB,EAAqC;AACjC,MAAA,aAAa,CAAC,QAAd,CAAuB,QAAvB;AACA;AACH,KANwK,CAQzK;;;AACA,QAAI,aAAa,GAAI,YAAY,GAAG,YAAY,CAAC,aAAhB,GAAgC,QAAQ,CAAC,aAA1E;;AAEA,IAAA,QAAQ,CAAC,WAAT,CAAqB,QAArB,EAA+B,QAA/B,EAAyC,aAAzC,EAXyK,CAazK;AACA;;;AACA,QAAI,MAAM,GAAI,YAAY,IAAI,YAAY,CAAC,iBAA9B,IAAoD,KAAK,MAAL,CAAY,MAA7E;;AAEA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,MAAM,CAAC,MAAnC,EAA2C,KAAK,EAAhD,EAAoD;AAChD,UAAI,IAAI,GAAG,MAAM,CAAC,KAAD,CAAjB;;AACA,UAAI,IAAI,CAAC,SAAL,MAAoB,IAAI,CAAC,eAAzB,IAA4C,IAAI,CAAC,SAAjD,IAA8D,IAAI,KAAK,YAAvE,IAAwF,CAAC,aAAa,GAAG,IAAI,CAAC,cAAtB,MAA0C,CAAtI,EAA0I;AACtI,QAAA,IAAI,CAAC,eAAL,CAAqB,QAArB;AACH;AACJ;;AAED,QAAI,CAAC,QAAQ,CAAC,cAAd,EAA8B;AAC1B,MAAA,QAAQ,CAAC,QAAT,CAAkB,QAAlB,EAA4B,aAA5B;AACA;AACH;;AAED,QAAI,QAAQ,CAAC,CAAT,KAAe,CAAf,IAAoB,QAAQ,CAAC,CAAT,KAAe,CAAnC,IAAwC,QAAQ,CAAC,CAAT,KAAe,CAA3D,EAA8D;AAC1D,MAAA,QAAQ,CAAC,YAAT,CAAsB,QAAtB,EAAgC,QAAhC;AACH;;AAED,QAAI,QAAQ,CAAC,MAAT,MAAqB,aAAzB,EAAwC;AACpC,MAAA,aAAa,CAAC,QAAd,CAAuB,QAAvB;AACA;AACH;;AAED,IAAA,QAAQ,CAAC,MAAT;;AACA,SAAK,iBAAL,CAAuB,QAAvB,EAAiC,QAAjC,EAA2C,QAA3C,EAAqD,YAArD,EAAmE,aAAnE,EAAkF,YAAlF;AACH,GAxCO;;AAyCZ,SAAA,2BAAA;AAAC,CAxED,EAAA;;;;AA0EA,KAAK,CAAC,2BAAN,GAAoC,YAAA;AAChC,SAAO,IAAI,2BAAJ,EAAP;AACH,CAFD","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Collider } from \"./collider\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/** @hidden */\r\nexport interface ICollisionCoordinator {\r\n    createCollider(): Collider;\r\n    getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: Nullable<AbstractMesh>, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;\r\n    init(scene: Scene): void;\r\n}\r\n\r\n/** @hidden */\r\nexport class DefaultCollisionCoordinator implements ICollisionCoordinator {\r\n\r\n    private _scene: Scene;\r\n\r\n    private _scaledPosition = Vector3.Zero();\r\n    private _scaledVelocity = Vector3.Zero();\r\n\r\n    private _finalPosition = Vector3.Zero();\r\n\r\n    public getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void {\r\n        position.divideToRef(collider._radius, this._scaledPosition);\r\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\r\n        collider.collidedMesh = null;\r\n        collider._retry = 0;\r\n        collider._initialVelocity = this._scaledVelocity;\r\n        collider._initialPosition = this._scaledPosition;\r\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\r\n\r\n        this._finalPosition.multiplyInPlace(collider._radius);\r\n        //run the callback\r\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\r\n    }\r\n\r\n    public createCollider(): Collider {\r\n        return new Collider();\r\n    }\r\n\r\n    public init(scene: Scene): void {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _collideWithWorld(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, finalPosition: Vector3, excludedMesh: Nullable<AbstractMesh> = null): void {\r\n        var closeDistance = Engine.CollisionsEpsilon * 10.0;\r\n\r\n        if (collider._retry >= maximumRetry) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        // Check if this is a mesh else camera or -1\r\n        var collisionMask = (excludedMesh ? excludedMesh.collisionMask : collider.collisionMask);\r\n\r\n        collider._initialize(position, velocity, closeDistance);\r\n\r\n        // Check if collision detection should happen against specified list of meshes or,\r\n        // if not specified, against all meshes in the scene\r\n        var meshes = (excludedMesh && excludedMesh.surroundingMeshes) || this._scene.meshes;\r\n\r\n        for (var index = 0; index < meshes.length; index++) {\r\n            var mesh = meshes[index];\r\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && ((collisionMask & mesh.collisionGroup) !== 0)) {\r\n                mesh._checkCollision(collider);\r\n            }\r\n        }\r\n\r\n        if (!collider.collisionFound) {\r\n            position.addToRef(velocity, finalPosition);\r\n            return;\r\n        }\r\n\r\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\r\n            collider._getResponse(position, velocity);\r\n        }\r\n\r\n        if (velocity.length() <= closeDistance) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        collider._retry++;\r\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\r\n    }\r\n}\r\n\r\nScene.CollisionCoordinatorFactory = () => {\r\n    return new DefaultCollisionCoordinator();\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}