{"ast":null,"code":"var _jsxFileName = \"D:\\\\tumblingTower\\\\src\\\\index.js\";\nimport React from \"react\";\nimport * as BABYLON from \"@babylonjs/core\";\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\n\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\n\nimport Scene from \"./3dScene\"; // import Gateway from \"../logic/GatewayLogic\";\n// import LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\n// import EventManager from \"../utilities/EventManager\";\n\nexport default class Lobby extends React.Component {\n  constructor(props) {\n    super();\n\n    this._updateSequin = (sequinInfo, region) => {\n      const sequin = this.scene.getMeshByName(sequinInfo.name);\n      sequin.isPickable = true;\n      sequin.metadata = {\n        id: sequinInfo.id,\n        name: sequinInfo.name,\n        region: region\n      };\n      this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\n    };\n\n    this._animateCamera = (trackName, speed = 1, reverse = false) => {\n      const track = this.scene.getMeshByName(trackName);\n      const keysLength = track.animations[0]._keys.length;\n      const start = 0;\n      const end = track.animations[0]._keys[keysLength - 1].frame;\n      const startFrame = reverse ? end : start;\n      const endFrame = reverse ? start : end;\n      this.camera.parent = track;\n      this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\n\n      return this.scene.beginAnimation(track, startFrame, endFrame, false, speed).waitAsync();\n    };\n\n    this._handleClickMain = () => {\n      const scene = this.scene;\n      let pickResult = scene.pick(scene.pointerX, scene.pointerY);\n\n      if (pickResult.hit) {\n        console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\n        let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\n\n        if (region) {\n          LobbyState.toRegionSelected(region);\n        }\n      }\n    };\n\n    this._handleMouseMoveMain = () => {\n      this.hlLayer.removeAllMeshes();\n      let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\n\n      if (pickResult.hit) {\n        const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\n\n        if (r) {\n          r.meshes.forEach(m => this.hlLayer.addMesh(m, BABYLON.Color3.Green()));\n        }\n      }\n    };\n\n    this.onSceneReady = async e => {\n      let that = this;\n      const {\n        scene\n      } = e;\n      this.scene = scene; // maybe use DeviceOrientationCamera so that tilting works on devices?\n\n      this.camera = new BABYLON.UniversalCamera(\"mainCamera\", new BABYLON.Vector3(0, 0, 0), scene); // 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\n\n      /* \r\n          // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n          var camerasBorderFunction = function () {\r\n            let alpha = -Math.PI / 2;\r\n            let beta = Math.PI / 2;\r\n            console.log(\"----  this.camera.beta ----\" + beta);\r\n            if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n            else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n            if (this.camera.radius > 150) this.camera.radius = 150;\r\n            if (this.camera.radius < 30) this.camera.radius = 30;\r\n          };\r\n          scene.registerBeforeRender(camerasBorderFunction);\r\n          this.camera.attachControl(this.canvas, true);\r\n      \r\n       */\n\n      const light1 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);\n      light1.intensity = 1.8;\n      var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\"default\", true, scene, [this.camera]);\n      var curve = new BABYLON.ColorCurves();\n      curve.globalHue = 200;\n      curve.globalDensity = 80;\n      curve.globalSaturation = 80;\n      curve.highlightsHue = 240; // 20;\n\n      curve.highlightsDensity = 100; // 80;\n\n      curve.highlightsSaturation = 100; // -80;\n\n      curve.shadowsHue = 2;\n      curve.shadowsDensity = 80;\n      curve.shadowsSaturation = 40;\n      defaultPipeline.imageProcessing.colorCurves = curve;\n      defaultPipeline.depthOfField.focalLength = 150; // sequin Bloom\n\n      defaultPipeline.bloomEnabled = true;\n      defaultPipeline.bloomThreshold = 0.8;\n      defaultPipeline.bloomWeight = 0.3;\n      defaultPipeline.bloomKernel = 64;\n      defaultPipeline.bloomScale = 0.5;\n      defaultPipeline.imageProcessingEnabled = true;\n      const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\n\n      const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\n      skyboxMaterial.backFaceCulling = false; // WORKS with out below line\n\n      skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\"/textures/skybox/TropicalSunnyDay\", scene);\n      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n      skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.disableLighting = true;\n      skybox.material = skyboxMaterial;\n      skybox.position.y = -30.0;\n      skybox.isPickable = false; // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\n      // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      // hdrBox.isPickable = false;\n      // var hdrRotation = 180; // in degrees\n      // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n      // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\n\n      let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true); //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\n      //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\n\n      let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      hdrBox.isPickable = false; //  var hdrRotation = -60; // in degrees //-50\n      //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n\n      this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene); // Exclude Mesh from roll over\n\n      this.hlLayer.addExcludedMesh(skybox); // PLEASE ADJUST AS NEEDED //\n      // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\n      // init state for setSequinsPickable();\n      //   this.hasCompletedSequinPickableInitRun = false;\n      // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\n\n      /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n              if (hasCompletedSequinPickableInitRun == false) {\r\n                  for (var i = 0; i < scene.meshes.length; i++) {\r\n                      var mesh = scene.meshes[i];\r\n                      var re = /sequin/gi;\r\n                      var str = mesh.name;\r\n                      if (str.search(re) == -1) {\r\n                         // console.log(\"Does not contain sequin\");\r\n                      } else {\r\n                          if (mesh.isPickable == false) {\r\n                             // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                             // console.log(\" ---- setting pickable ----\");\r\n                              mesh.isPickable = true;\r\n                          }\r\n                      }\r\n                  }\r\n              }\r\n              return hasCompletedSequinPickableInitRun = true;\r\n          } */\n      // PLEASE ADJUST AS NEEDED //\n\n      BABYLON.SceneLoader.ShowLoadingScreen = false;\n      await Promise.all([BABYLON.SceneLoader.AppendAsync(\"/models/\", \"setNoSequin_1a.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinOnlyNonPick29_l.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraIntro_1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion2.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion3.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion4.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"cloud001.babylon\", scene // cloud mesh and animation of 'Curve.001'(cloud001) Action\n      )]); // preload region tree meshes\n\n      Gateway.allRegions().forEach(r => {\n        r.treeNames.forEach(n => {\n          r.meshes.push(scene.getMeshByName(n));\n        });\n      });\n      if (this.sceneLoadedHandler) this.sceneLoadedHandler();\n      this.lobbyState$ = LobbyState.stream.subscribe(async ({\n        oldState,\n        newState\n      }) => {\n        await this._handleStateChange(oldState, newState);\n      }); // var createReflectionProbes = function () {\n\n      let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene); //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\n\n      probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\n      //}\n\n      this.camera.onViewMatrixChangedObservable.add(function () {\n        if (that.camera) {// console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\n          // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\n        } else {\n          console.log(\"no camera!\");\n        }\n      }); // scene.debugLayer.show();\n      // not sure where the code for rthe debugLayer is, but needs below line\n      // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\n      // debug GUI needs above line otherwise Inspector window hides when mesh selected.\n    };\n\n    this.onSceneRender = e => {};\n\n    this.sceneLoadedHandler = props.sceneLoaded;\n    this.lobbyState$ = undefined;\n    this.data$ = undefined;\n    this.scene = undefined;\n    this.hlLayer = undefined;\n    this.camera = undefined;\n    this.materials = [];\n  }\n\n  componentWillUnmount() {\n    // unsubscribe from all observables\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\n    if (this.data$) this.data$.unsubscribe();\n  }\n\n  renderScene() {\n    return /*#__PURE__*/React.createElement(Scene, {\n      antialias: true,\n      onSceneReady: this.onSceneReady,\n      onRender: this.onSceneRender,\n      canvasId: \"lobbyCanvas\",\n      className: \"lobby-canvas\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 393,\n        columnNumber: 7\n      }\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"lobby-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 12\n      }\n    }, this.renderScene());\n  }\n\n}","map":{"version":3,"sources":["D:/tumblingTower/src/index.js"],"names":["React","BABYLON","Scene","Lobby","Component","constructor","props","_updateSequin","sequinInfo","region","sequin","scene","getMeshByName","name","isPickable","metadata","id","hlLayer","addMesh","Color3","Blue","_animateCamera","trackName","speed","reverse","track","keysLength","animations","_keys","length","start","end","frame","startFrame","endFrame","camera","parent","fov","beginAnimation","waitAsync","_handleClickMain","pickResult","pick","pointerX","pointerY","hit","console","log","pickedMesh","Gateway","getRegionFromMesh","LobbyState","toRegionSelected","_handleMouseMoveMain","removeAllMeshes","r","meshes","forEach","m","Green","onSceneReady","e","that","UniversalCamera","Vector3","light1","HemisphericLight","intensity","defaultPipeline","DefaultRenderingPipeline","curve","ColorCurves","globalHue","globalDensity","globalSaturation","highlightsHue","highlightsDensity","highlightsSaturation","shadowsHue","shadowsDensity","shadowsSaturation","imageProcessing","colorCurves","depthOfField","focalLength","bloomEnabled","bloomThreshold","bloomWeight","bloomKernel","bloomScale","imageProcessingEnabled","skybox","Mesh","CreateBox","skyboxMaterial","StandardMaterial","backFaceCulling","reflectionTexture","CubeTexture","coordinatesMode","Texture","SKYBOX_MODE","diffuseColor","specularColor","disableLighting","material","position","y","hdrTexture","HDRCubeTexture","hdrBox","createDefaultSkybox","HighlightLayer","addExcludedMesh","SceneLoader","ShowLoadingScreen","Promise","all","AppendAsync","allRegions","treeNames","n","push","sceneLoadedHandler","lobbyState$","stream","subscribe","oldState","newState","_handleStateChange","probe","ReflectionProbe","renderList","onViewMatrixChangedObservable","add","onSceneRender","sceneLoaded","undefined","data$","materials","componentWillUnmount","unsubscribe","renderScene","render"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport * as BABYLON from \"@babylonjs/core\";\r\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\r\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\r\n\r\nimport Scene from \"./3dScene\";\r\n// import Gateway from \"../logic/GatewayLogic\";\r\n// import LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\r\n// import EventManager from \"../utilities/EventManager\";\r\n\r\nexport default class Lobby extends React.Component {\r\n  constructor(props) {\r\n    super();\r\n\r\n    this.sceneLoadedHandler = props.sceneLoaded;\r\n    this.lobbyState$ = undefined;\r\n    this.data$ = undefined;\r\n    this.scene = undefined;\r\n    this.hlLayer = undefined;\r\n    this.camera = undefined;\r\n    this.materials = [];\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // unsubscribe from all observables\r\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\r\n    if (this.data$) this.data$.unsubscribe();\r\n  }\r\n\r\n  _updateSequin = (sequinInfo, region) => {\r\n    const sequin = this.scene.getMeshByName(sequinInfo.name);\r\n    sequin.isPickable = true;\r\n    sequin.metadata = {\r\n      id: sequinInfo.id,\r\n      name: sequinInfo.name,\r\n      region: region,\r\n    };\r\n    this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\r\n  };\r\n\r\n  _animateCamera = (trackName, speed = 1, reverse = false) => {\r\n    const track = this.scene.getMeshByName(trackName);\r\n    const keysLength = track.animations[0]._keys.length;\r\n    const start = 0;\r\n    const end = track.animations[0]._keys[keysLength - 1].frame;\r\n    const startFrame = reverse ? end : start;\r\n    const endFrame = reverse ? start : end;\r\n    this.camera.parent = track;\r\n    this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\r\n    return this.scene\r\n      .beginAnimation(track, startFrame, endFrame, false, speed)\r\n      .waitAsync();\r\n  };\r\n\r\n  _handleClickMain = () => {\r\n    const scene = this.scene;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\r\n      let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (region) {\r\n        LobbyState.toRegionSelected(region);\r\n      }\r\n    }\r\n  };\r\n\r\n  _handleMouseMoveMain = () => {\r\n    this.hlLayer.removeAllMeshes();\r\n\r\n    let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (r) {\r\n        r.meshes.forEach((m) =>\r\n          this.hlLayer.addMesh(m, BABYLON.Color3.Green())\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n/*   _handleClickRegion = () => {\r\n    const scene = this.scene;\r\n    const region = LobbyState.current.newState.data.name;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const mesh = pickResult.pickedMesh;\r\n      console.log(\"picked mesh: \" + mesh);\r\n      // make sure a sequin was picked and the sequin is in the current region\r\n      if (mesh.name.indexOf(\"sequin\") === -1 || mesh.name.indexOf(region) === -1)\r\n        return;\r\n\r\n      LobbyState.toSequinView(mesh.metadata);\r\n    }\r\n  }; */\r\n\r\n/* \r\n  _handleStateChange = async (oldState, newState) => {\r\n    if (oldState) this._cleanUpOldState(oldState);\r\n    if (newState) await this._setUpNewState(oldState, newState);\r\n  }; */\r\n\r\n/*   _cleanUpOldState = (oldState) => {\r\n    switch (oldState.type) {\r\n      case LobbyStates.main:\r\n      case LobbyStates.regionEntered:\r\n        EventManager.removeAllListeners(window, \"click\");\r\n        EventManager.removeAllListeners(window, \"mousemove\");\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }; */\r\n\r\n /*  _setUpNewState = async (oldState, newState) => {\r\n    switch (newState.type) {\r\n      case LobbyStates.intro:\r\n        await this._animateCamera(\"introToWorldEmpty_2\", 2.6);\r\n        LobbyState.toMainView();\r\n        break;\r\n\r\n      case LobbyStates.main:\r\n        if (this.data$) this.data$.unsubscribe();\r\n\r\n        if (oldState.type === LobbyStates.regionEntered) {\r\n          const region = oldState.data;\r\n          await this._animateCamera(region.trackName, 2, true);\r\n        }\r\n        EventManager.addListener(window, \"click\", this._handleClickMain);\r\n        EventManager.addListener(\r\n          window,\r\n          \"mousemove\",\r\n          this._handleMouseMoveMain\r\n        );\r\n        break;\r\n\r\n      case LobbyStates.regionSelected:\r\n        this.hlLayer.removeAllMeshes();\r\n        let regionSelected = newState.data;\r\n        if (oldState.type === LobbyStates.main) {\r\n          await this._animateCamera(regionSelected.trackName, 2);\r\n        }\r\n        LobbyState.toRegionEntered(regionSelected);\r\n        break;\r\n\r\n      case LobbyStates.regionEntered:\r\n        let regionEntered = newState.data;\r\n        this.data$ = Gateway.getRegion(regionEntered.name).stream.subscribe(\r\n          (sequins) => {\r\n            sequins.forEach((seq) => {\r\n              this._updateSequin(seq, regionEntered);\r\n            });\r\n          }\r\n        );\r\n        setTimeout(\r\n          () =>\r\n            EventManager.addListener(window, \"click\", this._handleClickRegion),\r\n          200\r\n        ); // slight pause prevents the sequin info modal from immediately popping back open\r\n        break;\r\n\r\n      case LobbyStates.sequin:\r\n        if (this.data$) this.data$.unsubscribe();\r\n        break;\r\n\r\n      case LobbyStates.sequinLink:\r\n        let regionLinked = newState.data.region;\r\n        await this._animateCamera(regionLinked.trackName, 2);\r\n        LobbyState.toSequinView(newState.data);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }; */\r\n  \r\n\r\n  onSceneReady = async (e) => {\r\n    let that = this;\r\n    const { scene } = e;\r\n    this.scene = scene;\r\n\r\n    // maybe use DeviceOrientationCamera so that tilting works on devices?\r\n    this.camera = new BABYLON.UniversalCamera(\r\n      \"mainCamera\",\r\n      new BABYLON.Vector3(0, 0, 0),\r\n      scene\r\n    );\r\n\r\n// 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\r\n\r\n/* \r\n    // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n    var camerasBorderFunction = function () {\r\n      let alpha = -Math.PI / 2;\r\n      let beta = Math.PI / 2;\r\n      console.log(\"----  this.camera.beta ----\" + beta);\r\n      if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n      else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n      if (this.camera.radius > 150) this.camera.radius = 150;\r\n      if (this.camera.radius < 30) this.camera.radius = 30;\r\n    };\r\n    scene.registerBeforeRender(camerasBorderFunction);\r\n    this.camera.attachControl(this.canvas, true);\r\n\r\n */\r\n    const light1 = new BABYLON.HemisphericLight(\r\n      \"light1\",\r\n      new BABYLON.Vector3(0, 1, 0),\r\n      scene\r\n    );\r\n    light1.intensity = 1.8;\r\n\r\n    var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\r\n      \"default\",\r\n      true,\r\n      scene,\r\n      [this.camera]\r\n    );\r\n    var curve = new BABYLON.ColorCurves();\r\n    curve.globalHue = 200;\r\n    curve.globalDensity = 80;\r\n    curve.globalSaturation = 80;\r\n    curve.highlightsHue = 240; // 20;\r\n    curve.highlightsDensity = 100; // 80;\r\n    curve.highlightsSaturation = 100; // -80;\r\n    curve.shadowsHue = 2;\r\n    curve.shadowsDensity = 80;\r\n    curve.shadowsSaturation = 40;\r\n    defaultPipeline.imageProcessing.colorCurves = curve;\r\n    defaultPipeline.depthOfField.focalLength = 150;\r\n    // sequin Bloom\r\n    defaultPipeline.bloomEnabled = true;\r\n    defaultPipeline.bloomThreshold = 0.8;\r\n    defaultPipeline.bloomWeight = 0.3;\r\n    defaultPipeline.bloomKernel = 64;\r\n    defaultPipeline.bloomScale = 0.5;\r\n    defaultPipeline.imageProcessingEnabled = true;\r\n\r\n    const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\r\n    const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n    // WORKS with out below line\r\n    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\r\n      \"/textures/skybox/TropicalSunnyDay\",\r\n      scene\r\n    );\r\n    skyboxMaterial.reflectionTexture.coordinatesMode =\r\n      BABYLON.Texture.SKYBOX_MODE;\r\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.disableLighting = true;\r\n    skybox.material = skyboxMaterial;\r\n    skybox.position.y = -30.0;\r\n    skybox.isPickable = false;\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n    // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\r\n    // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    // hdrBox.isPickable = false;\r\n    // var hdrRotation = 180; // in degrees\r\n    // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n   // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\r\n    let hdrTexture =   new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true);\r\n  //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\r\n    //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\r\n    let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    \r\n    hdrBox.isPickable = false;\r\n  //  var hdrRotation = -60; // in degrees //-50\r\n  //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n\r\n\r\n    this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene);\r\n    // Exclude Mesh from roll over\r\n    this.hlLayer.addExcludedMesh(skybox);\r\n\r\n    // PLEASE ADJUST AS NEEDED //\r\n    // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\r\n    // init state for setSequinsPickable();\r\n    //   this.hasCompletedSequinPickableInitRun = false;\r\n    // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\r\n    /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n            if (hasCompletedSequinPickableInitRun == false) {\r\n                for (var i = 0; i < scene.meshes.length; i++) {\r\n                    var mesh = scene.meshes[i];\r\n                    var re = /sequin/gi;\r\n                    var str = mesh.name;\r\n                    if (str.search(re) == -1) {\r\n                       // console.log(\"Does not contain sequin\");\r\n                    } else {\r\n                        if (mesh.isPickable == false) {\r\n                           // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                           // console.log(\" ---- setting pickable ----\");\r\n                            mesh.isPickable = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return hasCompletedSequinPickableInitRun = true;\r\n        } */\r\n    // PLEASE ADJUST AS NEEDED //\r\n\r\n    BABYLON.SceneLoader.ShowLoadingScreen = false;\r\n\r\n    await Promise.all([\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"setNoSequin_1a.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinOnlyNonPick29_l.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraIntro_1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion2.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion3.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion4.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"cloud001.babylon\",\r\n        scene\r\n        // cloud mesh and animation of 'Curve.001'(cloud001) Action\r\n      ), \r\n    ]);\r\n\r\n    // preload region tree meshes\r\n    Gateway.allRegions().forEach((r) => {\r\n      r.treeNames.forEach((n) => {\r\n        r.meshes.push(scene.getMeshByName(n));\r\n      });\r\n    });\r\n\r\n    if (this.sceneLoadedHandler) this.sceneLoadedHandler();\r\n\r\n    this.lobbyState$ = LobbyState.stream.subscribe(\r\n      async ({ oldState, newState }) => {\r\n        await this._handleStateChange(oldState, newState);\r\n      }\r\n    );\r\n\r\n    // var createReflectionProbes = function () {\r\n    let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene);\r\n    //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\r\n    probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\r\n    //}\r\n\r\n    this.camera.onViewMatrixChangedObservable.add(function () {\r\n      if (that.camera) {\r\n        // console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\r\n        // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\r\n      } else {\r\n        console.log(\"no camera!\");\r\n      }\r\n    });\r\n\r\n    // scene.debugLayer.show();\r\n    // not sure where the code for rthe debugLayer is, but needs below line\r\n    // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\r\n    // debug GUI needs above line otherwise Inspector window hides when mesh selected.\r\n  };\r\n\r\n  onSceneRender = (e) => { };\r\n\r\n  renderScene() {\r\n    return (\r\n      <Scene\r\n        antialias={true}\r\n        onSceneReady={this.onSceneReady}\r\n        onRender={this.onSceneRender}\r\n        canvasId=\"lobbyCanvas\"\r\n        className=\"lobby-canvas\"\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return <div className=\"lobby-container\">{this.renderScene()}</div>;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}