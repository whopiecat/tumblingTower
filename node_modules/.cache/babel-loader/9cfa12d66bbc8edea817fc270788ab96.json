{"ast":null,"code":"import { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateTiledPlane = function (options) {\n  var flipTile = options.pattern || Mesh.NO_FLIP;\n  var tileWidth = options.tileWidth || options.tileSize || 1;\n  var tileHeight = options.tileHeight || options.tileSize || 1;\n  var alignH = options.alignHorizontal || 0;\n  var alignV = options.alignVertical || 0;\n  var width = options.width || options.size || 1;\n  var tilesX = Math.floor(width / tileWidth);\n  var offsetX = width - tilesX * tileWidth;\n  var height = options.height || options.size || 1;\n  var tilesY = Math.floor(height / tileHeight);\n  var offsetY = height - tilesY * tileHeight;\n  var halfWidth = tileWidth * tilesX / 2;\n  var halfHeight = tileHeight * tilesY / 2;\n  var adjustX = 0;\n  var adjustY = 0;\n  var startX = 0;\n  var startY = 0;\n  var endX = 0;\n  var endY = 0; //Part Tiles\n\n  if (offsetX > 0 || offsetY > 0) {\n    startX = -halfWidth;\n    startY = -halfHeight;\n    var endX = halfWidth;\n    var endY = halfHeight;\n\n    switch (alignH) {\n      case Mesh.CENTER:\n        offsetX /= 2;\n        startX -= offsetX;\n        endX += offsetX;\n        break;\n\n      case Mesh.LEFT:\n        endX += offsetX;\n        adjustX = -offsetX / 2;\n        break;\n\n      case Mesh.RIGHT:\n        startX -= offsetX;\n        adjustX = offsetX / 2;\n        break;\n    }\n\n    switch (alignV) {\n      case Mesh.CENTER:\n        offsetY /= 2;\n        startY -= offsetY;\n        endY += offsetY;\n        break;\n\n      case Mesh.BOTTOM:\n        endY += offsetY;\n        adjustY = -offsetY / 2;\n        break;\n\n      case Mesh.TOP:\n        startY -= offsetY;\n        adjustY = offsetY / 2;\n        break;\n    }\n  }\n\n  var positions = [];\n  var normals = [];\n  var uvBase = [];\n  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n\n  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n  }\n\n  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n  }\n\n  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n  }\n\n  var uvs = [];\n  var colors = [];\n  var indices = [];\n  var index = 0;\n\n  for (var y = 0; y < tilesY; y++) {\n    for (var x = 0; x < tilesX; x++) {\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);\n      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvs = uvs.concat(uvBase[y % 2]);\n      } else {\n        uvs = uvs.concat(uvBase[0]);\n      }\n\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      index += 4;\n    }\n  } //Part Tiles\n\n\n  if (offsetX > 0 || offsetY > 0) {\n    var partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n    var partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n    var partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n    var partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n    var uvPart = [];\n    var a, b, c, d; //corners\n\n    if (partialBottomRow && partialLeftCol) {\n      //bottom left corner\n      positions.push(startX + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialBottomRow && partialRightCol) {\n      //bottom right corner\n      positions.push(halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = offsetX / tileWidth;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialTopRow && partialLeftCol) {\n      //top left corner\n      positions.push(startX + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n      positions.push(startX + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n\n    if (partialTopRow && partialRightCol) {\n      //top right corner\n      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, endY + adjustY, 0);\n      positions.push(halfWidth + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 0;\n      c = offsetX / tileWidth;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    } //part rows\n\n\n    if (partialBottomRow) {\n      var uvBaseBR = [];\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseBR[1]);\n        } else {\n          uvs = uvs.concat(uvBaseBR[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialTopRow) {\n      var uvBaseTR = [];\n      a = 0;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseTR[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialLeftCol) {\n      var uvBaseLC = [];\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = 1;\n      uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var y = 0; y < tilesY; y++) {\n        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseLC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseLC[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n\n    if (partialRightCol) {\n      var uvBaseRC = [];\n      a = 0;\n      b = 0;\n      c = offsetX / tileHeight;\n      d = 1;\n      uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n\n      for (var y = 0; y < tilesY; y++) {\n        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseRC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseRC[0]);\n        }\n\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n  }\n\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n  vertexData.colors = totalColors;\n  return vertexData;\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TiledPlaneBuilder =\n/** @class */\nfunction () {\n  function TiledPlaneBuilder() {}\n  /**\r\n   * Creates a tiled plane mesh\r\n   * * The parameter `pattern` will, depending on value, do nothing or\r\n   * * * flip (reflect about central vertical) alternate tiles across and up\r\n   * * * flip every tile on alternate rows\r\n   * * * rotate (180 degs) alternate tiles across and up\r\n   * * * rotate every tile on alternate rows\r\n   * * * flip and rotate alternate tiles across and up\r\n   * * * flip and rotate every tile on alternate rows\r\n   * * The parameter `tileSize` sets the size (float) of each tile side (default 1)\r\n   * * You can set some different tile dimensions by using the parameters `tileWidth` and `tileHeight` (both by default have the same value of `tileSize`)\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the box mesh\r\n   */\n\n\n  TiledPlaneBuilder.CreateTiledPlane = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var plane = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    plane._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateTiledPlane(options);\n    vertexData.applyToMesh(plane, options.updatable);\n    return plane;\n  };\n\n  return TiledPlaneBuilder;\n}();\n\nexport { TiledPlaneBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/tiledPlaneBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\nVertexData.CreateTiledPlane = function(options: { pattern?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, size?: number, width?: number, height?: number, alignHorizontal?: number, alignVertical?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n\r\n    var flipTile = options.pattern || Mesh.NO_FLIP;\r\n    var tileWidth = options.tileWidth || options.tileSize || 1;\r\n    var tileHeight = options.tileHeight || options.tileSize || 1;\r\n    var alignH = options.alignHorizontal || 0;\r\n    var alignV = options.alignVertical || 0;\r\n\r\n    var width = options.width || options.size || 1;\r\n    var tilesX = Math.floor(width / tileWidth);\r\n    var offsetX = width - tilesX * tileWidth;\r\n\r\n    var height = options.height || options.size || 1;\r\n    var tilesY = Math.floor(height / tileHeight);\r\n    var offsetY = height - tilesY * tileHeight;\r\n\r\n    var halfWidth = tileWidth * tilesX / 2;\r\n    var halfHeight = tileHeight * tilesY / 2;\r\n\r\n    var adjustX = 0;\r\n    var adjustY = 0;\r\n    var startX = 0;\r\n    var startY = 0;\r\n    var endX = 0;\r\n    var endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        var endX = halfWidth;\r\n        var endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    var uvs: Array<number> = [];\r\n    var colors = [];\r\n    var indices = [];\r\n    var index = 0;\r\n    for (var y = 0; y < tilesY; y++) {\r\n        for (var x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);\r\n            }\r\n            else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            }\r\n            else {\r\n\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n\r\n        var partialBottomRow: boolean = (offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP));\r\n        var partialTopRow: boolean = (offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM));\r\n        var partialLeftCol: boolean = (offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT));\r\n        var partialRightCol: boolean = (offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT));\r\n        var uvPart: Array<number> = [];\r\n        var a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) { //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) { //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && (tilesX % 2) === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && (tilesX % 2) === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesX % 2) === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {//top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY % 1) === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY % 2) === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY % 2) === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) { //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && (tilesY % 2) === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            var uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (var x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                }\r\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                }\r\n                else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            var uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (var x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                }\r\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                }\r\n                else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            var uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (var y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                }\r\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                }\r\n                else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            var uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (var y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                }\r\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                }\r\n                else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TiledPlaneBuilder {\r\n    /**\r\n     * Creates a tiled plane mesh\r\n     * * The parameter `pattern` will, depending on value, do nothing or\r\n     * * * flip (reflect about central vertical) alternate tiles across and up\r\n     * * * flip every tile on alternate rows\r\n     * * * rotate (180 degs) alternate tiles across and up\r\n     * * * rotate every tile on alternate rows\r\n     * * * flip and rotate alternate tiles across and up\r\n     * * * flip and rotate every tile on alternate rows\r\n     * * The parameter `tileSize` sets the size (float) of each tile side (default 1)\r\n     * * You can set some different tile dimensions by using the parameters `tileWidth` and `tileHeight` (both by default have the same value of `tileSize`)\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    public static CreateTiledPlane(name: string, options: { pattern?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, size?: number, width?: number, height?: number, alignHorizontal?: number, alignVertical?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var plane = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateTiledPlane(options);\r\n\r\n        vertexData.applyToMesh(plane, options.updatable);\r\n\r\n        return plane;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}