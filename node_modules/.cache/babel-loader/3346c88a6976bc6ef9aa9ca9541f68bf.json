{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { PostProcess } from \"./postProcess\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport \"../Shaders/colorCorrection.fragment\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { SerializationHelper, serialize } from '../Misc/decorators';\n/**\r\n *\r\n * This post-process allows the modification of rendered colors by using\r\n * a 'look-up table' (LUT). This effect is also called Color Grading.\r\n *\r\n * The object needs to be provided an url to a texture containing the color\r\n * look-up table: the texture must be 256 pixels wide and 16 pixels high.\r\n * Use an image editing software to tweak the LUT to match your needs.\r\n *\r\n * For an example of a color LUT, see here:\r\n * @see http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png\r\n * For explanations on color grading, see here:\r\n * @see http://udn.epicgames.com/Three/ColorGrading.html\r\n *\r\n */\n\nvar ColorCorrectionPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(ColorCorrectionPostProcess, _super);\n\n  function ColorCorrectionPostProcess(name, colorTableUrl, options, camera, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, 'colorCorrection', null, ['colorTable'], options, camera, samplingMode, engine, reusable) || this;\n\n    _this._colorTableTexture = new Texture(colorTableUrl, camera.getScene(), true, false, Texture.TRILINEAR_SAMPLINGMODE);\n    _this._colorTableTexture.anisotropicFilteringLevel = 1;\n    _this._colorTableTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this._colorTableTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    _this.colorTableUrl = colorTableUrl;\n\n    _this.onApply = function (effect) {\n      effect.setTexture(\"colorTable\", _this._colorTableTexture);\n    };\n\n    return _this;\n  }\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"ColorCorrectionPostProcess\" string\r\n   */\n\n\n  ColorCorrectionPostProcess.prototype.getClassName = function () {\n    return \"ColorCorrectionPostProcess\";\n  };\n  /** @hidden */\n\n\n  ColorCorrectionPostProcess._Parse = function (parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(function () {\n      return new ColorCorrectionPostProcess(parsedPostProcess.name, parsedPostProcess.colorTableUrl, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  };\n\n  __decorate([serialize()], ColorCorrectionPostProcess.prototype, \"colorTableUrl\", void 0);\n\n  return ColorCorrectionPostProcess;\n}(PostProcess);\n\nexport { ColorCorrectionPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.ColorCorrectionPostProcess\"] = ColorCorrectionPostProcess;","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/colorCorrectionPostProcess.ts"],"names":[],"mappings":";AAAA,SAAS,WAAT,QAAgD,eAAhD;AAEA,SAAS,OAAT,QAAwB,+BAAxB;AAIA,OAAO,qCAAP;AACA,SAAS,UAAT,QAA2B,mBAA3B;AACA,SAAS,mBAAT,EAA8B,SAA9B,QAA+C,oBAA/C;AAKA;;;;;;;;;;;;;;;;AAeA,IAAA,0BAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAgD,EAAA,SAAA,CAAA,0BAAA,EAAA,MAAA,CAAA;;AAkB5C,WAAA,0BAAA,CAAY,IAAZ,EAA0B,aAA1B,EAAiD,OAAjD,EAAuF,MAAvF,EAAuG,YAAvG,EAA8H,MAA9H,EAA+I,QAA/I,EAAiK;AAAjK,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,iBAAZ,EAA+B,IAA/B,EAAqC,CAAC,YAAD,CAArC,EAAqD,OAArD,EAA8D,MAA9D,EAAsE,YAAtE,EAAoF,MAApF,EAA4F,QAA5F,KAAqG,IADzG;;AAGI,IAAA,KAAI,CAAC,kBAAL,GAA0B,IAAI,OAAJ,CAAY,aAAZ,EAA2B,MAAM,CAAC,QAAP,EAA3B,EAA8C,IAA9C,EAAoD,KAApD,EAA2D,OAAO,CAAC,sBAAnE,CAA1B;AACA,IAAA,KAAI,CAAC,kBAAL,CAAwB,yBAAxB,GAAoD,CAApD;AACA,IAAA,KAAI,CAAC,kBAAL,CAAwB,KAAxB,GAAgC,OAAO,CAAC,iBAAxC;AACA,IAAA,KAAI,CAAC,kBAAL,CAAwB,KAAxB,GAAgC,OAAO,CAAC,iBAAxC;AAEA,IAAA,KAAI,CAAC,aAAL,GAAqB,aAArB;;AAEA,IAAA,KAAI,CAAC,OAAL,GAAe,UAAC,MAAD,EAAe;AAC1B,MAAA,MAAM,CAAC,UAAP,CAAkB,YAAlB,EAAgC,KAAI,CAAC,kBAArC;AACH,KAFD;;;AAGH;AArBD;;;;;;AAIO,EAAA,0BAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,4BAAP;AACH,GAFM;AAmBP;;;AACc,EAAA,0BAAA,CAAA,MAAA,GAAd,UAAqB,iBAArB,EAA6C,YAA7C,EAAmE,KAAnE,EAAiF,OAAjF,EAAgG;AAC5F,WAAO,mBAAmB,CAAC,KAApB,CAA0B,YAAA;AAC7B,aAAO,IAAI,0BAAJ,CACH,iBAAiB,CAAC,IADf,EACqB,iBAAiB,CAAC,aADvC,EAEH,iBAAiB,CAAC,OAFf,EAEwB,YAFxB,EAGH,iBAAiB,CAAC,wBAHf,EAIH,KAAK,CAAC,SAAN,EAJG,EAIgB,iBAAiB,CAAC,QAJlC,CAAP;AAKH,KANM,EAMJ,iBANI,EAMe,KANf,EAMsB,OANtB,CAAP;AAOH,GARa;;AA1Bd,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,oCAAA,E,eAAA,E,KAA6B,CAA7B,CAAA;;AAmCJ,SAAA,0BAAA;AAAC,CA3CD,CAAgD,WAAhD,CAAA;;SAAa,0B;AA6Cb,UAAU,CAAC,eAAX,CAA2B,oCAA3B,IAAmE,0BAAnE","sourcesContent":["import { PostProcess, PostProcessOptions } from \"./postProcess\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Camera } from \"../Cameras/camera\";\r\n\r\nimport \"../Shaders/colorCorrection.fragment\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { SerializationHelper, serialize } from '../Misc/decorators';\r\nimport { Nullable } from '../types';\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n *\r\n * This post-process allows the modification of rendered colors by using\r\n * a 'look-up table' (LUT). This effect is also called Color Grading.\r\n *\r\n * The object needs to be provided an url to a texture containing the color\r\n * look-up table: the texture must be 256 pixels wide and 16 pixels high.\r\n * Use an image editing software to tweak the LUT to match your needs.\r\n *\r\n * For an example of a color LUT, see here:\r\n * @see http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png\r\n * For explanations on color grading, see here:\r\n * @see http://udn.epicgames.com/Three/ColorGrading.html\r\n *\r\n */\r\nexport class ColorCorrectionPostProcess extends PostProcess {\r\n\r\n    private _colorTableTexture: Texture;\r\n\r\n    /**\r\n     * Gets the color table url used to create the LUT texture\r\n     */\r\n    @serialize()\r\n    public colorTableUrl: string;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ColorCorrectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ColorCorrectionPostProcess\";\r\n    }\r\n\r\n    constructor(name: string, colorTableUrl: string, options: number | PostProcessOptions, camera: Camera, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(name, 'colorCorrection', null, ['colorTable'], options, camera, samplingMode, engine, reusable);\r\n\r\n        this._colorTableTexture = new Texture(colorTableUrl, camera.getScene(), true, false, Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._colorTableTexture.anisotropicFilteringLevel = 1;\r\n        this._colorTableTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._colorTableTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this.colorTableUrl = colorTableUrl;\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            effect.setTexture(\"colorTable\", this._colorTableTexture);\r\n        };\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ColorCorrectionPostProcess> {\r\n        return SerializationHelper.Parse(() => {\r\n            return new ColorCorrectionPostProcess(\r\n                parsedPostProcess.name, parsedPostProcess.colorTableUrl,\r\n                parsedPostProcess.options, targetCamera,\r\n                parsedPostProcess.renderTargetSamplingMode,\r\n                scene.getEngine(), parsedPostProcess.reusable);\r\n        }, parsedPostProcess, scene, rootUrl);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ColorCorrectionPostProcess\"] = ColorCorrectionPostProcess;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}