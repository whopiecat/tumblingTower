{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\nimport { WebXRCamera } from \"./webXRCamera\";\nimport { WebXRState } from \"./webXRTypes\";\nimport { WebXRFeaturesManager } from \"./webXRFeaturesManager\";\nimport { Logger } from \"../Misc/logger\";\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\r\n */\n\nvar WebXRExperienceHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a WebXRExperienceHelper\r\n   * @param scene The scene the helper should be created in\r\n   */\n  function WebXRExperienceHelper(scene) {\n    var _this = this;\n\n    this.scene = scene;\n    this._nonVRCamera = null;\n    this._originalSceneAutoClear = true;\n    this._supported = false;\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\n\n    this.onInitialXRPoseSetObservable = new Observable();\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\n\n    this.onStateChangedObservable = new Observable();\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\n\n    this.state = WebXRState.NOT_IN_XR;\n    this.sessionManager = new WebXRSessionManager(scene);\n    this.camera = new WebXRCamera(\"\", scene, this.sessionManager);\n    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\n    scene.onDisposeObservable.add(function () {\n      _this.exitXRAsync();\n    });\n  }\n  /**\r\n   * Creates the experience helper\r\n   * @param scene the scene to attach the experience helper to\r\n   * @returns a promise for the experience helper\r\n   */\n\n\n  WebXRExperienceHelper.CreateAsync = function (scene) {\n    var helper = new WebXRExperienceHelper(scene);\n    return helper.sessionManager.initializeAsync().then(function () {\n      helper._supported = true;\n      return helper;\n    }).catch(function (e) {\n      helper._setState(WebXRState.NOT_IN_XR);\n\n      helper.dispose();\n      throw e;\n    });\n  };\n  /**\r\n   * Disposes of the experience helper\r\n   */\n\n\n  WebXRExperienceHelper.prototype.dispose = function () {\n    this.camera.dispose();\n    this.onStateChangedObservable.clear();\n    this.onInitialXRPoseSetObservable.clear();\n    this.sessionManager.dispose();\n\n    if (this._nonVRCamera) {\n      this.scene.activeCamera = this._nonVRCamera;\n    }\n  };\n  /**\r\n   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n   * @param sessionMode options for the XR session\r\n   * @param referenceSpaceType frame of reference of the XR session\r\n   * @param renderTarget the output canvas that will be used to enter XR mode\r\n   * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n   * @returns promise that resolves after xr mode has entered\r\n   */\n\n\n  WebXRExperienceHelper.prototype.enterXRAsync = function (sessionMode, referenceSpaceType, renderTarget, sessionCreationOptions) {\n    var _this = this;\n\n    if (renderTarget === void 0) {\n      renderTarget = this.sessionManager.getWebXRRenderTarget();\n    }\n\n    if (sessionCreationOptions === void 0) {\n      sessionCreationOptions = {};\n    }\n\n    if (!this._supported) {\n      throw \"WebXR not supported in this browser or environment\";\n    }\n\n    this._setState(WebXRState.ENTERING_XR);\n\n    if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\n      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\n      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\n    }\n\n    this.featuresManager.extendXRSessionInitObject(sessionCreationOptions); // we currently recommend \"unbounded\" space in AR (#7959)\n\n    if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\n      Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\n    } // make sure that the session mode is supported\n\n\n    return this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions).then(function () {\n      return _this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\n    }).then(function () {\n      return renderTarget.initializeXRLayerAsync(_this.sessionManager.session);\n    }).then(function () {\n      return _this.sessionManager.updateRenderStateAsync({\n        depthFar: _this.camera.maxZ,\n        depthNear: _this.camera.minZ,\n        baseLayer: renderTarget.xrLayer\n      });\n    }).then(function () {\n      // run the render loop\n      _this.sessionManager.runXRRenderLoop(); // Cache pre xr scene settings\n\n\n      _this._originalSceneAutoClear = _this.scene.autoClear;\n      _this._nonVRCamera = _this.scene.activeCamera;\n      _this.scene.activeCamera = _this.camera; // do not compensate when AR session is used\n\n      if (sessionMode !== \"immersive-ar\") {\n        _this._nonXRToXRCamera();\n      } else {\n        // Kept here, TODO - check if needed\n        _this.scene.autoClear = false;\n        _this.camera.compensateOnFirstFrame = false;\n      }\n\n      _this.sessionManager.onXRSessionEnded.addOnce(function () {\n        // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\n        _this.camera.rigCameras.forEach(function (c) {\n          c.outputRenderTarget = null;\n        }); // Restore scene settings\n\n\n        _this.scene.autoClear = _this._originalSceneAutoClear;\n        _this.scene.activeCamera = _this._nonVRCamera;\n\n        if (sessionMode !== \"immersive-ar\" && _this.camera.compensateOnFirstFrame) {\n          if (_this._nonVRCamera.setPosition) {\n            _this._nonVRCamera.setPosition(_this.camera.position);\n          } else {\n            _this._nonVRCamera.position.copyFrom(_this.camera.position);\n          }\n        }\n\n        _this._setState(WebXRState.NOT_IN_XR);\n      }); // Wait until the first frame arrives before setting state to in xr\n\n\n      _this.sessionManager.onXRFrameObservable.addOnce(function () {\n        _this._setState(WebXRState.IN_XR);\n      });\n\n      return _this.sessionManager;\n    }).catch(function (e) {\n      console.log(e);\n      console.log(e.message);\n\n      _this._setState(WebXRState.NOT_IN_XR);\n\n      throw e;\n    });\n  };\n  /**\r\n   * Exits XR mode and returns the scene to its original state\r\n   * @returns promise that resolves after xr mode has exited\r\n   */\n\n\n  WebXRExperienceHelper.prototype.exitXRAsync = function () {\n    // only exit if state is IN_XR\n    if (this.state !== WebXRState.IN_XR) {\n      return Promise.resolve();\n    }\n\n    this._setState(WebXRState.EXITING_XR);\n\n    return this.sessionManager.exitXRAsync();\n  };\n\n  WebXRExperienceHelper.prototype._nonXRToXRCamera = function () {\n    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);\n    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n  };\n\n  WebXRExperienceHelper.prototype._setState = function (val) {\n    if (this.state === val) {\n      return;\n    }\n\n    this.state = val;\n    this.onStateChangedObservable.notifyObservers(this.state);\n  };\n\n  return WebXRExperienceHelper;\n}();\n\nexport { WebXRExperienceHelper };","map":{"version":3,"sources":["../../../sourceES6/core/XR/webXRExperienceHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { IDisposable, Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\nimport { WebXRState, WebXRRenderTarget } from \"./webXRTypes\";\r\nimport { WebXRFeaturesManager } from \"./webXRFeaturesManager\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\r\n * @see https://doc.babylonjs.com/how_to/webxr_experience_helpers\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _originalSceneAutoClear = true;\r\n    private _supported = false;\r\n\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n    /** A features manager for this xr session */\r\n    public featuresManager: WebXRFeaturesManager;\r\n    /**\r\n     * Observers registered here will be triggered after the camera's initial transformation is set\r\n     * This can be used to set a different ground level or an extra rotation.\r\n     *\r\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\r\n     * to the position set after this observable is done executing.\r\n     */\r\n    public onInitialXRPoseSetObservable = new Observable<WebXRCamera>();\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n    /** Session manager used to keep track of xr session */\r\n    public sessionManager: WebXRSessionManager;\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param scene The scene the helper should be created in\r\n     */\r\n    private constructor(private scene: Scene) {\r\n        this.sessionManager = new WebXRSessionManager(scene);\r\n        this.camera = new WebXRCamera(\"\", scene, this.sessionManager);\r\n        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            this.exitXRAsync();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        var helper = new WebXRExperienceHelper(scene);\r\n        return helper.sessionManager\r\n            .initializeAsync()\r\n            .then(() => {\r\n                helper._supported = true;\r\n                return helper;\r\n            })\r\n            .catch((e) => {\r\n                helper._setState(WebXRState.NOT_IN_XR);\r\n                helper.dispose();\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.camera.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this.onInitialXRPoseSetObservable.clear();\r\n        this.sessionManager.dispose();\r\n        if (this._nonVRCamera) {\r\n            this.scene.activeCamera = this._nonVRCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionMode options for the XR session\r\n     * @param referenceSpaceType frame of reference of the XR session\r\n     * @param renderTarget the output canvas that will be used to enter XR mode\r\n     * @param sessionCreationOptions optional XRSessionInit object to init the session with\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public enterXRAsync(sessionMode: XRSessionMode, referenceSpaceType: XRReferenceSpaceType, renderTarget: WebXRRenderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions: XRSessionInit = {}): Promise<WebXRSessionManager> {\r\n        if (!this._supported) {\r\n            throw \"WebXR not supported in this browser or environment\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n        if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\r\n            sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\r\n            sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\r\n        }\r\n        this.featuresManager.extendXRSessionInitObject(sessionCreationOptions);\r\n        // we currently recommend \"unbounded\" space in AR (#7959)\r\n        if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\r\n            Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\r\n        }\r\n        // make sure that the session mode is supported\r\n        return this.sessionManager\r\n            .initializeSessionAsync(sessionMode, sessionCreationOptions)\r\n            .then(() => {\r\n                return this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\r\n            })\r\n            .then(() => {\r\n                return renderTarget.initializeXRLayerAsync(this.sessionManager.session);\r\n            })\r\n            .then(() => {\r\n                return this.sessionManager.updateRenderStateAsync({\r\n                    depthFar: this.camera.maxZ,\r\n                    depthNear: this.camera.minZ,\r\n                    baseLayer: renderTarget.xrLayer!,\r\n                });\r\n            })\r\n            .then(() => {\r\n                // run the render loop\r\n                this.sessionManager.runXRRenderLoop();\r\n                // Cache pre xr scene settings\r\n                this._originalSceneAutoClear = this.scene.autoClear;\r\n                this._nonVRCamera = this.scene.activeCamera;\r\n\r\n                this.scene.activeCamera = this.camera;\r\n                // do not compensate when AR session is used\r\n                if (sessionMode !== \"immersive-ar\") {\r\n                    this._nonXRToXRCamera();\r\n                } else {\r\n                    // Kept here, TODO - check if needed\r\n                    this.scene.autoClear = false;\r\n                    this.camera.compensateOnFirstFrame = false;\r\n                }\r\n\r\n                this.sessionManager.onXRSessionEnded.addOnce(() => {\r\n                    // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                    this.camera.rigCameras.forEach((c) => {\r\n                        c.outputRenderTarget = null;\r\n                    });\r\n\r\n                    // Restore scene settings\r\n                    this.scene.autoClear = this._originalSceneAutoClear;\r\n                    this.scene.activeCamera = this._nonVRCamera;\r\n                    if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\r\n                        if ((<any>this._nonVRCamera).setPosition) {\r\n                            (<any>this._nonVRCamera).setPosition(this.camera.position);\r\n                        } else {\r\n                            this._nonVRCamera!.position.copyFrom(this.camera.position);\r\n                        }\r\n                    }\r\n\r\n                    this._setState(WebXRState.NOT_IN_XR);\r\n                });\r\n\r\n                // Wait until the first frame arrives before setting state to in xr\r\n                this.sessionManager.onXRFrameObservable.addOnce(() => {\r\n                    this._setState(WebXRState.IN_XR);\r\n                });\r\n\r\n                return this.sessionManager;\r\n            })\r\n            .catch((e: any) => {\r\n                console.log(e);\r\n                console.log(e.message);\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        // only exit if state is IN_XR\r\n        if (this.state !== WebXRState.IN_XR) {\r\n            return Promise.resolve();\r\n        }\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this.sessionManager.exitXRAsync();\r\n    }\r\n\r\n    private _nonXRToXRCamera() {\r\n        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera!);\r\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\r\n    }\r\n\r\n    private _setState(val: WebXRState) {\r\n        if (this.state === val) {\r\n            return;\r\n        }\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}