{"ast":null,"code":"import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\n\nvar Skeleton =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new skeleton\r\n   * @param name defines the skeleton name\r\n   * @param id defines the skeleton Id\r\n   * @param scene defines the hosting scene\r\n   */\n  function Skeleton(\n  /** defines the skeleton name */\n  name,\n  /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\r\n     * Defines the list of child bones\r\n     */\n\n    this.bones = new Array();\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\n\n    this.needInitialSkinMatrix = false;\n    /**\r\n     * Defines a mesh that override the matrix used to get the world matrix (null by default).\r\n     */\n\n    this.overrideMesh = null;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._ranges = {};\n    this._lastAbsoluteTransformsUpdateId = -1;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @hidden */\n\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @hidden */\n\n    this._hasWaitingData = null;\n    /** @hidden */\n\n    this._waitingOverrideMeshId = null;\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\n\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null; // Events\n\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\n\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n\n    this._scene.addSkeleton(this); //make sure it will recalculate the matrix next time prepare is called.\n\n\n    this._isDirty = true;\n\n    var engineCaps = this._scene.getEngine().getCaps();\n\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n\n  Object.defineProperty(Skeleton.prototype, \"useTextureToStoreBoneMatrices\", {\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\n    get: function () {\n      return this._useTextureToStoreBoneMatrices;\n    },\n    set: function (value) {\n      this._useTextureToStoreBoneMatrices = value;\n\n      this._markAsDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function () {\n      if (!this._animationPropertiesOverride) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function (value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"isUsingTextureForMatrices\", {\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\n    get: function () {\n      return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Skeleton.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\n    get: function () {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n  Skeleton.prototype.getClassName = function () {\n    return \"Skeleton\";\n  };\n  /**\r\n   * Returns an array containing the root bones\r\n   * @returns an array containing the root bones\r\n   */\n\n\n  Skeleton.prototype.getChildren = function () {\n    return this.bones.filter(function (b) {\n      return !b.getParent();\n    });\n  }; // Members\n\n  /**\r\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n   * @returns a Float32Array containing matrices data\r\n   */\n\n\n  Skeleton.prototype.getTransformMatrices = function (mesh) {\n    if (this.needInitialSkinMatrix && mesh._bonesTransformMatrices) {\n      return mesh._bonesTransformMatrices;\n    }\n\n    if (!this._transformMatrices) {\n      this.prepare();\n    }\n\n    return this._transformMatrices;\n  };\n  /**\r\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n   * @returns a raw texture containing the data\r\n   */\n\n\n  Skeleton.prototype.getTransformMatrixTexture = function (mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n\n    return this._transformMatrixTexture;\n  };\n  /**\r\n   * Gets the current hosting scene\r\n   * @returns a scene object\r\n   */\n\n\n  Skeleton.prototype.getScene = function () {\n    return this._scene;\n  }; // Methods\n\n  /**\r\n   * Gets a string representing the current skeleton data\r\n   * @param fullDetails defines a boolean indicating if we want a verbose version\r\n   * @returns a string representing the current skeleton data\r\n   */\n\n\n  Skeleton.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", nBones: \" + this.bones.length;\n    ret += \", nAnimationRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      var first = true;\n\n      for (var name_1 in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n\n        ret += name_1;\n      }\n\n      ret += \"}\";\n    }\n\n    return ret;\n  };\n  /**\r\n  * Get bone's index searching by name\r\n  * @param name defines bone's name to search for\r\n  * @return the indice of the bone. Returns -1 if not found\r\n  */\n\n\n  Skeleton.prototype.getBoneIndexByName = function (name) {\n    for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * Creater a new animation range\r\n   * @param name defines the name of the range\r\n   * @param from defines the start key\r\n   * @param to defines the end key\r\n   */\n\n\n  Skeleton.prototype.createAnimationRange = function (name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n\n      for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  };\n  /**\r\n   * Delete a specific animation range\r\n   * @param name defines the name of the range\r\n   * @param deleteFrames defines if frames must be removed as well\r\n   */\n\n\n  Skeleton.prototype.deleteAnimationRange = function (name, deleteFrames) {\n    if (deleteFrames === void 0) {\n      deleteFrames = true;\n    }\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  };\n  /**\r\n   * Gets a specific animation range\r\n   * @param name defines the name of the range to look for\r\n   * @returns the requested animation range or null if not found\r\n   */\n\n\n  Skeleton.prototype.getAnimationRange = function (name) {\n    return this._ranges[name] || null;\n  };\n  /**\r\n   * Gets the list of all animation ranges defined on this skeleton\r\n   * @returns an array\r\n   */\n\n\n  Skeleton.prototype.getAnimationRanges = function () {\n    var animationRanges = [];\n    var name;\n\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n\n    return animationRanges;\n  };\n  /**\r\n   * Copy animation range from a source skeleton.\r\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n   * @param source defines the source skeleton\r\n   * @param name defines the name of the range to copy\r\n   * @param rescaleAsRequired defines if rescaling must be applied if required\r\n   * @returns true if operation was successful\r\n   */\n\n\n  Skeleton.prototype.copyAnimationRange = function (source, name, rescaleAsRequired) {\n    if (rescaleAsRequired === void 0) {\n      rescaleAsRequired = false;\n    }\n\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n\n    var ret = true;\n    var frameOffset = this._getHighestAnimationFrame() + 1; // make a dictionary of source skeleton's bones, so exact same order or doublely nested loop is not required\n\n    var boneDict = {};\n    var sourceBones = source.bones;\n    var nBones;\n    var i;\n\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(\"copyAnimationRange: this rig has \" + this.bones.length + \" bones, while source as \" + sourceBones.length);\n      ret = false;\n    }\n\n    var skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      var boneName = this.bones[i].name;\n      var sourceBone = boneDict[boneName];\n\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    } // do not call createAnimationRange(), since it also is done to bones, which was already done\n\n\n    var range = source.getAnimationRange(name);\n\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n\n    return ret;\n  };\n  /**\r\n   * Forces the skeleton to go to rest pose\r\n   */\n\n\n  Skeleton.prototype.returnToRest = function () {\n    var _localScaling = TmpVectors.Vector3[0];\n    var _localRotation = TmpVectors.Quaternion[0];\n    var _localPosition = TmpVectors.Vector3[1];\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n\n      if (bone._index !== -1) {\n        bone.returnToRest();\n\n        if (bone._linkedTransformNode) {\n          bone.getRestPose().decompose(_localScaling, _localRotation, _localPosition);\n          bone._linkedTransformNode.position = _localPosition.clone();\n          bone._linkedTransformNode.rotationQuaternion = _localRotation.clone();\n          bone._linkedTransformNode.scaling = _localScaling.clone();\n        }\n      }\n    }\n  };\n\n  Skeleton.prototype._getHighestAnimationFrame = function () {\n    var ret = 0;\n\n    for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        var highest = this.bones[i].animations[0].getHighestFrame();\n\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Begin a specific animation range\r\n   * @param name defines the name of the range to start\r\n   * @param loop defines if looping must be turned on (false by default)\r\n   * @param speedRatio defines the speed ratio to apply (1 by default)\r\n   * @param onAnimationEnd defines a callback which will be called when animation will end\r\n   * @returns a new animatable\r\n   */\n\n\n  Skeleton.prototype.beginAnimation = function (name, loop, speedRatio, onAnimationEnd) {\n    var range = this.getAnimationRange(name);\n\n    if (!range) {\n      return null;\n    }\n\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  };\n  /**\r\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n   * @param skeleton defines the Skeleton containing the animation range to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n   * @returns the original skeleton\r\n   */\n\n\n  Skeleton.MakeAnimationAdditive = function (skeleton, referenceFrame, range) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    var rangeValue = skeleton.getAnimationRange(range); // We can't make a range additive if it doesn't exist\n\n    if (!rangeValue) {\n      return null;\n    } // Find any current scene-level animatable belonging to the target that matches the range\n\n\n    var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n\n    var rangeAnimatable = null;\n\n    for (var index = 0; index < sceneAnimatables.length; index++) {\n      var sceneAnimatable = sceneAnimatables[index];\n\n      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    } // Convert the animations belonging to the skeleton to additive keyframes\n\n\n    var animatables = skeleton.getAnimatables();\n\n    for (var index = 0; index < animatables.length; index++) {\n      var animatable = animatables[index];\n      var animations = animatable.animations;\n\n      if (!animations) {\n        continue;\n      }\n\n      for (var animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    } // Mark the scene-level animatable as additive\n\n\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n\n    return skeleton;\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._markAsDirty = function () {\n    this._isDirty = true;\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._registerMeshWithPoseMatrix = function (mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  };\n  /** @hidden */\n\n\n  Skeleton.prototype._unregisterMeshWithPoseMatrix = function (mesh) {\n    var index = this._meshesWithPoseMatrix.indexOf(mesh);\n\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  };\n\n  Skeleton.prototype._computeTransformMatrices = function (targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      bone._childUpdateId++;\n      var parentBone = bone.getParent();\n\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n        } else {\n          bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n\n      if (bone._index !== -1) {\n        var mappedIndex = bone._index === null ? index : bone._index;\n        bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  };\n  /**\r\n   * Build all resources required to render a skeleton\r\n   */\n\n\n  Skeleton.prototype.prepare = function () {\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (var _i = 0, _a = this.bones; _i < _a.length; _i++) {\n        var bone_1 = _a[_i];\n\n        if (bone_1._linkedTransformNode) {\n          // Computing the world matrix also computes the local matrix.\n          bone_1._linkedTransformNode.computeWorldMatrix();\n\n          bone_1._matrix = bone_1._linkedTransformNode._localMatrix;\n          bone_1.markAsDirty();\n        }\n      }\n    }\n\n    if (!this._isDirty) {\n      return;\n    }\n\n    if (this.needInitialSkinMatrix) {\n      for (var index = 0; index < this._meshesWithPoseMatrix.length; index++) {\n        var mesh = this._meshesWithPoseMatrix[index];\n        var poseMatrix = mesh.getPoseMatrix();\n\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n        }\n\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh; // Prepare bones\n\n          for (var boneIndex = 0; boneIndex < this.bones.length; boneIndex++) {\n            var bone = this.bones[boneIndex];\n\n            if (!bone.getParent()) {\n              var matrix = bone.getBaseMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n\n              bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\n            }\n          }\n\n          if (this.isUsingTextureForMatrices) {\n            var textureWidth = (this.bones.length + 1) * 4;\n\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n\n      this._computeTransformMatrices(this._transformMatrices, null);\n\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n\n    this._isDirty = false;\n\n    this._scene._activeBones.addCount(this.bones.length, false);\n  };\n  /**\r\n   * Gets the list of animatables currently running for this skeleton\r\n   * @returns an array of animatables\r\n   */\n\n\n  Skeleton.prototype.getAnimatables = function () {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n\n      for (var index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n\n    return this._animatables;\n  };\n  /**\r\n   * Clone the current skeleton\r\n   * @param name defines the name of the new skeleton\r\n   * @param id defines the id of the new skeleton\r\n   * @returns the new skeleton\r\n   */\n\n\n  Skeleton.prototype.clone = function (name, id) {\n    var result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    result.overrideMesh = this.overrideMesh;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var source = this.bones[index];\n      var parentBone = null;\n      var parent_1 = source.getParent();\n\n      if (parent_1) {\n        var parentIndex = this.bones.indexOf(parent_1);\n        parentBone = result.bones[parentIndex];\n      }\n\n      var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n      bone._index = source._index;\n\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n\n    if (this._ranges) {\n      result._ranges = {};\n\n      for (var rangeName in this._ranges) {\n        var range = this._ranges[rangeName];\n\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n\n    this._isDirty = true;\n    return result;\n  };\n  /**\r\n   * Enable animation blending for this skeleton\r\n   * @param blendingSpeed defines the blending speed to apply\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n   */\n\n\n  Skeleton.prototype.enableBlending = function (blendingSpeed) {\n    if (blendingSpeed === void 0) {\n      blendingSpeed = 0.01;\n    }\n\n    this.bones.forEach(function (bone) {\n      bone.animations.forEach(function (animation) {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  };\n  /**\r\n   * Releases all resources associated with the current skeleton\r\n   */\n\n\n  Skeleton.prototype.dispose = function () {\n    this._meshesWithPoseMatrix = []; // Animations\n\n    this.getScene().stopAnimation(this); // Remove from scene\n\n    this.getScene().removeSkeleton(this);\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    }\n  };\n  /**\r\n   * Serialize the skeleton in a JSON object\r\n   * @returns a JSON object\r\n   */\n\n\n  Skeleton.prototype.serialize = function () {\n    var _a, _b;\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    serializationObject.overrideMeshId = (_a = this.overrideMesh) === null || _a === void 0 ? void 0 : _a.id;\n\n    for (var index = 0; index < this.bones.length; index++) {\n      var bone = this.bones[index];\n      var parent_2 = bone.getParent();\n      var serializedBone = {\n        parentBoneIndex: parent_2 ? this.bones.indexOf(parent_2) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        matrix: bone.getBaseMatrix().toArray(),\n        rest: bone.getRestPose().toArray(),\n        linkedTransformNodeId: (_b = bone.getTransformNode()) === null || _b === void 0 ? void 0 : _b.id\n      };\n      serializationObject.bones.push(serializedBone);\n\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n\n      serializationObject.ranges = [];\n\n      for (var name in this._ranges) {\n        var source = this._ranges[name];\n\n        if (!source) {\n          continue;\n        }\n\n        var range = {};\n        range.name = name;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a new skeleton from serialized data\r\n   * @param parsedSkeleton defines the serialized data\r\n   * @param scene defines the hosting scene\r\n   * @returns a new skeleton\r\n   */\n\n\n  Skeleton.Parse = function (parsedSkeleton, scene) {\n    var skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n\n    if (parsedSkeleton.overrideMeshId) {\n      skeleton._hasWaitingData = true;\n      skeleton._waitingOverrideMeshId = parsedSkeleton.overrideMeshId;\n    }\n\n    var index;\n\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      var parsedBone = parsedSkeleton.bones[index];\n      var parsedBoneIndex = parsedSkeleton.bones[index].index;\n      var parentBone = null;\n\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n\n      var rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    } // placed after bones, so createAnimationRange can cascade down\n\n\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        var data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n\n    return skeleton;\n  };\n  /**\r\n   * Compute all node absolute transforms\r\n   * @param forceUpdate defines if computation must be done even if cache is up to date\r\n   */\n\n\n  Skeleton.prototype.computeAbsoluteTransforms = function (forceUpdate) {\n    if (forceUpdate === void 0) {\n      forceUpdate = false;\n    }\n\n    var renderId = this._scene.getRenderId();\n\n    if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\n      this.bones[0].computeAbsoluteTransforms();\n      this._lastAbsoluteTransformsUpdateId = renderId;\n    }\n  };\n  /**\r\n   * Gets the root pose matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Skeleton.prototype.getPoseMatrix = function () {\n    var poseMatrix = null;\n\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n\n    return poseMatrix;\n  };\n  /**\r\n   * Sorts bones per internal index\r\n   */\n\n\n  Skeleton.prototype.sortBones = function () {\n    var bones = new Array();\n    var visited = new Array(this.bones.length);\n\n    for (var index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n\n    this.bones = bones;\n  };\n\n  Skeleton.prototype._sortBones = function (index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n\n    visited[index] = true;\n    var bone = this.bones[index];\n\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n\n    var parentBone = bone.getParent();\n\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n\n    bones.push(bone);\n  };\n  /**\r\n   * Set the current local matrix as the restPose for all bones in the skeleton.\r\n   */\n\n\n  Skeleton.prototype.setCurrentPoseAsRest = function () {\n    this.bones.forEach(function (b) {\n      b.setCurrentPoseAsRest();\n    });\n  };\n\n  return Skeleton;\n}();\n\nexport { Skeleton };","map":{"version":3,"sources":["../../../sourceES6/core/Bones/skeleton.ts"],"names":[],"mappings":"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","sourcesContent":["import { Bone } from \"./bone\";\r\n\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Animatable } from \"../Animations/animatable\";\r\nimport { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { IInspectable } from '../Misc/iInspectable';\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones = new Array<Bone>();\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n    /**\r\n     * Defines a mesh that override the matrix used to get the world matrix (null by default).\r\n     */\r\n    public overrideMesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _lastAbsoluteTransformsUpdateId = -1;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @hidden */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @hidden */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @hidden */\r\n    public _waitingOverrideMeshId: Nullable<string> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string, scene: Scene) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: AbstractMesh): Float32Array {\r\n        if (this.needInitialSkinMatrix && mesh._bonesTransformMatrices) {\r\n            return mesh._bonesTransformMatrices;\r\n        }\r\n\r\n        if (!this._transformMatrices) {\r\n            this.prepare();\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (let name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n    * Get bone's index searching by name\r\n    * @param name defines bone's name to search for\r\n    * @return the indice of the bone. Returns -1 if not found\r\n    */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Creater a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        var animationRanges: Nullable<AnimationRange>[] = [];\r\n        var name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        var ret = true;\r\n        var frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doublely nested loop is not required\r\n        var boneDict: { [key: string]: Bone } = {};\r\n        var sourceBones = source.bones;\r\n        var nBones: number;\r\n        var i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        var skelDimensionsRatio = (rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest) ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            var boneName = this.bones[i].name;\r\n            var sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        var range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        const _localScaling = TmpVectors.Vector3[0];\r\n        const _localRotation = TmpVectors.Quaternion[0];\r\n        const _localPosition = TmpVectors.Vector3[1];\r\n\r\n        for (var index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n                if (bone._linkedTransformNode) {\r\n                    bone.getRestPose().decompose(_localScaling, _localRotation, _localPosition);\r\n\r\n                    bone._linkedTransformNode.position = _localPosition.clone();\r\n                    bone._linkedTransformNode.rotationQuaternion = _localRotation.clone();\r\n                    bone._linkedTransformNode.scaling = _localScaling.clone();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        var ret = 0;\r\n        for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                var highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        var range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        var rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        var sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        var rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            let sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        var animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            let animatable = animatables[index];\r\n            let animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (var animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        var index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (var index = 0; index < this.bones.length; index++) {\r\n            var bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            var parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\r\n                } else {\r\n                    bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                var mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     */\r\n    public prepare(): void {\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    // Computing the world matrix also computes the local matrix.\r\n                    bone._linkedTransformNode.computeWorldMatrix();\r\n                    bone._matrix = bone._linkedTransformNode._localMatrix;\r\n                    bone.markAsDirty();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._isDirty) {\r\n            return;\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (var index = 0; index < this._meshesWithPoseMatrix.length; index++) {\r\n                var mesh = this._meshesWithPoseMatrix[index];\r\n\r\n                var poseMatrix = mesh.getPoseMatrix();\r\n\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (var boneIndex = 0; boneIndex < this.bones.length; boneIndex++) {\r\n                        var bone = this.bones[boneIndex];\r\n\r\n                        if (!bone.getParent()) {\r\n                            var matrix = bone.getBaseMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n\r\n        this._scene._activeBones.addCount(this.bones.length, false);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (var index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        var result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        result.overrideMesh = this.overrideMesh;\r\n\r\n        for (var index = 0; index < this.bones.length; index++) {\r\n            var source = this.bones[index];\r\n            var parentBone = null;\r\n\r\n            let parent = source.getParent();\r\n            if (parent) {\r\n                var parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            var bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (var rangeName in this._ranges) {\r\n                let range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        this.bones.forEach((bone) => {\r\n            bone.animations.forEach((animation: Animation) => {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix = [];\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n        serializationObject.overrideMeshId = this.overrideMesh?.id;\r\n\r\n        for (var index = 0; index < this.bones.length; index++) {\r\n            var bone = this.bones[index];\r\n            let parent = bone.getParent();\r\n\r\n            var serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                matrix: bone.getBaseMatrix().toArray(),\r\n                rest: bone.getRestPose().toArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (var name in this._ranges) {\r\n                let source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                var range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        var skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        if (parsedSkeleton.overrideMeshId) {\r\n            skeleton._hasWaitingData = true;\r\n            skeleton._waitingOverrideMeshId = parsedSkeleton.overrideMeshId;\r\n        }\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            var parsedBone = parsedSkeleton.bones[index];\r\n            var parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            var parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            var rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            var bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                var data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute transforms\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n\r\n        var renderId = this._scene.getRenderId();\r\n\r\n        if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\r\n            this.bones[0].computeAbsoluteTransforms();\r\n            this._lastAbsoluteTransformsUpdateId = renderId;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        var poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        var bones = new Array<Bone>();\r\n        var visited = new Array<boolean>(this.bones.length);\r\n        for (var index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        var bone = this.bones[index];\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        var parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.bones.forEach((b) => {\r\n            b.setCurrentPoseAsRest();\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}