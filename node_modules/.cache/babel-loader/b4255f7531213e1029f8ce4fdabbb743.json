{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\nimport { Ray } from \"../../Culling/ray\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\nimport { Animation } from \"../../Animations/animation\";\nimport { Axis } from \"../../Maths/math.axis\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\nimport { GroundBuilder } from \"../../Meshes/Builders/groundBuilder\";\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\nimport { Curve3 } from \"../../Maths/math.path\";\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Color3 } from \"../../Maths/math.color\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { setAndStartTimer } from \"../../Misc/timer\";\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\n\nvar WebXRMotionControllerTeleportation =\n/** @class */\nfunction (_super) {\n  __extends(WebXRMotionControllerTeleportation, _super);\n  /**\r\n   * constructs a new anchor system\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param _options configuration object for this feature\r\n   */\n\n\n  function WebXRMotionControllerTeleportation(_xrSessionManager, _options) {\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._controllers = {};\n    _this._snappedToPoint = false;\n    _this._tmpRay = new Ray(new Vector3(), new Vector3());\n    _this._tmpVector = new Vector3();\n    _this._tmpQuaternion = new Quaternion();\n    /**\r\n     * Is movement backwards enabled\r\n     */\n\n    _this.backwardsMovementEnabled = true;\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\n\n    _this.backwardsTeleportationDistance = 0.7;\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\n\n    _this.parabolicCheckRadius = 5;\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\n\n    _this.parabolicRayEnabled = true;\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\n\n    _this.straightRayEnabled = true;\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\n\n    _this.rotationAngle = Math.PI / 8;\n    _this._rotationEnabled = true;\n\n    _this._attachController = function (xrController) {\n      if (_this._controllers[xrController.uniqueId] || _this._options.forceHandedness && xrController.inputSource.handedness !== _this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n\n      _this._controllers[xrController.uniqueId] = {\n        xrController: xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0\n        }\n      };\n      var controllerData = _this._controllers[xrController.uniqueId]; // motion controller only available to gamepad-enabled input sources.\n\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        var initMotionController_1 = function () {\n          if (xrController.motionController) {\n            var movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n\n            if (!movementController || _this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              var mainComponent_1 = xrController.motionController.getMainComponent();\n\n              if (!mainComponent_1) {\n                return;\n              }\n\n              controllerData.teleportationComponent = mainComponent_1;\n              controllerData.onButtonChangedObserver = mainComponent_1.onButtonStateChangedObservable.add(function () {\n                // did \"pressed\" changed?\n                if (mainComponent_1.changes.pressed) {\n                  if (mainComponent_1.changes.pressed.current) {\n                    // simulate \"forward\" thumbstick push\n                    controllerData.teleportationState.forward = true;\n                    _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                    controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                    controllerData.teleportationState.currentRotation = 0;\n                    var timeToSelect = _this._options.timeToTeleport || 3000;\n                    setAndStartTimer({\n                      timeout: timeToSelect,\n                      contextObservable: _this._xrSessionManager.onXRFrameObservable,\n                      breakCondition: function () {\n                        return !mainComponent_1.pressed;\n                      },\n                      onEnded: function () {\n                        if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                          _this._teleportForward(xrController.uniqueId);\n                        }\n                      }\n                    });\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    _this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController; // use thumbstick (or touchpad if thumbstick not available)\n\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(function (axesData) {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && _this.backwardsMovementEnabled && !_this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true; // teleport backwards ONCE\n\n                    _this._tmpQuaternion.copyFrom(_this._options.xrInput.xrCamera.rotationQuaternion);\n\n                    _this._tmpQuaternion.toEulerAnglesToRef(_this._tmpVector); // get only the y rotation\n\n\n                    _this._tmpVector.x = 0;\n                    _this._tmpVector.z = 0; // get the quaternion\n\n                    Quaternion.FromEulerVectorToRef(_this._tmpVector, _this._tmpQuaternion);\n\n                    _this._tmpVector.set(0, 0, _this.backwardsTeleportationDistance * (_this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n\n                    _this._tmpVector.rotateByQuaternionToRef(_this._tmpQuaternion, _this._tmpVector);\n\n                    _this._tmpVector.addInPlace(_this._options.xrInput.xrCamera.position);\n\n                    _this._tmpRay.origin.copyFrom(_this._tmpVector); // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n\n\n                    _this._tmpRay.length = _this._options.xrInput.xrCamera.realWorldHeight + 0.1; // Right handed system had here \"1\" instead of -1. This is unneeded.\n\n                    _this._tmpRay.direction.set(0, -1, 0);\n\n                    var pick = _this._xrSessionManager.scene.pickWithRay(_this._tmpRay, function (o) {\n                      return _this._floorMeshes.indexOf(o) !== -1;\n                    }); // pick must exist, but stay safe\n\n\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      _this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      _this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n\n                if (axesData.y < -0.7 && !_this._currentTeleportationControllerId && !controllerData.teleportationState.rotating) {\n                  controllerData.teleportationState.forward = true;\n                  _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      var rotation = _this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (_this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n\n                      _this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, rotation, 0));\n                    }\n                  } else {\n                    if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (_this.rotationEnabled) {\n                        setTimeout(function () {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (_this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.forward) {\n                    _this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n\n        if (xrController.motionController) {\n          initMotionController_1();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(function () {\n            initMotionController_1();\n          });\n        }\n      } else {\n        _this._xrSessionManager.scene.onPointerObservable.add(function (pointerInfo) {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            controllerData.teleportationState.forward = true;\n            _this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n            controllerData.teleportationState.baseRotation = _this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n            controllerData.teleportationState.currentRotation = 0;\n            var timeToSelect = _this._options.timeToTeleport || 3000;\n            setAndStartTimer({\n              timeout: timeToSelect,\n              contextObservable: _this._xrSessionManager.onXRFrameObservable,\n              onEnded: function () {\n                if (_this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                  _this._teleportForward(xrController.uniqueId);\n                }\n              }\n            });\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            controllerData.teleportationState.forward = false;\n            _this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    }; // create default mesh if not provided\n\n\n    if (!_this._options.teleportationTargetMesh) {\n      _this._createDefaultTargetMesh();\n    }\n\n    _this._floorMeshes = _this._options.floorMeshes || [];\n    _this._snapToPositions = _this._options.snapPositions || [];\n\n    _this._setTargetMeshVisibility(false);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"rotationEnabled\", {\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\n    get: function () {\n      return this._rotationEnabled;\n    },\n\n    /**\r\n     * Sets wether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\n    set: function (enabled) {\n      this._rotationEnabled = enabled;\n\n      if (this._options.teleportationTargetMesh) {\n        var children = this._options.teleportationTargetMesh.getChildMeshes(false, function (node) {\n          return node.name === \"rotationCone\";\n        });\n\n        if (children[0]) {\n          children[0].setEnabled(enabled);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"teleportationTargetMesh\", {\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\n    get: function () {\n      return this._options.teleportationTargetMesh || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebXRMotionControllerTeleportation.prototype, \"snapPointsOnly\", {\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\n    get: function () {\n      return !!this._options.snapPointsOnly;\n    },\n\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\n    set: function (snapToPoints) {\n      this._options.snapPointsOnly = snapToPoints;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add a new mesh to the floor meshes array\r\n   * @param mesh the mesh to use as floor mesh\r\n   */\n\n  WebXRMotionControllerTeleportation.prototype.addFloorMesh = function (mesh) {\n    this._floorMeshes.push(mesh);\n  };\n  /**\r\n   * Add a new snap-to point to fix teleportation to this position\r\n   * @param newSnapPoint The new Snap-To point\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.addSnapPoint = function (newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  };\n\n  WebXRMotionControllerTeleportation.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Safety reset\n\n\n    this._currentTeleportationControllerId = \"\";\n\n    this._options.xrInput.controllers.forEach(this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, function (controller) {\n      // REMOVE the controller\n      _this._detachController(controller.uniqueId);\n    });\n\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.detach = function () {\n    var _this = this;\n\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    Object.keys(this._controllers).forEach(function (controllerId) {\n      _this._detachController(controllerId);\n    });\n\n    this._setTargetMeshVisibility(false);\n\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  };\n\n  WebXRMotionControllerTeleportation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n  };\n  /**\r\n   * Remove a mesh from the floor meshes array\r\n   * @param mesh the mesh to remove\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMesh = function (mesh) {\n    var index = this._floorMeshes.indexOf(mesh);\n\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  };\n  /**\r\n   * Remove a mesh from the floor meshes array using its name\r\n   * @param name the mesh name to remove\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeFloorMeshByName = function (name) {\n    var mesh = this._xrSessionManager.scene.getMeshByName(name);\n\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  };\n  /**\r\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n   * @returns was the point found and removed or not\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.removeSnapPoint = function (snapPointToRemove) {\n    // check if the object is in the array\n    var index = this._snapToPositions.indexOf(snapPointToRemove); // if not found as an object, compare to the points\n\n\n    if (index === -1) {\n      for (var i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    } // index is not -1? remove the object\n\n\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * This function sets a selection feature that will be disabled when\r\n   * the forward ray is shown and will be reattached when hidden.\r\n   * This is used to remove the selection rays when moving.\r\n   * @param selectionFeature the feature to disable when forward movement is enabled\r\n   */\n\n\n  WebXRMotionControllerTeleportation.prototype.setSelectionFeature = function (selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._onXRFrame = function (_xrFrame) {\n    var _this = this;\n\n    var frame = this._xrSessionManager.currentFrame;\n    var scene = this._xrSessionManager.scene;\n\n    if (!this.attach || !frame) {\n      return;\n    } // render target if needed\n\n\n    var targetMesh = this._options.teleportationTargetMesh;\n\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      var controllerData = this._controllers[this._currentTeleportationControllerId];\n\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion); // set the ray and position\n\n        var hitPossible = false;\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            var index = _this._floorMeshes.indexOf(o);\n\n            if (index === -1) {\n              return false;\n            }\n\n            return _this._floorMeshes[index].absolutePosition.y < _this._options.xrInput.xrCamera.position.y;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick.pickedPoint);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n\n\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          var xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          var compensation = 1 + (Math.PI / 2 - Math.abs(xRotation)); // check parabolic ray\n\n          var radius = this.parabolicCheckRadius * compensation;\n\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n\n          this._tmpVector.y = this._tmpRay.origin.y;\n\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n\n          this._tmpRay.direction.normalize();\n\n          var pick = scene.pickWithRay(this._tmpRay, function (o) {\n            // check for mesh-blockers\n            if (_this._options.pickBlockerMeshes && _this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n\n            return _this._floorMeshes.indexOf(o) !== -1;\n          });\n\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n\n            this._setTargetMeshPosition(pick.pickedPoint);\n\n            this._setTargetMeshVisibility(true);\n\n            this._showParabolicPath(pick);\n          }\n        } // if needed, set visible:\n\n\n        this._setTargetMeshVisibility(hitPossible);\n      } else {\n        this._setTargetMeshVisibility(false);\n      }\n    } else {\n      this._setTargetMeshVisibility(false);\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._createDefaultTargetMesh = function () {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    var sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    var teleportationTarget = GroundBuilder.CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    var length = 512;\n    var dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n    dynamicTexture.hasAlpha = true;\n    var context = dynamicTexture.getContext();\n    var centerX = length / 2;\n    var centerY = length / 2;\n    var radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    var teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    teleportationTarget.material = teleportationCircleMaterial;\n    var torus = TorusBuilder.CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      var animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      var keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      var easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n\n    var cone = CylinderBuilder.CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      var torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n\n    this._options.teleportationTargetMesh = teleportationTarget;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._detachController = function (xrControllerUniqueId) {\n    var controllerData = this._controllers[xrControllerUniqueId];\n\n    if (!controllerData) {\n      return;\n    }\n\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    } // remove from the map\n\n\n    delete this._controllers[xrControllerUniqueId];\n  };\n\n  WebXRMotionControllerTeleportation.prototype._findClosestSnapPointWithRadius = function (realPosition, radius) {\n    if (radius === void 0) {\n      radius = this._options.snapToPositionRadius || 0.8;\n    }\n\n    var closestPoint = null;\n    var closestDistance = Number.MAX_VALUE;\n\n    if (this._snapToPositions.length) {\n      var radiusSquared_1 = radius * radius;\n\n      this._snapToPositions.forEach(function (position) {\n        var dist = Vector3.DistanceSquared(position, realPosition);\n\n        if (dist <= radiusSquared_1 && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n\n    return closestPoint;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshPosition = function (newPosition) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n\n    var snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n\n    this._snappedToPoint = !!snapPosition;\n\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n\n    this._options.teleportationTargetMesh.position.y += 0.01;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._setTargetMeshVisibility = function (visible) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n\n    if (this._options.teleportationTargetMesh.isVisible === visible) {\n      return;\n    }\n\n    this._options.teleportationTargetMesh.isVisible = visible;\n\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(function (m) {\n      m.isVisible = visible;\n    });\n\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n\n        this._quadraticBezierCurve = null;\n      }\n\n      if (this._selectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  };\n\n  WebXRMotionControllerTeleportation.prototype._showParabolicPath = function (pickInfo) {\n    if (!pickInfo.pickedPoint) {\n      return;\n    }\n\n    var controllerData = this._controllers[this._currentTeleportationControllerId];\n    var quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = LinesBuilder.CreateLines(\"teleportation path line\", {\n        points: quadraticBezierVectors.getPoints(),\n        instance: this._quadraticBezierCurve,\n        updatable: true\n      });\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints());\n    }\n\n    this._quadraticBezierCurve.isPickable = false;\n  };\n\n  WebXRMotionControllerTeleportation.prototype._teleportForward = function (controllerId) {\n    var controllerData = this._controllers[controllerId];\n\n    if (!controllerData || !controllerData.teleportationState.forward) {\n      return;\n    }\n\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    } // do the movement forward here\n\n\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      var height = this._options.xrInput.xrCamera.realWorldHeight;\n\n      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n\n      this._options.xrInput.xrCamera.position.y += height;\n\n      this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0));\n\n      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the webxr specs version\r\n   */\n\n  WebXRMotionControllerTeleportation.Version = 1;\n  return WebXRMotionControllerTeleportation;\n}(WebXRAbstractFeature);\n\nexport { WebXRMotionControllerTeleportation };\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRMotionControllerTeleportation(xrSessionManager, options);\n  };\n}, WebXRMotionControllerTeleportation.Version, true);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRControllerTeleportation.ts"],"names":[],"mappings":"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","sourcesContent":["import { IWebXRFeature, WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Nullable } from \"../../types\";\r\nimport { WebXRInput } from \"../webXRInput\";\r\nimport { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { WebXRControllerComponent, IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CylinderBuilder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { GroundBuilder } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { TorusBuilder } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long should the \"long press\" take before teleport\r\n     */\r\n    timeToTeleport?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[]) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets wether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRTeleportationOptions) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    let pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.position.y;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick.pickedPoint);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    let pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick.pickedPoint);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible);\r\n            } else {\r\n                this._setTargetMeshVisibility(false);\r\n            }\r\n        } else {\r\n            this._setTargetMeshVisibility(false);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // simulate \"forward\" thumbstick push\r\n                                    controllerData.teleportationState.forward = true;\r\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                    controllerData.teleportationState.currentRotation = 0;\r\n                                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                    setAndStartTimer({\r\n                                        timeout: timeToSelect,\r\n                                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                        breakCondition: () => !mainComponent.pressed,\r\n                                        onEnded: () => {\r\n                                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                                this._teleportForward(xrController.uniqueId);\r\n                                            }\r\n                                        },\r\n                                    });\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    let pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, rotation, 0));\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    controllerData.teleportationState.forward = true;\r\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                    controllerData.teleportationState.currentRotation = 0;\r\n                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                    setAndStartTimer({\r\n                        timeout: timeToSelect,\r\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                        onEnded: () => {\r\n                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                this._teleportForward(xrController.uniqueId);\r\n                            }\r\n                        },\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\r\n        const teleportationTarget = GroundBuilder.CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n        const length = 512;\r\n        const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n        dynamicTexture.hasAlpha = true;\r\n        const context = dynamicTexture.getContext();\r\n        const centerX = length / 2;\r\n        const centerY = length / 2;\r\n        const radius = 200;\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n        context.fill();\r\n        context.lineWidth = 10;\r\n        context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n        context.stroke();\r\n        context.closePath();\r\n        dynamicTexture.update();\r\n        const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n        teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n        teleportationTarget.material = teleportationCircleMaterial;\r\n        const torus = TorusBuilder.CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CylinderBuilder.CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(newPosition: Vector3) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint) {\r\n            return;\r\n        }\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = LinesBuilder.CreateLines(\"teleportation path line\", { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve as LinesMesh, updatable: true });\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints());\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            this._options.xrInput.xrCamera.rotationQuaternion.multiplyInPlace(Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0));\r\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}