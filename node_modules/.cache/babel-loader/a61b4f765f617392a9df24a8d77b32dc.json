{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Observable } from \"./observable\";\n/**\r\n * Defines the root class used to create scene optimization to use with SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimization =\n/** @class */\nfunction () {\n  /**\r\n   * Creates the SceneOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param desc defines the description associated with the optimization\r\n   */\n  function SceneOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    this.priority = priority;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  SceneOptimization.prototype.getDescription = function () {\n    return \"\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  SceneOptimization.prototype.apply = function (scene, optimizer) {\n    return true;\n  };\n\n  return SceneOptimization;\n}();\n\nexport { SceneOptimization };\n/**\r\n * Defines an optimization used to reduce the size of render target textures\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar TextureOptimization =\n/** @class */\nfunction (_super) {\n  __extends(TextureOptimization, _super);\n  /**\r\n   * Creates the TextureOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n   * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n   */\n\n\n  function TextureOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority,\n  /**\r\n   * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n   */\n  maximumSize,\n  /**\r\n   * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumSize === void 0) {\n      maximumSize = 1024;\n    }\n\n    if (step === void 0) {\n      step = 0.5;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumSize = maximumSize;\n    _this.step = step;\n    return _this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  TextureOptimization.prototype.getDescription = function () {\n    return \"Reducing render target texture size to \" + this.maximumSize;\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  TextureOptimization.prototype.apply = function (scene, optimizer) {\n    var allDone = true;\n\n    for (var index = 0; index < scene.textures.length; index++) {\n      var texture = scene.textures[index];\n\n      if (!texture.canRescale || texture.getContext) {\n        continue;\n      }\n\n      var currentSize = texture.getSize();\n      var maxDimension = Math.max(currentSize.width, currentSize.height);\n\n      if (maxDimension > this.maximumSize) {\n        texture.scale(this.step);\n        allDone = false;\n      }\n    }\n\n    return allDone;\n  };\n\n  return TextureOptimization;\n}(SceneOptimization);\n\nexport { TextureOptimization };\n/**\r\n * Defines an optimization used to increase or decrease the rendering resolution\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar HardwareScalingOptimization =\n/** @class */\nfunction (_super) {\n  __extends(HardwareScalingOptimization, _super);\n  /**\r\n   * Creates the HardwareScalingOptimization object\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @param maximumScale defines the maximum scale to use (2 by default)\r\n   * @param step defines the step to use between two passes (0.5 by default)\r\n   */\n\n\n  function HardwareScalingOptimization(\n  /**\r\n   * Defines the priority of this optimization (0 by default which means first in the list)\r\n   */\n  priority,\n  /**\r\n   * Defines the maximum scale to use (2 by default)\r\n   */\n  maximumScale,\n  /**\r\n   * Defines the step to use between two passes (0.5 by default)\r\n   */\n  step) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    if (maximumScale === void 0) {\n      maximumScale = 2;\n    }\n\n    if (step === void 0) {\n      step = 0.25;\n    }\n\n    var _this = _super.call(this, priority) || this;\n\n    _this.priority = priority;\n    _this.maximumScale = maximumScale;\n    _this.step = step;\n    _this._currentScale = -1;\n    _this._directionOffset = 1;\n    return _this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  HardwareScalingOptimization.prototype.getDescription = function () {\n    return \"Setting hardware scaling level to \" + this._currentScale;\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  HardwareScalingOptimization.prototype.apply = function (scene, optimizer) {\n    if (this._currentScale === -1) {\n      this._currentScale = scene.getEngine().getHardwareScalingLevel();\n\n      if (this._currentScale > this.maximumScale) {\n        this._directionOffset = -1;\n      }\n    }\n\n    this._currentScale += this._directionOffset * this.step;\n    scene.getEngine().setHardwareScalingLevel(this._currentScale);\n    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n  };\n\n  return HardwareScalingOptimization;\n}(SceneOptimization);\n\nexport { HardwareScalingOptimization };\n/**\r\n * Defines an optimization used to remove shadows\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar ShadowsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ShadowsOptimization, _super);\n\n  function ShadowsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  ShadowsOptimization.prototype.getDescription = function () {\n    return \"Turning shadows on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  ShadowsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.shadowsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ShadowsOptimization;\n}(SceneOptimization);\n\nexport { ShadowsOptimization };\n/**\r\n * Defines an optimization used to turn post-processes off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar PostProcessesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(PostProcessesOptimization, _super);\n\n  function PostProcessesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  PostProcessesOptimization.prototype.getDescription = function () {\n    return \"Turning post-processes on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  PostProcessesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.postProcessesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return PostProcessesOptimization;\n}(SceneOptimization);\n\nexport { PostProcessesOptimization };\n/**\r\n * Defines an optimization used to turn lens flares off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar LensFlaresOptimization =\n/** @class */\nfunction (_super) {\n  __extends(LensFlaresOptimization, _super);\n\n  function LensFlaresOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  LensFlaresOptimization.prototype.getDescription = function () {\n    return \"Turning lens flares on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  LensFlaresOptimization.prototype.apply = function (scene, optimizer) {\n    scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return LensFlaresOptimization;\n}(SceneOptimization);\n\nexport { LensFlaresOptimization };\n/**\r\n * Defines an optimization based on user defined callback.\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar CustomOptimization =\n/** @class */\nfunction (_super) {\n  __extends(CustomOptimization, _super);\n\n  function CustomOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @returns description string\r\n   */\n\n\n  CustomOptimization.prototype.getDescription = function () {\n    if (this.onGetDescription) {\n      return this.onGetDescription();\n    }\n\n    return \"Running user defined callback\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  CustomOptimization.prototype.apply = function (scene, optimizer) {\n    if (this.onApply) {\n      return this.onApply(scene, optimizer);\n    }\n\n    return true;\n  };\n\n  return CustomOptimization;\n}(SceneOptimization);\n\nexport { CustomOptimization };\n/**\r\n * Defines an optimization used to turn particles off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar ParticlesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(ParticlesOptimization, _super);\n\n  function ParticlesOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  ParticlesOptimization.prototype.getDescription = function () {\n    return \"Turning particles on/off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  ParticlesOptimization.prototype.apply = function (scene, optimizer) {\n    scene.particlesEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return ParticlesOptimization;\n}(SceneOptimization);\n\nexport { ParticlesOptimization };\n/**\r\n * Defines an optimization used to turn render targets off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar RenderTargetsOptimization =\n/** @class */\nfunction (_super) {\n  __extends(RenderTargetsOptimization, _super);\n\n  function RenderTargetsOptimization() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n\n  RenderTargetsOptimization.prototype.getDescription = function () {\n    return \"Turning render targets off\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  RenderTargetsOptimization.prototype.apply = function (scene, optimizer) {\n    scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n    return true;\n  };\n\n  return RenderTargetsOptimization;\n}(SceneOptimization);\n\nexport { RenderTargetsOptimization };\n/**\r\n * Defines an optimization used to merge meshes with compatible materials\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar MergeMeshesOptimization =\n/** @class */\nfunction (_super) {\n  __extends(MergeMeshesOptimization, _super);\n\n  function MergeMeshesOptimization() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._canBeMerged = function (abstractMesh) {\n      if (!(abstractMesh instanceof Mesh)) {\n        return false;\n      }\n\n      var mesh = abstractMesh;\n\n      if (mesh.isDisposed()) {\n        return false;\n      }\n\n      if (!mesh.isVisible || !mesh.isEnabled()) {\n        return false;\n      }\n\n      if (mesh.instances.length > 0) {\n        return false;\n      }\n\n      if (mesh.skeleton || mesh.hasLODLevels) {\n        return false;\n      }\n\n      return true;\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(MergeMeshesOptimization, \"UpdateSelectionTree\", {\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\n    get: function () {\n      return MergeMeshesOptimization._UpdateSelectionTree;\n    },\n\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\n    set: function (value) {\n      MergeMeshesOptimization._UpdateSelectionTree = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets a string describing the action executed by the current optimization\r\n   * @return description string\r\n   */\n\n  MergeMeshesOptimization.prototype.getDescription = function () {\n    return \"Merging similar meshes together\";\n  };\n  /**\r\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n   * @param scene defines the current scene where to apply this optimization\r\n   * @param optimizer defines the current optimizer\r\n   * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\r\n   * @returns true if everything that can be done was applied\r\n   */\n\n\n  MergeMeshesOptimization.prototype.apply = function (scene, optimizer, updateSelectionTree) {\n    var globalPool = scene.meshes.slice(0);\n    var globalLength = globalPool.length;\n\n    for (var index = 0; index < globalLength; index++) {\n      var currentPool = new Array();\n      var current = globalPool[index]; // Checks\n\n      if (!this._canBeMerged(current)) {\n        continue;\n      }\n\n      currentPool.push(current); // Find compatible meshes\n\n      for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {\n        var otherMesh = globalPool[subIndex];\n\n        if (!this._canBeMerged(otherMesh)) {\n          continue;\n        }\n\n        if (otherMesh.material !== current.material) {\n          continue;\n        }\n\n        if (otherMesh.checkCollisions !== current.checkCollisions) {\n          continue;\n        }\n\n        currentPool.push(otherMesh);\n        globalLength--;\n        globalPool.splice(subIndex, 1);\n        subIndex--;\n      }\n\n      if (currentPool.length < 2) {\n        continue;\n      } // Merge meshes\n\n\n      Mesh.MergeMeshes(currentPool, undefined, true);\n    } // Call the octree system optimization if it is defined.\n\n\n    var sceneAsAny = scene;\n\n    if (sceneAsAny.createOrUpdateSelectionOctree) {\n      if (updateSelectionTree != undefined) {\n        if (updateSelectionTree) {\n          sceneAsAny.createOrUpdateSelectionOctree();\n        }\n      } else if (MergeMeshesOptimization.UpdateSelectionTree) {\n        sceneAsAny.createOrUpdateSelectionOctree();\n      }\n    }\n\n    return true;\n  };\n\n  MergeMeshesOptimization._UpdateSelectionTree = false;\n  return MergeMeshesOptimization;\n}(SceneOptimization);\n\nexport { MergeMeshesOptimization };\n/**\r\n * Defines a list of options used by SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimizerOptions =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new list of options used by SceneOptimizer\r\n   * @param targetFrameRate defines the target frame rate to reach (60 by default)\r\n   * @param trackerDuration defines the interval between two checkes (2000ms by default)\r\n   */\n  function SceneOptimizerOptions(\n  /**\r\n   * Defines the target frame rate to reach (60 by default)\r\n   */\n  targetFrameRate,\n  /**\r\n   * Defines the interval between two checkes (2000ms by default)\r\n   */\n  trackerDuration) {\n    if (targetFrameRate === void 0) {\n      targetFrameRate = 60;\n    }\n\n    if (trackerDuration === void 0) {\n      trackerDuration = 2000;\n    }\n\n    this.targetFrameRate = targetFrameRate;\n    this.trackerDuration = trackerDuration;\n    /**\r\n     * Gets the list of optimizations to apply\r\n     */\n\n    this.optimizations = new Array();\n  }\n  /**\r\n   * Add a new optimization\r\n   * @param optimization defines the SceneOptimization to add to the list of active optimizations\r\n   * @returns the current SceneOptimizerOptions\r\n   */\n\n\n  SceneOptimizerOptions.prototype.addOptimization = function (optimization) {\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\r\n   * Add a new custom optimization\r\n   * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\r\n   * @param onGetDescription defines the callback called to get the description attached with the optimization.\r\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n   * @returns the current SceneOptimizerOptions\r\n   */\n\n\n  SceneOptimizerOptions.prototype.addCustomOptimization = function (onApply, onGetDescription, priority) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n\n    var optimization = new CustomOptimization(priority);\n    optimization.onApply = onApply;\n    optimization.onGetDescription = onGetDescription;\n    this.optimizations.push(optimization);\n    return this;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.LowDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 1024));\n    return result;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.ModerateDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 512)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 2));\n    return result;\n  };\n  /**\r\n   * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\r\n   * @param targetFrameRate defines the target frame rate (60 by default)\r\n   * @returns a SceneOptimizerOptions object\r\n   */\n\n\n  SceneOptimizerOptions.HighDegradationAllowed = function (targetFrameRate) {\n    var result = new SceneOptimizerOptions(targetFrameRate);\n    var priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 256)); // Next priority\n\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority)); // Next priority\n\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 4));\n    return result;\n  };\n\n  return SceneOptimizerOptions;\n}();\n\nexport { SceneOptimizerOptions };\n/**\r\n * Class used to run optimizations in order to reach a target frame rate\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\n\nvar SceneOptimizer =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new SceneOptimizer\r\n   * @param scene defines the scene to work on\r\n   * @param options defines the options to use with the SceneOptimizer\r\n   * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\r\n   * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\r\n   */\n  function SceneOptimizer(scene, options, autoGeneratePriorities, improvementMode) {\n    var _this = this;\n\n    if (autoGeneratePriorities === void 0) {\n      autoGeneratePriorities = true;\n    }\n\n    if (improvementMode === void 0) {\n      improvementMode = false;\n    }\n\n    this._isRunning = false;\n    this._currentPriorityLevel = 0;\n    this._targetFrameRate = 60;\n    this._trackerDuration = 2000;\n    this._currentFrameRate = 0;\n    this._improvementMode = false;\n    /**\r\n     * Defines an observable called when the optimizer reaches the target frame rate\r\n     */\n\n    this.onSuccessObservable = new Observable();\n    /**\r\n     * Defines an observable called when the optimizer enables an optimization\r\n     */\n\n    this.onNewOptimizationAppliedObservable = new Observable();\n    /**\r\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\r\n     */\n\n    this.onFailureObservable = new Observable();\n\n    if (!options) {\n      this._options = new SceneOptimizerOptions();\n    } else {\n      this._options = options;\n    }\n\n    if (this._options.targetFrameRate) {\n      this._targetFrameRate = this._options.targetFrameRate;\n    }\n\n    if (this._options.trackerDuration) {\n      this._trackerDuration = this._options.trackerDuration;\n    }\n\n    if (autoGeneratePriorities) {\n      var priority = 0;\n\n      for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {\n        var optim = _a[_i];\n        optim.priority = priority++;\n      }\n    }\n\n    this._improvementMode = improvementMode;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function () {\n      _this._sceneDisposeObserver = null;\n\n      _this.dispose();\n    });\n  }\n\n  Object.defineProperty(SceneOptimizer.prototype, \"isInImprovementMode\", {\n    /**\r\n     * Gets a boolean indicating if the optimizer is in improvement mode\r\n     */\n    get: function () {\n      return this._improvementMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentPriorityLevel\", {\n    /**\r\n     * Gets the current priority level (0 at start)\r\n     */\n    get: function () {\n      return this._currentPriorityLevel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"currentFrameRate\", {\n    /**\r\n     * Gets the current frame rate checked by the SceneOptimizer\r\n     */\n    get: function () {\n      return this._currentFrameRate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"targetFrameRate\", {\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\n    get: function () {\n      return this._targetFrameRate;\n    },\n\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\n    set: function (value) {\n      this._targetFrameRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"trackerDuration\", {\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\n    get: function () {\n      return this._trackerDuration;\n    },\n\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\n    set: function (value) {\n      this._trackerDuration = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneOptimizer.prototype, \"optimizations\", {\n    /**\r\n     * Gets the list of active optimizations\r\n     */\n    get: function () {\n      return this._options.optimizations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Stops the current optimizer\r\n   */\n\n  SceneOptimizer.prototype.stop = function () {\n    this._isRunning = false;\n  };\n  /**\r\n   * Reset the optimizer to initial step (current priority level = 0)\r\n   */\n\n\n  SceneOptimizer.prototype.reset = function () {\n    this._currentPriorityLevel = 0;\n  };\n  /**\r\n   * Start the optimizer. By default it will try to reach a specific framerate\r\n   * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate\r\n   */\n\n\n  SceneOptimizer.prototype.start = function () {\n    var _this = this;\n\n    if (this._isRunning) {\n      return;\n    }\n\n    this._isRunning = true; // Let's wait for the scene to be ready before running our check\n\n    this._scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n\n  SceneOptimizer.prototype._checkCurrentState = function () {\n    var _this = this;\n\n    if (!this._isRunning) {\n      return;\n    }\n\n    var scene = this._scene;\n    var options = this._options;\n    this._currentFrameRate = Math.round(scene.getEngine().getFps());\n\n    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\n      this._isRunning = false;\n      this.onSuccessObservable.notifyObservers(this);\n      return;\n    } // Apply current level of optimizations\n\n\n    var allDone = true;\n    var noOptimizationApplied = true;\n\n    for (var index = 0; index < options.optimizations.length; index++) {\n      var optimization = options.optimizations[index];\n\n      if (optimization.priority === this._currentPriorityLevel) {\n        noOptimizationApplied = false;\n        allDone = allDone && optimization.apply(scene, this);\n        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n      }\n    } // If no optimization was applied, this is a failure :(\n\n\n    if (noOptimizationApplied) {\n      this._isRunning = false;\n      this.onFailureObservable.notifyObservers(this);\n      return;\n    } // If all optimizations were done, move to next level\n\n\n    if (allDone) {\n      this._currentPriorityLevel++;\n    } // Let's the system running for a specific amount of time before checking FPS\n\n\n    scene.executeWhenReady(function () {\n      setTimeout(function () {\n        _this._checkCurrentState();\n      }, _this._trackerDuration);\n    });\n  };\n  /**\r\n   * Release all resources\r\n   */\n\n\n  SceneOptimizer.prototype.dispose = function () {\n    this.stop();\n    this.onSuccessObservable.clear();\n    this.onFailureObservable.clear();\n    this.onNewOptimizationAppliedObservable.clear();\n\n    if (this._sceneDisposeObserver) {\n      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n  };\n  /**\r\n   * Helper function to create a SceneOptimizer with one single line of code\r\n   * @param scene defines the scene to work on\r\n   * @param options defines the options to use with the SceneOptimizer\r\n   * @param onSuccess defines a callback to call on success\r\n   * @param onFailure defines a callback to call on failure\r\n   * @returns the new SceneOptimizer object\r\n   */\n\n\n  SceneOptimizer.OptimizeAsync = function (scene, options, onSuccess, onFailure) {\n    var optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n\n    if (onSuccess) {\n      optimizer.onSuccessObservable.add(function () {\n        onSuccess();\n      });\n    }\n\n    if (onFailure) {\n      optimizer.onFailureObservable.add(function () {\n        onFailure();\n      });\n    }\n\n    optimizer.start();\n    return optimizer;\n  };\n\n  return SceneOptimizer;\n}();\n\nexport { SceneOptimizer };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/sceneOptimizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene, IDisposable } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observer, Observable } from \"./observable\";\r\n\r\n/**\r\n * Defines the root class used to create scene optimization to use with SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates the SceneOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param desc defines the description associated with the optimization\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0) {\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to reduce the size of render target textures\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class TextureOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Reducing render target texture size to \" + this.maximumSize;\r\n    }\r\n\r\n    /**\r\n     * Creates the TextureOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n         */\r\n        public maximumSize: number = 1024,\r\n        /**\r\n         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n         */\r\n        public step = 0.5) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n\r\n        var allDone = true;\r\n        for (var index = 0; index < scene.textures.length; index++) {\r\n            var texture = scene.textures[index];\r\n\r\n            if (!texture.canRescale || (<any>texture).getContext) {\r\n                continue;\r\n            }\r\n\r\n            var currentSize = texture.getSize();\r\n            var maxDimension = Math.max(currentSize.width, currentSize.height);\r\n\r\n            if (maxDimension > this.maximumSize) {\r\n                texture.scale(this.step);\r\n                allDone = false;\r\n            }\r\n        }\r\n\r\n        return allDone;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to increase or decrease the rendering resolution\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class HardwareScalingOptimization extends SceneOptimization {\r\n    private _currentScale = -1;\r\n    private _directionOffset = 1;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Setting hardware scaling level to \" + this._currentScale;\r\n    }\r\n\r\n    /**\r\n     * Creates the HardwareScalingOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumScale defines the maximum scale to use (2 by default)\r\n     * @param step defines the step to use between two passes (0.5 by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum scale to use (2 by default)\r\n         */\r\n        public maximumScale: number = 2,\r\n        /**\r\n         * Defines the step to use between two passes (0.5 by default)\r\n         */\r\n        public step: number = 0.25) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this._currentScale === -1) {\r\n            this._currentScale = scene.getEngine().getHardwareScalingLevel();\r\n            if (this._currentScale > this.maximumScale) {\r\n                this._directionOffset = -1;\r\n            }\r\n        }\r\n\r\n        this._currentScale += this._directionOffset * this.step;\r\n\r\n        scene.getEngine().setHardwareScalingLevel(this._currentScale);\r\n\r\n        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to remove shadows\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class ShadowsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning shadows on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.shadowsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn post-processes off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class PostProcessesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning post-processes on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.postProcessesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn lens flares off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class LensFlaresOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning lens flares on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.lensFlaresEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization based on user defined callback.\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class CustomOptimization extends SceneOptimization {\r\n    /**\r\n     * Callback called to apply the custom optimization.\r\n     */\r\n    public onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean;\r\n\r\n    /**\r\n     * Callback called to get custom description\r\n     */\r\n    public onGetDescription: () => string;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        if (this.onGetDescription) {\r\n            return this.onGetDescription();\r\n        }\r\n\r\n        return \"Running user defined callback\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this.onApply) {\r\n            return this.onApply(scene, optimizer);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn particles off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class ParticlesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning particles on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.particlesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn render targets off\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class RenderTargetsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning render targets off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.renderTargetsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to merge meshes with compatible materials\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class MergeMeshesOptimization extends SceneOptimization {\r\n    private static _UpdateSelectionTree = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static get UpdateSelectionTree(): boolean {\r\n        return MergeMeshesOptimization._UpdateSelectionTree;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static set UpdateSelectionTree(value: boolean) {\r\n        MergeMeshesOptimization._UpdateSelectionTree = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @return description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Merging similar meshes together\";\r\n    }\r\n\r\n    private _canBeMerged = (abstractMesh: AbstractMesh): boolean => {\r\n        if (!(abstractMesh instanceof Mesh)) {\r\n            return false;\r\n        }\r\n\r\n        var mesh = <Mesh>abstractMesh;\r\n\r\n        if (mesh.isDisposed()) {\r\n            return false;\r\n        }\r\n\r\n        if (!mesh.isVisible || !mesh.isEnabled()) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.instances.length > 0) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.skeleton || mesh.hasLODLevels) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer, updateSelectionTree?: boolean): boolean {\r\n\r\n        var globalPool = scene.meshes.slice(0);\r\n        var globalLength = globalPool.length;\r\n\r\n        for (var index = 0; index < globalLength; index++) {\r\n            var currentPool = new Array<Mesh>();\r\n            var current = globalPool[index];\r\n\r\n            // Checks\r\n            if (!this._canBeMerged(current)) {\r\n                continue;\r\n            }\r\n\r\n            currentPool.push(<Mesh>current);\r\n\r\n            // Find compatible meshes\r\n            for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {\r\n                var otherMesh = globalPool[subIndex];\r\n\r\n                if (!this._canBeMerged(otherMesh)) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material !== current.material) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.checkCollisions !== current.checkCollisions) {\r\n                    continue;\r\n                }\r\n\r\n                currentPool.push(<Mesh>otherMesh);\r\n                globalLength--;\r\n\r\n                globalPool.splice(subIndex, 1);\r\n\r\n                subIndex--;\r\n            }\r\n\r\n            if (currentPool.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            // Merge meshes\r\n            Mesh.MergeMeshes(currentPool, undefined, true);\r\n        }\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const sceneAsAny = scene as any;\r\n        if (sceneAsAny.createOrUpdateSelectionOctree) {\r\n            if (updateSelectionTree != undefined) {\r\n                if (updateSelectionTree) {\r\n                    sceneAsAny.createOrUpdateSelectionOctree();\r\n                }\r\n            }\r\n            else if (MergeMeshesOptimization.UpdateSelectionTree) {\r\n                sceneAsAny.createOrUpdateSelectionOctree();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines a list of options used by SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimizerOptions {\r\n    /**\r\n     * Gets the list of optimizations to apply\r\n     */\r\n    public optimizations = new Array<SceneOptimization>();\r\n\r\n    /**\r\n     * Creates a new list of options used by SceneOptimizer\r\n     * @param targetFrameRate defines the target frame rate to reach (60 by default)\r\n     * @param trackerDuration defines the interval between two checkes (2000ms by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the target frame rate to reach (60 by default)\r\n         */\r\n        public targetFrameRate: number = 60,\r\n        /**\r\n         * Defines the interval between two checkes (2000ms by default)\r\n         */\r\n        public trackerDuration: number = 2000) {\r\n    }\r\n\r\n    /**\r\n     * Add a new optimization\r\n     * @param optimization defines the SceneOptimization to add to the list of active optimizations\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addOptimization(optimization: SceneOptimization): SceneOptimizerOptions {\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new custom optimization\r\n     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\r\n     * @param onGetDescription defines the callback called to get the description attached with the optimization.\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addCustomOptimization(onApply: (scene: Scene) => boolean, onGetDescription: () => string, priority: number = 0): SceneOptimizerOptions {\r\n        let optimization = new CustomOptimization(priority);\r\n        optimization.onApply = onApply;\r\n        optimization.onGetDescription = onGetDescription;\r\n\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static LowDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        var result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        var priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 1024));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static ModerateDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        var result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        var priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 512));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 2));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static HighDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        var result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        var priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 256));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 4));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to run optimizations in order to reach a target frame rate\r\n * @description More details at https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer\r\n */\r\nexport class SceneOptimizer implements IDisposable {\r\n    private _isRunning = false;\r\n    private _options: SceneOptimizerOptions;\r\n    private _scene: Scene;\r\n    private _currentPriorityLevel = 0;\r\n    private _targetFrameRate = 60;\r\n    private _trackerDuration = 2000;\r\n    private _currentFrameRate = 0;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _improvementMode = false;\r\n\r\n    /**\r\n     * Defines an observable called when the optimizer reaches the target frame rate\r\n     */\r\n    public onSuccessObservable = new Observable<SceneOptimizer>();\r\n    /**\r\n     * Defines an observable called when the optimizer enables an optimization\r\n     */\r\n    public onNewOptimizationAppliedObservable = new Observable<SceneOptimization>();\r\n    /**\r\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\r\n     */\r\n    public onFailureObservable = new Observable<SceneOptimizer>();\r\n\r\n    /**\r\n     * Gets a boolean indicating if the optimizer is in improvement mode\r\n     */\r\n    public get isInImprovementMode(): boolean {\r\n        return this._improvementMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the current priority level (0 at start)\r\n     */\r\n    public get currentPriorityLevel(): number {\r\n        return this._currentPriorityLevel;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame rate checked by the SceneOptimizer\r\n     */\r\n    public get currentFrameRate(): number {\r\n        return this._currentFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public get targetFrameRate(): number {\r\n        return this._targetFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public set targetFrameRate(value: number) {\r\n        this._targetFrameRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public get trackerDuration(): number {\r\n        return this._trackerDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public set trackerDuration(value: number) {\r\n        this._trackerDuration = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active optimizations\r\n     */\r\n    public get optimizations(): SceneOptimization[] {\r\n        return this._options.optimizations;\r\n    }\r\n\r\n    /**\r\n     * Creates a new SceneOptimizer\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\r\n     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\r\n     */\r\n    public constructor(scene: Scene, options?: SceneOptimizerOptions, autoGeneratePriorities = true, improvementMode = false) {\r\n        if (!options) {\r\n            this._options = new SceneOptimizerOptions();\r\n        } else {\r\n            this._options = options;\r\n        }\r\n\r\n        if (this._options.targetFrameRate) {\r\n            this._targetFrameRate = this._options.targetFrameRate;\r\n        }\r\n\r\n        if (this._options.trackerDuration) {\r\n            this._trackerDuration = this._options.trackerDuration;\r\n        }\r\n\r\n        if (autoGeneratePriorities) {\r\n            let priority = 0;\r\n            for (var optim of this._options.optimizations) {\r\n                optim.priority = priority++;\r\n            }\r\n        }\r\n\r\n        this._improvementMode = improvementMode;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\r\n            this._sceneDisposeObserver = null;\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops the current optimizer\r\n     */\r\n    public stop() {\r\n        this._isRunning = false;\r\n    }\r\n\r\n    /**\r\n     * Reset the optimizer to initial step (current priority level = 0)\r\n     */\r\n    public reset() {\r\n        this._currentPriorityLevel = 0;\r\n    }\r\n\r\n    /**\r\n     * Start the optimizer. By default it will try to reach a specific framerate\r\n     * but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate\r\n     */\r\n    public start() {\r\n        if (this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        this._isRunning = true;\r\n\r\n        // Let's wait for the scene to be ready before running our check\r\n        this._scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    private _checkCurrentState() {\r\n        if (!this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        let scene = this._scene;\r\n        let options = this._options;\r\n\r\n        this._currentFrameRate = Math.round(scene.getEngine().getFps());\r\n\r\n        if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate ||\r\n            !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\r\n            this._isRunning = false;\r\n            this.onSuccessObservable.notifyObservers(this);\r\n            return;\r\n        }\r\n\r\n        // Apply current level of optimizations\r\n        var allDone = true;\r\n        var noOptimizationApplied = true;\r\n        for (var index = 0; index < options.optimizations.length; index++) {\r\n            var optimization = options.optimizations[index];\r\n\r\n            if (optimization.priority === this._currentPriorityLevel) {\r\n                noOptimizationApplied = false;\r\n                allDone = allDone && optimization.apply(scene, this);\r\n                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\r\n            }\r\n        }\r\n\r\n        // If no optimization was applied, this is a failure :(\r\n        if (noOptimizationApplied) {\r\n            this._isRunning = false;\r\n            this.onFailureObservable.notifyObservers(this);\r\n\r\n            return;\r\n        }\r\n\r\n        // If all optimizations were done, move to next level\r\n        if (allDone) {\r\n            this._currentPriorityLevel++;\r\n        }\r\n\r\n        // Let's the system running for a specific amount of time before checking FPS\r\n        scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this.stop();\r\n        this.onSuccessObservable.clear();\r\n        this.onFailureObservable.clear();\r\n        this.onNewOptimizationAppliedObservable.clear();\r\n        if (this._sceneDisposeObserver) {\r\n            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to create a SceneOptimizer with one single line of code\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param onSuccess defines a callback to call on success\r\n     * @param onFailure defines a callback to call on failure\r\n     * @returns the new SceneOptimizer object\r\n     */\r\n    public static OptimizeAsync(scene: Scene, options?: SceneOptimizerOptions, onSuccess?: () => void, onFailure?: () => void): SceneOptimizer {\r\n        let optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\r\n\r\n        if (onSuccess) {\r\n            optimizer.onSuccessObservable.add(() => {\r\n                onSuccess();\r\n            });\r\n        }\r\n\r\n        if (onFailure) {\r\n            optimizer.onFailureObservable.add(() => {\r\n                onFailure();\r\n            });\r\n        }\r\n\r\n        optimizer.start();\r\n\r\n        return optimizer;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}