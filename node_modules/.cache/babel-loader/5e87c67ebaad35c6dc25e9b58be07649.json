{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Color3, Color4 } from \"../Maths/math.color\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\nimport { Material } from \"../Materials/material\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport { MaterialHelper } from '../Materials/materialHelper';\nimport \"../Shaders/color.fragment\";\nimport \"../Shaders/color.vertex\";\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\n\nvar LinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(LinesMesh, _super);\n  /**\r\n   * Creates a new LinesMesh\r\n   * @param name defines the name\r\n   * @param scene defines the hosting scene\r\n   * @param parent defines the parent mesh if any\r\n   * @param source defines the optional source LinesMesh used to clone data from\r\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n   * When false, achieved by calling a clone(), also passing False.\r\n   * This will make creation of children, recursive.\r\n   * @param useVertexColor defines if this LinesMesh supports vertex color\r\n   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n   */\n\n\n  function LinesMesh(name, scene, parent, source, doNotCloneChildren,\n  /**\r\n   * If vertex color should be applied to the mesh\r\n   */\n  useVertexColor,\n  /**\r\n   * If vertex alpha should be applied to the mesh\r\n   */\n  useVertexAlpha) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (parent === void 0) {\n      parent = null;\n    }\n\n    if (source === void 0) {\n      source = null;\n    }\n\n    var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\n\n    _this.useVertexColor = useVertexColor;\n    _this.useVertexAlpha = useVertexAlpha;\n    /**\r\n     * Color of the line (Default: White)\r\n     */\n\n    _this.color = new Color3(1, 1, 1);\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\n\n    _this.alpha = 1;\n\n    if (source) {\n      _this.color = source.color.clone();\n      _this.alpha = source.alpha;\n      _this.useVertexColor = source.useVertexColor;\n      _this.useVertexAlpha = source.useVertexAlpha;\n    }\n\n    _this.intersectionThreshold = 0.1;\n    var defines = [];\n    var options = {\n      attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\n      uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\n      needAlphaBlending: true,\n      defines: defines\n    };\n\n    if (useVertexAlpha === false) {\n      options.needAlphaBlending = false;\n    }\n\n    if (!useVertexColor) {\n      options.uniforms.push(\"color\");\n      _this.color4 = new Color4();\n    } else {\n      options.defines.push(\"#define VERTEXCOLOR\");\n      options.attributes.push(VertexBuffer.ColorKind);\n    }\n\n    _this._colorShader = new ShaderMaterial(\"colorShader\", _this.getScene(), \"color\", options);\n    return _this;\n  }\n\n  LinesMesh.prototype._addClipPlaneDefine = function (label) {\n    var define = \"#define \" + label;\n\n    var index = this._colorShader.options.defines.indexOf(define);\n\n    if (index !== -1) {\n      return;\n    }\n\n    this._colorShader.options.defines.push(define);\n  };\n\n  LinesMesh.prototype._removeClipPlaneDefine = function (label) {\n    var define = \"#define \" + label;\n\n    var index = this._colorShader.options.defines.indexOf(define);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._colorShader.options.defines.splice(index, 1);\n  };\n\n  LinesMesh.prototype.isReady = function () {\n    var scene = this.getScene(); // Clip planes\n\n    scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\n    scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\n    scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\n    scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\n    scene.clipPlane5 ? this._addClipPlaneDefine(\"CLIPPLANE5\") : this._removeClipPlaneDefine(\"CLIPPLANE5\");\n    scene.clipPlane6 ? this._addClipPlaneDefine(\"CLIPPLANE6\") : this._removeClipPlaneDefine(\"CLIPPLANE6\");\n\n    if (!this._colorShader.isReady(this)) {\n      return false;\n    }\n\n    return _super.prototype.isReady.call(this);\n  };\n  /**\r\n   * Returns the string \"LineMesh\"\r\n   */\n\n\n  LinesMesh.prototype.getClassName = function () {\n    return \"LinesMesh\";\n  };\n\n  Object.defineProperty(LinesMesh.prototype, \"material\", {\n    /**\r\n     * @hidden\r\n     */\n    get: function () {\n      return this._colorShader;\n    },\n\n    /**\r\n     * @hidden\r\n     */\n    set: function (value) {// Do nothing\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\n    /**\r\n     * @hidden\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  LinesMesh.prototype._bind = function (subMesh, effect, fillMode) {\n    if (!this._geometry) {\n      return this;\n    }\n\n    var colorEffect = this._colorShader.getEffect(); // VBOs\n\n\n    var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\n\n    this._geometry._bind(colorEffect, indexToBind); // Color\n\n\n    if (!this.useVertexColor) {\n      var _a = this.color,\n          r = _a.r,\n          g = _a.g,\n          b = _a.b;\n      this.color4.set(r, g, b, this.alpha);\n\n      this._colorShader.setColor4(\"color\", this.color4);\n    } // Clip planes\n\n\n    MaterialHelper.BindClipPlane(colorEffect, this.getScene());\n    return this;\n  };\n  /** @hidden */\n\n\n  LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n\n    var engine = this.getScene().getEngine(); // Draw order\n\n    if (this._unIndexed) {\n      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n    } else {\n      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\n    }\n\n    return this;\n  };\n  /**\r\n   * Disposes of the line mesh\r\n   * @param doNotRecurse If children should be disposed\r\n   */\n\n\n  LinesMesh.prototype.dispose = function (doNotRecurse) {\n    this._colorShader.dispose(false, false, true);\n\n    _super.prototype.dispose.call(this, doNotRecurse);\n  };\n  /**\r\n   * Returns a new LineMesh object cloned from the current one.\r\n   */\n\n\n  LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n  };\n  /**\r\n   * Creates a new InstancedLinesMesh object from the mesh model.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n   * @param name defines the name of the new instance\r\n   * @returns a new InstancedLinesMesh\r\n   */\n\n\n  LinesMesh.prototype.createInstance = function (name) {\n    return new InstancedLinesMesh(name, this);\n  };\n\n  return LinesMesh;\n}(Mesh);\n\nexport { LinesMesh };\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\n\nvar InstancedLinesMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedLinesMesh, _super);\n\n  function InstancedLinesMesh(name, source) {\n    var _this = _super.call(this, name, source) || this;\n\n    _this.intersectionThreshold = source.intersectionThreshold;\n    return _this;\n  }\n  /**\r\n   * Returns the string \"InstancedLinesMesh\".\r\n   */\n\n\n  InstancedLinesMesh.prototype.getClassName = function () {\n    return \"InstancedLinesMesh\";\n  };\n\n  return InstancedLinesMesh;\n}(InstancedMesh);\n\nexport { InstancedLinesMesh };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/linesMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport { MaterialHelper } from '../Materials/materialHelper';\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _colorShader: ShaderMaterial;\r\n\r\n    private color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        var defines: string[] = [];\r\n        var options = {\r\n            attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this.color4 = new Color4();\r\n        }\r\n        else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options);\r\n    }\r\n\r\n    private _addClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.push(define);\r\n    }\r\n\r\n    private _removeClipPlaneDefine(label: string) {\r\n        const define = \"#define \" + label;\r\n        let index = this._colorShader.options.defines.indexOf(define);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader.options.defines.splice(index, 1);\r\n    }\r\n\r\n    public isReady() {\r\n        const scene = this.getScene();\r\n\r\n        // Clip planes\r\n        scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\r\n        scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\r\n        scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\r\n        scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\r\n        scene.clipPlane5 ? this._addClipPlaneDefine(\"CLIPPLANE5\") : this._removeClipPlaneDefine(\"CLIPPLANE5\");\r\n        scene.clipPlane6 ? this._addClipPlaneDefine(\"CLIPPLANE6\") : this._removeClipPlaneDefine(\"CLIPPLANE6\");\r\n\r\n        if (!this._colorShader.isReady(this)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get material(): Material {\r\n        return this._colorShader;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public set material(value: Material) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bind(subMesh: SubMesh, effect: Effect, fillMode: number): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        const colorEffect = this._colorShader.getEffect();\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        this._geometry._bind(colorEffect, indexToBind);\r\n\r\n        // Color\r\n        if (!this.useVertexColor) {\r\n            const { r, g, b } = this.color;\r\n            this.color4.set(r, g, b, this.alpha);\r\n            this._colorShader.setColor4(\"color\", this.color4);\r\n        }\r\n\r\n        // Clip planes\r\n        MaterialHelper.BindClipPlane(colorEffect!, this.getScene());\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        var engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        }\r\n        else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    public dispose(doNotRecurse?: boolean): void {\r\n        this._colorShader.dispose(false, false, true);\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        return new InstancedLinesMesh(name, this);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initilized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}