{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Material } from \"../Materials/material\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\nimport { EffectLayer } from \"./effectLayer\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { Logger } from \"../Misc/logger\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Color4, Color3 } from '../Maths/math.color';\nimport \"../Shaders/glowMapMerge.fragment\";\nimport \"../Shaders/glowMapMerge.vertex\";\nimport \"../Shaders/glowBlurPostProcess.fragment\";\n\nAbstractScene.prototype.getHighlightLayerByName = function (name) {\n  for (var index = 0; index < this.effectLayers.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n\n  return null;\n};\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\n\n\nvar GlowBlurPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(GlowBlurPostProcess, _super);\n\n  function GlowBlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable) {\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable) || this;\n\n    _this.direction = direction;\n    _this.kernel = kernel;\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setFloat2(\"screenSize\", _this.width, _this.height);\n      effect.setVector2(\"direction\", _this.direction);\n      effect.setFloat(\"blurWidth\", _this.kernel);\n    });\n\n    return _this;\n  }\n\n  return GlowBlurPostProcess;\n}(PostProcess);\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\n\n\nvar HighlightLayer =\n/** @class */\nfunction (_super) {\n  __extends(HighlightLayer, _super);\n  /**\r\n   * Instantiates a new highlight Layer and references it to the scene..\r\n   * @param name The name of the layer\r\n   * @param scene The scene to use the layer in\r\n   * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n   */\n\n\n  function HighlightLayer(name, scene, options) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this.name = name;\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\n\n    _this.innerGlow = true;\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\n\n    _this.outerGlow = true;\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\n\n    _this.onBeforeBlurObservable = new Observable();\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\n\n    _this.onAfterBlurObservable = new Observable();\n    _this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\n    _this._meshes = {};\n    _this._excludedMeshes = {};\n    _this.neutralColor = HighlightLayer.NeutralColor; // Warn on stencil\n\n    if (!_this._engine.isStencilEnable) {\n      Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\n    } // Adapt options\n\n\n    _this._options = __assign({\n      mainTextureRatio: 0.5,\n      blurTextureSizeRatio: 0.5,\n      blurHorizontalSize: 1.0,\n      blurVerticalSize: 1.0,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1\n    }, options); // Initialize the layer\n\n    _this._init({\n      alphaBlendingMode: _this._options.alphaBlendingMode,\n      camera: _this._options.camera,\n      mainTextureFixedSize: _this._options.mainTextureFixedSize,\n      mainTextureRatio: _this._options.mainTextureRatio,\n      renderingGroupId: _this._options.renderingGroupId\n    }); // Do not render as long as no meshes have been added\n\n\n    _this._shouldRender = false;\n    return _this;\n  }\n\n  Object.defineProperty(HighlightLayer.prototype, \"blurHorizontalSize\", {\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\n    get: function () {\n      return this._horizontalBlurPostprocess.kernel;\n    },\n\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\n    set: function (value) {\n      this._horizontalBlurPostprocess.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(HighlightLayer.prototype, \"blurVerticalSize\", {\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\n    get: function () {\n      return this._verticalBlurPostprocess.kernel;\n    },\n\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\n    set: function (value) {\n      this._verticalBlurPostprocess.kernel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the effect name of the layer.\r\n   * @return The effect name\r\n   */\n\n  HighlightLayer.prototype.getEffectName = function () {\n    return HighlightLayer.EffectName;\n  };\n  /**\r\n   * Create the merge effect. This is the shader use to blit the information back\r\n   * to the main canvas at the end of the scene rendering.\r\n   */\n\n\n  HighlightLayer.prototype._createMergeEffect = function () {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\n  };\n  /**\r\n   * Creates the render target textures and post processes used in the highlight layer.\r\n   */\n\n\n  HighlightLayer.prototype._createTextureAndPostProcesses = function () {\n    var _this = this;\n\n    var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n    var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    var textureType = 0;\n\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n\n    this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.anisotropicFilteringLevel = 16;\n\n    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\n\n    this._blurTexture.renderParticles = false;\n    this._blurTexture.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture];\n\n    if (this._options.alphaBlendingMode === 2) {\n      this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._downSamplePostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n\n      this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n\n      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    } else {\n      this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._horizontalBlurPostprocess.width = blurTextureWidth;\n      this._horizontalBlurPostprocess.height = blurTextureHeight;\n\n      this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n        effect.setTexture(\"textureSampler\", _this._mainTexture);\n      });\n\n      this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    }\n\n    this._mainTexture.onAfterUnbindObservable.add(function () {\n      _this.onBeforeBlurObservable.notifyObservers(_this);\n\n      var internalTexture = _this._blurTexture.getInternalTexture();\n\n      if (internalTexture) {\n        _this._scene.postProcessManager.directRender(_this._postProcesses, internalTexture, true);\n\n        _this._engine.unBindFramebuffer(internalTexture, true);\n      }\n\n      _this.onAfterBlurObservable.notifyObservers(_this);\n    }); // Prevent autoClear.\n\n\n    this._postProcesses.map(function (pp) {\n      pp.autoClear = false;\n    });\n  };\n  /**\r\n   * Returns wether or nood the layer needs stencil enabled during the mesh rendering.\r\n   */\n\n\n  HighlightLayer.prototype.needStencil = function () {\n    return true;\n  };\n  /**\r\n   * Checks for the readiness of the element composing the layer.\r\n   * @param subMesh the mesh to check for\r\n   * @param useInstances specify wether or not to use instances to render the mesh\r\n   * @param emissiveTexture the associated emissive texture used to generate the glow\r\n   * @return true if ready otherwise, false\r\n   */\n\n\n  HighlightLayer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n    var mesh = subMesh.getRenderingMesh();\n\n    if (!material || !mesh || !this._meshes) {\n      return false;\n    }\n\n    var emissiveTexture = null;\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      emissiveTexture = material.emissiveTexture;\n    }\n\n    return _super.prototype._isReady.call(this, subMesh, useInstances, emissiveTexture);\n  };\n  /**\r\n   * Implementation specific of rendering the generating effect on the main canvas.\r\n   * @param effect The effect used to render through\r\n   */\n\n\n  HighlightLayer.prototype._internalRender = function (effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture); // Cache\n\n    var engine = this._engine;\n    engine.cacheStencilState(); // Stencil operations\n\n    engine.setStencilOperationPass(7681);\n    engine.setStencilOperationFail(7680);\n    engine.setStencilOperationDepthFail(7680); // Draw order\n\n    engine.setStencilMask(0x00);\n    engine.setStencilBuffer(true);\n    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference); // 2 passes inner outer\n\n    if (this.outerGlow) {\n      effect.setFloat(\"offset\", 0);\n      engine.setStencilFunction(517);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    if (this.innerGlow) {\n      effect.setFloat(\"offset\", 1);\n      engine.setStencilFunction(514);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    } // Restore Cache\n\n\n    engine.restoreStencilState();\n  };\n  /**\r\n   * Returns true if the layer contains information to display, otherwise false.\r\n   */\n\n\n  HighlightLayer.prototype.shouldRender = function () {\n    if (_super.prototype.shouldRender.call(this)) {\n      return this._meshes ? true : false;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the mesh should render, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @returns true if it should render otherwise false\r\n   */\n\n\n  HighlightLayer.prototype._shouldRenderMesh = function (mesh) {\n    // Excluded Mesh\n    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Returns true if the mesh can be rendered, otherwise false.\r\n   * @param mesh The mesh to render\r\n   * @param material The material used on the mesh\r\n   * @returns true if it can be rendered otherwise false\r\n   */\n\n\n  HighlightLayer.prototype._canRenderMesh = function (mesh, material) {\n    // all meshes can be rendered in the highlight layer, even transparent ones\n    return true;\n  };\n  /**\r\n   * Adds specific effects defines.\r\n   * @param defines The defines to add specifics to.\r\n   */\n\n\n  HighlightLayer.prototype._addCustomEffectDefines = function (defines) {\n    defines.push(\"#define HIGHLIGHT\");\n  };\n  /**\r\n   * Sets the required values for both the emissive texture and and the main color.\r\n   */\n\n\n  HighlightLayer.prototype._setEmissiveTextureAndColor = function (mesh, subMesh, material) {\n    var highlightLayerMesh = this._meshes[mesh.uniqueId];\n\n    if (highlightLayerMesh) {\n      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n    } else {\n      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n    }\n\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      this._emissiveTextureAndColor.texture = material.emissiveTexture;\n\n      this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._emissiveTextureAndColor.texture = null;\n    }\n  };\n  /**\r\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n   * @param mesh The mesh to exclude from the highlight layer\r\n   */\n\n\n  HighlightLayer.prototype.addExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (!meshExcluded) {\n      this._excludedMeshes[mesh.uniqueId] = {\n        mesh: mesh,\n        beforeBind: mesh.onBeforeBindObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(false);\n        }),\n        afterRender: mesh.onAfterRenderObservable.add(function (mesh) {\n          mesh.getEngine().setStencilBuffer(true);\n        })\n      };\n    }\n  };\n  /**\r\n    * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n    * @param mesh The mesh to highlight\r\n    */\n\n\n  HighlightLayer.prototype.removeExcludedMesh = function (mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n\n    var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n\n    if (meshExcluded) {\n      if (meshExcluded.beforeBind) {\n        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\n      }\n\n      if (meshExcluded.afterRender) {\n        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n      }\n    }\n\n    this._excludedMeshes[mesh.uniqueId] = null;\n  };\n  /**\r\n   * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n   * @param mesh mesh to test\r\n   * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n   */\n\n\n  HighlightLayer.prototype.hasMesh = function (mesh) {\n    if (!this._meshes) {\n      return false;\n    }\n\n    if (!_super.prototype.hasMesh.call(this, mesh)) {\n      return false;\n    }\n\n    return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\n  };\n  /**\r\n   * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n   * @param mesh The mesh to highlight\r\n   * @param color The color of the highlight\r\n   * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n   */\n\n\n  HighlightLayer.prototype.addMesh = function (mesh, color, glowEmissiveOnly) {\n    var _this = this;\n\n    if (glowEmissiveOnly === void 0) {\n      glowEmissiveOnly = false;\n    }\n\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      meshHighlight.color = color;\n    } else {\n      this._meshes[mesh.uniqueId] = {\n        mesh: mesh,\n        color: color,\n        // Lambda required for capture due to Observable this context\n        observerHighlight: mesh.onBeforeBindObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            if (_this._excludedMeshes && _this._excludedMeshes[mesh.uniqueId]) {\n              _this._defaultStencilReference(mesh);\n            } else {\n              mesh.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);\n            }\n          }\n        }),\n        observerDefault: mesh.onAfterRenderObservable.add(function (mesh) {\n          if (_this.isEnabled) {\n            _this._defaultStencilReference(mesh);\n          }\n        }),\n        glowEmissiveOnly: glowEmissiveOnly\n      };\n      mesh.onDisposeObservable.add(function () {\n        _this._disposeMesh(mesh);\n      });\n    }\n\n    this._shouldRender = true;\n  };\n  /**\r\n   * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n   * @param mesh The mesh to highlight\r\n   */\n\n\n  HighlightLayer.prototype.removeMesh = function (mesh) {\n    if (!this._meshes) {\n      return;\n    }\n\n    var meshHighlight = this._meshes[mesh.uniqueId];\n\n    if (meshHighlight) {\n      if (meshHighlight.observerHighlight) {\n        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n      }\n\n      if (meshHighlight.observerDefault) {\n        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n      }\n\n      delete this._meshes[mesh.uniqueId];\n    }\n\n    this._shouldRender = false;\n\n    for (var meshHighlightToCheck in this._meshes) {\n      if (this._meshes[meshHighlightToCheck]) {\n        this._shouldRender = true;\n        break;\n      }\n    }\n  };\n  /**\r\n   * Remove all the meshes currently referenced in the highlight layer\r\n   */\n\n\n  HighlightLayer.prototype.removeAllMeshes = function () {\n    if (!this._meshes) {\n      return;\n    }\n\n    for (var uniqueId in this._meshes) {\n      if (this._meshes.hasOwnProperty(uniqueId)) {\n        var mesh = this._meshes[uniqueId];\n\n        if (mesh) {\n          this.removeMesh(mesh.mesh);\n        }\n      }\n    }\n  };\n  /**\r\n   * Force the stencil to the normal expected value for none glowing parts\r\n   */\n\n\n  HighlightLayer.prototype._defaultStencilReference = function (mesh) {\n    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\n  };\n  /**\r\n   * Free any resources and references associated to a mesh.\r\n   * Internal use\r\n   * @param mesh The mesh to free.\r\n   * @hidden\r\n   */\n\n\n  HighlightLayer.prototype._disposeMesh = function (mesh) {\n    this.removeMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  };\n  /**\r\n   * Dispose the highlight layer and free resources.\r\n   */\n\n\n  HighlightLayer.prototype.dispose = function () {\n    if (this._meshes) {\n      // Clean mesh references\n      for (var id in this._meshes) {\n        var meshHighlight = this._meshes[id];\n\n        if (meshHighlight && meshHighlight.mesh) {\n          if (meshHighlight.observerHighlight) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n          }\n\n          if (meshHighlight.observerDefault) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n          }\n        }\n      }\n\n      this._meshes = null;\n    }\n\n    if (this._excludedMeshes) {\n      for (var id in this._excludedMeshes) {\n        var meshHighlight = this._excludedMeshes[id];\n\n        if (meshHighlight) {\n          if (meshHighlight.beforeBind) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\n          }\n\n          if (meshHighlight.afterRender) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n          }\n        }\n      }\n\n      this._excludedMeshes = null;\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n    * Gets the class name of the effect layer\r\n    * @returns the string with the class name of the effect layer\r\n    */\n\n\n  HighlightLayer.prototype.getClassName = function () {\n    return \"HighlightLayer\";\n  };\n  /**\r\n   * Serializes this Highlight layer\r\n   * @returns a serialized Highlight layer object\r\n   */\n\n\n  HighlightLayer.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.HighlightLayer\"; // Highlighted meshes\n\n    serializationObject.meshes = [];\n\n    if (this._meshes) {\n      for (var m in this._meshes) {\n        var mesh = this._meshes[m];\n\n        if (mesh) {\n          serializationObject.meshes.push({\n            glowEmissiveOnly: mesh.glowEmissiveOnly,\n            color: mesh.color.asArray(),\n            meshId: mesh.mesh.id\n          });\n        }\n      }\n    } // Excluded meshes\n\n\n    serializationObject.excludedMeshes = [];\n\n    if (this._excludedMeshes) {\n      for (var e in this._excludedMeshes) {\n        var excludedMesh = this._excludedMeshes[e];\n\n        if (excludedMesh) {\n          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\n        }\n      }\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a Highlight layer from parsed Highlight layer data\r\n   * @param parsedHightlightLayer defines the Highlight layer data\r\n   * @param scene defines the current scene\r\n   * @param rootUrl defines the root URL containing the Highlight layer information\r\n   * @returns a parsed Highlight layer\r\n   */\n\n\n  HighlightLayer.Parse = function (parsedHightlightLayer, scene, rootUrl) {\n    var hl = SerializationHelper.Parse(function () {\n      return new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options);\n    }, parsedHightlightLayer, scene, rootUrl);\n    var index; // Excluded meshes\n\n    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\n      var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);\n\n      if (mesh) {\n        hl.addExcludedMesh(mesh);\n      }\n    } // Included meshes\n\n\n    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\n      var highlightedMesh = parsedHightlightLayer.meshes[index];\n      var mesh = scene.getMeshByID(highlightedMesh.meshId);\n\n      if (mesh) {\n        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\n      }\n    }\n\n    return hl;\n  };\n  /**\r\n   * Effect Name of the highlight layer.\r\n   */\n\n\n  HighlightLayer.EffectName = \"HighlightLayer\";\n  /**\r\n   * The neutral color used during the preparation of the glow effect.\r\n   * This is black by default as the blend operation is a blend operation.\r\n   */\n\n  HighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);\n  /**\r\n   * Stencil value used for glowing meshes.\r\n   */\n\n  HighlightLayer.GlowingMeshStencilReference = 0x02;\n  /**\r\n   * Stencil value used for the other meshes in the scene.\r\n   */\n\n  HighlightLayer.NormalMeshStencilReference = 0x01;\n\n  __decorate([serialize()], HighlightLayer.prototype, \"innerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"outerGlow\", void 0);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurHorizontalSize\", null);\n\n  __decorate([serialize()], HighlightLayer.prototype, \"blurVerticalSize\", null);\n\n  __decorate([serialize(\"options\")], HighlightLayer.prototype, \"_options\", void 0);\n\n  return HighlightLayer;\n}(EffectLayer);\n\nexport { HighlightLayer };\n_TypeStore.RegisteredTypes[\"BABYLON.HighlightLayer\"] = HighlightLayer;","map":{"version":3,"sources":["../../../sourceES6/core/Layers/highlightLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Observer, Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess, PostProcessOptions } from \"../PostProcesses/postProcess\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Color4, Color3 } from '../Maths/math.color';\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Shaders/glowBlurPostProcess.fragment\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @return The highlight layer if found otherwise null.\r\n         */\r\n        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getHighlightLayerByName = function(name: string): Nullable<HighlightLayer> {\r\n    for (var index = 0; index < this.effectLayers.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as HighlightLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\r\nclass GlowBlurPostProcess extends PostProcess {\r\n    constructor(name: string, public direction: Vector2, public kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode: number = Texture.BILINEAR_SAMPLINGMODE, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"screenSize\", this.width, this.height);\r\n            effect.setVector2(\"direction\", this.direction);\r\n            effect.setFloat(\"blurWidth\", this.kernel);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IHighlightLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independant blur.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster).\r\n     */\r\n    blurTextureSizeRatio: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur.\r\n     */\r\n    blurVerticalSize: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur.\r\n     */\r\n    blurHorizontalSize: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default is combine.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke?\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n}\r\n\r\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\r\nexport class HighlightLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    private _instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    @serialize(\"options\")\r\n    private _options: IHighlightLayerOptions;\r\n    private _downSamplePostprocess: PassPostProcess;\r\n    private _horizontalBlurPostprocess: GlowBlurPostProcess;\r\n    private _verticalBlurPostprocess: GlowBlurPostProcess;\r\n    private _blurTexture: RenderTargetTexture;\r\n\r\n    private _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    private _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     */\r\n    constructor(public name: string, scene: Scene, options?: Partial<IHighlightLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = HighlightLayer.NeutralColor;\r\n\r\n        // Warn on stencil\r\n        if (!this._engine.isStencilEnable) {\r\n            Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\r\n        }\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: 2,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId\r\n        });\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return HighlightLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\"],\r\n            this._options.isStroke ? \"#define STROKE \\n\" : undefined);\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the highlight layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\r\n        var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        var textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = 2;\r\n        }\r\n        else {\r\n            textureType = 0;\r\n        }\r\n\r\n        this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType);\r\n        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.anisotropicFilteringLevel = 16;\r\n        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._blurTexture.renderParticles = false;\r\n        this._blurTexture.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture];\r\n\r\n        if (this._options.alphaBlendingMode === 2) {\r\n            this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._downSamplePostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._verticalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n        else {\r\n            this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n            this._horizontalBlurPostprocess.width = blurTextureWidth;\r\n            this._horizontalBlurPostprocess.height = blurTextureHeight;\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this.onBeforeBlurObservable.notifyObservers(this);\r\n\r\n            let internalTexture = this._blurTexture.getInternalTexture();\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(\r\n                    this._postProcesses,\r\n                    internalTexture,\r\n                    true);\r\n                this._engine.unBindFramebuffer(internalTexture, true);\r\n            }\r\n\r\n            this.onAfterBlurObservable.notifyObservers(this);\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => { pp.autoClear = false; });\r\n    }\r\n\r\n    /**\r\n     * Returns wether or nood the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify wether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        let material = subMesh.getMaterial();\r\n        let mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<Texture> = null;\r\n        let highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture);\r\n\r\n        // Cache\r\n        var engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(7681);\r\n        engine.setStencilOperationFail(7680);\r\n        engine.setStencilOperationDepthFail(7680);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow) {\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(517);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow) {\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(514);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (super.shouldRender()) {\r\n            return this._meshes ? true : false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        // all meshes can be rendered in the highlight layer, even transparent ones\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define HIGHLIGHT\");\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        var highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(\r\n                highlightLayerMesh.color.r,\r\n                highlightLayerMesh.color.g,\r\n                highlightLayerMesh.color.b,\r\n                1.0);\r\n        }\r\n        else {\r\n            this._emissiveTextureAndColor.color.set(\r\n                this.neutralColor.r,\r\n                this.neutralColor.g,\r\n                this.neutralColor.b,\r\n                this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(\r\n                1.0,\r\n                1.0,\r\n                1.0,\r\n                1.0);\r\n        }\r\n        else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        var meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            this._excludedMeshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                beforeBind: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(false);\r\n                }),\r\n                afterRender: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(true);\r\n                }),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n      * @param mesh The mesh to highlight\r\n      */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        var meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        var meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        }\r\n        else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        }\r\n                        else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        var meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (var meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (this._meshes.hasOwnProperty(uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the stencil to the normal expected value for none glowing parts\r\n     */\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @hidden\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (let id in this._meshes) {\r\n                let meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (let id in this._excludedMeshes) {\r\n                let meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n      * Gets the class name of the effect layer\r\n      * @returns the string with the class name of the effect layer\r\n      */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this Highlight layer\r\n     * @returns a serialized Highlight layer object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.HighlightLayer\";\r\n\r\n        // Highlighted meshes\r\n        serializationObject.meshes = [];\r\n\r\n        if (this._meshes) {\r\n            for (var m in this._meshes) {\r\n                var mesh = this._meshes[m];\r\n\r\n                if (mesh) {\r\n                    serializationObject.meshes.push({\r\n                        glowEmissiveOnly: mesh.glowEmissiveOnly,\r\n                        color: mesh.color.asArray(),\r\n                        meshId: mesh.mesh.id\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes) {\r\n            for (var e in this._excludedMeshes) {\r\n                var excludedMesh = this._excludedMeshes[e];\r\n\r\n                if (excludedMesh) {\r\n                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Highlight layer from parsed Highlight layer data\r\n     * @param parsedHightlightLayer defines the Highlight layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the Highlight layer information\r\n     * @returns a parsed Highlight layer\r\n     */\r\n    public static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer {\r\n        var hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\r\n        var index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\r\n            var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                hl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\r\n            var highlightedMesh = parsedHightlightLayer.meshes[index];\r\n            var mesh = scene.getMeshByID(highlightedMesh.meshId);\r\n\r\n            if (mesh) {\r\n                hl.addMesh(<Mesh>mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\r\n            }\r\n        }\r\n\r\n        return hl;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.HighlightLayer\"] = HighlightLayer;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}