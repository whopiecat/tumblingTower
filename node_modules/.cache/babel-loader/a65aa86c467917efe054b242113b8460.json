{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { Logger } from \"../Misc/logger\";\nimport { _DevTools } from \"../Misc/devTools\";\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\n\nvar Sound =\n/** @class */\nfunction () {\n  /**\r\n   * Create a sound and attach it to a scene\r\n   * @param name Name of your sound\r\n   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\r\n   * @param scene defines the scene the sound belongs to\r\n   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n   */\n  function Sound(name, urlOrArrayBuffer, scene, readyToPlayCallback, options) {\n    var _this = this;\n\n    if (readyToPlayCallback === void 0) {\n      readyToPlayCallback = null;\n    }\n\n    var _a, _b, _c, _d;\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\n\n\n    this.autoplay = false;\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\n\n    this.loop = false;\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\n\n    this.useCustomAttenuation = false;\n    /**\r\n     * Is this sound currently played.\r\n     */\n\n    this.isPlaying = false;\n    /**\r\n     * Is this sound currently paused.\r\n     */\n\n    this.isPaused = false;\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.spatialSound = false;\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.refDistance = 1;\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.rolloffFactor = 1;\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.maxDistance = 100;\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\n\n    this.distanceModel = \"linear\";\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\n\n    this.metadata = null;\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\n\n    this.onEndedObservable = new Observable();\n    this._panningModel = \"equalpower\";\n    this._playbackRate = 1;\n    this._streaming = false;\n    this._startTime = 0;\n    this._startOffset = 0;\n    this._position = Vector3.Zero();\n    /** @hidden */\n\n    this._positionInEmitterSpace = false;\n    this._localDirection = new Vector3(1, 0, 0);\n    this._volume = 1;\n    this._isReadyToPlay = false;\n    this._isDirectional = false; // Used if you'd like to create a directional sound.\n    // If not set, the sound will be omnidirectional\n\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._coneOuterGain = 0;\n    this._isOutputConnected = false;\n    this._urlType = \"Unknown\";\n    this.name = name;\n    this._scene = scene;\n\n    Sound._SceneComponentInitialization(scene);\n\n    this._readyToPlayCallback = readyToPlayCallback; // Default custom attenuation function is a linear attenuation\n\n    this._customAttenuationFunction = function (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {\n      if (currentDistance < maxDistance) {\n        return currentVolume * (1 - currentDistance / maxDistance);\n      } else {\n        return 0;\n      }\n    };\n\n    if (options) {\n      this.autoplay = options.autoplay || false;\n      this.loop = options.loop || false; // if volume === 0, we need another way to check this option\n\n      if (options.volume !== undefined) {\n        this._volume = options.volume;\n      }\n\n      this.spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\n      this.rolloffFactor = options.rolloffFactor || 1;\n      this.refDistance = options.refDistance || 1;\n      this.distanceModel = options.distanceModel || \"linear\";\n      this._playbackRate = options.playbackRate || 1;\n      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\n      this._length = options.length;\n      this._offset = options.offset;\n    }\n\n    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\n      this._soundGain = Engine.audioEngine.audioContext.createGain();\n      this._soundGain.gain.value = this._volume;\n      this._inputAudioNode = this._soundGain;\n      this._outputAudioNode = this._soundGain;\n\n      if (this.spatialSound) {\n        this._createSpatialParameters();\n      }\n\n      this._scene.mainSoundTrack.addSound(this);\n\n      var validParameter = true; // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n\n      if (urlOrArrayBuffer) {\n        try {\n          if (typeof urlOrArrayBuffer === \"string\") {\n            this._urlType = \"String\";\n          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            this._urlType = \"ArrayBuffer\";\n          } else if (urlOrArrayBuffer instanceof MediaStream) {\n            this._urlType = \"MediaStream\";\n          } else if (Array.isArray(urlOrArrayBuffer)) {\n            this._urlType = \"Array\";\n          }\n\n          var urls = [];\n          var codecSupportedFound = false;\n\n          switch (this._urlType) {\n            case \"MediaStream\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n\n              break;\n\n            case \"ArrayBuffer\":\n              if (urlOrArrayBuffer.byteLength > 0) {\n                codecSupportedFound = true;\n\n                this._soundLoaded(urlOrArrayBuffer);\n              }\n\n              break;\n\n            case \"String\":\n              urls.push(urlOrArrayBuffer);\n\n            case \"Array\":\n              if (urls.length === 0) {\n                urls = urlOrArrayBuffer;\n              } // If we found a supported format, we load it immediately and stop the loop\n\n\n              for (var i = 0; i < urls.length; i++) {\n                var url = urls[i];\n                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(\".wav\", url.length - 4) !== -1 || url.indexOf(\".m4a\", url.length - 4) !== -1 || url.indexOf(\"blob:\") !== -1;\n\n                if (codecSupportedFound) {\n                  // Loading sound using XHR2\n                  if (!this._streaming) {\n                    this._scene._loadFile(url, function (data) {\n                      _this._soundLoaded(data);\n                    }, undefined, true, true, function (exception) {\n                      if (exception) {\n                        Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                      }\n\n                      Logger.Error(\"Sound creation aborted.\");\n\n                      _this._scene.mainSoundTrack.removeSound(_this);\n                    });\n                  } // Streaming sound using HTML5 Audio tag\n                  else {\n                      this._htmlAudioElement = new Audio(url);\n                      this._htmlAudioElement.controls = false;\n                      this._htmlAudioElement.loop = this.loop;\n                      Tools.SetCorsBehavior(url, this._htmlAudioElement);\n                      this._htmlAudioElement.preload = \"auto\";\n\n                      this._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\n                        _this._isReadyToPlay = true;\n\n                        if (_this.autoplay) {\n                          _this.play(0, _this._offset, _this._length);\n                        }\n\n                        if (_this._readyToPlayCallback) {\n                          _this._readyToPlayCallback();\n                        }\n                      });\n\n                      document.body.appendChild(this._htmlAudioElement);\n\n                      this._htmlAudioElement.load();\n                    }\n\n                  break;\n                }\n              }\n\n              break;\n\n            default:\n              validParameter = false;\n              break;\n          }\n\n          if (!validParameter) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n          } else {\n            if (!codecSupportedFound) {\n              this._isReadyToPlay = true; // Simulating a ready to play event to avoid breaking code path\n\n              if (this._readyToPlayCallback) {\n                window.setTimeout(function () {\n                  if (_this._readyToPlayCallback) {\n                    _this._readyToPlayCallback();\n                  }\n                }, 1000);\n              }\n            }\n          }\n        } catch (ex) {\n          Logger.Error(\"Unexpected error. Sound creation aborted.\");\n\n          this._scene.mainSoundTrack.removeSound(this);\n        }\n      }\n    } else {\n      // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n      this._scene.mainSoundTrack.addSound(this);\n\n      if (!Engine.audioEngine.WarnedWebAudioUnsupported) {\n        Logger.Error(\"Web Audio is not supported by your browser.\");\n        Engine.audioEngine.WarnedWebAudioUnsupported = true;\n      } // Simulating a ready to play event to avoid breaking code for non web audio browsers\n\n\n      if (this._readyToPlayCallback) {\n        window.setTimeout(function () {\n          if (_this._readyToPlayCallback) {\n            _this._readyToPlayCallback();\n          }\n        }, 1000);\n      }\n    }\n  }\n\n  Object.defineProperty(Sound.prototype, \"currentTime\", {\n    /**\r\n     * Gets the current time for the sound.\r\n     */\n    get: function () {\n      if (this._htmlAudioElement) {\n        return this._htmlAudioElement.currentTime;\n      }\n\n      var currentTime = this._startOffset;\n\n      if (this.isPlaying && Engine.audioEngine.audioContext) {\n        currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n\n      return currentTime;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Release the sound and its associated resources\r\n   */\n\n  Sound.prototype.dispose = function () {\n    if (Engine.audioEngine.canUseWebAudio) {\n      if (this.isPlaying) {\n        this.stop();\n      }\n\n      this._isReadyToPlay = false;\n\n      if (this.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(this);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[this.soundTrackId].removeSound(this);\n      }\n\n      if (this._soundGain) {\n        this._soundGain.disconnect();\n\n        this._soundGain = null;\n      }\n\n      if (this._soundPanner) {\n        this._soundPanner.disconnect();\n\n        this._soundPanner = null;\n      }\n\n      if (this._soundSource) {\n        this._soundSource.disconnect();\n\n        this._soundSource = null;\n      }\n\n      this._audioBuffer = null;\n\n      if (this._htmlAudioElement) {\n        this._htmlAudioElement.pause();\n\n        this._htmlAudioElement.src = \"\";\n        document.body.removeChild(this._htmlAudioElement);\n      }\n\n      if (this._streamingSource) {\n        this._streamingSource.disconnect();\n      }\n\n      if (this._connectedTransformNode && this._registerFunc) {\n        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n        this._connectedTransformNode = null;\n      }\n    }\n  };\n  /**\r\n   * Gets if the sounds is ready to be played or not.\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  Sound.prototype.isReady = function () {\n    return this._isReadyToPlay;\n  };\n\n  Sound.prototype._soundLoaded = function (audioData) {\n    var _this = this;\n\n    if (!Engine.audioEngine.audioContext) {\n      return;\n    }\n\n    Engine.audioEngine.audioContext.decodeAudioData(audioData, function (buffer) {\n      _this._audioBuffer = buffer;\n      _this._isReadyToPlay = true;\n\n      if (_this.autoplay) {\n        _this.play(0, _this._offset, _this._length);\n      }\n\n      if (_this._readyToPlayCallback) {\n        _this._readyToPlayCallback();\n      }\n    }, function (err) {\n      Logger.Error(\"Error while decoding audio data for: \" + _this.name + \" / Error: \" + err);\n    });\n  };\n  /**\r\n   * Sets the data of the sound from an audiobuffer\r\n   * @param audioBuffer The audioBuffer containing the data\r\n   */\n\n\n  Sound.prototype.setAudioBuffer = function (audioBuffer) {\n    if (Engine.audioEngine.canUseWebAudio) {\n      this._audioBuffer = audioBuffer;\n      this._isReadyToPlay = true;\n    }\n  };\n  /**\r\n   * Updates the current sounds options such as maxdistance, loop...\r\n   * @param options A JSON object containing values named as the object properties\r\n   */\n\n\n  Sound.prototype.updateOptions = function (options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    if (options) {\n      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\n      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\n      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\n      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\n      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\n      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\n      this._offset = (_j = options.offset) !== null && _j !== void 0 ? _j : undefined;\n\n      this._updateSpatialParameters();\n\n      if (this.isPlaying) {\n        if (this._streaming && this._htmlAudioElement) {\n          this._htmlAudioElement.playbackRate = this._playbackRate;\n\n          if (this._htmlAudioElement.loop !== this.loop) {\n            this._htmlAudioElement.loop = this.loop;\n          }\n        } else {\n          if (this._soundSource) {\n            this._soundSource.playbackRate.value = this._playbackRate;\n\n            if (this._soundSource.loop !== this.loop) {\n              this._soundSource.loop = this.loop;\n            }\n\n            if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n              this._soundSource.loopStart = this._offset;\n            }\n\n            if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n              this._soundSource.loopEnd = (this._offset | 0) + this._length;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  Sound.prototype._createSpatialParameters = function () {\n    if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\n      if (this._scene.headphone) {\n        this._panningModel = \"HRTF\";\n      }\n\n      this._soundPanner = Engine.audioEngine.audioContext.createPanner();\n\n      if (this._soundPanner && this._outputAudioNode) {\n        this._updateSpatialParameters();\n\n        this._soundPanner.connect(this._outputAudioNode);\n\n        this._inputAudioNode = this._soundPanner;\n      }\n    }\n  };\n\n  Sound.prototype._updateSpatialParameters = function () {\n    if (this.spatialSound && this._soundPanner) {\n      if (this.useCustomAttenuation) {\n        // Tricks to disable in a way embedded Web Audio attenuation\n        this._soundPanner.distanceModel = \"linear\";\n        this._soundPanner.maxDistance = Number.MAX_VALUE;\n        this._soundPanner.refDistance = 1;\n        this._soundPanner.rolloffFactor = 1;\n        this._soundPanner.panningModel = this._panningModel;\n      } else {\n        this._soundPanner.distanceModel = this.distanceModel;\n        this._soundPanner.maxDistance = this.maxDistance;\n        this._soundPanner.refDistance = this.refDistance;\n        this._soundPanner.rolloffFactor = this.rolloffFactor;\n        this._soundPanner.panningModel = this._panningModel;\n      }\n    }\n  };\n  /**\r\n   * Switch the panning model to HRTF:\r\n   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  Sound.prototype.switchPanningModelToHRTF = function () {\n    this._panningModel = \"HRTF\";\n\n    this._switchPanningModel();\n  };\n  /**\r\n   * Switch the panning model to Equal Power:\r\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n   */\n\n\n  Sound.prototype.switchPanningModelToEqualPower = function () {\n    this._panningModel = \"equalpower\";\n\n    this._switchPanningModel();\n  };\n\n  Sound.prototype._switchPanningModel = function () {\n    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n      this._soundPanner.panningModel = this._panningModel;\n    }\n  };\n  /**\r\n   * Connect this sound to a sound track audio node like gain...\r\n   * @param soundTrackAudioNode the sound track audio node to connect to\r\n   */\n\n\n  Sound.prototype.connectToSoundTrackAudioNode = function (soundTrackAudioNode) {\n    if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\n      if (this._isOutputConnected) {\n        this._outputAudioNode.disconnect();\n      }\n\n      this._outputAudioNode.connect(soundTrackAudioNode);\n\n      this._isOutputConnected = true;\n    }\n  };\n  /**\r\n   * Transform this sound into a directional source\r\n   * @param coneInnerAngle Size of the inner cone in degree\r\n   * @param coneOuterAngle Size of the outer cone in degree\r\n   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n   */\n\n\n  Sound.prototype.setDirectionalCone = function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    if (coneOuterAngle < coneInnerAngle) {\n      Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n      return;\n    }\n\n    this._coneInnerAngle = coneInnerAngle;\n    this._coneOuterAngle = coneOuterAngle;\n    this._coneOuterGain = coneOuterGain;\n    this._isDirectional = true;\n\n    if (this.isPlaying && this.loop) {\n      this.stop();\n      this.play(0, this._offset, this._length);\n    }\n  };\n\n  Object.defineProperty(Sound.prototype, \"directionalConeInnerAngle\", {\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\n    get: function () {\n      return this._coneInnerAngle;\n    },\n\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\n    set: function (value) {\n      if (value != this._coneInnerAngle) {\n        if (this._coneOuterAngle < value) {\n          Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneInnerAngle = value;\n\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n          this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sound.prototype, \"directionalConeOuterAngle\", {\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\n    get: function () {\n      return this._coneOuterAngle;\n    },\n\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\n    set: function (value) {\n      if (value != this._coneOuterAngle) {\n        if (value < this._coneInnerAngle) {\n          Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          return;\n        }\n\n        this._coneOuterAngle = value;\n\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\n          this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the position of the emitter if spatial sound is enabled\r\n   * @param newPosition Defines the new posisiton\r\n   */\n\n  Sound.prototype.setPosition = function (newPosition) {\n    this._position = newPosition;\n\n    if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n      this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n    }\n  };\n  /**\r\n   * Sets the local direction of the emitter if spatial sound is enabled\r\n   * @param newLocalDirection Defines the new local direction\r\n   */\n\n\n  Sound.prototype.setLocalDirectionToMesh = function (newLocalDirection) {\n    this._localDirection = newLocalDirection;\n\n    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n\n  Sound.prototype._updateDirection = function () {\n    if (!this._connectedTransformNode || !this._soundPanner) {\n      return;\n    }\n\n    var mat = this._connectedTransformNode.getWorldMatrix();\n\n    var direction = Vector3.TransformNormal(this._localDirection, mat);\n    direction.normalize();\n\n    this._soundPanner.setOrientation(direction.x, direction.y, direction.z);\n  };\n  /** @hidden */\n\n\n  Sound.prototype.updateDistanceFromListener = function () {\n    if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n      var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n\n      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n    }\n  };\n  /**\r\n   * Sets a new custom attenuation function for the sound.\r\n   * @param callback Defines the function used for the attenuation\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n   */\n\n\n  Sound.prototype.setAttenuationFunction = function (callback) {\n    this._customAttenuationFunction = callback;\n  };\n  /**\r\n   * Play the sound\r\n   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n   * @param offset (optional) Start the sound at a specific time in seconds\r\n   * @param length (optional) Sound duration (in seconds)\r\n   */\n\n\n  Sound.prototype.play = function (time, offset, length) {\n    var _this = this;\n\n    if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine.audioContext) {\n      try {\n        if (this._startOffset < 0) {\n          time = -this._startOffset;\n          this._startOffset = 0;\n        }\n\n        var startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n\n        if (!this._soundSource || !this._streamingSource) {\n          if (this.spatialSound && this._soundPanner) {\n            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n              this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n            }\n\n            if (this._isDirectional) {\n              this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n              this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n              this._soundPanner.coneOuterGain = this._coneOuterGain;\n\n              if (this._connectedTransformNode) {\n                this._updateDirection();\n              } else {\n                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n              }\n            }\n          }\n        }\n\n        if (this._streaming) {\n          if (!this._streamingSource) {\n            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n\n            this._htmlAudioElement.onended = function () {\n              _this._onended();\n            };\n\n            this._htmlAudioElement.playbackRate = this._playbackRate;\n          }\n\n          this._streamingSource.disconnect();\n\n          if (this._inputAudioNode) {\n            this._streamingSource.connect(this._inputAudioNode);\n          }\n\n          if (this._htmlAudioElement) {\n            // required to manage properly the new suspended default state of Chrome\n            // When the option 'streaming: true' is used, we need first to wait for\n            // the audio engine to be unlocked by a user gesture before trying to play\n            // an HTML Audio elememt\n            var tryToPlay = function () {\n              if (Engine.audioEngine.unlocked) {\n                var playPromise = _this._htmlAudioElement.play(); // In browsers that don’t yet support this functionality,\n                // playPromise won’t be defined.\n\n\n                if (playPromise !== undefined) {\n                  playPromise.catch(function (error) {\n                    // Automatic playback failed.\n                    // Waiting for the audio engine to be unlocked by user click on unmute\n                    Engine.audioEngine.lock();\n\n                    if (_this.loop || _this.autoplay) {\n                      Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                        tryToPlay();\n                      });\n                    }\n                  });\n                }\n              } else {\n                if (_this.loop || _this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay();\n                  });\n                }\n              }\n            };\n\n            tryToPlay();\n          }\n        } else {\n          var tryToPlay = function () {\n            if (Engine.audioEngine.audioContext) {\n              length = length || _this._length;\n              offset = offset || _this._offset;\n\n              if (_this._soundSource) {\n                var oldSource_1 = _this._soundSource;\n\n                oldSource_1.onended = function () {\n                  oldSource_1.disconnect();\n                };\n              }\n\n              _this._soundSource = Engine.audioEngine.audioContext.createBufferSource();\n\n              if (_this._soundSource && _this._inputAudioNode) {\n                _this._soundSource.buffer = _this._audioBuffer;\n\n                _this._soundSource.connect(_this._inputAudioNode);\n\n                _this._soundSource.loop = _this.loop;\n\n                if (offset !== undefined) {\n                  _this._soundSource.loopStart = offset;\n                }\n\n                if (length !== undefined) {\n                  _this._soundSource.loopEnd = (offset | 0) + length;\n                }\n\n                _this._soundSource.playbackRate.value = _this._playbackRate;\n\n                _this._soundSource.onended = function () {\n                  _this._onended();\n                };\n\n                startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n                var actualOffset = _this.isPaused ? _this._startOffset % _this._soundSource.buffer.duration : offset ? offset : 0;\n\n                _this._soundSource.start(startTime, actualOffset, _this.loop ? undefined : length);\n              }\n            }\n          };\n\n          if (Engine.audioEngine.audioContext.state === \"suspended\") {\n            // Wait a bit for FF as context seems late to be ready.\n            setTimeout(function () {\n              if (Engine.audioEngine.audioContext.state === \"suspended\") {\n                // Automatic playback failed.\n                // Waiting for the audio engine to be unlocked by user click on unmute\n                Engine.audioEngine.lock();\n\n                if (_this.loop || _this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    tryToPlay();\n                  });\n                }\n              } else {\n                tryToPlay();\n              }\n            }, 500);\n          } else {\n            tryToPlay();\n          }\n        }\n\n        this._startTime = startTime;\n        this.isPlaying = true;\n        this.isPaused = false;\n      } catch (ex) {\n        Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n      }\n    }\n  };\n\n  Sound.prototype._onended = function () {\n    this.isPlaying = false;\n    this._startOffset = 0;\n\n    if (this.onended) {\n      this.onended();\n    }\n\n    this.onEndedObservable.notifyObservers(this);\n  };\n  /**\r\n   * Stop the sound\r\n   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n   */\n\n\n  Sound.prototype.stop = function (time) {\n    var _this = this;\n\n    if (this.isPlaying) {\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause(); // Test needed for Firefox or it will generate an Invalid State Error\n\n\n          if (this._htmlAudioElement.currentTime > 0) {\n            this._htmlAudioElement.currentTime = 0;\n          }\n        } else {\n          this._streamingSource.disconnect();\n        }\n\n        this.isPlaying = false;\n      } else if (Engine.audioEngine.audioContext && this._soundSource) {\n        var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\n\n        this._soundSource.stop(stopTime);\n\n        this._soundSource.onended = function () {\n          _this.isPlaying = false;\n        };\n\n        if (!this.isPaused) {\n          this._startOffset = 0;\n        }\n      }\n    }\n  };\n  /**\r\n   * Put the sound in pause\r\n   */\n\n\n  Sound.prototype.pause = function () {\n    if (this.isPlaying) {\n      this.isPaused = true;\n\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n        } else {\n          this._streamingSource.disconnect();\n        }\n      } else if (Engine.audioEngine.audioContext) {\n        this.stop(0);\n        this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n    }\n  };\n  /**\r\n   * Sets a dedicated volume for this sounds\r\n   * @param newVolume Define the new volume of the sound\r\n   * @param time Define time for gradual change to new volume\r\n   */\n\n\n  Sound.prototype.setVolume = function (newVolume, time) {\n    if (Engine.audioEngine.canUseWebAudio && this._soundGain) {\n      if (time && Engine.audioEngine.audioContext) {\n        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\n\n        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\n      } else {\n        this._soundGain.gain.value = newVolume;\n      }\n    }\n\n    this._volume = newVolume;\n  };\n  /**\r\n   * Set the sound play back rate\r\n   * @param newPlaybackRate Define the playback rate the sound should be played at\r\n   */\n\n\n  Sound.prototype.setPlaybackRate = function (newPlaybackRate) {\n    this._playbackRate = newPlaybackRate;\n\n    if (this.isPlaying) {\n      if (this._streaming && this._htmlAudioElement) {\n        this._htmlAudioElement.playbackRate = this._playbackRate;\n      } else if (this._soundSource) {\n        this._soundSource.playbackRate.value = this._playbackRate;\n      }\n    }\n  };\n  /**\r\n   * Gets the volume of the sound.\r\n   * @returns the volume of the sound\r\n   */\n\n\n  Sound.prototype.getVolume = function () {\n    return this._volume;\n  };\n  /**\r\n   * Attach the sound to a dedicated mesh\r\n   * @param transformNode The transform node to connect the sound with\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n   */\n\n\n  Sound.prototype.attachToMesh = function (transformNode) {\n    var _this = this;\n\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n    }\n\n    this._connectedTransformNode = transformNode;\n\n    if (!this.spatialSound) {\n      this.spatialSound = true;\n\n      this._createSpatialParameters();\n\n      if (this.isPlaying && this.loop) {\n        this.stop();\n        this.play(0, this._offset, this._length);\n      }\n    }\n\n    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n\n    this._registerFunc = function (transformNode) {\n      return _this._onRegisterAfterWorldMatrixUpdate(transformNode);\n    };\n\n    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n  };\n  /**\r\n   * Detach the sound from the previously attached mesh\r\n   * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n   */\n\n\n  Sound.prototype.detachFromMesh = function () {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n\n      this._registerFunc = null;\n      this._connectedTransformNode = null;\n    }\n  };\n\n  Sound.prototype._onRegisterAfterWorldMatrixUpdate = function (node) {\n    if (this._positionInEmitterSpace) {\n      node.worldMatrixFromCache.invertToRef(TmpVectors.Matrix[0]);\n      this.setPosition(TmpVectors.Matrix[0].getTranslation());\n    } else {\n      if (!node.getBoundingInfo) {\n        this.setPosition(node.absolutePosition);\n      } else {\n        var mesh = node;\n        var boundingInfo = mesh.getBoundingInfo();\n        this.setPosition(boundingInfo.boundingSphere.centerWorld);\n      }\n    }\n\n    if (Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {\n      this._updateDirection();\n    }\n  };\n  /**\r\n   * Clone the current sound in the scene.\r\n   * @returns the new sound clone\r\n   */\n\n\n  Sound.prototype.clone = function () {\n    var _this = this;\n\n    if (!this._streaming) {\n      var setBufferAndRun = function () {\n        if (_this._isReadyToPlay) {\n          clonedSound._audioBuffer = _this.getAudioBuffer();\n          clonedSound._isReadyToPlay = true;\n\n          if (clonedSound.autoplay) {\n            clonedSound.play(0, _this._offset, _this._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun, 300);\n        }\n      };\n\n      var currentOptions = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this.spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      };\n      var clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n\n      if (this.useCustomAttenuation) {\n        clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n      }\n\n      clonedSound.setPosition(this._position);\n      clonedSound.setPlaybackRate(this._playbackRate);\n      setBufferAndRun();\n      return clonedSound;\n    } // Can't clone a streaming sound\n    else {\n        return null;\n      }\n  };\n  /**\r\n   * Gets the current underlying audio buffer containing the data\r\n   * @returns the audio buffer\r\n   */\n\n\n  Sound.prototype.getAudioBuffer = function () {\n    return this._audioBuffer;\n  };\n  /**\r\n   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n   * @returns the source node\r\n   */\n\n\n  Sound.prototype.getSoundSource = function () {\n    return this._soundSource;\n  };\n  /**\r\n   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n   * @returns the gain node\r\n   */\n\n\n  Sound.prototype.getSoundGain = function () {\n    return this._soundGain;\n  };\n  /**\r\n   * Serializes the Sound in a JSON representation\r\n   * @returns the JSON representation of the sound\r\n   */\n\n\n  Sound.prototype.serialize = function () {\n    var serializationObject = {\n      name: this.name,\n      url: this.name,\n      autoplay: this.autoplay,\n      loop: this.loop,\n      volume: this._volume,\n      spatialSound: this.spatialSound,\n      maxDistance: this.maxDistance,\n      rolloffFactor: this.rolloffFactor,\n      refDistance: this.refDistance,\n      distanceModel: this.distanceModel,\n      playbackRate: this._playbackRate,\n      panningModel: this._panningModel,\n      soundTrackId: this.soundTrackId,\n      metadata: this.metadata\n    };\n\n    if (this.spatialSound) {\n      if (this._connectedTransformNode) {\n        serializationObject.connectedMeshId = this._connectedTransformNode.id;\n      }\n\n      serializationObject.position = this._position.asArray();\n      serializationObject.refDistance = this.refDistance;\n      serializationObject.distanceModel = this.distanceModel;\n      serializationObject.isDirectional = this._isDirectional;\n      serializationObject.localDirectionToMesh = this._localDirection.asArray();\n      serializationObject.coneInnerAngle = this._coneInnerAngle;\n      serializationObject.coneOuterAngle = this._coneOuterAngle;\n      serializationObject.coneOuterGain = this._coneOuterGain;\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Parse a JSON representation of a sound to innstantiate in a given scene\r\n   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n   * @param scene Define the scene the new parsed sound should be created in\r\n   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n   * @param sourceSound Define a cound place holder if do not need to instantiate a new one\r\n   * @returns the newly parsed sound\r\n   */\n\n\n  Sound.Parse = function (parsedSound, scene, rootUrl, sourceSound) {\n    var soundName = parsedSound.name;\n    var soundUrl;\n\n    if (parsedSound.url) {\n      soundUrl = rootUrl + parsedSound.url;\n    } else {\n      soundUrl = rootUrl + soundName;\n    }\n\n    var options = {\n      autoplay: parsedSound.autoplay,\n      loop: parsedSound.loop,\n      volume: parsedSound.volume,\n      spatialSound: parsedSound.spatialSound,\n      maxDistance: parsedSound.maxDistance,\n      rolloffFactor: parsedSound.rolloffFactor,\n      refDistance: parsedSound.refDistance,\n      distanceModel: parsedSound.distanceModel,\n      playbackRate: parsedSound.playbackRate\n    };\n    var newSound;\n\n    if (!sourceSound) {\n      newSound = new Sound(soundName, soundUrl, scene, function () {\n        scene._removePendingData(newSound);\n      }, options);\n\n      scene._addPendingData(newSound);\n    } else {\n      var setBufferAndRun = function () {\n        if (sourceSound._isReadyToPlay) {\n          newSound._audioBuffer = sourceSound.getAudioBuffer();\n          newSound._isReadyToPlay = true;\n\n          if (newSound.autoplay) {\n            newSound.play(0, newSound._offset, newSound._length);\n          }\n        } else {\n          window.setTimeout(setBufferAndRun, 300);\n        }\n      };\n\n      newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n      setBufferAndRun();\n    }\n\n    if (parsedSound.position) {\n      var soundPosition = Vector3.FromArray(parsedSound.position);\n      newSound.setPosition(soundPosition);\n    }\n\n    if (parsedSound.isDirectional) {\n      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n\n      if (parsedSound.localDirectionToMesh) {\n        var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n        newSound.setLocalDirectionToMesh(localDirectionToMesh);\n      }\n    }\n\n    if (parsedSound.connectedMeshId) {\n      var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);\n\n      if (connectedMesh) {\n        newSound.attachToMesh(connectedMesh);\n      }\n    }\n\n    if (parsedSound.metadata) {\n      newSound.metadata = parsedSound.metadata;\n    }\n\n    return newSound;\n  };\n  /** @hidden */\n\n\n  Sound._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"AudioSceneComponent\");\n  };\n\n  return Sound;\n}();\n\nexport { Sound };","map":{"version":3,"sources":["../../../sourceES6/core/Audio/sound.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _DevTools } from \"../Misc/devTools\";\r\nimport { ISoundOptions } from './Interfaces/ISoundOptions';\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public loop: boolean = false;\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public spatialSound: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @hidden\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        let currentTime: number = this._startOffset;\r\n        if (this.isPlaying && Engine.audioEngine.audioContext) {\r\n            currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n        }\r\n        return currentTime;\r\n    }\r\n\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _startOffset: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    /** @hidden */\r\n    public _positionInEmitterSpace: boolean = false;\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: AudioNode;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: HTMLAudioElement;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene: Scene, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this.loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this.spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._soundGain = Engine.audioEngine.audioContext.createGain();\r\n            this._soundGain!.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this.spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            var validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    var urls: string[] = [];\r\n                    var codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (var i = 0; i < urls.length; i++) {\r\n                                var url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound using XHR2\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\r\n                                            this._isReadyToPlay = true;\r\n                                            if (this.autoplay) {\r\n                                                this.play(0, this._offset, this._length);\r\n                                            }\r\n                                            if (this._readyToPlayCallback) {\r\n                                                this._readyToPlayCallback();\r\n                                            }\r\n                                        });\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                window.setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (!Engine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                Engine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                window.setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (Engine.audioEngine.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!Engine.audioEngine.audioContext) {\r\n            return;\r\n        }\r\n        Engine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBuffer = buffer;\r\n                this._isReadyToPlay = true;\r\n                if (this.autoplay) {\r\n                    this.play(0, this._offset, this._length);\r\n                }\r\n                if (this._readyToPlayCallback) {\r\n                    this._readyToPlayCallback();\r\n                }\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (Engine.audioEngine.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this._offset = options.offset ?? undefined;\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (Engine.audioEngine.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = Engine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (this.spatialSound && this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (Engine.audioEngine.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new posisiton\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        this._position = newPosition;\r\n\r\n        if (Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n            this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        var mat = this._connectedTransformNode.getWorldMatrix();\r\n        var direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.setOrientation(direction.x, direction.y, direction.z);\r\n    }\r\n\r\n    /** @hidden */\r\n    public updateDistanceFromListener() {\r\n        if (Engine.audioEngine.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            var distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine.audioContext) {\r\n            try {\r\n                if (this._startOffset < 0) {\r\n                    time = -this._startOffset;\r\n                    this._startOffset = 0;\r\n                }\r\n                var startTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this.spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource) {\r\n                        this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    this._streamingSource.disconnect();\r\n                    if (this._inputAudioNode) {\r\n                        this._streamingSource.connect(this._inputAudioNode);\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio elememt\r\n                        var tryToPlay = () => {\r\n                            if (Engine.audioEngine.unlocked) {\r\n                                var playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    playPromise.catch((error) => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        Engine.audioEngine.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    var tryToPlay = () => {\r\n                        if (Engine.audioEngine.audioContext) {\r\n                            length = length || this._length;\r\n                            offset = offset || this._offset;\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = Engine.audioEngine.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length!;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? Engine.audioEngine.audioContext!.currentTime + time : Engine.audioEngine.audioContext!.currentTime;\r\n                                const actualOffset = this.isPaused ? this._startOffset % this._soundSource!.buffer!.duration : offset ? offset : 0;\r\n                                this._soundSource!.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (Engine.audioEngine.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        setTimeout(() => {\r\n                            if (Engine.audioEngine.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                Engine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        this._startOffset = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (Engine.audioEngine.audioContext && this._soundSource) {\r\n                var stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : Engine.audioEngine.audioContext.currentTime;\r\n                this._soundSource.stop(stopTime);\r\n                this._soundSource.onended = () => {\r\n                    this.isPlaying = false;\r\n                };\r\n                if (!this.isPaused) {\r\n                    this._startOffset = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n            } else if (Engine.audioEngine.audioContext) {\r\n                this.stop(0);\r\n                this._startOffset += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (Engine.audioEngine.canUseWebAudio && this._soundGain) {\r\n            if (time && Engine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this.spatialSound) {\r\n            this.spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/how_to/playing_sounds_and_music#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (this._positionInEmitterSpace) {\r\n            node.worldMatrixFromCache.invertToRef(TmpVectors.Matrix[0]);\r\n            this.setPosition(TmpVectors.Matrix[0].getTranslation());\r\n        } else {\r\n            if (!(<any>node).getBoundingInfo) {\r\n                this.setPosition(node.absolutePosition);\r\n            } else {\r\n                let mesh = node as AbstractMesh;\r\n                let boundingInfo = mesh.getBoundingInfo();\r\n                this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n            }\r\n        }\r\n        if (Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            var setBufferAndRun = () => {\r\n                if (this._isReadyToPlay) {\r\n                    clonedSound._audioBuffer = this.getAudioBuffer();\r\n                    clonedSound._isReadyToPlay = true;\r\n                    if (clonedSound.autoplay) {\r\n                        clonedSound.play(0, this._offset, this._length);\r\n                    }\r\n                } else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            var currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this.spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            var clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {\r\n            name: this.name,\r\n            url: this.name,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this.spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to innstantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a cound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        var soundName = parsedSound.name;\r\n        var soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        var options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        var newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene._removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene._addPendingData(newSound);\r\n        } else {\r\n            var setBufferAndRun = () => {\r\n                if (sourceSound._isReadyToPlay) {\r\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                    newSound._isReadyToPlay = true;\r\n                    if (newSound.autoplay) {\r\n                        newSound.play(0, newSound._offset, newSound._length);\r\n                    }\r\n                } else {\r\n                    window.setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            var soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                var localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}