{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { _TypeStore } from '../../Misc/typeStore';\nimport \"../../Engines/Extensions/engine.cubeTexture\";\nimport { StringTools } from '../../Misc/stringTools';\nimport { Observable } from '../../Misc/observable';\n/**\r\n * Class for creating a cube texture\r\n */\n\nvar CubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(CubeTexture, _super);\n  /**\r\n   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n   * as prefiltered data.\r\n   * @param rootUrl defines the url of the texture or the root name of the six images\r\n   * @param null defines the scene or engine the texture is attached to\r\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n   * @param noMipmap defines if mipmaps should be created or not\r\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n   * @param onLoad defines a callback triggered at the end of the file load if no errors occured\r\n   * @param onError defines a callback triggered in case of error during load\r\n   * @param format defines the internal format to use for the texture once loaded\r\n   * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n   * @param loaderOptions options to be passed to the loader\r\n   * @return the cube texture\r\n   */\n\n\n  function CubeTexture(rootUrl, sceneOrEngine, extensions, noMipmap, files, onLoad, onError, format, prefiltered, forcedExtension, createPolynomials, lodScale, lodOffset, loaderOptions) {\n    if (extensions === void 0) {\n      extensions = null;\n    }\n\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (files === void 0) {\n      files = null;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = false;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    var _a;\n\n    var _this = _super.call(this, sceneOrEngine) || this;\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\n\n\n    _this.onLoadObservable = new Observable();\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\n\n    _this.boundingBoxPosition = Vector3.Zero();\n    _this._rotationY = 0;\n    _this._files = null;\n    _this._forcedExtension = null;\n    _this._extensions = null;\n    _this.name = rootUrl;\n    _this.url = rootUrl;\n    _this._noMipmap = noMipmap;\n    _this.hasAlpha = false;\n    _this._format = format;\n    _this.isCube = true;\n    _this._textureMatrix = Matrix.Identity();\n    _this._createPolynomials = createPolynomials;\n    _this.coordinatesMode = Texture.CUBIC_MODE;\n    _this._extensions = extensions;\n    _this._files = files;\n    _this._forcedExtension = forcedExtension;\n    _this._loaderOptions = loaderOptions;\n\n    if (!rootUrl && !files) {\n      return _this;\n    }\n\n    var lastDot = rootUrl.lastIndexOf(\".\");\n    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n    var isDDS = extension === \".dds\";\n    var isEnv = extension === \".env\";\n\n    if (isEnv) {\n      _this.gammaSpace = false;\n      _this._prefiltered = false;\n      _this.anisotropicFilteringLevel = 1;\n    } else {\n      _this._prefiltered = prefiltered;\n\n      if (prefiltered) {\n        _this.gammaSpace = false;\n        _this.anisotropicFilteringLevel = 1;\n      }\n    }\n\n    _this._texture = _this._getFromCache(rootUrl, noMipmap);\n\n    if (!files) {\n      if (!isEnv && !isDDS && !extensions) {\n        extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n      }\n\n      files = [];\n\n      if (extensions) {\n        for (var index = 0; index < extensions.length; index++) {\n          files.push(rootUrl + extensions[index]);\n        }\n      }\n    }\n\n    _this._files = files;\n\n    var onLoadProcessing = function () {\n      _this.onLoadObservable.notifyObservers(_this);\n\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    if (!_this._texture) {\n      var scene = _this.getScene();\n\n      if (!(scene === null || scene === void 0 ? void 0 : scene.useDelayedTextureLoading)) {\n        if (prefiltered) {\n          _this._texture = _this._getEngine().createPrefilteredCubeTexture(rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, _this._createPolynomials);\n        } else {\n          _this._texture = _this._getEngine().createCubeTexture(rootUrl, scene, files, noMipmap, onLoad, onError, _this._format, forcedExtension, false, lodScale, lodOffset, null, loaderOptions);\n        }\n\n        (_a = _this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function () {\n          return _this.onLoadObservable.notifyObservers(_this);\n        });\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoadProcessing();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(function () {\n          return onLoadProcessing();\n        });\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(CubeTexture.prototype, \"boundingBoxSize\", {\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\n    get: function () {\n      return this._boundingBoxSize;\n    },\n\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\n    set: function (value) {\n      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n        return;\n      }\n\n      this._boundingBoxSize = value;\n      var scene = this.getScene();\n\n      if (scene) {\n        scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"rotationY\", {\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\n    get: function () {\n      return this._rotationY;\n    },\n\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\n    set: function (value) {\n      this._rotationY = value;\n      this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CubeTexture.prototype, \"noMipmap\", {\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\n    get: function () {\n      return this._noMipmap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a cube texture from an array of image urls\r\n   * @param files defines an array of image urls\r\n   * @param scene defines the hosting scene\r\n   * @param noMipmap specifies if mip maps are not used\r\n   * @returns a cube texture\r\n   */\n\n  CubeTexture.CreateFromImages = function (files, scene, noMipmap) {\n    var rootUrlKey = \"\";\n    files.forEach(function (url) {\n      return rootUrlKey += url;\n    });\n    return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n  };\n  /**\r\n   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n   * @param url defines the url of the prefiltered texture\r\n   * @param scene defines the scene the texture is attached to\r\n   * @param forcedExtension defines the extension of the file if different from the url\r\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n   * @return the prefiltered texture\r\n   */\n\n\n  CubeTexture.CreateFromPrefilteredData = function (url, scene, forcedExtension, createPolynomials) {\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    if (createPolynomials === void 0) {\n      createPolynomials = true;\n    }\n\n    var oldValue = scene.useDelayedTextureLoading;\n    scene.useDelayedTextureLoading = false;\n    var result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n    scene.useDelayedTextureLoading = oldValue;\n    return result;\n  };\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"CubeTexture\"\r\n   */\n\n\n  CubeTexture.prototype.getClassName = function () {\n    return \"CubeTexture\";\n  };\n  /**\r\n   * Update the url (and optional buffer) of this texture if url was null during construction.\r\n   * @param url the url of the texture\r\n   * @param forcedExtension defines the extension to use\r\n   * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n   * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n   */\n\n\n  CubeTexture.prototype.updateURL = function (url, forcedExtension, onLoad, prefiltered) {\n    var _a;\n\n    if (prefiltered === void 0) {\n      prefiltered = false;\n    }\n\n    if (this.url) {\n      this.releaseInternalTexture();\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);\n    }\n\n    if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\n      this.name = url;\n    }\n\n    this.url = url;\n    this.delayLoadState = 4;\n    this._prefiltered = prefiltered;\n\n    if (this._prefiltered) {\n      this.gammaSpace = false;\n      this.anisotropicFilteringLevel = 1;\n    }\n\n    this._forcedExtension = forcedExtension || null;\n\n    if (onLoad) {\n      this._delayedOnLoad = onLoad;\n    }\n\n    this.delayLoad(forcedExtension);\n  };\n  /**\r\n   * Delays loading of the cube texture\r\n   * @param forcedExtension defines the extension to use\r\n   */\n\n\n  CubeTexture.prototype.delayLoad = function (forcedExtension) {\n    var _this = this;\n\n    var _a;\n\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, this._noMipmap);\n\n    if (!this._texture) {\n      var scene = this.getScene();\n\n      if (this._prefiltered) {\n        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, 0.8, 0, this._delayedOnLoad, undefined, this._format, forcedExtension, this._createPolynomials);\n      } else {\n        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, this._delayedOnLoad, null, this._format, forcedExtension, false, 0, 0, null, this._loaderOptions);\n      }\n\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(function () {\n        return _this.onLoadObservable.notifyObservers(_this);\n      });\n    }\n  };\n  /**\r\n   * Returns the reflection texture matrix\r\n   * @returns the reflection texture matrix\r\n   */\n\n\n  CubeTexture.prototype.getReflectionTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\r\n   * Sets the reflection texture matrix\r\n   * @param value Reflection texture matrix\r\n   */\n\n\n  CubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n    var _this = this;\n\n    var _a;\n\n    if (value.updateFlag === this._textureMatrix.updateFlag) {\n      return;\n    }\n\n    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, function (mat) {\n        return mat.getActiveTextures().indexOf(_this) !== -1;\n      });\n    }\n\n    this._textureMatrix = value;\n  };\n  /**\r\n   * Parses text to create a cube texture\r\n   * @param parsedTexture define the serialized text to read from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root url of the cube texture\r\n   * @returns a cube texture\r\n   */\n\n\n  CubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n    var texture = SerializationHelper.Parse(function () {\n      var prefiltered = false;\n\n      if (parsedTexture.prefiltered) {\n        prefiltered = parsedTexture.prefiltered;\n      }\n\n      return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n    }, parsedTexture, scene); // Local Cubemaps\n\n    if (parsedTexture.boundingBoxPosition) {\n      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n    }\n\n    if (parsedTexture.boundingBoxSize) {\n      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n    } // Animations\n\n\n    if (parsedTexture.animations) {\n      for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n        var parsedAnimation = parsedTexture.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          texture.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n\n    return texture;\n  };\n  /**\r\n   * Makes a clone, or deep copy, of the cube texture\r\n   * @returns a new cube texture\r\n   */\n\n\n  CubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    var uniqueId = 0;\n    var newCubeTexture = SerializationHelper.Clone(function () {\n      var cubeTexture = new CubeTexture(_this.url, _this.getScene() || _this._getEngine(), _this._extensions, _this._noMipmap, _this._files);\n      uniqueId = cubeTexture.uniqueId;\n      return cubeTexture;\n    }, this);\n    newCubeTexture.uniqueId = uniqueId;\n    return newCubeTexture;\n  };\n\n  __decorate([serialize()], CubeTexture.prototype, \"url\", void 0);\n\n  __decorate([serialize(\"rotationY\")], CubeTexture.prototype, \"rotationY\", null);\n\n  __decorate([serialize(\"files\")], CubeTexture.prototype, \"_files\", void 0);\n\n  __decorate([serialize(\"forcedExtension\")], CubeTexture.prototype, \"_forcedExtension\", void 0);\n\n  __decorate([serialize(\"extensions\")], CubeTexture.prototype, \"_extensions\", void 0);\n\n  __decorate([serializeAsMatrix(\"textureMatrix\")], CubeTexture.prototype, \"_textureMatrix\", void 0);\n\n  return CubeTexture;\n}(BaseTexture);\n\nexport { CubeTexture };\nTexture._CubeTextureParser = CubeTexture.Parse; // Some exporters relies on Tools.Instantiate\n\n_TypeStore.RegisteredTypes[\"BABYLON.CubeTexture\"] = CubeTexture;","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/cubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { ThinEngine } from '../../Engines/thinEngine';\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { StringTools } from '../../Misc/stringTools';\r\nimport { Observable } from '../../Misc/observable';\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        let scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(1);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/how_to/reflect#using-local-cubemap-mode\r\n     */\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    @serialize(\"files\")\r\n    private _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => rootUrlKey += url);\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @return the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param null defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occured\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @return the cube texture\r\n     */\r\n    constructor(rootUrl: string, sceneOrEngine: Scene | ThinEngine, extensions: Nullable<string[]> = null, noMipmap: boolean = false, files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null, format: number = 5, prefiltered = false,\r\n        forcedExtension: any = null, createPolynomials: boolean = false,\r\n        lodScale: number = 0.8, lodOffset: number = 0, loaderOptions?: any) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        const lastDot = rootUrl.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : (lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\");\r\n        const isDDS = (extension === \".dds\");\r\n        const isEnv = (extension === \".env\");\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        }\r\n        else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        this._texture = this._getFromCache(rootUrl, noMipmap);\r\n\r\n        if (!files) {\r\n            if (!isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            files = [];\r\n\r\n            if (extensions) {\r\n\r\n                for (var index = 0; index < extensions.length; index++) {\r\n                    files.push(rootUrl + extensions[index]);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._files = files;\r\n\r\n        let onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (!scene?.useDelayedTextureLoading) {\r\n                if (prefiltered) {\r\n                    this._texture = this._getEngine()!.createPrefilteredCubeTexture(rootUrl, scene, lodScale, lodOffset, onLoad, onError, format, forcedExtension, this._createPolynomials);\r\n                }\r\n                else {\r\n                    this._texture = this._getEngine()!.createCubeTexture(rootUrl, scene, files, noMipmap, onLoad, onError, this._format, forcedExtension, false, lodScale, lodOffset, null, loaderOptions);\r\n                }\r\n                this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n\r\n            } else {\r\n                this.delayLoadState = 4;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     */\r\n    public updateURL(url: string, forcedExtension?: string, onLoad?: () => void, prefiltered: boolean = false): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()?.markAllMaterialsAsDirty(1);\r\n        }\r\n\r\n        if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this.delayLoadState = 4;\r\n        this._prefiltered = prefiltered;\r\n        if (this._prefiltered) {\r\n            this.gammaSpace = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        }\r\n        this._forcedExtension = forcedExtension || null;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n\r\n        this.delayLoad(forcedExtension);\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== 4) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = 1;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap);\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(this.url, scene, 0.8, 0, this._delayedOnLoad, undefined, this._format, forcedExtension, this._createPolynomials);\r\n            }\r\n            else {\r\n                this._texture = this._getEngine()!.createCubeTexture(this.url, scene, this._files, this._noMipmap, this._delayedOnLoad, null, this._format, forcedExtension, false, 0, 0, null, this._loaderOptions);\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        var texture = SerializationHelper.Parse(() => {\r\n            var prefiltered: boolean = false;\r\n            if (parsedTexture.prefiltered) {\r\n                prefiltered = parsedTexture.prefiltered;\r\n            }\r\n            return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\r\n        }, parsedTexture, scene);\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                var parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        let newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\n_TypeStore.RegisteredTypes[\"BABYLON.CubeTexture\"] = CubeTexture;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}