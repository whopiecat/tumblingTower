{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { AbstractScene } from \"../abstractScene\";\n\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n  if (!this.reflectionProbes) {\n    return -1;\n  }\n\n  var index = this.reflectionProbes.indexOf(toRemove);\n\n  if (index !== -1) {\n    this.reflectionProbes.splice(index, 1);\n  }\n\n  return index;\n};\n\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n  if (!this.reflectionProbes) {\n    this.reflectionProbes = [];\n  }\n\n  this.reflectionProbes.push(newReflectionProbe);\n};\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n */\n\n\nvar ReflectionProbe =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new reflection probe\r\n   * @param name defines the name of the probe\r\n   * @param size defines the texture resolution (for each face)\r\n   * @param scene defines the hosting scene\r\n   * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n   * @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)\r\n   */\n  function ReflectionProbe(\n  /** defines the name of the probe */\n  name, size, scene, generateMipMaps, useFloat) {\n    var _this = this;\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (useFloat === void 0) {\n      useFloat = false;\n    }\n\n    this.name = name;\n    this._viewMatrix = Matrix.Identity();\n    this._target = Vector3.Zero();\n    this._add = Vector3.Zero();\n    this._invertYAxis = false;\n    /** Gets or sets probe position (center of the cube map) */\n\n    this.position = Vector3.Zero();\n    this._scene = scene; // Create the scene field if not exist.\n\n    if (!this._scene.reflectionProbes) {\n      this._scene.reflectionProbes = new Array();\n    }\n\n    this._scene.reflectionProbes.push(this);\n\n    var textureType = 0;\n\n    if (useFloat) {\n      var caps = this._scene.getEngine().getCaps();\n\n      if (caps.textureHalfFloatRender) {\n        textureType = 2;\n      } else if (caps.textureFloatRender) {\n        textureType = 1;\n      }\n    }\n\n    this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n\n    this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {\n      switch (faceIndex) {\n        case 0:\n          _this._add.copyFromFloats(1, 0, 0);\n\n          break;\n\n        case 1:\n          _this._add.copyFromFloats(-1, 0, 0);\n\n          break;\n\n        case 2:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);\n\n          break;\n\n        case 3:\n          _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);\n\n          break;\n\n        case 4:\n          _this._add.copyFromFloats(0, 0, 1);\n\n          break;\n\n        case 5:\n          _this._add.copyFromFloats(0, 0, -1);\n\n          break;\n      }\n\n      if (_this._attachedMesh) {\n        _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());\n      }\n\n      _this.position.addToRef(_this._add, _this._target);\n\n      Matrix.LookAtLHToRef(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);\n\n      if (scene.activeCamera) {\n        _this._projectionMatrix = Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);\n        scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);\n      }\n\n      scene._forcedViewPosition = _this.position;\n    });\n\n    this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n      scene._forcedViewPosition = null;\n      scene.updateTransformMatrix(true);\n    });\n  }\n\n  Object.defineProperty(ReflectionProbe.prototype, \"samples\", {\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n    get: function () {\n      return this._renderTargetTexture.samples;\n    },\n    set: function (value) {\n      this._renderTargetTexture.samples = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"refreshRate\", {\n    /** Gets or sets the refresh rate to use (on every frame by default) */\n    get: function () {\n      return this._renderTargetTexture.refreshRate;\n    },\n    set: function (value) {\n      this._renderTargetTexture.refreshRate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the hosting scene\r\n   * @returns a Scene\r\n   */\n\n  ReflectionProbe.prototype.getScene = function () {\n    return this._scene;\n  };\n\n  Object.defineProperty(ReflectionProbe.prototype, \"cubeTexture\", {\n    /** Gets the internal CubeTexture used to render to */\n    get: function () {\n      return this._renderTargetTexture;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ReflectionProbe.prototype, \"renderList\", {\n    /** Gets the list of meshes to render */\n    get: function () {\n      return this._renderTargetTexture.renderList;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n   * @param mesh defines the mesh to attach to\r\n   */\n\n  ReflectionProbe.prototype.attachToMesh = function (mesh) {\n    this._attachedMesh = mesh;\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   */\n\n\n  ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n  };\n  /**\r\n   * Clean all associated resources\r\n   */\n\n\n  ReflectionProbe.prototype.dispose = function () {\n    var index = this._scene.reflectionProbes.indexOf(this);\n\n    if (index !== -1) {\n      // Remove from the scene if found\n      this._scene.reflectionProbes.splice(index, 1);\n    }\n\n    if (this._renderTargetTexture) {\n      this._renderTargetTexture.dispose();\n\n      this._renderTargetTexture = null;\n    }\n  };\n  /**\r\n   * Converts the reflection probe information to a readable string for debug purpose.\r\n   * @param fullDetails Supports for multiple levels of logging within scene loading\r\n   * @returns the human readable reflection probe info\r\n   */\n\n\n  ReflectionProbe.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n\n    if (fullDetails) {\n      ret += \", position: \" + this.position.toString();\n\n      if (this._attachedMesh) {\n        ret += \", attached mesh: \" + this._attachedMesh.name;\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Get the class name of the relfection probe.\r\n   * @returns \"ReflectionProbe\"\r\n   */\n\n\n  ReflectionProbe.prototype.getClassName = function () {\n    return \"ReflectionProbe\";\n  };\n  /**\r\n   * Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.\r\n   * @returns The JSON representation of the texture\r\n   */\n\n\n  ReflectionProbe.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n    serializationObject.isReflectionProbe = true;\n    return serializationObject;\n  };\n  /**\r\n   * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n   * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n   * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n   * @returns The parsed reflection probe if successful\r\n   */\n\n\n  ReflectionProbe.Parse = function (parsedReflectionProbe, scene, rootUrl) {\n    var reflectionProbe = null;\n\n    if (scene.reflectionProbes) {\n      for (var index = 0; index < scene.reflectionProbes.length; index++) {\n        var rp = scene.reflectionProbes[index];\n\n        if (rp.name === parsedReflectionProbe.name) {\n          reflectionProbe = rp;\n          break;\n        }\n      }\n    }\n\n    reflectionProbe = SerializationHelper.Parse(function () {\n      return reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps);\n    }, parsedReflectionProbe, scene, rootUrl);\n    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n\n    if (parsedReflectionProbe._attachedMesh) {\n      reflectionProbe.attachToMesh(scene.getMeshByID(parsedReflectionProbe._attachedMesh));\n    }\n\n    return reflectionProbe;\n  };\n\n  __decorate([serializeAsMeshReference()], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n\n  __decorate([serializeAsVector3()], ReflectionProbe.prototype, \"position\", void 0);\n\n  return ReflectionProbe;\n}();\n\nexport { ReflectionProbe };","map":{"version":3,"sources":["../../../sourceES6/core/Probes/reflectionProbe.ts"],"names":[],"mappings":"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","sourcesContent":["import { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Nullable } from \"../types\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Scene } from \"../scene\";\r\n\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of reflection probes added to the scene\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n         */\r\n        reflectionProbes: Array<ReflectionProbe>;\r\n\r\n        /**\r\n         * Removes the given reflection probe from this scene.\r\n         * @param toRemove The reflection probe to remove\r\n         * @returns The index of the removed reflection probe\r\n         */\r\n        removeReflectionProbe(toRemove: ReflectionProbe): number;\r\n\r\n        /**\r\n         * Adds the given reflection probe to this scene.\r\n         * @param newReflectionProbe The reflection probe to add\r\n         */\r\n        addReflectionProbe(newReflectionProbe: ReflectionProbe): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeReflectionProbe = function(toRemove: ReflectionProbe): number {\r\n    if (!this.reflectionProbes) {\r\n        return -1;\r\n    }\r\n\r\n    var index = this.reflectionProbes.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.reflectionProbes.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addReflectionProbe = function(newReflectionProbe: ReflectionProbe): void {\r\n    if (!this.reflectionProbes) {\r\n        this.reflectionProbes = [];\r\n    }\r\n\r\n    this.reflectionProbes.push(newReflectionProbe);\r\n};\r\n\r\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\r\n */\r\nexport class ReflectionProbe {\r\n    private _scene: Scene;\r\n    private _renderTargetTexture: RenderTargetTexture;\r\n    private _projectionMatrix: Matrix;\r\n    private _viewMatrix = Matrix.Identity();\r\n    private _target = Vector3.Zero();\r\n    private _add = Vector3.Zero();\r\n    @serializeAsMeshReference()\r\n    private _attachedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _invertYAxis = false;\r\n\r\n    /** Gets or sets probe position (center of the cube map) */\r\n    @serializeAsVector3()\r\n    public position = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a new reflection probe\r\n     * @param name defines the name of the probe\r\n     * @param size defines the texture resolution (for each face)\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n     * @param useFloat defines if HDR data (flaot data) should be used to store colors (false by default)\r\n     */\r\n    constructor(\r\n        /** defines the name of the probe */\r\n        public name: string,\r\n        size: number, scene: Scene, generateMipMaps = true, useFloat = false) {\r\n        this._scene = scene;\r\n\r\n        // Create the scene field if not exist.\r\n        if (!this._scene.reflectionProbes) {\r\n            this._scene.reflectionProbes = new Array<ReflectionProbe>();\r\n        }\r\n        this._scene.reflectionProbes.push(this);\r\n\r\n        let textureType = 0;\r\n        if (useFloat) {\r\n            const caps = this._scene.getEngine().getCaps();\r\n            if (caps.textureHalfFloatRender) {\r\n                textureType = 2;\r\n            }\r\n            else if (caps.textureFloatRender) {\r\n                textureType = 1;\r\n            }\r\n        }\r\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\r\n\r\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    this._add.copyFromFloats(1, 0, 0);\r\n                    break;\r\n                case 1:\r\n                    this._add.copyFromFloats(-1, 0, 0);\r\n                    break;\r\n                case 2:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\r\n                    break;\r\n                case 3:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\r\n                    break;\r\n                case 4:\r\n                    this._add.copyFromFloats(0, 0, 1);\r\n                    break;\r\n                case 5:\r\n                    this._add.copyFromFloats(0, 0, -1);\r\n                    break;\r\n\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\r\n            }\r\n\r\n            this.position.addToRef(this._add, this._target);\r\n\r\n            Matrix.LookAtLHToRef(this.position, this._target, Vector3.Up(), this._viewMatrix);\r\n\r\n            if (scene.activeCamera) {\r\n                this._projectionMatrix = Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);\r\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n            }\r\n\r\n            scene._forcedViewPosition = this.position;\r\n        });\r\n\r\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\r\n            scene._forcedViewPosition = null;\r\n            scene.updateTransformMatrix(true);\r\n        });\r\n    }\r\n\r\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\r\n    public get samples(): number {\r\n        return this._renderTargetTexture.samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        this._renderTargetTexture.samples = value;\r\n    }\r\n\r\n    /** Gets or sets the refresh rate to use (on every frame by default) */\r\n    public get refreshRate(): number {\r\n        return this._renderTargetTexture.refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._renderTargetTexture.refreshRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets the internal CubeTexture used to render to */\r\n    public get cubeTexture(): RenderTargetTexture {\r\n        return this._renderTargetTexture;\r\n    }\r\n\r\n    /** Gets the list of meshes to render */\r\n    public get renderList(): Nullable<AbstractMesh[]> {\r\n        return this._renderTargetTexture.renderList;\r\n    }\r\n\r\n    /**\r\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n     * @param mesh defines the mesh to attach to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>): void {\r\n        this._attachedMesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clean all associated resources\r\n     */\r\n    public dispose() {\r\n        var index = this._scene.reflectionProbes.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this._scene.reflectionProbes.splice(index, 1);\r\n        }\r\n\r\n        if (this._renderTargetTexture) {\r\n            this._renderTargetTexture.dispose();\r\n            (<any>this._renderTargetTexture) = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the reflection probe information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable reflection probe info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name;\r\n\r\n        if (fullDetails) {\r\n            ret += \", position: \" + this.position.toString();\r\n\r\n            if (this._attachedMesh) {\r\n                ret += \", attached mesh: \" + this._attachedMesh.name;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the relfection probe.\r\n     * @returns \"ReflectionProbe\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ReflectionProbe\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the reflection probe to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\r\n        serializationObject.isReflectionProbe = true;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed reflection probe if successful\r\n     */\r\n    public static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe> {\r\n        let reflectionProbe: Nullable<ReflectionProbe> = null;\r\n        if (scene.reflectionProbes) {\r\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const rp = scene.reflectionProbes[index];\r\n                if (rp.name === parsedReflectionProbe.name) {\r\n                    reflectionProbe = rp;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);\r\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\r\n\r\n        if (parsedReflectionProbe._attachedMesh) {\r\n            reflectionProbe.attachToMesh(scene.getMeshByID(parsedReflectionProbe._attachedMesh));\r\n        }\r\n\r\n        return reflectionProbe;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}