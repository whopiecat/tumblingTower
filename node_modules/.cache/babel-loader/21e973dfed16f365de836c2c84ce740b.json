{"ast":null,"code":"/**\r\n * This class implement a typical dictionary using a string as key and the generic type T as value.\r\n * The underlying implementation relies on an associative array to ensure the best performances.\r\n * The value can be anything including 'null' but except 'undefined'\r\n */\nvar StringDictionary =\n/** @class */\nfunction () {\n  function StringDictionary() {\n    this._count = 0;\n    this._data = {};\n  }\n  /**\r\n   * This will clear this dictionary and copy the content from the 'source' one.\r\n   * If the T value is a custom object, it won't be copied/cloned, the same object will be used\r\n   * @param source the dictionary to take the content from and copy to this dictionary\r\n   */\n\n\n  StringDictionary.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    this.clear();\n    source.forEach(function (t, v) {\n      return _this.add(t, v);\n    });\n  };\n  /**\r\n   * Get a value based from its key\r\n   * @param key the given key to get the matching value from\r\n   * @return the value if found, otherwise undefined is returned\r\n   */\n\n\n  StringDictionary.prototype.get = function (key) {\n    var val = this._data[key];\n\n    if (val !== undefined) {\n      return val;\n    }\n\n    return undefined;\n  };\n  /**\r\n   * Get a value from its key or add it if it doesn't exist.\r\n   * This method will ensure you that a given key/data will be present in the dictionary.\r\n   * @param key the given key to get the matching value from\r\n   * @param factory the factory that will create the value if the key is not present in the dictionary.\r\n   * The factory will only be invoked if there's no data for the given key.\r\n   * @return the value corresponding to the key.\r\n   */\n\n\n  StringDictionary.prototype.getOrAddWithFactory = function (key, factory) {\n    var val = this.get(key);\n\n    if (val !== undefined) {\n      return val;\n    }\n\n    val = factory(key);\n\n    if (val) {\n      this.add(key, val);\n    }\n\n    return val;\n  };\n  /**\r\n   * Get a value from its key if present in the dictionary otherwise add it\r\n   * @param key the key to get the value from\r\n   * @param val if there's no such key/value pair in the dictionary add it with this value\r\n   * @return the value corresponding to the key\r\n   */\n\n\n  StringDictionary.prototype.getOrAdd = function (key, val) {\n    var curVal = this.get(key);\n\n    if (curVal !== undefined) {\n      return curVal;\n    }\n\n    this.add(key, val);\n    return val;\n  };\n  /**\r\n   * Check if there's a given key in the dictionary\r\n   * @param key the key to check for\r\n   * @return true if the key is present, false otherwise\r\n   */\n\n\n  StringDictionary.prototype.contains = function (key) {\n    return this._data[key] !== undefined;\n  };\n  /**\r\n   * Add a new key and its corresponding value\r\n   * @param key the key to add\r\n   * @param value the value corresponding to the key\r\n   * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\r\n   */\n\n\n  StringDictionary.prototype.add = function (key, value) {\n    if (this._data[key] !== undefined) {\n      return false;\n    }\n\n    this._data[key] = value;\n    ++this._count;\n    return true;\n  };\n  /**\r\n   * Update a specific value associated to a key\r\n   * @param key defines the key to use\r\n   * @param value defines the value to store\r\n   * @returns true if the value was updated (or false if the key was not found)\r\n   */\n\n\n  StringDictionary.prototype.set = function (key, value) {\n    if (this._data[key] === undefined) {\n      return false;\n    }\n\n    this._data[key] = value;\n    return true;\n  };\n  /**\r\n   * Get the element of the given key and remove it from the dictionary\r\n   * @param key defines the key to search\r\n   * @returns the value associated with the key or null if not found\r\n   */\n\n\n  StringDictionary.prototype.getAndRemove = function (key) {\n    var val = this.get(key);\n\n    if (val !== undefined) {\n      delete this._data[key];\n      --this._count;\n      return val;\n    }\n\n    return null;\n  };\n  /**\r\n   * Remove a key/value from the dictionary.\r\n   * @param key the key to remove\r\n   * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary\r\n   */\n\n\n  StringDictionary.prototype.remove = function (key) {\n    if (this.contains(key)) {\n      delete this._data[key];\n      --this._count;\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Clear the whole content of the dictionary\r\n   */\n\n\n  StringDictionary.prototype.clear = function () {\n    this._data = {};\n    this._count = 0;\n  };\n\n  Object.defineProperty(StringDictionary.prototype, \"count\", {\n    /**\r\n     * Gets the current count\r\n     */\n    get: function () {\n      return this._count;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Execute a callback on each key/val of the dictionary.\r\n   * Note that you can remove any element in this dictionary in the callback implementation\r\n   * @param callback the callback to execute on a given key/value pair\r\n   */\n\n  StringDictionary.prototype.forEach = function (callback) {\n    for (var cur in this._data) {\n      var val = this._data[cur];\n      callback(cur, val);\n    }\n  };\n  /**\r\n   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\r\n   * If the callback returns null or undefined the method will iterate to the next key/value pair\r\n   * Note that you can remove any element in this dictionary in the callback implementation\r\n   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\r\n   * @returns the first item\r\n   */\n\n\n  StringDictionary.prototype.first = function (callback) {\n    for (var cur in this._data) {\n      var val = this._data[cur];\n      var res = callback(cur, val);\n\n      if (res) {\n        return res;\n      }\n    }\n\n    return null;\n  };\n\n  return StringDictionary;\n}();\n\nexport { StringDictionary };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/stringDictionary.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\n\r\n/**\r\n * This class implement a typical dictionary using a string as key and the generic type T as value.\r\n * The underlying implementation relies on an associative array to ensure the best performances.\r\n * The value can be anything including 'null' but except 'undefined'\r\n */\r\nexport class StringDictionary<T> {\r\n\r\n    /**\r\n     * This will clear this dictionary and copy the content from the 'source' one.\r\n     * If the T value is a custom object, it won't be copied/cloned, the same object will be used\r\n     * @param source the dictionary to take the content from and copy to this dictionary\r\n     */\r\n    public copyFrom(source: StringDictionary<T>) {\r\n        this.clear();\r\n        source.forEach((t, v) => this.add(t, v));\r\n    }\r\n\r\n    /**\r\n     * Get a value based from its key\r\n     * @param key the given key to get the matching value from\r\n     * @return the value if found, otherwise undefined is returned\r\n     */\r\n    public get(key: string): T | undefined {\r\n        var val = this._data[key];\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key or add it if it doesn't exist.\r\n     * This method will ensure you that a given key/data will be present in the dictionary.\r\n     * @param key the given key to get the matching value from\r\n     * @param factory the factory that will create the value if the key is not present in the dictionary.\r\n     * The factory will only be invoked if there's no data for the given key.\r\n     * @return the value corresponding to the key.\r\n     */\r\n    public getOrAddWithFactory(key: string, factory: (key: string) => T): T {\r\n        var val = this.get(key);\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n\r\n        val = factory(key);\r\n        if (val) {\r\n            this.add(key, val);\r\n        }\r\n\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key if present in the dictionary otherwise add it\r\n     * @param key the key to get the value from\r\n     * @param val if there's no such key/value pair in the dictionary add it with this value\r\n     * @return the value corresponding to the key\r\n     */\r\n    public getOrAdd(key: string, val: T): T {\r\n        var curVal = this.get(key);\r\n        if (curVal !== undefined) {\r\n            return curVal;\r\n        }\r\n\r\n        this.add(key, val);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Check if there's a given key in the dictionary\r\n     * @param key the key to check for\r\n     * @return true if the key is present, false otherwise\r\n     */\r\n    public contains(key: string): boolean {\r\n        return this._data[key] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Add a new key and its corresponding value\r\n     * @param key the key to add\r\n     * @param value the value corresponding to the key\r\n     * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\r\n     */\r\n    public add(key: string, value: T): boolean {\r\n        if (this._data[key] !== undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        ++this._count;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update a specific value associated to a key\r\n     * @param key defines the key to use\r\n     * @param value defines the value to store\r\n     * @returns true if the value was updated (or false if the key was not found)\r\n     */\r\n    public set(key: string, value: T): boolean {\r\n        if (this._data[key] === undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the element of the given key and remove it from the dictionary\r\n     * @param key defines the key to search\r\n     * @returns the value associated with the key or null if not found\r\n     */\r\n    public getAndRemove(key: string): Nullable<T> {\r\n        let val = this.get(key);\r\n        if (val !== undefined) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return val;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a key/value from the dictionary.\r\n     * @param key the key to remove\r\n     * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary\r\n     */\r\n    public remove(key: string): boolean {\r\n        if (this.contains(key)) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Clear the whole content of the dictionary\r\n     */\r\n    public clear() {\r\n        this._data = {};\r\n        this._count = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current count\r\n     */\r\n    public get count() {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on each key/val of the dictionary.\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute on a given key/value pair\r\n     */\r\n    public forEach(callback: (key: string, val: T) => void) {\r\n        for (let cur in this._data) {\r\n            var val = this._data[cur];\r\n            callback(cur, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\r\n     * If the callback returns null or undefined the method will iterate to the next key/value pair\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\r\n     * @returns the first item\r\n     */\r\n    public first<TRes>(callback: (key: string, val: T) => TRes) {\r\n        for (let cur in this._data) {\r\n            var val = this._data[cur];\r\n            var res = callback(cur, val);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _count = 0;\r\n    private _data: { [key: string]: T } = {};\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}