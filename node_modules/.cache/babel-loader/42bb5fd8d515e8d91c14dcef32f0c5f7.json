{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\nimport { Scene } from \"../scene\";\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"../Misc/logger\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\n\nexport var SceneLoaderAnimationGroupLoadingMode;\n\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\r\n   * Reset all old animations to initial state then dispose them.\r\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\r\n   * Stop all old animations.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\r\n   * Restart old animations from first frame.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\r\n   * Old animations remains untouched.\r\n   */\n\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\n\n\nvar SceneLoader =\n/** @class */\nfunction () {\n  function SceneLoader() {}\n\n  Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\n    get: function () {\n      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n    },\n    set: function (value) {\n      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\n    get: function () {\n      return SceneLoaderFlags.ShowLoadingScreen;\n    },\n    set: function (value) {\n      SceneLoaderFlags.ShowLoadingScreen = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"loggingLevel\", {\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\n    get: function () {\n      return SceneLoaderFlags.loggingLevel;\n    },\n    set: function (value) {\n      SceneLoaderFlags.loggingLevel = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SceneLoader, \"CleanBoneMatrixWeights\", {\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\n    get: function () {\n      return SceneLoaderFlags.CleanBoneMatrixWeights;\n    },\n    set: function (value) {\n      SceneLoaderFlags.CleanBoneMatrixWeights = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the default plugin (used to load Babylon files)\r\n   * @returns the .babylon plugin\r\n   */\n\n  SceneLoader.GetDefaultPlugin = function () {\n    return SceneLoader._registeredPlugins[\".babylon\"];\n  };\n\n  SceneLoader._GetPluginForExtension = function (extension) {\n    var registeredPlugin = SceneLoader._registeredPlugins[extension];\n\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForDirectLoad = function (data) {\n    for (var extension in SceneLoader._registeredPlugins) {\n      var plugin = SceneLoader._registeredPlugins[extension].plugin;\n\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._registeredPlugins[extension];\n      }\n    }\n\n    return SceneLoader.GetDefaultPlugin();\n  };\n\n  SceneLoader._GetPluginForFilename = function (sceneFilename) {\n    var queryStringPosition = sceneFilename.indexOf(\"?\");\n\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n\n    var dotPosition = sceneFilename.lastIndexOf(\".\");\n    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  };\n\n  SceneLoader._GetDirectLoad = function (sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n\n    return null;\n  };\n\n  SceneLoader._LoadData = function (fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n    var directLoad = SceneLoader._GetDirectLoad(fileInfo.name);\n\n    var registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.name) : SceneLoader._GetPluginForFilename(fileInfo.name);\n    var plugin;\n\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n\n    if (directLoad) {\n      if (plugin.directLoad) {\n        var result = plugin.directLoad(scene, directLoad);\n\n        if (result.then) {\n          result.then(function (data) {\n            onSuccess(plugin, data);\n          }).catch(function (error) {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n\n      return plugin;\n    }\n\n    var useArrayBuffer = registeredPlugin.isBinary;\n\n    var dataCallback = function (data, responseURL) {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n\n      onSuccess(plugin, data, responseURL);\n    };\n\n    var request = null;\n    var pluginDisposed = false;\n    var onDisposeObservable = plugin.onDisposeObservable;\n\n    if (onDisposeObservable) {\n      onDisposeObservable.add(function () {\n        pluginDisposed = true;\n\n        if (request) {\n          request.abort();\n          request = null;\n        }\n\n        onDispose();\n      });\n    }\n\n    var manifestChecked = function () {\n      if (pluginDisposed) {\n        return;\n      }\n\n      var successCallback = function (data, request) {\n        dataCallback(data, request ? request.responseURL : undefined);\n      };\n\n      var errorCallback = function (error) {\n        onError(error.message, error);\n      };\n\n      request = plugin.requestFile ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback) : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n\n    var file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\n\n    if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file) {\n      var engine = scene.getEngine();\n      var canUseOfflineSupport = engine.enableOfflineSupport;\n\n      if (canUseOfflineSupport) {\n        // Also check for exceptions\n        var exceptionFound = false;\n\n        for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {\n          var regex = _a[_i];\n\n          if (regex.test(fileInfo.url)) {\n            exceptionFound = true;\n            break;\n          }\n        }\n\n        canUseOfflineSupport = !exceptionFound;\n      }\n\n      if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n        // Checking if a manifest file has been set for this scene and if offline mode has been requested\n        scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n      } else {\n        manifestChecked();\n      }\n    } // Loading file from disk via input file or drag'n'drop\n    else {\n        if (file) {\n          var errorCallback = function (error) {\n            onError(error.message, error);\n          };\n\n          request = plugin.readFile ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);\n        } else {\n          onError(\"Unable to find file named \" + fileInfo.name);\n        }\n      }\n\n    return plugin;\n  };\n\n  SceneLoader._GetFileInfo = function (rootUrl, sceneFilename) {\n    var url;\n    var name;\n    var file = null;\n\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      var sceneFile = sceneFilename;\n      url = rootUrl + sceneFile.name;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else {\n      var filename = sceneFilename;\n\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n\n      url = rootUrl + filename;\n      name = filename;\n    }\n\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file\n    };\n  }; // Public functions\n\n  /**\r\n   * Gets a plugin that can load the given extension\r\n   * @param extension defines the extension to load\r\n   * @returns a plugin or null if none works\r\n   */\n\n\n  SceneLoader.GetPluginForExtension = function (extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  };\n  /**\r\n   * Gets a boolean indicating that the given extension can be loaded\r\n   * @param extension defines the extension to load\r\n   * @returns true if the extension is supported\r\n   */\n\n\n  SceneLoader.IsPluginForExtensionAvailable = function (extension) {\n    return !!SceneLoader._registeredPlugins[extension];\n  };\n  /**\r\n   * Adds a new plugin to the list of registered plugins\r\n   * @param plugin defines the plugin to add\r\n   */\n\n\n  SceneLoader.RegisterPlugin = function (plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      var extension = plugin.extensions;\n      SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      var extensions = plugin.extensions;\n      Object.keys(extensions).forEach(function (extension) {\n        SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.ImportMesh = function (meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n\n    var successHandler = function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n      scene.importedMeshesFiles.push(fileInfo.url);\n\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data, responseURL) {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n\n      if (plugin.importMesh) {\n        var syncedPlugin = plugin;\n        var meshes = new Array();\n        var particleSystems = new Array();\n        var skeletons = new Array();\n\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (result) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Import meshes into a scene\r\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n   */\n\n\n  SceneLoader.ImportMeshAsync = function (meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Load = function (rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Load a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded scene\r\n   */\n\n\n  SceneLoader.LoadAsync = function (rootUrl, sceneFilename, engine, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (engine === void 0) {\n      engine = EngineStore.LastCreatedEngine;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.Append = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    var _this = this;\n\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    if (SceneLoader.ShowLoadingScreen && !this._showingLoadingScreen) {\n      this._showingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(function () {\n        scene.getEngine().hideLoadingUI();\n        _this._showingLoadingScreen = false;\n      });\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function () {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.load) {\n        var syncedPlugin = plugin;\n\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function () {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Append a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The given scene\r\n   */\n\n\n  SceneLoader.AppendAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, function (scene) {\n        resolve(scene);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded plugin\r\n   */\n\n\n  SceneLoader.LoadAssetContainer = function (rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n\n    var fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n\n    if (!fileInfo) {\n      return null;\n    }\n\n    var loadingToken = {};\n\n    scene._addPendingData(loadingToken);\n\n    var disposeHandler = function () {\n      scene._removePendingData(loadingToken);\n    };\n\n    var errorHandler = function (message, exception) {\n      var errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\n\n      if (exception && exception.message) {\n        errorMessage += \" (\" + exception.message + \")\";\n      }\n\n      if (onError) {\n        onError(scene, errorMessage, exception);\n      } else {\n        Logger.Error(errorMessage); // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n\n    var progressHandler = onProgress ? function (event) {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n\n    var successHandler = function (assets) {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n\n      scene._removePendingData(loadingToken);\n    };\n\n    return SceneLoader._LoadData(fileInfo, scene, function (plugin, data) {\n      if (plugin.loadAssetContainer) {\n        var syncedPlugin = plugin;\n        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n\n        if (!assetContainer) {\n          return;\n        }\n\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        var asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function (assetContainer) {\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(function (error) {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  };\n  /**\r\n   * Load a scene into an asset container\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n   * @param scene is the instance of Scene to append to\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns The loaded asset container\r\n   */\n\n\n  SceneLoader.LoadAssetContainerAsync = function (rootUrl, sceneFilename, scene, onProgress, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, function (assetContainer) {\n        resolve(assetContainer);\n      }, onProgress, function (scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   */\n\n\n  SceneLoader.ImportAnimations = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {\n        var animatable = _a[_i];\n        animatable.reset();\n      }\n\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(function (animationGroup) {\n        animationGroup.dispose();\n      });\n      var nodes = scene.getNodes();\n      nodes.forEach(function (node) {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(function (animationGroup) {\n            animationGroup.dispose();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.stop();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(function (animationGroup) {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n\n    var startingIndexForNewAnimatables = scene.animatables.length;\n\n    var onAssetContainerLoaded = function (container) {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  };\n  /**\r\n   * Import animations from a file into a scene\r\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n   * @param onSuccess a callback with the scene when import succeeds\r\n   * @param onProgress a callback with a progress event for each file being loaded\r\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n   * @param pluginExtension the extension used to determine the plugin\r\n   * @returns the updated scene with imported animations\r\n   */\n\n\n  SceneLoader.ImportAnimationsAsync = function (rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {\n    if (sceneFilename === void 0) {\n      sceneFilename = \"\";\n    }\n\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (overwriteAnimations === void 0) {\n      overwriteAnimations = true;\n    }\n\n    if (animationGroupLoadingMode === void 0) {\n      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (onSuccess === void 0) {\n      onSuccess = null;\n    }\n\n    if (onProgress === void 0) {\n      onProgress = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (pluginExtension === void 0) {\n      pluginExtension = null;\n    }\n\n    return new Promise(function (resolve, reject) {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function (_scene) {\n        resolve(_scene);\n      }, onProgress, function (_scene, message, exception) {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  };\n  /**\r\n   * No logging while loading\r\n   */\n\n\n  SceneLoader.NO_LOGGING = 0;\n  /**\r\n   * Minimal logging while loading\r\n   */\n\n  SceneLoader.MINIMAL_LOGGING = 1;\n  /**\r\n   * Summary logging while loading\r\n   */\n\n  SceneLoader.SUMMARY_LOGGING = 2;\n  /**\r\n   * Detailled logging while loading\r\n   */\n\n  SceneLoader.DETAILED_LOGGING = 3; // Members\n\n  /**\r\n   * Event raised when a plugin is used to load a scene\r\n   */\n\n  SceneLoader.OnPluginActivatedObservable = new Observable();\n  SceneLoader._registeredPlugins = {};\n  SceneLoader._showingLoadingScreen = false;\n  return SceneLoader;\n}();\n\nexport { SceneLoader };","map":{"version":3,"sources":["../../../sourceES6/core/Loading/sceneLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport { AssetContainer } from \"../assetContainer\";\r\nimport { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport { IFileRequest } from \"../Misc/fileRequest\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { RequestFileError, ReadFileError } from '../Misc/fileTools';\r\nimport { TransformNode } from '../Meshes/transformNode';\r\nimport { Geometry } from '../Meshes/geometry';\r\nimport { Light } from '../Lights/light';\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    [extension: string]: {\r\n        isBinary: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the factory\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @return the new plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    requestFile?(scene: Scene, url: string, onSuccess: (data: any, request?: WebRequest) => void, onProgress?: (ev: ISceneLoaderProgressEvent) => void, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;\r\n\r\n    /**\r\n     * The callback called when loading from a file object.\r\n     * @param scene scene loading this file\r\n     * @param file defines the file to load\r\n     * @param onSuccess defines the callback to call when data is loaded\r\n     * @param onProgress defines the callback to call during loading process\r\n     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n     * @param onError defines the callback to call when an error occurs\r\n     * @returns a file request object\r\n     */\r\n    readFile?(scene: Scene, file: File, onSuccess: (data: any) => void, onProgress?: (ev: ISceneLoaderProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: any) => void): IFileRequest;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): any;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = 0;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = 1;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = 2;\r\n\r\n    /**\r\n     * Detailled logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = 3;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static OnPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\n\r\n    private static _registeredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\n\r\n    private static _showingLoadingScreen = false;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin {\r\n        return SceneLoader._registeredPlugins[\".babylon\"];\r\n    }\r\n\r\n    private static _GetPluginForExtension(extension: string): IRegisteredPlugin {\r\n        var registeredPlugin = SceneLoader._registeredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type\");\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForDirectLoad(data: string): IRegisteredPlugin {\r\n        for (var extension in SceneLoader._registeredPlugins) {\r\n            var plugin = SceneLoader._registeredPlugins[extension].plugin;\r\n\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._registeredPlugins[extension];\r\n            }\r\n        }\r\n\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForFilename(sceneFilename: string): IRegisteredPlugin {\r\n        var queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n\r\n        var dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n        var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._GetPluginForExtension(extension);\r\n    }\r\n\r\n    private static _GetDirectLoad(sceneFilename: string): Nullable<string> {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _LoadData(fileInfo: IFileInfo, scene: Scene, onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: any, responseURL?: string) => void, onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined, onError: (message: string, exception?: any) => void, onDispose: () => void, pluginExtension: Nullable<string>): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        const directLoad = SceneLoader._GetDirectLoad(fileInfo.name);\r\n        const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : (directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.name) : SceneLoader._GetPluginForFilename(fileInfo.name));\r\n\r\n        let plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n        if ((registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin !== undefined) {\r\n            plugin = (registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin();\r\n        }\r\n        else {\r\n            plugin = <any>registeredPlugin.plugin;\r\n        }\r\n\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        if (directLoad) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result.then) {\r\n                    result.then((data: any) => {\r\n                        onSuccess(plugin, data);\r\n                    }).catch((error: any) => {\r\n                        onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                    });\r\n                }\r\n                else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return plugin;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin.isBinary;\r\n\r\n        const dataCallback = (data: any, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        const onDisposeObservable = (plugin as any).onDisposeObservable as Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(() => {\r\n                pluginDisposed = true;\r\n\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n\r\n                onDispose();\r\n            });\r\n        }\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const successCallback = (data: string | ArrayBuffer, request?: WebRequest) => {\r\n                dataCallback(data, request ? request.responseURL : undefined);\r\n            };\r\n\r\n            const errorCallback = (error: RequestFileError) => {\r\n                onError(error.message, error);\r\n            };\r\n\r\n            request = plugin.requestFile\r\n                ? plugin.requestFile(scene, fileInfo.url, successCallback, onProgress, useArrayBuffer, errorCallback)\r\n                : scene._requestFile(fileInfo.url, successCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\r\n\r\n        if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || (fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file)) {\r\n            const engine = scene.getEngine();\r\n            let canUseOfflineSupport = engine.enableOfflineSupport;\r\n            if (canUseOfflineSupport) {\r\n                // Also check for exceptions\r\n                let exceptionFound = false;\r\n                for (var regex of scene.disableOfflineSupportExceptionRules) {\r\n                    if (regex.test(fileInfo.url)) {\r\n                        exceptionFound = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                canUseOfflineSupport = !exceptionFound;\r\n            }\r\n\r\n            if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n                // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n                scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n            }\r\n            else {\r\n                manifestChecked();\r\n            }\r\n        }\r\n        // Loading file from disk via input file or drag'n'drop\r\n        else {\r\n            if (file) {\r\n                const errorCallback = (error: ReadFileError) => {\r\n                    onError(error.message, error);\r\n                };\r\n\r\n                request = plugin.readFile\r\n                    ? plugin.readFile(scene, file, dataCallback, onProgress, useArrayBuffer, errorCallback)\r\n                    : scene._readFile(file, dataCallback, onProgress, useArrayBuffer, errorCallback);\r\n            } else {\r\n                onError(\"Unable to find file named \" + fileInfo.name);\r\n            }\r\n        }\r\n        return plugin;\r\n    }\r\n\r\n    private static _GetFileInfo(rootUrl: string, sceneFilename: string | File): Nullable<IFileInfo> {\r\n        let url: string;\r\n        let name: string;\r\n        let file: Nullable<File> = null;\r\n\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        }\r\n        else if ((sceneFilename as File).name) {\r\n            const sceneFile = sceneFilename as File;\r\n            url = rootUrl + sceneFile.name;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        }\r\n        else {\r\n            const filename = sceneFilename as string;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file\r\n        };\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory {\r\n        return SceneLoader._GetPluginForExtension(extension).plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return !!SceneLoader._registeredPlugins[extension];\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            var extension = <string>plugin.extensions;\r\n            SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false\r\n            };\r\n        }\r\n        else {\r\n            var extensions = <ISceneLoaderPluginExtensions>plugin.extensions;\r\n            Object.keys(extensions).forEach((extension) => {\r\n                SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static ImportMesh(meshNames: any, rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onSuccess: Nullable<SceneLoaderSuccessCallback> = null, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        var errorHandler = (message: string, exception?: any) => {\r\n            let errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: ISceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback: \" + e, e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n\r\n            if ((<any>plugin).importMesh) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                var meshes = new Array<AbstractMesh>();\r\n                var particleSystems = new Array<IParticleSystem>();\r\n                var skeletons = new Array<Skeleton>();\r\n\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, [], [], [], []);\r\n            }\r\n            else {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(meshNames: any, rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: particleSystems,\r\n                    skeletons: skeletons,\r\n                    animationGroups: animationGroups,\r\n                    transformNodes: transformNodes,\r\n                    geometries: geometries,\r\n                    lights: lights\r\n                });\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n                pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Load(rootUrl: string, sceneFilename: string | File = \"\", engine: Nullable<Engine> = EngineStore.LastCreatedEngine, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(rootUrl: string, sceneFilename: string | File = \"\", engine: Nullable<Engine> = EngineStore.LastCreatedEngine, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {\r\n                resolve(scene);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Append(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (SceneLoader.ShowLoadingScreen && !this._showingLoadingScreen) {\r\n            this._showingLoadingScreen = true;\r\n            scene.getEngine().displayLoadingUI();\r\n            scene.executeWhenReady(() => {\r\n                scene.getEngine().hideLoadingUI();\r\n                this._showingLoadingScreen = false;\r\n            });\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        var errorHandler = (message: Nullable<string>, exception?: any) => {\r\n            let errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: ISceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler = () => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\r\n            if ((<any>plugin).load) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            } else {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Append(rootUrl, sceneFilename, scene, (scene) => {\r\n                resolve(scene);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        var errorHandler = (message: Nullable<string>, exception?: any) => {\r\n            let errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n\r\n            if (exception && exception.message) {\r\n                errorMessage += ` (${exception.message})`;\r\n            }\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: ISceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler = (assets: AssetContainer) => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\r\n            if ((<any>plugin).loadAssetContainer) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            } else if ((<any>plugin).loadAssetContainerAsync) {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            } else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(rootUrl: string, sceneFilename: string = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<AssetContainer> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {\r\n                resolve(assetContainer);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     */\r\n    public static ImportAnimations(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter: Nullable<(target: any) => any> = null, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): void {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load animations to\");\r\n            return;\r\n        }\r\n\r\n        if (overwriteAnimations) {\r\n            // Reset, stop and dispose all animations before loading new ones\r\n            for (let animatable of scene.animatables) {\r\n                animatable.reset();\r\n            }\r\n            scene.stopAllAnimations();\r\n            scene.animationGroups.slice().forEach((animationGroup) => {\r\n                animationGroup.dispose();\r\n            });\r\n            let nodes = scene.getNodes();\r\n            nodes.forEach((node) => {\r\n                if (node.animations) {\r\n                    node.animations = [];\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            switch (animationGroupLoadingMode) {\r\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                    scene.animationGroups.slice().forEach((animationGroup) => {\r\n                        animationGroup.dispose();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.stop();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.reset();\r\n                        animationGroup.restart();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                    // nothing to do\r\n                    break;\r\n                default:\r\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                    return;\r\n            }\r\n        }\r\n\r\n        let startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n        let onAssetContainerLoaded = (container: AssetContainer) => {\r\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n            container.dispose();\r\n\r\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n            if (onSuccess) {\r\n                onSuccess(scene);\r\n            }\r\n        };\r\n\r\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    public static ImportAnimationsAsync(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter: Nullable<(target: any) => any> = null, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, (_scene: Scene) => {\r\n                resolve(_scene);\r\n            }, onProgress, (_scene: Scene, message: string, exception: any) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}