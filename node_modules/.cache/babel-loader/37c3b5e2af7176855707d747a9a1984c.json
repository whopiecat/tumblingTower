{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Ray } from \"../Culling/ray\";\nimport { Material } from \"../Materials/material\";\nimport { LensFlare } from \"./lensFlare\";\nimport \"../Shaders/lensFlare.fragment\";\nimport \"../Shaders/lensFlare.vertex\";\nimport { _DevTools } from '../Misc/devTools';\nimport { Color3 } from '../Maths/math.color';\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n */\n\nvar LensFlareSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a lens flare system.\r\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n   * It is usually composed of several `lensFlare`.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n   * @param name Define the name of the lens flare system in the scene\r\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n   * @param scene Define the scene the lens flare system belongs to\r\n   */\n  function LensFlareSystem(\n  /**\r\n   * Define the name of the lens flare system\r\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\r\n     * List of lens flares used in this system.\r\n     */\n\n    this.lensFlares = new Array();\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\n\n    this.borderLimit = 300;\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\n\n    this.viewportBorder = 0;\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\n\n    this.layerMask = 0x0FFFFFFF;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n\n    this.meshesSelectionPredicate = function (m) {\n      return scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    };\n\n    var engine = scene.getEngine(); // VBO\n\n    var vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2); // Indices\n\n    var indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices); // Effects\n\n    this._effect = engine.createEffect(\"lensFlare\", [VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\n  }\n\n  Object.defineProperty(LensFlareSystem.prototype, \"isEnabled\", {\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\n    get: function () {\n      return this._isEnabled;\n    },\n    set: function (value) {\n      this._isEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the scene the effects belongs to.\r\n   * @returns the scene holding the lens flare system\r\n   */\n\n  LensFlareSystem.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\r\n   * Get the emitter of the lens flare system.\r\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @returns the emitter of the lens flare system\r\n   */\n\n\n  LensFlareSystem.prototype.getEmitter = function () {\n    return this._emitter;\n  };\n  /**\r\n   * Set the emitter of the lens flare system.\r\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @param newEmitter Define the new emitter of the system\r\n   */\n\n\n  LensFlareSystem.prototype.setEmitter = function (newEmitter) {\n    this._emitter = newEmitter;\n  };\n  /**\r\n   * Get the lens flare system emitter position.\r\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n   * @returns the position\r\n   */\n\n\n  LensFlareSystem.prototype.getEmitterPosition = function () {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  LensFlareSystem.prototype.computeEffectivePosition = function (globalViewport) {\n    var position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n\n    if (position.z > 0) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  LensFlareSystem.prototype._isVisible = function () {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n\n    var emitterPosition = this.getEmitterPosition();\n    var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    var distance = direction.length();\n    direction.normalize();\n    var ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n\n    var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  LensFlareSystem.prototype.render = function () {\n    if (!this._effect.isReady() || !this._scene.activeCamera) {\n      return false;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var viewport = this._scene.activeCamera.viewport;\n    var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true)); // Position\n\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    } // Visibility\n\n\n    if (!this._isVisible()) {\n      return false;\n    } // Intensity\n\n\n    var awayX;\n    var awayY;\n\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n\n    var away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n\n    var intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n\n    if (intensity < 0) {\n      return false;\n    }\n\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    } // Position\n\n\n    var centerX = globalViewport.x + globalViewport.width / 2;\n    var centerY = globalViewport.y + globalViewport.height / 2;\n    var distX = centerX - this._positionX;\n    var distY = centerY - this._positionY; // Effects\n\n    engine.enableEffect(this._effect);\n    engine.setState(false);\n    engine.setDepthBuffer(false); // VBOs\n\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect); // Flares\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n\n      if (flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n\n      engine.setAlphaMode(flare.alphaMode);\n      var x = centerX - distX * flare.position;\n      var y = centerY - distY * flare.position;\n      var cw = flare.size;\n      var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      var viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n\n      this._effect.setMatrix(\"viewportMatrix\", viewportMatrix); // Texture\n\n\n      this._effect.setTexture(\"textureSampler\", flare.texture); // Color\n\n\n      this._effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0); // Draw order\n\n\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  };\n  /**\r\n   * Dispose and release the lens flare with its associated resources.\r\n   */\n\n\n  LensFlareSystem.prototype.dispose = function () {\n    var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n\n      this._indexBuffer = null;\n    }\n\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    } // Remove from scene\n\n\n    var index = this._scene.lensFlareSystems.indexOf(this);\n\n    this._scene.lensFlareSystems.splice(index, 1);\n  };\n  /**\r\n   * Parse a lens flare system from a JSON repressentation\r\n   * @param parsedLensFlareSystem Define the JSON to parse\r\n   * @param scene Define the scene the parsed system should be instantiated in\r\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n   * @returns the parsed system\r\n   */\n\n\n  LensFlareSystem.Parse = function (parsedLensFlareSystem, scene, rootUrl) {\n    var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);\n    var name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    var lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n\n    for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      var parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n\n    return lensFlareSystem;\n  };\n  /**\r\n   * Serialize the current Lens Flare System into a JSON representation.\r\n   * @returns the serialized JSON\r\n   */\n\n\n  LensFlareSystem.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n\n    for (var index = 0; index < this.lensFlares.length; index++) {\n      var flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  LensFlareSystem._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"LensFlareSystemSceneComponent\");\n  };\n\n  return LensFlareSystem;\n}();\n\nexport { LensFlareSystem };","map":{"version":3,"sources":["../../../sourceES6/core/LensFlares/lensFlareSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { LensFlare } from \"./lensFlare\";\r\n\r\n\r\nimport \"../Shaders/lensFlare.fragment\";\r\nimport \"../Shaders/lensFlare.vertex\";\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Viewport } from '../Maths/math.viewport';\r\n\r\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n */\r\nexport class LensFlareSystem {\r\n    /**\r\n     * List of lens flares used in this system.\r\n     */\r\n    public lensFlares = new Array<LensFlare>();\r\n\r\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\r\n    public borderLimit = 300;\r\n\r\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\r\n    public viewportBorder = 0;\r\n\r\n    /**\r\n     * Define a predicate which could limit the list of meshes able to occlude the effect.\r\n     */\r\n    public meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\r\n    public layerMask: number = 0x0FFFFFFF;\r\n\r\n    /**\r\n     * Define the id of the lens flare system in the scene.\r\n     * (equal to name by default)\r\n     */\r\n    public id: string;\r\n\r\n    private _scene: Scene;\r\n    private _emitter: any;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effect: Effect;\r\n    private _positionX: number;\r\n    private _positionY: number;\r\n    private _isEnabled = true;\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"LensFlareSystemSceneComponent\");\r\n    }\r\n\r\n    /**\r\n     * Instantiates a lens flare system.\r\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n     * It is usually composed of several `lensFlare`.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     * @param name Define the name of the lens flare system in the scene\r\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param scene Define the scene the lens flare system belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the lens flare system\r\n         */\r\n        public name: string,\r\n        emitter: any,\r\n        scene: Scene) {\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        LensFlareSystem._SceneComponentInitialization(this._scene);\r\n\r\n        this._emitter = emitter;\r\n        this.id = name;\r\n        scene.lensFlareSystems.push(this);\r\n\r\n        this.meshesSelectionPredicate = (m) => <boolean>(scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && ((m.layerMask & scene.activeCamera.layerMask) != 0));\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n\r\n        // Effects\r\n        this._effect = engine.createEffect(\"lensFlare\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"color\", \"viewportMatrix\"],\r\n            [\"textureSampler\"], \"\");\r\n    }\r\n\r\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the effects belongs to.\r\n     * @returns the scene holding the lens flare system\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the emitter of the lens flare system\r\n     */\r\n    public getEmitter(): any {\r\n        return this._emitter;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param newEmitter Define the new emitter of the system\r\n     */\r\n    public setEmitter(newEmitter: any): void {\r\n        this._emitter = newEmitter;\r\n    }\r\n\r\n    /**\r\n     * Get the lens flare system emitter position.\r\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the position\r\n     */\r\n    public getEmitterPosition(): Vector3 {\r\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public computeEffectivePosition(globalViewport: Viewport): boolean {\r\n        var position = this.getEmitterPosition();\r\n\r\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._positionX = position.x;\r\n        this._positionY = position.y;\r\n\r\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x -= this.viewportBorder;\r\n            globalViewport.y -= this.viewportBorder;\r\n            globalViewport.width += this.viewportBorder * 2;\r\n            globalViewport.height += this.viewportBorder * 2;\r\n            position.x += this.viewportBorder;\r\n            position.y += this.viewportBorder;\r\n            this._positionX += this.viewportBorder;\r\n            this._positionY += this.viewportBorder;\r\n        }\r\n\r\n        if (position.z > 0) {\r\n            if ((this._positionX > globalViewport.x) && (this._positionX < globalViewport.x + globalViewport.width)) {\r\n                if ((this._positionY > globalViewport.y) && (this._positionY < globalViewport.y + globalViewport.height)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _isVisible(): boolean {\r\n        if (!this._isEnabled || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        var emitterPosition = this.getEmitterPosition();\r\n        var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\r\n        var distance = direction.length();\r\n        direction.normalize();\r\n\r\n        var ray = new Ray(this._scene.activeCamera.globalPosition, direction);\r\n        var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\r\n\r\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public render(): boolean {\r\n        if (!this._effect.isReady() || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n        var viewport = this._scene.activeCamera.viewport;\r\n        var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\r\n\r\n        // Position\r\n        if (!this.computeEffectivePosition(globalViewport)) {\r\n            return false;\r\n        }\r\n\r\n        // Visibility\r\n        if (!this._isVisible()) {\r\n            return false;\r\n        }\r\n\r\n        // Intensity\r\n        var awayX;\r\n        var awayY;\r\n\r\n        if (this._positionX < this.borderLimit + globalViewport.x) {\r\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\r\n        } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\r\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\r\n        } else {\r\n            awayX = 0;\r\n        }\r\n\r\n        if (this._positionY < this.borderLimit + globalViewport.y) {\r\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\r\n        } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\r\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\r\n        } else {\r\n            awayY = 0;\r\n        }\r\n\r\n        var away = (awayX > awayY) ? awayX : awayY;\r\n\r\n        away -= this.viewportBorder;\r\n\r\n        if (away > this.borderLimit) {\r\n            away = this.borderLimit;\r\n        }\r\n\r\n        var intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\r\n        if (intensity < 0) {\r\n            return false;\r\n        }\r\n\r\n        if (intensity > 1.0) {\r\n            intensity = 1.0;\r\n        }\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x += this.viewportBorder;\r\n            globalViewport.y += this.viewportBorder;\r\n            globalViewport.width -= this.viewportBorder * 2;\r\n            globalViewport.height -= this.viewportBorder * 2;\r\n            this._positionX -= this.viewportBorder;\r\n            this._positionY -= this.viewportBorder;\r\n        }\r\n\r\n        // Position\r\n        var centerX = globalViewport.x + globalViewport.width / 2;\r\n        var centerY = globalViewport.y + globalViewport.height / 2;\r\n        var distX = centerX - this._positionX;\r\n        var distY = centerY - this._positionY;\r\n\r\n        // Effects\r\n        engine.enableEffect(this._effect);\r\n        engine.setState(false);\r\n        engine.setDepthBuffer(false);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\r\n\r\n        // Flares\r\n        for (var index = 0; index < this.lensFlares.length; index++) {\r\n            var flare = this.lensFlares[index];\r\n\r\n            if (flare.texture && !flare.texture.isReady()) {\r\n                continue;\r\n            }\r\n\r\n            engine.setAlphaMode(flare.alphaMode);\r\n\r\n            var x = centerX - (distX * flare.position);\r\n            var y = centerY - (distY * flare.position);\r\n\r\n            var cw = flare.size;\r\n            var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\r\n            var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\r\n            var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\r\n\r\n            var viewportMatrix = Matrix.FromValues(\r\n                cw / 2, 0, 0, 0,\r\n                0, ch / 2, 0, 0,\r\n                0, 0, 1, 0,\r\n                cx, cy, 0, 1);\r\n\r\n            this._effect.setMatrix(\"viewportMatrix\", viewportMatrix);\r\n\r\n            // Texture\r\n            this._effect.setTexture(\"textureSampler\", flare.texture);\r\n\r\n            // Color\r\n            this._effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        engine.setDepthBuffer(true);\r\n        engine.setAlphaMode(0);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        while (this.lensFlares.length) {\r\n            this.lensFlares[0].dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        var index = this._scene.lensFlareSystems.indexOf(this);\r\n        this._scene.lensFlareSystems.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Parse a lens flare system from a JSON repressentation\r\n     * @param parsedLensFlareSystem Define the JSON to parse\r\n     * @param scene Define the scene the parsed system should be instantiated in\r\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n     * @returns the parsed system\r\n     */\r\n    public static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem {\r\n        var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);\r\n\r\n        var name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\r\n\r\n        var lensFlareSystem = new LensFlareSystem(name, emitter, scene);\r\n\r\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\r\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\r\n\r\n        for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {\r\n            var parsedFlare = parsedLensFlareSystem.flares[index];\r\n            LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\r\n        }\r\n\r\n        return lensFlareSystem;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current Lens Flare System into a JSON representation.\r\n     * @returns the serialized JSON\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.emitterId = this.getEmitter().id;\r\n        serializationObject.borderLimit = this.borderLimit;\r\n\r\n        serializationObject.flares = [];\r\n        for (var index = 0; index < this.lensFlares.length; index++) {\r\n            var flare = this.lensFlares[index];\r\n\r\n            serializationObject.flares.push({\r\n                size: flare.size,\r\n                position: flare.position,\r\n                color: flare.color.asArray(),\r\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}