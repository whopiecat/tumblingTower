{"ast":null,"code":"import { SmartArray } from \"../Misc/smartArray\";\nimport { Logger } from \"../Misc/logger\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { MorphTarget } from \"./morphTarget\";\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\n\nvar MorphTargetManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new MorphTargetManager\r\n   * @param scene defines the current scene\r\n   */\n  function MorphTargetManager(scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this._targets = new Array();\n    this._targetInfluenceChangedObservers = new Array();\n    this._targetDataLayoutChangedObservers = new Array();\n    this._activeTargets = new SmartArray(16);\n    this._supportsNormals = false;\n    this._supportsTangents = false;\n    this._supportsUVs = false;\n    this._vertexCount = 0;\n    this._uniqueId = 0;\n    this._tempInfluences = new Array();\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\n\n    this.enableNormalMorphing = true;\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\n\n    this.enableTangentMorphing = true;\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\n\n    this.enableUVMorphing = true;\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    this._scene = scene;\n\n    if (this._scene) {\n      this._scene.morphTargetManagers.push(this);\n\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n\n  Object.defineProperty(MorphTargetManager.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\n    get: function () {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"vertexCount\", {\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\n    get: function () {\n      return this._vertexCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsNormals\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\n    get: function () {\n      return this._supportsNormals && this.enableNormalMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsTangents\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\n    get: function () {\n      return this._supportsTangents && this.enableTangentMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"supportsUVs\", {\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\n    get: function () {\n      return this._supportsUVs && this.enableUVMorphing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numTargets\", {\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\n    get: function () {\n      return this._targets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"numInfluencers\", {\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\n    get: function () {\n      return this._activeTargets.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetManager.prototype, \"influences\", {\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\n    get: function () {\n      return this._influences;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the active target at specified index. An active target is a target with an influence > 0\r\n   * @param index defines the index to check\r\n   * @returns the requested target\r\n   */\n\n  MorphTargetManager.prototype.getActiveTarget = function (index) {\n    return this._activeTargets.data[index];\n  };\n  /**\r\n   * Gets the target at specified index\r\n   * @param index defines the index to check\r\n   * @returns the requested target\r\n   */\n\n\n  MorphTargetManager.prototype.getTarget = function (index) {\n    return this._targets[index];\n  };\n  /**\r\n   * Add a new target to this manager\r\n   * @param target defines the target to add\r\n   */\n\n\n  MorphTargetManager.prototype.addTarget = function (target) {\n    var _this = this;\n\n    this._targets.push(target);\n\n    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(function (needUpdate) {\n      _this._syncActiveTargets(needUpdate);\n    }));\n\n    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(function () {\n      _this._syncActiveTargets(true);\n    }));\n\n    this._syncActiveTargets(true);\n  };\n  /**\r\n   * Removes a target from the manager\r\n   * @param target defines the target to remove\r\n   */\n\n\n  MorphTargetManager.prototype.removeTarget = function (target) {\n    var index = this._targets.indexOf(target);\n\n    if (index >= 0) {\n      this._targets.splice(index, 1);\n\n      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\n\n      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\n\n      this._syncActiveTargets(true);\n    }\n  };\n  /**\r\n   * Clone the current manager\r\n   * @returns a new MorphTargetManager\r\n   */\n\n\n  MorphTargetManager.prototype.clone = function () {\n    var copy = new MorphTargetManager(this._scene);\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      copy.addTarget(target.clone());\n    }\n\n    copy.enableNormalMorphing = this.enableNormalMorphing;\n    copy.enableTangentMorphing = this.enableTangentMorphing;\n    copy.enableUVMorphing = this.enableUVMorphing;\n    return copy;\n  };\n  /**\r\n   * Serializes the current manager into a Serialization object\r\n   * @returns the serialized object\r\n   */\n\n\n  MorphTargetManager.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.uniqueId;\n    serializationObject.targets = [];\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n      serializationObject.targets.push(target.serialize());\n    }\n\n    return serializationObject;\n  };\n\n  MorphTargetManager.prototype._syncActiveTargets = function (needUpdate) {\n    var influenceCount = 0;\n\n    this._activeTargets.reset();\n\n    this._supportsNormals = true;\n    this._supportsTangents = true;\n    this._supportsUVs = true;\n    this._vertexCount = 0;\n\n    for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n      var target = _a[_i];\n\n      if (target.influence === 0) {\n        continue;\n      }\n\n      this._activeTargets.push(target);\n\n      this._tempInfluences[influenceCount++] = target.influence;\n      this._supportsNormals = this._supportsNormals && target.hasNormals;\n      this._supportsTangents = this._supportsTangents && target.hasTangents;\n      this._supportsUVs = this._supportsUVs && target.hasUVs;\n      var positions = target.getPositions();\n\n      if (positions) {\n        var vertexCount = positions.length / 3;\n\n        if (this._vertexCount === 0) {\n          this._vertexCount = vertexCount;\n        } else if (this._vertexCount !== vertexCount) {\n          Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n          return;\n        }\n      }\n    }\n\n    if (!this._influences || this._influences.length !== influenceCount) {\n      this._influences = new Float32Array(influenceCount);\n    }\n\n    for (var index = 0; index < influenceCount; index++) {\n      this._influences[index] = this._tempInfluences[index];\n    }\n\n    if (needUpdate) {\n      this.synchronize();\n    }\n  };\n  /**\r\n   * Syncrhonize the targets with all the meshes using this morph target manager\r\n   */\n\n\n  MorphTargetManager.prototype.synchronize = function () {\n    if (!this._scene) {\n      return;\n    } // Flag meshes as dirty to resync with the active targets\n\n\n    for (var _i = 0, _a = this._scene.meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      if (mesh.morphTargetManager === this) {\n        mesh._syncGeometryWithMorphTargetManager();\n      }\n    }\n  }; // Statics\n\n  /**\r\n   * Creates a new MorphTargetManager from serialized data\r\n   * @param serializationObject defines the serialized data\r\n   * @param scene defines the hosting scene\r\n   * @returns the new MorphTargetManager\r\n   */\n\n\n  MorphTargetManager.Parse = function (serializationObject, scene) {\n    var result = new MorphTargetManager(scene);\n    result._uniqueId = serializationObject.id;\n\n    for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {\n      var targetData = _a[_i];\n      result.addTarget(MorphTarget.Parse(targetData));\n    }\n\n    return result;\n  };\n\n  return MorphTargetManager;\n}();\n\nexport { MorphTargetManager };","map":{"version":3,"sources":["../../../sourceES6/core/Morph/morphTargetManager.ts"],"names":[],"mappings":"AACA,SAAS,UAAT,QAA2B,oBAA3B;AACA,SAAS,MAAT,QAAuB,gBAAvB;AAGA,SAAS,WAAT,QAA4B,wBAA5B;AAEA,SAAS,WAAT,QAA4B,eAA5B;AACA;;;;;AAIA,IAAA,kBAAA;AAAA;AAAA,YAAA;AA6BI;;;;AAIA,WAAA,kBAAA,CAAmB,KAAnB,EAAgD;AAA7B,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA6B;;AAhCxC,SAAA,QAAA,GAAW,IAAI,KAAJ,EAAX;AACA,SAAA,gCAAA,GAAmC,IAAI,KAAJ,EAAnC;AACA,SAAA,iCAAA,GAAoC,IAAI,KAAJ,EAApC;AACA,SAAA,cAAA,GAAiB,IAAI,UAAJ,CAA4B,EAA5B,CAAjB;AAGA,SAAA,gBAAA,GAAmB,KAAnB;AACA,SAAA,iBAAA,GAAoB,KAApB;AACA,SAAA,YAAA,GAAe,KAAf;AACA,SAAA,YAAA,GAAe,CAAf;AACA,SAAA,SAAA,GAAY,CAAZ;AACA,SAAA,eAAA,GAAkB,IAAI,KAAJ,EAAlB;AAER;;;;AAGO,SAAA,oBAAA,GAAuB,IAAvB;AAEP;;;;AAGO,SAAA,qBAAA,GAAwB,IAAxB;AAEP;;;;AAGO,SAAA,gBAAA,GAAmB,IAAnB;;AAOH,QAAI,CAAC,KAAL,EAAY;AACR,MAAA,KAAK,GAAG,WAAW,CAAC,gBAApB;AACH;;AAED,SAAK,MAAL,GAAc,KAAd;;AAEA,QAAI,KAAK,MAAT,EAAiB;AACb,WAAK,MAAL,CAAY,mBAAZ,CAAgC,IAAhC,CAAqC,IAArC;;AAEA,WAAK,SAAL,GAAiB,KAAK,MAAL,CAAY,WAAZ,EAAjB;AACH;AACJ;;AAKD,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA,YAAA;AACI,aAAO,KAAK,SAAZ;AACH,KAFkB;qBAAA;;AAAA,GAAnB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,aAAO,KAAK,YAAZ;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;AAH1B;;;SAGA,YAAA;AACI,aAAO,KAAK,gBAAL,IAAyB,KAAK,oBAArC;AACH,KAFyB;qBAAA;;AAAA,GAA1B;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,kBAAX,EAA2B;AAH3B;;;SAGA,YAAA;AACI,aAAO,KAAK,iBAAL,IAA0B,KAAK,qBAAtC;AACH,KAF0B;qBAAA;;AAAA,GAA3B;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,aAAO,KAAK,YAAL,IAAqB,KAAK,gBAAjC;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,MAArB;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAHzB;;;SAGA,YAAA;AACI,aAAO,KAAK,cAAL,CAAoB,MAA3B;AACH,KAFwB;qBAAA;;AAAA,GAAzB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,WAAZ;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAIA;;;;;;AAKO,EAAA,kBAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAoC;AAChC,WAAO,KAAK,cAAL,CAAoB,IAApB,CAAyB,KAAzB,CAAP;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,kBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAA8B;AAC1B,WAAO,KAAK,QAAL,CAAc,KAAd,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,MAAjB,EAAoC;AAApC,QAAA,KAAA,GAAA,IAAA;;AACI,SAAK,QAAL,CAAc,IAAd,CAAmB,MAAnB;;AACA,SAAK,gCAAL,CAAsC,IAAtC,CAA2C,MAAM,CAAC,kBAAP,CAA0B,GAA1B,CAA8B,UAAC,UAAD,EAAW;AAChF,MAAA,KAAI,CAAC,kBAAL,CAAwB,UAAxB;AACH,KAF0C,CAA3C;;AAGA,SAAK,iCAAL,CAAuC,IAAvC,CAA4C,MAAM,CAAC,oBAAP,CAA4B,GAA5B,CAAgC,YAAA;AACxE,MAAA,KAAI,CAAC,kBAAL,CAAwB,IAAxB;AACH,KAF2C,CAA5C;;AAGA,SAAK,kBAAL,CAAwB,IAAxB;AACH,GATM;AAWP;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,MAApB,EAAuC;AACnC,QAAI,KAAK,GAAG,KAAK,QAAL,CAAc,OAAd,CAAsB,MAAtB,CAAZ;;AACA,QAAI,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAK,QAAL,CAAc,MAAd,CAAqB,KAArB,EAA4B,CAA5B;;AAEA,MAAA,MAAM,CAAC,kBAAP,CAA0B,MAA1B,CAAiC,KAAK,gCAAL,CAAsC,MAAtC,CAA6C,KAA7C,EAAoD,CAApD,EAAuD,CAAvD,CAAjC;;AACA,MAAA,MAAM,CAAC,oBAAP,CAA4B,MAA5B,CAAmC,KAAK,iCAAL,CAAuC,MAAvC,CAA8C,KAA9C,EAAqD,CAArD,EAAwD,CAAxD,CAAnC;;AACA,WAAK,kBAAL,CAAwB,IAAxB;AACH;AACJ,GATM;AAWP;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,IAAI,kBAAJ,CAAuB,KAAK,MAA5B,CAAX;;AAEA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAkC;AAA7B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,IAAI,CAAC,SAAL,CAAe,MAAM,CAAC,KAAP,EAAf;AACH;;AAED,IAAA,IAAI,CAAC,oBAAL,GAA4B,KAAK,oBAAjC;AACA,IAAA,IAAI,CAAC,qBAAL,GAA6B,KAAK,qBAAlC;AACA,IAAA,IAAI,CAAC,gBAAL,GAAwB,KAAK,gBAA7B;AAEA,WAAO,IAAP;AACH,GAZM;AAcP;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,mBAAmB,GAAQ,EAA/B;AAEA,IAAA,mBAAmB,CAAC,EAApB,GAAyB,KAAK,QAA9B;AAEA,IAAA,mBAAmB,CAAC,OAApB,GAA8B,EAA9B;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAkC;AAA7B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,mBAAmB,CAAC,OAApB,CAA4B,IAA5B,CAAiC,MAAM,CAAC,SAAP,EAAjC;AACH;;AAED,WAAO,mBAAP;AACH,GAXM;;AAaC,EAAA,kBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,UAA3B,EAA8C;AAC1C,QAAI,cAAc,GAAG,CAArB;;AACA,SAAK,cAAL,CAAoB,KAApB;;AACA,SAAK,gBAAL,GAAwB,IAAxB;AACA,SAAK,iBAAL,GAAyB,IAAzB;AACA,SAAK,YAAL,GAAoB,IAApB;AACA,SAAK,YAAL,GAAoB,CAApB;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAkC;AAA7B,UAAI,MAAM,GAAA,EAAA,CAAA,EAAA,CAAV;;AACD,UAAI,MAAM,CAAC,SAAP,KAAqB,CAAzB,EAA4B;AACxB;AACH;;AAED,WAAK,cAAL,CAAoB,IAApB,CAAyB,MAAzB;;AACA,WAAK,eAAL,CAAqB,cAAc,EAAnC,IAAyC,MAAM,CAAC,SAAhD;AAEA,WAAK,gBAAL,GAAwB,KAAK,gBAAL,IAAyB,MAAM,CAAC,UAAxD;AACA,WAAK,iBAAL,GAAyB,KAAK,iBAAL,IAA0B,MAAM,CAAC,WAA1D;AACA,WAAK,YAAL,GAAoB,KAAK,YAAL,IAAqB,MAAM,CAAC,MAAhD;AAEA,UAAM,SAAS,GAAG,MAAM,CAAC,YAAP,EAAlB;;AACA,UAAI,SAAJ,EAAe;AACX,YAAM,WAAW,GAAG,SAAS,CAAC,MAAV,GAAmB,CAAvC;;AACA,YAAI,KAAK,YAAL,KAAsB,CAA1B,EAA6B;AACzB,eAAK,YAAL,GAAoB,WAApB;AACH,SAFD,MAGK,IAAI,KAAK,YAAL,KAAsB,WAA1B,EAAuC;AACxC,UAAA,MAAM,CAAC,KAAP,CAAa,qEAAb;AACA;AACH;AACJ;AACJ;;AAED,QAAI,CAAC,KAAK,WAAN,IAAqB,KAAK,WAAL,CAAiB,MAAjB,KAA4B,cAArD,EAAqE;AACjE,WAAK,WAAL,GAAmB,IAAI,YAAJ,CAAiB,cAAjB,CAAnB;AACH;;AAED,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,cAA5B,EAA4C,KAAK,EAAjD,EAAqD;AACjD,WAAK,WAAL,CAAiB,KAAjB,IAA0B,KAAK,eAAL,CAAqB,KAArB,CAA1B;AACH;;AAED,QAAI,UAAJ,EAAgB;AACZ,WAAK,WAAL;AACH;AACJ,GA3CO;AA6CR;;;;;AAGO,EAAA,kBAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,QAAI,CAAC,KAAK,MAAV,EAAkB;AACd;AACH,KAHL,CAII;;;AACA,SAAiB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,MAAL,CAAY,MAA7B,EAAiB,EAAA,GAAA,EAAA,CAAA,MAAjB,EAAiB,EAAA,EAAjB,EAAqC;AAAhC,UAAI,IAAI,GAAA,EAAA,CAAA,EAAA,CAAR;;AACD,UAAU,IAAK,CAAC,kBAAN,KAA6B,IAAvC,EAA6C;AAClC,QAAA,IAAK,CAAC,mCAAN;AACV;AACJ;AACJ,GAVM,CA1OX,CAsPI;;AAEA;;;;;;;;AAMc,EAAA,kBAAA,CAAA,KAAA,GAAd,UAAoB,mBAApB,EAA8C,KAA9C,EAA0D;AACtD,QAAI,MAAM,GAAG,IAAI,kBAAJ,CAAuB,KAAvB,CAAb;AAEA,IAAA,MAAM,CAAC,SAAP,GAAmB,mBAAmB,CAAC,EAAvC;;AAEA,SAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,mBAAmB,CAAC,OAA3C,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAAoD;AAA/C,UAAI,UAAU,GAAA,EAAA,CAAA,EAAA,CAAd;AACD,MAAA,MAAM,CAAC,SAAP,CAAiB,WAAW,CAAC,KAAZ,CAAkB,UAAlB,CAAjB;AACH;;AAED,WAAO,MAAP;AACH,GAVa;;AAWlB,SAAA,kBAAA;AAAC,CAzQD,EAAA","sourcesContent":["import { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\r\nexport class MorphTargetManager {\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _vertexCount = 0;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.morphTargetManagers.push(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        return this._influences;\r\n    }\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {\r\n            this._syncActiveTargets(needUpdate);\r\n        }));\r\n        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {\r\n            this._syncActiveTargets(true);\r\n        }));\r\n        this._syncActiveTargets(true);\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        var index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._syncActiveTargets(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        let copy = new MorphTargetManager(this._scene);\r\n\r\n        for (var target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (var target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate: boolean): void {\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._vertexCount = 0;\r\n        for (var target of this._targets) {\r\n            if (target.influence === 0) {\r\n                continue;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n\r\n            const positions = target.getPositions();\r\n            if (positions) {\r\n                const vertexCount = positions.length / 3;\r\n                if (this._vertexCount === 0) {\r\n                    this._vertexCount = vertexCount;\r\n                }\r\n                else if (this._vertexCount !== vertexCount) {\r\n                    Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (var index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this.synchronize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Syncrhonize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (var mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        var result = new MorphTargetManager(scene);\r\n\r\n        result._uniqueId = serializationObject.id;\r\n\r\n        for (var targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}