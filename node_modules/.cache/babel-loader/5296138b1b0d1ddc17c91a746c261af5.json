{"ast":null,"code":"import { Tools } from './tools';\nimport { Texture } from '../Materials/Textures/texture';\nimport { InternalTexture, InternalTextureSource } from '../Materials/Textures/internalTexture';\nimport { Scalar } from '../Maths/math.scalar';\n/**\r\n * Info about the .basis files\r\n */\n\nvar BasisFileInfo =\n/** @class */\nfunction () {\n  function BasisFileInfo() {}\n\n  return BasisFileInfo;\n}();\n/**\r\n * Result of transcoding a basis file\r\n */\n\n\nvar TranscodeResult =\n/** @class */\nfunction () {\n  function TranscodeResult() {}\n\n  return TranscodeResult;\n}();\n/**\r\n * Configuration options for the Basis transcoder\r\n */\n\n\nvar BasisTranscodeConfiguration =\n/** @class */\nfunction () {\n  function BasisTranscodeConfiguration() {}\n\n  return BasisTranscodeConfiguration;\n}();\n\nexport { BasisTranscodeConfiguration };\n/**\r\n * @hidden\r\n * Enum of basis transcoder formats\r\n */\n\nvar BASIS_FORMATS;\n\n(function (BASIS_FORMATS) {\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 1] = \"cTFBC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 2] = \"cTFBC4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_OPAQUE_ONLY\"] = 3] = \"cTFPVRTC1_4_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7_M6_OPAQUE_ONLY\"] = 4] = \"cTFBC7_M6_OPAQUE_ONLY\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 5] = \"cTFETC2\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 6] = \"cTFBC3\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 7] = \"cTFBC5\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\n\n\nvar BasisTools =\n/** @class */\nfunction () {\n  function BasisTools() {}\n  /**\r\n   * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n   * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n   * @returns internal format corresponding to the Basis format\r\n   */\n\n\n  BasisTools.GetInternalFormatFromBasisFormat = function (basisFormat) {\n    // Corrisponding internal formats\n    var COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\n    var COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n    var RGB_ETC1_Format = 36196;\n\n    if (basisFormat === BASIS_FORMATS.cTFETC1) {\n      return RGB_ETC1_Format;\n    } else if (basisFormat === BASIS_FORMATS.cTFBC1) {\n      return COMPRESSED_RGB_S3TC_DXT1_EXT;\n    } else if (basisFormat === BASIS_FORMATS.cTFBC3) {\n      return COMPRESSED_RGBA_S3TC_DXT5_EXT;\n    } else {\n      throw \"The chosen Basis transcoder format is not currently supported\";\n    }\n  };\n\n  BasisTools._CreateWorkerAsync = function () {\n    var _this = this;\n\n    if (!this._WorkerPromise) {\n      this._WorkerPromise = new Promise(function (res) {\n        if (_this._Worker) {\n          res(_this._Worker);\n        } else {\n          Tools.LoadFileAsync(BasisTools.WasmModuleURL).then(function (wasmBinary) {\n            var workerBlobUrl = URL.createObjectURL(new Blob([\"(\" + workerFunc + \")()\"], {\n              type: \"application/javascript\"\n            }));\n            _this._Worker = new Worker(workerBlobUrl);\n\n            var initHandler = function (msg) {\n              if (msg.data.action === \"init\") {\n                _this._Worker.removeEventListener(\"message\", initHandler);\n\n                res(_this._Worker);\n              }\n            };\n\n            _this._Worker.addEventListener(\"message\", initHandler);\n\n            _this._Worker.postMessage({\n              action: \"init\",\n              url: BasisTools.JSModuleURL,\n              wasmBinary: wasmBinary\n            });\n          });\n        }\n      });\n    }\n\n    return this._WorkerPromise;\n  };\n  /**\r\n   * Transcodes a loaded image file to compressed pixel data\r\n   * @param data image data to transcode\r\n   * @param config configuration options for the transcoding\r\n   * @returns a promise resulting in the transcoded image\r\n   */\n\n\n  BasisTools.TranscodeAsync = function (data, config) {\n    var _this = this;\n\n    var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n    return new Promise(function (res, rej) {\n      _this._CreateWorkerAsync().then(function () {\n        var actionId = _this._actionId++;\n\n        var messageHandler = function (msg) {\n          if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n            _this._Worker.removeEventListener(\"message\", messageHandler);\n\n            if (!msg.data.success) {\n              rej(\"Transcode is not supported on this device\");\n            } else {\n              res(msg.data);\n            }\n          }\n        };\n\n        _this._Worker.addEventListener(\"message\", messageHandler);\n\n        var dataViewCopy = new Uint8Array(dataView.byteLength);\n        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n\n        _this._Worker.postMessage({\n          action: \"transcode\",\n          id: actionId,\n          imageData: dataViewCopy,\n          config: config,\n          ignoreSupportedFormats: _this._IgnoreSupportedFormats\n        }, [dataViewCopy.buffer]);\n      });\n    });\n  };\n  /**\r\n   * Loads a texture from the transcode result\r\n   * @param texture texture load to\r\n   * @param transcodeResult the result of transcoding the basis file to load from\r\n   */\n\n\n  BasisTools.LoadTextureFromTranscodeResult = function (texture, transcodeResult) {\n    var engine = texture.getEngine();\n\n    var _loop_1 = function () {\n      rootImage = transcodeResult.fileInfo.images[i].levels[0];\n      texture._invertVScale = texture.invertY;\n\n      if (transcodeResult.format === -1) {\n        // No compatable compressed format found, fallback to RGB\n        texture.type = 10;\n        texture.format = 4;\n\n        if (engine.webGLVersion < 2 && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n          // Create non power of two texture\n          var source_1 = new InternalTexture(engine, InternalTextureSource.Temp);\n          texture._invertVScale = texture.invertY;\n          source_1.type = 10;\n          source_1.format = 4; // Fallback requires aligned width/height\n\n          source_1.width = rootImage.width + 3 & ~3;\n          source_1.height = rootImage.height + 3 & ~3;\n\n          engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source_1, true);\n\n          engine._uploadDataToTextureDirectly(source_1, rootImage.transcodedPixels, i, 0, 4, true); // Resize to power of two\n\n\n          engine._rescaleTexture(source_1, texture, engine.scenes[0], engine._getInternalFormat(4), function () {\n            engine._releaseTexture(source_1);\n\n            engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);\n          });\n        } else {\n          // Fallback is already inverted\n          texture._invertVScale = !texture.invertY; // Upload directly\n\n          texture.width = rootImage.width + 3 & ~3;\n          texture.height = rootImage.height + 3 & ~3;\n\n          engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, 4, true);\n        }\n      } else {\n        texture.width = rootImage.width;\n        texture.height = rootImage.height; // Upload all mip levels in the file\n\n        transcodeResult.fileInfo.images[i].levels.forEach(function (level, index) {\n          engine._uploadCompressedDataToTextureDirectly(texture, BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format), level.width, level.height, level.transcodedPixels, i, index);\n        });\n\n        if (engine.webGLVersion < 2 && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n          Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n          texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n          texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n      }\n    };\n\n    var rootImage;\n\n    for (var i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n      _loop_1();\n    }\n  };\n\n  BasisTools._IgnoreSupportedFormats = false;\n  /**\r\n   * URL to use when loading the basis transcoder\r\n   */\n\n  BasisTools.JSModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js\";\n  /**\r\n   * URL to use when loading the wasm module for the transcoder\r\n   */\n\n  BasisTools.WasmModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm\";\n  BasisTools._WorkerPromise = null;\n  BasisTools._Worker = null;\n  BasisTools._actionId = 0;\n  return BasisTools;\n}();\n\nexport { BasisTools };\n\nfunction workerFunc() {\n  var _BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFBC1: 1,\n    cTFBC4: 2,\n    cTFPVRTC1_4_OPAQUE_ONLY: 3,\n    cTFBC7_M6_OPAQUE_ONLY: 4,\n    cTFETC2: 5,\n    cTFBC3: 6,\n    cTFBC5: 7\n  };\n  var transcoderModulePromise = null;\n\n  onmessage = function (event) {\n    if (event.data.action === \"init\") {\n      // Load the transcoder if it hasn't been yet\n      if (!transcoderModulePromise) {\n        // Override wasm binary\n        Module = {\n          wasmBinary: event.data.wasmBinary\n        };\n        importScripts(event.data.url);\n        transcoderModulePromise = new Promise(function (res) {\n          Module.onRuntimeInitialized = function () {\n            Module.initializeBasis();\n            res();\n          };\n        });\n      }\n\n      transcoderModulePromise.then(function () {\n        postMessage({\n          action: \"init\"\n        });\n      });\n    } else if (event.data.action === \"transcode\") {\n      // Transcode the basis image and return the resulting pixels\n      var config = event.data.config;\n      var imgData = event.data.imageData;\n      var loadedFile = new Module.BasisFile(imgData);\n      var fileInfo = GetFileInfo(loadedFile);\n      var format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n      var needsConversion = false;\n\n      if (format === null) {\n        needsConversion = true;\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } // Begin transcode\n\n\n      var success = true;\n\n      if (!loadedFile.startTranscoding()) {\n        success = false;\n      }\n\n      var buffers = [];\n\n      for (var imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n        if (!success) {\n          break;\n        }\n\n        var image = fileInfo.images[imageIndex];\n\n        if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n          var mipCount = image.levels.length;\n\n          if (config.loadMipmapLevels === false) {\n            mipCount = 1;\n          }\n\n          for (var levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n            var levelInfo = image.levels[levelIndex];\n            var pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n\n            if (!pixels) {\n              success = false;\n              break;\n            }\n\n            levelInfo.transcodedPixels = pixels;\n            buffers.push(levelInfo.transcodedPixels.buffer);\n          }\n        }\n      } // Close file\n\n\n      loadedFile.close();\n      loadedFile.delete();\n\n      if (needsConversion) {\n        format = -1;\n      }\n\n      if (!success) {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id\n        });\n      } else {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id,\n          fileInfo: fileInfo,\n          format: format\n        }, buffers);\n      }\n    }\n  };\n  /**\r\n   * Detects the supported transcode format for the file\r\n   * @param config transcode config\r\n   * @param fileInfo info about the file\r\n   * @returns the chosed format or null if none are supported\r\n   */\n\n\n  function GetSupportedTranscodeFormat(config, fileInfo) {\n    var format = null;\n\n    if (config.supportedCompressionFormats) {\n      if (config.supportedCompressionFormats.etc1) {\n        format = _BASIS_FORMAT.cTFETC1;\n      } else if (config.supportedCompressionFormats.s3tc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } else if (config.supportedCompressionFormats.pvrtc) {// TODO uncomment this after pvrtc bug is fixed is basis transcoder\n        // See discussion here: https://github.com/mrdoob/three.js/issues/16524#issuecomment-498929924\n        // format = _BASIS_FORMAT.cTFPVRTC1_4_OPAQUE_ONLY;\n      } else if (config.supportedCompressionFormats.etc2) {\n        format = _BASIS_FORMAT.cTFETC2;\n      }\n    }\n\n    return format;\n  }\n  /**\r\n   * Retreives information about the basis file eg. dimensions\r\n   * @param basisFile the basis file to get the info from\r\n   * @returns information about the basis file\r\n   */\n\n\n  function GetFileInfo(basisFile) {\n    var hasAlpha = basisFile.getHasAlpha();\n    var imageCount = basisFile.getNumImages();\n    var images = [];\n\n    for (var i = 0; i < imageCount; i++) {\n      var imageInfo = {\n        levels: []\n      };\n      var levelCount = basisFile.getNumLevels(i);\n\n      for (var level = 0; level < levelCount; level++) {\n        var levelInfo = {\n          width: basisFile.getImageWidth(i, level),\n          height: basisFile.getImageHeight(i, level)\n        };\n        imageInfo.levels.push(levelInfo);\n      }\n\n      images.push(imageInfo);\n    }\n\n    var info = {\n      hasAlpha: hasAlpha,\n      images: images\n    };\n    return info;\n  }\n\n  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n    var dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n    var dst = new Uint8Array(dstSize);\n\n    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n      return null;\n    } // If no supported format is found, load as dxt and convert to rgb565\n\n\n    if (convertToRgb565) {\n      var alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;\n      var alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;\n      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n    }\n\n    return dst;\n  }\n  /**\r\n   * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n   * An unoptimized version of dxtToRgb565.  Also, the floating\r\n   * point math used to compute the colors actually results in\r\n   * slightly different colors compared to hardware DXT decoders.\r\n   * @param src dxt src pixels\r\n   * @param srcByteOffset offset for the start of src\r\n   * @param  width aligned width of the image\r\n   * @param  height aligned height of the image\r\n   * @return the converted pixels\r\n   */\n\n\n  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n    var c = new Uint16Array(4);\n    var dst = new Uint16Array(width * height);\n    var blockWidth = width / 4;\n    var blockHeight = height / 4;\n\n    for (var blockY = 0; blockY < blockHeight; blockY++) {\n      for (var blockX = 0; blockX < blockWidth; blockX++) {\n        var i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n        c[0] = src[i] | src[i + 1] << 8;\n        c[1] = src[i + 2] | src[i + 3] << 8;\n        c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;\n        c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;\n\n        for (var row = 0; row < 4; row++) {\n          var m = src[i + 4 + row];\n          var dstI = (blockY * 4 + row) * width + blockX * 4;\n          dst[dstI++] = c[m & 0x3];\n          dst[dstI++] = c[m >> 2 & 0x3];\n          dst[dstI++] = c[m >> 4 & 0x3];\n          dst[dstI++] = c[m >> 6 & 0x3];\n        }\n      }\n    }\n\n    return dst;\n  }\n}","map":{"version":3,"sources":["../../../sourceES6/core/Misc/basis.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from '../types';\r\nimport { Tools } from './tools';\r\nimport { Texture } from '../Materials/Textures/texture';\r\nimport { InternalTexture, InternalTextureSource } from '../Materials/Textures/internalTexture';\r\nimport { Scalar } from '../Maths/math.scalar';\r\n\r\nimport { Engine } from '../Engines/engine';\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nclass BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{levels: Array<{width: number, height: number, transcodedPixels: ArrayBufferView}>}>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFBC1 = 1,\r\n    cTFBC4 = 2,\r\n    cTFPVRTC1_4_OPAQUE_ONLY = 3,\r\n    cTFBC7_M6_OPAQUE_ONLY = 4,\r\n    cTFETC2 = 5,\r\n    cTFBC3 = 6,\r\n    cTFBC5 = 7\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport class BasisTools {\r\n    private static _IgnoreSupportedFormats = false;\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    public static JSModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.js\";\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    public static WasmModuleURL = \"https://preview.babylonjs.com/basisTranscoder/basis_transcoder.wasm\";\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    public static GetInternalFormatFromBasisFormat(basisFormat: number) {\r\n        // Corrisponding internal formats\r\n        var COMPRESSED_RGB_S3TC_DXT1_EXT  = 0x83F0;\r\n        var COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\r\n        var RGB_ETC1_Format = 36196;\r\n\r\n        if (basisFormat === BASIS_FORMATS.cTFETC1) {\r\n            return RGB_ETC1_Format;\r\n        }else if (basisFormat === BASIS_FORMATS.cTFBC1) {\r\n            return COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n        }else if (basisFormat === BASIS_FORMATS.cTFBC3) {\r\n            return COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n        }else {\r\n            throw \"The chosen Basis transcoder format is not currently supported\";\r\n        }\r\n    }\r\n\r\n    private static _WorkerPromise: Nullable<Promise<Worker>> = null;\r\n    private static _Worker: Nullable<Worker> = null;\r\n    private static _actionId = 0;\r\n    private static _CreateWorkerAsync() {\r\n        if (!this._WorkerPromise) {\r\n            this._WorkerPromise = new Promise((res) => {\r\n                if (this._Worker) {\r\n                    res(this._Worker);\r\n                }else {\r\n                    Tools.LoadFileAsync(BasisTools.WasmModuleURL).then((wasmBinary) => {\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc})()`], { type: \"application/javascript\" }));\r\n                        this._Worker = new Worker(workerBlobUrl);\r\n\r\n                        var initHandler = (msg: any) => {\r\n                            if (msg.data.action === \"init\") {\r\n                                this._Worker!.removeEventListener(\"message\", initHandler);\r\n                                res(this._Worker!);\r\n                            }\r\n                        };\r\n                        this._Worker.addEventListener(\"message\", initHandler);\r\n                        this._Worker.postMessage({action: \"init\", url: BasisTools.JSModuleURL, wasmBinary: wasmBinary});\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._WorkerPromise;\r\n    }\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    public static TranscodeAsync(data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> {\r\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n        return new Promise((res, rej) => {\r\n            this._CreateWorkerAsync().then(() => {\r\n                var actionId = this._actionId++;\r\n                var messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        this._Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        }else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                this._Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                this._Worker!.postMessage({action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: this._IgnoreSupportedFormats}, [dataViewCopy.buffer]);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    public static LoadTextureFromTranscodeResult(texture: InternalTexture, transcodeResult: TranscodeResult) {\r\n        let engine = texture.getEngine() as Engine;\r\n        for (var i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n            var rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n            texture._invertVScale = texture.invertY;\r\n            if (transcodeResult.format === -1) {\r\n                // No compatable compressed format found, fallback to RGB\r\n                texture.type = 10;\r\n                texture.format = 4;\r\n\r\n                if (engine.webGLVersion < 2 && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\r\n                    // Create non power of two texture\r\n                    let source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                    texture._invertVScale = texture.invertY;\r\n                    source.type = 10;\r\n                    source.format = 4;\r\n                    // Fallback requires aligned width/height\r\n                    source.width = (rootImage.width + 3) & ~3;\r\n                    source.height = (rootImage.height + 3) & ~3;\r\n                    engine._bindTextureDirectly(engine._gl.TEXTURE_2D, source, true);\r\n                    engine._uploadDataToTextureDirectly(source, rootImage.transcodedPixels, i, 0, 4, true);\r\n\r\n                    // Resize to power of two\r\n                    engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {\r\n                        engine._releaseTexture(source);\r\n                        engine._bindTextureDirectly(engine._gl.TEXTURE_2D, texture, true);\r\n                    });\r\n                } else {\r\n                    // Fallback is already inverted\r\n                    texture._invertVScale = !texture.invertY;\r\n\r\n                    // Upload directly\r\n                    texture.width = (rootImage.width + 3) & ~3;\r\n                    texture.height = (rootImage.height + 3) & ~3;\r\n                    engine._uploadDataToTextureDirectly(texture, rootImage.transcodedPixels, i, 0, 4, true);\r\n                }\r\n\r\n            }else {\r\n                texture.width = rootImage.width;\r\n                texture.height = rootImage.height;\r\n\r\n                // Upload all mip levels in the file\r\n                transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                    engine._uploadCompressedDataToTextureDirectly(texture, BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!), level.width, level.height, level.transcodedPixels, i, index);\r\n                });\r\n\r\n                if (engine.webGLVersion < 2 && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\r\n                    Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\r\n                    texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare var Module: any;\r\nfunction workerFunc(): void {\r\n    var _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFBC1: 1,\r\n        cTFBC4: 2,\r\n        cTFPVRTC1_4_OPAQUE_ONLY: 3,\r\n        cTFBC7_M6_OPAQUE_ONLY: 4,\r\n        cTFETC2: 5,\r\n        cTFBC3: 6,\r\n        cTFBC5: 7,\r\n    };\r\n    var transcoderModulePromise: Nullable<Promise<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n             // Load the transcoder if it hasn't been yet\r\n            if (!transcoderModulePromise) {\r\n                // Override wasm binary\r\n                Module = { wasmBinary: (event.data.wasmBinary) };\r\n                importScripts(event.data.url);\r\n                transcoderModulePromise = new Promise((res) => {\r\n                    Module.onRuntimeInitialized = () => {\r\n                        Module.initializeBasis();\r\n                        res();\r\n                    };\r\n                });\r\n            }\r\n            transcoderModulePromise.then(() => {\r\n                postMessage({action: \"init\"});\r\n            });\r\n        }else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            var config: BasisTranscodeConfiguration = event.data.config;\r\n            var imgData = event.data.imageData;\r\n            var loadedFile = new Module.BasisFile(imgData);\r\n            var fileInfo = GetFileInfo(loadedFile);\r\n            var format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            var needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            var success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            var buffers: Array<any> = [];\r\n            for (var imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                var image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    var mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (var levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        var levelInfo = image.levels[levelIndex];\r\n\r\n                        var pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({action: \"transcode\", success: success, id: event.data.id});\r\n            }else {\r\n                postMessage({action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format}, buffers);\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        var format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            }else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }else if (config.supportedCompressionFormats.pvrtc) {\r\n                // TODO uncomment this after pvrtc bug is fixed is basis transcoder\r\n                // See discussion here: https://github.com/mrdoob/three.js/issues/16524#issuecomment-498929924\r\n                // format = _BASIS_FORMAT.cTFPVRTC1_4_OPAQUE_ONLY;\r\n            }else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retreives information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        var hasAlpha = basisFile.getHasAlpha();\r\n        var imageCount = basisFile.getNumImages();\r\n        var images = [];\r\n        for (var i = 0; i < imageCount; i++) {\r\n            var imageInfo = {\r\n                levels: ([] as Array<any>)\r\n            };\r\n            var levelCount = basisFile.getNumLevels(i);\r\n            for (var level = 0; level < levelCount; level++) {\r\n                var levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level)\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        var info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint16Array> {\r\n        var dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        var dst = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            var alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            var alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @return the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        var c = new Uint16Array(4);\r\n        var dst = new Uint16Array(width * height);\r\n\r\n        var blockWidth = width / 4;\r\n        var blockHeight = height / 4;\r\n        for (var blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (var blockX = 0; blockX < blockWidth; blockX++) {\r\n            var i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n            c[0] = src[i] | (src[i + 1] << 8);\r\n            c[1] = src[i + 2] | (src[i + 3] << 8);\r\n            c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3\r\n                    | (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0)\r\n                    | (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n            c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3\r\n                    | (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0)\r\n                    | (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n            for (var row = 0; row < 4; row++) {\r\n                var m = src[i + 4 + row];\r\n                var dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                dst[dstI++] = c[m & 0x3];\r\n                dst[dstI++] = c[(m >> 2) & 0x3];\r\n                dst[dstI++] = c[(m >> 4) & 0x3];\r\n                dst[dstI++] = c[(m >> 6) & 0x3];\r\n            }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}