{"ast":null,"code":"import { Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Color4 } from '../Maths/math.color';\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\n\nvar currentCSGMeshId = 0;\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\n\nvar Vertex =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the vertex\r\n   * @param pos The position of the vertex\r\n   * @param normal The normal of the vertex\r\n   * @param uv The texture coordinate of the vertex\r\n   * @param vertColor The RGBA color of the vertex\r\n   */\n  function Vertex(\n  /**\r\n   * The position of the vertex\r\n   */\n  pos,\n  /**\r\n   * The normal of the vertex\r\n   */\n  normal,\n  /**\r\n   * The texture coordinate of the vertex\r\n   */\n  uv,\n  /**\r\n   * The texture coordinate of the vertex\r\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\r\n   * Make a clone, or deep copy, of the vertex\r\n   * @returns A new Vertex\r\n   */\n\n\n  Vertex.prototype.clone = function () {\n    var _a, _b;\n\n    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n  };\n  /**\r\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n   * orientation of a polygon is flipped.\r\n   */\n\n\n  Vertex.prototype.flip = function () {\n    this.normal = this.normal.scale(-1);\n  };\n  /**\r\n   * Create a new vertex between this vertex and `other` by linearly\r\n   * interpolating all properties using a parameter of `t`. Subclasses should\r\n   * override this to interpolate additional properties.\r\n   * @param other the vertex to interpolate against\r\n   * @param t The factor used to linearly interpolate between the vertices\r\n   */\n\n\n  Vertex.prototype.interpolate = function (other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  };\n\n  return Vertex;\n}();\n/**\r\n * Represents a plane in 3D space.\r\n */\n\n\nvar Plane =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the plane\r\n   * @param normal The normal for the plane\r\n   * @param w\r\n   */\n  function Plane(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\r\n   * Construct a plane from three points\r\n   * @param a Point a\r\n   * @param b Point b\r\n   * @param c Point c\r\n   */\n\n\n  Plane.FromPoints = function (a, b, c) {\n    var v0 = c.subtract(a);\n    var v1 = b.subtract(a);\n\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n\n    var n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new Plane(n, Vector3.Dot(n, a));\n  };\n  /**\r\n   * Clone, or make a deep copy of the plane\r\n   * @returns a new Plane\r\n   */\n\n\n  Plane.prototype.clone = function () {\n    return new Plane(this.normal.clone(), this.w);\n  };\n  /**\r\n   * Flip the face of the plane\r\n   */\n\n\n  Plane.prototype.flip = function () {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  };\n  /**\r\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n   * fragments in the appropriate lists. Coplanar polygons go into either\r\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n   * respect to this plane. Polygons in front or in back of this plane go into\r\n   * either `front` or `back`\r\n   * @param polygon The polygon to be split\r\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n   * @param front Will contain the polygons in front of the plane\r\n   * @param back Will contain the polygons begind the plane\r\n   */\n\n\n  Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {\n    var COPLANAR = 0;\n    var FRONT = 1;\n    var BACK = 2;\n    var SPANNING = 3; // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n\n    var polygonType = 0;\n    var types = [];\n    var i;\n    var t;\n\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      var type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    } // Put the polygon in the correct list, splitting it when necessary\n\n\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n\n      case FRONT:\n        front.push(polygon);\n        break;\n\n      case BACK:\n        back.push(polygon);\n        break;\n\n      case SPANNING:\n        var f = [],\n            b = [];\n\n        for (i = 0; i < polygon.vertices.length; i++) {\n          var j = (i + 1) % polygon.vertices.length;\n          var ti = types[i],\n              tj = types[j];\n          var vi = polygon.vertices[i],\n              vj = polygon.vertices[j];\n\n          if (ti !== BACK) {\n            f.push(vi);\n          }\n\n          if (ti !== FRONT) {\n            b.push(ti !== BACK ? vi.clone() : vi);\n          }\n\n          if ((ti | tj) === SPANNING) {\n            t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n            var v = vi.interpolate(vj, t);\n            f.push(v);\n            b.push(v.clone());\n          }\n        }\n\n        var poly;\n\n        if (f.length >= 3) {\n          poly = new Polygon(f, polygon.shared);\n\n          if (poly.plane) {\n            front.push(poly);\n          }\n        }\n\n        if (b.length >= 3) {\n          poly = new Polygon(b, polygon.shared);\n\n          if (poly.plane) {\n            back.push(poly);\n          }\n        }\n\n        break;\n    }\n  };\n  /**\r\n   * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n   * point is on the plane\r\n   */\n\n\n  Plane.EPSILON = 1e-5;\n  return Plane;\n}();\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the polygon\r\n   * @param vertices The vertices of the polygon\r\n   * @param shared The properties shared across all polygons\r\n   */\n  function Polygon(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\r\n   * Clones, or makes a deep copy, or the polygon\r\n   */\n\n\n  Polygon.prototype.clone = function () {\n    var vertices = this.vertices.map(function (v) {\n      return v.clone();\n    });\n    return new Polygon(vertices, this.shared);\n  };\n  /**\r\n   * Flips the faces of the polygon\r\n   */\n\n\n  Polygon.prototype.flip = function () {\n    this.vertices.reverse().map(function (v) {\n      v.flip();\n    });\n    this.plane.flip();\n  };\n\n  return Polygon;\n}();\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the node\r\n   * @param polygons A collection of polygons held in the node\r\n   */\n  function Node(polygons) {\n    this.plane = null;\n    this.front = null;\n    this.back = null;\n    this.polygons = new Array();\n\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\r\n   * Clones, or makes a deep copy, of the node\r\n   * @returns The cloned node\r\n   */\n\n\n  Node.prototype.clone = function () {\n    var node = new Node();\n    node.plane = this.plane && this.plane.clone();\n    node.front = this.front && this.front.clone();\n    node.back = this.back && this.back.clone();\n    node.polygons = this.polygons.map(function (p) {\n      return p.clone();\n    });\n    return node;\n  };\n  /**\r\n   * Convert solid space to empty space and empty space to solid space\r\n   */\n\n\n  Node.prototype.invert = function () {\n    for (var i = 0; i < this.polygons.length; i++) {\n      this.polygons[i].flip();\n    }\n\n    if (this.plane) {\n      this.plane.flip();\n    }\n\n    if (this.front) {\n      this.front.invert();\n    }\n\n    if (this.back) {\n      this.back.invert();\n    }\n\n    var temp = this.front;\n    this.front = this.back;\n    this.back = temp;\n  };\n  /**\r\n   * Recursively remove all polygons in `polygons` that are inside this BSP\r\n   * tree.\r\n   * @param polygons Polygons to remove from the BSP\r\n   * @returns Polygons clipped from the BSP\r\n   */\n\n\n  Node.prototype.clipPolygons = function (polygons) {\n    if (!this.plane) {\n      return polygons.slice();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n\n    if (this.front) {\n      front = this.front.clipPolygons(front);\n    }\n\n    if (this.back) {\n      back = this.back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n\n    return front.concat(back);\n  };\n  /**\r\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n   * `bsp`.\r\n   * @param bsp BSP containing polygons to remove from this BSP\r\n   */\n\n\n  Node.prototype.clipTo = function (bsp) {\n    this.polygons = bsp.clipPolygons(this.polygons);\n\n    if (this.front) {\n      this.front.clipTo(bsp);\n    }\n\n    if (this.back) {\n      this.back.clipTo(bsp);\n    }\n  };\n  /**\r\n   * Return a list of all polygons in this BSP tree\r\n   * @returns List of all polygons in this BSP tree\r\n   */\n\n\n  Node.prototype.allPolygons = function () {\n    var polygons = this.polygons.slice();\n\n    if (this.front) {\n      polygons = polygons.concat(this.front.allPolygons());\n    }\n\n    if (this.back) {\n      polygons = polygons.concat(this.back.allPolygons());\n    }\n\n    return polygons;\n  };\n  /**\r\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n   * new polygons are filtered down to the bottom of the tree and become new\r\n   * nodes there. Each set of polygons is partitioned using the first polygon\r\n   * (no heuristic is used to pick a good split)\r\n   * @param polygons Polygons used to construct the BSP tree\r\n   */\n\n\n  Node.prototype.build = function (polygons) {\n    if (!polygons.length) {\n      return;\n    }\n\n    if (!this.plane) {\n      this.plane = polygons[0].plane.clone();\n    }\n\n    var front = new Array(),\n        back = new Array();\n\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n\n    if (front.length) {\n      if (!this.front) {\n        this.front = new Node();\n      }\n\n      this.front.build(front);\n    }\n\n    if (back.length) {\n      if (!this.back) {\n        this.back = new Node();\n      }\n\n      this.back.build(back);\n    }\n  };\n\n  return Node;\n}();\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\n\n\nvar CSG =\n/** @class */\nfunction () {\n  function CSG() {\n    this.polygons = new Array();\n  }\n  /**\r\n   * Convert the Mesh to CSG\r\n   * @param mesh The Mesh to convert to CSG\r\n   * @returns A new CSG from the Mesh\r\n   */\n\n\n  CSG.FromMesh = function (mesh) {\n    var vertex,\n        normal,\n        uv = undefined,\n        position,\n        vertColor = undefined,\n        polygon,\n        polygons = new Array(),\n        vertices;\n    var matrix,\n        meshPosition,\n        meshRotation,\n        meshRotationQuaternion = null,\n        meshScaling;\n\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n\n      meshScaling = mesh.scaling.clone();\n    } else {\n      throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';\n    }\n\n    var indices = mesh.getIndices(),\n        positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n        normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n        uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n        vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var subMeshes = mesh.subMeshes;\n\n    for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n\n        for (var j = 0; j < 3; j++) {\n          var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);\n\n          if (uvs) {\n            uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);\n          }\n\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[i + j] * 4], vertColors[indices[i + j] * 4 + 1], vertColors[indices[i + j] * 4 + 2], vertColors[indices[i + j] * 4 + 3]);\n          }\n\n          var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n\n        polygon = new Polygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        }); // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n\n    var csg = CSG.FromPolygons(polygons);\n    csg.matrix = matrix;\n    csg.position = meshPosition;\n    csg.rotation = meshRotation;\n    csg.scaling = meshScaling;\n    csg.rotationQuaternion = meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  };\n  /**\r\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n   * @param polygons Polygons used to construct a CSG solid\r\n   */\n\n\n  CSG.FromPolygons = function (polygons) {\n    var csg = new CSG();\n    csg.polygons = polygons;\n    return csg;\n  };\n  /**\r\n   * Clones, or makes a deep copy, of the CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.clone = function () {\n    var csg = new CSG();\n    csg.polygons = this.polygons.map(function (p) {\n      return p.clone();\n    });\n    csg.copyTransformAttributes(this);\n    return csg;\n  };\n  /**\r\n   * Unions this CSG with another CSG\r\n   * @param csg The CSG to union against this CSG\r\n   * @returns The unioned CSG\r\n   */\n\n\n  CSG.prototype.union = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Unions this CSG with another CSG in place\r\n   * @param csg The CSG to union against this CSG\r\n   */\n\n\n  CSG.prototype.unionInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Subtracts this CSG with another CSG\r\n   * @param csg The CSG to subtract against this CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.subtract = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Subtracts this CSG with another CSG in place\r\n   * @param csg The CSG to subtact against this CSG\r\n   */\n\n\n  CSG.prototype.subtractInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Intersect this CSG with another CSG\r\n   * @param csg The CSG to intersect against this CSG\r\n   * @returns A new CSG\r\n   */\n\n\n  CSG.prototype.intersect = function (csg) {\n    var a = new Node(this.clone().polygons);\n    var b = new Node(csg.clone().polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  };\n  /**\r\n   * Intersects this CSG with another CSG in place\r\n   * @param csg The CSG to intersect against this CSG\r\n   */\n\n\n  CSG.prototype.intersectInPlace = function (csg) {\n    var a = new Node(this.polygons);\n    var b = new Node(csg.polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this.polygons = a.allPolygons();\n  };\n  /**\r\n   * Return a new CSG solid with solid and empty space switched. This solid is\r\n   * not modified.\r\n   * @returns A new CSG solid with solid and empty space switched\r\n   */\n\n\n  CSG.prototype.inverse = function () {\n    var csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  };\n  /**\r\n   * Inverses the CSG in place\r\n   */\n\n\n  CSG.prototype.inverseInPlace = function () {\n    this.polygons.map(function (p) {\n      p.flip();\n    });\n  };\n  /**\r\n   * This is used to keep meshes transformations so they can be restored\r\n   * when we build back a Babylon Mesh\r\n   * NB : All CSG operations are performed in world coordinates\r\n   * @param csg The CSG to copy the transform attributes from\r\n   * @returns This CSG\r\n   */\n\n\n  CSG.prototype.copyTransformAttributes = function (csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  };\n  /**\r\n   * Build Raw mesh from CSG\r\n   * Coordinates here are in world space\r\n   * @param name The name of the mesh geometry\r\n   * @param scene The Scene\r\n   * @param keepSubMeshes Specifies if the submeshes should be kept\r\n   * @returns A new Mesh\r\n   */\n\n\n  CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {\n    var matrix = this.matrix.clone();\n    matrix.invert();\n    var mesh = new Mesh(name, scene);\n    var vertices = [];\n    var indices = [];\n    var normals = [];\n    var uvs = null;\n    var vertColors = null;\n    var vertex = Vector3.Zero();\n    var normal = Vector3.Zero();\n    var uv = Vector2.Zero();\n    var vertColor = new Color4(0, 0, 0, 0);\n    var polygons = this.polygons;\n    var polygonIndices = [0, 0, 0],\n        polygon;\n    var vertice_dict = {};\n    var vertex_idx;\n    var currentIndex = 0;\n    var subMesh_dict = {};\n    var subMesh_obj;\n\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort(function (a, b) {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n\n    for (var i = 0, il = polygons.length; i < il; i++) {\n      polygon = polygons[i]; // Building SubMeshes\n\n      if (!subMesh_dict[polygon.shared.meshId]) {\n        subMesh_dict[polygon.shared.meshId] = {};\n      }\n\n      if (!subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n\n      subMesh_obj = subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId];\n\n      for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n\n        for (var k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n\n          var localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          var localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];\n          var areUvsDifferent = false;\n\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n\n          var areColorsDifferent = false;\n\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          } // Check if 2 points can be merged\n\n\n          if (!(typeof vertex_idx !== 'undefined' && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n\n            normals.push(normal.x, normal.y, normal.z);\n\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n\n            vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = vertices.length / 3 - 1;\n          }\n\n          indices.push(vertex_idx);\n          subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);\n          subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);\n          currentIndex++;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n\n    if (uvs) {\n      mesh.setVerticesData(VertexBuffer.UVKind, uvs);\n    }\n\n    if (vertColors) {\n      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\n    }\n\n    mesh.setIndices(indices, null);\n\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      var materialIndexOffset = 0,\n          materialMaxIndex;\n      mesh.subMeshes = new Array();\n\n      for (var m in subMesh_dict) {\n        materialMaxIndex = -1;\n\n        for (var sm in subMesh_dict[m]) {\n          subMesh_obj = subMesh_dict[m][sm];\n          SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);\n        }\n\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n\n    return mesh;\n  };\n  /**\r\n   * Build Mesh from CSG taking material and transforms into account\r\n   * @param name The name of the Mesh\r\n   * @param material The material of the Mesh\r\n   * @param scene The Scene\r\n   * @param keepSubMeshes Specifies if submeshes should be kept\r\n   * @returns The new Mesh\r\n   */\n\n\n  CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {\n    if (material === void 0) {\n      material = null;\n    }\n\n    var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  };\n\n  return CSG;\n}();\n\nexport { CSG };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/csg.ts"],"names":[],"mappings":"AAEA,SAA6B,OAA7B,EAAsC,OAAtC,QAAqD,sBAArD;AACA,SAAS,YAAT,QAA6B,kBAA7B;AAEA,SAAS,OAAT,QAAwB,mBAAxB;AACA,SAAS,IAAT,QAAqB,gBAArB;AAEA,SAAS,MAAT,QAAuB,qBAAvB;AACA;;;;AAGA,IAAI,gBAAgB,GAAG,CAAvB;AAEA;;;;;;;;;;;AAUA,IAAA,MAAA;AAAA;AAAA,YAAA;AACI;;;;;;;AAOA,WAAA,MAAA;AACI;;;AAGO,EAAA,GAJX;AAKI;;;AAGO,EAAA,MARX;AASI;;;AAGO,EAAA,EAZX;AAaI;;;AAGO,EAAA,SAhBX,EAgB6B;AAZlB,SAAA,GAAA,GAAA,GAAA;AAIA,SAAA,MAAA,GAAA,MAAA;AAIA,SAAA,EAAA,GAAA,EAAA;AAIA,SAAA,SAAA,GAAA,SAAA;AACV;AAED;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;;;AACI,WAAO,IAAI,MAAJ,CAAW,KAAK,GAAL,CAAS,KAAT,EAAX,EAA6B,KAAK,MAAL,CAAY,KAAZ,EAA7B,EAAgD,CAAA,EAAA,GAAE,KAAK,EAAP,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAS,EAAA,CAAE,KAAF,EAAzD,EAAgE,CAAA,EAAA,GAAI,KAAK,SAAT,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,KAAF,EAAlF,CAAP;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,MAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACI,SAAK,MAAL,GAAc,KAAK,MAAL,CAAY,KAAZ,CAAkB,CAAC,CAAnB,CAAd;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,MAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAkC,CAAlC,EAA2C;AACvC,WAAO,IAAI,MAAJ,CAAW,OAAO,CAAC,IAAR,CAAa,KAAK,GAAlB,EAAuB,KAAK,CAAC,GAA7B,EAAkC,CAAlC,CAAX,EACH,OAAO,CAAC,IAAR,CAAa,KAAK,MAAlB,EAA0B,KAAK,CAAC,MAAhC,EAAwC,CAAxC,CADG,EAEH,KAAK,EAAL,IAAW,KAAK,CAAC,EAAjB,GAAsB,OAAO,CAAC,IAAR,CAAa,KAAK,EAAlB,EAAsB,KAAK,CAAC,EAA5B,EAAgC,CAAhC,CAAtB,GAA2D,SAFxD,EAGH,KAAK,SAAL,IAAkB,KAAK,CAAC,SAAxB,GAAoC,MAAM,CAAC,IAAP,CAAY,KAAK,SAAjB,EAA4B,KAAK,CAAC,SAAlC,EAA6C,CAA7C,CAApC,GAAsF,SAHnF,CAAP;AAKH,GANM;;AAOX,SAAA,MAAA;AAAC,CAzDD,EAAA;AA2DA;;;;;AAGA,IAAA,KAAA;AAAA;AAAA,YAAA;AACI;;;;;AAKA,WAAA,KAAA,CAAmB,MAAnB,EAA2C,CAA3C,EAAoD;AAAjC,SAAA,MAAA,GAAA,MAAA;AAAwB,SAAA,CAAA,GAAA,CAAA;AAC1C;AAQD;;;;;;;;AAMc,EAAA,KAAA,CAAA,UAAA,GAAd,UAAyB,CAAzB,EAAqC,CAArC,EAAiD,CAAjD,EAA2D;AACvD,QAAI,EAAE,GAAG,CAAC,CAAC,QAAF,CAAW,CAAX,CAAT;AACA,QAAI,EAAE,GAAG,CAAC,CAAC,QAAF,CAAW,CAAX,CAAT;;AAEA,QAAI,EAAE,CAAC,aAAH,OAAuB,CAAvB,IAA4B,EAAE,CAAC,aAAH,OAAuB,CAAvD,EAA0D;AACtD,aAAO,IAAP;AACH;;AAED,QAAI,CAAC,GAAG,OAAO,CAAC,SAAR,CAAkB,OAAO,CAAC,KAAR,CAAc,EAAd,EAAkB,EAAlB,CAAlB,CAAR;AACA,WAAO,IAAI,KAAJ,CAAU,CAAV,EAAa,OAAO,CAAC,GAAR,CAAY,CAAZ,EAAe,CAAf,CAAb,CAAP;AACH,GAVa;AAYd;;;;;;AAIO,EAAA,KAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,KAAJ,CAAU,KAAK,MAAL,CAAY,KAAZ,EAAV,EAA+B,KAAK,CAApC,CAAP;AACH,GAFM;AAIP;;;;;AAGO,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACI,SAAK,MAAL,CAAY,YAAZ,CAAyB,CAAC,CAA1B;AACA,SAAK,CAAL,GAAS,CAAC,KAAK,CAAf;AACH,GAHM;AAKP;;;;;;;;;;;;;;AAYO,EAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,OAApB,EAAsC,aAAtC,EAAgE,YAAhE,EAAyF,KAAzF,EAA2G,IAA3G,EAA0H;AACtH,QAAI,QAAQ,GAAG,CAAf;AACA,QAAI,KAAK,GAAG,CAAZ;AACA,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,QAAQ,GAAG,CAAf,CAJsH,CAMtH;AACA;;AACA,QAAI,WAAW,GAAG,CAAlB;AACA,QAAI,KAAK,GAAG,EAAZ;AACA,QAAI,CAAJ;AACA,QAAI,CAAJ;;AACA,SAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAO,CAAC,QAAR,CAAiB,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC1C,MAAA,CAAC,GAAG,OAAO,CAAC,GAAR,CAAY,KAAK,MAAjB,EAAyB,OAAO,CAAC,QAAR,CAAiB,CAAjB,EAAoB,GAA7C,IAAoD,KAAK,CAA7D;AACA,UAAI,IAAI,GAAI,CAAC,GAAG,CAAC,KAAK,CAAC,OAAZ,GAAuB,IAAvB,GAA+B,CAAC,GAAG,KAAK,CAAC,OAAX,GAAsB,KAAtB,GAA8B,QAAvE;AACA,MAAA,WAAW,IAAI,IAAf;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACH,KAjBqH,CAmBtH;;;AACA,YAAQ,WAAR;AACI,WAAK,QAAL;AACI,SAAC,OAAO,CAAC,GAAR,CAAY,KAAK,MAAjB,EAAyB,OAAO,CAAC,KAAR,CAAc,MAAvC,IAAiD,CAAjD,GAAqD,aAArD,GAAqE,YAAtE,EAAoF,IAApF,CAAyF,OAAzF;AACA;;AACJ,WAAK,KAAL;AACI,QAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACA;;AACJ,WAAK,IAAL;AACI,QAAA,IAAI,CAAC,IAAL,CAAU,OAAV;AACA;;AACJ,WAAK,QAAL;AACI,YAAI,CAAC,GAAG,EAAR;AAAA,YAAY,CAAC,GAAG,EAAhB;;AACA,aAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAO,CAAC,QAAR,CAAiB,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC1C,cAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAL,IAAU,OAAO,CAAC,QAAR,CAAiB,MAAnC;AACA,cAAI,EAAE,GAAG,KAAK,CAAC,CAAD,CAAd;AAAA,cAAmB,EAAE,GAAG,KAAK,CAAC,CAAD,CAA7B;AACA,cAAI,EAAE,GAAG,OAAO,CAAC,QAAR,CAAiB,CAAjB,CAAT;AAAA,cAA8B,EAAE,GAAG,OAAO,CAAC,QAAR,CAAiB,CAAjB,CAAnC;;AACA,cAAI,EAAE,KAAK,IAAX,EAAiB;AAAE,YAAA,CAAC,CAAC,IAAF,CAAO,EAAP;AAAa;;AAChC,cAAI,EAAE,KAAK,KAAX,EAAkB;AAAE,YAAA,CAAC,CAAC,IAAF,CAAO,EAAE,KAAK,IAAP,GAAc,EAAE,CAAC,KAAH,EAAd,GAA2B,EAAlC;AAAwC;;AAC5D,cAAI,CAAC,EAAE,GAAG,EAAN,MAAc,QAAlB,EAA4B;AACxB,YAAA,CAAC,GAAG,CAAC,KAAK,CAAL,GAAS,OAAO,CAAC,GAAR,CAAY,KAAK,MAAjB,EAAyB,EAAE,CAAC,GAA5B,CAAV,IAA8C,OAAO,CAAC,GAAR,CAAY,KAAK,MAAjB,EAAyB,EAAE,CAAC,GAAH,CAAO,QAAP,CAAgB,EAAE,CAAC,GAAnB,CAAzB,CAAlD;AACA,gBAAI,CAAC,GAAG,EAAE,CAAC,WAAH,CAAe,EAAf,EAAmB,CAAnB,CAAR;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,CAAP;AACA,YAAA,CAAC,CAAC,IAAF,CAAO,CAAC,CAAC,KAAF,EAAP;AACH;AACJ;;AACD,YAAI,IAAJ;;AACA,YAAI,CAAC,CAAC,MAAF,IAAY,CAAhB,EAAmB;AACf,UAAA,IAAI,GAAG,IAAI,OAAJ,CAAY,CAAZ,EAAe,OAAO,CAAC,MAAvB,CAAP;;AACA,cAAI,IAAI,CAAC,KAAT,EAAgB;AACZ,YAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACH;AACJ;;AAED,YAAI,CAAC,CAAC,MAAF,IAAY,CAAhB,EAAmB;AACf,UAAA,IAAI,GAAG,IAAI,OAAJ,CAAY,CAAZ,EAAe,OAAO,CAAC,MAAvB,CAAP;;AAEA,cAAI,IAAI,CAAC,KAAT,EAAgB;AACZ,YAAA,IAAI,CAAC,IAAL,CAAU,IAAV;AACH;AACJ;;AAED;AAzCR;AA2CH,GA/DM;AApDP;;;;;;AAIO,EAAA,KAAA,CAAA,OAAA,GAAU,IAAV;AAgHX,SAAA,KAAA;AAAC,CA7HD,EAAA;AA+HA;;;;;;;;;;AAQA,IAAA,OAAA;AAAA;AAAA,YAAA;AAcI;;;;;AAKA,WAAA,OAAA,CAAY,QAAZ,EAAgC,MAAhC,EAA2C;AACvC,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,KAAL,GAAoB,KAAK,CAAC,UAAN,CAAiB,QAAQ,CAAC,CAAD,CAAR,CAAY,GAA7B,EAAkC,QAAQ,CAAC,CAAD,CAAR,CAAY,GAA9C,EAAmD,QAAQ,CAAC,CAAD,CAAR,CAAY,GAA/D,CAApB;AAEH;AAED;;;;;AAGO,EAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,QAAI,QAAQ,GAAG,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,CAAD,EAAE;AAAK,aAAA,CAAC,CAAD,KAAA,EAAA;AAAS,KAAlC,CAAf;AACA,WAAO,IAAI,OAAJ,CAAY,QAAZ,EAAsB,KAAK,MAA3B,CAAP;AACH,GAHM;AAKP;;;;;AAGO,EAAA,OAAA,CAAA,SAAA,CAAA,IAAA,GAAP,YAAA;AACI,SAAK,QAAL,CAAc,OAAd,GAAwB,GAAxB,CAA4B,UAAC,CAAD,EAAE;AAAO,MAAA,CAAC,CAAC,IAAF;AAAW,KAAhD;AACA,SAAK,KAAL,CAAW,IAAX;AACH,GAHM;;AAIX,SAAA,OAAA;AAAC,CAzCD,EAAA;AA2CA;;;;;;;;;AAOA,IAAA,IAAA;AAAA;AAAA,YAAA;AAMI;;;;AAIA,WAAA,IAAA,CAAY,QAAZ,EAAqC;AAT7B,SAAA,KAAA,GAAyB,IAAzB;AACA,SAAA,KAAA,GAAwB,IAAxB;AACA,SAAA,IAAA,GAAuB,IAAvB;AACA,SAAA,QAAA,GAAW,IAAI,KAAJ,EAAX;;AAOJ,QAAI,QAAJ,EAAc;AACV,WAAK,KAAL,CAAW,QAAX;AACH;AACJ;AAED;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,QAAI,IAAI,GAAG,IAAI,IAAJ,EAAX;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,KAAX,EAA3B;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,KAAX,EAA3B;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,KAAK,IAAL,IAAa,KAAK,IAAL,CAAU,KAAV,EAAzB;AACA,IAAA,IAAI,CAAC,QAAL,GAAgB,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,CAAD,EAAE;AAAK,aAAA,CAAC,CAAD,KAAA,EAAA;AAAS,KAAlC,CAAhB;AACA,WAAO,IAAP;AACH,GAPM;AASP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,QAAL,CAAc,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC3C,WAAK,QAAL,CAAc,CAAd,EAAiB,IAAjB;AACH;;AACD,QAAI,KAAK,KAAT,EAAgB;AACZ,WAAK,KAAL,CAAW,IAAX;AACH;;AACD,QAAI,KAAK,KAAT,EAAgB;AACZ,WAAK,KAAL,CAAW,MAAX;AACH;;AACD,QAAI,KAAK,IAAT,EAAe;AACX,WAAK,IAAL,CAAU,MAAV;AACH;;AACD,QAAI,IAAI,GAAG,KAAK,KAAhB;AACA,SAAK,KAAL,GAAa,KAAK,IAAlB;AACA,SAAK,IAAL,GAAY,IAAZ;AACH,GAhBM;AAkBP;;;;;;;;AAMA,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,QAAb,EAAgC;AAC5B,QAAI,CAAC,KAAK,KAAV,EAAiB;AAAE,aAAO,QAAQ,CAAC,KAAT,EAAP;AAA0B;;AAC7C,QAAI,KAAK,GAAG,IAAI,KAAJ,EAAZ;AAAA,QAAkC,IAAI,GAAG,IAAI,KAAJ,EAAzC;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACtC,WAAK,KAAL,CAAW,YAAX,CAAwB,QAAQ,CAAC,CAAD,CAAhC,EAAqC,KAArC,EAA4C,IAA5C,EAAkD,KAAlD,EAAyD,IAAzD;AACH;;AACD,QAAI,KAAK,KAAT,EAAgB;AACZ,MAAA,KAAK,GAAG,KAAK,KAAL,CAAW,YAAX,CAAwB,KAAxB,CAAR;AACH;;AACD,QAAI,KAAK,IAAT,EAAe;AACX,MAAA,IAAI,GAAG,KAAK,IAAL,CAAU,YAAV,CAAuB,IAAvB,CAAP;AACH,KAFD,MAEO;AACH,MAAA,IAAI,GAAG,EAAP;AACH;;AACD,WAAO,KAAK,CAAC,MAAN,CAAa,IAAb,CAAP;AACH,GAfD;AAiBA;;;;;;;AAKA,EAAA,IAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,GAAP,EAAgB;AACZ,SAAK,QAAL,GAAgB,GAAG,CAAC,YAAJ,CAAiB,KAAK,QAAtB,CAAhB;;AACA,QAAI,KAAK,KAAT,EAAgB;AAAE,WAAK,KAAL,CAAW,MAAX,CAAkB,GAAlB;AAAyB;;AAC3C,QAAI,KAAK,IAAT,EAAe;AAAE,WAAK,IAAL,CAAU,MAAV,CAAiB,GAAjB;AAAwB;AAC5C,GAJD;AAMA;;;;;;AAIA,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACI,QAAI,QAAQ,GAAG,KAAK,QAAL,CAAc,KAAd,EAAf;;AACA,QAAI,KAAK,KAAT,EAAgB;AAAE,MAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAAK,KAAL,CAAW,WAAX,EAAhB,CAAX;AAAuD;;AACzE,QAAI,KAAK,IAAT,EAAe;AAAE,MAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAAK,IAAL,CAAU,WAAV,EAAhB,CAAX;AAAsD;;AACvE,WAAO,QAAP;AACH,GALD;AAOA;;;;;;;;;AAOA,EAAA,IAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,QAAN,EAAyB;AACrB,QAAI,CAAC,QAAQ,CAAC,MAAd,EAAsB;AAAE;AAAS;;AACjC,QAAI,CAAC,KAAK,KAAV,EAAiB;AAAE,WAAK,KAAL,GAAa,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAZ,CAAkB,KAAlB,EAAb;AAAyC;;AAC5D,QAAI,KAAK,GAAG,IAAI,KAAJ,EAAZ;AAAA,QAAkC,IAAI,GAAG,IAAI,KAAJ,EAAzC;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACtC,WAAK,KAAL,CAAW,YAAX,CAAwB,QAAQ,CAAC,CAAD,CAAhC,EAAqC,KAAK,QAA1C,EAAoD,KAAK,QAAzD,EAAmE,KAAnE,EAA0E,IAA1E;AACH;;AACD,QAAI,KAAK,CAAC,MAAV,EAAkB;AACd,UAAI,CAAC,KAAK,KAAV,EAAiB;AAAE,aAAK,KAAL,GAAa,IAAI,IAAJ,EAAb;AAA0B;;AAC7C,WAAK,KAAL,CAAW,KAAX,CAAiB,KAAjB;AACH;;AACD,QAAI,IAAI,CAAC,MAAT,EAAiB;AACb,UAAI,CAAC,KAAK,IAAV,EAAgB;AAAE,aAAK,IAAL,GAAY,IAAI,IAAJ,EAAZ;AAAyB;;AAC3C,WAAK,IAAL,CAAU,KAAV,CAAgB,IAAhB;AACH;AACJ,GAfD;;AAgBJ,SAAA,IAAA;AAAC,CAtHD,EAAA;AAwHA;;;;;AAGA,IAAA,GAAA;AAAA;AAAA,YAAA;AAAA,WAAA,GAAA,GAAA;AACY,SAAA,QAAA,GAAW,IAAI,KAAJ,EAAX;AAicX;AA3aG;;;;;;;AAKc,EAAA,GAAA,CAAA,QAAA,GAAd,UAAuB,IAAvB,EAAiC;AAC7B,QAAI,MAAJ;AAAA,QAAoB,MAApB;AAAA,QAAqC,EAAE,GAAwB,SAA/D;AAAA,QAA0E,QAA1E;AAAA,QAA6F,SAAS,GAAuB,SAA7H;AAAA,QACI,OADJ;AAAA,QAEI,QAAQ,GAAG,IAAI,KAAJ,EAFf;AAAA,QAGI,QAHJ;AAIA,QAAI,MAAJ;AAAA,QACI,YADJ;AAAA,QAEI,YAFJ;AAAA,QAGI,sBAAsB,GAAyB,IAHnD;AAAA,QAII,WAJJ;;AAMA,QAAI,IAAI,YAAY,IAApB,EAA0B;AACtB,MAAA,IAAI,CAAC,kBAAL,CAAwB,IAAxB;AACA,MAAA,MAAM,GAAG,IAAI,CAAC,cAAL,EAAT;AACA,MAAA,YAAY,GAAG,IAAI,CAAC,QAAL,CAAc,KAAd,EAAf;AACA,MAAA,YAAY,GAAG,IAAI,CAAC,QAAL,CAAc,KAAd,EAAf;;AACA,UAAI,IAAI,CAAC,kBAAT,EAA6B;AACzB,QAAA,sBAAsB,GAAG,IAAI,CAAC,kBAAL,CAAwB,KAAxB,EAAzB;AACH;;AACD,MAAA,WAAW,GAAG,IAAI,CAAC,OAAL,CAAa,KAAb,EAAd;AACH,KATD,MASO;AACH,YAAM,oDAAN;AACH;;AAED,QAAI,OAAO,GAAiB,IAAI,CAAC,UAAL,EAA5B;AAAA,QACI,SAAS,GAAe,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,YAAlC,CAD5B;AAAA,QAEI,OAAO,GAAe,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,UAAlC,CAF1B;AAAA,QAGI,GAAG,GAAe,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,MAAlC,CAHtB;AAAA,QAII,UAAU,GAAe,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,SAAlC,CAJ7B;AAMA,QAAI,SAAS,GAAG,IAAI,CAAC,SAArB;;AAEA,SAAK,IAAI,EAAE,GAAG,CAAT,EAAY,GAAG,GAAG,SAAS,CAAC,MAAjC,EAAyC,EAAE,GAAG,GAA9C,EAAmD,EAAE,EAArD,EAAyD;AACrD,WAAK,IAAI,CAAC,GAAG,SAAS,CAAC,EAAD,CAAT,CAAc,UAAtB,EAAkC,EAAE,GAAG,SAAS,CAAC,EAAD,CAAT,CAAc,UAAd,GAA2B,SAAS,CAAC,EAAD,CAAT,CAAc,UAArF,EAAiG,CAAC,GAAG,EAArG,EAAyG,CAAC,IAAI,CAA9G,EAAiH;AAC7G,QAAA,QAAQ,GAAG,EAAX;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AACxB,cAAI,YAAY,GAAG,IAAI,OAAJ,CAAY,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAlB,CAAnB,EAAyC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAAhD,EAA0E,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAAjF,CAAnB;;AACA,cAAI,GAAJ,EAAS;AACL,YAAA,EAAE,GAAG,IAAI,OAAJ,CAAY,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAlB,CAAf,EAAqC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAAxC,CAAL;AACH;;AACD,cAAI,UAAJ,EAAgB;AACZ,YAAA,SAAS,GAAG,IAAI,MAAJ,CAAW,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAlB,CAArB,EAA2C,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAArD,EAA+E,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAAzF,EAAmH,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAA7H,CAAZ;AACH;;AACD,cAAI,cAAc,GAAG,IAAI,OAAJ,CAAY,SAAS,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAlB,CAArB,EAA2C,SAAS,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAApD,EAA8E,SAAS,CAAC,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB,GAAqB,CAAtB,CAAvF,CAArB;AACA,UAAA,QAAQ,GAAG,OAAO,CAAC,oBAAR,CAA6B,cAA7B,EAA6C,MAA7C,CAAX;AACA,UAAA,MAAM,GAAG,OAAO,CAAC,eAAR,CAAwB,YAAxB,EAAsC,MAAtC,CAAT;AAEA,UAAA,MAAM,GAAG,IAAI,MAAJ,CAAW,QAAX,EAAqB,MAArB,EAA6B,EAA7B,EAAiC,SAAjC,CAAT;AACA,UAAA,QAAQ,CAAC,IAAT,CAAc,MAAd;AACH;;AAED,QAAA,OAAO,GAAG,IAAI,OAAJ,CAAY,QAAZ,EAAsB;AAAE,UAAA,SAAS,EAAE,EAAb;AAAiB,UAAA,MAAM,EAAE,gBAAzB;AAA2C,UAAA,aAAa,EAAE,SAAS,CAAC,EAAD,CAAT,CAAc;AAAxE,SAAtB,CAAV,CAlB6G,CAoB7G;AACA;;AACA,YAAI,OAAO,CAAC,KAAZ,EAAmB;AACf,UAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;AACH;AACJ;AACJ;;AAED,QAAI,GAAG,GAAG,GAAG,CAAC,YAAJ,CAAiB,QAAjB,CAAV;AACA,IAAA,GAAG,CAAC,MAAJ,GAAa,MAAb;AACA,IAAA,GAAG,CAAC,QAAJ,GAAe,YAAf;AACA,IAAA,GAAG,CAAC,QAAJ,GAAe,YAAf;AACA,IAAA,GAAG,CAAC,OAAJ,GAAc,WAAd;AACA,IAAA,GAAG,CAAC,kBAAJ,GAAyB,sBAAzB;AACA,IAAA,gBAAgB;AAEhB,WAAO,GAAP;AACH,GAtEa;AAwEd;;;;;;AAIe,EAAA,GAAA,CAAA,YAAA,GAAf,UAA4B,QAA5B,EAA+C;AAC3C,QAAI,GAAG,GAAG,IAAI,GAAJ,EAAV;AACA,IAAA,GAAG,CAAC,QAAJ,GAAe,QAAf;AACA,WAAO,GAAP;AACH,GAJc;AAMf;;;;;;AAIO,EAAA,GAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,QAAI,GAAG,GAAG,IAAI,GAAJ,EAAV;AACA,IAAA,GAAG,CAAC,QAAJ,GAAe,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,CAAD,EAAE;AAAK,aAAA,CAAC,CAAD,KAAA,EAAA;AAAS,KAAlC,CAAf;AACA,IAAA,GAAG,CAAC,uBAAJ,CAA4B,IAA5B;AACA,WAAO,GAAP;AACH,GALM;AAOP;;;;;;;AAKO,EAAA,GAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,GAAb,EAAqB;AACjB,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,KAAL,GAAa,QAAtB,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,KAAJ,GAAY,QAArB,CAAR;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AACA,WAAO,GAAG,CAAC,YAAJ,CAAiB,CAAC,CAAC,WAAF,EAAjB,EAAkC,uBAAlC,CAA0D,IAA1D,CAAP;AACH,GAVM;AAYP;;;;;;AAIO,EAAA,GAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,GAApB,EAA4B;AACxB,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,QAAd,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,QAAb,CAAR;AAEA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AAEA,SAAK,QAAL,GAAgB,CAAC,CAAC,WAAF,EAAhB;AACH,GAZM;AAcP;;;;;;;AAKO,EAAA,GAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,GAAhB,EAAwB;AACpB,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,KAAL,GAAa,QAAtB,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,KAAJ,GAAY,QAArB,CAAR;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AACA,IAAA,CAAC,CAAC,MAAF;AACA,WAAO,GAAG,CAAC,YAAJ,CAAiB,CAAC,CAAC,WAAF,EAAjB,EAAkC,uBAAlC,CAA0D,IAA1D,CAAP;AACH,GAZM;AAcP;;;;;;AAIO,EAAA,GAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,GAAvB,EAA+B;AAC3B,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,QAAd,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,QAAb,CAAR;AAEA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AACA,IAAA,CAAC,CAAC,MAAF;AAEA,SAAK,QAAL,GAAgB,CAAC,CAAC,WAAF,EAAhB;AACH,GAdM;AAgBP;;;;;;;AAKO,EAAA,GAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,GAAjB,EAAyB;AACrB,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,KAAL,GAAa,QAAtB,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,KAAJ,GAAY,QAArB,CAAR;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AACA,IAAA,CAAC,CAAC,MAAF;AACA,WAAO,GAAG,CAAC,YAAJ,CAAiB,CAAC,CAAC,WAAF,EAAjB,EAAkC,uBAAlC,CAA0D,IAA1D,CAAP;AACH,GAXM;AAaP;;;;;;AAIO,EAAA,GAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,GAAxB,EAAgC;AAC5B,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,KAAK,QAAd,CAAR;AACA,QAAI,CAAC,GAAG,IAAI,IAAJ,CAAS,GAAG,CAAC,QAAb,CAAR;AAEA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,MAAF,CAAS,CAAT;AACA,IAAA,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,WAAF,EAAR;AACA,IAAA,CAAC,CAAC,MAAF;AAEA,SAAK,QAAL,GAAgB,CAAC,CAAC,WAAF,EAAhB;AACH,GAbM;AAeP;;;;;;;AAKO,EAAA,GAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,GAAG,GAAG,KAAK,KAAL,EAAV;AACA,IAAA,GAAG,CAAC,cAAJ;AACA,WAAO,GAAP;AACH,GAJM;AAMP;;;;;AAGO,EAAA,GAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,SAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,CAAD,EAAE;AAAO,MAAA,CAAC,CAAC,IAAF;AAAW,KAAtC;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,GAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,GAA/B,EAAuC;AACnC,SAAK,MAAL,GAAc,GAAG,CAAC,MAAlB;AACA,SAAK,QAAL,GAAgB,GAAG,CAAC,QAApB;AACA,SAAK,QAAL,GAAgB,GAAG,CAAC,QAApB;AACA,SAAK,OAAL,GAAe,GAAG,CAAC,OAAnB;AACA,SAAK,kBAAL,GAA0B,GAAG,CAAC,kBAA9B;AAEA,WAAO,IAAP;AACH,GARM;AAUP;;;;;;;;;;AAQO,EAAA,GAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,IAAzB,EAAuC,KAAvC,EAAsD,aAAtD,EAA6E;AACzE,QAAI,MAAM,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAb;AACA,IAAA,MAAM,CAAC,MAAP;AAEA,QAAI,IAAI,GAAG,IAAI,IAAJ,CAAS,IAAT,EAAe,KAAf,CAAX;AACA,QAAI,QAAQ,GAAG,EAAf;AACA,QAAI,OAAO,GAAG,EAAd;AACA,QAAI,OAAO,GAAG,EAAd;AACA,QAAI,GAAG,GAAuB,IAA9B;AACA,QAAI,UAAU,GAAuB,IAArC;AACA,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AACA,QAAI,EAAE,GAAG,OAAO,CAAC,IAAR,EAAT;AACA,QAAI,SAAS,GAAG,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,CAAhB;AACA,QAAI,QAAQ,GAAG,KAAK,QAApB;AACA,QAAI,cAAc,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAArB;AAAA,QAAgC,OAAhC;AACA,QAAI,YAAY,GAAG,EAAnB;AACA,QAAI,UAAJ;AACA,QAAI,YAAY,GAAG,CAAnB;AACA,QAAI,YAAY,GAAG,EAAnB;AACA,QAAI,WAAJ;;AAEA,QAAI,aAAJ,EAAmB;AACf;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,UAAC,CAAD,EAAI,CAAJ,EAAK;AACf,YAAI,CAAC,CAAC,MAAF,CAAS,MAAT,KAAoB,CAAC,CAAC,MAAF,CAAS,MAAjC,EAAyC;AACrC,iBAAO,CAAC,CAAC,MAAF,CAAS,SAAT,GAAqB,CAAC,CAAC,MAAF,CAAS,SAArC;AACH,SAFD,MAEO;AACH,iBAAO,CAAC,CAAC,MAAF,CAAS,MAAT,GAAkB,CAAC,CAAC,MAAF,CAAS,MAAlC;AACH;AACJ,OAND;AAOH;;AAED,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,QAAQ,CAAC,MAA9B,EAAsC,CAAC,GAAG,EAA1C,EAA8C,CAAC,EAA/C,EAAmD;AAC/C,MAAA,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAlB,CAD+C,CAG/C;;AACA,UAAI,CAAO,YAAa,CAAC,OAAO,CAAC,MAAR,CAAe,MAAhB,CAAxB,EAAiD;AACvC,QAAA,YAAa,CAAC,OAAO,CAAC,MAAR,CAAe,MAAhB,CAAb,GAAuC,EAAvC;AACT;;AACD,UAAI,CAAO,YAAa,CAAC,OAAO,CAAC,MAAR,CAAe,MAAhB,CAAb,CAAqC,OAAO,CAAC,MAAR,CAAe,SAApD,CAAX,EAA2E;AACjE,QAAA,YAAa,CAAC,OAAO,CAAC,MAAR,CAAe,MAAhB,CAAb,CAAqC,OAAO,CAAC,MAAR,CAAe,SAApD,IAAiE;AACnE,UAAA,UAAU,EAAE,CAAC,QADsD;AAEnE,UAAA,QAAQ,EAAE,CAAC,QAFwD;AAGnE,UAAA,aAAa,EAAE,OAAO,CAAC,MAAR,CAAe;AAHqC,SAAjE;AAKT;;AACD,MAAA,WAAW,GAAS,YAAa,CAAC,OAAO,CAAC,MAAR,CAAe,MAAhB,CAAb,CAAqC,OAAO,CAAC,MAAR,CAAe,SAApD,CAApB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,OAAO,CAAC,QAAR,CAAiB,MAAtC,EAA8C,CAAC,GAAG,EAAlD,EAAsD,CAAC,EAAvD,EAA2D;AAEvD,QAAA,cAAc,CAAC,CAAD,CAAd,GAAoB,CAApB;AACA,QAAA,cAAc,CAAC,CAAD,CAAd,GAAoB,CAAC,GAAG,CAAxB;AACA,QAAA,cAAc,CAAC,CAAD,CAAd,GAAoB,CAApB;;AAEA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AACxB,UAAA,MAAM,CAAC,QAAP,CAAgB,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,GAApD;AACA,UAAA,MAAM,CAAC,QAAP,CAAgB,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,MAApD;;AACA,cAAI,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,EAAxC,EAA4C;AACxC,gBAAI,CAAC,GAAL,EAAU;AACN,cAAA,GAAG,GAAG,EAAN;AACH;;AACD,YAAA,EAAE,CAAC,QAAH,CAAY,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,EAAhD;AACH;;AAED,cAAI,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,SAAxC,EAAmD;AAC/C,gBAAI,CAAC,UAAL,EAAiB;AACb,cAAA,UAAU,GAAG,EAAb;AACH;;AACD,YAAA,SAAS,CAAC,QAAV,CAAmB,OAAO,CAAC,QAAR,CAAiB,cAAc,CAAC,CAAD,CAA/B,EAAoC,SAAvD;AACH;;AACD,cAAI,WAAW,GAAG,OAAO,CAAC,oBAAR,CAA6B,MAA7B,EAAqC,MAArC,CAAlB;AACA,cAAI,WAAW,GAAG,OAAO,CAAC,eAAR,CAAwB,MAAxB,EAAgC,MAAhC,CAAlB;AAEA,UAAA,UAAU,GAAS,YAAa,CAAC,WAAW,CAAC,CAAZ,GAAgB,GAAhB,GAAsB,WAAW,CAAC,CAAlC,GAAsC,GAAtC,GAA4C,WAAW,CAAC,CAAzD,CAAhC;AAEA,cAAI,eAAe,GAAG,KAAtB;;AAEA,cAAI,GAAG,IACH,EAAE,GAAG,CAAC,UAAU,GAAG,CAAd,CAAH,KAAwB,EAAE,CAAC,CAA3B,IACF,GAAG,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAH,KAA4B,EAAE,CAAC,CAD/B,CADJ,EAEuC;AACnC,YAAA,eAAe,GAAG,IAAlB;AACH;;AAED,cAAI,kBAAkB,GAAG,KAAzB;;AAEA,cAAI,UAAU,IACV,EAAE,UAAU,CAAC,UAAU,GAAG,CAAd,CAAV,KAA+B,SAAS,CAAC,CAAzC,IACF,UAAU,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAV,KAAmC,SAAS,CAAC,CAD3C,IAEF,UAAU,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAV,KAAmC,SAAS,CAAC,CAF3C,IAGF,UAAU,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAV,KAAmC,SAAS,CAAC,CAH7C,CADJ,EAIqD;AACjD,YAAA,kBAAkB,GAAG,IAArB;AACH,WArCuB,CAuCxB;;;AACA,cAAI,EAAE,OAAO,UAAP,KAAsB,WAAtB,IACF,OAAO,CAAC,UAAU,GAAG,CAAd,CAAP,KAA4B,WAAW,CAAC,CADtC,IAEF,OAAO,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAP,KAAgC,WAAW,CAAC,CAF1C,IAGF,OAAO,CAAC,UAAU,GAAG,CAAb,GAAiB,CAAlB,CAAP,KAAgC,WAAW,CAAC,CAH5C,KAGkD,eAHlD,IAGqE,kBAHzE,EAG6F;AACrF,YAAA,QAAQ,CAAC,IAAT,CAAc,WAAW,CAAC,CAA1B,EAA6B,WAAW,CAAC,CAAzC,EAA4C,WAAW,CAAC,CAAxD;;AACA,gBAAI,GAAJ,EAAS;AACL,cAAA,GAAG,CAAC,IAAJ,CAAS,EAAE,CAAC,CAAZ,EAAe,EAAE,CAAC,CAAlB;AACH;;AACD,YAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,CAApB,EAAuB,MAAM,CAAC,CAA9B,EAAiC,MAAM,CAAC,CAAxC;;AACA,gBAAI,UAAJ,EAAgB;AACZ,cAAA,UAAU,CAAC,IAAX,CAAgB,SAAS,CAAC,CAA1B,EAA6B,SAAS,CAAC,CAAvC,EAA0C,SAAS,CAAC,CAApD,EAAuD,SAAS,CAAC,CAAjE;AACH;;AACL,YAAA,UAAU,GAAS,YAAa,CAAC,WAAW,CAAC,CAAZ,GAAgB,GAAhB,GAAsB,WAAW,CAAC,CAAlC,GAAsC,GAAtC,GAA4C,WAAW,CAAC,CAAzD,CAAb,GAA4E,QAAQ,CAAC,MAAT,GAAkB,CAAnB,GAAwB,CAAtH;AACH;;AAED,UAAA,OAAO,CAAC,IAAR,CAAa,UAAb;AAEA,UAAA,WAAW,CAAC,UAAZ,GAAyB,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,WAAW,CAAC,UAAnC,CAAzB;AACA,UAAA,WAAW,CAAC,QAAZ,GAAuB,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,WAAW,CAAC,QAAnC,CAAvB;AACA,UAAA,YAAY;AACf;AAEJ;AAEJ;;AAED,IAAA,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,YAAlC,EAAgD,QAAhD;AACA,IAAA,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,UAAlC,EAA8C,OAA9C;;AACA,QAAI,GAAJ,EAAS;AACL,MAAA,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,MAAlC,EAA0C,GAA1C;AACH;;AACD,QAAI,UAAJ,EAAgB;AACZ,MAAA,IAAI,CAAC,eAAL,CAAqB,YAAY,CAAC,SAAlC,EAA6C,UAA7C;AACH;;AACD,IAAA,IAAI,CAAC,UAAL,CAAgB,OAAhB,EAAyB,IAAzB;;AAEA,QAAI,aAAJ,EAAmB;AACf;AACA,UAAI,mBAAmB,GAAG,CAA1B;AAAA,UACI,gBADJ;AAGA,MAAA,IAAI,CAAC,SAAL,GAAiB,IAAI,KAAJ,EAAjB;;AAEA,WAAK,IAAI,CAAT,IAAc,YAAd,EAA4B;AACxB,QAAA,gBAAgB,GAAG,CAAC,CAApB;;AACA,aAAK,IAAI,EAAT,IAAqB,YAAa,CAAC,CAAD,CAAlC,EAAuC;AACnC,UAAA,WAAW,GAAS,YAAa,CAAC,CAAD,CAAb,CAAiB,EAAjB,CAApB;AACA,UAAA,OAAO,CAAC,iBAAR,CAA0B,WAAW,CAAC,aAAZ,GAA4B,mBAAtD,EAA2E,WAAW,CAAC,UAAvF,EAAmG,WAAW,CAAC,QAAZ,GAAuB,WAAW,CAAC,UAAnC,GAAgD,CAAnJ,EAAoK,IAApK;AACA,UAAA,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,aAArB,EAAoC,gBAApC,CAAnB;AACH;;AACD,QAAA,mBAAmB,IAAI,EAAE,gBAAzB;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GAtJM;AAwJP;;;;;;;;;;AAQO,EAAA,GAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA4B,QAA5B,EAAiE,KAAjE,EAAgF,aAAhF,EAAuG;AAA3E,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA,IAAA;AAAmC;;AAC3D,QAAI,IAAI,GAAG,KAAK,iBAAL,CAAuB,IAAvB,EAA6B,KAA7B,EAAoC,aAApC,CAAX;AAEA,IAAA,IAAI,CAAC,QAAL,GAAgB,QAAhB;AAEA,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,CAAuB,KAAK,QAA5B;AACA,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,CAAuB,KAAK,QAA5B;;AACA,QAAI,KAAK,kBAAT,EAA6B;AACzB,MAAA,IAAI,CAAC,kBAAL,GAA0B,KAAK,kBAAL,CAAwB,KAAxB,EAA1B;AACH;;AACD,IAAA,IAAI,CAAC,OAAL,CAAa,QAAb,CAAsB,KAAK,OAA3B;AACA,IAAA,IAAI,CAAC,kBAAL,CAAwB,IAAxB;AAEA,WAAO,IAAP;AACH,GAdM;;AAeX,SAAA,GAAA;AAAC,CAlcD,EAAA","sourcesContent":["import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Color4 } from '../Maths/math.color';\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nvar currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4) {\r\n    }\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {\r\n    }\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        var v0 = c.subtract(a);\r\n        var v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        var n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        var COPLANAR = 0;\r\n        var FRONT = 1;\r\n        var BACK = 2;\r\n        var SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        var polygonType = 0;\r\n        var types = [];\r\n        var i: number;\r\n        var t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            var type = (t < -Plane.EPSILON) ? BACK : (t > Plane.EPSILON) ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING:\r\n                var f = [], b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    var j = (i + 1) % polygon.vertices.length;\r\n                    var ti = types[i], tj = types[j];\r\n                    var vi = polygon.vertices[i], vj = polygon.vertices[j];\r\n                    if (ti !== BACK) { f.push(vi); }\r\n                    if (ti !== FRONT) { b.push(ti !== BACK ? vi.clone() : vi); }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        var v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                var poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        var vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => { v.flip(); });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private plane: Nullable<Plane> = null;\r\n    private front: Nullable<Node> = null;\r\n    private back: Nullable<Node> = null;\r\n    private polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        var node = new Node();\r\n        node.plane = this.plane && this.plane.clone();\r\n        node.front = this.front && this.front.clone();\r\n        node.back = this.back && this.back.clone();\r\n        node.polygons = this.polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (var i = 0; i < this.polygons.length; i++) {\r\n            this.polygons[i].flip();\r\n        }\r\n        if (this.plane) {\r\n            this.plane.flip();\r\n        }\r\n        if (this.front) {\r\n            this.front.invert();\r\n        }\r\n        if (this.back) {\r\n            this.back.invert();\r\n        }\r\n        var temp = this.front;\r\n        this.front = this.back;\r\n        this.back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this.plane) { return polygons.slice(); }\r\n        var front = new Array<Polygon>(), back = new Array<Polygon>();\r\n        for (var i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this.front) {\r\n            front = this.front.clipPolygons(front);\r\n        }\r\n        if (this.back) {\r\n            back = this.back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this.polygons = bsp.clipPolygons(this.polygons);\r\n        if (this.front) { this.front.clipTo(bsp); }\r\n        if (this.back) { this.back.clipTo(bsp); }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        var polygons = this.polygons.slice();\r\n        if (this.front) { polygons = polygons.concat(this.front.allPolygons()); }\r\n        if (this.back) { polygons = polygons.concat(this.back.allPolygons()); }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) { return; }\r\n        if (!this.plane) { this.plane = polygons[0].plane.clone(); }\r\n        var front = new Array<Polygon>(), back = new Array<Polygon>();\r\n        for (var i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this.front) { this.front = new Node(); }\r\n            this.front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this.back) { this.back = new Node(); }\r\n            this.back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh): CSG {\r\n        var vertex: Vertex, normal: Vector3, uv: Vector2 | undefined = undefined, position: Vector3, vertColor: Color4 | undefined = undefined,\r\n            polygon: Polygon,\r\n            polygons = new Array<Polygon>(),\r\n            vertices;\r\n        var matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n        } else {\r\n            throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';\r\n        }\r\n\r\n        var indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        var subMeshes = mesh.subMeshes;\r\n\r\n        for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (var j = 0; j < 3; j++) {\r\n                    var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(vertColors[indices[i + j] * 4], vertColors[indices[i + j] * 4 + 1], vertColors[indices[i + j] * 4 + 2], vertColors[indices[i + j] * 4 + 3]);\r\n                    }\r\n                    var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        var csg = CSG.FromPolygons(polygons);\r\n        csg.matrix = matrix;\r\n        csg.position = meshPosition;\r\n        csg.rotation = meshRotation;\r\n        csg.scaling = meshScaling;\r\n        csg.rotationQuaternion = meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static FromPolygons(polygons: Polygon[]): CSG {\r\n        var csg = new CSG();\r\n        csg.polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        var csg = new CSG();\r\n        csg.polygons = this.polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtact against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        var csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this.polygons.map((p) => { p.flip(); });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        var matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        var mesh = new Mesh(name, scene);\r\n        var vertices = [];\r\n        var indices = [];\r\n        var normals = [];\r\n        var uvs: Nullable<number[]> = null;\r\n        var vertColors: Nullable<number[]> = null;\r\n        var vertex = Vector3.Zero();\r\n        var normal = Vector3.Zero();\r\n        var uv = Vector2.Zero();\r\n        var vertColor = new Color4(0, 0, 0, 0);\r\n        var polygons = this.polygons;\r\n        var polygonIndices = [0, 0, 0], polygon;\r\n        var vertice_dict = {};\r\n        var vertex_idx;\r\n        var currentIndex = 0;\r\n        var subMesh_dict = {};\r\n        var subMesh_obj;\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        for (var i = 0, il = polygons.length; i < il; i++) {\r\n            polygon = polygons[i];\r\n\r\n            // Building SubMeshes\r\n            if (!(<any>subMesh_dict)[polygon.shared.meshId]) {\r\n                (<any>subMesh_dict)[polygon.shared.meshId] = {};\r\n            }\r\n            if (!(<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                (<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                    indexStart: +Infinity,\r\n                    indexEnd: -Infinity,\r\n                    materialIndex: polygon.shared.materialIndex\r\n                };\r\n            }\r\n            subMesh_obj = (<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n\r\n            for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (var k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    var localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    var localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs &&\r\n                        !(uvs[vertex_idx * 2] === uv.x ||\r\n                        uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (vertColors &&\r\n                        !(vertColors[vertex_idx * 4] === vertColor.r ||\r\n                        vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                        vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                        vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (!(typeof vertex_idx !== 'undefined' &&\r\n                        normals[vertex_idx * 3] === localNormal.x &&\r\n                        normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                        normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\r\n                            vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                            if (uvs) {\r\n                                uvs.push(uv.x, uv.y);\r\n                            }\r\n                            normals.push(normal.x, normal.y, normal.z);\r\n                            if (vertColors) {\r\n                                vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                            }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = (vertices.length / 3) - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);\r\n                    subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);\r\n                    currentIndex++;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        if (uvs) {\r\n            mesh.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        }\r\n        if (vertColors) {\r\n            mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\r\n        }\r\n        mesh.setIndices(indices, null);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            var materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (var m in subMesh_dict) {\r\n                materialMaxIndex = -1;\r\n                for (var sm in (<any>subMesh_dict)[m]) {\r\n                    subMesh_obj = (<any>subMesh_dict)[m][sm];\r\n                    SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, <AbstractMesh>mesh);\r\n                    materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}