{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\n\nvar AnisotropyBlock =\n/** @class */\nfunction (_super) {\n  __extends(AnisotropyBlock, _super);\n  /**\r\n   * Create a new AnisotropyBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function AnisotropyBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._isUnique = true;\n\n    _this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n\n\n    _this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n\n    _this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", _this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n\n    return _this;\n  }\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n\n  AnisotropyBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"anisotropicOut\");\n\n    state._excludeVariableName(\"TBN\");\n  };\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  AnisotropyBlock.prototype.getClassName = function () {\n    return \"AnisotropyBlock\";\n  };\n\n  Object.defineProperty(AnisotropyBlock.prototype, \"intensity\", {\n    /**\r\n     * Gets the intensity input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"direction\", {\n    /**\r\n     * Gets the direction input component\r\n     */\n    get: function () {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function () {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"worldTangent\", {\n    /**\r\n     * Gets the worldTangent input component\r\n     */\n    get: function () {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnisotropyBlock.prototype, \"anisotropy\", {\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AnisotropyBlock.prototype._generateTBNSpace = function (state) {\n    var code = \"\";\n    var comments = \"//\" + this.name;\n    var uv = this.uv;\n    var worldPosition = this.worldPositionConnectionPoint;\n    var worldNormal = this.worldNormalConnectionPoint;\n    var worldTangent = this.worldTangent;\n\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n\n    var tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n\n    if (worldTangent.isConnected) {\n      code += \"vec3 tbnNormal = normalize(\" + worldNormal.associatedVariableName + \".xyz);\\r\\n\";\n      code += \"vec3 tbnTangent = normalize(\" + worldTangent.associatedVariableName + \".xyz);\\r\\n\";\n      code += \"vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\\r\\n\";\n      code += \"mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n\";\n    }\n\n    code += \"\\n            #if defined(\" + (worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\") + \") && defined(NORMAL)\\n                mat3 TBN = vTBN;\\n            #else\\n                mat3 TBN = cotangent_frame(\" + (worldNormal.associatedVariableName + \".xyz\") + \", \" + (\"v_\" + worldPosition.associatedVariableName + \".xyz\") + \", \" + (uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\") + \", vec2(1., 1.));\\n            #endif\\r\\n\";\n\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n\n    return code;\n  };\n  /**\r\n   * Gets the main code of the block (fragment side)\r\n   * @param state current state of the node material building\r\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n   * @returns the shader code\r\n   */\n\n\n  AnisotropyBlock.prototype.getCode = function (state, generateTBNSpace) {\n    if (generateTBNSpace === void 0) {\n      generateTBNSpace = false;\n    }\n\n    var code = \"\";\n\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n\n    var intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    var direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    code += \"anisotropicOutParams anisotropicOut;\\n            anisotropicBlock(\\n                vec3(\" + direction + \", \" + intensity + \"),\\n            #ifdef ANISOTROPIC_TEXTURE\\n                vec3(0.),\\n            #endif\\n                TBN,\\n                normalW,\\n                viewDirectionW,\\n                anisotropicOut\\n            );\\r\\n\";\n    return code;\n  };\n\n  AnisotropyBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    _super.prototype.prepareDefines.call(this, mesh, nodeMaterial, defines);\n\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n  };\n\n  AnisotropyBlock.prototype._buildBlock = function (state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n\n    return this;\n  };\n\n  return AnisotropyBlock;\n}(NodeMaterialBlock);\n\nexport { AnisotropyBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.AnisotropyBlock\"] = AnisotropyBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/PBR/anisotropyBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n    */\r\n\r\n    /** @hidden */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @hidden */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n\r\n        this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        let comments = `//${this.name}`;\r\n        let uv = this.uv;\r\n        let worldPosition = this.worldPositionConnectionPoint;\r\n        let worldNormal = this.worldNormalConnectionPoint;\r\n        let worldTangent = this.worldTangent;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        let tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent);\\r\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"}, vec2(1., 1.));\r\n            #endif\\r\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [\r\n                tangentReplaceString,\r\n            ]\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n\r\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.AnisotropyBlock\"] = AnisotropyBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}