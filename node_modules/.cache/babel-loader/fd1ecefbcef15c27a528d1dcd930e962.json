{"ast":null,"code":"import { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { PointerEventTypes } from '../Events/pointerEvents';\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\n\nvar Gizmo =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a gizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   */\n  function Gizmo(\n  /** The utility layer the gizmo will be added to */\n  gizmoLayer) {\n    var _this = this;\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n\n    this._scaleRatio = 1;\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\n\n    this._isHovered = false;\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\n\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\n\n    this.updateGizmoPositionToMatchAttachedMesh = true;\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\n\n    this.updateScale = true;\n    this._interactionsEnabled = true;\n    this._tempQuaternion = new Quaternion(0, 0, 0, 1);\n    this._tempVector = new Vector3();\n    this._tempVector2 = new Vector3();\n    this._tempMatrix1 = new Matrix();\n    this._tempMatrix2 = new Matrix();\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {\n      _this._update();\n    });\n  }\n\n  Object.defineProperty(Gizmo.prototype, \"scaleRatio\", {\n    get: function () {\n      return this._scaleRatio;\n    },\n\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\n    set: function (value) {\n      this._scaleRatio = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\n    get: function () {\n      return this._isHovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedMesh\", {\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\n    get: function () {\n      return this._attachedMesh;\n    },\n    set: function (value) {\n      this._attachedMesh = value;\n\n      if (value) {\n        this._attachedNode = value;\n      }\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Gizmo.prototype, \"attachedNode\", {\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\n    get: function () {\n      return this._attachedNode;\n    },\n    set: function (value) {\n      this._attachedNode = value;\n      this._attachedMesh = null;\n\n      this._rootMesh.setEnabled(value ? true : false);\n\n      this._attachedNodeChanged(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   */\n\n  Gizmo.prototype.setCustomMesh = function (mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n\n    this._rootMesh.getChildMeshes().forEach(function (c) {\n      c.dispose();\n    });\n\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  };\n\n  Object.defineProperty(Gizmo.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n    get: function () {\n      return this._updateGizmoRotationToMatchAttachedMesh;\n    },\n\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\n    set: function (value) {\n      this._updateGizmoRotationToMatchAttachedMesh = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Gizmo.prototype._attachedNodeChanged = function (value) {};\n  /**\r\n   * Updates the gizmo to match the attached mesh's position/rotation\r\n   */\n\n\n  Gizmo.prototype._update = function () {\n    if (this.attachedNode) {\n      var effectiveNode = this.attachedNode;\n\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh._effectiveMesh || this.attachedNode;\n      } // Position\n\n\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        var row = effectiveNode.getWorldMatrix().getRow(3);\n        var position = row ? row.toVector3() : new Vector3(0, 0, 0);\n\n        this._rootMesh.position.copyFrom(position);\n      } // Rotation\n\n\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion);\n      } else {\n        this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n      } // Scale\n\n\n      if (this.updateScale) {\n        var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        var cameraPosition = activeCamera.globalPosition;\n\n        if (activeCamera.devicePosition) {\n          cameraPosition = activeCamera.devicePosition;\n        }\n\n        this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\n\n        var dist = this._tempVector.length() * this.scaleRatio;\n\n        this._rootMesh.scaling.set(dist, dist, dist); // Account for handedness, similar to Matrix.decompose\n\n\n        if (effectiveNode._getWorldMatrixDeterminant() < 0) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n  };\n  /**\r\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n   * @param value Node, TransformNode or mesh\r\n   */\n\n\n  Gizmo.prototype._matrixChanged = function () {\n    if (!this._attachedNode) {\n      return;\n    }\n\n    if (this._attachedNode._isCamera) {\n      var camera = this._attachedNode;\n      var worldMatrix;\n      var worldMatrixUC;\n\n      if (camera.parent) {\n        var parentInv = this._tempMatrix2;\n\n        camera.parent._worldMatrix.invertToRef(parentInv);\n\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\n\n        worldMatrix = this._tempMatrix1;\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\n\n        worldMatrixUC = this._tempMatrix2;\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n\n      worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\n      var inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n\n      if (inheritsTargetCamera) {\n        var targetCamera = this._attachedNode;\n        targetCamera.rotation = this._tempQuaternion.toEulerAngles();\n\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\n        }\n      }\n\n      camera.position.copyFrom(this._tempVector);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      var transform = this._attachedNode;\n\n      if (transform.parent) {\n        var parentInv = this._tempMatrix1;\n        var localMat = this._tempMatrix2;\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n\n        localMat.decompose(transform.scaling, this._tempQuaternion, transform.position);\n      } else {\n        this._attachedNode._worldMatrix.decompose(transform.scaling, this._tempQuaternion, transform.position);\n      }\n\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(this._tempQuaternion);\n        } else {\n          transform.rotation = this._tempQuaternion.toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      var bone = this._attachedNode;\n      var parent_1 = bone.getParent();\n\n      if (parent_1) {\n        var invParent = this._tempMatrix1;\n        var boneLocalMatrix = this._tempMatrix2;\n        parent_1.getWorldMatrix().invertToRef(invParent);\n        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        var lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getWorldMatrix());\n      }\n\n      bone.markAsDirty();\n    }\n  };\n  /**\r\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n   * @returns {Observer<PointerInfo>} pointerObserver\r\n   */\n\n\n  Gizmo.GizmoAxisPointerObserver = function (gizmoLayer, gizmoAxisCache) {\n    var dragging = false;\n    var pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      var _a, _b;\n\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n\n          gizmoAxisCache.forEach(function (cache) {\n            var _a, _b;\n\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material_1 = isHovered || cache.active ? cache.hoverMaterial : cache.material;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material_1;\n\n                if (m.color) {\n                  m.color = material_1.diffuseColor;\n                }\n              });\n            }\n          });\n        } // On Mouse Down\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {\n            dragging = true;\n            var statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(function (cache) {\n              var _a, _b;\n\n              var isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              var material = isHovered || cache.active ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(function (m) {\n                m.material = material;\n\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        } // On Mouse Up\n\n\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(function (cache) {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(function (m) {\n              m.material = cache.material;\n\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  Gizmo.prototype.dispose = function () {\n    this._rootMesh.dispose();\n\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  };\n\n  return Gizmo;\n}();\n\nexport { Gizmo };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/gizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { WebVRFreeCamera } from \"../Cameras/VR/webVRCamera\";\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { Node } from \"../node\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { TransformNode } from '../Meshes/transformNode';\r\nimport { StandardMaterial } from '../Materials/standardMaterial';\r\nimport { PointerEventTypes, PointerInfo } from '../Events/pointerEvents';\r\nimport { LinesMesh } from '../Meshes/linesMesh';\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to runder the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to inicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to inicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to inicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IDisposable {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    private _attachedMesh: Nullable<AbstractMesh> = null;\r\n    private _attachedNode: Nullable<Node> = null;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public updateGizmoPositionToMatchAttachedMesh = true;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    public updateScale = true;\r\n    protected _interactionsEnabled = true;\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {\r\n    }\r\n\r\n    private _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tempQuaternion = new Quaternion(0, 0, 0, 1);\r\n    private _tempVector = new Vector3();\r\n    private _tempVector2 = new Vector3();\r\n    private _tempMatrix1 = new Matrix();\r\n    private _tempMatrix2 = new Matrix();\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            var effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh._effectiveMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                this._rootMesh.position.copyFrom(position);\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!);\r\n            }\r\n            else {\r\n                this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                var cameraPosition = activeCamera.globalPosition;\r\n                if ((<WebVRFreeCamera>activeCamera).devicePosition) {\r\n                    cameraPosition = (<WebVRFreeCamera>activeCamera).devicePosition;\r\n                }\r\n                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);\r\n                var dist = this._tempVector.length() * this.scaleRatio;\r\n                this._rootMesh.scaling.set(dist, dist, dist);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     * @param value Node, TransformNode or mesh\r\n     */\r\n    protected _matrixChanged()\r\n    {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if  ((<Camera>this._attachedNode)._isCamera) {\r\n            var camera = this._attachedNode as Camera;\r\n            var worldMatrix;\r\n            var worldMatrixUC;\r\n            if (camera.parent) {\r\n                var parentInv = this._tempMatrix2;\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, this._tempMatrix1);\r\n                worldMatrix = this._tempMatrix1;\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, this._tempMatrix2);\r\n                worldMatrixUC = this._tempMatrix2;\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(this._tempVector2, this._tempQuaternion, this._tempVector);\r\n\r\n            var inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\"\r\n            || this._attachedNode.getClassName() === \"FlyCamera\"\r\n            || this._attachedNode.getClassName() === \"ArcFollowCamera\"\r\n            || this._attachedNode.getClassName() === \"TargetCamera\"\r\n            || this._attachedNode.getClassName() === \"TouchCamera\"\r\n            || this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                var targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = this._tempQuaternion.toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(this._tempVector);\r\n        } else if ((<Mesh>this._attachedNode)._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\r\n            var transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                var parentInv = this._tempMatrix1;\r\n                var localMat = this._tempMatrix2;\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(transform.scaling, this._tempQuaternion, transform.position);\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(transform.scaling, this._tempQuaternion, transform.position);\r\n            }\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(this._tempQuaternion);\r\n                } else {\r\n                    transform.rotation = this._tempQuaternion.toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            var bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                var invParent = this._tempMatrix1;\r\n                var boneLocalMatrix = this._tempMatrix2;\r\n                parent.getWorldMatrix().invertToRef(invParent);\r\n                bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                var lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                var lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getWorldMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) { return; }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = (cache.colliderMeshes?.indexOf((pointerInfo?.pickInfo?.pickedMesh as Mesh)) != -1);\r\n                            const material = isHovered || cache.active ? cache.hoverMaterial : cache.material;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = (cache.colliderMeshes?.indexOf((pointerInfo?.pickInfo?.pickedMesh as Mesh)) != -1);\r\n                            const material = isHovered || cache.active ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.material;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}