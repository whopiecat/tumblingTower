{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\nimport { ArrayTools } from \"../Misc/arrayTools\";\nimport { Node } from \"../node\";\nimport { Space } from '../Maths/math.axis';\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\n\nvar Bone =\n/** @class */\nfunction (_super) {\n  __extends(Bone, _super);\n  /**\r\n   * Create a new bone\r\n   * @param name defines the bone name\r\n   * @param skeleton defines the parent skeleton\r\n   * @param parentBone defines the parent (can be null if the bone is the root)\r\n   * @param localMatrix defines the local matrix\r\n   * @param restPose defines the rest pose matrix\r\n   * @param baseMatrix defines the base matrix\r\n   * @param index defines index of the bone in the hiearchy\r\n   */\n\n\n  function Bone(\n  /**\r\n   * defines the bone name\r\n   */\n  name, skeleton, parentBone, localMatrix, restPose, baseMatrix, index) {\n    if (parentBone === void 0) {\n      parentBone = null;\n    }\n\n    if (localMatrix === void 0) {\n      localMatrix = null;\n    }\n\n    if (restPose === void 0) {\n      restPose = null;\n    }\n\n    if (baseMatrix === void 0) {\n      baseMatrix = null;\n    }\n\n    if (index === void 0) {\n      index = null;\n    }\n\n    var _this = _super.call(this, name, skeleton.getScene()) || this;\n\n    _this.name = name;\n    /**\r\n     * Gets the list of child bones\r\n     */\n\n    _this.children = new Array();\n    /** Gets the animations associated with this bone */\n\n    _this.animations = new Array();\n    /**\r\n     * @hidden Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\n\n    _this._index = null;\n    _this._absoluteTransform = new Matrix();\n    _this._invertedAbsoluteTransform = new Matrix();\n    _this._scalingDeterminant = 1;\n    _this._worldTransform = new Matrix();\n    _this._needToDecompose = true;\n    _this._needToCompose = false;\n    /** @hidden */\n\n    _this._linkedTransformNode = null;\n    /** @hidden */\n\n    _this._waitingTransformNodeId = null;\n    _this._skeleton = skeleton;\n    _this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\n    _this._restPose = restPose ? restPose : _this._localMatrix.clone();\n    _this._bindPose = _this._localMatrix.clone();\n    _this._baseMatrix = baseMatrix ? baseMatrix : _this._localMatrix.clone();\n    _this._index = index;\n    skeleton.bones.push(_this);\n\n    _this.setParent(parentBone, false);\n\n    if (baseMatrix || localMatrix) {\n      _this._updateDifferenceMatrix();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Bone.prototype, \"_matrix\", {\n    /** @hidden */\n    get: function () {\n      this._compose();\n\n      return this._localMatrix;\n    },\n\n    /** @hidden */\n    set: function (value) {\n      this._localMatrix.copyFrom(value);\n\n      this._needToDecompose = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n  Bone.prototype.getClassName = function () {\n    return \"Bone\";\n  }; // Members\n\n  /**\r\n   * Gets the parent skeleton\r\n   * @returns a skeleton\r\n   */\n\n\n  Bone.prototype.getSkeleton = function () {\n    return this._skeleton;\n  };\n  /**\r\n   * Gets parent bone\r\n   * @returns a bone or null if the bone is the root of the bone hierarchy\r\n   */\n\n\n  Bone.prototype.getParent = function () {\n    return this._parent;\n  };\n  /**\r\n   * Returns an array containing the root bones\r\n   * @returns an array containing the root bones\r\n   */\n\n\n  Bone.prototype.getChildren = function () {\n    return this.children;\n  };\n  /**\r\n   * Gets the node index in matrix array generated for rendering\r\n   * @returns the node index\r\n   */\n\n\n  Bone.prototype.getIndex = function () {\n    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\n  };\n  /**\r\n   * Sets the parent bone\r\n   * @param parent defines the parent (can be null if the bone is the root)\r\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n   */\n\n\n  Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (this._parent === parent) {\n      return;\n    }\n\n    if (this._parent) {\n      var index = this._parent.children.indexOf(this);\n\n      if (index !== -1) {\n        this._parent.children.splice(index, 1);\n      }\n    }\n\n    this._parent = parent;\n\n    if (this._parent) {\n      this._parent.children.push(this);\n    }\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    this.markAsDirty();\n  };\n  /**\r\n   * Gets the local matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getLocalMatrix = function () {\n    this._compose();\n\n    return this._localMatrix;\n  };\n  /**\r\n   * Gets the base matrix (initial matrix which remains unchanged)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getBaseMatrix = function () {\n    return this._baseMatrix;\n  };\n  /**\r\n   * Gets the rest pose matrix\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getRestPose = function () {\n    return this._restPose;\n  };\n  /**\r\n   * Sets the rest pose matrix\r\n   * @param matrix the local-space rest pose to set for this bone\r\n   */\n\n\n  Bone.prototype.setRestPose = function (matrix) {\n    this._restPose.copyFrom(matrix);\n  };\n  /**\r\n   * Gets the bind pose matrix\r\n   * @returns the bind pose matrix\r\n   */\n\n\n  Bone.prototype.getBindPose = function () {\n    return this._bindPose;\n  };\n  /**\r\n   * Sets the bind pose matrix\r\n   * @param matrix the local-space bind pose to set for this bone\r\n   */\n\n\n  Bone.prototype.setBindPose = function (matrix) {\n    this._bindPose.copyFrom(matrix);\n  };\n  /**\r\n   * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n   */\n\n\n  Bone.prototype.getWorldMatrix = function () {\n    return this._worldTransform;\n  };\n  /**\r\n   * Sets the local matrix to rest pose matrix\r\n   */\n\n\n  Bone.prototype.returnToRest = function () {\n    if (this._skeleton._numBonesWithLinkedTransformNode > 0) {\n      this.updateMatrix(this._restPose, false, false);\n    } else {\n      this.updateMatrix(this._restPose, false, true);\n    }\n  };\n  /**\r\n   * Gets the inverse of the absolute transform matrix.\r\n   * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getInvertedAbsoluteTransform = function () {\n    return this._invertedAbsoluteTransform;\n  };\n  /**\r\n   * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n   * @returns a matrix\r\n   */\n\n\n  Bone.prototype.getAbsoluteTransform = function () {\n    return this._absoluteTransform;\n  };\n  /**\r\n   * Links with the given transform node.\r\n   * The local matrix of this bone is copied from the transform node every frame.\r\n   * @param transformNode defines the transform node to link to\r\n   */\n\n\n  Bone.prototype.linkTransformNode = function (transformNode) {\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode--;\n    }\n\n    this._linkedTransformNode = transformNode;\n\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode++;\n    }\n  }; // Properties (matches AbstractMesh properties)\n\n  /**\r\n   * Gets the node used to drive the bone's transformation\r\n   * @returns a transform node or null\r\n   */\n\n\n  Bone.prototype.getTransformNode = function () {\n    return this._linkedTransformNode;\n  };\n\n  Object.defineProperty(Bone.prototype, \"position\", {\n    /** Gets or sets current position (in local space) */\n    get: function () {\n      this._decompose();\n\n      return this._localPosition;\n    },\n    set: function (newPosition) {\n      this._decompose();\n\n      this._localPosition.copyFrom(newPosition);\n\n      this._markAsDirtyAndCompose();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotation\", {\n    /** Gets or sets current rotation (in local space) */\n    get: function () {\n      return this.getRotation();\n    },\n    set: function (newRotation) {\n      this.setRotation(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\n    /** Gets or sets current rotation quaternion (in local space) */\n    get: function () {\n      this._decompose();\n\n      return this._localRotation;\n    },\n    set: function (newRotation) {\n      this.setRotationQuaternion(newRotation);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"scaling\", {\n    /** Gets or sets current scaling (in local space) */\n    get: function () {\n      return this.getScale();\n    },\n    set: function (newScaling) {\n      this.setScale(newScaling);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Bone.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets the animation properties override\r\n     */\n    get: function () {\n      return this._skeleton.animationPropertiesOverride;\n    },\n    enumerable: false,\n    configurable: true\n  }); // Methods\n\n  Bone.prototype._decompose = function () {\n    if (!this._needToDecompose) {\n      return;\n    }\n\n    this._needToDecompose = false;\n\n    if (!this._localScaling) {\n      this._localScaling = Vector3.Zero();\n      this._localRotation = Quaternion.Zero();\n      this._localPosition = Vector3.Zero();\n    }\n\n    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\n  };\n\n  Bone.prototype._compose = function () {\n    if (!this._needToCompose) {\n      return;\n    }\n\n    if (!this._localScaling) {\n      this._needToCompose = false;\n      return;\n    }\n\n    this._needToCompose = false;\n    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\n  };\n  /**\r\n   * Update the base and local matrices\r\n   * @param matrix defines the new base or local matrix\r\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n   * @param updateLocalMatrix defines if the local matrix should be updated\r\n   */\n\n\n  Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix, updateLocalMatrix) {\n    if (updateDifferenceMatrix === void 0) {\n      updateDifferenceMatrix = true;\n    }\n\n    if (updateLocalMatrix === void 0) {\n      updateLocalMatrix = true;\n    }\n\n    this._baseMatrix.copyFrom(matrix);\n\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n\n    if (updateLocalMatrix) {\n      this._needToCompose = false; // in case there was a pending compose\n\n      this._localMatrix.copyFrom(matrix);\n\n      this._markAsDirtyAndDecompose();\n    } else {\n      this.markAsDirty();\n    }\n  };\n  /** @hidden */\n\n\n  Bone.prototype._updateDifferenceMatrix = function (rootMatrix, updateChildren) {\n    if (updateChildren === void 0) {\n      updateChildren = true;\n    }\n\n    if (!rootMatrix) {\n      rootMatrix = this._baseMatrix;\n    }\n\n    if (this._parent) {\n      rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(rootMatrix);\n    }\n\n    this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n\n    if (updateChildren) {\n      for (var index = 0; index < this.children.length; index++) {\n        this.children[index]._updateDifferenceMatrix();\n      }\n    }\n\n    this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n  };\n  /**\r\n   * Flag the bone as dirty (Forcing it to update everything)\r\n   */\n\n\n  Bone.prototype.markAsDirty = function () {\n    this._currentRenderId++;\n    this._childUpdateId++;\n\n    this._skeleton._markAsDirty();\n  };\n  /** @hidden */\n\n\n  Bone.prototype._markAsDirtyAndCompose = function () {\n    this.markAsDirty();\n    this._needToCompose = true;\n  };\n\n  Bone.prototype._markAsDirtyAndDecompose = function () {\n    this.markAsDirty();\n    this._needToDecompose = true;\n  };\n  /**\r\n   * Translate the bone in local or world space\r\n   * @param vec The amount to translate the bone\r\n   * @param space The space that the translation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.translate = function (vec, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.addAtIndex(12, vec.x);\n      lm.addAtIndex(13, vec.y);\n      lm.addAtIndex(14, vec.z);\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n      var tvec = Bone._tmpVecs[0];\n\n      if (this._parent) {\n        if (mesh && wm) {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n        }\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      tmat.setTranslationFromFloats(0, 0, 0);\n      tmat.invert();\n      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n      lm.addAtIndex(12, tvec.x);\n      lm.addAtIndex(13, tvec.y);\n      lm.addAtIndex(14, tvec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\r\n   * Set the postion of the bone in local or world space\r\n   * @param position The position to set the bone\r\n   * @param space The space that the position is in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setPosition = function (position, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lm = this.getLocalMatrix();\n\n    if (space == Space.LOCAL) {\n      lm.setTranslationFromFloats(position.x, position.y, position.z);\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n      var vec = Bone._tmpVecs[0];\n\n      if (this._parent) {\n        if (mesh && wm) {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this._parent.getAbsoluteTransform());\n        }\n\n        tmat.invert();\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n\n      Vector3.TransformCoordinatesToRef(position, tmat, vec);\n      lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\n    }\n\n    this._markAsDirtyAndDecompose();\n  };\n  /**\r\n   * Set the absolute position of the bone (world space)\r\n   * @param position The position to set the bone\r\n   * @param mesh The mesh that this bone is attached to\r\n   */\n\n\n  Bone.prototype.setAbsolutePosition = function (position, mesh) {\n    this.setPosition(position, Space.WORLD, mesh);\n  };\n  /**\r\n   * Scale the bone on the x, y and z axes (in local space)\r\n   * @param x The amount to scale the bone on the x axis\r\n   * @param y The amount to scale the bone on the y axis\r\n   * @param z The amount to scale the bone on the z axis\r\n   * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n   */\n\n\n  Bone.prototype.scale = function (x, y, z, scaleChildren) {\n    if (scaleChildren === void 0) {\n      scaleChildren = false;\n    }\n\n    var locMat = this.getLocalMatrix(); // Apply new scaling on top of current local matrix\n\n    var scaleMat = Bone._tmpMats[0];\n    Matrix.ScalingToRef(x, y, z, scaleMat);\n    scaleMat.multiplyToRef(locMat, locMat); // Invert scaling matrix and apply the inverse to all children\n\n    scaleMat.invert();\n\n    for (var _i = 0, _a = this.children; _i < _a.length; _i++) {\n      var child = _a[_i];\n      var cm = child.getLocalMatrix();\n      cm.multiplyToRef(scaleMat, cm);\n      cm.multiplyAtIndex(12, x);\n      cm.multiplyAtIndex(13, y);\n      cm.multiplyAtIndex(14, z);\n\n      child._markAsDirtyAndDecompose();\n    }\n\n    this._markAsDirtyAndDecompose();\n\n    if (scaleChildren) {\n      for (var _b = 0, _c = this.children; _b < _c.length; _b++) {\n        var child = _c[_b];\n        child.scale(x, y, z, scaleChildren);\n      }\n    }\n  };\n  /**\r\n   * Set the bone scaling in local space\r\n   * @param scale defines the scaling vector\r\n   */\n\n\n  Bone.prototype.setScale = function (scale) {\n    this._decompose();\n\n    this._localScaling.copyFrom(scale);\n\n    this._markAsDirtyAndCompose();\n  };\n  /**\r\n   * Gets the current scaling in local space\r\n   * @returns the current scaling vector\r\n   */\n\n\n  Bone.prototype.getScale = function () {\n    this._decompose();\n\n    return this._localScaling;\n  };\n  /**\r\n   * Gets the current scaling in local space and stores it in a target vector\r\n   * @param result defines the target vector\r\n   */\n\n\n  Bone.prototype.getScaleToRef = function (result) {\n    this._decompose();\n\n    result.copyFrom(this._localScaling);\n  };\n  /**\r\n   * Set the yaw, pitch, and roll of the bone in local or world space\r\n   * @param yaw The rotation of the bone on the y axis\r\n   * @param pitch The rotation of the bone on the x axis\r\n   * @param roll The rotation of the bone on the z axis\r\n   * @param space The space that the axes of rotation are in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Add a rotation to the bone on an axis in local or world space\r\n   * @param axis The axis to rotate the bone on\r\n   * @param amount The amount to rotate the bone\r\n   * @param space The space that the axis is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.rotate = function (axis, amount, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var rmat = Bone._tmpMats[0];\n    rmat.setTranslationFromFloats(0, 0, 0);\n    Matrix.RotationAxisToRef(axis, amount, rmat);\n\n    this._rotateWithMatrix(rmat, space, mesh);\n  };\n  /**\r\n   * Set the rotation of the bone to a particular axis angle in local or world space\r\n   * @param axis The axis to rotate the bone on\r\n   * @param angle The angle that the bone should be rotated to\r\n   * @param space The space that the axis is in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   */\n\n\n  Bone.prototype.setAxisAngle = function (axis, angle, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.RotationAxisToRef(axis, angle, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.RotationAxisToRef(axis, angle, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Set the euler rotation of the bone in local or world space\r\n   * @param rotation The euler rotation that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotation = function (rotation, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\n  };\n  /**\r\n   * Set the quaternion rotation of the bone in local or world space\r\n   * @param quat The quaternion rotation that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotationQuaternion = function (quat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      this._decompose();\n\n      this._localRotation.copyFrom(quat);\n\n      this._markAsDirtyAndCompose();\n\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat = Bone._tmpMats[1];\n    Matrix.FromQuaternionToRef(quat, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n\n    this._rotateWithMatrix(rotMat, space, mesh);\n  };\n  /**\r\n   * Set the rotation matrix of the bone in local or world space\r\n   * @param rotMat The rotation matrix that the bone should be set to\r\n   * @param space The space that the rotation is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   */\n\n\n  Bone.prototype.setRotationMatrix = function (rotMat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space === Space.LOCAL) {\n      var quat = Bone._tmpQuat;\n      Quaternion.FromRotationMatrixToRef(rotMat, quat);\n      this.setRotationQuaternion(quat, space, mesh);\n      return;\n    }\n\n    var rotMatInv = Bone._tmpMats[0];\n\n    if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\n      return;\n    }\n\n    var rotMat2 = Bone._tmpMats[1];\n    rotMat2.copyFrom(rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat2);\n\n    this._rotateWithMatrix(rotMat2, space, mesh);\n  };\n\n  Bone.prototype._rotateWithMatrix = function (rmat, space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var lmat = this.getLocalMatrix();\n    var lx = lmat.m[12];\n    var ly = lmat.m[13];\n    var lz = lmat.m[14];\n    var parent = this.getParent();\n    var parentScale = Bone._tmpMats[3];\n    var parentScaleInv = Bone._tmpMats[4];\n\n    if (parent && space == Space.WORLD) {\n      if (mesh) {\n        parentScale.copyFrom(mesh.getWorldMatrix());\n        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n      } else {\n        parentScale.copyFrom(parent.getAbsoluteTransform());\n      }\n\n      parentScaleInv.copyFrom(parentScale);\n      parentScaleInv.invert();\n      lmat.multiplyToRef(parentScale, lmat);\n      lmat.multiplyToRef(rmat, lmat);\n      lmat.multiplyToRef(parentScaleInv, lmat);\n    } else {\n      if (space == Space.WORLD && mesh) {\n        parentScale.copyFrom(mesh.getWorldMatrix());\n        parentScaleInv.copyFrom(parentScale);\n        parentScaleInv.invert();\n        lmat.multiplyToRef(parentScale, lmat);\n        lmat.multiplyToRef(rmat, lmat);\n        lmat.multiplyToRef(parentScaleInv, lmat);\n      } else {\n        lmat.multiplyToRef(rmat, lmat);\n      }\n    }\n\n    lmat.setTranslationFromFloats(lx, ly, lz);\n    this.computeAbsoluteTransforms();\n\n    this._markAsDirtyAndDecompose();\n  };\n\n  Bone.prototype._getNegativeRotationToRef = function (rotMatInv, mesh) {\n    var scaleMatrix = Bone._tmpMats[2];\n    rotMatInv.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh) {\n      rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\n      Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);\n    }\n\n    rotMatInv.invert();\n\n    if (isNaN(rotMatInv.m[0])) {\n      // Matrix failed to invert.\n      // This can happen if scale is zero for example.\n      return false;\n    }\n\n    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\n    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n    return true;\n  };\n  /**\r\n   * Get the position of the bone in local or world space\r\n   * @param space The space that the returned position is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   * @returns The position of the bone\r\n   */\n\n\n  Bone.prototype.getPosition = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(space, mesh, pos);\n    return pos;\n  };\n  /**\r\n   * Copy the position of the bone to a vector3 in local or world space\r\n   * @param space The space that the returned position is in\r\n   * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n   * @param result The vector3 to copy the position to\r\n   */\n\n\n  Bone.prototype.getPositionToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      var lm = this.getLocalMatrix();\n      result.x = lm.m[12];\n      result.y = lm.m[13];\n      result.z = lm.m[14];\n    } else {\n      var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n      if (mesh) {\n        wm = mesh.getWorldMatrix();\n      }\n\n      this._skeleton.computeAbsoluteTransforms();\n\n      var tmat = Bone._tmpMats[0];\n\n      if (mesh && wm) {\n        tmat.copyFrom(this.getAbsoluteTransform());\n        tmat.multiplyToRef(wm, tmat);\n      } else {\n        tmat = this.getAbsoluteTransform();\n      }\n\n      result.x = tmat.m[12];\n      result.y = tmat.m[13];\n      result.z = tmat.m[14];\n    }\n  };\n  /**\r\n   * Get the absolute position of the bone (world space)\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The absolute position of the bone\r\n   */\n\n\n  Bone.prototype.getAbsolutePosition = function (mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var pos = Vector3.Zero();\n    this.getPositionToRef(Space.WORLD, mesh, pos);\n    return pos;\n  };\n  /**\r\n   * Copy the absolute position of the bone (world space) to the result param\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 to copy the absolute position to\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionToRef = function (mesh, result) {\n    this.getPositionToRef(Space.WORLD, mesh, result);\n  };\n  /**\r\n   * Compute the absolute transforms of this bone and its children\r\n   */\n\n\n  Bone.prototype.computeAbsoluteTransforms = function () {\n    this._compose();\n\n    if (this._parent) {\n      this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(this._localMatrix);\n\n      var poseMatrix = this._skeleton.getPoseMatrix();\n\n      if (poseMatrix) {\n        this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n      }\n    }\n\n    var children = this.children;\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      children[i].computeAbsoluteTransforms();\n    }\n  };\n  /**\r\n   * Get the world direction from an axis that is in the local space of the bone\r\n   * @param localAxis The local direction that is used to compute the world direction\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The world direction\r\n   */\n\n\n  Bone.prototype.getDirection = function (localAxis, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n   * @param localAxis The local direction that is used to compute the world direction\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the world direction will be copied to\r\n   */\n\n\n  Bone.prototype.getDirectionToRef = function (localAxis, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var mat = Bone._tmpMats[0];\n    mat.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh && wm) {\n      mat.multiplyToRef(wm, mat);\n    }\n\n    Vector3.TransformNormalToRef(localAxis, mat, result);\n    result.normalize();\n  };\n  /**\r\n   * Get the euler rotation of the bone in local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The euler rotation\r\n   */\n\n\n  Bone.prototype.getRotation = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getRotationToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The vector3 that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var quat = Bone._tmpQuat;\n    this.getRotationQuaternionToRef(space, mesh, quat);\n    quat.toEulerAnglesToRef(result);\n  };\n  /**\r\n   * Get the quaternion rotation of the bone in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The quaternion rotation\r\n   */\n\n\n  Bone.prototype.getRotationQuaternion = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Quaternion.Identity();\n    this.getRotationQuaternionToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The quaternion that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationQuaternionToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    if (space == Space.LOCAL) {\n      this._decompose();\n\n      result.copyFrom(this._localRotation);\n    } else {\n      var mat = Bone._tmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (mesh) {\n        amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.decompose(undefined, result, undefined);\n    }\n  };\n  /**\r\n   * Get the rotation matrix of the bone in local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @returns The rotation matrix\r\n   */\n\n\n  Bone.prototype.getRotationMatrix = function (space, mesh) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    var result = Matrix.Identity();\n    this.getRotationMatrixToRef(space, mesh, result);\n    return result;\n  };\n  /**\r\n   * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n   * @param space The space that the rotation should be in\r\n   * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n   * @param result The quaternion that the rotation should be copied to\r\n   */\n\n\n  Bone.prototype.getRotationMatrixToRef = function (space, mesh, result) {\n    if (space === void 0) {\n      space = Space.LOCAL;\n    }\n\n    if (space == Space.LOCAL) {\n      this.getLocalMatrix().getRotationMatrixToRef(result);\n    } else {\n      var mat = Bone._tmpMats[0];\n      var amat = this.getAbsoluteTransform();\n\n      if (mesh) {\n        amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.getRotationMatrixToRef(result);\n    }\n  };\n  /**\r\n   * Get the world position of a point that is in the local space of the bone\r\n   * @param position The local position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The world position\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocal = function (position, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getAbsolutePositionFromLocalToRef(position, mesh, result);\n    return result;\n  };\n  /**\r\n   * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n   * @param position The local position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the world position should be copied to\r\n   */\n\n\n  Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._tmpMats[0];\n\n    if (mesh && wm) {\n      tmat.copyFrom(this.getAbsoluteTransform());\n      tmat.multiplyToRef(wm, tmat);\n    } else {\n      tmat = this.getAbsoluteTransform();\n    }\n\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\r\n   * Get the local position of a point that is in world space\r\n   * @param position The world position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @returns The local position\r\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsolute = function (position, mesh) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var result = Vector3.Zero();\n    this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\n    return result;\n  };\n  /**\r\n   * Get the local position of a point that is in world space and copy it to the result param\r\n   * @param position The world position\r\n   * @param mesh The mesh that this bone is attached to\r\n   * @param result The vector3 that the local position should be copied to\r\n   */\n\n\n  Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, mesh, result) {\n    if (mesh === void 0) {\n      mesh = null;\n    }\n\n    var wm = null; //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n\n    if (mesh) {\n      wm = mesh.getWorldMatrix();\n    }\n\n    this._skeleton.computeAbsoluteTransforms();\n\n    var tmat = Bone._tmpMats[0];\n    tmat.copyFrom(this.getAbsoluteTransform());\n\n    if (mesh && wm) {\n      tmat.multiplyToRef(wm, tmat);\n    }\n\n    tmat.invert();\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  };\n  /**\r\n   * Set the current local matrix as the restPose for this bone.\r\n   */\n\n\n  Bone.prototype.setCurrentPoseAsRest = function () {\n    this.setRestPose(this.getLocalMatrix());\n  };\n\n  Bone._tmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\n  Bone._tmpQuat = Quaternion.Identity();\n  Bone._tmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n  return Bone;\n}(Node);\n\nexport { Bone };","map":{"version":3,"sources":["../../../sourceES6/core/Bones/bone.ts"],"names":[],"mappings":";AAEA,SAAS,OAAT,EAAkB,UAAlB,EAA8B,MAA9B,QAA4C,sBAA5C;AACA,SAAS,UAAT,QAA2B,oBAA3B;AAIA,SAAS,IAAT,QAAqB,SAArB;AACA,SAAS,KAAT,QAAsB,oBAAtB;AAKA;;;;;AAIA,IAAA,IAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA0B,EAAA,SAAA,CAAA,IAAA,EAAA,MAAA,CAAA;AA6DtB;;;;;;;;;;;;AAUA,WAAA,IAAA;AACI;;;AAGO,EAAA,IAJX,EAIyB,QAJzB,EAI6C,UAJ7C,EAIgF,WAJhF,EAKI,QALJ,EAKuC,UALvC,EAK4E,KAL5E,EAK0G;AAD7D,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAA,IAAA;AAAiC;;AAAE,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,IAAA;AAAoC;;AAChH,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA,IAAA;AAAiC;;AAAE,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAA,IAAA;AAAmC;;AAAE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA8B;;AAL1G,QAAA,KAAA,GAMI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,QAAQ,CAAC,QAAT,EAAZ,KAAgC,IANpC;;AAIW,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA;AArEX;;;;AAGO,IAAA,KAAA,CAAA,QAAA,GAAW,IAAI,KAAJ,EAAX;AAEP;;AACO,IAAA,KAAA,CAAA,UAAA,GAAa,IAAI,KAAJ,EAAb;AAOP;;;;;;AAKO,IAAA,KAAA,CAAA,MAAA,GAA2B,IAA3B;AAOC,IAAA,KAAA,CAAA,kBAAA,GAAqB,IAAI,MAAJ,EAArB;AACA,IAAA,KAAA,CAAA,0BAAA,GAA6B,IAAI,MAAJ,EAA7B;AAEA,IAAA,KAAA,CAAA,mBAAA,GAAsB,CAAtB;AACA,IAAA,KAAA,CAAA,eAAA,GAAkB,IAAI,MAAJ,EAAlB;AAKA,IAAA,KAAA,CAAA,gBAAA,GAAmB,IAAnB;AACA,IAAA,KAAA,CAAA,cAAA,GAAiB,KAAjB;AAER;;AACO,IAAA,KAAA,CAAA,oBAAA,GAAgD,IAAhD;AAEP;;AACO,IAAA,KAAA,CAAA,uBAAA,GAA4C,IAA5C;AA+BH,IAAA,KAAI,CAAC,SAAL,GAAiB,QAAjB;AACA,IAAA,KAAI,CAAC,YAAL,GAAoB,WAAW,GAAG,WAAW,CAAC,KAAZ,EAAH,GAAyB,MAAM,CAAC,QAAP,EAAxD;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,QAAQ,GAAG,QAAH,GAAc,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAvC;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAjB;AACA,IAAA,KAAI,CAAC,WAAL,GAAmB,UAAU,GAAG,UAAH,GAAgB,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAA7C;AACA,IAAA,KAAI,CAAC,MAAL,GAAc,KAAd;AAEA,IAAA,QAAQ,CAAC,KAAT,CAAe,IAAf,CAAoB,KAApB;;AAEA,IAAA,KAAI,CAAC,SAAL,CAAe,UAAf,EAA2B,KAA3B;;AAEA,QAAI,UAAU,IAAI,WAAlB,EAA+B;AAC3B,MAAA,KAAI,CAAC,uBAAL;AACH;;;AACJ;;AA1CD,EAAA,MAAA,CAAA,cAAA,CAAI,IAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;AADX;SACA,YAAA;AACI,WAAK,QAAL;;AACA,aAAO,KAAK,YAAZ;AACH,KAHU;;AAKX;SACA,UAAY,KAAZ,EAAyB;AACrB,WAAK,YAAL,CAAkB,QAAlB,CAA2B,KAA3B;;AACA,WAAK,gBAAL,GAAwB,IAAxB;AACH,KATU;qBAAA;;AAAA,GAAX;AA4CA;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,MAAP;AACH,GAFM,CAlGX,CAsGI;;AAEA;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,SAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,KAAK,OAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,QAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,KAAK,MAAL,KAAgB,IAAhB,GAAuB,KAAK,WAAL,GAAmB,KAAnB,CAAyB,OAAzB,CAAiC,IAAjC,CAAvB,GAAgE,KAAK,MAA5E;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,MAAjB,EAAyC,sBAAzC,EAA+E;AAAtC,QAAA,sBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,sBAAA,GAAA,IAAA;AAAsC;;AAC3E,QAAI,KAAK,OAAL,KAAiB,MAArB,EAA6B;AACzB;AACH;;AAED,QAAI,KAAK,OAAT,EAAkB;AACd,UAAI,KAAK,GAAG,KAAK,OAAL,CAAa,QAAb,CAAsB,OAAtB,CAA8B,IAA9B,CAAZ;;AACA,UAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd,aAAK,OAAL,CAAa,QAAb,CAAsB,MAAtB,CAA6B,KAA7B,EAAoC,CAApC;AACH;AACJ;;AAED,SAAK,OAAL,GAAe,MAAf;;AAEA,QAAI,KAAK,OAAT,EAAkB;AACd,WAAK,OAAL,CAAa,QAAb,CAAsB,IAAtB,CAA2B,IAA3B;AACH;;AAED,QAAI,sBAAJ,EAA4B;AACxB,WAAK,uBAAL;AACH;;AAED,SAAK,WAAL;AACH,GAvBM;AAyBP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,SAAK,QAAL;;AACA,WAAO,KAAK,YAAZ;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,GAAP,YAAA;AACI,WAAO,KAAK,WAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,SAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAiC;AAC7B,SAAK,SAAL,CAAe,QAAf,CAAwB,MAAxB;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,SAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAiC;AAC7B,SAAK,SAAL,CAAe,QAAf,CAAwB,MAAxB;AACH,GAFM;AAIP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,cAAA,GAAP,YAAA;AACI,WAAO,KAAK,eAAZ;AACH,GAFM;AAIP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,QAAI,KAAK,SAAL,CAAe,gCAAf,GAAkD,CAAtD,EAAyD;AACrD,WAAK,YAAL,CAAkB,KAAK,SAAvB,EAAkC,KAAlC,EAAyC,KAAzC;AACH,KAFD,MAEO;AACH,WAAK,YAAL,CAAkB,KAAK,SAAvB,EAAkC,KAAlC,EAAyC,IAAzC;AACH;AACJ,GANM;AAQP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,4BAAA,GAAP,YAAA;AACI,WAAO,KAAK,0BAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACI,WAAO,KAAK,kBAAZ;AACH,GAFM;AAIP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,aAAzB,EAA+D;AAC3D,QAAI,KAAK,oBAAT,EAA+B;AAC3B,WAAK,SAAL,CAAe,gCAAf;AACH;;AAED,SAAK,oBAAL,GAA4B,aAA5B;;AAEA,QAAI,KAAK,oBAAT,EAA+B;AAC3B,WAAK,SAAL,CAAe,gCAAf;AACH;AACJ,GAVM,CA/PX,CA2QI;;AAEA;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,YAAA;AACI,WAAO,KAAK,oBAAZ;AACH,GAFM;;AAKP,EAAA,MAAA,CAAA,cAAA,CAAW,IAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AADnB;SACA,YAAA;AACI,WAAK,UAAL;;AACA,aAAO,KAAK,cAAZ;AACH,KAHkB;SAKnB,UAAoB,WAApB,EAAwC;AACpC,WAAK,UAAL;;AACA,WAAK,cAAL,CAAoB,QAApB,CAA6B,WAA7B;;AAEA,WAAK,sBAAL;AACH,KAVkB;qBAAA;;AAAA,GAAnB;AAaA,EAAA,MAAA,CAAA,cAAA,CAAW,IAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AADnB;SACA,YAAA;AACI,aAAO,KAAK,WAAL,EAAP;AACH,KAFkB;SAInB,UAAoB,WAApB,EAAwC;AACpC,WAAK,WAAL,CAAiB,WAAjB;AACH,KANkB;qBAAA;;AAAA,GAAnB;AASA,EAAA,MAAA,CAAA,cAAA,CAAW,IAAA,CAAA,SAAX,EAAW,oBAAX,EAA6B;AAD7B;SACA,YAAA;AACI,WAAK,UAAL;;AACA,aAAO,KAAK,cAAZ;AACH,KAH4B;SAK7B,UAA8B,WAA9B,EAAqD;AACjD,WAAK,qBAAL,CAA2B,WAA3B;AACH,KAP4B;qBAAA;;AAAA,GAA7B;AAUA,EAAA,MAAA,CAAA,cAAA,CAAW,IAAA,CAAA,SAAX,EAAW,SAAX,EAAkB;AADlB;SACA,YAAA;AACI,aAAO,KAAK,QAAL,EAAP;AACH,KAFiB;SAIlB,UAAmB,UAAnB,EAAsC;AAClC,WAAK,QAAL,CAAc,UAAd;AACH,KANiB;qBAAA;;AAAA,GAAlB;AAWA,EAAA,MAAA,CAAA,cAAA,CAAW,IAAA,CAAA,SAAX,EAAW,6BAAX,EAAsC;AAHtC;;;SAGA,YAAA;AACI,aAAO,KAAK,SAAL,CAAe,2BAAtB;AACH,KAFqC;qBAAA;;AAAA,GAAtC,EAjUJ,CAqUI;;AACQ,EAAA,IAAA,CAAA,SAAA,CAAA,UAAA,GAAR,YAAA;AACI,QAAI,CAAC,KAAK,gBAAV,EAA4B;AACxB;AACH;;AAED,SAAK,gBAAL,GAAwB,KAAxB;;AAEA,QAAI,CAAC,KAAK,aAAV,EAAyB;AACrB,WAAK,aAAL,GAAqB,OAAO,CAAC,IAAR,EAArB;AACA,WAAK,cAAL,GAAsB,UAAU,CAAC,IAAX,EAAtB;AACA,WAAK,cAAL,GAAsB,OAAO,CAAC,IAAR,EAAtB;AACH;;AACD,SAAK,YAAL,CAAkB,SAAlB,CAA4B,KAAK,aAAjC,EAAgD,KAAK,cAArD,EAAqE,KAAK,cAA1E;AACH,GAbO;;AAeA,EAAA,IAAA,CAAA,SAAA,CAAA,QAAA,GAAR,YAAA;AACI,QAAI,CAAC,KAAK,cAAV,EAA0B;AACtB;AACH;;AAED,QAAI,CAAC,KAAK,aAAV,EAAyB;AACrB,WAAK,cAAL,GAAsB,KAAtB;AACA;AACH;;AAED,SAAK,cAAL,GAAsB,KAAtB;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,KAAK,aAAzB,EAAwC,KAAK,cAA7C,EAA6D,KAAK,cAAlE,EAAkF,KAAK,YAAvF;AACH,GAZO;AAcR;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,MAApB,EAAoC,sBAApC,EAAmE,iBAAnE,EAA2F;AAAvD,QAAA,sBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,sBAAA,GAAA,IAAA;AAA6B;;AAAE,QAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,IAAA;AAAwB;;AACvF,SAAK,WAAL,CAAiB,QAAjB,CAA0B,MAA1B;;AAEA,QAAI,sBAAJ,EAA4B;AACxB,WAAK,uBAAL;AACH;;AAED,QAAI,iBAAJ,EAAuB;AACnB,WAAK,cAAL,GAAsB,KAAtB,CADmB,CACU;;AAC7B,WAAK,YAAL,CAAkB,QAAlB,CAA2B,MAA3B;;AACA,WAAK,wBAAL;AACH,KAJD,MAKK;AACD,WAAK,WAAL;AACH;AACJ,GAfM;AAiBP;;;AACO,EAAA,IAAA,CAAA,SAAA,CAAA,uBAAA,GAAP,UAA+B,UAA/B,EAAoD,cAApD,EAAyE;AAArB,QAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,cAAA,GAAA,IAAA;AAAqB;;AACrE,QAAI,CAAC,UAAL,EAAiB;AACb,MAAA,UAAU,GAAG,KAAK,WAAlB;AACH;;AAED,QAAI,KAAK,OAAT,EAAkB;AACd,MAAA,UAAU,CAAC,aAAX,CAAyB,KAAK,OAAL,CAAa,kBAAtC,EAA0D,KAAK,kBAA/D;AACH,KAFD,MAEO;AACH,WAAK,kBAAL,CAAwB,QAAxB,CAAiC,UAAjC;AACH;;AAED,SAAK,kBAAL,CAAwB,WAAxB,CAAoC,KAAK,0BAAzC;;AAEA,QAAI,cAAJ,EAAoB;AAChB,WAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,KAAK,QAAL,CAAc,MAA1C,EAAkD,KAAK,EAAvD,EAA2D;AACvD,aAAK,QAAL,CAAc,KAAd,EAAqB,uBAArB;AACH;AACJ;;AAED,SAAK,mBAAL,GAA4B,KAAK,kBAAL,CAAwB,WAAxB,KAAwC,CAAxC,GAA4C,CAAC,CAA7C,GAAiD,CAA7E;AACH,GApBM;AAsBP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,SAAK,gBAAL;AACA,SAAK,cAAL;;AACA,SAAK,SAAL,CAAe,YAAf;AACH,GAJM;AAMP;;;AACO,EAAA,IAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,YAAA;AACI,SAAK,WAAL;AACA,SAAK,cAAL,GAAsB,IAAtB;AACH,GAHM;;AAKC,EAAA,IAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,YAAA;AACI,SAAK,WAAL;AACA,SAAK,gBAAL,GAAwB,IAAxB;AACH,GAHO;AAKR;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,GAAjB,EAA+B,KAA/B,EAAoD,IAApD,EAAuE;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAC9C,QAAI,EAAE,GAAG,KAAK,cAAL,EAAT;;AAEA,QAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACtB,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,GAAG,CAAC,CAAtB;AACA,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,GAAG,CAAC,CAAtB;AACA,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,GAAG,CAAC,CAAtB;AACH,KAJD,MAIO;AACH,UAAI,EAAE,GAAqB,IAA3B,CADG,CAGH;;AACA,UAAI,IAAJ,EAAU;AACN,QAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,WAAK,SAAL,CAAe,yBAAf;;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;;AAEA,UAAI,KAAK,OAAT,EAAkB;AACd,YAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,UAAA,IAAI,CAAC,QAAL,CAAc,KAAK,OAAL,CAAa,oBAAb,EAAd;AACA,UAAA,IAAI,CAAC,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACH,SAHD,MAGO;AACH,UAAA,IAAI,CAAC,QAAL,CAAc,KAAK,OAAL,CAAa,oBAAb,EAAd;AACH;AACJ,OAPD,MAOO;AACH,QAAA,MAAM,CAAC,aAAP,CAAqB,IAArB;AACH;;AAED,MAAA,IAAI,CAAC,wBAAL,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC;AACA,MAAA,IAAI,CAAC,MAAL;AACA,MAAA,OAAO,CAAC,yBAAR,CAAkC,GAAlC,EAAuC,IAAvC,EAA6C,IAA7C;AAEA,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,IAAI,CAAC,CAAvB;AACA,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,IAAI,CAAC,CAAvB;AACA,MAAA,EAAE,CAAC,UAAH,CAAc,EAAd,EAAkB,IAAI,CAAC,CAAvB;AACH;;AAED,SAAK,wBAAL;AACH,GAxCM;AA0CP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,QAAnB,EAAsC,KAAtC,EAA2D,IAA3D,EAA8E;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACrD,QAAI,EAAE,GAAG,KAAK,cAAL,EAAT;;AAEA,QAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACtB,MAAA,EAAE,CAAC,wBAAH,CAA4B,QAAQ,CAAC,CAArC,EAAwC,QAAQ,CAAC,CAAjD,EAAoD,QAAQ,CAAC,CAA7D;AACH,KAFD,MAEO;AACH,UAAI,EAAE,GAAqB,IAA3B,CADG,CAGH;;AACA,UAAI,IAAJ,EAAU;AACN,QAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,WAAK,SAAL,CAAe,yBAAf;;AAEA,UAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;AACA,UAAI,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAV;;AAEA,UAAI,KAAK,OAAT,EAAkB;AACd,YAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,UAAA,IAAI,CAAC,QAAL,CAAc,KAAK,OAAL,CAAa,oBAAb,EAAd;AACA,UAAA,IAAI,CAAC,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACH,SAHD,MAGO;AACH,UAAA,IAAI,CAAC,QAAL,CAAc,KAAK,OAAL,CAAa,oBAAb,EAAd;AACH;;AACD,QAAA,IAAI,CAAC,MAAL;AACH,OARD,MAQO;AACH,QAAA,MAAM,CAAC,aAAP,CAAqB,IAArB;AACH;;AAED,MAAA,OAAO,CAAC,yBAAR,CAAkC,QAAlC,EAA4C,IAA5C,EAAkD,GAAlD;AACA,MAAA,EAAE,CAAC,wBAAH,CAA4B,GAAG,CAAC,CAAhC,EAAmC,GAAG,CAAC,CAAvC,EAA0C,GAAG,CAAC,CAA9C;AACH;;AAED,SAAK,wBAAL;AACH,GAnCM;AAqCP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,QAA3B,EAA8C,IAA9C,EAAiE;AAC7D,SAAK,WAAL,CAAiB,QAAjB,EAA2B,KAAK,CAAC,KAAjC,EAAwC,IAAxC;AACH,GAFM;AAIP;;;;;;;;;AAOO,EAAA,IAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,CAAb,EAAwB,CAAxB,EAAmC,CAAnC,EAA8C,aAA9C,EAAmE;AAArB,QAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,aAAA,GAAA,KAAA;AAAqB;;AAC/D,QAAI,MAAM,GAAG,KAAK,cAAL,EAAb,CAD+D,CAG/D;;AACA,QAAI,QAAQ,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAf;AACA,IAAA,MAAM,CAAC,YAAP,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA6B,QAA7B;AACA,IAAA,QAAQ,CAAC,aAAT,CAAuB,MAAvB,EAA+B,MAA/B,EAN+D,CAQ/D;;AACA,IAAA,QAAQ,CAAC,MAAT;;AAEA,SAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAAvB,EAAkB,EAAA,GAAA,EAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAAiC;AAA5B,UAAI,KAAK,GAAA,EAAA,CAAA,EAAA,CAAT;AACD,UAAI,EAAE,GAAG,KAAK,CAAC,cAAN,EAAT;AACA,MAAA,EAAE,CAAC,aAAH,CAAiB,QAAjB,EAA2B,EAA3B;AACA,MAAA,EAAE,CAAC,eAAH,CAAmB,EAAnB,EAAuB,CAAvB;AACA,MAAA,EAAE,CAAC,eAAH,CAAmB,EAAnB,EAAuB,CAAvB;AACA,MAAA,EAAE,CAAC,eAAH,CAAmB,EAAnB,EAAuB,CAAvB;;AAEA,MAAA,KAAK,CAAC,wBAAN;AACH;;AAED,SAAK,wBAAL;;AAEA,QAAI,aAAJ,EAAmB;AACf,WAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAAvB,EAAkB,EAAA,GAAA,EAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAAiC;AAA5B,YAAI,KAAK,GAAA,EAAA,CAAA,EAAA,CAAT;AACD,QAAA,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,aAArB;AACH;AACJ;AACJ,GA5BM;AA8BP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA8B;AAC1B,SAAK,UAAL;;AACA,SAAK,aAAL,CAAmB,QAAnB,CAA4B,KAA5B;;AACA,SAAK,sBAAL;AACH,GAJM;AAMP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,SAAK,UAAL;;AACA,WAAO,KAAK,aAAZ;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,MAArB,EAAoC;AAChC,SAAK,UAAL;;AACA,IAAA,MAAM,CAAC,QAAP,CAAgB,KAAK,aAArB;AACH,GAHM;AAKP;;;;;;;;;;AAQO,EAAA,IAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UAAuB,GAAvB,EAAoC,KAApC,EAAmD,IAAnD,EAAiE,KAAjE,EAAsF,IAAtF,EAAyG;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAChF,QAAI,KAAK,KAAK,KAAK,CAAC,KAApB,EAA2B;AACvB,UAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AACA,MAAA,UAAU,CAAC,yBAAX,CAAqC,GAArC,EAA0C,KAA1C,EAAiD,IAAjD,EAAuD,IAAvD;AACA,WAAK,qBAAL,CAA2B,IAA3B,EAAiC,KAAjC,EAAwC,IAAxC;AACA;AACH;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAhB;;AACA,QAAI,CAAC,KAAK,yBAAL,CAA+B,SAA/B,EAA0C,IAA1C,CAAL,EAAsD;AAClD;AACH;;AAED,QAAI,MAAM,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAb;AACA,IAAA,MAAM,CAAC,yBAAP,CAAiC,GAAjC,EAAsC,KAAtC,EAA6C,IAA7C,EAAmD,MAAnD;AAEA,IAAA,SAAS,CAAC,aAAV,CAAwB,MAAxB,EAAgC,MAAhC;;AACA,SAAK,iBAAL,CAAuB,MAAvB,EAA+B,KAA/B,EAAsC,IAAtC;AAEH,GAnBM;AAqBP;;;;;;;;;AAOO,EAAA,IAAA,CAAA,SAAA,CAAA,MAAA,GAAP,UAAc,IAAd,EAA6B,MAA7B,EAA6C,KAA7C,EAAkE,IAAlE,EAAqF;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAC5D,QAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;AACA,IAAA,IAAI,CAAC,wBAAL,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC;AACA,IAAA,MAAM,CAAC,iBAAP,CAAyB,IAAzB,EAA+B,MAA/B,EAAuC,IAAvC;;AACA,SAAK,iBAAL,CAAuB,IAAvB,EAA6B,KAA7B,EAAoC,IAApC;AACH,GALM;AAOP;;;;;;;;;AAOO,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,IAApB,EAAmC,KAAnC,EAAkD,KAAlD,EAAuE,IAAvE,EAA0F;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACjE,QAAI,KAAK,KAAK,KAAK,CAAC,KAApB,EAA2B;AACvB,UAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AACA,MAAA,UAAU,CAAC,iBAAX,CAA6B,IAA7B,EAAmC,KAAnC,EAA0C,IAA1C;AAEA,WAAK,qBAAL,CAA2B,IAA3B,EAAiC,KAAjC,EAAwC,IAAxC;AACA;AACH;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAhB;;AACA,QAAI,CAAC,KAAK,yBAAL,CAA+B,SAA/B,EAA0C,IAA1C,CAAL,EAAsD;AAClD;AACH;;AAED,QAAI,MAAM,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAb;AACA,IAAA,MAAM,CAAC,iBAAP,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,MAAtC;AAEA,IAAA,SAAS,CAAC,aAAV,CAAwB,MAAxB,EAAgC,MAAhC;;AACA,SAAK,iBAAL,CAAuB,MAAvB,EAA+B,KAA/B,EAAsC,IAAtC;AACH,GAnBM;AAqBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,QAAnB,EAAsC,KAAtC,EAA2D,IAA3D,EAA8E;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACrD,SAAK,eAAL,CAAqB,QAAQ,CAAC,CAA9B,EAAiC,QAAQ,CAAC,CAA1C,EAA6C,QAAQ,CAAC,CAAtD,EAAyD,KAAzD,EAAgE,IAAhE;AACH,GAFM;AAIP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UAA6B,IAA7B,EAA+C,KAA/C,EAAoE,IAApE,EAAuF;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAC9D,QAAI,KAAK,KAAK,KAAK,CAAC,KAApB,EAA2B;AACvB,WAAK,UAAL;;AACA,WAAK,cAAL,CAAoB,QAApB,CAA6B,IAA7B;;AAEA,WAAK,sBAAL;;AAEA;AACH;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAhB;;AACA,QAAI,CAAC,KAAK,yBAAL,CAA+B,SAA/B,EAA0C,IAA1C,CAAL,EAAsD;AAClD;AACH;;AAED,QAAI,MAAM,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAb;AACA,IAAA,MAAM,CAAC,mBAAP,CAA2B,IAA3B,EAAiC,MAAjC;AAEA,IAAA,SAAS,CAAC,aAAV,CAAwB,MAAxB,EAAgC,MAAhC;;AAEA,SAAK,iBAAL,CAAuB,MAAvB,EAA+B,KAA/B,EAAsC,IAAtC;AAEH,GAtBM;AAwBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,MAAzB,EAAyC,KAAzC,EAA8D,IAA9D,EAAiF;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACxD,QAAI,KAAK,KAAK,KAAK,CAAC,KAApB,EAA2B;AACvB,UAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AACA,MAAA,UAAU,CAAC,uBAAX,CAAmC,MAAnC,EAA2C,IAA3C;AACA,WAAK,qBAAL,CAA2B,IAA3B,EAAiC,KAAjC,EAAwC,IAAxC;AACA;AACH;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAhB;;AACA,QAAI,CAAC,KAAK,yBAAL,CAA+B,SAA/B,EAA0C,IAA1C,CAAL,EAAsD;AAClD;AACH;;AAED,QAAI,OAAO,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAd;AACA,IAAA,OAAO,CAAC,QAAR,CAAiB,MAAjB;AAEA,IAAA,SAAS,CAAC,aAAV,CAAwB,MAAxB,EAAgC,OAAhC;;AAEA,SAAK,iBAAL,CAAuB,OAAvB,EAAgC,KAAhC,EAAuC,IAAvC;AAEH,GApBM;;AAsBC,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,IAA1B,EAAwC,KAAxC,EAA6D,IAA7D,EAAgF;AAAxC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACvD,QAAI,IAAI,GAAG,KAAK,cAAL,EAAX;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,CAAL,CAAO,EAAP,CAAT;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,CAAL,CAAO,EAAP,CAAT;AACA,QAAI,EAAE,GAAG,IAAI,CAAC,CAAL,CAAO,EAAP,CAAT;AACA,QAAI,MAAM,GAAG,KAAK,SAAL,EAAb;AACA,QAAI,WAAW,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAlB;AACA,QAAI,cAAc,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAArB;;AAEA,QAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,KAA7B,EAAoC;AAChC,UAAI,IAAJ,EAAU;AACN,QAAA,WAAW,CAAC,QAAZ,CAAqB,IAAI,CAAC,cAAL,EAArB;AACA,QAAA,MAAM,CAAC,oBAAP,GAA8B,aAA9B,CAA4C,WAA5C,EAAyD,WAAzD;AACH,OAHD,MAGO;AACH,QAAA,WAAW,CAAC,QAAZ,CAAqB,MAAM,CAAC,oBAAP,EAArB;AACH;;AACD,MAAA,cAAc,CAAC,QAAf,CAAwB,WAAxB;AACA,MAAA,cAAc,CAAC,MAAf;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,WAAnB,EAAgC,IAAhC;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,IAAzB;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,cAAnB,EAAmC,IAAnC;AACH,KAZD,MAYO;AACH,UAAI,KAAK,IAAI,KAAK,CAAC,KAAf,IAAwB,IAA5B,EAAkC;AAC9B,QAAA,WAAW,CAAC,QAAZ,CAAqB,IAAI,CAAC,cAAL,EAArB;AACA,QAAA,cAAc,CAAC,QAAf,CAAwB,WAAxB;AACA,QAAA,cAAc,CAAC,MAAf;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,WAAnB,EAAgC,IAAhC;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,IAAzB;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,cAAnB,EAAmC,IAAnC;AACH,OAPD,MAOO;AACH,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAnB,EAAyB,IAAzB;AACH;AACJ;;AAED,IAAA,IAAI,CAAC,wBAAL,CAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC;AAEA,SAAK,yBAAL;;AACA,SAAK,wBAAL;AACH,GAtCO;;AAwCA,EAAA,IAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,SAAlC,EAAqD,IAArD,EAAwE;AACpE,QAAI,WAAW,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAlB;AACA,IAAA,SAAS,CAAC,QAAV,CAAmB,KAAK,oBAAL,EAAnB;;AAEA,QAAI,IAAJ,EAAU;AACN,MAAA,SAAS,CAAC,aAAV,CAAwB,IAAI,CAAC,cAAL,EAAxB,EAA+C,SAA/C;AACA,MAAA,MAAM,CAAC,YAAP,CAAoB,IAAI,CAAC,OAAL,CAAa,CAAjC,EAAoC,IAAI,CAAC,OAAL,CAAa,CAAjD,EAAoD,IAAI,CAAC,OAAL,CAAa,CAAjE,EAAoE,WAApE;AACH;;AAED,IAAA,SAAS,CAAC,MAAV;;AACA,QAAI,KAAK,CAAC,SAAS,CAAC,CAAV,CAAY,CAAZ,CAAD,CAAT,EAA2B;AACvB;AACA;AACA,aAAO,KAAP;AACH;;AAED,IAAA,WAAW,CAAC,eAAZ,CAA4B,CAA5B,EAA+B,KAAK,mBAApC;AACA,IAAA,SAAS,CAAC,aAAV,CAAwB,WAAxB,EAAqC,SAArC;AAEA,WAAO,IAAP;AACH,GApBO;AAsBR;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAwC,IAAxC,EAA2E;AAAxD,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACvE,QAAI,GAAG,GAAG,OAAO,CAAC,IAAR,EAAV;AAEA,SAAK,gBAAL,CAAsB,KAAtB,EAA6B,IAA7B,EAAmC,GAAnC;AAEA,WAAO,GAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAA6C,IAA7C,EAA2E,MAA3E,EAA0F;AAAlE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACvC,QAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACtB,UAAI,EAAE,GAAG,KAAK,cAAL,EAAT;AAEA,MAAA,MAAM,CAAC,CAAP,GAAW,EAAE,CAAC,CAAH,CAAK,EAAL,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,EAAE,CAAC,CAAH,CAAK,EAAL,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,EAAE,CAAC,CAAH,CAAK,EAAL,CAAX;AACH,KAND,MAMO;AACH,UAAI,EAAE,GAAqB,IAA3B,CADG,CAGH;;AACA,UAAI,IAAJ,EAAU;AACN,QAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,WAAK,SAAL,CAAe,yBAAf;;AAEA,UAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;;AAEA,UAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,QAAA,IAAI,CAAC,QAAL,CAAc,KAAK,oBAAL,EAAd;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACH,OAHD,MAGO;AACH,QAAA,IAAI,GAAG,KAAK,oBAAL,EAAP;AACH;;AAED,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,CAAL,CAAO,EAAP,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,CAAL,CAAO,EAAP,CAAX;AACA,MAAA,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,CAAL,CAAO,EAAP,CAAX;AACH;AACJ,GA9BM;AAgCP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,IAA3B,EAA8D;AAAnC,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AAC1D,QAAI,GAAG,GAAG,OAAO,CAAC,IAAR,EAAV;AAEA,SAAK,gBAAL,CAAsB,KAAK,CAAC,KAA5B,EAAmC,IAAnC,EAAyC,GAAzC;AAEA,WAAO,GAAP;AACH,GANM;AAQP;;;;;;;AAKO,EAAA,IAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,IAAhC,EAAoD,MAApD,EAAmE;AAC/D,SAAK,gBAAL,CAAsB,KAAK,CAAC,KAA5B,EAAmC,IAAnC,EAAyC,MAAzC;AACH,GAFM;AAIP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,YAAA;AACI,SAAK,QAAL;;AAEA,QAAI,KAAK,OAAT,EAAkB;AACd,WAAK,YAAL,CAAkB,aAAlB,CAAgC,KAAK,OAAL,CAAa,kBAA7C,EAAiE,KAAK,kBAAtE;AACH,KAFD,MAEO;AACH,WAAK,kBAAL,CAAwB,QAAxB,CAAiC,KAAK,YAAtC;;AAEA,UAAI,UAAU,GAAG,KAAK,SAAL,CAAe,aAAf,EAAjB;;AAEA,UAAI,UAAJ,EAAgB;AACZ,aAAK,kBAAL,CAAwB,aAAxB,CAAsC,UAAtC,EAAkD,KAAK,kBAAvD;AACH;AACJ;;AAED,QAAI,QAAQ,GAAG,KAAK,QAApB;AACA,QAAI,GAAG,GAAG,QAAQ,CAAC,MAAnB;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC1B,MAAA,QAAQ,CAAC,CAAD,CAAR,CAAY,yBAAZ;AACH;AACJ,GArBM;AAuBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,SAApB,EAAwC,IAAxC,EAA2E;AAAnC,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACvE,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,SAAK,iBAAL,CAAuB,SAAvB,EAAkC,IAAlC,EAAwC,MAAxC;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,SAAzB,EAA6C,IAA7C,EAAkF,MAAlF,EAAiG;AAApD,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AAC5E,QAAI,EAAE,GAAqB,IAA3B,CAD6F,CAG7F;;AACA,QAAI,IAAJ,EAAU;AACN,MAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,SAAK,SAAL,CAAe,yBAAf;;AAEA,QAAI,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAV;AAEA,IAAA,GAAG,CAAC,QAAJ,CAAa,KAAK,oBAAL,EAAb;;AAEA,QAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,MAAA,GAAG,CAAC,aAAJ,CAAkB,EAAlB,EAAsB,GAAtB;AACH;;AAED,IAAA,OAAO,CAAC,oBAAR,CAA6B,SAA7B,EAAwC,GAAxC,EAA6C,MAA7C;AAEA,IAAA,MAAM,CAAC,SAAP;AACH,GArBM;AAuBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,KAAnB,EAAwC,IAAxC,EAA2E;AAAxD,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACvE,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,SAAK,gBAAL,CAAsB,KAAtB,EAA6B,IAA7B,EAAmC,MAAnC;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,KAAxB,EAA6C,IAA7C,EAAkF,MAAlF,EAAiG;AAAzE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AAC5E,QAAI,IAAI,GAAG,IAAI,CAAC,QAAhB;AAEA,SAAK,0BAAL,CAAgC,KAAhC,EAAuC,IAAvC,EAA6C,IAA7C;AAEA,IAAA,IAAI,CAAC,kBAAL,CAAwB,MAAxB;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UAA6B,KAA7B,EAAkD,IAAlD,EAAqF;AAAxD,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACjF,QAAI,MAAM,GAAG,UAAU,CAAC,QAAX,EAAb;AAEA,SAAK,0BAAL,CAAgC,KAAhC,EAAuC,IAAvC,EAA6C,MAA7C;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,0BAAA,GAAP,UAAkC,KAAlC,EAAuD,IAAvD,EAA4F,MAA5F,EAA8G;AAA5E,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACtF,QAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACtB,WAAK,UAAL;;AACA,MAAA,MAAM,CAAC,QAAP,CAAgB,KAAK,cAArB;AACH,KAHD,MAGO;AACH,UAAI,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAV;AACA,UAAI,IAAI,GAAG,KAAK,oBAAL,EAAX;;AAEA,UAAI,IAAJ,EAAU;AACN,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,cAAL,EAAnB,EAA0C,GAA1C;AACH,OAFD,MAEO;AACH,QAAA,GAAG,CAAC,QAAJ,CAAa,IAAb;AACH;;AAED,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AACA,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AACA,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AAEA,MAAA,GAAG,CAAC,SAAJ,CAAc,SAAd,EAAyB,MAAzB,EAAiC,SAAjC;AACH;AACJ,GApBM;AAsBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,KAAzB,EAA8C,IAA9C,EAAgE;AAAvC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AACxC,QAAI,MAAM,GAAG,MAAM,CAAC,QAAP,EAAb;AAEA,SAAK,sBAAL,CAA4B,KAA5B,EAAmC,IAAnC,EAAyC,MAAzC;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,UAA8B,KAA9B,EAAmD,IAAnD,EAAuE,MAAvE,EAAqF;AAAvD,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,CAAC,KAAd;AAAmB;;AAC7C,QAAI,KAAK,IAAI,KAAK,CAAC,KAAnB,EAA0B;AACtB,WAAK,cAAL,GAAsB,sBAAtB,CAA6C,MAA7C;AACH,KAFD,MAEO;AAEH,UAAI,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAV;AACA,UAAI,IAAI,GAAG,KAAK,oBAAL,EAAX;;AAEA,UAAI,IAAJ,EAAU;AACN,QAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,cAAL,EAAnB,EAA0C,GAA1C;AACH,OAFD,MAEO;AACH,QAAA,GAAG,CAAC,QAAJ,CAAa,IAAb;AACH;;AAED,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AACA,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AACA,MAAA,GAAG,CAAC,eAAJ,CAAoB,CAApB,EAAuB,KAAK,mBAA5B;AAEA,MAAA,GAAG,CAAC,sBAAJ,CAA2B,MAA3B;AACH;AACJ,GApBM;AAsBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,4BAAA,GAAP,UAAoC,QAApC,EAAuD,IAAvD,EAA0F;AAAnC,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACtF,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,SAAK,iCAAL,CAAuC,QAAvC,EAAiD,IAAjD,EAAuD,MAAvD;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,iCAAA,GAAP,UAAyC,QAAzC,EAA4D,IAA5D,EAAiG,MAAjG,EAAgH;AAApD,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AAC3F,QAAI,EAAE,GAAqB,IAA3B,CAD4G,CAG5G;;AACA,QAAI,IAAJ,EAAU;AACN,MAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,SAAK,SAAL,CAAe,yBAAf;;AAEA,QAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;;AAEA,QAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,MAAA,IAAI,CAAC,QAAL,CAAc,KAAK,oBAAL,EAAd;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACH,KAHD,MAGO;AACH,MAAA,IAAI,GAAG,KAAK,oBAAL,EAAP;AACH;;AAED,IAAA,OAAO,CAAC,yBAAR,CAAkC,QAAlC,EAA4C,IAA5C,EAAkD,MAAlD;AACH,GApBM;AAsBP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,4BAAA,GAAP,UAAoC,QAApC,EAAuD,IAAvD,EAA0F;AAAnC,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AACtF,QAAI,MAAM,GAAG,OAAO,CAAC,IAAR,EAAb;AAEA,SAAK,iCAAL,CAAuC,QAAvC,EAAiD,IAAjD,EAAuD,MAAvD;AAEA,WAAO,MAAP;AACH,GANM;AAQP;;;;;;;;AAMO,EAAA,IAAA,CAAA,SAAA,CAAA,iCAAA,GAAP,UAAyC,QAAzC,EAA4D,IAA5D,EAAiG,MAAjG,EAAgH;AAApD,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAmC;;AAC3F,QAAI,EAAE,GAAqB,IAA3B,CAD4G,CAG5G;;AACA,QAAI,IAAJ,EAAU;AACN,MAAA,EAAE,GAAG,IAAI,CAAC,cAAL,EAAL;AACH;;AAED,SAAK,SAAL,CAAe,yBAAf;;AAEA,QAAI,IAAI,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAX;AAEA,IAAA,IAAI,CAAC,QAAL,CAAc,KAAK,oBAAL,EAAd;;AAEA,QAAI,IAAI,IAAI,EAAZ,EAAgB;AACZ,MAAA,IAAI,CAAC,aAAL,CAAmB,EAAnB,EAAuB,IAAvB;AACH;;AAED,IAAA,IAAI,CAAC,MAAL;AAEA,IAAA,OAAO,CAAC,yBAAR,CAAkC,QAAlC,EAA4C,IAA5C,EAAkD,MAAlD;AACH,GArBM;AAuBP;;;;;AAGO,EAAA,IAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACI,SAAK,WAAL,CAAiB,KAAK,cAAL,EAAjB;AACH,GAFM;;AAxmCQ,EAAA,IAAA,CAAA,QAAA,GAAsB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,OAAO,CAAC,IAAjC,CAAtB;AACA,EAAA,IAAA,CAAA,QAAA,GAAW,UAAU,CAAC,QAAX,EAAX;AACA,EAAA,IAAA,CAAA,QAAA,GAAqB,UAAU,CAAC,UAAX,CAAsB,CAAtB,EAAyB,MAAM,CAAC,QAAhC,CAArB;AAymCnB,SAAA,IAAA;AAAC,CA7mCD,CAA0B,IAA1B,CAAA;;SAAa,I","sourcesContent":["import { Skeleton } from \"./skeleton\";\r\n\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Nullable } from \"../types\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from '../Maths/math.axis';\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type AnimationPropertiesOverride = import(\"../Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n */\r\nexport class Bone extends Node {\r\n\r\n    private static _tmpVecs: Vector3[] = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    private static _tmpQuat = Quaternion.Identity();\r\n    private static _tmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children = new Array<Bone>();\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @hidden Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix;\r\n    private _restPose: Matrix;\r\n    private _bindPose: Matrix;\r\n    private _baseMatrix: Matrix;\r\n    private _absoluteTransform = new Matrix();\r\n    private _invertedAbsoluteTransform = new Matrix();\r\n    private _parent: Nullable<Bone>;\r\n    private _scalingDeterminant = 1;\r\n    private _worldTransform = new Matrix();\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @hidden */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @hidden */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @hidden */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    set _matrix(value: Matrix) {\r\n        this._localMatrix.copyFrom(value);\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix\r\n     * @param restPose defines the rest pose matrix\r\n     * @param baseMatrix defines the base matrix\r\n     * @param index defines index of the bone in the hiearchy\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public name: string, skeleton: Skeleton, parentBone: Nullable<Bone> = null, localMatrix: Nullable<Matrix> = null,\r\n        restPose: Nullable<Matrix> = null, baseMatrix: Nullable<Matrix> = null, index: Nullable<number> = null) {\r\n        super(name, skeleton.getScene());\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\r\n        this._restPose = restPose ? restPose : this._localMatrix.clone();\r\n        this._bindPose = this._localMatrix.clone();\r\n        this._baseMatrix = baseMatrix ? baseMatrix : this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        if (baseMatrix || localMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateDifferenceMatrix: boolean = true): void {\r\n        if (this._parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this._parent) {\r\n            var index = this._parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this._parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parent = parent;\r\n\r\n        if (this._parent) {\r\n            this._parent.children.push(this);\r\n        }\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns a matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the base matrix (initial matrix which remains unchanged)\r\n     * @returns a matrix\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this._baseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this._restPose;\r\n    }\r\n\r\n    /**\r\n     * Sets the rest pose matrix\r\n     * @param matrix the local-space rest pose to set for this bone\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this._restPose.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind pose matrix\r\n     * @returns the bind pose matrix\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this._bindPose;\r\n    }\r\n\r\n    /**\r\n     * Sets the bind pose matrix\r\n     * @param matrix the local-space bind pose to set for this bone\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this._bindPose.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        return this._worldTransform;\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to rest pose matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._skeleton._numBonesWithLinkedTransformNode > 0) {\r\n            this.updateMatrix(this._restPose, false, false);\r\n        } else {\r\n            this.updateMatrix(this._restPose, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the absolute transform matrix.\r\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n     * @returns a matrix\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this._invertedAbsoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n     * @returns a matrix\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is copied from the transform node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches AbstractMesh properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the base and local matrices\r\n     * @param matrix defines the new base or local matrix\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     * @param updateLocalMatrix defines if the local matrix should be updated\r\n     */\r\n    public updateMatrix(matrix: Matrix, updateDifferenceMatrix = true, updateLocalMatrix = true): void {\r\n        this._baseMatrix.copyFrom(matrix);\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._needToCompose = false; // in case there was a pending compose\r\n            this._localMatrix.copyFrom(matrix);\r\n            this._markAsDirtyAndDecompose();\r\n        }\r\n        else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateDifferenceMatrix(rootMatrix?: Matrix, updateChildren = true): void {\r\n        if (!rootMatrix) {\r\n            rootMatrix = this._baseMatrix;\r\n        }\r\n\r\n        if (this._parent) {\r\n            rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(rootMatrix);\r\n        }\r\n\r\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\r\n\r\n        if (updateChildren) {\r\n            for (var index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateDifferenceMatrix();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = (this._absoluteTransform.determinant() < 0 ? -1 : 1);\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     */\r\n    public markAsDirty(): void {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        var lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.addAtIndex(12, vec.x);\r\n            lm.addAtIndex(13, vec.y);\r\n            lm.addAtIndex(14, vec.z);\r\n        } else {\r\n            var wm: Nullable<Matrix> = null;\r\n\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            var tmat = Bone._tmpMats[0];\r\n            var tvec = Bone._tmpVecs[0];\r\n\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            tmat.setTranslationFromFloats(0, 0, 0);\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            lm.addAtIndex(12, tvec.x);\r\n            lm.addAtIndex(13, tvec.y);\r\n            lm.addAtIndex(14, tvec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the postion of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        var lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\r\n        } else {\r\n            var wm: Nullable<Matrix> = null;\r\n\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            var tmat = Bone._tmpMats[0];\r\n            var vec = Bone._tmpVecs[0];\r\n\r\n            if (this._parent) {\r\n                if (mesh && wm) {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\r\n                }\r\n                tmat.invert();\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\r\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param mesh The mesh that this bone is attached to\r\n     */\r\n    public setAbsolutePosition(position: Vector3, mesh?: AbstractMesh) {\r\n        this.setPosition(position, Space.WORLD, mesh);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        var locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        var scaleMat = Bone._tmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (var child of this.children) {\r\n            var cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (var child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        var rmat = Bone._tmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, mesh);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n\r\n        var rotMat = Bone._tmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, mesh);\r\n\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        if (space === Space.LOCAL) {\r\n            var quat = Bone._tmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, mesh);\r\n            return;\r\n        }\r\n\r\n        var rotMatInv = Bone._tmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, mesh)) {\r\n            return;\r\n        }\r\n\r\n        var rotMat2 = Bone._tmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, mesh);\r\n\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, mesh?: AbstractMesh): void {\r\n        var lmat = this.getLocalMatrix();\r\n        var lx = lmat.m[12];\r\n        var ly = lmat.m[13];\r\n        var lz = lmat.m[14];\r\n        var parent = this.getParent();\r\n        var parentScale = Bone._tmpMats[3];\r\n        var parentScaleInv = Bone._tmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteTransform());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && mesh) {\r\n                parentScale.copyFrom(mesh.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteTransforms();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getNegativeRotationToRef(rotMatInv: Matrix, mesh?: AbstractMesh): boolean {\r\n        var scaleMatrix = Bone._tmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (mesh) {\r\n            rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, mesh, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param mesh The mesh that this bone is attached to. This is only used in world space\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, mesh: Nullable<AbstractMesh>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            var lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            var wm: Nullable<Matrix> = null;\r\n\r\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (mesh) {\r\n                wm = mesh.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            var tmat = Bone._tmpMats[0];\r\n\r\n            if (mesh && wm) {\r\n                tmat.copyFrom(this.getAbsoluteTransform());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteTransform();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, mesh, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(mesh: AbstractMesh, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, mesh, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute transforms of this bone and its children\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this._compose();\r\n\r\n        if (this._parent) {\r\n            this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(this._localMatrix);\r\n\r\n            var poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\r\n            }\r\n        }\r\n\r\n        var children = this.children;\r\n        var len = children.length;\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteTransforms();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, mesh: Nullable<AbstractMesh> = null, result: Vector3): void {\r\n        var wm: Nullable<Matrix> = null;\r\n\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        var mat = Bone._tmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (mesh && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, mesh: Nullable<AbstractMesh> = null, result: Vector3): void {\r\n        var quat = Bone._tmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, mesh, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, mesh: Nullable<AbstractMesh> = null): Quaternion {\r\n        var result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, mesh: Nullable<AbstractMesh> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, mesh: AbstractMesh): Matrix {\r\n        var result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param mesh The mesh that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, mesh: AbstractMesh, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n\r\n            var mat = Bone._tmpMats[0];\r\n            var amat = this.getAbsoluteTransform();\r\n\r\n            if (mesh) {\r\n                amat.multiplyToRef(mesh.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, mesh: Nullable<AbstractMesh> = null, result: Vector3): void {\r\n        var wm: Nullable<Matrix> = null;\r\n\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        var tmat = Bone._tmpMats[0];\r\n\r\n        if (mesh && wm) {\r\n            tmat.copyFrom(this.getAbsoluteTransform());\r\n            tmat.multiplyToRef(wm, tmat);\r\n        } else {\r\n            tmat = this.getAbsoluteTransform();\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, mesh: Nullable<AbstractMesh> = null): Vector3 {\r\n        var result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param mesh The mesh that this bone is attached to\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, mesh: Nullable<AbstractMesh> = null, result: Vector3): void {\r\n        var wm: Nullable<Matrix> = null;\r\n\r\n        //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (mesh) {\r\n            wm = mesh.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        var tmat = Bone._tmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (mesh && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestPose(this.getLocalMatrix());\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}