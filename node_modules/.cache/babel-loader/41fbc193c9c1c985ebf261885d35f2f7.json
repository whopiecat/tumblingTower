{"ast":null,"code":"import { Vector2, Vector4 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { EngineStore } from '../../Engines/engineStore';\n\nVertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {\n  var faceUV = fUV || new Array(3);\n  var faceColors = fColors;\n  var colors = [];\n  var wrap = wrp || false; // default face colors and UV if undefined\n\n  for (var f = 0; f < 3; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var positions = polygon.getVerticesData(VertexBuffer.PositionKind);\n  var normals = polygon.getVerticesData(VertexBuffer.NormalKind);\n  var uvs = polygon.getVerticesData(VertexBuffer.UVKind);\n  var indices = polygon.getIndices();\n  var startIndex = positions.length / 9;\n  var disp = 0;\n  var distX = 0;\n  var distZ = 0;\n  var dist = 0;\n  var totalLen = 0;\n  var cumulate = [0];\n\n  if (wrap) {\n    for (var idx = startIndex; idx < positions.length / 3; idx += 4) {\n      distX = positions[3 * (idx + 2)] - positions[3 * idx];\n      distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\n      dist = Math.sqrt(distX * distX + distZ * distZ);\n      totalLen += dist;\n      cumulate.push(totalLen);\n    }\n  } // set face colours and textures\n\n\n  var idx = 0;\n  var face = 0;\n\n  for (var index = 0; index < normals.length; index += 3) {\n    //Edge Face  no. 1\n    if (Math.abs(normals[index + 1]) < 0.001) {\n      face = 1;\n    } //Top Face  no. 0\n\n\n    if (Math.abs(normals[index + 1] - 1) < 0.001) {\n      face = 0;\n    } //Bottom Face  no. 2\n\n\n    if (Math.abs(normals[index + 1] + 1) < 0.001) {\n      face = 2;\n    }\n\n    idx = index / 3;\n\n    if (face === 1) {\n      disp = idx - startIndex;\n\n      if (disp % 4 < 1.5) {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].x;\n        }\n      } else {\n        if (wrap) {\n          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;\n        } else {\n          uvs[2 * idx] = faceUV[face].z;\n        }\n      }\n\n      if (disp % 2 === 0) {\n        uvs[2 * idx + 1] = faceUV[face].w;\n      } else {\n        uvs[2 * idx + 1] = faceUV[face].y;\n      }\n    } else {\n      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n    }\n\n    if (faceColors) {\n      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n    }\n  } // sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n};\n\nMesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\n};\n\nMesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\n  if (earcutInjection === void 0) {\n    earcutInjection = earcut;\n  }\n\n  var options = {\n    shape: shape,\n    holes: holes,\n    depth: depth,\n    updatable: updatable,\n    sideOrientation: sideOrientation\n  };\n  return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar PolygonBuilder =\n/** @class */\nfunction () {\n  function PolygonBuilder() {}\n  /**\r\n   * Creates a polygon mesh\r\n   * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n   * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n   * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n   * * Remember you can only change the shape positions, not their number when updating a polygon\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   * @returns the polygon mesh\r\n   */\n\n\n  PolygonBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var shape = options.shape;\n    var holes = options.holes || [];\n    var depth = options.depth || 0;\n    var contours = [];\n    var hole = [];\n\n    for (var i = 0; i < shape.length; i++) {\n      contours[i] = new Vector2(shape[i].x, shape[i].z);\n    }\n\n    var epsilon = 0.00000001;\n\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n      contours.pop();\n    }\n\n    var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);\n\n    for (var hNb = 0; hNb < holes.length; hNb++) {\n      hole = [];\n\n      for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n        hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n      }\n\n      polygonTriangulation.addHole(hole);\n    }\n\n    var polygon = polygonTriangulation.build(options.updatable, depth);\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\n    vertexData.applyToMesh(polygon, options.updatable);\n    return polygon;\n  };\n  /**\r\n   * Creates an extruded polygon mesh, with depth in the Y direction.\r\n   * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n   * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   * @returns the polygon mesh\r\n   */\n\n\n  PolygonBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\n  };\n\n  return PolygonBuilder;\n}();\n\nexport { PolygonBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/polygonBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { EngineStore } from '../../Engines/engineStore';\r\n\r\ndeclare var earcut: any;\r\n\r\nVertexData.CreatePolygon = function(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    var faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    var faceColors = fColors;\r\n    var colors = [];\r\n    var wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    var positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    var normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    var uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    var indices = <IndicesArray>polygon.getIndices();\r\n    var startIndex = positions.length / 9;\r\n    var disp = 0;\r\n    var distX = 0;\r\n    var distZ = 0;\r\n    var dist = 0;\r\n    var totalLen = 0;\r\n    var cumulate = [0];\r\n    if (wrap) {\r\n        for (var idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    var idx: number = 0;\r\n    var face: number = 0;\r\n    for (var index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;\r\n                }\r\n                else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            }\r\n            else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;\r\n                }\r\n                else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = faceUV[face].w;\r\n            }\r\n            else {\r\n                uvs[2 * idx + 1] = faceUV[face].y;\r\n            }\r\n        }\r\n        else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreatePolygon = (name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\nMesh.ExtrudePolygon = (name: string, shape: Vector3[], depth: number, scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class PolygonBuilder {\r\n    /**\r\n     * Creates a polygon mesh\r\n     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n     * * Remember you can only change the shape positions, not their number when updating a polygon\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    public static CreatePolygon(name: string, options: { shape: Vector3[], holes?: Vector3[][], depth?: number, faceUV?: Vector4[], faceColors?: Color4[], updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean}, scene: Nullable<Scene> = null, earcutInjection = earcut): Mesh {\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var shape = options.shape;\r\n        var holes = options.holes || [];\r\n        var depth = options.depth || 0;\r\n        var contours: Array<Vector2> = [];\r\n        var hole: Array<Vector2> = [];\r\n\r\n        for (var i = 0; i < shape.length; i++) {\r\n            contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n        }\r\n        var epsilon = 0.00000001;\r\n        if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n            contours.pop();\r\n        }\r\n\r\n        var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n        for (var hNb = 0; hNb < holes.length; hNb++) {\r\n            hole = [];\r\n            for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n                hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n            }\r\n            polygonTriangulation.addHole(hole);\r\n        }\r\n        var polygon = polygonTriangulation.build(options.updatable, depth);\r\n        polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n        vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n        return polygon;\r\n    }\r\n\r\n    /**\r\n     * Creates an extruded polygon mesh, with depth in the Y direction.\r\n     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    public static ExtrudePolygon(name: string, options: { shape: Vector3[], holes?: Vector3[][], depth?: number, faceUV?: Vector4[], faceColors?: Color4[], updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean }, scene: Nullable<Scene> = null, earcutInjection = earcut): Mesh {\r\n        return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}