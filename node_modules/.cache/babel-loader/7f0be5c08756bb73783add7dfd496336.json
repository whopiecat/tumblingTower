{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { Logger } from \"../Misc/logger\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { BoxBuilder } from \"../Meshes/Builders/boxBuilder\";\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { PivotTools } from \"../Misc/pivotTools\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/boxBuilder\";\nimport { Epsilon } from '../Maths/math.constants';\n/**\r\n * Bounding box gizmo\r\n */\n\nvar BoundingBoxGizmo =\n/** @class */\nfunction (_super) {\n  __extends(BoundingBoxGizmo, _super);\n  /**\r\n   * Creates an BoundingBoxGizmo\r\n   * @param gizmoLayer The utility layer the gizmo will be added to\r\n   * @param color The color of the gizmo\r\n   */\n\n\n  function BoundingBoxGizmo(color, gizmoLayer) {\n    if (color === void 0) {\n      color = Color3.Gray();\n    }\n\n    if (gizmoLayer === void 0) {\n      gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    var _this = _super.call(this, gizmoLayer) || this;\n\n    _this._boundingDimensions = new Vector3(1, 1, 1);\n    _this._renderObserver = null;\n    _this._pointerObserver = null;\n    _this._scaleDragSpeed = 0.2;\n    _this._tmpQuaternion = new Quaternion();\n    _this._tmpVector = new Vector3(0, 0, 0);\n    _this._tmpRotationMatrix = new Matrix();\n    /**\r\n     * If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\n\n    _this.ignoreChildren = false;\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\n\n    _this.includeChildPredicate = null;\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\n\n    _this.rotationSphereSize = 0.1;\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\n\n    _this.scaleBoxSize = 0.1;\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\n\n    _this.fixedDragMeshScreenSize = false;\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\n\n    _this.fixedDragMeshBoundsSize = false;\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\n\n    _this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\n\n    _this.onDragStartObservable = new Observable();\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\n\n    _this.onScaleBoxDragObservable = new Observable();\n    /**\r\n      * Fired when a scale box drag is ended\r\n     */\n\n    _this.onScaleBoxDragEndObservable = new Observable();\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\n\n    _this.onRotationSphereDragObservable = new Observable();\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\n\n    _this.onRotationSphereDragEndObservable = new Observable();\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\n\n    _this.scalePivot = null;\n    _this._existingMeshScale = new Vector3(); // Dragging\n\n    _this._dragMesh = null;\n    _this.pointerDragBehavior = new PointerDragBehavior(); // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n\n    _this.updateScale = false;\n    _this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene); // Create Materials\n\n    _this.coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this.coloredMaterial.disableLighting = true;\n    _this.hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    _this.hoverColoredMaterial.disableLighting = true; // Build bounding box out of lines\n\n    _this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    var lines = [];\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(_this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, 0, 0), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, _this._boundingDimensions.y, 0), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(0, _this._boundingDimensions.y, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, 0, _this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(LinesBuilder.CreateLines(\"lines\", {\n      points: [new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, _this._boundingDimensions.z), new Vector3(_this._boundingDimensions.x, _this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(function (l) {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-_this._boundingDimensions.x / 2, -_this._boundingDimensions.y / 2, -_this._boundingDimensions.z / 2));\n      l.isPickable = false;\n\n      _this._lineBoundingBox.addChild(l);\n    });\n\n    _this._rootMesh.addChild(_this._lineBoundingBox);\n\n    _this.setColor(color); // Create rotation spheres\n\n\n    _this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n\n    var _loop_1 = function (i_1) {\n      var sphere = SphereBuilder.CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this_1.coloredMaterial; // Drag behavior\n\n      _dragBehavior = new PointerDragBehavior({});\n      _dragBehavior.moveAttached = false;\n      _dragBehavior.updateDragPlane = false;\n      sphere.addBehavior(_dragBehavior);\n      var startingTurnDirection = new Vector3(1, 0, 0);\n      var totalTurnAmountOfDrag = 0;\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n      });\n\n      _dragBehavior.onDragObservable.add(function (event) {\n        _this.onRotationSphereDragObservable.notifyObservers({});\n\n        if (_this.attachedMesh) {\n          var originalParent = _this.attachedMesh.parent;\n\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n\n          PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n          var worldDragDirection = startingTurnDirection; // Project the world right on to the drag plane\n\n          var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew(); // project drag delta on to the resulting drag axis and rotate based on that\n\n          var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length()); // Make rotation relative to size of mesh.\n\n          projectDist = projectDist / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length(); // Rotate based on axis\n\n          if (!_this.attachedMesh.rotationQuaternion) {\n            _this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this.attachedMesh.rotation.y, _this.attachedMesh.rotation.x, _this.attachedMesh.rotation.z);\n          }\n\n          if (!_this._anchorMesh.rotationQuaternion) {\n            _this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(_this._anchorMesh.rotation.y, _this._anchorMesh.rotation.x, _this._anchorMesh.rotation.z);\n          } // Do not allow the object to turn more than a full circle\n\n\n          totalTurnAmountOfDrag += projectDist;\n\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (i_1 >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, _this._tmpQuaternion);\n            } else if (i_1 >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, _this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, _this._tmpQuaternion);\n            } // Rotate around center of bounding box\n\n\n            _this._anchorMesh.addChild(_this.attachedMesh);\n\n            _this._anchorMesh.rotationQuaternion.multiplyToRef(_this._tmpQuaternion, _this._anchorMesh.rotationQuaternion);\n\n            _this._anchorMesh.removeChild(_this.attachedMesh);\n\n            _this.attachedMesh.setParent(originalParent);\n          }\n\n          _this.updateBoundingBox();\n\n          PivotTools._RestorePivotPoint(_this.attachedMesh);\n        }\n\n        _this._updateDummy();\n      }); // Selection/deselection\n\n\n      _dragBehavior.onDragStartObservable.add(function () {\n        _this.onDragStartObservable.notifyObservers({});\n\n        _this._selectNode(sphere);\n      });\n\n      _dragBehavior.onDragEndObservable.add(function () {\n        _this.onRotationSphereDragEndObservable.notifyObservers({});\n\n        _this._selectNode(null);\n\n        _this._updateDummy();\n      });\n\n      this_1._rotateSpheresParent.addChild(sphere);\n    };\n\n    var this_1 = this,\n        _dragBehavior;\n\n    for (var i_1 = 0; i_1 < 12; i_1++) {\n      _loop_1(i_1);\n    }\n\n    _this._rootMesh.addChild(_this._rotateSpheresParent); // Create scale cubes\n\n\n    _this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    _this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        var _loop_2 = function () {\n          // create box for relevant axis\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            return \"continue\";\n          }\n\n          var box = BoxBuilder.CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this_2.coloredMaterial;\n          box.metadata = zeroAxisCount === 2; // None homogenous scale handle\n          // Dragging logic\n\n          var dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n          _dragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n          _dragBehavior.updateDragPlane = false;\n          _dragBehavior.moveAttached = false;\n          box.addBehavior(_dragBehavior);\n\n          _dragBehavior.onDragObservable.add(function (event) {\n            _this.onScaleBoxDragObservable.notifyObservers({});\n\n            if (_this.attachedMesh) {\n              var originalParent = _this.attachedMesh.parent;\n\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n\n              PivotTools._RemoveAndStorePivotPoint(_this.attachedMesh);\n\n              var relativeDragDistance = event.dragDistance / _this._boundingDimensions.length() * _this._anchorMesh.scaling.length();\n\n              var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n\n              deltaScale.scaleInPlace(_this._scaleDragSpeed);\n\n              _this.updateBoundingBox();\n\n              if (_this.scalePivot) {\n                _this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(_this._tmpRotationMatrix); // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n\n\n                _this._boundingDimensions.scaleToRef(0.5, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n\n                _this._boundingDimensions.multiplyToRef(_this.scalePivot, _this._tmpVector);\n\n                Vector3.TransformCoordinatesToRef(_this._tmpVector, _this._tmpRotationMatrix, _this._tmpVector);\n\n                _this._anchorMesh.position.addInPlace(_this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(_this._anchorMesh.position, _this._tmpVector);\n\n                _this._anchorMesh.position.subtractInPlace(_this._tmpVector);\n              }\n\n              _this._anchorMesh.addChild(_this.attachedMesh);\n\n              _this._anchorMesh.scaling.addInPlace(deltaScale);\n\n              if (_this._anchorMesh.scaling.x < 0 || _this._anchorMesh.scaling.y < 0 || _this._anchorMesh.scaling.z < 0) {\n                _this._anchorMesh.scaling.subtractInPlace(deltaScale);\n              }\n\n              _this._anchorMesh.removeChild(_this.attachedMesh);\n\n              _this.attachedMesh.setParent(originalParent);\n\n              PivotTools._RestorePivotPoint(_this.attachedMesh);\n            }\n\n            _this._updateDummy();\n          }); // Selection/deselection\n\n\n          _dragBehavior.onDragStartObservable.add(function () {\n            _this.onDragStartObservable.notifyObservers({});\n\n            _this._selectNode(box);\n          });\n\n          _dragBehavior.onDragEndObservable.add(function () {\n            _this.onScaleBoxDragEndObservable.notifyObservers({});\n\n            _this._selectNode(null);\n\n            _this._updateDummy();\n          });\n\n          this_2._scaleBoxesParent.addChild(box);\n        };\n\n        var this_2 = this,\n            _dragBehavior;\n\n        for (var k = 0; k < 3; k++) {\n          _loop_2();\n        }\n      }\n    }\n\n    _this._rootMesh.addChild(_this._scaleBoxesParent); // Hover color change\n\n\n    var pointerIds = new Array();\n    _this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(function (pointerInfo) {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        _this._rotateSpheresParent.getChildMeshes().concat(_this._scaleBoxesParent.getChildMeshes()).forEach(function (mesh) {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = _this.hoverColoredMaterial;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = _this.coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n        }\n      }\n    }); // Update bounding box positions\n\n    _this._renderObserver = _this.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {\n      // Only update the bouding box if scaling has changed\n      if (_this.attachedMesh && !_this._existingMeshScale.equals(_this.attachedMesh.scaling)) {\n        _this.updateBoundingBox();\n      } else if (_this.fixedDragMeshScreenSize || _this.fixedDragMeshBoundsSize) {\n        _this._updateRotationSpheres();\n\n        _this._updateScaleBoxes();\n      } // If dragg mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n\n\n      if (_this._dragMesh && _this.attachedMesh && _this.pointerDragBehavior.dragging) {\n        _this._lineBoundingBox.position.rotateByQuaternionToRef(_this._rootMesh.rotationQuaternion, _this._tmpVector);\n\n        _this.attachedMesh.setAbsolutePosition(_this._dragMesh.position.add(_this._tmpVector.scale(-1)));\n      }\n    });\n\n    _this.updateBoundingBox();\n\n    return _this;\n  }\n  /**\r\n   * Sets the color of the bounding box gizmo\r\n   * @param color the color to set\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setColor = function (color) {\n    this.coloredMaterial.emissiveColor = color;\n    this.hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n\n    this._lineBoundingBox.getChildren().forEach(function (l) {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  };\n\n  BoundingBoxGizmo.prototype._attachedNodeChanged = function (value) {\n    var _this = this;\n\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      PivotTools._RemoveAndStorePivotPoint(value);\n\n      var originalParent = value.parent;\n\n      this._anchorMesh.addChild(value);\n\n      this._anchorMesh.removeChild(value);\n\n      value.setParent(originalParent);\n\n      PivotTools._RestorePivotPoint(value);\n\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(function (m) {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(function () {\n        _this._updateDummy();\n      });\n    }\n  };\n\n  BoundingBoxGizmo.prototype._selectNode = function (selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(function (m) {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  };\n  /**\r\n   * Updates the bounding box information for the Gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.updateBoundingBox = function () {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh); // Store original parent\n\n\n      var originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null); // Store original skelton override mesh\n\n      var originalSkeletonOverrideMesh = null;\n\n      if (this.attachedMesh.skeleton) {\n        originalSkeletonOverrideMesh = this.attachedMesh.skeleton.overrideMesh;\n        this.attachedMesh.skeleton.overrideMesh = null;\n      }\n\n      this._update(); // Rotate based on axis\n\n\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion); // Store original position and reset mesh to origin before computing the bounding box\n\n\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n      var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions); // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n\n      this._lineBoundingBox.computeWorldMatrix();\n\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition); // Restore position/rotation values\n\n\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector); // Restore original parent\n\n      this.attachedMesh.setParent(originalParent); // Restore original skeleton override mesh\n\n      if (this.attachedMesh.skeleton) {\n        this.attachedMesh.skeleton.overrideMesh = originalSkeletonOverrideMesh;\n      }\n    }\n\n    this._updateRotationSpheres();\n\n    this._updateScaleBoxes();\n\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateRotationSpheres = function () {\n    var rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 2; j++) {\n        for (var k = 0; k < 2; k++) {\n          var index = i * 4 + j * 2 + k;\n\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  };\n\n  BoundingBoxGizmo.prototype._updateScaleBoxes = function () {\n    var scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n\n    var index = 0;\n\n    for (var i = 0; i < 3; i++) {\n      for (var j = 0; j < 3; j++) {\n        for (var k = 0; k < 3; k++) {\n          var zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n              var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n\n          index++;\n        }\n      }\n    }\n  };\n  /**\r\n   * Enables rotation on the specified axis and disables rotation on the others\r\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledRotationAxis = function (axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach(function (m, i) {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  };\n  /**\r\n   * Enables/disables scaling\r\n   * @param enable if scaling should be enabled\r\n   * @param homogeneousScaling defines if scaling should only be homogeneous\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setEnabledScaling = function (enable, homogeneousScaling) {\n    if (homogeneousScaling === void 0) {\n      homogeneousScaling = false;\n    }\n\n    this._scaleBoxesParent.getChildMeshes().forEach(function (m, i) {\n      var enableMesh = enable; // Disable heterogenous scale handles if requested.\n\n      if (homogeneousScaling && m.metadata === true) {\n        enableMesh = false;\n      }\n\n      m.setEnabled(enableMesh);\n    });\n  };\n\n  BoundingBoxGizmo.prototype._updateDummy = function () {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  };\n  /**\r\n   * Enables a pointer drag behavior on the bounding box of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.enableDragBehavior = function () {\n    this._dragMesh = Mesh.CreateBox(\"dummy\", 1, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this.pointerDragBehavior.useObjectOrientationForDragging = false;\n\n    this._dragMesh.addBehavior(this.pointerDragBehavior);\n  };\n  /**\r\n   * Disposes of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.dispose = function () {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n\n    this._lineBoundingBox.dispose();\n\n    this._rotateSpheresParent.dispose();\n\n    this._scaleBoxesParent.dispose();\n\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n   * @returns the bounding box mesh with the passed in mesh as a child\r\n   */\n\n\n  BoundingBoxGizmo.MakeNotPickableAndWrapInBoundingBox = function (mesh) {\n    var makeNotPickable = function (root) {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(function (c) {\n        makeNotPickable(c);\n      });\n    };\n\n    makeNotPickable(mesh); // Reset position to get boudning box from origin with no rotation\n\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n\n    var oldPos = mesh.position.clone();\n    var oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0); // Update bounding dimensions/positions\n\n    var box = BoxBuilder.CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    var boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling); // Adjust scale to avoid undefined behavior when adding child\n\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2); // Restore original positions\n\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos); // Reverse parenting\n\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  };\n  /**\r\n   * CustomMeshes are not supported by this gizmo\r\n   * @param mesh The mesh to replace the default mesh of the gizmo\r\n   */\n\n\n  BoundingBoxGizmo.prototype.setCustomMesh = function (mesh) {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  };\n\n  return BoundingBoxGizmo;\n}(Gizmo);\n\nexport { BoundingBoxGizmo };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/boundingBoxGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Nullable } from \"../types\";\r\nimport { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { BoxBuilder } from \"../Meshes/Builders/boxBuilder\";\r\nimport { LinesBuilder } from \"../Meshes/Builders/linesBuilder\";\r\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { PivotTools } from \"../Misc/pivotTools\";\r\nimport { Color3 } from '../Maths/math.color';\r\n\r\nimport \"../Meshes/Builders/boxBuilder\";\r\nimport { LinesMesh } from '../Meshes/linesMesh';\r\nimport { Epsilon } from '../Maths/math.constants';\r\n\r\n/**\r\n * Bounding box gizmo\r\n */\r\nexport class BoundingBoxGizmo extends Gizmo {\r\n    private _lineBoundingBox: AbstractMesh;\r\n    private _rotateSpheresParent: AbstractMesh;\r\n    private _scaleBoxesParent: AbstractMesh;\r\n    private _boundingDimensions = new Vector3(1, 1, 1);\r\n    private _renderObserver: Nullable<Observer<Scene>> = null;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n    private _scaleDragSpeed = 0.2;\r\n\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpVector = new Vector3(0, 0, 0);\r\n    private _tmpRotationMatrix = new Matrix();\r\n    /**\r\n     * If child meshes should be ignored when calculating the boudning box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\r\n     */\r\n    public ignoreChildren = false;\r\n    /**\r\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\r\n     */\r\n    public includeChildPredicate: Nullable<(abstractMesh: AbstractMesh) => boolean> = null;\r\n\r\n    /**\r\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\r\n     */\r\n    public rotationSphereSize = 0.1;\r\n    /**\r\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\r\n     */\r\n    public scaleBoxSize = 0.1;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshScreenSize = false;\r\n    /**\r\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\r\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\r\n     */\r\n    public fixedDragMeshBoundsSize = false;\r\n    /**\r\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\r\n     */\r\n    public fixedDragMeshScreenSizeDistanceFactor = 10;\r\n    /**\r\n     * Fired when a rotation sphere or scale box is dragged\r\n     */\r\n    public onDragStartObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a scale box is dragged\r\n     */\r\n    public onScaleBoxDragObservable = new Observable<{}>();\r\n    /**\r\n      * Fired when a scale box drag is ended\r\n     */\r\n    public onScaleBoxDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere is dragged\r\n     */\r\n    public onRotationSphereDragObservable = new Observable<{}>();\r\n    /**\r\n     * Fired when a rotation sphere drag is ended\r\n     */\r\n    public onRotationSphereDragEndObservable = new Observable<{}>();\r\n    /**\r\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\r\n     */\r\n    public scalePivot: Nullable<Vector3> = null;\r\n\r\n    /**\r\n     * Mesh used as a pivot to rotate the attached node\r\n     */\r\n    private _anchorMesh: AbstractMesh;\r\n\r\n    private _existingMeshScale = new Vector3();\r\n\r\n    // Dragging\r\n    private _dragMesh: Nullable<Mesh> = null;\r\n    private pointerDragBehavior = new PointerDragBehavior();\r\n\r\n    private coloredMaterial: StandardMaterial;\r\n    private hoverColoredMaterial: StandardMaterial;\r\n\r\n    /**\r\n     * Sets the color of the bounding box gizmo\r\n     * @param color the color to set\r\n     */\r\n    public setColor(color: Color3) {\r\n        this.coloredMaterial.emissiveColor = color;\r\n        this.hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\r\n        this._lineBoundingBox.getChildren().forEach((l) => {\r\n            if ((l as LinesMesh).color) {\r\n                (l as LinesMesh).color = color;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Creates an BoundingBoxGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param color The color of the gizmo\r\n     */\r\n    constructor(color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\r\n        super(gizmoLayer);\r\n\r\n        // Do not update the gizmo's scale so it has a fixed size to the object its attached to\r\n        this.updateScale = false;\r\n\r\n        this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\r\n        // Create Materials\r\n        this.coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this.coloredMaterial.disableLighting = true;\r\n        this.hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\r\n        this.hoverColoredMaterial.disableLighting = true;\r\n\r\n        // Build bounding box out of lines\r\n        this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._lineBoundingBox.rotationQuaternion = new Quaternion();\r\n        var lines = [];\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)] }, gizmoLayer.utilityLayerScene));\r\n        lines.push(LinesBuilder.CreateLines(\"lines\", { points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)] }, gizmoLayer.utilityLayerScene));\r\n        lines.forEach((l) => {\r\n            l.color = color;\r\n            l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n            l.isPickable = false;\r\n            this._lineBoundingBox.addChild(l);\r\n        });\r\n        this._rootMesh.addChild(this._lineBoundingBox);\r\n\r\n        this.setColor(color);\r\n\r\n        // Create rotation spheres\r\n        this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._rotateSpheresParent.rotationQuaternion = new Quaternion();\r\n        for (let i = 0; i < 12; i++) {\r\n            let sphere = SphereBuilder.CreateSphere(\"\", { diameter: 1 }, gizmoLayer.utilityLayerScene);\r\n            sphere.rotationQuaternion = new Quaternion();\r\n            sphere.material = this.coloredMaterial;\r\n\r\n            // Drag behavior\r\n            var _dragBehavior = new PointerDragBehavior({});\r\n            _dragBehavior.moveAttached = false;\r\n            _dragBehavior.updateDragPlane = false;\r\n            sphere.addBehavior(_dragBehavior);\r\n            let startingTurnDirection = new Vector3(1, 0, 0);\r\n            let totalTurnAmountOfDrag = 0;\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                startingTurnDirection.copyFrom(sphere.forward);\r\n                totalTurnAmountOfDrag = 0;\r\n            });\r\n            _dragBehavior.onDragObservable.add((event) => {\r\n                this.onRotationSphereDragObservable.notifyObservers({});\r\n                if (this.attachedMesh) {\r\n                    var originalParent = this.attachedMesh.parent;\r\n                    if (originalParent && ((originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                        Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                        return;\r\n                    }\r\n                    PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n                    var worldDragDirection = startingTurnDirection;\r\n\r\n                    // Project the world right on to the drag plane\r\n                    var toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\r\n                    var dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\r\n\r\n                    // project drag delta on to the resulting drag axis and rotate based on that\r\n                    var projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\r\n\r\n                    // Make rotation relative to size of mesh.\r\n                    projectDist = (projectDist / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n\r\n                    // Rotate based on axis\r\n                    if (!this.attachedMesh.rotationQuaternion) {\r\n                        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n                    }\r\n                    if (!this._anchorMesh.rotationQuaternion) {\r\n                        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\r\n                    }\r\n\r\n                    // Do not allow the object to turn more than a full circle\r\n                    totalTurnAmountOfDrag += projectDist;\r\n                    if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\r\n                        if (i >= 8) {\r\n                            Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\r\n                        } else if (i >= 4) {\r\n                            Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\r\n                        } else {\r\n                            Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\r\n                        }\r\n\r\n                        // Rotate around center of bounding box\r\n                        this._anchorMesh.addChild(this.attachedMesh);\r\n                        this._anchorMesh.rotationQuaternion!.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion!);\r\n                        this._anchorMesh.removeChild(this.attachedMesh);\r\n                        this.attachedMesh.setParent(originalParent);\r\n                    }\r\n                    this.updateBoundingBox();\r\n\r\n                    PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                }\r\n                this._updateDummy();\r\n            });\r\n\r\n            // Selection/deselection\r\n            _dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n                this._selectNode(sphere);\r\n            });\r\n            _dragBehavior.onDragEndObservable.add(() => {\r\n                this.onRotationSphereDragEndObservable.notifyObservers({});\r\n                this._selectNode(null);\r\n                this._updateDummy();\r\n            });\r\n\r\n            this._rotateSpheresParent.addChild(sphere);\r\n        }\r\n        this._rootMesh.addChild(this._rotateSpheresParent);\r\n\r\n        // Create scale cubes\r\n        this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\r\n        this._scaleBoxesParent.rotationQuaternion = new Quaternion();\r\n        for (var i = 0; i < 3; i++) {\r\n            for (var j = 0; j < 3; j++) {\r\n                for (var k = 0; k < 3; k++) {\r\n                    // create box for relevant axis\r\n                    let zeroAxisCount = ((i === 1) ? 1 : 0) + ((j === 1) ? 1 : 0) + ((k === 1) ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n\r\n                    let box = BoxBuilder.CreateBox(\"\", { size: 1 }, gizmoLayer.utilityLayerScene);\r\n                    box.material = this.coloredMaterial;\r\n                    box.metadata = zeroAxisCount === 2; // None homogenous scale handle\r\n\r\n                    // Dragging logic\r\n                    let dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\r\n                    var _dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\r\n                    _dragBehavior.updateDragPlane = false;\r\n                    _dragBehavior.moveAttached = false;\r\n                    box.addBehavior(_dragBehavior);\r\n                    _dragBehavior.onDragObservable.add((event) => {\r\n                        this.onScaleBoxDragObservable.notifyObservers({});\r\n                        if (this.attachedMesh) {\r\n                            var originalParent = this.attachedMesh.parent;\r\n                            if (originalParent && ((originalParent as Mesh).scaling && (originalParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\r\n                                return;\r\n                            }\r\n                            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n                            var relativeDragDistance = (event.dragDistance / this._boundingDimensions.length()) * this._anchorMesh.scaling.length();\r\n                            var deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\r\n                            if (zeroAxisCount === 2) {\r\n                                // scale on 1 axis when using the anchor box in the face middle\r\n                                deltaScale.x *= Math.abs(dragAxis.x);\r\n                                deltaScale.y *= Math.abs(dragAxis.y);\r\n                                deltaScale.z *= Math.abs(dragAxis.z);\r\n                            }\r\n                            deltaScale.scaleInPlace(this._scaleDragSpeed);\r\n                            this.updateBoundingBox();\r\n                            if (this.scalePivot) {\r\n                                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\r\n                                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\r\n                                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\r\n                                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\r\n                                this._anchorMesh.position.addInPlace(this._tmpVector);\r\n                            } else {\r\n                                // Scale from the position of the opposite corner\r\n                                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\r\n                                this._anchorMesh.position.subtractInPlace(this._tmpVector);\r\n                            }\r\n\r\n                            this._anchorMesh.addChild(this.attachedMesh);\r\n                            this._anchorMesh.scaling.addInPlace(deltaScale);\r\n                            if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\r\n                                this._anchorMesh.scaling.subtractInPlace(deltaScale);\r\n                            }\r\n                            this._anchorMesh.removeChild(this.attachedMesh);\r\n                            this.attachedMesh.setParent(originalParent);\r\n                            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n                        }\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    // Selection/deselection\r\n                    _dragBehavior.onDragStartObservable.add(() => {\r\n                        this.onDragStartObservable.notifyObservers({});\r\n                        this._selectNode(box);\r\n                    });\r\n                    _dragBehavior.onDragEndObservable.add(() => {\r\n                        this.onScaleBoxDragEndObservable.notifyObservers({});\r\n                        this._selectNode(null);\r\n                        this._updateDummy();\r\n                    });\r\n\r\n                    this._scaleBoxesParent.addChild(box);\r\n                }\r\n            }\r\n        }\r\n        this._rootMesh.addChild(this._scaleBoxesParent);\r\n\r\n        // Hover color change\r\n        var pointerIds = new Array<AbstractMesh>();\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!pointerIds[(<PointerEvent>pointerInfo.event).pointerId]) {\r\n                this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach((mesh) => {\r\n                    if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\r\n                        pointerIds[(<PointerEvent>pointerInfo.event).pointerId] = mesh;\r\n                        mesh.material = this.hoverColoredMaterial;\r\n                    }\r\n                });\r\n            } else {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[(<PointerEvent>pointerInfo.event).pointerId]) {\r\n                    pointerIds[(<PointerEvent>pointerInfo.event).pointerId].material = this.coloredMaterial;\r\n                    delete pointerIds[(<PointerEvent>pointerInfo.event).pointerId];\r\n                }\r\n            }\r\n        });\r\n\r\n        // Update bounding box positions\r\n        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\r\n            // Only update the bouding box if scaling has changed\r\n            if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\r\n                this.updateBoundingBox();\r\n            } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\r\n                this._updateRotationSpheres();\r\n                this._updateScaleBoxes();\r\n            }\r\n\r\n            // If dragg mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\r\n            if (this._dragMesh && this.attachedMesh && this.pointerDragBehavior.dragging) {\r\n                this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion!, this._tmpVector);\r\n                this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\r\n            }\r\n        });\r\n        this.updateBoundingBox();\r\n    }\r\n\r\n    protected _attachedNodeChanged(value: Nullable<AbstractMesh>) {\r\n        if (value) {\r\n            // Reset anchor mesh to match attached mesh's scale\r\n            // This is needed to avoid invalid box/sphere position on first drag\r\n            PivotTools._RemoveAndStorePivotPoint(value);\r\n            var originalParent = value.parent;\r\n            this._anchorMesh.addChild(value);\r\n            this._anchorMesh.removeChild(value);\r\n            value.setParent(originalParent);\r\n            PivotTools._RestorePivotPoint(value);\r\n            this.updateBoundingBox();\r\n            value.getChildMeshes(false).forEach((m) => {\r\n                m.markAsDirty(\"scaling\");\r\n            });\r\n\r\n            this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\r\n                this._updateDummy();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _selectNode(selectedMesh: Nullable<Mesh>) {\r\n        this._rotateSpheresParent.getChildMeshes()\r\n            .concat(this._scaleBoxesParent.getChildMeshes()).forEach((m) => {\r\n                m.isVisible = (!selectedMesh || m == selectedMesh);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Updates the bounding box information for the Gizmo\r\n     */\r\n    public updateBoundingBox() {\r\n        if (this.attachedMesh) {\r\n            PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\r\n\r\n            // Store original parent\r\n            var originalParent = this.attachedMesh.parent;\r\n            this.attachedMesh.setParent(null);\r\n\r\n            // Store original skelton override mesh\r\n            var originalSkeletonOverrideMesh = null;\r\n            if (this.attachedMesh.skeleton) {\r\n                originalSkeletonOverrideMesh = this.attachedMesh.skeleton.overrideMesh;\r\n                this.attachedMesh.skeleton.overrideMesh = null;\r\n            }\r\n\r\n            this._update();\r\n\r\n            // Rotate based on axis\r\n            if (!this.attachedMesh.rotationQuaternion) {\r\n                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\r\n            }\r\n            if (!this._anchorMesh.rotationQuaternion) {\r\n                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\r\n            }\r\n            this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n\r\n            // Store original position and reset mesh to origin before computing the bounding box\r\n            this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\r\n            this._tmpVector.copyFrom(this.attachedMesh.position);\r\n            this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\r\n            this.attachedMesh.position.set(0, 0, 0);\r\n\r\n            // Update bounding dimensions/positions\r\n            var boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\r\n            boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\r\n\r\n            // Update gizmo to match bounding box scaling and rotation\r\n            // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\r\n            // The position of the gizmo is then set to the attachedMesh in gizmo._update\r\n            this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\r\n            this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\r\n            this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\r\n            this._lineBoundingBox.computeWorldMatrix();\r\n            this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\r\n\r\n            // Restore position/rotation values\r\n            this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\r\n            this.attachedMesh.position.copyFrom(this._tmpVector);\r\n\r\n            // Restore original parent\r\n            this.attachedMesh.setParent(originalParent);\r\n\r\n            // Restore original skeleton override mesh\r\n            if (this.attachedMesh.skeleton) {\r\n                this.attachedMesh.skeleton.overrideMesh = originalSkeletonOverrideMesh;\r\n            }\r\n        }\r\n\r\n        this._updateRotationSpheres();\r\n        this._updateScaleBoxes();\r\n\r\n        if (this.attachedMesh) {\r\n            this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\r\n            PivotTools._RestorePivotPoint(this.attachedMesh);\r\n        }\r\n    }\r\n\r\n    private _updateRotationSpheres() {\r\n        var rotateSpheres = this._rotateSpheresParent.getChildMeshes();\r\n        for (var i = 0; i < 3; i++) {\r\n            for (var j = 0; j < 2; j++) {\r\n                for (var k = 0; k < 2; k++) {\r\n                    var index = ((i * 4) + (j * 2)) + k;\r\n                    if (i == 0) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\r\n                    }\r\n                    if (i == 1) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\r\n                    }\r\n                    if (i == 2) {\r\n                        rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\r\n                        rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\r\n                    }\r\n                    if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                        rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                        var distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                        rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                    } else if (this.fixedDragMeshBoundsSize) {\r\n                        rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\r\n                    } else {\r\n                        rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateScaleBoxes() {\r\n        var scaleBoxes = this._scaleBoxesParent.getChildMeshes();\r\n        var index = 0;\r\n        for (var i = 0; i < 3; i++) {\r\n            for (var j = 0; j < 3; j++) {\r\n                for (var k = 0; k < 3; k++) {\r\n                    let zeroAxisCount = ((i === 1) ? 1 : 0) + ((j === 1) ? 1 : 0) + ((k === 1) ? 1 : 0);\r\n                    if (zeroAxisCount === 1 || zeroAxisCount === 3) {\r\n                        continue;\r\n                    }\r\n                    if (scaleBoxes[index]) {\r\n                        scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\r\n                        scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\r\n                        if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\r\n                            scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\r\n                            var distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\r\n                            scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\r\n                        } else if (this.fixedDragMeshBoundsSize) {\r\n                            scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\r\n                        } else {\r\n                            scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\r\n                        }\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables rotation on the specified axis and disables rotation on the others\r\n     * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\r\n     */\r\n    public setEnabledRotationAxis(axis: string) {\r\n        this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\r\n            if (i < 4) {\r\n                m.setEnabled(axis.indexOf(\"x\") != -1);\r\n            } else if (i < 8) {\r\n                m.setEnabled(axis.indexOf(\"y\") != -1);\r\n            } else {\r\n                m.setEnabled(axis.indexOf(\"z\") != -1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables/disables scaling\r\n     * @param enable if scaling should be enabled\r\n     * @param homogeneousScaling defines if scaling should only be homogeneous\r\n     */\r\n    public setEnabledScaling(enable: boolean, homogeneousScaling = false) {\r\n        this._scaleBoxesParent.getChildMeshes().forEach((m, i) => {\r\n            let enableMesh = enable;\r\n            // Disable heterogenous scale handles if requested.\r\n            if (homogeneousScaling && m.metadata === true) {\r\n                enableMesh = false;\r\n            }\r\n            m.setEnabled(enableMesh);\r\n        });\r\n    }\r\n\r\n    private _updateDummy() {\r\n        if (this._dragMesh) {\r\n            this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\r\n            this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\r\n            this._dragMesh.rotationQuaternion!.copyFrom(this._rootMesh.rotationQuaternion!);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables a pointer drag behavior on the bounding box of the gizmo\r\n     */\r\n    public enableDragBehavior() {\r\n        this._dragMesh = Mesh.CreateBox(\"dummy\", 1, this.gizmoLayer.utilityLayerScene);\r\n        this._dragMesh.visibility = 0;\r\n        this._dragMesh.rotationQuaternion = new Quaternion();\r\n        this.pointerDragBehavior.useObjectOrientationForDragging = false;\r\n        this._dragMesh.addBehavior(this.pointerDragBehavior);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\r\n        this._lineBoundingBox.dispose();\r\n        this._rotateSpheresParent.dispose();\r\n        this._scaleBoxesParent.dispose();\r\n        if (this._dragMesh) {\r\n            this._dragMesh.dispose();\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\r\n     * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\r\n     * @returns the bounding box mesh with the passed in mesh as a child\r\n     */\r\n    public static MakeNotPickableAndWrapInBoundingBox(mesh: Mesh): Mesh {\r\n        var makeNotPickable = (root: AbstractMesh) => {\r\n            root.isPickable = false;\r\n            root.getChildMeshes().forEach((c) => {\r\n                makeNotPickable(c);\r\n            });\r\n        };\r\n        makeNotPickable(mesh);\r\n\r\n        // Reset position to get boudning box from origin with no rotation\r\n        if (!mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\r\n        }\r\n        var oldPos = mesh.position.clone();\r\n        var oldRot = mesh.rotationQuaternion.clone();\r\n        mesh.rotationQuaternion.set(0, 0, 0, 1);\r\n        mesh.position.set(0, 0, 0);\r\n\r\n        // Update bounding dimensions/positions\r\n        var box = BoxBuilder.CreateBox(\"box\", { size: 1 }, mesh.getScene());\r\n        var boundingMinMax = mesh.getHierarchyBoundingVectors();\r\n        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\r\n\r\n        // Adjust scale to avoid undefined behavior when adding child\r\n        if (box.scaling.y === 0) {\r\n            box.scaling.y = Epsilon;\r\n        }\r\n        if (box.scaling.x === 0) {\r\n            box.scaling.x = Epsilon;\r\n        }\r\n        if (box.scaling.z === 0) {\r\n            box.scaling.z = Epsilon;\r\n        }\r\n\r\n        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\r\n\r\n        // Restore original positions\r\n        mesh.addChild(box);\r\n        mesh.rotationQuaternion.copyFrom(oldRot);\r\n        mesh.position.copyFrom(oldPos);\r\n\r\n        // Reverse parenting\r\n        mesh.removeChild(box);\r\n\r\n        box.addChild(mesh);\r\n        box.visibility = 0;\r\n        return box;\r\n    }\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        Logger.Error(\"Custom meshes are not supported on this gizmo\");\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}