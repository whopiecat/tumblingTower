{"ast":null,"code":"import { Vector3, Matrix } from './math.vector';\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\n\nvar Plane =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n   * @param a a component of the plane\r\n   * @param b b component of the plane\r\n   * @param c c component of the plane\r\n   * @param d d component of the plane\r\n   */\n  function Plane(a, b, c, d) {\n    this.normal = new Vector3(a, b, c);\n    this.d = d;\n  }\n  /**\r\n   * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n   */\n\n\n  Plane.prototype.asArray = function () {\n    return [this.normal.x, this.normal.y, this.normal.z, this.d];\n  }; // Methods\n\n  /**\r\n   * @returns a new plane copied from the current Plane.\r\n   */\n\n\n  Plane.prototype.clone = function () {\n    return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n  };\n  /**\r\n   * @returns the string \"Plane\".\r\n   */\n\n\n  Plane.prototype.getClassName = function () {\n    return \"Plane\";\n  };\n  /**\r\n   * @returns the Plane hash code.\r\n   */\n\n\n  Plane.prototype.getHashCode = function () {\n    var hash = this.normal.getHashCode();\n    hash = hash * 397 ^ (this.d | 0);\n    return hash;\n  };\n  /**\r\n   * Normalize the current Plane in place.\r\n   * @returns the updated Plane.\r\n   */\n\n\n  Plane.prototype.normalize = function () {\n    var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n    var magnitude = 0.0;\n\n    if (norm !== 0) {\n      magnitude = 1.0 / norm;\n    }\n\n    this.normal.x *= magnitude;\n    this.normal.y *= magnitude;\n    this.normal.z *= magnitude;\n    this.d *= magnitude;\n    return this;\n  };\n  /**\r\n   * Applies a transformation the plane and returns the result\r\n   * @param transformation the transformation matrix to be applied to the plane\r\n   * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n   */\n\n\n  Plane.prototype.transform = function (transformation) {\n    var invertedMatrix = Plane._TmpMatrix;\n    transformation.invertToRef(invertedMatrix);\n    var m = invertedMatrix.m;\n    var x = this.normal.x;\n    var y = this.normal.y;\n    var z = this.normal.z;\n    var d = this.d;\n    var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n    var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n    var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n    var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n    return new Plane(normalX, normalY, normalZ, finalD);\n  };\n  /**\r\n   * Compute the dot product between the point and the plane normal\r\n   * @param point point to calculate the dot product with\r\n   * @returns the dot product (float) of the point coordinates and the plane normal.\r\n   */\n\n\n  Plane.prototype.dotCoordinate = function (point) {\n    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n  };\n  /**\r\n   * Updates the current Plane from the plane defined by the three given points.\r\n   * @param point1 one of the points used to contruct the plane\r\n   * @param point2 one of the points used to contruct the plane\r\n   * @param point3 one of the points used to contruct the plane\r\n   * @returns the updated Plane.\r\n   */\n\n\n  Plane.prototype.copyFromPoints = function (point1, point2, point3) {\n    var x1 = point2.x - point1.x;\n    var y1 = point2.y - point1.y;\n    var z1 = point2.z - point1.z;\n    var x2 = point3.x - point1.x;\n    var y2 = point3.y - point1.y;\n    var z2 = point3.z - point1.z;\n    var yz = y1 * z2 - z1 * y2;\n    var xz = z1 * x2 - x1 * z2;\n    var xy = x1 * y2 - y1 * x2;\n    var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n    var invPyth;\n\n    if (pyth !== 0) {\n      invPyth = 1.0 / pyth;\n    } else {\n      invPyth = 0.0;\n    }\n\n    this.normal.x = yz * invPyth;\n    this.normal.y = xz * invPyth;\n    this.normal.z = xy * invPyth;\n    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n    return this;\n  };\n  /**\r\n   * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n   * Note that for this function to work as expected you should make sure that:\r\n   *   - direction and the plane normal are normalized\r\n   *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n   * @param direction the direction to check if the plane is facing\r\n   * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n   * @returns True if the plane is facing the given direction\r\n   */\n\n\n  Plane.prototype.isFrontFacingTo = function (direction, epsilon) {\n    var dot = Vector3.Dot(this.normal, direction);\n    return dot <= epsilon;\n  };\n  /**\r\n   * Calculates the distance to a point\r\n   * @param point point to calculate distance to\r\n   * @returns the signed distance (float) from the given point to the Plane.\r\n   */\n\n\n  Plane.prototype.signedDistanceTo = function (point) {\n    return Vector3.Dot(point, this.normal) + this.d;\n  }; // Statics\n\n  /**\r\n   * Creates a plane from an  array\r\n   * @param array the array to create a plane from\r\n   * @returns a new Plane from the given array.\r\n   */\n\n\n  Plane.FromArray = function (array) {\n    return new Plane(array[0], array[1], array[2], array[3]);\n  };\n  /**\r\n   * Creates a plane from three points\r\n   * @param point1 point used to create the plane\r\n   * @param point2 point used to create the plane\r\n   * @param point3 point used to create the plane\r\n   * @returns a new Plane defined by the three given points.\r\n   */\n\n\n  Plane.FromPoints = function (point1, point2, point3) {\n    var result = new Plane(0.0, 0.0, 0.0, 0.0);\n    result.copyFromPoints(point1, point2, point3);\n    return result;\n  };\n  /**\r\n   * Creates a plane from an origin point and a normal\r\n   * @param origin origin of the plane to be constructed\r\n   * @param normal normal of the plane to be constructed\r\n   * @returns a new Plane the normal vector to this plane at the given origin point.\r\n   * Note : the vector \"normal\" is updated because normalized.\r\n   */\n\n\n  Plane.FromPositionAndNormal = function (origin, normal) {\n    var result = new Plane(0.0, 0.0, 0.0, 0.0);\n    normal.normalize();\n    result.normal = normal;\n    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return result;\n  };\n  /**\r\n   * Calculates the distance from a plane and a point\r\n   * @param origin origin of the plane to be constructed\r\n   * @param normal normal of the plane to be constructed\r\n   * @param point point to calculate distance to\r\n   * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n   */\n\n\n  Plane.SignedDistanceToPlaneFromPositionAndNormal = function (origin, normal, point) {\n    var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return Vector3.Dot(point, normal) + d;\n  };\n\n  Plane._TmpMatrix = Matrix.Identity();\n  return Plane;\n}();\n\nexport { Plane };","map":{"version":3,"sources":["../../../sourceES6/core/Maths/math.plane.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepImmutable } from '../types';\r\nimport { Vector3, Matrix } from './math.vector';\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        var norm = (Math.sqrt((this.normal.x * this.normal.x) + (this.normal.y * this.normal.y) + (this.normal.z * this.normal.z)));\r\n        var magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        var x = this.normal.x;\r\n        var y = this.normal.y;\r\n        var z = this.normal.z;\r\n        var d = this.d;\r\n\r\n        var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return ((((this.normal.x * point.x) + (this.normal.y * point.y)) + (this.normal.z * point.z)) + this.d);\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to contruct the plane\r\n     * @param point2 one of the points used to contruct the plane\r\n     * @param point3 one of the points used to contruct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        var x1 = point2.x - point1.x;\r\n        var y1 = point2.y - point1.y;\r\n        var z1 = point2.z - point1.z;\r\n        var x2 = point3.x - point1.x;\r\n        var y2 = point3.y - point1.y;\r\n        var z2 = point3.z - point1.z;\r\n        var yz = (y1 * z2) - (z1 * y2);\r\n        var xz = (z1 * x2) - (x1 * z2);\r\n        var xy = (x1 * y2) - (y1 * x2);\r\n        var pyth = (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\r\n        var invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        }\r\n        else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -((this.normal.x * point1.x) + (this.normal.y * point1.y) + (this.normal.z * point1.z));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        var dot = Vector3.Dot(this.normal, direction);\r\n        return (dot <= epsilon);\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     * Note : the vector \"normal\" is updated because normalized.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        normal.normalize();\r\n        result.normal = normal;\r\n        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}