{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients\";\nimport { Observable } from \"../Misc/observable\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { Color4, TmpColors } from '../Maths/math.color';\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { Buffer } from \"../Meshes/buffer\";\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\nimport { Effect } from \"../Materials/effect\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CustomParticleEmitter } from './EmitterTypes/customParticleEmitter';\nimport \"../Shaders/gpuUpdateParticles.fragment\";\nimport \"../Shaders/gpuUpdateParticles.vertex\";\nimport \"../Shaders/gpuRenderParticles.fragment\";\nimport \"../Shaders/gpuRenderParticles.vertex\";\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\n\nvar GPUParticleSystem =\n/** @class */\nfunction (_super) {\n  __extends(GPUParticleSystem, _super);\n  /**\r\n   * Instantiates a GPU particle system.\r\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n   * @param name The name of the particle system\r\n   * @param options The options used to create the system\r\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n   * @param customEffect a custom effect used to change the way particles are rendered by default\r\n   */\n\n\n  function GPUParticleSystem(name, options, sceneOrEngine, isAnimationSheetEnabled, customEffect) {\n    if (isAnimationSheetEnabled === void 0) {\n      isAnimationSheetEnabled = false;\n    }\n\n    if (customEffect === void 0) {\n      customEffect = null;\n    }\n\n    var _this = _super.call(this, name) || this;\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\n\n\n    _this.layerMask = 0x0FFFFFFF;\n    _this._accumulatedCount = 0;\n    _this._targetIndex = 0;\n    _this._currentRenderId = -1;\n    _this._started = false;\n    _this._stopped = false;\n    _this._timeDelta = 0;\n    _this._actualFrame = 0;\n    _this._rawTextureWidth = 256;\n    /**\r\n    * An event triggered when the system is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    /**\r\n    * An event triggered when the system is stopped\r\n    */\n\n    _this.onStoppedObservable = new Observable();\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\n\n    _this.forceDepthWrite = false;\n    _this._preWarmDone = false;\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\n\n    _this.isLocal = false;\n    /** @hidden */\n\n    _this._onBeforeDrawParticlesObservable = null;\n\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      _this._engine = _this._scene.getEngine();\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.particleSystems.push(_this);\n    } else {\n      _this._engine = sceneOrEngine;\n      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\n    }\n\n    _this._customEffect = {\n      0: customEffect\n    }; // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    if (!options.randomTextureSize) {\n      delete options.randomTextureSize;\n    }\n\n    var fullOptions = __assign({\n      capacity: 50000,\n      randomTextureSize: _this._engine.getCaps().maxTextureSize\n    }, options);\n\n    var optionsAsNumber = options;\n\n    if (isFinite(optionsAsNumber)) {\n      fullOptions.capacity = optionsAsNumber;\n    }\n\n    _this._capacity = fullOptions.capacity;\n    _this._activeCount = fullOptions.capacity;\n    _this._currentActiveCount = 0;\n    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    _this._updateEffectOptions = {\n      attributes: [\"position\", \"initialPosition\", \"age\", \"life\", \"seed\", \"size\", \"color\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\", \"cellStartOffset\", \"noiseCoordinates1\", \"noiseCoordinates2\"],\n      uniformsNames: [\"currentCount\", \"timeDelta\", \"emitterWM\", \"lifeTime\", \"color1\", \"color2\", \"sizeRange\", \"scaleRange\", \"gravity\", \"emitPower\", \"direction1\", \"direction2\", \"minEmitBox\", \"maxEmitBox\", \"radius\", \"directionRandomizer\", \"height\", \"coneAngle\", \"stopFactor\", \"angleRange\", \"radiusRange\", \"cellInfos\", \"noiseStrength\", \"limitVelocityDamping\"],\n      uniformBuffersNames: [],\n      samplers: [\"randomSampler\", \"randomSampler2\", \"sizeGradientSampler\", \"angularSpeedGradientSampler\", \"velocityGradientSampler\", \"limitVelocityGradientSampler\", \"noiseSampler\", \"dragGradientSampler\"],\n      defines: \"\",\n      fallbacks: null,\n      onCompiled: null,\n      onError: null,\n      indexParameters: null,\n      maxSimultaneousLights: 0,\n      transformFeedbackVaryings: []\n    };\n    _this.particleEmitterType = new BoxParticleEmitter(); // Random data\n\n    var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n    var d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture.wrapU = 1;\n    _this._randomTexture.wrapV = 1;\n    d = [];\n\n    for (var i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n\n    _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    _this._randomTexture2.wrapU = 1;\n    _this._randomTexture2.wrapV = 1;\n    _this._randomTextureSize = maxTextureSize;\n    return _this;\n  }\n\n  Object.defineProperty(GPUParticleSystem, \"IsSupported\", {\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\n    get: function () {\n      if (!EngineStore.LastCreatedEngine) {\n        return false;\n      }\n\n      return EngineStore.LastCreatedEngine.webGLVersion > 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the maximum number of particles active at the same time.\r\n   * @returns The max number of active particles.\r\n   */\n\n  GPUParticleSystem.prototype.getCapacity = function () {\n    return this._capacity;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"activeParticleCount\", {\n    /**\r\n     * Gets or set the number of active particles\r\n     */\n    get: function () {\n      return this._activeCount;\n    },\n    set: function (value) {\n      this._activeCount = Math.min(value, this._capacity);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Is this system ready to be used/rendered\r\n   * @return true if the system is ready\r\n   */\n\n  GPUParticleSystem.prototype.isReady = function () {\n    if (!this._updateEffect) {\n      this._recreateUpdateEffect();\n\n      this._recreateRenderEffect();\n\n      return false;\n    }\n\n    if (!this.emitter || !this._updateEffect.isReady() || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this._getEffect().isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n   * @returns True if it has been started, otherwise false.\r\n   */\n\n\n  GPUParticleSystem.prototype.isStarted = function () {\n    return this._started;\n  };\n  /**\r\n   * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n   * @returns True if it has been stopped, otherwise false.\r\n   */\n\n\n  GPUParticleSystem.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\r\n   * Gets a boolean indicating that the system is stopping\r\n   * @returns true if the system is currently stopping\r\n   */\n\n\n  GPUParticleSystem.prototype.isStopping = function () {\n    return false; // Stop is immediate on GPU\n  };\n  /**\r\n   * Gets the number of particles active at the same time.\r\n   * @returns The number of active particles.\r\n   */\n\n\n  GPUParticleSystem.prototype.getActiveCount = function () {\n    return this._currentActiveCount;\n  };\n  /**\r\n   * Starts the particle system and begins to emit\r\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n   */\n\n\n  GPUParticleSystem.prototype.start = function (delay) {\n    var _this = this;\n\n    if (delay === void 0) {\n      delay = this.startDelay;\n    }\n\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n\n    if (delay) {\n      setTimeout(function () {\n        _this.start(0);\n      }, delay);\n      return;\n    }\n\n    this._started = true;\n    this._stopped = false;\n    this._preWarmDone = false; // Animations\n\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  };\n  /**\r\n   * Stops the particle system.\r\n   */\n\n\n  GPUParticleSystem.prototype.stop = function () {\n    if (this._stopped) {\n      return;\n    }\n\n    this._stopped = true;\n  };\n  /**\r\n   * Remove all active particles\r\n   */\n\n\n  GPUParticleSystem.prototype.reset = function () {\n    this._releaseBuffers();\n\n    this._releaseVAOs();\n\n    this._currentActiveCount = 0;\n    this._targetIndex = 0;\n  };\n  /**\r\n   * Returns the string \"GPUParticleSystem\"\r\n   * @returns a string containing the class name\r\n   */\n\n\n  GPUParticleSystem.prototype.getClassName = function () {\n    return \"GPUParticleSystem\";\n  };\n  /**\r\n   * Gets the custom effect used to render the particles\r\n   * @param blendMode Blend mode for which the effect should be retrieved\r\n   * @returns The effect\r\n   */\n\n\n  GPUParticleSystem.prototype.getCustomEffect = function (blendMode) {\n    var _a;\n\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    return (_a = this._customEffect[blendMode]) !== null && _a !== void 0 ? _a : this._customEffect[0];\n  };\n  /**\r\n   * Sets the custom effect used to render the particles\r\n   * @param effect The effect to set\r\n   * @param blendMode Blend mode for which the effect should be set\r\n   */\n\n\n  GPUParticleSystem.prototype.setCustomEffect = function (effect, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    this._customEffect[blendMode] = effect;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"onBeforeDrawParticlesObservable\", {\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\n    get: function () {\n      if (!this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable = new Observable();\n      }\n\n      return this._onBeforeDrawParticlesObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GPUParticleSystem.prototype, \"vertexShaderName\", {\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\n    get: function () {\n      return \"gpuRenderParticles\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  GPUParticleSystem.prototype._removeGradientAndTexture = function (gradient, gradients, texture) {\n    _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Adds a new color gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color1 defines the color to affect to the specified gradient\r\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addColorGradient = function (gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n\n    var colorGradient = new ColorGradient(gradient, color1);\n\n    this._colorGradients.push(colorGradient);\n\n    this._refreshColorGradient(true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshColorGradient = function (reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (this._colorGradients) {\n      if (reorder) {\n        this._colorGradients.sort(function (a, b) {\n          if (a.gradient < b.gradient) {\n            return -1;\n          } else if (a.gradient > b.gradient) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      if (this._colorGradientsTexture) {\n        this._colorGradientsTexture.dispose();\n\n        this._colorGradientsTexture = null;\n      }\n    }\n  };\n  /** Force the system to rebuild all gradients that need to be resync */\n\n\n  GPUParticleSystem.prototype.forceRefreshGradients = function () {\n    this._refreshColorGradient();\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n\n    this.reset();\n  };\n  /**\r\n   * Remove a specific color gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeColorGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n\n    this._colorGradientsTexture = null;\n    return this;\n  };\n\n  GPUParticleSystem.prototype._addFactorGradient = function (factorGradients, gradient, factor) {\n    var valueGradient = new FactorGradient(gradient, factor);\n    factorGradients.push(valueGradient);\n\n    this._releaseBuffers();\n  };\n  /**\r\n   * Adds a new size gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the size factor to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addSizeGradient = function (gradient, factor) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n\n    this._addFactorGradient(this._sizeGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific size gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeSizeGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n\n    this._sizeGradientsTexture = null;\n    return this;\n  };\n\n  GPUParticleSystem.prototype._refreshFactorGradient = function (factorGradients, textureName, reorder) {\n    if (reorder === void 0) {\n      reorder = false;\n    }\n\n    if (!factorGradients) {\n      return;\n    }\n\n    if (reorder) {\n      factorGradients.sort(function (a, b) {\n        if (a.gradient < b.gradient) {\n          return -1;\n        } else if (a.gradient > b.gradient) {\n          return 1;\n        }\n\n        return 0;\n      });\n    }\n\n    var that = this;\n\n    if (that[textureName]) {\n      that[textureName].dispose();\n      that[textureName] = null;\n    }\n  };\n  /**\r\n   * Adds a new angular speed gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the angular speed to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addAngularSpeedGradient = function (gradient, factor) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific angular speed gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeAngularSpeedGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n\n    this._angularSpeedGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the velocity to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addVelocityGradient = function (gradient, factor) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n\n    this._addFactorGradient(this._velocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n\n    this._velocityGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new limit velocity gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the limit velocity value to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addLimitVelocityGradient = function (gradient, factor) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific limit velocity gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeLimitVelocityGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n\n    this._limitVelocityGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Adds a new drag gradient\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the drag value to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addDragGradient = function (gradient, factor) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n\n    this._addFactorGradient(this._dragGradients, gradient, factor);\n\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n\n    this._releaseBuffers();\n\n    return this;\n  };\n  /**\r\n   * Remove a specific drag gradient\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeDragGradient = function (gradient) {\n    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n\n    this._dragGradientsTexture = null;\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the emit rate value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addEmitRateGradient = function (gradient, factor, factor2) {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeEmitRateGradient = function (gradient) {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the start size value to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addStartSizeGradient = function (gradient, factor, factor2) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeStartSizeGradient = function (gradient) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the color remap minimal range\r\n   * @param max defines the color remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addColorRemapGradient = function (gradient, min, max) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeColorRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param min defines the alpha remap minimal range\r\n   * @param max defines the alpha remap maximal range\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addAlphaRemapGradient = function (gradient, min, max) {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeAlphaRemapGradient = function () {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param color defines the color to affect to the specified gradient\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.addRampGradient = function (gradient, color) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeRampGradient = function () {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @returns the list of ramp gradients\r\n   */\n\n\n  GPUParticleSystem.prototype.getRampGradients = function () {\n    return null;\n  };\n\n  Object.defineProperty(GPUParticleSystem.prototype, \"useRampGradients\", {\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\n    get: function () {\n      //Not supported by GPUParticleSystem\n      return false;\n    },\n    set: function (value) {//Not supported by GPUParticleSystem\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to use (between 0 and 1)\r\n   * @param factor defines the life time factor to affect to the specified gradient\r\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n   * @returns the current particle system\r\n   */\n\n  GPUParticleSystem.prototype.addLifeTimeGradient = function (gradient, factor, factor2) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n  /**\r\n   * Not supported by GPUParticleSystem\r\n   * @param gradient defines the gradient to remove\r\n   * @returns the current particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.removeLifeTimeGradient = function (gradient) {\n    //Not supported by GPUParticleSystem\n    return this;\n  };\n\n  GPUParticleSystem.prototype._reset = function () {\n    this._releaseBuffers();\n  };\n\n  GPUParticleSystem.prototype._createUpdateVAO = function (source) {\n    var updateVertexBuffers = {};\n    updateVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3);\n    var offset = 3;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      updateVertexBuffers[\"initialPosition\"] = source.createVertexBuffer(\"initialPosition\", offset, 3);\n      offset += 3;\n    }\n\n    updateVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"seed\"] = source.createVertexBuffer(\"seed\", offset, 4);\n    offset += 4;\n    updateVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3);\n    offset += 3;\n\n    if (!this._colorGradientsTexture) {\n      updateVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4);\n      offset += 4;\n    }\n\n    updateVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3);\n    offset += 3;\n\n    if (!this._isBillboardBased) {\n      updateVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3);\n      offset += 3;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1);\n      offset += 1;\n    } else {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 2);\n      offset += 2;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      updateVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1);\n      offset += 1;\n\n      if (this.spriteRandomStartCell) {\n        updateVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1);\n        offset += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      updateVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3);\n      offset += 3;\n      updateVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3);\n      offset += 3;\n    }\n\n    var vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);\n\n    this._engine.bindArrayBuffer(null);\n\n    return vao;\n  };\n\n  GPUParticleSystem.prototype._createRenderVAO = function (source, spriteSource) {\n    var renderVertexBuffers = {};\n    renderVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n    var offset = 3;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    renderVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n    offset += 5;\n    renderVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n    offset += 3;\n\n    if (!this._colorGradientsTexture) {\n      renderVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n      offset += 4;\n    }\n\n    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      renderVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n    }\n\n    offset += 3; // Direction\n\n    if (!this._isBillboardBased) {\n      renderVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n\n    if (this._angularSpeedGradientsTexture) {\n      offset++;\n    } else {\n      offset += 2;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      renderVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n      offset += 1;\n\n      if (this.spriteRandomStartCell) {\n        renderVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      renderVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      renderVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n    }\n\n    renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n    renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n\n    var vao = this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._getEffect());\n\n    this._engine.bindArrayBuffer(null);\n\n    return vao;\n  };\n\n  GPUParticleSystem.prototype._initialize = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (this._buffer0 && !force) {\n      return;\n    }\n\n    var engine = this._engine;\n    var data = new Array();\n    this._attributesStrideSize = 21;\n    this._targetIndex = 0;\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._attributesStrideSize += 3;\n    }\n\n    if (!this.isBillboardBased) {\n      this._attributesStrideSize += 3;\n    }\n\n    if (this._colorGradientsTexture) {\n      this._attributesStrideSize -= 4;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._attributesStrideSize -= 1;\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._attributesStrideSize += 1;\n\n      if (this.spriteRandomStartCell) {\n        this._attributesStrideSize += 1;\n      }\n    }\n\n    if (this.noiseTexture) {\n      this._attributesStrideSize += 6;\n    }\n\n    var usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n    var tmpVector = TmpVectors.Vector3[0];\n\n    for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n      // position\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } // Age and life\n\n\n      data.push(0.0); // create the particle as a dead one to create a new one at start\n\n      data.push(0.0); // Seed\n\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random()); // Size\n\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n\n      if (!this._colorGradientsTexture) {\n        // color\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      } // direction\n\n\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } else {\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      }\n\n      if (!this.isBillboardBased) {\n        // initialDirection\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      } // angle\n\n\n      data.push(0.0);\n\n      if (!this._angularSpeedGradientsTexture) {\n        data.push(0.0);\n      }\n\n      if (this._isAnimationSheetEnabled) {\n        data.push(0.0);\n\n        if (this.spriteRandomStartCell) {\n          data.push(0.0);\n        }\n      }\n\n      if (this.noiseTexture) {\n        // Random coordinates for reading into noise texture\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n      }\n    } // Sprite data\n\n\n    var spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, -0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0]); // Buffers\n\n    this._buffer0 = new Buffer(engine, data, false, this._attributesStrideSize);\n    this._buffer1 = new Buffer(engine, data, false, this._attributesStrideSize);\n    this._spriteBuffer = new Buffer(engine, spriteData, false, 4); // Update VAO\n\n    this._updateVAO = [];\n\n    this._updateVAO.push(this._createUpdateVAO(this._buffer0));\n\n    this._updateVAO.push(this._createUpdateVAO(this._buffer1)); // Render VAO\n\n\n    this._renderVAO = [];\n\n    this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer));\n\n    this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer)); // Links\n\n\n    this._sourceBuffer = this._buffer0;\n    this._targetBuffer = this._buffer1;\n  };\n  /** @hidden */\n\n\n  GPUParticleSystem.prototype._recreateUpdateEffect = function () {\n    var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n\n    if (this._isBillboardBased) {\n      defines += \"\\n#define BILLBOARD\";\n    }\n\n    if (this._colorGradientsTexture) {\n      defines += \"\\n#define COLORGRADIENTS\";\n    }\n\n    if (this._sizeGradientsTexture) {\n      defines += \"\\n#define SIZEGRADIENTS\";\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n    }\n\n    if (this._velocityGradientsTexture) {\n      defines += \"\\n#define VELOCITYGRADIENTS\";\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n    }\n\n    if (this._dragGradientsTexture) {\n      defines += \"\\n#define DRAGGRADIENTS\";\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines += \"\\n#define ANIMATESHEET\";\n\n      if (this.spriteRandomStartCell) {\n        defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n      }\n    }\n\n    if (this.noiseTexture) {\n      defines += \"\\n#define NOISE\";\n    }\n\n    if (this.isLocal) {\n      defines += \"\\n#define LOCAL\";\n    }\n\n    if (this._updateEffect && this._updateEffectOptions.defines === defines) {\n      return;\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\"];\n\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialPosition\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAge\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outLife\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSeed\");\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSize\");\n\n    if (!this._colorGradientsTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\");\n\n    if (!this._isBillboardBased) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\");\n    }\n\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\");\n\n    if (this.isAnimationSheetEnabled) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\");\n\n      if (this.spriteRandomStartCell) {\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\");\n      }\n    }\n\n    if (this.noiseTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\");\n\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\");\n    }\n\n    this._updateEffectOptions.defines = defines;\n    this._updateEffect = new Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._engine);\n  };\n\n  GPUParticleSystem.prototype._getEffect = function () {\n    var _a;\n\n    return (_a = this.getCustomEffect()) !== null && _a !== void 0 ? _a : this._renderEffect;\n  };\n  /**\r\n   * Fill the defines array according to the current settings of the particle system\r\n   * @param defines Array to be updated\r\n   * @param blendMode blend mode to take into account when updating the array\r\n   */\n\n\n  GPUParticleSystem.prototype.fillDefines = function (defines, blendMode) {\n    if (blendMode === void 0) {\n      blendMode = 0;\n    }\n\n    if (this._scene) {\n      if (this._scene.clipPlane) {\n        defines.push(\"#define CLIPPLANE\");\n      }\n\n      if (this._scene.clipPlane2) {\n        defines.push(\"#define CLIPPLANE2\");\n      }\n\n      if (this._scene.clipPlane3) {\n        defines.push(\"#define CLIPPLANE3\");\n      }\n\n      if (this._scene.clipPlane4) {\n        defines.push(\"#define CLIPPLANE4\");\n      }\n\n      if (this._scene.clipPlane5) {\n        defines.push(\"#define CLIPPLANE5\");\n      }\n\n      if (this._scene.clipPlane6) {\n        defines.push(\"#define CLIPPLANE6\");\n      }\n    }\n\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n\n    if (this.isLocal) {\n      defines.push(\"#define LOCAL\");\n    }\n\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this._colorGradientsTexture) {\n      defines.push(\"#define COLORGRADIENTS\");\n    }\n\n    if (this.isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n\n      defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n    }\n  };\n  /**\r\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n   * @param uniforms Uniforms array to fill\r\n   * @param attributes Attributes array to fill\r\n   * @param samplers Samplers array to fill\r\n   */\n\n\n  GPUParticleSystem.prototype.fillUniformsAttributesAndSamplerNames = function (uniforms, attributes, samplers) {\n    attributes.push(\"position\", \"age\", \"life\", \"size\", \"color\", \"offset\", \"uv\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\");\n    uniforms.push(\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"sheetInfos\", \"translationPivot\", \"eyePosition\");\n    samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  };\n  /** @hidden */\n\n\n  GPUParticleSystem.prototype._recreateRenderEffect = function () {\n    var customEffect = this.getCustomEffect();\n\n    if (customEffect) {\n      return customEffect;\n    }\n\n    var defines = [];\n    this.fillDefines(defines);\n    var join = defines.join(\"\\n\");\n\n    if (this._renderEffect && this._renderEffect.defines === join) {\n      return this._renderEffect;\n    }\n\n    var attributes = [];\n    var uniforms = [];\n    var samplers = [];\n    this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n    this._renderEffect = new Effect(\"gpuRenderParticles\", attributes, uniforms, samplers, this._engine, join);\n    return this._renderEffect;\n  };\n  /**\r\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n   * @param preWarm defines if we are in the pre-warmimg phase\r\n   */\n\n\n  GPUParticleSystem.prototype.animate = function (preWarm) {\n    var _a;\n\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    this._actualFrame += this._timeDelta;\n\n    if (!this._stopped) {\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    }\n  };\n\n  GPUParticleSystem.prototype._createFactorGradientTexture = function (factorGradients, textureName) {\n    var texture = this[textureName];\n\n    if (!factorGradients || !factorGradients.length || texture) {\n      return;\n    }\n\n    var data = new Float32Array(this._rawTextureWidth);\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, factorGradients, function (currentGradient, nextGradient, scale) {\n        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n      });\n    }\n\n    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n  };\n\n  GPUParticleSystem.prototype._createSizeGradientTexture = function () {\n    this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createAngularSpeedGradientTexture = function () {\n    this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createLimitVelocityGradientTexture = function () {\n    this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createDragGradientTexture = function () {\n    this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n  };\n\n  GPUParticleSystem.prototype._createColorGradientTexture = function () {\n    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n      return;\n    }\n\n    var data = new Uint8Array(this._rawTextureWidth * 4);\n    var tmpColor = TmpColors.Color4[0];\n\n    for (var x = 0; x < this._rawTextureWidth; x++) {\n      var ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, function (currentGradient, nextGradient, scale) {\n        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = tmpColor.a * 255;\n      });\n    }\n\n    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  };\n  /**\r\n   * Renders the particle system in its current state\r\n   * @param preWarm defines if the system should only update the particles but not render them\r\n   * @returns the current number of particles\r\n   */\n\n\n  GPUParticleSystem.prototype.render = function (preWarm) {\n    var _a, _b;\n\n    if (preWarm === void 0) {\n      preWarm = false;\n    }\n\n    if (!this._started) {\n      return 0;\n    }\n\n    this._createColorGradientTexture();\n\n    this._createSizeGradientTexture();\n\n    this._createAngularSpeedGradientTexture();\n\n    this._createVelocityGradientTexture();\n\n    this._createLimitVelocityGradientTexture();\n\n    this._createDragGradientTexture();\n\n    this._recreateUpdateEffect();\n\n    this._recreateRenderEffect();\n\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    if (!preWarm && this._scene) {\n      if (!this._preWarmDone && this.preWarmCycles) {\n        for (var index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n          this.render(true);\n        }\n\n        this._preWarmDone = true;\n      }\n\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return 0;\n      }\n\n      this._currentRenderId = this._scene.getFrameId();\n    } // Get everything ready to render\n\n\n    this._initialize();\n\n    this._accumulatedCount += this.emitRate * this._timeDelta;\n\n    if (this._accumulatedCount > 1) {\n      var intPart = this._accumulatedCount | 0;\n      this._accumulatedCount -= intPart;\n      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\n    }\n\n    if (!this._currentActiveCount) {\n      return 0;\n    } // Enable update effect\n\n\n    this._engine.enableEffect(this._updateEffect);\n\n    var engine = this._engine;\n\n    if (!engine.setState) {\n      throw new Error(\"GPU particles cannot work with a full Engine. ThinEngine is not supported\");\n    }\n\n    this._updateEffect.setFloat(\"currentCount\", this._currentActiveCount);\n\n    this._updateEffect.setFloat(\"timeDelta\", this._timeDelta);\n\n    this._updateEffect.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n\n    this._updateEffect.setTexture(\"randomSampler\", this._randomTexture);\n\n    this._updateEffect.setTexture(\"randomSampler2\", this._randomTexture2);\n\n    this._updateEffect.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n\n    this._updateEffect.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n\n    if (!this._colorGradientsTexture) {\n      this._updateEffect.setDirectColor4(\"color1\", this.color1);\n\n      this._updateEffect.setDirectColor4(\"color2\", this.color2);\n    }\n\n    this._updateEffect.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n\n    this._updateEffect.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n\n    this._updateEffect.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n\n    this._updateEffect.setVector3(\"gravity\", this.gravity);\n\n    if (this._sizeGradientsTexture) {\n      this._updateEffect.setTexture(\"sizeGradientSampler\", this._sizeGradientsTexture);\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._angularSpeedGradientsTexture);\n    }\n\n    if (this._velocityGradientsTexture) {\n      this._updateEffect.setTexture(\"velocityGradientSampler\", this._velocityGradientsTexture);\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._limitVelocityGradientsTexture);\n\n      this._updateEffect.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n    }\n\n    if (this._dragGradientsTexture) {\n      this._updateEffect.setTexture(\"dragGradientSampler\", this._dragGradientsTexture);\n    }\n\n    if (this.particleEmitterType) {\n      this.particleEmitterType.applyToShader(this._updateEffect);\n    }\n\n    if (this._isAnimationSheetEnabled) {\n      this._updateEffect.setFloat3(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed);\n    }\n\n    if (this.noiseTexture) {\n      this._updateEffect.setTexture(\"noiseSampler\", this.noiseTexture);\n\n      this._updateEffect.setVector3(\"noiseStrength\", this.noiseStrength);\n    }\n\n    var emitterWM;\n\n    if (this.emitter.position) {\n      var emitterMesh = this.emitter;\n      emitterWM = emitterMesh.getWorldMatrix();\n    } else {\n      var emitterPosition = this.emitter;\n      emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n\n    if (!this.isLocal) {\n      this._updateEffect.setMatrix(\"emitterWM\", emitterWM);\n    } // Bind source VAO\n\n\n    this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null); // Update\n\n\n    engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer());\n    engine.setRasterizerState(false);\n    engine.beginTransformFeedback(true);\n    engine.drawArraysType(3, 0, this._currentActiveCount);\n    engine.endTransformFeedback();\n    engine.setRasterizerState(true);\n    engine.bindTransformFeedbackBuffer(null);\n\n    if (!preWarm) {\n      // Enable render effect\n      var effect = this._getEffect();\n\n      this._engine.enableEffect(effect);\n\n      var viewMatrix = ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getViewMatrix()) || Matrix.IdentityReadOnly;\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n      effect.setTexture(\"diffuseSampler\", this.particleTexture);\n      effect.setVector2(\"translationPivot\", this.translationPivot);\n      effect.setVector3(\"worldOffset\", this.worldOffset);\n\n      if (this.isLocal) {\n        effect.setMatrix(\"emitterWM\", emitterWM);\n      }\n\n      if (this._colorGradientsTexture) {\n        effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n      } else {\n        effect.setDirectColor4(\"colorDead\", this.colorDead);\n      }\n\n      if (this._isAnimationSheetEnabled && this.particleTexture) {\n        var baseSize = this.particleTexture.getBaseSize();\n        effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n      }\n\n      if (this._isBillboardBased && this._scene) {\n        var camera = this._scene.activeCamera;\n        effect.setVector3(\"eyePosition\", camera.globalPosition);\n      }\n\n      var defines = effect.defines;\n\n      if (this._scene) {\n        if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\n          MaterialHelper.BindClipPlane(effect, this._scene);\n        }\n      }\n\n      if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n        var invView = viewMatrix.clone();\n        invView.invert();\n        effect.setMatrix(\"invView\", invView);\n      } // image processing\n\n\n      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n        this._imageProcessingConfiguration.bind(effect);\n      } // Draw order\n\n\n      switch (this.blendMode) {\n        case ParticleSystem.BLENDMODE_ADD:\n          this._engine.setAlphaMode(1);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_ONEONE:\n          this._engine.setAlphaMode(6);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_STANDARD:\n          this._engine.setAlphaMode(2);\n\n          break;\n\n        case ParticleSystem.BLENDMODE_MULTIPLY:\n          this._engine.setAlphaMode(4);\n\n          break;\n      }\n\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      } // Bind source VAO\n\n\n      this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null);\n\n      if (this._onBeforeDrawParticlesObservable) {\n        this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n      } // Render\n\n\n      this._engine.drawArraysType(8, 0, 4, this._currentActiveCount);\n\n      this._engine.setAlphaMode(0);\n    } // Switch VAOs\n\n\n    this._targetIndex++;\n\n    if (this._targetIndex === 2) {\n      this._targetIndex = 0;\n    } // Switch buffers\n\n\n    var tmpBuffer = this._sourceBuffer;\n    this._sourceBuffer = this._targetBuffer;\n    this._targetBuffer = tmpBuffer;\n    return this._currentActiveCount;\n  };\n  /**\r\n   * Rebuilds the particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.rebuild = function () {\n    this._initialize(true);\n  };\n\n  GPUParticleSystem.prototype._releaseBuffers = function () {\n    if (this._buffer0) {\n      this._buffer0.dispose();\n\n      this._buffer0 = null;\n    }\n\n    if (this._buffer1) {\n      this._buffer1.dispose();\n\n      this._buffer1 = null;\n    }\n\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n\n      this._spriteBuffer = null;\n    }\n  };\n\n  GPUParticleSystem.prototype._releaseVAOs = function () {\n    if (!this._updateVAO) {\n      return;\n    }\n\n    for (var index = 0; index < this._updateVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._updateVAO[index]);\n    }\n\n    this._updateVAO = [];\n\n    for (var index = 0; index < this._renderVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._renderVAO[index]);\n    }\n\n    this._renderVAO = [];\n  };\n  /**\r\n   * Disposes the particle system and free the associated resources\r\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n   */\n\n\n  GPUParticleSystem.prototype.dispose = function (disposeTexture) {\n    if (disposeTexture === void 0) {\n      disposeTexture = true;\n    }\n\n    if (this._scene) {\n      var index = this._scene.particleSystems.indexOf(this);\n\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n    }\n\n    this._releaseBuffers();\n\n    this._releaseVAOs();\n\n    if (this._colorGradientsTexture) {\n      this._colorGradientsTexture.dispose();\n\n      this._colorGradientsTexture = null;\n    }\n\n    if (this._sizeGradientsTexture) {\n      this._sizeGradientsTexture.dispose();\n\n      this._sizeGradientsTexture = null;\n    }\n\n    if (this._angularSpeedGradientsTexture) {\n      this._angularSpeedGradientsTexture.dispose();\n\n      this._angularSpeedGradientsTexture = null;\n    }\n\n    if (this._velocityGradientsTexture) {\n      this._velocityGradientsTexture.dispose();\n\n      this._velocityGradientsTexture = null;\n    }\n\n    if (this._limitVelocityGradientsTexture) {\n      this._limitVelocityGradientsTexture.dispose();\n\n      this._limitVelocityGradientsTexture = null;\n    }\n\n    if (this._dragGradientsTexture) {\n      this._dragGradientsTexture.dispose();\n\n      this._dragGradientsTexture = null;\n    }\n\n    if (this._randomTexture) {\n      this._randomTexture.dispose();\n\n      this._randomTexture = null;\n    }\n\n    if (this._randomTexture2) {\n      this._randomTexture2.dispose();\n\n      this._randomTexture2 = null;\n    }\n\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    } // Callback\n\n\n    this.onStoppedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\r\n   * Clones the particle system.\r\n   * @param name The name of the cloned object\r\n   * @param newEmitter The new emitter to use\r\n   * @returns the cloned particle system\r\n   */\n\n\n  GPUParticleSystem.prototype.clone = function (name, newEmitter) {\n    var serialization = this.serialize();\n    var result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\n\n    var custom = __assign({}, this._customEffect);\n\n    result.name = name;\n    result._customEffect = custom;\n\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n\n    result.emitter = newEmitter;\n    result.noiseTexture = this.noiseTexture;\n    return result;\n  };\n  /**\r\n   * Serializes the particle system to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  GPUParticleSystem.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n\n    serializationObject.activeParticleCount = this.activeParticleCount;\n    serializationObject.randomTextureSize = this._randomTextureSize;\n    return serializationObject;\n  };\n  /**\r\n   * Parses a JSON object to create a GPU particle system.\r\n   * @param parsedParticleSystem The JSON object to parse\r\n   * @param sceneOrEngine The scene or the engine to create the particle system in\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n   * @returns the parsed GPU particle system\r\n   */\n\n\n  GPUParticleSystem.Parse = function (parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart) {\n    if (doNotStart === void 0) {\n      doNotStart = false;\n    }\n\n    var name = parsedParticleSystem.name;\n    var particleSystem = new GPUParticleSystem(name, {\n      capacity: parsedParticleSystem.capacity,\n      randomTextureSize: parsedParticleSystem.randomTextureSize\n    }, sceneOrEngine);\n\n    if (parsedParticleSystem.activeParticleCount) {\n      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n    }\n\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl); // Auto start\n\n\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n\n    return particleSystem;\n  };\n\n  return GPUParticleSystem;\n}(BaseParticleSystem);\n\nexport { GPUParticleSystem };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/gpuParticleSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, float } from \"../types\";\r\nimport { FactorGradient, ColorGradient, Color3Gradient, IValueGradient, GradientHelper } from \"../Misc/gradients\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color4, Color3, TmpColors } from '../Maths/math.color';\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Buffer } from \"../Meshes/buffer\";\r\nimport { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter\";\r\nimport { IDisposable } from \"../scene\";\r\nimport { Effect, IEffectCreationOptions } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\n\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\nimport { CustomParticleEmitter } from './EmitterTypes/customParticleEmitter';\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\nimport \"../Shaders/gpuUpdateParticles.fragment\";\r\nimport \"../Shaders/gpuUpdateParticles.vertex\";\r\nimport \"../Shaders/gpuRenderParticles.fragment\";\r\nimport \"../Shaders/gpuRenderParticles.vertex\";\r\n\r\n/**\r\n * This represents a GPU particle system in Babylon\r\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\r\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\r\n */\r\nexport class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {\r\n    /**\r\n     * The layer mask we are rendering the particles through.\r\n     */\r\n    public layerMask: number = 0x0FFFFFFF;\r\n\r\n    private _capacity: number;\r\n    private _activeCount: number;\r\n    private _currentActiveCount: number;\r\n    private _accumulatedCount = 0;\r\n    private _renderEffect: Effect;\r\n    private _updateEffect: Effect;\r\n\r\n    private _buffer0: Buffer;\r\n    private _buffer1: Buffer;\r\n    private _spriteBuffer: Buffer;\r\n    private _updateVAO: Array<WebGLVertexArrayObject>;\r\n    private _renderVAO: Array<WebGLVertexArrayObject>;\r\n\r\n    private _targetIndex = 0;\r\n    private _sourceBuffer: Buffer;\r\n    private _targetBuffer: Buffer;\r\n\r\n    private _currentRenderId = -1;\r\n    private _started = false;\r\n    private _stopped = false;\r\n\r\n    private _timeDelta = 0;\r\n\r\n    private _randomTexture: RawTexture;\r\n    private _randomTexture2: RawTexture;\r\n\r\n    private _attributesStrideSize: number;\r\n    private _updateEffectOptions: IEffectCreationOptions;\r\n\r\n    private _randomTextureSize: number;\r\n    private _actualFrame = 0;\r\n    private _customEffect: { [blendMode: number] : Nullable<Effect> };\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the GPU particles can be rendered on current browser\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        if (!EngineStore.LastCreatedEngine) {\r\n            return false;\r\n        }\r\n        return EngineStore.LastCreatedEngine.webGLVersion > 1;\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the system is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n    * An event triggered when the system is stopped\r\n    */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\r\n     * to override the particles.\r\n     */\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Gets or set the number of active particles\r\n     */\r\n    public get activeParticleCount(): number {\r\n        return this._activeCount;\r\n    }\r\n\r\n    public set activeParticleCount(value: number) {\r\n        this._activeCount = Math.min(value, this._capacity);\r\n    }\r\n\r\n    private _preWarmDone = false;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space.\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @return true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this._updateEffect) {\r\n            this._recreateUpdateEffect();\r\n            this._recreateRenderEffect();\r\n            return false;\r\n        }\r\n\r\n        if (!this.emitter || !this._updateEffect.isReady() || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this._getEffect().isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\r\n     * @returns True if it has been stopped, otherwise false.\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return false; // Stop is immediate on GPU\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._preWarmDone = false;\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     */\r\n    public stop(): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n        this._stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._releaseBuffers();\r\n        this._releaseVAOs();\r\n        this._currentActiveCount = 0;\r\n        this._targetIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"GPUParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"GPUParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customEffect[blendMode] ?? this._customEffect[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customEffect[blendMode] = effect;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"gpuRenderParticles\";\r\n    }\r\n\r\n    private _colorGradientsTexture: RawTexture;\r\n\r\n    protected _removeGradientAndTexture(gradient: number, gradients: Nullable<IValueGradient[]>, texture: RawTexture): BaseParticleSystem {\r\n        super._removeGradientAndTexture(gradient, gradients, texture);\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns the current particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): GPUParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        let colorGradient = new ColorGradient(gradient, color1);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._refreshColorGradient(true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshColorGradient(reorder = false) {\r\n        if (this._colorGradients) {\r\n            if (reorder) {\r\n                this._colorGradients.sort((a, b) => {\r\n                    if (a.gradient < b.gradient) {\r\n                        return -1;\r\n                    } else if (a.gradient > b.gradient) {\r\n                        return 1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n            }\r\n\r\n            if (this._colorGradientsTexture) {\r\n                this._colorGradientsTexture.dispose();\r\n                (<any>this._colorGradientsTexture) = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._refreshColorGradient();\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\r\n\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\r\n        (<any>this._colorGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _angularSpeedGradientsTexture: RawTexture;\r\n    private _sizeGradientsTexture: RawTexture;\r\n    private _velocityGradientsTexture: RawTexture;\r\n    private _limitVelocityGradientsTexture: RawTexture;\r\n    private _dragGradientsTexture: RawTexture;\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number) {\r\n        let valueGradient = new FactorGradient(gradient, factor);\r\n        factorGradients.push(valueGradient);\r\n\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor);\r\n\r\n        this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\r\n        (<any>this._sizeGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _refreshFactorGradient(factorGradients: Nullable<FactorGradient[]>, textureName: string, reorder = false) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        if (reorder) {\r\n            factorGradients.sort((a, b) => {\r\n                if (a.gradient < b.gradient) {\r\n                    return -1;\r\n                } else if (a.gradient > b.gradient) {\r\n                    return 1;\r\n                }\r\n\r\n                return 0;\r\n            });\r\n        }\r\n\r\n        let that = this as any;\r\n        if (that[textureName]) {\r\n            that[textureName].dispose();\r\n            that[textureName] = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\r\n        (<any>this._angularSpeedGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\r\n        (<any>this._velocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\r\n        (<any>this._limitVelocityGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number): GPUParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor);\r\n        this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\r\n\r\n        this._releaseBuffers();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): GPUParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\r\n        (<any>this._dragGradientsTexture) = null;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\r\n        // Do nothing as emit rate is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(): IParticleSystem {\r\n        // Do nothing as start size is not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(gradient: number, color: Color3): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/babylon101/particles#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        //Not supported by GPUParticleSystem\r\n        return false;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        //Not supported by GPUParticleSystem\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Not supported by GPUParticleSystem\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\r\n        //Not supported by GPUParticleSystem\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a GPU particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param options The options used to create the system\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     */\r\n    constructor(name: string, options: Partial<{\r\n        capacity: number,\r\n        randomTextureSize: number\r\n    }>, sceneOrEngine: Scene | ThinEngine, isAnimationSheetEnabled: boolean = false, customEffect: Nullable<Effect> = null) {\r\n        super(name);\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = (sceneOrEngine as ThinEngine);\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100);\r\n        }\r\n\r\n        this._customEffect = { 0: customEffect };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        if (!options.randomTextureSize) {\r\n            delete options.randomTextureSize;\r\n        }\r\n\r\n        let fullOptions = {\r\n            capacity: 50000,\r\n            randomTextureSize: this._engine.getCaps().maxTextureSize,\r\n            ...options\r\n        };\r\n\r\n        var optionsAsNumber = <number>options;\r\n        if (isFinite(optionsAsNumber)) {\r\n            fullOptions.capacity = optionsAsNumber;\r\n        }\r\n\r\n        this._capacity = fullOptions.capacity;\r\n        this._activeCount = fullOptions.capacity;\r\n        this._currentActiveCount = 0;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        this._updateEffectOptions = {\r\n            attributes: [\"position\", \"initialPosition\", \"age\", \"life\", \"seed\", \"size\", \"color\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\", \"cellStartOffset\", \"noiseCoordinates1\", \"noiseCoordinates2\"],\r\n            uniformsNames: [\"currentCount\", \"timeDelta\", \"emitterWM\", \"lifeTime\", \"color1\", \"color2\", \"sizeRange\", \"scaleRange\", \"gravity\", \"emitPower\",\r\n                \"direction1\", \"direction2\", \"minEmitBox\", \"maxEmitBox\", \"radius\", \"directionRandomizer\", \"height\", \"coneAngle\", \"stopFactor\",\r\n                \"angleRange\", \"radiusRange\", \"cellInfos\", \"noiseStrength\", \"limitVelocityDamping\"],\r\n            uniformBuffersNames: [],\r\n            samplers: [\"randomSampler\", \"randomSampler2\", \"sizeGradientSampler\", \"angularSpeedGradientSampler\", \"velocityGradientSampler\", \"limitVelocityGradientSampler\", \"noiseSampler\", \"dragGradientSampler\"],\r\n            defines: \"\",\r\n            fallbacks: null,\r\n            onCompiled: null,\r\n            onError: null,\r\n            indexParameters: null,\r\n            maxSimultaneousLights: 0,\r\n            transformFeedbackVaryings: []\r\n        };\r\n\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n\r\n        // Random data\r\n        var maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\r\n        var d = [];\r\n        for (var i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\r\n        this._randomTexture.wrapU = 1;\r\n        this._randomTexture.wrapV = 1;\r\n\r\n        d = [];\r\n        for (var i = 0; i < maxTextureSize; ++i) {\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n            d.push(Math.random());\r\n        }\r\n        this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\r\n        this._randomTexture2.wrapU = 1;\r\n        this._randomTexture2.wrapV = 1;\r\n\r\n        this._randomTextureSize = maxTextureSize;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._releaseBuffers();\r\n    }\r\n\r\n    private _createUpdateVAO(source: Buffer): WebGLVertexArrayObject {\r\n        let updateVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        updateVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3);\r\n\r\n        let offset = 3;\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            updateVertexBuffers[\"initialPosition\"] = source.createVertexBuffer(\"initialPosition\", offset, 3);\r\n            offset += 3;\r\n        }\r\n        updateVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1);\r\n        offset += 1;\r\n        updateVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1);\r\n        offset += 1;\r\n        updateVertexBuffers[\"seed\"] = source.createVertexBuffer(\"seed\", offset, 4);\r\n        offset += 4;\r\n        updateVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3);\r\n        offset += 3;\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            updateVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4);\r\n            offset += 4;\r\n        }\r\n\r\n        updateVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3);\r\n        offset += 3;\r\n\r\n        if (!this._isBillboardBased) {\r\n            updateVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3);\r\n            offset += 3;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1);\r\n            offset += 1;\r\n        } else {\r\n            updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 2);\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            updateVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                updateVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            updateVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3);\r\n            offset += 3;\r\n            updateVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3);\r\n            offset += 3;\r\n        }\r\n\r\n        let vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);\r\n        this._engine.bindArrayBuffer(null);\r\n\r\n        return vao;\r\n    }\r\n\r\n    private _createRenderVAO(source: Buffer, spriteSource: Buffer): WebGLVertexArrayObject {\r\n        let renderVertexBuffers: { [key: string]: VertexBuffer } = {};\r\n        renderVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\r\n        let offset = 3;\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            offset += 3;\r\n        }\r\n        renderVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 1;\r\n        renderVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\r\n        offset += 5;\r\n        renderVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\r\n        offset += 3;\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            renderVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\r\n            offset += 4;\r\n        }\r\n\r\n        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\r\n            renderVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\r\n        }\r\n        offset += 3; // Direction\r\n\r\n        if (!this._isBillboardBased) {\r\n            renderVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n        }\r\n\r\n        renderVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\r\n        if (this._angularSpeedGradientsTexture) {\r\n            offset++;\r\n        } else {\r\n            offset += 2;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            renderVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\r\n            offset += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                renderVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\r\n                offset += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            renderVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n            renderVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\r\n            offset += 3;\r\n        }\r\n\r\n        renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\r\n        renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\r\n\r\n        let vao = this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._getEffect());\r\n        this._engine.bindArrayBuffer(null);\r\n\r\n        return vao;\r\n    }\r\n\r\n    private _initialize(force = false): void {\r\n        if (this._buffer0 && !force) {\r\n            return;\r\n        }\r\n\r\n        let engine = this._engine;\r\n        var data = new Array<float>();\r\n\r\n        this._attributesStrideSize = 21;\r\n        this._targetIndex = 0;\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._attributesStrideSize += 3;\r\n        }\r\n\r\n        if (!this.isBillboardBased) {\r\n            this._attributesStrideSize += 3;\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._attributesStrideSize -= 4;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._attributesStrideSize -= 1;\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._attributesStrideSize += 1;\r\n            if (this.spriteRandomStartCell) {\r\n                this._attributesStrideSize += 1;\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._attributesStrideSize += 6;\r\n        }\r\n\r\n        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\r\n            // position\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particlePositionGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            }\r\n\r\n            // Age and life\r\n            data.push(0.0); // create the particle as a dead one to create a new one at start\r\n            data.push(0.0);\r\n\r\n            // Seed\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n            data.push(Math.random());\r\n\r\n            // Size\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n            data.push(0.0);\r\n\r\n            if (!this._colorGradientsTexture) {\r\n                // color\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            // direction\r\n            if (usingCustomEmitter) {\r\n                (this.particleEmitterType as CustomParticleEmitter).particleDestinationGenerator(particleIndex, null, tmpVector);\r\n                data.push(tmpVector.x);\r\n                data.push(tmpVector.y);\r\n                data.push(tmpVector.z);\r\n            } else {\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (!this.isBillboardBased) {\r\n                // initialDirection\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n                data.push(0.0);\r\n            }\r\n\r\n            // angle\r\n            data.push(0.0);\r\n\r\n            if (!this._angularSpeedGradientsTexture) {\r\n                data.push(0.0);\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled) {\r\n                data.push(0.0);\r\n                if (this.spriteRandomStartCell) {\r\n                    data.push(0.0);\r\n                }\r\n            }\r\n\r\n            if (this.noiseTexture) { // Random coordinates for reading into noise texture\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n                data.push(Math.random());\r\n            }\r\n        }\r\n\r\n        // Sprite data\r\n        var spriteData = new Float32Array([0.5, 0.5, 1, 1,\r\n            -0.5, 0.5, 0, 1,\r\n            -0.5, -0.5, 0, 0,\r\n            0.5, -0.5, 1, 0]);\r\n\r\n        // Buffers\r\n        this._buffer0 = new Buffer(engine, data, false, this._attributesStrideSize);\r\n        this._buffer1 = new Buffer(engine, data, false, this._attributesStrideSize);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\r\n\r\n        // Update VAO\r\n        this._updateVAO = [];\r\n        this._updateVAO.push(this._createUpdateVAO(this._buffer0));\r\n        this._updateVAO.push(this._createUpdateVAO(this._buffer1));\r\n\r\n        // Render VAO\r\n        this._renderVAO = [];\r\n        this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer));\r\n        this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer));\r\n\r\n        // Links\r\n        this._sourceBuffer = this._buffer0;\r\n        this._targetBuffer = this._buffer1;\r\n\r\n    }\r\n\r\n    /** @hidden */\r\n    public _recreateUpdateEffect() {\r\n        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\r\n\r\n        if (this._isBillboardBased) {\r\n            defines += \"\\n#define BILLBOARD\";\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines += \"\\n#define COLORGRADIENTS\";\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            defines += \"\\n#define SIZEGRADIENTS\";\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            defines += \"\\n#define VELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            defines += \"\\n#define DRAGGRADIENTS\";\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines += \"\\n#define ANIMATESHEET\";\r\n            if (this.spriteRandomStartCell) {\r\n                defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            defines += \"\\n#define NOISE\";\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines += \"\\n#define LOCAL\";\r\n        }\r\n\r\n        if (this._updateEffect && this._updateEffectOptions.defines === defines) {\r\n            return;\r\n        }\r\n\r\n        this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\"];\r\n\r\n        if (this.particleEmitterType instanceof CustomParticleEmitter) {\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialPosition\");\r\n        }\r\n\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outAge\");\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outLife\");\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outSeed\");\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outSize\");\r\n\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\");\r\n        }\r\n\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\");\r\n\r\n        if (!this._isBillboardBased) {\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\");\r\n        }\r\n\r\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\");\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\");\r\n            if (this.spriteRandomStartCell) {\r\n                this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\");\r\n            }\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\");\r\n            this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\");\r\n        }\r\n\r\n        this._updateEffectOptions.defines = defines;\r\n        this._updateEffect = new Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._engine);\r\n    }\r\n\r\n    private _getEffect(): Effect {\r\n        return this.getCustomEffect() ?? this._renderEffect;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number = 0) {\r\n        if (this._scene) {\r\n            if (this._scene.clipPlane) {\r\n                defines.push(\"#define CLIPPLANE\");\r\n            }\r\n            if (this._scene.clipPlane2) {\r\n                defines.push(\"#define CLIPPLANE2\");\r\n            }\r\n            if (this._scene.clipPlane3) {\r\n                defines.push(\"#define CLIPPLANE3\");\r\n            }\r\n            if (this._scene.clipPlane4) {\r\n                defines.push(\"#define CLIPPLANE4\");\r\n            }\r\n            if (this._scene.clipPlane5) {\r\n                defines.push(\"#define CLIPPLANE5\");\r\n            }\r\n            if (this._scene.clipPlane6) {\r\n                defines.push(\"#define CLIPPLANE6\");\r\n            }\r\n        }\r\n\r\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this.isLocal) {\r\n            defines.push(\"#define LOCAL\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._colorGradientsTexture) {\r\n            defines.push(\"#define COLORGRADIENTS\");\r\n        }\r\n\r\n        if (this.isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\"position\", \"age\", \"life\", \"size\", \"color\", \"offset\", \"uv\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\");\r\n\r\n        uniforms.push(\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"sheetInfos\", \"translationPivot\", \"eyePosition\");\r\n\r\n        samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _recreateRenderEffect(): Effect {\r\n        const customEffect = this.getCustomEffect();\r\n\r\n        if (customEffect) {\r\n            return customEffect;\r\n        }\r\n\r\n        let defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines);\r\n\r\n        var join = defines.join(\"\\n\");\r\n\r\n        if (this._renderEffect && this._renderEffect.defines === join) {\r\n            return this._renderEffect;\r\n        }\r\n\r\n        var attributes: Array<string> = [];\r\n        var uniforms: Array<string> = [];\r\n        var samplers: Array<string> = [];\r\n\r\n        this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\r\n\r\n        this._renderEffect = new Effect(\"gpuRenderParticles\",\r\n            attributes,\r\n            uniforms,\r\n            samplers, this._engine, join);\r\n\r\n        return this._renderEffect;\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarm defines if we are in the pre-warmimg phase\r\n     */\r\n    public animate(preWarm = false): void {\r\n        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n        this._actualFrame += this._timeDelta;\r\n\r\n        if (!this._stopped) {\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createFactorGradientTexture(factorGradients: Nullable<IValueGradient[]>, textureName: string) {\r\n        let texture: RawTexture = (<any>this)[textureName];\r\n\r\n        if (!factorGradients || !factorGradients.length || texture) {\r\n            return;\r\n        }\r\n\r\n        let data = new Float32Array(this._rawTextureWidth);\r\n\r\n        for (var x = 0; x < this._rawTextureWidth; x++) {\r\n            var ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\r\n                data[x] = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n            });\r\n        }\r\n\r\n        (<any>this)[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\r\n    }\r\n\r\n    private _createSizeGradientTexture() {\r\n        this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\r\n    }\r\n\r\n    private _createAngularSpeedGradientTexture() {\r\n        this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\r\n    }\r\n\r\n    private _createVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\r\n    }\r\n\r\n    private _createLimitVelocityGradientTexture() {\r\n        this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\r\n    }\r\n\r\n    private _createDragGradientTexture() {\r\n        this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\r\n    }\r\n\r\n    private _createColorGradientTexture() {\r\n        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\r\n            return;\r\n        }\r\n\r\n        let data = new Uint8Array(this._rawTextureWidth * 4);\r\n        let tmpColor = TmpColors.Color4[0];\r\n\r\n        for (var x = 0; x < this._rawTextureWidth; x++) {\r\n            var ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n\r\n                Color4.LerpToRef((<ColorGradient>currentGradient).color1, (<ColorGradient>nextGradient).color1, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = tmpColor.a * 255;\r\n            });\r\n\r\n        }\r\n\r\n        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state\r\n     * @param preWarm defines if the system should only update the particles but not render them\r\n     * @returns the current number of particles\r\n     */\r\n    public render(preWarm = false): number {\r\n        if (!this._started) {\r\n            return 0;\r\n        }\r\n\r\n        this._createColorGradientTexture();\r\n        this._createSizeGradientTexture();\r\n        this._createAngularSpeedGradientTexture();\r\n        this._createVelocityGradientTexture();\r\n        this._createLimitVelocityGradientTexture();\r\n        this._createDragGradientTexture();\r\n\r\n        this._recreateUpdateEffect();\r\n        this._recreateRenderEffect();\r\n\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        if (!preWarm && this._scene) {\r\n            if (!this._preWarmDone && this.preWarmCycles) {\r\n                for (var index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                    this.render(true);\r\n                }\r\n\r\n                this._preWarmDone = true;\r\n            }\r\n\r\n            if (this._currentRenderId === this._scene.getFrameId()) {\r\n                return 0;\r\n            }\r\n\r\n            this._currentRenderId = this._scene.getFrameId();\r\n        }\r\n\r\n        // Get everything ready to render\r\n        this._initialize();\r\n\r\n        this._accumulatedCount += this.emitRate * this._timeDelta;\r\n        if (this._accumulatedCount > 1) {\r\n            var intPart = this._accumulatedCount | 0;\r\n            this._accumulatedCount -= intPart;\r\n            this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);\r\n        }\r\n\r\n        if (!this._currentActiveCount) {\r\n            return 0;\r\n        }\r\n\r\n        // Enable update effect\r\n        this._engine.enableEffect(this._updateEffect);\r\n        var engine = this._engine as Engine;\r\n        if (!engine.setState) {\r\n            throw new Error(\"GPU particles cannot work with a full Engine. ThinEngine is not supported\");\r\n        }\r\n\r\n        this._updateEffect.setFloat(\"currentCount\", this._currentActiveCount);\r\n        this._updateEffect.setFloat(\"timeDelta\", this._timeDelta);\r\n        this._updateEffect.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\r\n        this._updateEffect.setTexture(\"randomSampler\", this._randomTexture);\r\n        this._updateEffect.setTexture(\"randomSampler2\", this._randomTexture2);\r\n        this._updateEffect.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\r\n        this._updateEffect.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\r\n        if (!this._colorGradientsTexture) {\r\n            this._updateEffect.setDirectColor4(\"color1\", this.color1);\r\n            this._updateEffect.setDirectColor4(\"color2\", this.color2);\r\n        }\r\n        this._updateEffect.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\r\n        this._updateEffect.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\r\n        this._updateEffect.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\r\n        this._updateEffect.setVector3(\"gravity\", this.gravity);\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._updateEffect.setTexture(\"sizeGradientSampler\", this._sizeGradientsTexture);\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._angularSpeedGradientsTexture);\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._updateEffect.setTexture(\"velocityGradientSampler\", this._velocityGradientsTexture);\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._limitVelocityGradientsTexture);\r\n            this._updateEffect.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._updateEffect.setTexture(\"dragGradientSampler\", this._dragGradientsTexture);\r\n        }\r\n\r\n        if (this.particleEmitterType) {\r\n            this.particleEmitterType.applyToShader(this._updateEffect);\r\n        }\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._updateEffect.setFloat3(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed);\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            this._updateEffect.setTexture(\"noiseSampler\", this.noiseTexture);\r\n            this._updateEffect.setVector3(\"noiseStrength\", this.noiseStrength);\r\n        }\r\n\r\n        let emitterWM: Matrix;\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            var emitterMesh = (<AbstractMesh>this.emitter);\r\n            emitterWM = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            var emitterPosition = (<Vector3>this.emitter);\r\n            emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        if (!this.isLocal) {\r\n            this._updateEffect.setMatrix(\"emitterWM\", emitterWM);\r\n        }\r\n\r\n        // Bind source VAO\r\n        this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null);\r\n\r\n        // Update\r\n        engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer());\r\n        engine.setRasterizerState(false);\r\n        engine.beginTransformFeedback(true);\r\n        engine.drawArraysType(3, 0, this._currentActiveCount);\r\n        engine.endTransformFeedback();\r\n        engine.setRasterizerState(true);\r\n        engine.bindTransformFeedbackBuffer(null);\r\n\r\n        if (!preWarm) {\r\n            // Enable render effect\r\n            const effect = this._getEffect();\r\n\r\n            this._engine.enableEffect(effect);\r\n            let viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n            effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n            effect.setVector2(\"translationPivot\", this.translationPivot);\r\n            effect.setVector3(\"worldOffset\", this.worldOffset);\r\n            if (this.isLocal) {\r\n                effect.setMatrix(\"emitterWM\", emitterWM);\r\n            }\r\n            if (this._colorGradientsTexture) {\r\n                effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\r\n            } else {\r\n                effect.setDirectColor4(\"colorDead\", this.colorDead);\r\n            }\r\n\r\n            if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n                let baseSize = this.particleTexture.getBaseSize();\r\n                effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\r\n            }\r\n\r\n            if (this._isBillboardBased && this._scene) {\r\n                var camera = this._scene.activeCamera!;\r\n                effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n            }\r\n\r\n            const defines = effect.defines;\r\n\r\n            if (this._scene) {\r\n                if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {\r\n                    MaterialHelper.BindClipPlane(effect, this._scene);\r\n                }\r\n            }\r\n\r\n            if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n                var invView = viewMatrix.clone();\r\n                invView.invert();\r\n                effect.setMatrix(\"invView\", invView);\r\n            }\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(effect);\r\n            }\r\n\r\n            // Draw order\r\n            switch (this.blendMode) {\r\n                case ParticleSystem.BLENDMODE_ADD:\r\n                    this._engine.setAlphaMode(1);\r\n                    break;\r\n                case ParticleSystem.BLENDMODE_ONEONE:\r\n                    this._engine.setAlphaMode(6);\r\n                    break;\r\n                case ParticleSystem.BLENDMODE_STANDARD:\r\n                    this._engine.setAlphaMode(2);\r\n                    break;\r\n                case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                    this._engine.setAlphaMode(4);\r\n                    break;\r\n            }\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n\r\n            // Bind source VAO\r\n            this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null);\r\n\r\n            if (this._onBeforeDrawParticlesObservable) {\r\n                this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n            }\r\n\r\n            // Render\r\n            this._engine.drawArraysType(8, 0, 4, this._currentActiveCount);\r\n            this._engine.setAlphaMode(0);\r\n        }\r\n        // Switch VAOs\r\n        this._targetIndex++;\r\n        if (this._targetIndex === 2) {\r\n            this._targetIndex = 0;\r\n        }\r\n\r\n        // Switch buffers\r\n        let tmpBuffer = this._sourceBuffer;\r\n        this._sourceBuffer = this._targetBuffer;\r\n        this._targetBuffer = tmpBuffer;\r\n\r\n        return this._currentActiveCount;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system\r\n     */\r\n    public rebuild(): void {\r\n        this._initialize(true);\r\n    }\r\n\r\n    private _releaseBuffers() {\r\n        if (this._buffer0) {\r\n            this._buffer0.dispose();\r\n            (<any>this._buffer0) = null;\r\n        }\r\n        if (this._buffer1) {\r\n            this._buffer1.dispose();\r\n            (<any>this._buffer1) = null;\r\n        }\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            (<any>this._spriteBuffer) = null;\r\n        }\r\n    }\r\n\r\n    private _releaseVAOs() {\r\n        if (!this._updateVAO) {\r\n            return;\r\n        }\r\n\r\n        for (var index = 0; index < this._updateVAO.length; index++) {\r\n            this._engine.releaseVertexArrayObject(this._updateVAO[index]);\r\n        }\r\n        this._updateVAO = [];\r\n\r\n        for (var index = 0; index < this._renderVAO.length; index++) {\r\n            this._engine.releaseVertexArrayObject(this._renderVAO[index]);\r\n        }\r\n        this._renderVAO = [];\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        if (this._scene) {\r\n            var index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._releaseBuffers();\r\n        this._releaseVAOs();\r\n\r\n        if (this._colorGradientsTexture) {\r\n            this._colorGradientsTexture.dispose();\r\n            (<any>this._colorGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._sizeGradientsTexture) {\r\n            this._sizeGradientsTexture.dispose();\r\n            (<any>this._sizeGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._angularSpeedGradientsTexture) {\r\n            this._angularSpeedGradientsTexture.dispose();\r\n            (<any>this._angularSpeedGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._velocityGradientsTexture) {\r\n            this._velocityGradientsTexture.dispose();\r\n            (<any>this._velocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._limitVelocityGradientsTexture) {\r\n            this._limitVelocityGradientsTexture.dispose();\r\n            (<any>this._limitVelocityGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._dragGradientsTexture) {\r\n            this._dragGradientsTexture.dispose();\r\n            (<any>this._dragGradientsTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture) {\r\n            this._randomTexture.dispose();\r\n            (<any>this._randomTexture) = null;\r\n        }\r\n\r\n        if (this._randomTexture2) {\r\n            this._randomTexture2.dispose();\r\n            (<any>this._randomTexture2) = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onStoppedObservable.clear();\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any): GPUParticleSystem {\r\n        let serialization = this.serialize();\r\n        var result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, \"\");\r\n        var custom = { ...this._customEffect };\r\n        result.name = name;\r\n        result._customEffect = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n\r\n        result.noiseTexture = this.noiseTexture;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        var serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n        serializationObject.activeParticleCount = this.activeParticleCount;\r\n        serializationObject.randomTextureSize = this._randomTextureSize;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a GPU particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @returns the parsed GPU particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false): GPUParticleSystem {\r\n        var name = parsedParticleSystem.name;\r\n        var particleSystem = new GPUParticleSystem(name, { capacity: parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine);\r\n\r\n        if (parsedParticleSystem.activeParticleCount) {\r\n            particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\r\n        }\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}