{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine\";\nimport { WebGLDataBuffer } from '../../Meshes/WebGL/webGLDataBuffer';\n\nThinEngine.prototype.createUniformBuffer = function (elements) {\n  var ubo = this._gl.createBuffer();\n\n  if (!ubo) {\n    throw new Error(\"Unable to create uniform buffer\");\n  }\n\n  var result = new WebGLDataBuffer(ubo);\n  this.bindUniformBuffer(result);\n\n  if (elements instanceof Float32Array) {\n    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);\n  } else {\n    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);\n  }\n\n  this.bindUniformBuffer(null);\n  result.references = 1;\n  return result;\n};\n\nThinEngine.prototype.createDynamicUniformBuffer = function (elements) {\n  var ubo = this._gl.createBuffer();\n\n  if (!ubo) {\n    throw new Error(\"Unable to create dynamic uniform buffer\");\n  }\n\n  var result = new WebGLDataBuffer(ubo);\n  this.bindUniformBuffer(result);\n\n  if (elements instanceof Float32Array) {\n    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);\n  } else {\n    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);\n  }\n\n  this.bindUniformBuffer(null);\n  result.references = 1;\n  return result;\n};\n\nThinEngine.prototype.updateUniformBuffer = function (uniformBuffer, elements, offset, count) {\n  this.bindUniformBuffer(uniformBuffer);\n\n  if (offset === undefined) {\n    offset = 0;\n  }\n\n  if (count === undefined) {\n    if (elements instanceof Float32Array) {\n      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);\n    } else {\n      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));\n    }\n  } else {\n    if (elements instanceof Float32Array) {\n      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));\n    } else {\n      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));\n    }\n  }\n\n  this.bindUniformBuffer(null);\n};\n\nThinEngine.prototype.bindUniformBuffer = function (buffer) {\n  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);\n};\n\nThinEngine.prototype.bindUniformBufferBase = function (buffer, location) {\n  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer ? buffer.underlyingResource : null);\n};\n\nThinEngine.prototype.bindUniformBlock = function (pipelineContext, blockName, index) {\n  var program = pipelineContext.program;\n\n  var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\n\n  this._gl.uniformBlockBinding(program, uniformLocation, index);\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Extensions/engine.uniformBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { FloatArray, Nullable } from '../../types';\r\nimport { DataBuffer } from '../../Meshes/dataBuffer';\r\nimport { WebGLDataBuffer } from '../../Meshes/WebGL/webGLDataBuffer';\r\nimport { IPipelineContext } from '../IPipelineContext';\r\nimport { WebGLPipelineContext } from '../WebGL/webGLPipelineContext';\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Create an uniform buffer\r\n         * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createUniformBuffer(elements: FloatArray): DataBuffer;\r\n\r\n        /**\r\n         * Create a dynamic uniform buffer\r\n         * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets\r\n         * @param elements defines the content of the uniform buffer\r\n         * @returns the webGL uniform buffer\r\n         */\r\n        createDynamicUniformBuffer(elements: FloatArray): DataBuffer;\r\n\r\n        /**\r\n         * Update an existing uniform buffer\r\n         * @see https://doc.babylonjs.com/features/webgl2#uniform-buffer-objets\r\n         * @param uniformBuffer defines the target uniform buffer\r\n         * @param elements defines the content to update\r\n         * @param offset defines the offset in the uniform buffer where update should start\r\n         * @param count defines the size of the data to update\r\n         */\r\n        updateUniformBuffer(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void;\r\n\r\n        /**\r\n         * Bind an uniform buffer to the current webGL context\r\n         * @param buffer defines the buffer to bind\r\n         */\r\n        bindUniformBuffer(buffer: Nullable<DataBuffer>): void;\r\n\r\n        /**\r\n         * Bind a buffer to the current webGL context at a given location\r\n         * @param buffer defines the buffer to bind\r\n         * @param location defines the index where to bind the buffer\r\n         */\r\n        bindUniformBufferBase(buffer: DataBuffer, location: number): void;\r\n\r\n         /**\r\n          * Bind a specific block at a given index in a specific shader program\r\n          * @param pipelineContext defines the pipeline context to use\r\n          * @param blockName defines the block name\r\n          * @param index defines the index where to bind the block\r\n          */\r\n        bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createUniformBuffer = function(elements: FloatArray): DataBuffer {\r\n    var ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create uniform buffer\");\r\n    }\r\n    let result = new WebGLDataBuffer(ubo);\r\n\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.STATIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.STATIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.createDynamicUniformBuffer = function(elements: FloatArray): DataBuffer {\r\n    var ubo = this._gl.createBuffer();\r\n\r\n    if (!ubo) {\r\n        throw new Error(\"Unable to create dynamic uniform buffer\");\r\n    }\r\n\r\n    let result = new WebGLDataBuffer(ubo);\r\n    this.bindUniformBuffer(result);\r\n\r\n    if (elements instanceof Float32Array) {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, <Float32Array>elements, this._gl.DYNAMIC_DRAW);\r\n    } else {\r\n        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(<number[]>elements), this._gl.DYNAMIC_DRAW);\r\n    }\r\n\r\n    this.bindUniformBuffer(null);\r\n\r\n    result.references = 1;\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.updateUniformBuffer = function(uniformBuffer: DataBuffer, elements: FloatArray, offset?: number, count?: number): void {\r\n   this.bindUniformBuffer(uniformBuffer);\r\n\r\n   if (offset === undefined) {\r\n       offset = 0;\r\n   }\r\n\r\n   if (count === undefined) {\r\n       if (elements instanceof Float32Array) {\r\n           this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, <Float32Array>elements);\r\n       } else {\r\n           this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(<number[]>elements));\r\n       }\r\n   } else {\r\n       if (elements instanceof Float32Array) {\r\n           this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, <Float32Array>elements.subarray(offset, offset + count));\r\n       } else {\r\n           this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(<number[]>elements).subarray(offset, offset + count));\r\n       }\r\n   }\r\n\r\n   this.bindUniformBuffer(null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBuffer = function(buffer: Nullable<DataBuffer>): void {\r\n    this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBufferBase = function(buffer: DataBuffer, location: number): void {\r\n    this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer ? buffer.underlyingResource : null);\r\n};\r\n\r\nThinEngine.prototype.bindUniformBlock = function(pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n    let program = (pipelineContext as WebGLPipelineContext).program!;\r\n\r\n    var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);\r\n\r\n    this._gl.uniformBlockBinding(program, uniformLocation, index);\r\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}