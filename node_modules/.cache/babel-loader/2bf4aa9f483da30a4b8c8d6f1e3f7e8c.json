{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Observable } from \"../Misc/observable\";\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\nimport { Camera } from \"./camera\";\nimport { TargetCamera } from \"./targetCamera\";\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\nimport { Epsilon } from \"../Maths/math.constants\";\nimport { Tools } from \"../Misc/tools\";\nNode.AddNodeConstructor(\"ArcRotateCamera\", function (name, scene) {\n  return function () {\n    return new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera\r\n */\n\nvar ArcRotateCamera =\n/** @class */\nfunction (_super) {\n  __extends(ArcRotateCamera, _super);\n  /**\r\n   * Instantiates a new ArcRotateCamera in a given scene\r\n   * @param name Defines the name of the camera\r\n   * @param alpha Defines the camera rotation along the logitudinal axis\r\n   * @param beta Defines the camera rotation along the latitudinal axis\r\n   * @param radius Defines the camera distance from its target\r\n   * @param target Defines the camera target\r\n   * @param scene Defines the scene the camera belongs to\r\n   * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n   */\n\n\n  function ArcRotateCamera(name, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive) || this;\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\n\n\n    _this.inertialAlphaOffset = 0;\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\n\n    _this.inertialBetaOffset = 0;\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\n\n    _this.inertialRadiusOffset = 0;\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerAlphaLimit = null;\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperAlphaLimit = null;\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerBetaLimit = 0.01;\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperBetaLimit = Math.PI - 0.01;\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.lowerRadiusLimit = null;\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\n\n    _this.upperRadiusLimit = null;\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\n\n    _this.inertialPanningX = 0;\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\n\n    _this.inertialPanningY = 0;\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\n\n    _this.pinchToPanMaxDistance = 20;\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the cammera always in your scene.\r\n     */\n\n    _this.panningDistanceLimit = null;\n    /**\r\n     * Defines the target of the camera before paning.\r\n     */\n\n    _this.panningOriginTarget = Vector3.Zero();\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no decelleration at all.\r\n     */\n\n    _this.panningInertia = 0.9; //-- end properties for backward compatibility for inputs\n\n    /**\r\n     * Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)\r\n     */\n\n    _this.zoomOnFactor = 1;\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\n\n    _this.targetScreenOffset = Vector2.Zero();\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\n\n    _this.allowUpsideDown = true;\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\n\n    _this.useInputToRestoreState = true;\n    /** @hidden */\n\n    _this._viewMatrix = new Matrix();\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\n\n    _this.panningAxis = new Vector3(1, 1, 0);\n    /**\r\n     * Observable triggered when the mesh target has been changed on the camera.\r\n     */\n\n    _this.onMeshTargetChangedObservable = new Observable();\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this\r\n     */\n\n    _this.checkCollisions = false;\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\n\n    _this.collisionRadius = new Vector3(0.5, 0.5, 0.5);\n    _this._previousPosition = Vector3.Zero();\n    _this._collisionVelocity = Vector3.Zero();\n    _this._newPosition = Vector3.Zero();\n    _this._computationVector = Vector3.Zero();\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      if (!collidedMesh) {\n        _this._previousPosition.copyFrom(_this._position);\n      } else {\n        _this.setPosition(newPosition);\n\n        if (_this.onCollide) {\n          _this.onCollide(collidedMesh);\n        }\n      } // Recompute because of constraints\n\n\n      var cosa = Math.cos(_this.alpha);\n      var sina = Math.sin(_this.alpha);\n      var cosb = Math.cos(_this.beta);\n      var sinb = Math.sin(_this.beta);\n\n      if (sinb === 0) {\n        sinb = 0.0001;\n      }\n\n      var target = _this._getTargetPosition();\n\n      _this._computationVector.copyFromFloats(_this.radius * cosa * sinb, _this.radius * cosb, _this.radius * sina * sinb);\n\n      target.addToRef(_this._computationVector, _this._newPosition);\n\n      _this._position.copyFrom(_this._newPosition);\n\n      var up = _this.upVector;\n\n      if (_this.allowUpsideDown && _this.beta < 0) {\n        up = up.clone();\n        up = up.negate();\n      }\n\n      _this._computeViewMatrix(_this._position, target, up);\n\n      _this._viewMatrix.addAtIndex(12, _this.targetScreenOffset.x);\n\n      _this._viewMatrix.addAtIndex(13, _this.targetScreenOffset.y);\n\n      _this._collisionTriggered = false;\n    };\n\n    _this._target = Vector3.Zero();\n\n    if (target) {\n      _this.setTarget(target);\n    }\n\n    _this.alpha = alpha;\n    _this.beta = beta;\n    _this.radius = radius;\n\n    _this.getViewMatrix();\n\n    _this.inputs = new ArcRotateCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouseWheel().addPointers();\n\n    return _this;\n  }\n\n  Object.defineProperty(ArcRotateCamera.prototype, \"target\", {\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     * Please note that you can set the target to a mesh and thus the target will be copied from mesh.position\r\n     */\n    get: function () {\n      return this._target;\n    },\n    set: function (value) {\n      this.setTarget(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"position\", {\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\n    get: function () {\n      return this._position;\n    },\n    set: function (newPosition) {\n      this.setPosition(newPosition);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"upVector\", {\n    get: function () {\n      return this._upVector;\n    },\n\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\n    set: function (vec) {\n      if (!this._upToYMatrix) {\n        this._YToUpMatrix = new Matrix();\n        this._upToYMatrix = new Matrix();\n        this._upVector = Vector3.Zero();\n      }\n\n      vec.normalize();\n\n      this._upVector.copyFrom(vec);\n\n      this.setMatUp();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n   */\n\n  ArcRotateCamera.prototype.setMatUp = function () {\n    // from y-up to custom-up (used in _getViewMatrix)\n    Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._YToUpMatrix); // from custom-up to y-up (used in rebuildAnglesAndRadius)\n\n    Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\n  };\n\n  Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityX\", {\n    //-- begin properties for backward compatibility for inputs\n\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.angularSensibilityX;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.angularSensibilityX = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityY\", {\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.angularSensibilityY;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.angularSensibilityY = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"pinchPrecision\", {\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.pinchPrecision;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.pinchPrecision = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"pinchDeltaPercentage\", {\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.pinchDeltaPercentage;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.pinchDeltaPercentage = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"useNaturalPinchZoom\", {\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.useNaturalPinchZoom;\n      }\n\n      return false;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.useNaturalPinchZoom = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"panningSensibility\", {\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\n    get: function () {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        return pointers.panningSensibility;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var pointers = this.inputs.attached[\"pointers\"];\n\n      if (pointers) {\n        pointers.panningSensibility = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"keysUp\", {\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysUp;\n      }\n\n      return [];\n    },\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysUp = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"keysDown\", {\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysDown;\n      }\n\n      return [];\n    },\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysDown = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"keysLeft\", {\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysLeft;\n      }\n\n      return [];\n    },\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysLeft = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"keysRight\", {\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRight;\n      }\n\n      return [];\n    },\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRight = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"wheelPrecision\", {\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\n    get: function () {\n      var mousewheel = this.inputs.attached[\"mousewheel\"];\n\n      if (mousewheel) {\n        return mousewheel.wheelPrecision;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var mousewheel = this.inputs.attached[\"mousewheel\"];\n\n      if (mousewheel) {\n        mousewheel.wheelPrecision = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"wheelDeltaPercentage\", {\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\n    get: function () {\n      var mousewheel = this.inputs.attached[\"mousewheel\"];\n\n      if (mousewheel) {\n        return mousewheel.wheelDeltaPercentage;\n      }\n\n      return 0;\n    },\n    set: function (value) {\n      var mousewheel = this.inputs.attached[\"mousewheel\"];\n\n      if (mousewheel) {\n        mousewheel.wheelDeltaPercentage = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"bouncingBehavior\", {\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\n    get: function () {\n      return this._bouncingBehavior;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"useBouncingBehavior\", {\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\n    get: function () {\n      return this._bouncingBehavior != null;\n    },\n    set: function (value) {\n      if (value === this.useBouncingBehavior) {\n        return;\n      }\n\n      if (value) {\n        this._bouncingBehavior = new BouncingBehavior();\n        this.addBehavior(this._bouncingBehavior);\n      } else if (this._bouncingBehavior) {\n        this.removeBehavior(this._bouncingBehavior);\n        this._bouncingBehavior = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"framingBehavior\", {\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\n    get: function () {\n      return this._framingBehavior;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"useFramingBehavior\", {\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\n    get: function () {\n      return this._framingBehavior != null;\n    },\n    set: function (value) {\n      if (value === this.useFramingBehavior) {\n        return;\n      }\n\n      if (value) {\n        this._framingBehavior = new FramingBehavior();\n        this.addBehavior(this._framingBehavior);\n      } else if (this._framingBehavior) {\n        this.removeBehavior(this._framingBehavior);\n        this._framingBehavior = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"autoRotationBehavior\", {\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\n    get: function () {\n      return this._autoRotationBehavior;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ArcRotateCamera.prototype, \"useAutoRotationBehavior\", {\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\n    get: function () {\n      return this._autoRotationBehavior != null;\n    },\n    set: function (value) {\n      if (value === this.useAutoRotationBehavior) {\n        return;\n      }\n\n      if (value) {\n        this._autoRotationBehavior = new AutoRotationBehavior();\n        this.addBehavior(this._autoRotationBehavior);\n      } else if (this._autoRotationBehavior) {\n        this.removeBehavior(this._autoRotationBehavior);\n        this._autoRotationBehavior = null;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  }); // Cache\n\n  /** @hidden */\n\n  ArcRotateCamera.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.alpha = undefined;\n    this._cache.beta = undefined;\n    this._cache.radius = undefined;\n    this._cache.targetScreenOffset = Vector2.Zero();\n  };\n  /** @hidden */\n\n\n  ArcRotateCamera.prototype._updateCache = function (ignoreParentClass) {\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    this._cache._target.copyFrom(this._getTargetPosition());\n\n    this._cache.alpha = this.alpha;\n    this._cache.beta = this.beta;\n    this._cache.radius = this.radius;\n\n    this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\n  };\n\n  ArcRotateCamera.prototype._getTargetPosition = function () {\n    if (this._targetHost && this._targetHost.getAbsolutePosition) {\n      var pos = this._targetHost.absolutePosition;\n\n      if (this._targetBoundingCenter) {\n        pos.addToRef(this._targetBoundingCenter, this._target);\n      } else {\n        this._target.copyFrom(pos);\n      }\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    if (lockedTargetPosition) {\n      return lockedTargetPosition;\n    }\n\n    return this._target;\n  };\n  /**\r\n   * Stores the current state of the camera (alpha, beta, radius and target)\r\n   * @returns the camera itself\r\n   */\n\n\n  ArcRotateCamera.prototype.storeState = function () {\n    this._storedAlpha = this.alpha;\n    this._storedBeta = this.beta;\n    this._storedRadius = this.radius;\n    this._storedTarget = this._getTargetPosition().clone();\n    this._storedTargetScreenOffset = this.targetScreenOffset.clone();\n    return _super.prototype.storeState.call(this);\n  };\n  /**\r\n   * @hidden\r\n   * Restored camera state. You must call storeState() first\r\n   */\n\n\n  ArcRotateCamera.prototype._restoreStateValues = function () {\n    if (!_super.prototype._restoreStateValues.call(this)) {\n      return false;\n    }\n\n    this.setTarget(this._storedTarget.clone());\n    this.alpha = this._storedAlpha;\n    this.beta = this._storedBeta;\n    this.radius = this._storedRadius;\n    this.targetScreenOffset = this._storedTargetScreenOffset.clone();\n    this.inertialAlphaOffset = 0;\n    this.inertialBetaOffset = 0;\n    this.inertialRadiusOffset = 0;\n    this.inertialPanningX = 0;\n    this.inertialPanningY = 0;\n    return true;\n  }; // Synchronized\n\n  /** @hidden */\n\n\n  ArcRotateCamera.prototype._isSynchronizedViewMatrix = function () {\n    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\n      return false;\n    }\n\n    return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);\n  };\n  /**\r\n   * Attached controls to the current camera.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n   * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n   */\n\n\n  ArcRotateCamera.prototype.attachControl = function (ignored, noPreventDefault, useCtrlForPanning, panningMouseButton) {\n    var _this = this;\n\n    if (useCtrlForPanning === void 0) {\n      useCtrlForPanning = true;\n    }\n\n    if (panningMouseButton === void 0) {\n      panningMouseButton = 2;\n    }\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._useCtrlForPanning = useCtrlForPanning;\n    this._panningMouseButton = panningMouseButton; // backwards compatibility\n\n    if (typeof arguments[0] === \"boolean\") {\n      if (arguments.length > 1) {\n        this._useCtrlForPanning = arguments[1];\n      }\n\n      if (arguments.length > 2) {\n        this._panningMouseButton = arguments[2];\n      }\n    }\n\n    this.inputs.attachElement(noPreventDefault);\n\n    this._reset = function () {\n      _this.inertialAlphaOffset = 0;\n      _this.inertialBetaOffset = 0;\n      _this.inertialRadiusOffset = 0;\n      _this.inertialPanningX = 0;\n      _this.inertialPanningY = 0;\n    };\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  ArcRotateCamera.prototype.detachControl = function (ignored) {\n    this.inputs.detachElement();\n\n    if (this._reset) {\n      this._reset();\n    }\n  };\n  /** @hidden */\n\n\n  ArcRotateCamera.prototype._checkInputs = function () {\n    //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\n    if (this._collisionTriggered) {\n      return;\n    }\n\n    this.inputs.checkInputs(); // Inertia\n\n    if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\n      var inertialAlphaOffset = this.inertialAlphaOffset;\n\n      if (this.beta <= 0) {\n        inertialAlphaOffset *= -1;\n      }\n\n      if (this.getScene().useRightHandedSystem) {\n        inertialAlphaOffset *= -1;\n      }\n\n      if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {\n        inertialAlphaOffset *= -1;\n      }\n\n      this.alpha += inertialAlphaOffset;\n      this.beta += this.inertialBetaOffset;\n      this.radius -= this.inertialRadiusOffset;\n      this.inertialAlphaOffset *= this.inertia;\n      this.inertialBetaOffset *= this.inertia;\n      this.inertialRadiusOffset *= this.inertia;\n\n      if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\n        this.inertialAlphaOffset = 0;\n      }\n\n      if (Math.abs(this.inertialBetaOffset) < Epsilon) {\n        this.inertialBetaOffset = 0;\n      }\n\n      if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\n        this.inertialRadiusOffset = 0;\n      }\n    } // Panning inertia\n\n\n    if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\n      if (!this._localDirection) {\n        this._localDirection = Vector3.Zero();\n        this._transformedDirection = Vector3.Zero();\n      }\n\n      this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\n\n      this._localDirection.multiplyInPlace(this.panningAxis);\n\n      this._viewMatrix.invertToRef(this._cameraTransformMatrix);\n\n      Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection); //Eliminate y if map panning is enabled (panningAxis == 1,0,1)\n\n      if (!this.panningAxis.y) {\n        this._transformedDirection.y = 0;\n      }\n\n      if (!this._targetHost) {\n        if (this.panningDistanceLimit) {\n          this._transformedDirection.addInPlace(this._target);\n\n          var distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\n\n          if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\n            this._target.copyFrom(this._transformedDirection);\n          }\n        } else {\n          this._target.addInPlace(this._transformedDirection);\n        }\n      }\n\n      this.inertialPanningX *= this.panningInertia;\n      this.inertialPanningY *= this.panningInertia;\n\n      if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\n        this.inertialPanningX = 0;\n      }\n\n      if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\n        this.inertialPanningY = 0;\n      }\n    } // Limits\n\n\n    this._checkLimits();\n\n    _super.prototype._checkInputs.call(this);\n  };\n\n  ArcRotateCamera.prototype._checkLimits = function () {\n    if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\n      if (this.allowUpsideDown && this.beta > Math.PI) {\n        this.beta = this.beta - 2 * Math.PI;\n      }\n    } else {\n      if (this.beta < this.lowerBetaLimit) {\n        this.beta = this.lowerBetaLimit;\n      }\n    }\n\n    if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\n      if (this.allowUpsideDown && this.beta < -Math.PI) {\n        this.beta = this.beta + 2 * Math.PI;\n      }\n    } else {\n      if (this.beta > this.upperBetaLimit) {\n        this.beta = this.upperBetaLimit;\n      }\n    }\n\n    if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\n      this.alpha = this.lowerAlphaLimit;\n    }\n\n    if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\n      this.alpha = this.upperAlphaLimit;\n    }\n\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n      this.inertialRadiusOffset = 0;\n    }\n\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n      this.inertialRadiusOffset = 0;\n    }\n  };\n  /**\r\n   * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n   */\n\n\n  ArcRotateCamera.prototype.rebuildAnglesAndRadius = function () {\n    this._position.subtractToRef(this._getTargetPosition(), this._computationVector); // need to rotate to Y up equivalent if up vector not Axis.Y\n\n\n    if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\n      Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\n    }\n\n    this.radius = this._computationVector.length();\n\n    if (this.radius === 0) {\n      this.radius = 0.0001; // Just to avoid division by zero\n    } // Alpha\n\n\n    var previousAlpha = this.alpha;\n\n    if (this._computationVector.x === 0 && this._computationVector.z === 0) {\n      this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\n    } else {\n      this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\n    }\n\n    if (this._computationVector.z < 0) {\n      this.alpha = 2 * Math.PI - this.alpha;\n    } // Calculate the number of revolutions between the new and old alpha values.\n\n\n    var alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI)); // Adjust alpha so that its numerical representation is the closest one to the old value.\n\n    this.alpha += alphaCorrectionTurns * 2.0 * Math.PI; // Beta\n\n    this.beta = Math.acos(this._computationVector.y / this.radius);\n\n    this._checkLimits();\n  };\n  /**\r\n   * Use a position to define the current camera related information like alpha, beta and radius\r\n   * @param position Defines the position to set the camera at\r\n   */\n\n\n  ArcRotateCamera.prototype.setPosition = function (position) {\n    if (this._position.equals(position)) {\n      return;\n    }\n\n    this._position.copyFrom(position);\n\n    this.rebuildAnglesAndRadius();\n  };\n  /**\r\n   * Defines the target the camera should look at.\r\n   * This will automatically adapt alpha beta and radius to fit within the new target.\r\n   * @param target Defines the new target as a Vector or a mesh\r\n   * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n   * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n   */\n\n\n  ArcRotateCamera.prototype.setTarget = function (target, toBoundingCenter, allowSamePosition) {\n    if (toBoundingCenter === void 0) {\n      toBoundingCenter = false;\n    }\n\n    if (allowSamePosition === void 0) {\n      allowSamePosition = false;\n    }\n\n    if (target.getBoundingInfo) {\n      if (toBoundingCenter) {\n        this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();\n      } else {\n        this._targetBoundingCenter = null;\n      }\n\n      target.computeWorldMatrix();\n      this._targetHost = target;\n      this._target = this._getTargetPosition();\n      this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\n    } else {\n      var newTarget = target;\n\n      var currentTarget = this._getTargetPosition();\n\n      if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\n        return;\n      }\n\n      this._targetHost = null;\n      this._target = newTarget;\n      this._targetBoundingCenter = null;\n      this.onMeshTargetChangedObservable.notifyObservers(null);\n    }\n\n    this.rebuildAnglesAndRadius();\n  };\n  /** @hidden */\n\n\n  ArcRotateCamera.prototype._getViewMatrix = function () {\n    // Compute\n    var cosa = Math.cos(this.alpha);\n    var sina = Math.sin(this.alpha);\n    var cosb = Math.cos(this.beta);\n    var sinb = Math.sin(this.beta);\n\n    if (sinb === 0) {\n      sinb = 0.0001;\n    }\n\n    if (this.radius === 0) {\n      this.radius = 0.0001; // Just to avoid division by zero\n    }\n\n    var target = this._getTargetPosition();\n\n    this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb); // Rotate according to up vector\n\n\n    if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\n      Vector3.TransformCoordinatesToRef(this._computationVector, this._YToUpMatrix, this._computationVector);\n    }\n\n    target.addToRef(this._computationVector, this._newPosition);\n\n    if (this.getScene().collisionsEnabled && this.checkCollisions) {\n      var coordinator = this.getScene().collisionCoordinator;\n\n      if (!this._collider) {\n        this._collider = coordinator.createCollider();\n      }\n\n      this._collider._radius = this.collisionRadius;\n\n      this._newPosition.subtractToRef(this._position, this._collisionVelocity);\n\n      this._collisionTriggered = true;\n      coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n    } else {\n      this._position.copyFrom(this._newPosition);\n\n      var up = this.upVector;\n\n      if (this.allowUpsideDown && sinb < 0) {\n        up = up.negate();\n      }\n\n      this._computeViewMatrix(this._position, target, up);\n\n      this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\n\n      this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\n    }\n\n    this._currentTarget = target;\n    return this._viewMatrix;\n  };\n  /**\r\n   * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n   * @param meshes Defines the mesh to zoom on\r\n   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n   */\n\n\n  ArcRotateCamera.prototype.zoomOn = function (meshes, doNotUpdateMaxZ) {\n    if (doNotUpdateMaxZ === void 0) {\n      doNotUpdateMaxZ = false;\n    }\n\n    meshes = meshes || this.getScene().meshes;\n    var minMaxVector = Mesh.MinMax(meshes);\n    var distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);\n    this.radius = distance * this.zoomOnFactor;\n    this.focusOn({\n      min: minMaxVector.min,\n      max: minMaxVector.max,\n      distance: distance\n    }, doNotUpdateMaxZ);\n  };\n  /**\r\n   * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n   * The target will be changed but the radius\r\n   * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n   * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n   */\n\n\n  ArcRotateCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ) {\n    if (doNotUpdateMaxZ === void 0) {\n      doNotUpdateMaxZ = false;\n    }\n\n    var meshesOrMinMaxVector;\n    var distance;\n\n    if (meshesOrMinMaxVectorAndDistance.min === undefined) {\n      // meshes\n      var meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\n      meshesOrMinMaxVector = Mesh.MinMax(meshes);\n      distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\n    } else {\n      //minMaxVector and distance\n      var minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;\n      meshesOrMinMaxVector = minMaxVectorAndDistance;\n      distance = minMaxVectorAndDistance.distance;\n    }\n\n    this._target = Mesh.Center(meshesOrMinMaxVector);\n\n    if (!doNotUpdateMaxZ) {\n      this.maxZ = distance * 2;\n    }\n  };\n  /**\r\n   * @override\r\n   * Override Camera.createRigCamera\r\n   */\n\n\n  ArcRotateCamera.prototype.createRigCamera = function (name, cameraIndex) {\n    var alphaShift = 0;\n\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n      case Camera.RIG_MODE_VR:\n        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\n        break;\n\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n        alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\n        break;\n    }\n\n    var rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\n    rigCam._cameraRigParams = {};\n    rigCam.isRigCamera = true;\n    rigCam.rigParent = this;\n    rigCam.upVector = this.upVector;\n    return rigCam;\n  };\n  /**\r\n   * @hidden\r\n   * @override\r\n   * Override Camera._updateRigCameras\r\n   */\n\n\n  ArcRotateCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    camLeft.beta = camRight.beta = this.beta;\n\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n      case Camera.RIG_MODE_VR:\n        camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n        camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n        break;\n\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n        camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n        camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n        break;\n    }\n\n    _super.prototype._updateRigCameras.call(this);\n  };\n  /**\r\n   * Destroy the camera and release the current resources hold by it.\r\n   */\n\n\n  ArcRotateCamera.prototype.dispose = function () {\n    this.inputs.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n\n  ArcRotateCamera.prototype.getClassName = function () {\n    return \"ArcRotateCamera\";\n  };\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"alpha\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"beta\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"radius\", void 0);\n\n  __decorate([serializeAsVector3(\"target\")], ArcRotateCamera.prototype, \"_target\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"inertialAlphaOffset\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"inertialBetaOffset\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"inertialRadiusOffset\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"lowerAlphaLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"upperAlphaLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"lowerBetaLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"upperBetaLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"lowerRadiusLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"upperRadiusLimit\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"inertialPanningX\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"inertialPanningY\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"pinchToPanMaxDistance\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"panningDistanceLimit\", void 0);\n\n  __decorate([serializeAsVector3()], ArcRotateCamera.prototype, \"panningOriginTarget\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"panningInertia\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"zoomOnFactor\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"targetScreenOffset\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"allowUpsideDown\", void 0);\n\n  __decorate([serialize()], ArcRotateCamera.prototype, \"useInputToRestoreState\", void 0);\n\n  return ArcRotateCamera;\n}(TargetCamera);\n\nexport { ArcRotateCamera };","map":{"version":3,"sources":["../../../sourceES6/core/Cameras/arcRotateCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AutoRotationBehavior } from \"../Behaviors/Cameras/autoRotationBehavior\";\r\nimport { BouncingBehavior } from \"../Behaviors/Cameras/bouncingBehavior\";\r\nimport { FramingBehavior } from \"../Behaviors/Cameras/framingBehavior\";\r\nimport { Camera } from \"./camera\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { ArcRotateCameraPointersInput } from \"../Cameras/Inputs/arcRotateCameraPointersInput\";\r\nimport { ArcRotateCameraKeyboardMoveInput } from \"../Cameras/Inputs/arcRotateCameraKeyboardMoveInput\";\r\nimport { ArcRotateCameraMouseWheelInput } from \"../Cameras/Inputs/arcRotateCameraMouseWheelInput\";\r\nimport { ArcRotateCameraInputsManager } from \"../Cameras/arcRotateCameraInputsManager\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\nNode.AddNodeConstructor(\"ArcRotateCamera\", (name, scene) => {\r\n    return () => new ArcRotateCamera(name, 0, 0, 1.0, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This represents an orbital type of camera.\r\n *\r\n * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.\r\n * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.\r\n * @see https://doc.babylonjs.com/babylon101/cameras#arc-rotate-camera\r\n */\r\nexport class ArcRotateCamera extends TargetCamera {\r\n    /**\r\n     * Defines the rotation angle of the camera along the longitudinal axis.\r\n     */\r\n    @serialize()\r\n    public alpha: number;\r\n\r\n    /**\r\n     * Defines the rotation angle of the camera along the latitudinal axis.\r\n     */\r\n    @serialize()\r\n    public beta: number;\r\n\r\n    /**\r\n     * Defines the radius of the camera from it s target point.\r\n     */\r\n    @serialize()\r\n    public radius: number;\r\n\r\n    @serializeAsVector3(\"target\")\r\n    protected _target: Vector3;\r\n    protected _targetHost: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     * Please note that you can set the target to a mesh and thus the target will be copied from mesh.position\r\n     */\r\n    public get target(): Vector3 {\r\n        return this._target;\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this.setPosition(newPosition);\r\n    }\r\n\r\n    protected _upToYMatrix: Matrix;\r\n    protected _YToUpMatrix: Matrix;\r\n\r\n    /**\r\n     * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.\r\n     * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.\r\n     */\r\n    set upVector(vec: Vector3) {\r\n        if (!this._upToYMatrix) {\r\n            this._YToUpMatrix = new Matrix();\r\n            this._upToYMatrix = new Matrix();\r\n\r\n            this._upVector = Vector3.Zero();\r\n        }\r\n\r\n        vec.normalize();\r\n        this._upVector.copyFrom(vec);\r\n        this.setMatUp();\r\n    }\r\n\r\n    get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.\r\n     */\r\n    public setMatUp() {\r\n        // from y-up to custom-up (used in _getViewMatrix)\r\n        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._YToUpMatrix);\r\n\r\n        // from custom-up to y-up (used in rebuildAnglesAndRadius)\r\n        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);\r\n    }\r\n\r\n    /**\r\n     * Current inertia value on the longitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialAlphaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the latitudinal axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialBetaOffset = 0;\r\n\r\n    /**\r\n     * Current inertia value on the radius axis.\r\n     * The bigger this number the longer it will take for the camera to stop.\r\n     */\r\n    @serialize()\r\n    public inertialRadiusOffset = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle on the longitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperAlphaLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Minimum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerBetaLimit = 0.01;\r\n\r\n    /**\r\n     * Maximum allowed angle on the latitudinal axis.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperBetaLimit = Math.PI - 0.01;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the target (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the target (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the X axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningX: number = 0;\r\n\r\n    /**\r\n     * Defines the current inertia value used during panning of the camera along the Y axis.\r\n     */\r\n    @serialize()\r\n    public inertialPanningY: number = 0;\r\n\r\n    /**\r\n     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.\r\n     * Basically if your fingers moves away from more than this distance you will be considered\r\n     * in pinch mode.\r\n     */\r\n    @serialize()\r\n    public pinchToPanMaxDistance: number = 20;\r\n\r\n    /**\r\n     * Defines the maximum distance the camera can pan.\r\n     * This could help keeping the cammera always in your scene.\r\n     */\r\n    @serialize()\r\n    public panningDistanceLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Defines the target of the camera before paning.\r\n     */\r\n    @serializeAsVector3()\r\n    public panningOriginTarget: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the value of the inertia used during panning.\r\n     * 0 would mean stop inertia and one would mean no decelleration at all.\r\n     */\r\n    @serialize()\r\n    public panningInertia = 0.9;\r\n\r\n    //-- begin properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityX(): number {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityX;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityX(value: number) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityX = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.\r\n     */\r\n    public get angularSensibilityY(): number {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.angularSensibilityY;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set angularSensibilityY(value: number) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.angularSensibilityY = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    public get pinchPrecision(): number {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchPrecision(value: number) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get pinchDeltaPercentage(): number {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.pinchDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set pinchDeltaPercentage(value: number) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.pinchDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer use natural pinch zoom to override the pinch precision\r\n     * and pinch delta percentage.\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     */\r\n    public get useNaturalPinchZoom(): boolean {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.useNaturalPinchZoom;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public set useNaturalPinchZoom(value: boolean) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.useNaturalPinchZoom = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    public get panningSensibility(): number {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            return pointers.panningSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set panningSensibility(value: number) {\r\n        var pointers = <ArcRotateCameraPointersInput>this.inputs.attached[\"pointers\"];\r\n        if (pointers) {\r\n            pointers.panningSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.\r\n     */\r\n    public get keysUp(): number[] {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.\r\n     */\r\n    public get keysDown(): number[] {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.\r\n     */\r\n    public get keysRight(): number[] {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        var keyboard = <ArcRotateCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\r\n     */\r\n    public get wheelPrecision(): number {\r\n        var mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelPrecision;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelPrecision(value: number) {\r\n        var mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelPrecision = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.\r\n     * It will be used instead of pinchDeltaPrecision if different from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.\r\n     */\r\n    public get wheelDeltaPercentage(): number {\r\n        var mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            return mousewheel.wheelDeltaPercentage;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public set wheelDeltaPercentage(value: number) {\r\n        var mousewheel = <ArcRotateCameraMouseWheelInput>this.inputs.attached[\"mousewheel\"];\r\n        if (mousewheel) {\r\n            mousewheel.wheelDeltaPercentage = value;\r\n        }\r\n    }\r\n\r\n    //-- end properties for backward compatibility for inputs\r\n\r\n    /**\r\n     * Defines how much the radius should be scaled while zomming on a particular mesh (through the zoomOn function)\r\n     */\r\n    @serialize()\r\n    public zoomOnFactor = 1;\r\n\r\n    /**\r\n     * Defines a screen offset for the camera position.\r\n     */\r\n    @serialize()\r\n    public targetScreenOffset = Vector2.Zero();\r\n\r\n    /**\r\n     * Allows the camera to be completely reversed.\r\n     * If false the camera can not arrive upside down.\r\n     */\r\n    @serialize()\r\n    public allowUpsideDown = true;\r\n\r\n    /**\r\n     * Define if double tap/click is used to restore the previously saved state of the camera.\r\n     */\r\n    @serialize()\r\n    public useInputToRestoreState = true;\r\n\r\n    /** @hidden */\r\n    public _viewMatrix = new Matrix();\r\n    /** @hidden */\r\n    public _useCtrlForPanning: boolean;\r\n    /** @hidden */\r\n    public _panningMouseButton: number;\r\n\r\n    /**\r\n     * Defines the input associated to the camera.\r\n     */\r\n    public inputs: ArcRotateCameraInputsManager;\r\n\r\n    /** @hidden */\r\n    public _reset: () => void;\r\n\r\n    /**\r\n     * Defines the allowed panning axis.\r\n     */\r\n    public panningAxis: Vector3 = new Vector3(1, 1, 0);\r\n    protected _localDirection: Vector3;\r\n    protected _transformedDirection: Vector3;\r\n\r\n    // Behaviors\r\n    private _bouncingBehavior: Nullable<BouncingBehavior>;\r\n\r\n    /**\r\n     * Gets the bouncing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\r\n    public get bouncingBehavior(): Nullable<BouncingBehavior> {\r\n        return this._bouncingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the bouncing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#bouncing-behavior\r\n     */\r\n    public get useBouncingBehavior(): boolean {\r\n        return this._bouncingBehavior != null;\r\n    }\r\n\r\n    public set useBouncingBehavior(value: boolean) {\r\n        if (value === this.useBouncingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._bouncingBehavior = new BouncingBehavior();\r\n            this.addBehavior(this._bouncingBehavior);\r\n        } else if (this._bouncingBehavior) {\r\n            this.removeBehavior(this._bouncingBehavior);\r\n            this._bouncingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _framingBehavior: Nullable<FramingBehavior>;\r\n\r\n    /**\r\n     * Gets the framing behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\r\n    public get framingBehavior(): Nullable<FramingBehavior> {\r\n        return this._framingBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the framing behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#framing-behavior\r\n     */\r\n    public get useFramingBehavior(): boolean {\r\n        return this._framingBehavior != null;\r\n    }\r\n\r\n    public set useFramingBehavior(value: boolean) {\r\n        if (value === this.useFramingBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._framingBehavior = new FramingBehavior();\r\n            this.addBehavior(this._framingBehavior);\r\n        } else if (this._framingBehavior) {\r\n            this.removeBehavior(this._framingBehavior);\r\n            this._framingBehavior = null;\r\n        }\r\n    }\r\n\r\n    private _autoRotationBehavior: Nullable<AutoRotationBehavior>;\r\n\r\n    /**\r\n     * Gets the auto rotation behavior of the camera if it has been enabled.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\r\n    public get autoRotationBehavior(): Nullable<AutoRotationBehavior> {\r\n        return this._autoRotationBehavior;\r\n    }\r\n\r\n    /**\r\n     * Defines if the auto rotation behavior of the camera is enabled on the camera.\r\n     * @see https://doc.babylonjs.com/how_to/camera_behaviors#autorotation-behavior\r\n     */\r\n    public get useAutoRotationBehavior(): boolean {\r\n        return this._autoRotationBehavior != null;\r\n    }\r\n\r\n    public set useAutoRotationBehavior(value: boolean) {\r\n        if (value === this.useAutoRotationBehavior) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._autoRotationBehavior = new AutoRotationBehavior();\r\n            this.addBehavior(this._autoRotationBehavior);\r\n        } else if (this._autoRotationBehavior) {\r\n            this.removeBehavior(this._autoRotationBehavior);\r\n            this._autoRotationBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable triggered when the mesh target has been changed on the camera.\r\n     */\r\n    public onMeshTargetChangedObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /**\r\n     * Event raised when the camera is colliding with a mesh.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Defines whether the camera should check collision with the objects oh the scene.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#how-can-i-do-this\r\n     */\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Defines the collision radius of the camera.\r\n     * This simulates a sphere around the camera.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\r\n    public collisionRadius = new Vector3(0.5, 0.5, 0.5);\r\n\r\n    protected _collider: Collider;\r\n    protected _previousPosition = Vector3.Zero();\r\n    protected _collisionVelocity = Vector3.Zero();\r\n    protected _newPosition = Vector3.Zero();\r\n    protected _previousAlpha: number;\r\n    protected _previousBeta: number;\r\n    protected _previousRadius: number;\r\n    //due to async collision inspection\r\n    protected _collisionTriggered: boolean;\r\n\r\n    protected _targetBoundingCenter: Nullable<Vector3>;\r\n\r\n    private _computationVector: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Instantiates a new ArcRotateCamera in a given scene\r\n     * @param name Defines the name of the camera\r\n     * @param alpha Defines the camera rotation along the logitudinal axis\r\n     * @param beta Defines the camera rotation along the latitudinal axis\r\n     * @param radius Defines the camera distance from its target\r\n     * @param target Defines the camera target\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, alpha: number, beta: number, radius: number, target: Vector3, scene: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._target = Vector3.Zero();\r\n        if (target) {\r\n            this.setTarget(target);\r\n        }\r\n\r\n        this.alpha = alpha;\r\n        this.beta = beta;\r\n        this.radius = radius;\r\n\r\n        this.getViewMatrix();\r\n        this.inputs = new ArcRotateCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n    }\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _initCache(): void {\r\n        super._initCache();\r\n        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.alpha = undefined;\r\n        this._cache.beta = undefined;\r\n        this._cache.radius = undefined;\r\n        this._cache.targetScreenOffset = Vector2.Zero();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache._target.copyFrom(this._getTargetPosition());\r\n        this._cache.alpha = this.alpha;\r\n        this._cache.beta = this.beta;\r\n        this._cache.radius = this.radius;\r\n        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\r\n    }\r\n\r\n    protected _getTargetPosition(): Vector3 {\r\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\r\n            var pos: Vector3 = this._targetHost.absolutePosition;\r\n            if (this._targetBoundingCenter) {\r\n                pos.addToRef(this._targetBoundingCenter, this._target);\r\n            } else {\r\n                this._target.copyFrom(pos);\r\n            }\r\n        }\r\n\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        if (lockedTargetPosition) {\r\n            return lockedTargetPosition;\r\n        }\r\n\r\n        return this._target;\r\n    }\r\n\r\n    private _storedAlpha: number;\r\n    private _storedBeta: number;\r\n    private _storedRadius: number;\r\n    private _storedTarget: Vector3;\r\n    private _storedTargetScreenOffset: Vector2;\r\n\r\n    /**\r\n     * Stores the current state of the camera (alpha, beta, radius and target)\r\n     * @returns the camera itself\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedAlpha = this.alpha;\r\n        this._storedBeta = this.beta;\r\n        this._storedRadius = this.radius;\r\n        this._storedTarget = this._getTargetPosition().clone();\r\n        this._storedTargetScreenOffset = this.targetScreenOffset.clone();\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Restored camera state. You must call storeState() first\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.setTarget(this._storedTarget.clone());\r\n        this.alpha = this._storedAlpha;\r\n        this.beta = this._storedBeta;\r\n        this.radius = this._storedRadius;\r\n        this.targetScreenOffset = this._storedTargetScreenOffset.clone();\r\n\r\n        this.inertialAlphaOffset = 0;\r\n        this.inertialBetaOffset = 0;\r\n        this.inertialRadiusOffset = 0;\r\n        this.inertialPanningX = 0;\r\n        this.inertialPanningY = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Synchronized\r\n    /** @hidden */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault: boolean, useCtrlForPanning: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(noPreventDefault: boolean, useCtrlForPanning: boolean, panningMouseButton: number): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * @param useCtrlForPanning  Defines whether ctrl is used for paning within the controls\r\n     * @param panningMouseButton Defines whether panning is allowed through mouse click button\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean, useCtrlForPanning: boolean | number = true, panningMouseButton: number = 2): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this._useCtrlForPanning = useCtrlForPanning as boolean;\r\n        this._panningMouseButton = panningMouseButton;\r\n        // backwards compatibility\r\n        if (typeof arguments[0] === \"boolean\") {\r\n            if (arguments.length > 1) {\r\n                this._useCtrlForPanning = arguments[1];\r\n            }\r\n            if (arguments.length > 2) {\r\n                this._panningMouseButton = arguments[2];\r\n            }\r\n        }\r\n\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {\r\n            this.inertialAlphaOffset = 0;\r\n            this.inertialBetaOffset = 0;\r\n            this.inertialRadiusOffset = 0;\r\n            this.inertialPanningX = 0;\r\n            this.inertialPanningY = 0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored: any): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored?: any): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\r\n        if (this._collisionTriggered) {\r\n            return;\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n        // Inertia\r\n        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\r\n            let inertialAlphaOffset = this.inertialAlphaOffset;\r\n            if (this.beta <= 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.getScene().useRightHandedSystem) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {\r\n                inertialAlphaOffset *= -1;\r\n            }\r\n            this.alpha += inertialAlphaOffset;\r\n\r\n            this.beta += this.inertialBetaOffset;\r\n\r\n            this.radius -= this.inertialRadiusOffset;\r\n            this.inertialAlphaOffset *= this.inertia;\r\n            this.inertialBetaOffset *= this.inertia;\r\n            this.inertialRadiusOffset *= this.inertia;\r\n            if (Math.abs(this.inertialAlphaOffset) < Epsilon) {\r\n                this.inertialAlphaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialBetaOffset) < Epsilon) {\r\n                this.inertialBetaOffset = 0;\r\n            }\r\n            if (Math.abs(this.inertialRadiusOffset) < this.speed * Epsilon) {\r\n                this.inertialRadiusOffset = 0;\r\n            }\r\n        }\r\n\r\n        // Panning inertia\r\n        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\r\n            if (!this._localDirection) {\r\n                this._localDirection = Vector3.Zero();\r\n                this._transformedDirection = Vector3.Zero();\r\n            }\r\n\r\n            this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\r\n            this._localDirection.multiplyInPlace(this.panningAxis);\r\n            this._viewMatrix.invertToRef(this._cameraTransformMatrix);\r\n            Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);\r\n            //Eliminate y if map panning is enabled (panningAxis == 1,0,1)\r\n            if (!this.panningAxis.y) {\r\n                this._transformedDirection.y = 0;\r\n            }\r\n\r\n            if (!this._targetHost) {\r\n                if (this.panningDistanceLimit) {\r\n                    this._transformedDirection.addInPlace(this._target);\r\n                    var distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);\r\n                    if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {\r\n                        this._target.copyFrom(this._transformedDirection);\r\n                    }\r\n                } else {\r\n                    this._target.addInPlace(this._transformedDirection);\r\n                }\r\n            }\r\n\r\n            this.inertialPanningX *= this.panningInertia;\r\n            this.inertialPanningY *= this.panningInertia;\r\n\r\n            if (Math.abs(this.inertialPanningX) < this.speed * Epsilon) {\r\n                this.inertialPanningX = 0;\r\n            }\r\n            if (Math.abs(this.inertialPanningY) < this.speed * Epsilon) {\r\n                this.inertialPanningY = 0;\r\n            }\r\n        }\r\n\r\n        // Limits\r\n        this._checkLimits();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _checkLimits() {\r\n        if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta > Math.PI) {\r\n                this.beta = this.beta - 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta < this.lowerBetaLimit) {\r\n                this.beta = this.lowerBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\r\n            if (this.allowUpsideDown && this.beta < -Math.PI) {\r\n                this.beta = this.beta + 2 * Math.PI;\r\n            }\r\n        } else {\r\n            if (this.beta > this.upperBetaLimit) {\r\n                this.beta = this.upperBetaLimit;\r\n            }\r\n        }\r\n\r\n        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {\r\n            this.alpha = this.lowerAlphaLimit;\r\n        }\r\n        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {\r\n            this.alpha = this.upperAlphaLimit;\r\n        }\r\n\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n            this.inertialRadiusOffset = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds angles (alpha, beta) and radius from the give position and target\r\n     */\r\n    public rebuildAnglesAndRadius(): void {\r\n        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);\r\n\r\n        // need to rotate to Y up equivalent if up vector not Axis.Y\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);\r\n        }\r\n\r\n        this.radius = this._computationVector.length();\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        // Alpha\r\n        const previousAlpha = this.alpha;\r\n        if (this._computationVector.x === 0 && this._computationVector.z === 0) {\r\n            this.alpha = Math.PI / 2; // avoid division by zero when looking along up axis, and set to acos(0)\r\n        } else {\r\n            this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2)));\r\n        }\r\n\r\n        if (this._computationVector.z < 0) {\r\n            this.alpha = 2 * Math.PI - this.alpha;\r\n        }\r\n\r\n        // Calculate the number of revolutions between the new and old alpha values.\r\n        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2.0 * Math.PI));\r\n        // Adjust alpha so that its numerical representation is the closest one to the old value.\r\n        this.alpha += alphaCorrectionTurns * 2.0 * Math.PI;\r\n\r\n        // Beta\r\n        this.beta = Math.acos(this._computationVector.y / this.radius);\r\n\r\n        this._checkLimits();\r\n    }\r\n\r\n    /**\r\n     * Use a position to define the current camera related information like alpha, beta and radius\r\n     * @param position Defines the position to set the camera at\r\n     */\r\n    public setPosition(position: Vector3): void {\r\n        if (this._position.equals(position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(position);\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * This will automatically adapt alpha beta and radius to fit within the new target.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center\r\n     * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)\r\n     */\r\n    public setTarget(target: AbstractMesh | Vector3, toBoundingCenter = false, allowSamePosition = false): void {\r\n        if ((<any>target).getBoundingInfo) {\r\n            if (toBoundingCenter) {\r\n                this._targetBoundingCenter = (<any>target).getBoundingInfo().boundingBox.centerWorld.clone();\r\n            } else {\r\n                this._targetBoundingCenter = null;\r\n            }\r\n            (<AbstractMesh>target).computeWorldMatrix();\r\n            this._targetHost = <AbstractMesh>target;\r\n            this._target = this._getTargetPosition();\r\n\r\n            this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);\r\n        } else {\r\n            var newTarget = <Vector3>target;\r\n            var currentTarget = this._getTargetPosition();\r\n            if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\r\n                return;\r\n            }\r\n            this._targetHost = null;\r\n            this._target = newTarget;\r\n            this._targetBoundingCenter = null;\r\n            this.onMeshTargetChangedObservable.notifyObservers(null);\r\n        }\r\n\r\n        this.rebuildAnglesAndRadius();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getViewMatrix(): Matrix {\r\n        // Compute\r\n        var cosa = Math.cos(this.alpha);\r\n        var sina = Math.sin(this.alpha);\r\n        var cosb = Math.cos(this.beta);\r\n        var sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        if (this.radius === 0) {\r\n            this.radius = 0.0001; // Just to avoid division by zero\r\n        }\r\n\r\n        var target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n\r\n        // Rotate according to up vector\r\n        if (this._upVector.x !== 0 || this._upVector.y !== 1.0 || this._upVector.z !== 0) {\r\n            Vector3.TransformCoordinatesToRef(this._computationVector, this._YToUpMatrix, this._computationVector);\r\n        }\r\n\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        if (this.getScene().collisionsEnabled && this.checkCollisions) {\r\n            const coordinator = this.getScene().collisionCoordinator;\r\n            if (!this._collider) {\r\n                this._collider = coordinator.createCollider();\r\n            }\r\n            this._collider._radius = this.collisionRadius;\r\n            this._newPosition.subtractToRef(this._position, this._collisionVelocity);\r\n            this._collisionTriggered = true;\r\n            coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n        } else {\r\n            this._position.copyFrom(this._newPosition);\r\n\r\n            var up = this.upVector;\r\n            if (this.allowUpsideDown && sinb < 0) {\r\n                up = up.negate();\r\n            }\r\n\r\n            this._computeViewMatrix(this._position, target, up);\r\n\r\n            this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n            this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n        }\r\n        this._currentTarget = target;\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        if (!collidedMesh) {\r\n            this._previousPosition.copyFrom(this._position);\r\n        } else {\r\n            this.setPosition(newPosition);\r\n\r\n            if (this.onCollide) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n\r\n        // Recompute because of constraints\r\n        var cosa = Math.cos(this.alpha);\r\n        var sina = Math.sin(this.alpha);\r\n        var cosb = Math.cos(this.beta);\r\n        var sinb = Math.sin(this.beta);\r\n\r\n        if (sinb === 0) {\r\n            sinb = 0.0001;\r\n        }\r\n\r\n        var target = this._getTargetPosition();\r\n        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);\r\n        target.addToRef(this._computationVector, this._newPosition);\r\n        this._position.copyFrom(this._newPosition);\r\n\r\n        var up = this.upVector;\r\n        if (this.allowUpsideDown && this.beta < 0) {\r\n            up = up.clone();\r\n            up = up.negate();\r\n        }\r\n\r\n        this._computeViewMatrix(this._position, target, up);\r\n        this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);\r\n        this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);\r\n\r\n        this._collisionTriggered = false;\r\n    };\r\n\r\n    /**\r\n     * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.\r\n     * @param meshes Defines the mesh to zoom on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public zoomOn(meshes?: AbstractMesh[], doNotUpdateMaxZ = false): void {\r\n        meshes = meshes || this.getScene().meshes;\r\n\r\n        var minMaxVector = Mesh.MinMax(meshes);\r\n        var distance = Vector3.Distance(minMaxVector.min, minMaxVector.max);\r\n\r\n        this.radius = distance * this.zoomOnFactor;\r\n\r\n        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\r\n    }\r\n\r\n    /**\r\n     * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.\r\n     * The target will be changed but the radius\r\n     * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on\r\n     * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)\r\n     */\r\n    public focusOn(meshesOrMinMaxVectorAndDistance: AbstractMesh[] | { min: Vector3; max: Vector3; distance: number }, doNotUpdateMaxZ = false): void {\r\n        var meshesOrMinMaxVector: { min: Vector3; max: Vector3 };\r\n        var distance: number;\r\n\r\n        if ((<any>meshesOrMinMaxVectorAndDistance).min === undefined) {\r\n            // meshes\r\n            var meshes = <AbstractMesh[]>meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\r\n            meshesOrMinMaxVector = Mesh.MinMax(meshes);\r\n            distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\r\n        } else {\r\n            //minMaxVector and distance\r\n            var minMaxVectorAndDistance = <any>meshesOrMinMaxVectorAndDistance;\r\n            meshesOrMinMaxVector = minMaxVectorAndDistance;\r\n            distance = minMaxVectorAndDistance.distance;\r\n        }\r\n\r\n        this._target = Mesh.Center(meshesOrMinMaxVector);\r\n\r\n        if (!doNotUpdateMaxZ) {\r\n            this.maxZ = distance * 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     * Override Camera.createRigCamera\r\n     */\r\n    public createRigCamera(name: string, cameraIndex: number): Camera {\r\n        var alphaShift: number = 0;\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\r\n                break;\r\n        }\r\n        var rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\r\n        rigCam._cameraRigParams = {};\r\n        rigCam.isRigCamera = true;\r\n        rigCam.rigParent = this;\r\n        rigCam.upVector = this.upVector;\r\n        return rigCam;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @override\r\n     * Override Camera._updateRigCameras\r\n     */\r\n    public _updateRigCameras() {\r\n        var camLeft = <ArcRotateCamera>this._rigCameras[0];\r\n        var camRight = <ArcRotateCamera>this._rigCameras[1];\r\n\r\n        camLeft.beta = camRight.beta = this.beta;\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n            case Camera.RIG_MODE_VR:\r\n                camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n                camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\r\n                camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCamera\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}