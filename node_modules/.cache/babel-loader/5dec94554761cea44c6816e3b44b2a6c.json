{"ast":null,"code":"/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\nvar NodeMaterialBuildStateSharedData =\n/** @class */\nfunction () {\n  /** Creates a new shared data */\n  function NodeMaterialBuildStateSharedData() {\n    /**\r\n    * Gets the list of emitted varyings\r\n    */\n    this.temps = new Array();\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\n\n    this.varyings = new Array();\n    /**\r\n     * Gets the varying declaration string\r\n     */\n\n    this.varyingDeclaration = \"\";\n    /**\r\n     * Input blocks\r\n     */\n\n    this.inputBlocks = new Array();\n    /**\r\n     * Input blocks\r\n     */\n\n    this.textureBlocks = new Array();\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\n\n    this.bindableBlocks = new Array();\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\n\n    this.blocksWithFallbacks = new Array();\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\n\n    this.blocksWithDefines = new Array();\n    /**\r\n    * List of blocks that can provide a repeatable content\r\n    */\n\n    this.repeatableContentBlocks = new Array();\n    /**\r\n    * List of blocks that can provide a dynamic list of uniforms\r\n    */\n\n    this.dynamicUniformBlocks = new Array();\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\n\n    this.blockingBlocks = new Array();\n    /**\r\n     * Gets the list of animated inputs\r\n     */\n\n    this.animatedInputs = new Array();\n    /** List of emitted variables */\n\n    this.variableNames = {};\n    /** List of emitted defines */\n\n    this.defineNames = {};\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\n\n    this.hints = {\n      needWorldViewMatrix: false,\n      needWorldViewProjectionMatrix: false,\n      needAlphaBlending: false,\n      needAlphaTesting: false\n    };\n    /**\r\n     * List of compilation checks\r\n     */\n\n    this.checks = {\n      emitVertex: false,\n      emitFragment: false,\n      notConnectedNonOptionalInputs: new Array()\n    };\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\n\n    this.allowEmptyVertexProgram = false; // Exclude usual attributes from free variable names\n\n    this.variableNames[\"position\"] = 0;\n    this.variableNames[\"normal\"] = 0;\n    this.variableNames[\"tangent\"] = 0;\n    this.variableNames[\"uv\"] = 0;\n    this.variableNames[\"uv2\"] = 0;\n    this.variableNames[\"uv3\"] = 0;\n    this.variableNames[\"uv4\"] = 0;\n    this.variableNames[\"uv4\"] = 0;\n    this.variableNames[\"uv5\"] = 0;\n    this.variableNames[\"uv6\"] = 0;\n    this.variableNames[\"color\"] = 0;\n    this.variableNames[\"matricesIndices\"] = 0;\n    this.variableNames[\"matricesWeights\"] = 0;\n    this.variableNames[\"matricesIndicesExtra\"] = 0;\n    this.variableNames[\"matricesWeightsExtra\"] = 0;\n    this.variableNames[\"diffuseBase\"] = 0;\n    this.variableNames[\"specularBase\"] = 0;\n    this.variableNames[\"worldPos\"] = 0;\n    this.variableNames[\"shadow\"] = 0;\n    this.variableNames[\"view\"] = 0; // Exclude known varyings\n\n    this.variableNames[\"vTBN\"] = 0; // Exclude defines\n\n    this.defineNames[\"MAINUV0\"] = 0;\n    this.defineNames[\"MAINUV1\"] = 0;\n    this.defineNames[\"MAINUV2\"] = 0;\n    this.defineNames[\"MAINUV3\"] = 0;\n    this.defineNames[\"MAINUV4\"] = 0;\n    this.defineNames[\"MAINUV5\"] = 0;\n    this.defineNames[\"MAINUV6\"] = 0;\n    this.defineNames[\"MAINUV7\"] = 0;\n  }\n  /**\r\n   * Emits console errors and exceptions if there is a failing check\r\n   */\n\n\n  NodeMaterialBuildStateSharedData.prototype.emitErrors = function () {\n    var errorMessage = \"\";\n\n    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\n      errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\r\\n\";\n    }\n\n    if (!this.checks.emitFragment) {\n      errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\r\\n\";\n    }\n\n    for (var _i = 0, _a = this.checks.notConnectedNonOptionalInputs; _i < _a.length; _i++) {\n      var notConnectedInput = _a[_i];\n      errorMessage += \"input \" + notConnectedInput.name + \" from block \" + notConnectedInput.ownerBlock.name + \"[\" + notConnectedInput.ownerBlock.getClassName() + \"] is not connected and is not optional.\\r\\n\";\n    }\n\n    if (errorMessage) {\n      throw \"Build of NodeMaterial failed:\\r\\n\" + errorMessage;\n    }\n  };\n\n  return NodeMaterialBuildStateSharedData;\n}();\n\nexport { NodeMaterialBuildStateSharedData };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Node/nodeMaterialBuildStateSharedData.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialConnectionPoint } from './nodeMaterialBlockConnectionPoint';\r\nimport { NodeMaterialBlock } from './nodeMaterialBlock';\r\nimport { InputBlock } from './Blocks/Input/inputBlock';\r\nimport { TextureBlock } from './Blocks/Dual/textureBlock';\r\nimport { ReflectionTextureBaseBlock } from './Blocks/Dual/reflectionTextureBaseBlock';\r\nimport { RefractionBlock } from './Blocks/PBR/refractionBlock';\r\nimport { CurrentScreenBlock } from './Blocks/Dual/currentScreenBlock';\r\nimport { ParticleTextureBlock } from './Blocks/Particle/particleTextureBlock';\r\nimport { Scene } from '../../scene';\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n    * Gets the list of emitted varyings\r\n    */\r\n    public temps = new Array<string>();\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings = new Array<string>();\r\n\r\n    /**\r\n     * Gets the varying declaration string\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks = new Array<TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n    * List of blocks that can provide a repeatable content\r\n    */\r\n    public repeatableContentBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n    * List of blocks that can provide a dynamic list of uniforms\r\n    */\r\n    public dynamicUniformBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>()\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\r\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\r\\n\";\r\n        }\r\n        for (var notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\r\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeMaterial failed:\\r\\n\" + errorMessage;\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}