{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar ArcRotateCameraPointersInput =\n/** @class */\nfunction (_super) {\n  __extends(ArcRotateCameraPointersInput, _super);\n\n  function ArcRotateCameraPointersInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\n\n\n    _this.buttons = [0, 1, 2];\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\n\n    _this.angularSensibilityX = 1000.0;\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\n\n    _this.angularSensibilityY = 1000.0;\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\n\n    _this.pinchPrecision = 12.0;\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\n\n    _this.pinchDeltaPercentage = 0;\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\n\n    _this.useNaturalPinchZoom = false;\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\n\n    _this.panningSensibility = 1000.0;\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\n\n    _this.multiTouchPanning = true;\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\n\n    _this.multiTouchPanAndZoom = true;\n    /**\r\n     * Revers pinch action direction.\r\n     */\n\n    _this.pinchInwards = true;\n    _this._isPanClick = false;\n    _this._twoFingerActivityCount = 0;\n    _this._isPinching = false;\n    return _this;\n  }\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.getClassName = function () {\n    return \"ArcRotateCameraPointersInput\";\n  };\n  /**\r\n   * Called on pointer POINTERMOVE event if only a single touch is active.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onTouch = function (point, offsetX, offsetY) {\n    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {\n      this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n      this.camera.inertialPanningY += offsetY / this.panningSensibility;\n    } else {\n      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n    }\n  };\n  /**\r\n   * Called on pointer POINTERDOUBLETAP event.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onDoubleTap = function (type) {\n    if (this.camera.useInputToRestoreState) {\n      this.camera.restoreState();\n    }\n  };\n  /**\r\n   * Called on pointer POINTERMOVE event if multiple touches are active.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onMultiTouch = function (pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n\n    var direction = this.pinchInwards ? 1 : -1;\n\n    if (this.multiTouchPanAndZoom) {\n      if (this.useNaturalPinchZoom) {\n        this.camera.radius = this.camera.radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\n      } else if (this.pinchDeltaPercentage) {\n        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * this.camera.radius * this.pinchDeltaPercentage;\n      } else {\n        this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n      }\n\n      if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n        var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n        var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n        this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n        this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n      }\n    } else {\n      this._twoFingerActivityCount++;\n      var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);\n      var pinchDistance = Math.sqrt(pinchSquaredDistance);\n\n      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(pinchDistance - previousPinchDistance) > this.camera.pinchToPanMaxDistance) {\n        // Since pinch has not been active long, assume we intend to zoom.\n        if (this.pinchDeltaPercentage) {\n          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * this.camera.radius * this.pinchDeltaPercentage;\n        } else {\n          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * direction * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n        } // Since we are pinching, remain pinching on next iteration.\n\n\n        this._isPinching = true;\n      } else {\n        // Pause between pinch starting and moving implies not a zoom event.\n        // Pan instead.\n        if (this.panningSensibility !== 0 && this.multiTouchPanning && multiTouchPanPosition && previousMultiTouchPanPosition) {\n          var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n          var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n        }\n      }\n    }\n  };\n  /**\r\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n   * press.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonDown = function (evt) {\n    this._isPanClick = evt.button === this.camera._panningMouseButton;\n  };\n  /**\r\n   * Called each time a new POINTERUP event occurs. Ie, for each button\r\n   * release.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onButtonUp = function (evt) {\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n  /**\r\n   * Called when window becomes inactive.\r\n   */\n\n\n  ArcRotateCameraPointersInput.prototype.onLostFocus = function () {\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  };\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n\n  __decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\n\n  return ArcRotateCameraPointersInput;\n}(BaseCameraPointersInput);\n\nexport { ArcRotateCameraPointersInput };\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;","map":{"version":3,"sources":["../../../../sourceES6/core/Cameras/Inputs/arcRotateCameraPointersInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput\";\r\nimport { PointerTouch } from \"../../Events/pointerEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n    private _twoFingerActivityCount: number = 0;\r\n    private _isPinching: boolean = false;\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     */\r\n    protected onTouch(point: Nullable<PointerTouch>,\r\n                      offsetX: number,\r\n                      offsetY: number): void {\r\n        if (this.panningSensibility !== 0 &&\r\n          ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    protected onDoubleTap(type: string) {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     */\r\n    protected onMultiTouch(pointA: Nullable<PointerTouch>,\r\n                           pointB: Nullable<PointerTouch>,\r\n                           previousPinchSquaredDistance: number,\r\n                           pinchSquaredDistance: number,\r\n                           previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n                           multiTouchPanPosition: Nullable<PointerTouch>): void\r\n    {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        var direction = this.pinchInwards ? 1 : -1;\r\n\r\n        if (this.multiTouchPanAndZoom) {\r\n            if (this.useNaturalPinchZoom) {\r\n                this.camera.radius = this.camera.radius *\r\n                    Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\r\n            } else if (this.pinchDeltaPercentage) {\r\n                this.camera.inertialRadiusOffset +=\r\n                    (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *\r\n                    this.camera.radius * this.pinchDeltaPercentage;\r\n            }\r\n            else {\r\n                this.camera.inertialRadiusOffset +=\r\n                    (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                    (this.pinchPrecision * direction *\r\n                    (this.angularSensibilityX + this.angularSensibilityY) / 2);\r\n            }\r\n\r\n            if (this.panningSensibility !== 0 &&\r\n              previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n                var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n                var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n                this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n                this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n            }\r\n        } else {\r\n            this._twoFingerActivityCount++;\r\n            var previousPinchDistance = Math.sqrt(previousPinchSquaredDistance);\r\n            var pinchDistance = Math.sqrt(pinchSquaredDistance);\r\n            if (this._isPinching ||\r\n              (this._twoFingerActivityCount < 20 &&\r\n               Math.abs(pinchDistance - previousPinchDistance) >\r\n               this.camera.pinchToPanMaxDistance)) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                if (this.pinchDeltaPercentage) {\r\n                    this.camera.inertialRadiusOffset +=\r\n                      (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 *\r\n                      this.camera.radius * this.pinchDeltaPercentage;\r\n                } else {\r\n                    this.camera.inertialRadiusOffset +=\r\n                        (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                        (this.pinchPrecision * direction *\r\n                        (this.angularSensibilityX + this.angularSensibilityY) / 2);\r\n                }\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event.\r\n                // Pan instead.\r\n                if (this.panningSensibility !== 0 && this.multiTouchPanning &&\r\n                  multiTouchPanPosition && previousMultiTouchPanPosition) {\r\n                    var moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n                    var moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n                    this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n                    this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     */\r\n    protected onButtonDown(evt: PointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     */\r\n    protected onButtonUp(evt: PointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    protected onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] =\r\n  ArcRotateCameraPointersInput;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}