{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Scene } from \"../scene\";\nimport { PhysicsEngine } from \"./physicsEngine\";\nimport { PhysicsJoint } from \"./physicsJoint\";\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\n\nScene.prototype.getPhysicsEngine = function () {\n  return this._physicsEngine;\n};\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n * @return a boolean indicating if the physics engine was initialized\r\n */\n\n\nScene.prototype.enablePhysics = function (gravity, plugin) {\n  if (gravity === void 0) {\n    gravity = null;\n  }\n\n  if (this._physicsEngine) {\n    return true;\n  } // Register the component to the scene\n\n\n  var component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);\n\n  if (!component) {\n    component = new PhysicsEngineSceneComponent(this);\n\n    this._addComponent(component);\n  }\n\n  try {\n    this._physicsEngine = new PhysicsEngine(gravity, plugin);\n    this._physicsTimeAccumulator = 0;\n    return true;\n  } catch (e) {\n    Logger.Error(e.message);\n    return false;\n  }\n};\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\n\n\nScene.prototype.disablePhysicsEngine = function () {\n  if (!this._physicsEngine) {\n    return;\n  }\n\n  this._physicsEngine.dispose();\n\n  this._physicsEngine = null;\n};\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\n\n\nScene.prototype.isPhysicsEnabled = function () {\n  return this._physicsEngine !== undefined;\n};\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\n\n\nScene.prototype.deleteCompoundImpostor = function (compound) {\n  var mesh = compound.parts[0].mesh;\n\n  if (mesh.physicsImpostor) {\n    mesh.physicsImpostor.dispose();\n    mesh.physicsImpostor = null;\n  }\n};\n/** @hidden */\n\n\nScene.prototype._advancePhysicsEngineStep = function (step) {\n  if (this._physicsEngine) {\n    var subTime = this._physicsEngine.getSubTimeStep();\n\n    if (subTime > 0) {\n      this._physicsTimeAccumulator += step;\n\n      while (this._physicsTimeAccumulator > subTime) {\n        this.onBeforePhysicsObservable.notifyObservers(this);\n\n        this._physicsEngine._step(subTime / 1000);\n\n        this.onAfterPhysicsObservable.notifyObservers(this);\n        this._physicsTimeAccumulator -= subTime;\n      }\n    } else {\n      this.onBeforePhysicsObservable.notifyObservers(this);\n\n      this._physicsEngine._step(step / 1000);\n\n      this.onAfterPhysicsObservable.notifyObservers(this);\n    }\n  }\n};\n\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\n  get: function () {\n    return this._physicsImpostor;\n  },\n  set: function (value) {\n    var _this = this;\n\n    if (this._physicsImpostor === value) {\n      return;\n    }\n\n    if (this._disposePhysicsObserver) {\n      this.onDisposeObservable.remove(this._disposePhysicsObserver);\n    }\n\n    this._physicsImpostor = value;\n\n    if (value) {\n      this._disposePhysicsObserver = this.onDisposeObservable.add(function () {\n        // Physics\n        if (_this.physicsImpostor) {\n          _this.physicsImpostor.dispose();\n\n          _this.physicsImpostor = null;\n        }\n      });\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\n\nAbstractMesh.prototype.getPhysicsImpostor = function () {\n  return this.physicsImpostor;\n};\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\n\n\nAbstractMesh.prototype.applyImpulse = function (force, contactPoint) {\n  if (!this.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.applyImpulse(force, contactPoint);\n  return this;\n};\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\n\n\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {\n  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\n    return this;\n  }\n\n  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\n    mainPivot: pivot1,\n    connectedPivot: pivot2,\n    nativeParams: options\n  });\n  return this;\n};\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\n\n\nvar PhysicsEngineSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function PhysicsEngineSceneComponent(scene) {\n    var _this = this;\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\n\n\n    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;\n    this.scene = scene;\n    this.scene.onBeforePhysicsObservable = new Observable();\n    this.scene.onAfterPhysicsObservable = new Observable(); // Replace the function used to get the deterministic frame time\n\n    this.scene.getDeterministicFrameTime = function () {\n      if (_this.scene._physicsEngine) {\n        return _this.scene._physicsEngine.getTimeStep() * 1000;\n      }\n\n      return 1000.0 / 60.0;\n    };\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.register = function () {};\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\r\n   * Disposes the component and the associated ressources\r\n   */\n\n\n  PhysicsEngineSceneComponent.prototype.dispose = function () {\n    this.scene.onBeforePhysicsObservable.clear();\n    this.scene.onAfterPhysicsObservable.clear();\n\n    if (this.scene._physicsEngine) {\n      this.scene.disablePhysicsEngine();\n    }\n  };\n\n  return PhysicsEngineSceneComponent;\n}();\n\nexport { PhysicsEngineSceneComponent };","map":{"version":3,"sources":["../../../sourceES6/core/Physics/physicsEngineComponent.ts"],"names":[],"mappings":"AACA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,UAAT,QAAqC,oBAArC;AAGA,SAAS,YAAT,QAA6B,wBAA7B;AACA,SAA0B,uBAA1B,QAAyD,mBAAzD;AACA,SAAS,KAAT,QAAsB,UAAtB;AAIA,SAAS,aAAT,QAA8B,iBAA9B;AAEA,SAAS,YAAT,QAA6B,gBAA7B;AAoDA;;;;;AAIA,KAAK,CAAC,SAAN,CAAgB,gBAAhB,GAAmC,YAAA;AAC/B,SAAO,KAAK,cAAZ;AACH,CAFD;AAIA;;;;;;;;AAMA,KAAK,CAAC,SAAN,CAAgB,aAAhB,GAAgC,UAAS,OAAT,EAA4C,MAA5C,EAAyE;AAAhE,MAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,OAAA,GAAA,IAAA;AAAiC;;AACtE,MAAI,KAAK,cAAT,EAAyB;AACrB,WAAO,IAAP;AACH,GAHoG,CAKrG;;;AACA,MAAI,SAAS,GAAG,KAAK,aAAL,CAAmB,uBAAuB,CAAC,kBAA3C,CAAhB;;AACA,MAAI,CAAC,SAAL,EAAgB;AACZ,IAAA,SAAS,GAAG,IAAI,2BAAJ,CAAgC,IAAhC,CAAZ;;AACA,SAAK,aAAL,CAAmB,SAAnB;AACH;;AAED,MAAI;AACA,SAAK,cAAL,GAAsB,IAAI,aAAJ,CAAkB,OAAlB,EAA2B,MAA3B,CAAtB;AACA,SAAK,uBAAL,GAA+B,CAA/B;AACA,WAAO,IAAP;AACH,GAJD,CAIE,OAAO,CAAP,EAAU;AACR,IAAA,MAAM,CAAC,KAAP,CAAa,CAAC,CAAC,OAAf;AACA,WAAO,KAAP;AACH;AACJ,CApBD;AAsBA;;;;;AAGA,KAAK,CAAC,SAAN,CAAgB,oBAAhB,GAAuC,YAAA;AACnC,MAAI,CAAC,KAAK,cAAV,EAA0B;AACtB;AACH;;AAED,OAAK,cAAL,CAAoB,OAApB;;AACA,OAAK,cAAL,GAAsB,IAAtB;AACH,CAPD;AASA;;;;;;AAIA,KAAK,CAAC,SAAN,CAAgB,gBAAhB,GAAmC,YAAA;AAC/B,SAAO,KAAK,cAAL,KAAwB,SAA/B;AACH,CAFD;AAIA;;;;;;AAIA,KAAK,CAAC,SAAN,CAAgB,sBAAhB,GAAyC,UAAS,QAAT,EAAsB;AAC3D,MAAI,IAAI,GAAiB,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,IAA3C;;AAEA,MAAI,IAAI,CAAC,eAAT,EAA0B;AACtB,IAAA,IAAI,CAAC,eAAL,CAAqB,OAArB;AACA,IAAA,IAAI,CAAC,eAAL,GAAuB,IAAvB;AACH;AACJ,CAPD;AASA;;;AACA,KAAK,CAAC,SAAN,CAAgB,yBAAhB,GAA4C,UAAS,IAAT,EAAqB;AAC7D,MAAI,KAAK,cAAT,EAAyB;AACrB,QAAI,OAAO,GAAG,KAAK,cAAL,CAAoB,cAApB,EAAd;;AACA,QAAI,OAAO,GAAG,CAAd,EAAiB;AACb,WAAK,uBAAL,IAAgC,IAAhC;;AACA,aAAO,KAAK,uBAAL,GAA+B,OAAtC,EAA+C;AAC3C,aAAK,yBAAL,CAA+B,eAA/B,CAA+C,IAA/C;;AACA,aAAK,cAAL,CAAoB,KAApB,CAA0B,OAAO,GAAG,IAApC;;AACA,aAAK,wBAAL,CAA8B,eAA9B,CAA8C,IAA9C;AACA,aAAK,uBAAL,IAAgC,OAAhC;AACH;AACJ,KARD,MAQO;AACH,WAAK,yBAAL,CAA+B,eAA/B,CAA+C,IAA/C;;AACA,WAAK,cAAL,CAAoB,KAApB,CAA0B,IAAI,GAAG,IAAjC;;AACA,WAAK,wBAAL,CAA8B,eAA9B,CAA8C,IAA9C;AACH;AACJ;AACJ,CAjBD;;AA6DA,MAAM,CAAC,cAAP,CAAsB,YAAY,CAAC,SAAnC,EAA8C,iBAA9C,EAAiE;AAC7D,EAAA,GAAG,EAAE,YAAA;AACD,WAAO,KAAK,gBAAZ;AACH,GAH4D;AAI7D,EAAA,GAAG,EAAE,UAA6B,KAA7B,EAA6D;AAA7D,QAAA,KAAA,GAAA,IAAA;;AACD,QAAI,KAAK,gBAAL,KAA0B,KAA9B,EAAqC;AACjC;AACH;;AACD,QAAI,KAAK,uBAAT,EAAkC;AAC9B,WAAK,mBAAL,CAAyB,MAAzB,CAAgC,KAAK,uBAArC;AACH;;AAED,SAAK,gBAAL,GAAwB,KAAxB;;AAEA,QAAI,KAAJ,EAAW;AACP,WAAK,uBAAL,GAA+B,KAAK,mBAAL,CAAyB,GAAzB,CAA6B,YAAA;AACxD;AACA,YAAI,KAAI,CAAC,eAAT,EAA0B;AACtB,UAAA,KAAI,CAAC,eAAL,CAAqB,OAArB;;AACA,UAAA,KAAI,CAAC,eAAL,GAAuB,IAAvB;AACH;AACJ,OAN8B,CAA/B;AAOH;AACJ,GAvB4D;AAwB7D,EAAA,UAAU,EAAE,IAxBiD;AAyB7D,EAAA,YAAY,EAAE;AAzB+C,CAAjE;AA4BA;;;;;;AAKA,YAAY,CAAC,SAAb,CAAuB,kBAAvB,GAA4C,YAAA;AACxC,SAAO,KAAK,eAAZ;AACH,CAFD;AAIA;;;;;;;;;AAOA,YAAY,CAAC,SAAb,CAAuB,YAAvB,GAAsC,UAAS,KAAT,EAAyB,YAAzB,EAA8C;AAChF,MAAI,CAAC,KAAK,eAAV,EAA2B;AACvB,WAAO,IAAP;AACH;;AACD,OAAK,eAAL,CAAqB,YAArB,CAAkC,KAAlC,EAAyC,YAAzC;AACA,SAAO,IAAP;AACH,CAND;AAQA;;;;;;;;;;;AASA,YAAY,CAAC,SAAb,CAAuB,kBAAvB,GAA4C,UAAS,SAAT,EAA0B,MAA1B,EAA2C,MAA3C,EAA4D,OAA5D,EAAyE;AACjH,MAAI,CAAC,KAAK,eAAN,IAAyB,CAAC,SAAS,CAAC,eAAxC,EAAyD;AACrD,WAAO,IAAP;AACH;;AACD,OAAK,eAAL,CAAqB,WAArB,CAAiC,SAAS,CAAC,eAA3C,EAA4D,YAAY,CAAC,UAAzE,EAAqF;AACjF,IAAA,SAAS,EAAE,MADsE;AAEjF,IAAA,cAAc,EAAE,MAFiE;AAGjF,IAAA,YAAY,EAAE;AAHmE,GAArF;AAKA,SAAO,IAAP;AACH,CAVD;AAYA;;;;;AAGA,IAAA,2BAAA;AAAA;AAAA,YAAA;AAWI;;;;AAIA,WAAA,2BAAA,CAAY,KAAZ,EAAwB;AAAxB,QAAA,KAAA,GAAA,IAAA;AAdA;;;;;AAGgB,SAAA,IAAA,GAAO,uBAAuB,CAAC,kBAA/B;AAYZ,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,KAAL,CAAW,yBAAX,GAAuC,IAAI,UAAJ,EAAvC;AACA,SAAK,KAAL,CAAW,wBAAX,GAAsC,IAAI,UAAJ,EAAtC,CAHoB,CAKpB;;AACA,SAAK,KAAL,CAAW,yBAAX,GAAuC,YAAA;AACnC,UAAI,KAAI,CAAC,KAAL,CAAW,cAAf,EAA+B;AAC3B,eAAO,KAAI,CAAC,KAAL,CAAW,cAAX,CAA0B,WAA1B,KAA0C,IAAjD;AACH;;AAED,aAAO,SAAS,IAAhB;AACH,KAND;AAOH;AAED;;;;;AAGO,EAAA,2BAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA,CACC,CADM;AAGP;;;;;;AAIO,EAAA,2BAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACI;AACH,GAFM;AAIP;;;;;AAGO,EAAA,2BAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,SAAK,KAAL,CAAW,yBAAX,CAAqC,KAArC;AACA,SAAK,KAAL,CAAW,wBAAX,CAAoC,KAApC;;AAEA,QAAI,KAAK,KAAL,CAAW,cAAf,EAA+B;AAC3B,WAAK,KAAL,CAAW,oBAAX;AACH;AACJ,GAPM;;AAQX,SAAA,2BAAA;AAAC,CAvDD,EAAA","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport { Node } from \"../node\";\r\n\r\nimport { IPhysicsEngine, IPhysicsEnginePlugin } from \"./IPhysicsEngine\";\r\nimport { PhysicsEngine } from \"./physicsEngine\";\r\nimport { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @hidden */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine\r\n         * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n         * @return a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity: Nullable<Vector3>, plugin?: IPhysicsEnginePlugin): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n        * An event triggered when physic simulation is about to be run\r\n        */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function(): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to OimoJS.\r\n * @return a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function(gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePlugin): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        this._physicsEngine = new PhysicsEngine(gravity, plugin);\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function(): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function(): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function(compound: any): void {\r\n    var mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/** @hidden */\r\nScene.prototype._advancePhysicsEngineStep = function(step: number) {\r\n    if (this._physicsEngine) {\r\n        let subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/physics_engine\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @hidden */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function(this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function(this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/physics_engine\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function(): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function(force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}