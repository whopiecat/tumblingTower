{"ast":null,"code":"import { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { VertexBuffer } from \"../buffer\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { PositionNormalVertex } from '../../Maths/math.vertexFormat';\n\nMesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\n  var options = {\n    position: position,\n    normal: normal,\n    size: size,\n    angle: angle\n  };\n  return DecalBuilder.CreateDecal(name, sourceMesh, options);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar DecalBuilder =\n/** @class */\nfunction () {\n  function DecalBuilder() {}\n  /**\r\n   * Creates a decal mesh.\r\n   * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n   * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n   * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n   * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n   * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n   * @param name defines the name of the mesh\r\n   * @param sourceMesh defines the mesh where the decal must be applied\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the decal mesh\r\n   * @see https://doc.babylonjs.com/how_to/decals\r\n   */\n\n\n  DecalBuilder.CreateDecal = function (name, sourceMesh, options) {\n    var indices = sourceMesh.getIndices();\n    var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n    var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n    var position = options.position || Vector3.Zero();\n    var normal = options.normal || Vector3.Up();\n    var size = options.size || Vector3.One();\n    var angle = options.angle || 0; // Getting correct rotation\n\n    if (!normal) {\n      var target = new Vector3(0, 0, 1);\n      var camera = sourceMesh.getScene().activeCamera;\n      var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n      normal = camera.globalPosition.subtract(cameraWorldTarget);\n    }\n\n    var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n    var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n    var pitch = Math.atan2(normal.y, len); // Matrix\n\n    var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    var meshWorldMatrix = sourceMesh.getWorldMatrix();\n    var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    vertexData.positions = [];\n    vertexData.normals = [];\n    vertexData.uvs = [];\n    var currentVertexDataIndex = 0;\n\n    var extractDecalVector3 = function (indexId) {\n      var result = new PositionNormalVertex();\n\n      if (!indices || !positions || !normals) {\n        return result;\n      }\n\n      var vertexId = indices[indexId];\n      result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]); // Send vector to decal local world\n\n      result.position = Vector3.TransformCoordinates(result.position, transformMatrix); // Get normal\n\n      result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n      result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\n      return result;\n    }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n\n\n    var clip = function (vertices, axis) {\n      if (vertices.length === 0) {\n        return vertices;\n      }\n\n      var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n\n      var clipVertices = function (v0, v1) {\n        var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n        return new PositionNormalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));\n      };\n\n      var result = new Array();\n\n      for (var index = 0; index < vertices.length; index += 3) {\n        var v1Out;\n        var v2Out;\n        var v3Out;\n        var total = 0;\n        var nV1 = null;\n        var nV2 = null;\n        var nV3 = null;\n        var nV4 = null;\n        var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n        var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n        var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0;\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            result.push(vertices[index]);\n            result.push(vertices[index + 1]);\n            result.push(vertices[index + 2]);\n            break;\n\n          case 1:\n            if (v1Out) {\n              nV1 = vertices[index + 1];\n              nV2 = vertices[index + 2];\n              nV3 = clipVertices(vertices[index], nV1);\n              nV4 = clipVertices(vertices[index], nV2);\n            }\n\n            if (v2Out) {\n              nV1 = vertices[index];\n              nV2 = vertices[index + 2];\n              nV3 = clipVertices(vertices[index + 1], nV1);\n              nV4 = clipVertices(vertices[index + 1], nV2);\n              result.push(nV3);\n              result.push(nV2.clone());\n              result.push(nV1.clone());\n              result.push(nV2.clone());\n              result.push(nV3.clone());\n              result.push(nV4);\n              break;\n            }\n\n            if (v3Out) {\n              nV1 = vertices[index];\n              nV2 = vertices[index + 1];\n              nV3 = clipVertices(vertices[index + 2], nV1);\n              nV4 = clipVertices(vertices[index + 2], nV2);\n            }\n\n            if (nV1 && nV2 && nV3 && nV4) {\n              result.push(nV1.clone());\n              result.push(nV2.clone());\n              result.push(nV3);\n              result.push(nV4);\n              result.push(nV3.clone());\n              result.push(nV2.clone());\n            }\n\n            break;\n\n          case 2:\n            if (!v1Out) {\n              nV1 = vertices[index].clone();\n              nV2 = clipVertices(nV1, vertices[index + 1]);\n              nV3 = clipVertices(nV1, vertices[index + 2]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            if (!v2Out) {\n              nV1 = vertices[index + 1].clone();\n              nV2 = clipVertices(nV1, vertices[index + 2]);\n              nV3 = clipVertices(nV1, vertices[index]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            if (!v3Out) {\n              nV1 = vertices[index + 2].clone();\n              nV2 = clipVertices(nV1, vertices[index]);\n              nV3 = clipVertices(nV1, vertices[index + 1]);\n              result.push(nV1);\n              result.push(nV2);\n              result.push(nV3);\n            }\n\n            break;\n\n          case 3:\n            break;\n        }\n      }\n\n      return result;\n    };\n\n    for (var index = 0; index < indices.length; index += 3) {\n      var faceVertices = new Array();\n      faceVertices.push(extractDecalVector3(index));\n      faceVertices.push(extractDecalVector3(index + 1));\n      faceVertices.push(extractDecalVector3(index + 2)); // Clip\n\n      faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\n      faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\n      faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\n      faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\n\n      if (faceVertices.length === 0) {\n        continue;\n      } // Add UVs and get back to world\n\n\n      for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n        var vertex = faceVertices[vIndex]; //TODO check for Int32Array | Uint32Array | Uint16Array\n\n        vertexData.indices.push(currentVertexDataIndex);\n        vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n        vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n        vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n        vertexData.uvs.push(0.5 + vertex.position.y / size.y);\n        currentVertexDataIndex++;\n      }\n    } // Return mesh\n\n\n    var decal = new Mesh(name, sourceMesh.getScene());\n    vertexData.applyToMesh(decal);\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n    return decal;\n  };\n\n  return DecalBuilder;\n}();\n\nexport { DecalBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/decalBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, IndicesArray } from \"../../types\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { AbstractMesh } from \"../abstractMesh\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { PositionNormalVertex } from '../../Maths/math.vertexFormat';\r\n\r\nMesh.CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    var options = {\r\n        position: position,\r\n        normal: normal,\r\n        size: size,\r\n        angle: angle\r\n    };\r\n\r\n    return DecalBuilder.CreateDecal(name, sourceMesh, options);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class DecalBuilder {\r\n    /**\r\n     * Creates a decal mesh.\r\n     * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n     * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n     * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n     * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n     * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n     * @param name defines the name of the mesh\r\n     * @param sourceMesh defines the mesh where the decal must be applied\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the decal mesh\r\n     * @see https://doc.babylonjs.com/how_to/decals\r\n     */\r\n    public static CreateDecal(name: string, sourceMesh: AbstractMesh, options: { position?: Vector3, normal?: Vector3, size?: Vector3, angle?: number }): Mesh {\r\n        var indices = <IndicesArray>sourceMesh.getIndices();\r\n        var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n        var position = options.position || Vector3.Zero();\r\n        var normal = options.normal || Vector3.Up();\r\n        var size = options.size || Vector3.One();\r\n        var angle = options.angle || 0;\r\n\r\n        // Getting correct rotation\r\n        if (!normal) {\r\n            var target = new Vector3(0, 0, 1);\r\n            var camera = <Camera>sourceMesh.getScene().activeCamera;\r\n            var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n            normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n        }\r\n\r\n        var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n        var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n        var pitch = Math.atan2(normal.y, len);\r\n\r\n        // Matrix\r\n        var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n        var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n        var meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\r\n\r\n        var vertexData = new VertexData();\r\n        vertexData.indices = [];\r\n        vertexData.positions = [];\r\n        vertexData.normals = [];\r\n        vertexData.uvs = [];\r\n\r\n        var currentVertexDataIndex = 0;\r\n\r\n        var extractDecalVector3 = (indexId: number): PositionNormalVertex => {\r\n            var result = new PositionNormalVertex();\r\n            if (!indices || !positions || !normals) {\r\n                return result;\r\n            }\r\n\r\n            var vertexId = indices[indexId];\r\n            result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n\r\n            // Send vector to decal local world\r\n            result.position = Vector3.TransformCoordinates(result.position, transformMatrix);\r\n\r\n            // Get normal\r\n            result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n            result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\r\n\r\n            return result;\r\n        }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n        var clip = (vertices: PositionNormalVertex[], axis: Vector3): PositionNormalVertex[] => {\r\n            if (vertices.length === 0) {\r\n                return vertices;\r\n            }\r\n\r\n            var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n            var clipVertices = (v0: PositionNormalVertex, v1: PositionNormalVertex): PositionNormalVertex => {\r\n                var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n                return new PositionNormalVertex(\r\n                    Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                    Vector3.Lerp(v0.normal, v1.normal, clipFactor)\r\n                );\r\n            };\r\n            var result = new Array<PositionNormalVertex>();\r\n\r\n            for (var index = 0; index < vertices.length; index += 3) {\r\n                var v1Out: boolean;\r\n                var v2Out: boolean;\r\n                var v3Out: boolean;\r\n                var total = 0;\r\n                let nV1: Nullable<PositionNormalVertex> = null;\r\n                let nV2: Nullable<PositionNormalVertex> = null;\r\n                let nV3: Nullable<PositionNormalVertex> = null;\r\n                let nV4: Nullable<PositionNormalVertex> = null;\r\n\r\n                var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n                var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n                var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n                v1Out = d1 > 0;\r\n                v2Out = d2 > 0;\r\n                v3Out = d3 > 0;\r\n\r\n                total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n                switch (total) {\r\n                    case 0:\r\n                        result.push(vertices[index]);\r\n                        result.push(vertices[index + 1]);\r\n                        result.push(vertices[index + 2]);\r\n                        break;\r\n                    case 1:\r\n\r\n                        if (v1Out) {\r\n                            nV1 = vertices[index + 1];\r\n                            nV2 = vertices[index + 2];\r\n                            nV3 = clipVertices(vertices[index], nV1);\r\n                            nV4 = clipVertices(vertices[index], nV2);\r\n                        }\r\n\r\n                        if (v2Out) {\r\n                            nV1 = vertices[index];\r\n                            nV2 = vertices[index + 2];\r\n                            nV3 = clipVertices(vertices[index + 1], nV1);\r\n                            nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                            result.push(nV3);\r\n                            result.push(nV2.clone());\r\n                            result.push(nV1.clone());\r\n\r\n                            result.push(nV2.clone());\r\n                            result.push(nV3.clone());\r\n                            result.push(nV4);\r\n                            break;\r\n                        }\r\n                        if (v3Out) {\r\n                            nV1 = vertices[index];\r\n                            nV2 = vertices[index + 1];\r\n                            nV3 = clipVertices(vertices[index + 2], nV1);\r\n                            nV4 = clipVertices(vertices[index + 2], nV2);\r\n                        }\r\n\r\n                        if (nV1 && nV2 && nV3 && nV4) {\r\n                            result.push(nV1.clone());\r\n                            result.push(nV2.clone());\r\n                            result.push(nV3);\r\n\r\n                            result.push(nV4);\r\n                            result.push(nV3.clone());\r\n                            result.push(nV2.clone());\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        if (!v1Out) {\r\n                            nV1 = vertices[index].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                            nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        if (!v2Out) {\r\n                            nV1 = vertices[index + 1].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                            nV3 = clipVertices(nV1, vertices[index]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        if (!v3Out) {\r\n                            nV1 = vertices[index + 2].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index]);\r\n                            nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        break;\r\n                    case 3:\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        };\r\n        for (var index = 0; index < indices.length; index += 3) {\r\n            var faceVertices = new Array<PositionNormalVertex>();\r\n\r\n            faceVertices.push(extractDecalVector3(index));\r\n            faceVertices.push(extractDecalVector3(index + 1));\r\n            faceVertices.push(extractDecalVector3(index + 2));\r\n\r\n            // Clip\r\n            faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\r\n            faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\r\n            faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\r\n            faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\r\n            faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\r\n            faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\r\n\r\n            if (faceVertices.length === 0) {\r\n                continue;\r\n            }\r\n\r\n            // Add UVs and get back to world\r\n            for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                var vertex = faceVertices[vIndex];\r\n\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n                vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                (<number[]>vertexData.uvs).push(0.5 + vertex.position.y / size.y);\r\n\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n\r\n        // Return mesh\r\n        var decal = new Mesh(name, sourceMesh.getScene());\r\n        vertexData.applyToMesh(decal);\r\n\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n\r\n        return decal;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}