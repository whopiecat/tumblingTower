{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { Color4 } from \"../Maths/math.color\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { SubMesh } from \"../Meshes/subMesh\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Tools } from \"../Misc/tools\";\nimport { Tags } from \"../Misc/tags\";\nimport { extractMinAndMax } from \"../Maths/math.functions\";\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\n\nvar Geometry =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new geometry\r\n   * @param id defines the unique ID\r\n   * @param scene defines the hosting scene\r\n   * @param vertexData defines the VertexData used to get geometry data\r\n   * @param updatable defines if geometry must be updatable (false by default)\r\n   * @param mesh defines the mesh that will be associated with the geometry\r\n   */\n  function Geometry(id, scene, vertexData, updatable, mesh) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (mesh === void 0) {\n      mesh = null;\n    }\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\n\n\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /**\r\n     * If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\n\n    this.useBoundingInfoFromGeometry = false;\n    this.id = id;\n    this.uniqueId = scene.getUniqueId();\n    this._engine = scene.getEngine();\n    this._meshes = [];\n    this._scene = scene; //Init vertex buffer cache\n\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable; // vertexData\n\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n      this._indices = [];\n    }\n\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    } // applyToMesh\n\n\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n\n  Object.defineProperty(Geometry.prototype, \"boundingBias\", {\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\n    get: function () {\n      return this._boundingBias;\n    },\n\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\n    set: function (value) {\n      if (this._boundingBias) {\n        this._boundingBias.copyFrom(value);\n      } else {\n        this._boundingBias = value.clone();\n      }\n\n      this._updateBoundingInfo(true, null);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Static function used to attach a new empty geometry to a mesh\r\n   * @param mesh defines the mesh to attach the geometry to\r\n   * @returns the new Geometry\r\n   */\n\n  Geometry.CreateGeometryForMesh = function (mesh) {\n    var geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"meshes\", {\n    /** Get the list of meshes using this geometry */\n    get: function () {\n      return this._meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Geometry.prototype, \"extend\", {\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\n    get: function () {\n      return this._extend;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the hosting scene\r\n   * @returns the hosting Scene\r\n   */\n\n  Geometry.prototype.getScene = function () {\n    return this._scene;\n  };\n  /**\r\n   * Gets the hosting engine\r\n   * @returns the hosting Engine\r\n   */\n\n\n  Geometry.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Defines if the geometry is ready to use\r\n   * @returns true if the geometry is ready to be used\r\n   */\n\n\n  Geometry.prototype.isReady = function () {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  };\n\n  Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\n    get: function () {\n      for (var index = 0; index < this._meshes.length; index++) {\n        if (!this._meshes[index].doNotSerialize) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  Geometry.prototype._rebuild = function () {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    } // Index buffer\n\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n    } // Vertex buffers\n\n\n    for (var key in this._vertexBuffers) {\n      var vertexBuffer = this._vertexBuffers[key];\n\n      vertexBuffer._rebuild();\n    }\n  };\n  /**\r\n   * Affects all geometry data in one call\r\n   * @param vertexData defines the geometry data\r\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n   */\n\n\n  Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n    this.notifyUpdate();\n  };\n  /**\r\n   * Set specific vertex data\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the vertex data to use\r\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n   */\n\n\n  Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n\n    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n    this.setVerticesBuffer(buffer);\n  };\n  /**\r\n   * Removes a specific vertex data\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   */\n\n\n  Geometry.prototype.removeVerticesData = function (kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n\n      delete this._vertexBuffers[kind];\n    }\n  };\n  /**\r\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n   * @param buffer defines the vertex buffer to use\r\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n   */\n\n\n  Geometry.prototype.setVerticesBuffer = function (buffer, totalVertices) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    var kind = buffer.getKind();\n\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    this._vertexBuffers[kind] = buffer;\n\n    if (kind === VertexBuffer.PositionKind) {\n      var data = buffer.getData();\n\n      if (totalVertices != null) {\n        this._totalVertices = totalVertices;\n      } else {\n        if (data != null) {\n          this._totalVertices = data.length / (buffer.byteStride / 4);\n        }\n      }\n\n      this._updateExtend(data);\n\n      this._resetPointsArrayCache();\n\n      var meshes = this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        var mesh = meshes[index];\n        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false);\n\n        mesh.computeWorldMatrix(true);\n      }\n    }\n\n    this.notifyUpdate(kind);\n\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n    }\n  };\n  /**\r\n   * Update a specific vertex buffer\r\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n   * It will do nothing if the buffer is not updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the data to use\r\n   * @param offset defines the offset in the target buffer where to store the data\r\n   * @param useBytes set to true if the offset is in bytes\r\n   */\n\n\n  Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset, useBytes) {\n    if (useBytes === void 0) {\n      useBytes = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n    this.notifyUpdate(kind);\n  };\n  /**\r\n   * Update a specific vertex buffer\r\n   * This function will create a new buffer if the current one is not updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param data defines the data to use\r\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n   */\n\n\n  Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\n    if (updateExtends === void 0) {\n      updateExtends = false;\n    }\n\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return;\n    }\n\n    vertexBuffer.update(data);\n\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n\n    this.notifyUpdate(kind);\n  };\n\n  Geometry.prototype._updateBoundingInfo = function (updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n\n    this._resetPointsArrayCache();\n\n    if (updateExtends) {\n      var meshes = this._meshes;\n\n      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n        var mesh = meshes_1[_i];\n\n        if (mesh._boundingInfo) {\n          mesh._boundingInfo.reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n\n        var subMeshes = mesh.subMeshes;\n\n        for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {\n          var subMesh = subMeshes_1[_a];\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._bind = function (effect, indexToBind) {\n    if (!effect) {\n      return;\n    }\n\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n\n    var vbs = this.getVertexBuffers();\n\n    if (!vbs) {\n      return;\n    }\n\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect);\n\n      return;\n    } // Using VAO\n\n\n    if (!this._vertexArrayObjects[effect.key]) {\n      this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect);\n    }\n\n    this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);\n  };\n  /**\r\n   * Gets total number of vertices\r\n   * @returns the total number of vertices\r\n   */\n\n\n  Geometry.prototype.getTotalVertices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._totalVertices;\n  };\n  /**\r\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n   * @returns a float array containing vertex data\r\n   */\n\n\n  Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n    var vertexBuffer = this.getVertexBuffer(kind);\n\n    if (!vertexBuffer) {\n      return null;\n    }\n\n    var data = vertexBuffer.getData();\n\n    if (!data) {\n      return null;\n    }\n\n    var tightlyPackedByteStride = vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(vertexBuffer.type);\n    var count = this._totalVertices * vertexBuffer.getSize();\n\n    if (vertexBuffer.type !== VertexBuffer.FLOAT || vertexBuffer.byteStride !== tightlyPackedByteStride) {\n      var copy_1 = [];\n      vertexBuffer.forEach(count, function (value) {\n        return copy_1.push(value);\n      });\n      return copy_1;\n    }\n\n    if (!(data instanceof Array || data instanceof Float32Array) || vertexBuffer.byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        var offset = vertexBuffer.byteOffset / 4;\n        return Tools.Slice(data, offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, vertexBuffer.byteOffset, count);\n      } else {\n        var offset = data.byteOffset + vertexBuffer.byteOffset;\n\n        if (forceCopy || copyWhenShared && this._meshes.length !== 1) {\n          var result = new Float32Array(count);\n          var source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        } // Portect against bad data\n\n\n        var remainder = offset % 4;\n\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n\n    if (forceCopy || copyWhenShared && this._meshes.length !== 1) {\n      return Tools.Slice(data);\n    }\n\n    return data;\n  };\n  /**\r\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns true if the vertex buffer with the specified kind is updatable\r\n   */\n\n\n  Geometry.prototype.isVertexBufferUpdatable = function (kind) {\n    var vb = this._vertexBuffers[kind];\n\n    if (!vb) {\n      return false;\n    }\n\n    return vb.isUpdatable();\n  };\n  /**\r\n   * Gets a specific vertex buffer\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns a VertexBuffer\r\n   */\n\n\n  Geometry.prototype.getVertexBuffer = function (kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers[kind];\n  };\n  /**\r\n   * Returns all vertex buffers\r\n   * @return an object holding all vertex buffers indexed by kind\r\n   */\n\n\n  Geometry.prototype.getVertexBuffers = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._vertexBuffers;\n  };\n  /**\r\n   * Gets a boolean indicating if specific vertex buffer is present\r\n   * @param kind defines the data kind (Position, normal, etc...)\r\n   * @returns true if data is present\r\n   */\n\n\n  Geometry.prototype.isVerticesDataPresent = function (kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n\n      return false;\n    }\n\n    return this._vertexBuffers[kind] !== undefined;\n  };\n  /**\r\n   * Gets a list of all attached data kinds (Position, normal, etc...)\r\n   * @returns a list of string containing all kinds\r\n   */\n\n\n  Geometry.prototype.getVerticesDataKinds = function () {\n    var result = [];\n    var kind;\n\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Update index buffer\r\n   * @param indices defines the indices to store in the index buffer\r\n   * @param offset defines the offset in the target buffer where to store the data\r\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n   */\n\n\n  Geometry.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    if (!this._indexBuffer) {\n      return;\n    }\n\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      var needToUpdateSubMeshes = indices.length !== this._indices.length;\n\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n\n      if (needToUpdateSubMeshes) {\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n          var mesh = _a[_i];\n\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  };\n  /**\r\n   * Creates a new index buffer\r\n   * @param indices defines the indices to store in the index buffer\r\n   * @param totalVertices defines the total number of vertices (could be null)\r\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n   */\n\n\n  Geometry.prototype.setIndices = function (indices, totalVertices, updatable) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._disposeVertexArrayObjects();\n\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n    }\n\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._createGlobalSubMesh(true);\n    }\n\n    this.notifyUpdate();\n  };\n  /**\r\n   * Return the total number of indices\r\n   * @returns the total number of indices\r\n   */\n\n\n  Geometry.prototype.getTotalIndices = function () {\n    if (!this.isReady()) {\n      return 0;\n    }\n\n    return this._indices.length;\n  };\n  /**\r\n   * Gets the index buffer array\r\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n   * @returns the index buffer array\r\n   */\n\n\n  Geometry.prototype.getIndices = function (copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    var orig = this._indices;\n\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      var len = orig.length;\n      var copy = [];\n\n      for (var i = 0; i < len; i++) {\n        copy.push(orig[i]);\n      }\n\n      return copy;\n    }\n  };\n  /**\r\n   * Gets the index buffer\r\n   * @return the index buffer\r\n   */\n\n\n  Geometry.prototype.getIndexBuffer = function () {\n    if (!this.isReady()) {\n      return null;\n    }\n\n    return this._indexBuffer;\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._releaseVertexArrayObject = function (effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n\n      delete this._vertexArrayObjects[effect.key];\n    }\n  };\n  /**\r\n   * Release the associated resources for a specific mesh\r\n   * @param mesh defines the source mesh\r\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n   */\n\n\n  Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\n    var meshes = this._meshes;\n    var index = meshes.indexOf(mesh);\n\n    if (index === -1) {\n      return;\n    }\n\n    meshes.splice(index, 1);\n    mesh._geometry = null;\n\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  };\n  /**\r\n   * Apply current geometry to a given mesh\r\n   * @param mesh defines the mesh to apply geometry to\r\n   */\n\n\n  Geometry.prototype.applyToMesh = function (mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n\n    var previousGeometry = mesh._geometry;\n\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n\n    var meshes = this._meshes; // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n\n    mesh._geometry = this;\n\n    this._scene.pushGeometry(this);\n\n    meshes.push(mesh);\n\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else {\n      mesh._boundingInfo = this._boundingInfo;\n    }\n  };\n\n  Geometry.prototype._updateExtend = function (data) {\n    if (data === void 0) {\n      data = null;\n    }\n\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind);\n      }\n\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  };\n\n  Geometry.prototype._applyToMesh = function (mesh) {\n    var numOfMeshes = this._meshes.length; // vertexBuffers\n\n    for (var kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n\n      var buffer = this._vertexBuffers[kind].getBuffer();\n\n      if (buffer) {\n        buffer.references = numOfMeshes;\n      }\n\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n\n        mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n\n        mesh._createGlobalSubMesh(false); //bounding info was just created again, world matrix should be applied again.\n\n\n        mesh._updateBoundingInfo();\n      }\n    } // indexBuffer\n\n\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n    }\n\n    if (this._indexBuffer) {\n      this._indexBuffer.references = numOfMeshes;\n    } // morphTargets\n\n\n    mesh._syncGeometryWithMorphTargetManager(); // instances\n\n\n    mesh.synchronizeInstances();\n  };\n\n  Geometry.prototype.notifyUpdate = function (kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n\n    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n      var mesh = _a[_i];\n\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  };\n  /**\r\n   * Load the geometry if it was flagged as delay loaded\r\n   * @param scene defines the hosting scene\r\n   * @param onLoaded defines a callback called when the geometry is loaded\r\n   */\n\n\n  Geometry.prototype.load = function (scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n\n      return;\n    }\n\n    this.delayLoadState = 2;\n\n    this._queueLoad(scene, onLoaded);\n  };\n\n  Geometry.prototype._queueLoad = function (scene, onLoaded) {\n    var _this = this;\n\n    if (!this.delayLoadingFile) {\n      return;\n    }\n\n    scene._addPendingData(this);\n\n    scene._loadFile(this.delayLoadingFile, function (data) {\n      if (!_this._delayLoadingFunction) {\n        return;\n      }\n\n      _this._delayLoadingFunction(JSON.parse(data), _this);\n\n      _this.delayLoadState = 1;\n      _this._delayInfo = [];\n\n      scene._removePendingData(_this);\n\n      var meshes = _this._meshes;\n      var numOfMeshes = meshes.length;\n\n      for (var index = 0; index < numOfMeshes; index++) {\n        _this._applyToMesh(meshes[index]);\n      }\n\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  };\n  /**\r\n   * Invert the geometry to move from a right handed system to a left handed one.\r\n   */\n\n\n  Geometry.prototype.toLeftHanded = function () {\n    // Flip faces\n    var tIndices = this.getIndices(false);\n\n    if (tIndices != null && tIndices.length > 0) {\n      for (var i = 0; i < tIndices.length; i += 3) {\n        var tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n\n      this.setIndices(tIndices);\n    } // Negate position.z\n\n\n    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n\n    if (tPositions != null && tPositions.length > 0) {\n      for (var i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    } // Negate normal.z\n\n\n    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n\n    if (tNormals != null && tNormals.length > 0) {\n      for (var i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }; // Cache\n\n  /** @hidden */\n\n\n  Geometry.prototype._resetPointsArrayCache = function () {\n    this._positions = null;\n  };\n  /** @hidden */\n\n\n  Geometry.prototype._generatePointsArray = function () {\n    if (this._positions) {\n      return true;\n    }\n\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!data || data.length === 0) {\n      return false;\n    }\n\n    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n\n    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    } // just in case the number of positions was reduced, splice the array\n\n\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  };\n  /**\r\n   * Gets a value indicating if the geometry is disposed\r\n   * @returns true if the geometry was disposed\r\n   */\n\n\n  Geometry.prototype.isDisposed = function () {\n    return this._isDisposed;\n  };\n\n  Geometry.prototype._disposeVertexArrayObjects = function () {\n    if (this._vertexArrayObjects) {\n      for (var kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n\n      this._vertexArrayObjects = {};\n    }\n  };\n  /**\r\n   * Free all associated resources\r\n   */\n\n\n  Geometry.prototype.dispose = function () {\n    var meshes = this._meshes;\n    var numOfMeshes = meshes.length;\n    var index;\n\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n\n    this._meshes = [];\n\n    this._disposeVertexArrayObjects();\n\n    for (var kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n\n    this._scene.removeGeometry(this);\n\n    this._isDisposed = true;\n  };\n  /**\r\n   * Clone the current geometry into a new geometry\r\n   * @param id defines the unique ID of the new geometry\r\n   * @returns a new geometry object\r\n   */\n\n\n  Geometry.prototype.copy = function (id) {\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    var indices = this.getIndices();\n\n    if (indices) {\n      for (var index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n\n    var updatable = false;\n    var stopChecking = false;\n    var kind;\n\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      var data = this.getVerticesData(kind);\n\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n\n        if (!stopChecking) {\n          var vb = this.getVertexBuffer(kind);\n\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n\n    var geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n\n      geometry._delayInfo.push(kind);\n    } // Bounding info\n\n\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  };\n  /**\r\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n   * @return a JSON representation of the current geometry data (without the vertices data)\r\n   */\n\n\n  Geometry.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.updatable = this._updatable;\n\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n\n    return serializationObject;\n  };\n\n  Geometry.prototype.toNumberArray = function (origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  };\n  /**\r\n   * Serialize all vertices data into a JSON oject\r\n   * @returns a JSON representation of the current geometry data\r\n   */\n\n\n  Geometry.prototype.serializeVerticeData = function () {\n    var serializationObject = this.serialize();\n\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangets = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangets._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uv2s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uv3s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uv4s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uv5s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uv6s._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n\n    serializationObject.indices = this.toNumberArray(this.getIndices());\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Extracts a clone of a mesh geometry\r\n   * @param mesh defines the source mesh\r\n   * @param id defines the unique ID of the new geometry object\r\n   * @returns the new geometry object\r\n   */\n\n\n  Geometry.ExtractFromMesh = function (mesh, id) {\n    var geometry = mesh._geometry;\n\n    if (!geometry) {\n      return null;\n    }\n\n    return geometry.copy(id);\n  };\n  /**\r\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n   * Be aware Math.random() could cause collisions, but:\r\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n   * @returns a string containing a new GUID\r\n   */\n\n\n  Geometry.RandomId = function () {\n    return Tools.RandomId();\n  };\n  /** @hidden */\n\n\n  Geometry._ImportGeometry = function (parsedGeometry, mesh) {\n    var scene = mesh.getScene(); // Geometry\n\n    var geometryId = parsedGeometry.geometryId;\n\n    if (geometryId) {\n      var geometry = scene.getGeometryByID(geometryId);\n\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      var binaryInfo = mesh._binaryInfo;\n\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        var floatIndices = [];\n\n        for (var i = 0; i < matricesIndicesData.length; i++) {\n          var index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n\n        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          var materialIndex = subMeshesData[i * 5 + 0];\n          var verticesStart = subMeshesData[i * 5 + 1];\n          var verticesCount = subMeshesData[i * 5 + 2];\n          var indexStart = subMeshesData[i * 5 + 3];\n          var indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          var floatIndices = [];\n\n          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n\n      mesh.setIndices(parsedGeometry.indices, null);\n    } // SubMeshes\n\n\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n\n      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    } // Flat shading\n\n\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    } // Update\n\n\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  };\n\n  Geometry._CleanMatricesWeights = function (parsedGeometry, mesh) {\n    var epsilon = 1e-3;\n\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n\n    var noInfluenceBoneIndex = 0.0;\n\n    if (parsedGeometry.skeletonId > -1) {\n      var skeleton = mesh.getScene().getLastSkeletonByID(parsedGeometry.skeletonId);\n\n      if (!skeleton) {\n        return;\n      }\n\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n\n    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    var matricesWeights = parsedGeometry.matricesWeights;\n    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    var influencers = parsedGeometry.numBoneInfluencer;\n    var size = matricesWeights.length;\n\n    for (var i = 0; i < size; i += 4) {\n      var weight = 0.0;\n      var firstZeroWeight = -1;\n\n      for (var j = 0; j < 4; j++) {\n        var w = matricesWeights[i + j];\n        weight += w;\n\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n\n      if (matricesWeightsExtra) {\n        for (var j = 0; j < 4; j++) {\n          var w = matricesWeightsExtra[i + j];\n          weight += w;\n\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n\n      if (weight > epsilon) {\n        var mweight = 1.0 / weight;\n\n        for (var j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n\n        if (matricesWeightsExtra) {\n          for (var j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  };\n  /**\r\n   * Create a new geometry from persisted data (Using .babylon file format)\r\n   * @param parsedVertexData defines the persisted data\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n   * @returns the new geometry object\r\n   */\n\n\n  Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\n    if (scene.getGeometryByID(parsedVertexData.id)) {\n      return null; // null since geometry could be something else than a box...\n    }\n\n    var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  };\n\n  return Geometry;\n}();\n\nexport { Geometry };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/geometry.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { IGetSetVerticesData, VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\n\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { DataBuffer } from \"./dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = 0;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    /** @hidden */\r\n    public _indices: IndicesArray;\r\n    /** @hidden */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @hidden */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @hidden */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @hidden */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @hidden */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        let geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by defaut), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this.id = id;\r\n        this.uniqueId = scene.getUniqueId();\r\n        this._engine = scene.getEngine();\r\n        this._meshes = [];\r\n        this._scene = scene;\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n            this._indices = [];\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === 1 || this.delayLoadState === 0;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (var index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices);\r\n        }\r\n\r\n        // Vertex buffers\r\n        for (var key in this._vertexBuffers) {\r\n            let vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this.notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null): void {\r\n        var kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            var data = <FloatArray>buffer.getData();\r\n            if (totalVertices != null) {\r\n                this._totalVertices = totalVertices;\r\n            } else {\r\n                if (data != null) {\r\n                    this._totalVertices = data.length / (buffer.byteStride / 4);\r\n                }\r\n            }\r\n\r\n            this._updateExtend(data);\r\n            this._resetPointsArrayCache();\r\n\r\n            var meshes = this._meshes;\r\n            var numOfMeshes = meshes.length;\r\n\r\n            for (var index = 0; index < numOfMeshes; index++) {\r\n                var mesh = meshes[index];\r\n                mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(false);\r\n                mesh.computeWorldMatrix(true);\r\n            }\r\n        }\r\n\r\n        this.notifyUpdate(kind);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        var vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this.notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        var vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this.notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            var meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh._boundingInfo) {\r\n                    mesh._boundingInfo.reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bind(effect: Nullable<Effect>, indexToBind?: Nullable<DataBuffer>): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        let vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect);\r\n            return;\r\n        }\r\n\r\n        // Using VAO\r\n        if (!this._vertexArrayObjects[effect.key]) {\r\n            this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        let data = vertexBuffer.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        const tightlyPackedByteStride = vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n        const count = this._totalVertices * vertexBuffer.getSize();\r\n\r\n        if (vertexBuffer.type !== VertexBuffer.FLOAT || vertexBuffer.byteStride !== tightlyPackedByteStride) {\r\n            const copy: number[] = [];\r\n            vertexBuffer.forEach(count, (value) => copy.push(value));\r\n            return copy;\r\n        }\r\n\r\n        if (!(data instanceof Array || data instanceof Float32Array) || vertexBuffer.byteOffset !== 0 || data.length !== count) {\r\n            if (data instanceof Array) {\r\n                const offset = vertexBuffer.byteOffset / 4;\r\n                return Tools.Slice(data, offset, offset + count);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                return new Float32Array(data, vertexBuffer.byteOffset, count);\r\n            } else {\r\n                let offset = data.byteOffset + vertexBuffer.byteOffset;\r\n                if (forceCopy || (copyWhenShared && this._meshes.length !== 1)) {\r\n                    let result = new Float32Array(count);\r\n                    let source = new Float32Array(data.buffer, offset, count);\r\n\r\n                    result.set(source);\r\n\r\n                    return result;\r\n                }\r\n\r\n                // Portect against bad data\r\n                let remainder = offset % 4;\r\n\r\n                if (remainder) {\r\n                    offset = Math.max(0, offset - remainder);\r\n                }\r\n\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n\r\n        if (forceCopy || (copyWhenShared && this._meshes.length !== 1)) {\r\n            return Tools.Slice(data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        let vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @return an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        var result = [];\r\n        var kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n        }\r\n\r\n        this.notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        var orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            var len = orig.length;\r\n            var copy = [];\r\n            for (var i = 0; i < len; i++) {\r\n                copy.push(orig[i]);\r\n            }\r\n            return copy;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @return the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        var meshes = this._meshes;\r\n        var index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        var previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        var meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else {\r\n            mesh._boundingInfo = this._boundingInfo;\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        var numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (var kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n            var buffer = this._vertexBuffers[kind].getBuffer();\r\n            if (buffer) {\r\n                buffer.references = numOfMeshes;\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(false);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices);\r\n        }\r\n        if (this._indexBuffer) {\r\n            this._indexBuffer.references = numOfMeshes;\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        for (var mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === 2) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = 2;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene._addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = 1;\r\n                this._delayInfo = [];\r\n\r\n                scene._removePendingData(this);\r\n\r\n                var meshes = this._meshes;\r\n                var numOfMeshes = meshes.length;\r\n                for (var index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        let tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                let tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        let tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        let tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @hidden */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (var kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        var meshes = this._meshes;\r\n        var numOfMeshes = meshes.length;\r\n        var index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes = [];\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (var kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = 0;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        var vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        var indices = this.getIndices();\r\n        if (indices) {\r\n            for (var index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        var updatable = false;\r\n        var stopChecking = false;\r\n        var kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            var data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    let vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @return a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON oject\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        var serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangets = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangets._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uv2s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uv3s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uv4s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uv5s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uv6s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this.toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        var geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        var scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        var geometryId = parsedGeometry.geometryId;\r\n        if (geometryId) {\r\n            var geometry = scene.getGeometryByID(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            var binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                var floatIndices = [];\r\n                for (var i = 0; i < matricesIndicesData.length; i++) {\r\n                    var index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                var floatIndices = [];\r\n                for (var i = 0; i < matricesIndicesData.length; i++) {\r\n                    var index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    var materialIndex = subMeshesData[i * 5 + 0];\r\n                    var verticesStart = subMeshesData[i * 5 + 1];\r\n                    var verticesCount = subMeshesData[i * 5 + 2];\r\n                    var indexStart = subMeshesData[i * 5 + 3];\r\n                    var indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    var floatIndices = [];\r\n\r\n                    for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        var matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    var floatIndices = [];\r\n\r\n                    for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, <AbstractMesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            let skeleton = mesh.getScene().getLastSkeletonByID(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        let matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        let matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        let matricesWeights = parsedGeometry.matricesWeights;\r\n        let matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        let influencers = parsedGeometry.numBoneInfluencer;\r\n        let size = matricesWeights.length;\r\n\r\n        for (var i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (var j = 0; j < 4; j++) {\r\n                let w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (var j = 0; j < 4; j++) {\r\n                    let w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                let mweight = 1.0 / weight;\r\n                for (var j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (var j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        if (scene.getGeometryByID(parsedVertexData.id)) {\r\n            return null; // null since geometry could be something else than a box...\r\n        }\r\n\r\n        var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = 4;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}