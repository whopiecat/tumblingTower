{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector2 } from \"../Maths/math.vector\";\nimport { PostProcess } from \"./postProcess\";\nimport \"../Shaders/stereoscopicInterlace.fragment\";\n/**\r\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\r\n */\n\nvar StereoscopicInterlacePostProcessI =\n/** @class */\nfunction (_super) {\n  __extends(StereoscopicInterlacePostProcessI, _super);\n  /**\r\n   * Initializes a StereoscopicInterlacePostProcessI\r\n   * @param name The name of the effect.\r\n   * @param rigCameras The rig cameras to be appled to the post process\r\n   * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n   * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   */\n\n\n  function StereoscopicInterlacePostProcessI(name, rigCameras, isStereoscopicHoriz, isStereoscopicInterlaced, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, \"stereoscopicInterlace\", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined) || this;\n\n    _this._passedProcess = rigCameras[0]._rigPostProcess;\n    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n\n    _this.onSizeChangedObservable.add(function () {\n      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n    });\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setTextureFromPostProcess(\"camASampler\", _this._passedProcess);\n      effect.setFloat2(\"stepSize\", _this._stepSize.x, _this._stepSize.y);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"StereoscopicInterlacePostProcessI\" string\r\n   */\n\n\n  StereoscopicInterlacePostProcessI.prototype.getClassName = function () {\n    return \"StereoscopicInterlacePostProcessI\";\n  };\n\n  return StereoscopicInterlacePostProcessI;\n}(PostProcess);\n\nexport { StereoscopicInterlacePostProcessI };\n/**\r\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\r\n */\n\nvar StereoscopicInterlacePostProcess =\n/** @class */\nfunction (_super) {\n  __extends(StereoscopicInterlacePostProcess, _super);\n  /**\r\n   * Initializes a StereoscopicInterlacePostProcess\r\n   * @param name The name of the effect.\r\n   * @param rigCameras The rig cameras to be appled to the post process\r\n   * @param isStereoscopicHoriz If the rendered results are horizontal or verticle\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   */\n\n\n  function StereoscopicInterlacePostProcess(name, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {\n    var _this = _super.call(this, name, \"stereoscopicInterlace\", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined) || this;\n\n    _this._passedProcess = rigCameras[0]._rigPostProcess;\n    _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n\n    _this.onSizeChangedObservable.add(function () {\n      _this._stepSize = new Vector2(1 / _this.width, 1 / _this.height);\n    });\n\n    _this.onApplyObservable.add(function (effect) {\n      effect.setTextureFromPostProcess(\"camASampler\", _this._passedProcess);\n      effect.setFloat2(\"stepSize\", _this._stepSize.x, _this._stepSize.y);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Gets a string identifying the name of the class\r\n   * @returns \"StereoscopicInterlacePostProcess\" string\r\n   */\n\n\n  StereoscopicInterlacePostProcess.prototype.getClassName = function () {\n    return \"StereoscopicInterlacePostProcess\";\n  };\n\n  return StereoscopicInterlacePostProcess;\n}(PostProcess);\n\nexport { StereoscopicInterlacePostProcess };","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/stereoscopicInterlacePostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Shaders/stereoscopicInterlace.fragment\";\r\n\r\n/**\r\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\r\n */\r\nexport class StereoscopicInterlacePostProcessI extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcessI\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcessI\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcessI\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be appled to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\r\n     * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, isStereoscopicInterlaced: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"stereoscopicInterlace\", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined);\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}\r\n/**\r\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\r\n */\r\nexport class StereoscopicInterlacePostProcess extends PostProcess {\r\n    private _stepSize: Vector2;\r\n    private _passedProcess: Nullable<PostProcess>;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"StereoscopicInterlacePostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicInterlacePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Initializes a StereoscopicInterlacePostProcess\r\n     * @param name The name of the effect.\r\n     * @param rigCameras The rig cameras to be appled to the post process\r\n     * @param isStereoscopicHoriz If the rendered results are horizontal or verticle\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(name: string, rigCameras: Camera[], isStereoscopicHoriz: boolean, samplingMode?: number, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"stereoscopicInterlace\", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined);\r\n\r\n        this._passedProcess = rigCameras[0]._rigPostProcess;\r\n        this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n\r\n        this.onSizeChangedObservable.add(() => {\r\n            this._stepSize = new Vector2(1 / this.width, 1 / this.height);\r\n        });\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\r\n            effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\r\n        });\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}