{"ast":null,"code":"import { Effect } from './effect';\nimport { GUID } from '../Misc/guid';\nimport { NodeMaterialSystemValues } from './Node/Enums/nodeMaterialSystemValues';\n\nvar MapMap =\n/** @class */\nfunction () {\n  function MapMap() {\n    this.mm = new Map();\n  }\n\n  MapMap.prototype.get = function (a, b) {\n    var m = this.mm.get(a);\n\n    if (m !== undefined) {\n      return m.get(b);\n    }\n\n    return undefined;\n  };\n\n  MapMap.prototype.set = function (a, b, v) {\n    var m = this.mm.get(a);\n\n    if (m === undefined) {\n      this.mm.set(a, m = new Map());\n    }\n\n    m.set(b, v);\n  };\n\n  return MapMap;\n}();\n/**\r\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\r\n */\n\n\nvar ShadowDepthWrapper =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new shadow depth wrapper.\r\n   * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\r\n   * generate the shadow depth map. For more information, please refer to the documentation:\r\n   * https://doc.babylonjs.com/babylon101/shadows\r\n   * @param baseMaterial Material to wrap\r\n   * @param scene Define the scene the material belongs to\r\n   * @param options Options used to create the wrapper\r\n   */\n  function ShadowDepthWrapper(baseMaterial, scene, options) {\n    var _this = this;\n\n    this._baseMaterial = baseMaterial;\n    this._scene = scene;\n    this._options = options;\n    this._subMeshToEffect = new Map();\n    this._subMeshToDepthEffect = new MapMap();\n    this._meshes = new Map();\n    var prefix = baseMaterial.getClassName() === \"NodeMaterial\" ? \"u_\" : \"\";\n\n    if (prefix) {\n      this._matriceNames = {\n        \"world\": prefix + \"World\",\n        \"view\": prefix + \"View\",\n        \"projection\": prefix + \"Projection\",\n        \"viewProjection\": prefix + \"ViewProjection\",\n        \"worldView\": prefix + \"WorldxView\",\n        \"worldViewProjection\": prefix + \"WorldxViewxProjection\"\n      };\n      var nodeMat = baseMaterial;\n      var inputBlocks = nodeMat.getInputBlocks();\n\n      for (var i = 0; i < inputBlocks.length; ++i) {\n        switch (inputBlocks[i]._systemValue) {\n          case NodeMaterialSystemValues.World:\n            this._matriceNames[\"world\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.View:\n            this._matriceNames[\"view\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.Projection:\n            this._matriceNames[\"projection\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.ViewProjection:\n            this._matriceNames[\"viewProjection\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.WorldView:\n            this._matriceNames[\"worldView\"] = inputBlocks[i].associatedVariableName;\n            break;\n\n          case NodeMaterialSystemValues.WorldViewProjection:\n            this._matriceNames[\"worldViewProjection\"] = inputBlocks[i].associatedVariableName;\n            break;\n        }\n      }\n    } else {\n      this._matriceNames = {\n        \"world\": prefix + \"world\",\n        \"view\": prefix + \"view\",\n        \"projection\": prefix + \"projection\",\n        \"viewProjection\": prefix + \"viewProjection\",\n        \"worldView\": prefix + \"worldView\",\n        \"worldViewProjection\": prefix + \"worldViewProjection\"\n      };\n    } // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\n    // to create the depth effect later on\n\n\n    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add(function (params) {\n      var _a;\n\n      var mesh = (_a = params.subMesh) === null || _a === void 0 ? void 0 : _a.getMesh();\n\n      if (mesh && !_this._meshes.has(mesh)) {\n        // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\n        _this._meshes.set(mesh, mesh.onDisposeObservable.add(function (mesh) {\n          var iterator = _this._subMeshToEffect.keys();\n\n          for (var key = iterator.next(); key.done !== true; key = iterator.next()) {\n            var subMesh = key.value;\n\n            if ((subMesh === null || subMesh === void 0 ? void 0 : subMesh.getMesh()) === mesh) {\n              _this._subMeshToEffect.delete(subMesh);\n\n              _this._subMeshToDepthEffect.mm.delete(subMesh);\n            }\n          }\n        }));\n      }\n\n      _this._subMeshToEffect.set(params.subMesh, params.effect);\n\n      _this._subMeshToDepthEffect.mm.delete(params.subMesh); // trigger a depth effect recreation\n\n    });\n  }\n\n  Object.defineProperty(ShadowDepthWrapper.prototype, \"standalone\", {\n    /** Gets the standalone status of the wrapper */\n    get: function () {\n      var _a, _b;\n\n      return (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.standalone) !== null && _b !== void 0 ? _b : false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShadowDepthWrapper.prototype, \"baseMaterial\", {\n    /** Gets the base material the wrapper is built upon */\n    get: function () {\n      return this._baseMaterial;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the effect to use to generate the depth map\r\n   * @param subMesh subMesh to get the effect for\r\n   * @param shadowGenerator shadow generator to get the effect for\r\n   * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\r\n   */\n\n  ShadowDepthWrapper.prototype.getEffect = function (subMesh, shadowGenerator) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return (_f = (_c = (_b = (_a = this._subMeshToDepthEffect.mm.get(subMesh)) === null || _a === void 0 ? void 0 : _a.get(shadowGenerator)) === null || _b === void 0 ? void 0 : _b.depthEffect) !== null && _c !== void 0 ? _c : (_e = (_d = this._subMeshToDepthEffect.mm.get(null)) === null || _d === void 0 ? void 0 : _d.get(shadowGenerator)) === null || _e === void 0 ? void 0 : _e.depthEffect) !== null && _f !== void 0 ? _f : null;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used for depth rendering\r\n   * @param subMesh submesh to check\r\n   * @param defines the list of defines to take into account when checking the effect\r\n   * @param shadowGenerator combined with subMesh, it defines the effect to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  ShadowDepthWrapper.prototype.isReadyForSubMesh = function (subMesh, defines, shadowGenerator, useInstances) {\n    var _a, _b;\n\n    if (this.standalone) {\n      // will ensure the effect is (re)created for the base material\n      this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n\n    return (_b = (_a = this._makeEffect(subMesh, defines, shadowGenerator)) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n  };\n  /**\r\n   * Disposes the resources\r\n   */\n\n\n  ShadowDepthWrapper.prototype.dispose = function () {\n    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\n\n    this._onEffectCreatedObserver = null;\n\n    var iterator = this._meshes.entries();\n\n    for (var entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n      var _a = entry.value,\n          mesh = _a[0],\n          observer = _a[1];\n      mesh.onDisposeObservable.remove(observer);\n    }\n  };\n\n  ShadowDepthWrapper.prototype._makeEffect = function (subMesh, defines, shadowGenerator) {\n    var _a;\n\n    var origEffect = (_a = this._subMeshToEffect.get(subMesh)) !== null && _a !== void 0 ? _a : this._subMeshToEffect.get(null);\n\n    if (!origEffect) {\n      return null;\n    }\n\n    var params = this._subMeshToDepthEffect.get(subMesh, shadowGenerator);\n\n    if (!params) {\n      params = {\n        depthEffect: null,\n        depthDefines: \"\",\n        token: GUID.RandomId()\n      };\n\n      this._subMeshToDepthEffect.set(subMesh, shadowGenerator, params);\n    }\n\n    var join = defines.join(\"\\n\");\n\n    if (params.depthEffect) {\n      if (join === params.depthDefines) {\n        // we already created the depth effect and it is still up to date for this submesh + shadow generator\n        return params.depthEffect;\n      }\n    }\n\n    params.depthDefines = join; // the depth effect is either out of date or has not been created yet\n\n    var vertexCode = origEffect.rawVertexSourceCode,\n        fragmentCode = origEffect.rawFragmentSourceCode; // vertex code\n\n    var vertexNormalBiasCode = this._options && this._options.remappedVariables ? \"#include<shadowMapVertexNormalBias>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapVertexNormalBias\"],\n        vertexMetricCode = this._options && this._options.remappedVariables ? \"#include<shadowMapVertexMetric>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapVertexMetric\"],\n        fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? \"#include<shadowMapFragmentSoftTransparentShadow>(\" + this._options.remappedVariables.join(\",\") + \")\" : Effect.IncludesShadersStore[\"shadowMapFragmentSoftTransparentShadow\"],\n        fragmentBlockCode = Effect.IncludesShadersStore[\"shadowMapFragment\"];\n    vertexCode = vertexCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapVertexDeclaration\"] + \"\\r\\nvoid main\");\n    vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\n\n    if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\n      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\n    } else {\n      vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\r\\n}\");\n    }\n\n    vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\"); // fragment code\n\n    var hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\n    var hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\n    var fragmentCodeToInjectAtEnd = \"\";\n\n    if (!hasLocationForSoftTransparentShadow) {\n      fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\r\\n\";\n    } else {\n      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\n    }\n\n    fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentDeclaration\"] + \"\\r\\nvoid main\");\n\n    if (hasLocationForFragment) {\n      fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\n    } else {\n      fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\r\\n\";\n    }\n\n    if (fragmentCodeToInjectAtEnd) {\n      fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\n    }\n\n    fragmentCode = fragmentCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\n    var uniforms = origEffect.getUniformNames().slice();\n    uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\n    params.depthEffect = this._scene.getEngine().createEffect({\n      vertexSource: vertexCode,\n      fragmentSource: fragmentCode,\n      vertexToken: params.token,\n      fragmentToken: params.token\n    }, {\n      attributes: origEffect.getAttributesNames(),\n      uniformsNames: uniforms,\n      uniformBuffersNames: origEffect.getUniformBuffersNames(),\n      samplers: origEffect.getSamplers(),\n      defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\n      indexParameters: origEffect.getIndexParameters()\n    }, this._scene.getEngine());\n    return params.depthEffect;\n  };\n\n  return ShadowDepthWrapper;\n}();\n\nexport { ShadowDepthWrapper };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/shadowDepthWrapper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { Effect, IEffectCreationOptions } from './effect';\r\nimport { AbstractMesh } from '../Meshes/abstractMesh';\r\nimport { Node } from '../node';\r\nimport { ShadowGenerator } from '../Lights/Shadows/shadowGenerator';\r\nimport { GUID } from '../Misc/guid';\r\nimport { NodeMaterial } from './Node/nodeMaterial';\r\nimport { NodeMaterialSystemValues } from './Node/Enums/nodeMaterialSystemValues';\r\n\r\n/**\r\n * Options to be used when creating a shadow depth material\r\n */\r\nexport interface IIOptionShadowDepthMaterial {\r\n    /** Variables in the vertex shader code that need to have their names remapped.\r\n     * The format is: [\"var_name\", \"var_remapped_name\", \"var_name\", \"var_remapped_name\", ...]\r\n     * \"var_name\" should be either: worldPos or vNormalW\r\n     * So, if the variable holding the world position in your vertex shader is not named worldPos, you must tell the system\r\n     * the name to use instead by using: [\"worldPos\", \"myWorldPosVar\"] assuming the variable is named myWorldPosVar in your code.\r\n     * If the normal must also be remapped: [\"worldPos\", \"myWorldPosVar\", \"vNormalW\", \"myWorldNormal\"]\r\n    */\r\n    remappedVariables?: string[];\r\n\r\n    /** Set standalone to true if the base material wrapped by ShadowDepthMaterial is not used for a regular object but for depth shadow generation only */\r\n    standalone?: boolean;\r\n}\r\n\r\nclass MapMap<Ka, Kb, V> {\r\n    readonly mm = new Map<Ka, Map<Kb, V>>();\r\n\r\n    get(a: Ka, b: Kb): V | undefined {\r\n        const m = this.mm.get(a);\r\n        if (m !== undefined) {\r\n            return m.get(b);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    set(a: Ka, b: Kb, v: V): void {\r\n        let m = this.mm.get(a);\r\n        if (m === undefined) {\r\n            this.mm.set(a, (m = new Map()));\r\n        }\r\n        m.set(b, v);\r\n    }\r\n}\r\n\r\n/**\r\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\r\n */\r\nexport class ShadowDepthWrapper {\r\n\r\n    private _scene: Scene;\r\n    private _options?: IIOptionShadowDepthMaterial;\r\n    private _baseMaterial: Material;\r\n    private _onEffectCreatedObserver: Nullable<Observer<{ effect: Effect, subMesh: Nullable<SubMesh>}>>;\r\n    private _subMeshToEffect: Map<Nullable<SubMesh>, Effect>;\r\n    private _subMeshToDepthEffect: MapMap<Nullable<SubMesh>, ShadowGenerator, { depthEffect: Nullable<Effect>, depthDefines: string, token: string }>; // key is (subMesh + shadowGenerator)\r\n    private _meshes: Map<AbstractMesh, Nullable<Observer<Node>>>;\r\n\r\n    /** @hidden */\r\n    public _matriceNames: any;\r\n\r\n    /** Gets the standalone status of the wrapper */\r\n    public get standalone(): boolean {\r\n        return this._options?.standalone ?? false;\r\n    }\r\n\r\n    /** Gets the base material the wrapper is built upon */\r\n    public get baseMaterial(): Material {\r\n        return this._baseMaterial;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new shadow depth wrapper.\r\n     * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\r\n     * generate the shadow depth map. For more information, please refer to the documentation:\r\n     * https://doc.babylonjs.com/babylon101/shadows\r\n     * @param baseMaterial Material to wrap\r\n     * @param scene Define the scene the material belongs to\r\n     * @param options Options used to create the wrapper\r\n     */\r\n    constructor(baseMaterial: Material, scene: Scene, options?: IIOptionShadowDepthMaterial) {\r\n        this._baseMaterial = baseMaterial;\r\n        this._scene = scene;\r\n        this._options = options;\r\n\r\n        this._subMeshToEffect = new Map();\r\n        this._subMeshToDepthEffect = new MapMap();\r\n        this._meshes = new Map();\r\n\r\n        const prefix = baseMaterial.getClassName() === \"NodeMaterial\" ? \"u_\" : \"\";\r\n\r\n        if (prefix) {\r\n            this._matriceNames = {\r\n                \"world\": prefix + \"World\",\r\n                \"view\": prefix + \"View\",\r\n                \"projection\": prefix + \"Projection\",\r\n                \"viewProjection\": prefix + \"ViewProjection\",\r\n                \"worldView\": prefix + \"WorldxView\",\r\n                \"worldViewProjection\": prefix + \"WorldxViewxProjection\",\r\n            };\r\n\r\n            const nodeMat = baseMaterial as NodeMaterial;\r\n            const inputBlocks = nodeMat.getInputBlocks();\r\n\r\n            for (let i = 0; i < inputBlocks.length; ++i) {\r\n                switch (inputBlocks[i]._systemValue) {\r\n                    case NodeMaterialSystemValues.World:\r\n                        this._matriceNames[\"world\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                    case NodeMaterialSystemValues.View:\r\n                        this._matriceNames[\"view\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                    case NodeMaterialSystemValues.Projection:\r\n                        this._matriceNames[\"projection\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                    case NodeMaterialSystemValues.ViewProjection:\r\n                        this._matriceNames[\"viewProjection\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldView:\r\n                        this._matriceNames[\"worldView\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                    case NodeMaterialSystemValues.WorldViewProjection:\r\n                        this._matriceNames[\"worldViewProjection\"] = inputBlocks[i].associatedVariableName;\r\n                        break;\r\n                }\r\n            }\r\n        } else {\r\n            this._matriceNames = {\r\n                \"world\": prefix + \"world\",\r\n                \"view\": prefix + \"view\",\r\n                \"projection\": prefix + \"projection\",\r\n                \"viewProjection\": prefix + \"viewProjection\",\r\n                \"worldView\": prefix + \"worldView\",\r\n                \"worldViewProjection\": prefix + \"worldViewProjection\",\r\n            };\r\n        }\r\n\r\n        // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\r\n        // to create the depth effect later on\r\n        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params: { effect: Effect, subMesh: Nullable<SubMesh> }) => {\r\n            const mesh = params.subMesh?.getMesh();\r\n\r\n            if (mesh && !this._meshes.has(mesh)) {\r\n                // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\r\n                this._meshes.set(mesh,\r\n                    mesh.onDisposeObservable.add((mesh: Node) => {\r\n                        const iterator = this._subMeshToEffect.keys();\r\n                        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                            const subMesh = key.value;\r\n                            if (subMesh?.getMesh() === mesh as AbstractMesh) {\r\n                                this._subMeshToEffect.delete(subMesh);\r\n                                this._subMeshToDepthEffect.mm.delete(subMesh);\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            this._subMeshToEffect.set(params.subMesh, params.effect);\r\n            this._subMeshToDepthEffect.mm.delete(params.subMesh); // trigger a depth effect recreation\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the effect to use to generate the depth map\r\n     * @param subMesh subMesh to get the effect for\r\n     * @param shadowGenerator shadow generator to get the effect for\r\n     * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\r\n     */\r\n    public getEffect(subMesh: Nullable<SubMesh>, shadowGenerator: ShadowGenerator): Nullable<Effect> {\r\n        return this._subMeshToDepthEffect.mm.get(subMesh)?.get(shadowGenerator)?.depthEffect ?? this._subMeshToDepthEffect.mm.get(null)?.get(shadowGenerator)?.depthEffect ?? null;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used for depth rendering\r\n     * @param subMesh submesh to check\r\n     * @param defines the list of defines to take into account when checking the effect\r\n     * @param shadowGenerator combined with subMesh, it defines the effect to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, useInstances: boolean): boolean {\r\n        if (this.standalone) {\r\n            // will ensure the effect is (re)created for the base material\r\n            this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        return this._makeEffect(subMesh, defines, shadowGenerator)?.isReady() ?? false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources\r\n     */\r\n    public dispose(): void {\r\n        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\r\n        this._onEffectCreatedObserver = null;\r\n\r\n        const iterator = this._meshes.entries();\r\n        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\r\n            const [mesh, observer] = entry.value;\r\n\r\n            mesh.onDisposeObservable.remove(observer);\r\n        }\r\n    }\r\n\r\n    private _makeEffect(subMesh: Nullable<SubMesh>, defines: string[], shadowGenerator: ShadowGenerator): Nullable<Effect> {\r\n        const origEffect = this._subMeshToEffect.get(subMesh) ?? this._subMeshToEffect.get(null);\r\n\r\n        if (!origEffect) {\r\n            return null;\r\n        }\r\n\r\n        let params = this._subMeshToDepthEffect.get(subMesh, shadowGenerator);\r\n        if (!params) {\r\n            params = {\r\n                depthEffect: null,\r\n                depthDefines: \"\",\r\n                token: GUID.RandomId()\r\n            };\r\n            this._subMeshToDepthEffect.set(subMesh, shadowGenerator, params);\r\n        }\r\n\r\n        let join = defines.join(\"\\n\");\r\n\r\n        if (params.depthEffect) {\r\n            if (join === params.depthDefines) {\r\n                // we already created the depth effect and it is still up to date for this submesh + shadow generator\r\n                return params.depthEffect;\r\n            }\r\n        }\r\n\r\n        params.depthDefines = join;\r\n\r\n        // the depth effect is either out of date or has not been created yet\r\n        let vertexCode = origEffect.rawVertexSourceCode,\r\n            fragmentCode = origEffect.rawFragmentSourceCode;\r\n\r\n        // vertex code\r\n        const vertexNormalBiasCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})` : Effect.IncludesShadersStore[\"shadowMapVertexNormalBias\"],\r\n              vertexMetricCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})` : Effect.IncludesShadersStore[\"shadowMapVertexMetric\"],\r\n              fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})` : Effect.IncludesShadersStore[\"shadowMapFragmentSoftTransparentShadow\"],\r\n              fragmentBlockCode = Effect.IncludesShadersStore[\"shadowMapFragment\"];\r\n\r\n        vertexCode = vertexCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapVertexDeclaration\"] + \"\\r\\nvoid main\");\r\n        vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\r\n\r\n        if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\r\n            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\r\n        } else {\r\n            vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\r\\n}\");\r\n        }\r\n        vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\r\n\r\n        // fragment code\r\n        const hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\r\n        const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\r\n\r\n        let fragmentCodeToInjectAtEnd = \"\";\r\n\r\n        if (!hasLocationForSoftTransparentShadow) {\r\n            fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\r\\n\";\r\n        } else {\r\n            fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\r\n        }\r\n\r\n        fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentDeclaration\"] + \"\\r\\nvoid main\");\r\n\r\n        if (hasLocationForFragment) {\r\n            fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\r\n        } else {\r\n            fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\r\\n\";\r\n        }\r\n        if (fragmentCodeToInjectAtEnd) {\r\n            fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\r\n        }\r\n\r\n        fragmentCode = fragmentCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\r\n\r\n        const uniforms = origEffect.getUniformNames().slice();\r\n\r\n        uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\r\n\r\n        params.depthEffect = this._scene.getEngine().createEffect({\r\n            vertexSource: vertexCode,\r\n            fragmentSource: fragmentCode,\r\n            vertexToken: params.token,\r\n            fragmentToken: params.token,\r\n        }, <IEffectCreationOptions>{\r\n            attributes: origEffect.getAttributesNames(),\r\n            uniformsNames: uniforms,\r\n            uniformBuffersNames: origEffect.getUniformBuffersNames(),\r\n            samplers: origEffect.getSamplers(),\r\n            defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\r\n            indexParameters: origEffect.getIndexParameters(),\r\n        }, this._scene.getEngine());\r\n\r\n        return params.depthEffect;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}