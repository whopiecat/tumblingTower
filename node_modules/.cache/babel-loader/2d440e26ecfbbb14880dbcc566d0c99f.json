{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../../Meshes/mesh\";\nimport { Epsilon, Vector3 } from '../../Maths/math';\nimport { VertexBuffer } from \"../../Meshes/buffer\";\n/**\r\n * RecastJS navigation plugin\r\n */\n\nvar RecastJSPlugin =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the recastJS plugin\r\n   * @param recastInjection can be used to inject your own recast reference\r\n   */\n  function RecastJSPlugin(recastInjection) {\n    if (recastInjection === void 0) {\n      recastInjection = Recast;\n    }\n    /**\r\n     * Reference to the Recast library\r\n     */\n\n\n    this.bjsRECAST = {};\n    /**\r\n     * plugin name\r\n     */\n\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n\n    if (typeof recastInjection === \"function\") {\n      recastInjection(this.bjsRECAST);\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this.setTimeStep();\n  }\n  /**\r\n   * Set the time step of the navigation tick update.\r\n   * Default is 1/60.\r\n   * A value of 0 will disable fixed time update\r\n   * @param newTimeStep the new timestep to apply to this world.\r\n   */\n\n\n  RecastJSPlugin.prototype.setTimeStep = function (newTimeStep) {\n    if (newTimeStep === void 0) {\n      newTimeStep = 1 / 60;\n    }\n\n    this._timeStep = newTimeStep;\n  };\n  /**\r\n   * Get the time step of the navigation tick update.\r\n   * @returns the current time step\r\n   */\n\n\n  RecastJSPlugin.prototype.getTimeStep = function () {\n    return this._timeStep;\n  };\n  /**\r\n   * If delta time in navigation tick update is greater than the time step\r\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n   * they will be discarded.\r\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n   * @param newStepCount the maximum number of iterations\r\n   */\n\n\n  RecastJSPlugin.prototype.setMaximumSubStepCount = function (newStepCount) {\n    if (newStepCount === void 0) {\n      newStepCount = 10;\n    }\n\n    this._maximumSubStepCount = newStepCount;\n  };\n  /**\r\n   * Get the maximum number of iterations per navigation tick update\r\n   * @returns the maximum number of iterations\r\n   */\n\n\n  RecastJSPlugin.prototype.getMaximumSubStepCount = function () {\n    return this._maximumSubStepCount;\n  };\n  /**\r\n   * Creates a navigation mesh\r\n   * @param meshes array of all the geometry used to compute the navigatio mesh\r\n   * @param parameters bunch of parameters used to filter geometry\r\n   */\n\n\n  RecastJSPlugin.prototype.createNavMesh = function (meshes, parameters) {\n    var rc = new this.bjsRECAST.rcConfig();\n    rc.cs = parameters.cs;\n    rc.ch = parameters.ch;\n    rc.borderSize = 0;\n    rc.tileSize = 0;\n    rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n    rc.walkableHeight = parameters.walkableHeight;\n    rc.walkableClimb = parameters.walkableClimb;\n    rc.walkableRadius = parameters.walkableRadius;\n    rc.maxEdgeLen = parameters.maxEdgeLen;\n    rc.maxSimplificationError = parameters.maxSimplificationError;\n    rc.minRegionArea = parameters.minRegionArea;\n    rc.mergeRegionArea = parameters.mergeRegionArea;\n    rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n    rc.detailSampleDist = parameters.detailSampleDist;\n    rc.detailSampleMaxError = parameters.detailSampleMaxError;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    var index;\n    var tri;\n    var pt;\n    var indices = [];\n    var positions = [];\n    var offset = 0;\n\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        var mesh = meshes[index];\n        var meshIndices = mesh.getIndices();\n\n        if (!meshIndices) {\n          continue;\n        }\n\n        var meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n\n        if (!meshPositions) {\n          continue;\n        }\n\n        var wm = mesh.computeWorldMatrix(true);\n\n        for (tri = 0; tri < meshIndices.length; tri++) {\n          indices.push(meshIndices[tri] + offset);\n        }\n\n        var transformed = Vector3.Zero();\n        var position = Vector3.Zero();\n\n        for (pt = 0; pt < meshPositions.length; pt += 3) {\n          Vector3.FromArrayToRef(meshPositions, pt, position);\n          Vector3.TransformCoordinatesToRef(position, wm, transformed);\n          positions.push(transformed.x, transformed.y, transformed.z);\n        }\n\n        offset += meshPositions.length / 3;\n      }\n    }\n\n    this.navMesh.build(positions, offset, indices, indices.length, rc);\n  };\n  /**\r\n   * Create a navigation mesh debug mesh\r\n   * @param scene is where the mesh will be added\r\n   * @returns debug display mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.createDebugNavMesh = function (scene) {\n    var tri;\n    var pt;\n    var debugNavMesh = this.navMesh.getDebugNavMesh();\n    var triangleCount = debugNavMesh.getTriangleCount();\n    var indices = [];\n    var positions = [];\n\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        var point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n\n    var mesh = new Mesh(\"NavMeshDebug\", scene);\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, closest to the parameter position\r\n   * @param position world position\r\n   * @returns the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPoint = function (position) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getClosestPoint(p);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, closest to the parameter position\r\n   * @param position world position\r\n   * @param result output the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getClosestPointToRef = function (position, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getClosestPoint(p);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Get a navigation mesh constrained position, within a particular radius\r\n   * @param position world position\r\n   * @param maxRadius the maximum distance to the constrained world position\r\n   * @returns the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAround = function (position, maxRadius) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getRandomPointAround(p, maxRadius);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Get a navigation mesh constrained position, within a particular radius\r\n   * @param position world position\r\n   * @param maxRadius the maximum distance to the constrained world position\r\n   * @param result output the closest point to position constrained by the navigation mesh\r\n   */\n\n\n  RecastJSPlugin.prototype.getRandomPointAroundToRef = function (position, maxRadius, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var ret = this.navMesh.getRandomPointAround(p, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Compute the final position from a segment made of destination-position\r\n   * @param position world position\r\n   * @param destination world position\r\n   * @returns the resulting point along the navmesh\r\n   */\n\n\n  RecastJSPlugin.prototype.moveAlong = function (position, destination) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\n    var ret = this.navMesh.moveAlong(p, d);\n    var pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  };\n  /**\r\n   * Compute the final position from a segment made of destination-position\r\n   * @param position world position\r\n   * @param destination world position\r\n   * @param result output the resulting point along the navmesh\r\n   */\n\n\n  RecastJSPlugin.prototype.moveAlongToRef = function (position, destination, result) {\n    var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\n    var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\n    var ret = this.navMesh.moveAlong(p, d);\n    result.set(ret.x, ret.y, ret.z);\n  };\n  /**\r\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n   * @param start world position\r\n   * @param end world position\r\n   * @returns array containing world position composing the path\r\n   */\n\n\n  RecastJSPlugin.prototype.computePath = function (start, end) {\n    var pt;\n    var startPos = new this.bjsRECAST.Vec3(start.x, start.y, start.z);\n    var endPos = new this.bjsRECAST.Vec3(end.x, end.y, end.z);\n    var navPath = this.navMesh.computePath(startPos, endPos);\n    var pointCount = navPath.getPointCount();\n    var positions = [];\n\n    for (pt = 0; pt < pointCount; pt++) {\n      var p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n\n    return positions;\n  };\n  /**\r\n   * Create a new Crowd so you can add agents\r\n   * @param maxAgents the maximum agent count in the crowd\r\n   * @param maxAgentRadius the maximum radius an agent can have\r\n   * @param scene to attach the crowd to\r\n   * @returns the crowd you can add agents to\r\n   */\n\n\n  RecastJSPlugin.prototype.createCrowd = function (maxAgents, maxAgentRadius, scene) {\n    var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  };\n  /**\r\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n   * The queries will try to find a solution within those bounds\r\n   * default is (1,1,1)\r\n   * @param extent x,y,z value that define the extent around the queries point of reference\r\n   */\n\n\n  RecastJSPlugin.prototype.setDefaultQueryExtent = function (extent) {\n    var ext = new this.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.navMesh.setDefaultQueryExtent(ext);\n  };\n  /**\r\n   * Get the Bounding box extent specified by setDefaultQueryExtent\r\n   * @returns the box extent values\r\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtent = function () {\n    var p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\r\n   * build the navmesh from a previously saved state using getNavmeshData\r\n   * @param data the Uint8Array returned by getNavmeshData\r\n   */\n\n\n  RecastJSPlugin.prototype.buildFromNavmeshData = function (data) {\n    var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n\n    var dataPtr = this.bjsRECAST._malloc(nDataBytes);\n\n    var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    var buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf); // Free memory\n\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  };\n  /**\r\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n   * @returns data the Uint8Array that can be saved and reused\r\n   */\n\n\n  RecastJSPlugin.prototype.getNavmeshData = function () {\n    var navmeshData = this.navMesh.getNavmeshData();\n    var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    var ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  };\n  /**\r\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n   * @param result output the box extent values\r\n   */\n\n\n  RecastJSPlugin.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\r\n   * Disposes\r\n   */\n\n\n  RecastJSPlugin.prototype.dispose = function () {};\n  /**\r\n   * If this plugin is supported\r\n   * @returns true if plugin is supported\r\n   */\n\n\n  RecastJSPlugin.prototype.isSupported = function () {\n    return this.bjsRECAST !== undefined;\n  };\n\n  return RecastJSPlugin;\n}();\n\nexport { RecastJSPlugin };\n/**\r\n * Recast detour crowd implementation\r\n */\n\nvar RecastJSCrowd =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   * @param plugin recastJS plugin\r\n   * @param maxAgents the maximum agent count in the crowd\r\n   * @param maxAgentRadius the maximum radius an agent can have\r\n   * @param scene to attach the crowd to\r\n   * @returns the crowd you can add agents to\r\n   */\n  function RecastJSCrowd(plugin, maxAgents, maxAgentRadius, scene) {\n    var _this = this;\n    /**\r\n     * Link to the detour crowd\r\n     */\n\n\n    this.recastCrowd = {};\n    /**\r\n     * One transform per agent\r\n     */\n\n    this.transforms = new Array();\n    /**\r\n     * All agents created\r\n     */\n\n    this.agents = new Array();\n    /**\r\n     * Observer for crowd updates\r\n     */\n\n    this._onBeforeAnimationsObserver = null;\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(function () {\n      _this.update(scene.getEngine().getDeltaTime() * 0.001);\n    });\n  }\n  /**\r\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n   * You can attach anything to that node. The node position is updated in the scene update tick.\r\n   * @param pos world position that will be constrained by the navigation mesh\r\n   * @param parameters agent parameters\r\n   * @param transform hooked to the agent that will be update by the scene\r\n   * @returns agent index\r\n   */\n\n\n  RecastJSCrowd.prototype.addAgent = function (pos, parameters, transform) {\n    var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    return agentIndex;\n  };\n  /**\r\n   * Returns the agent position in world space\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPosition = function (index) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\r\n   * Returns the agent position result in world space\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentPositionToRef = function (index, result) {\n    var agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  };\n  /**\r\n   * Returns the agent velocity in world space\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space velocity\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocity = function (index) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\r\n   * Returns the agent velocity result in world space\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space velocity\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentVelocityToRef = function (index, result) {\n    var agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  };\n  /**\r\n   * Returns the agent next target point on the path\r\n   * @param index agent index returned by addAgent\r\n   * @returns world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPath = function (index) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\r\n   * Returns the agent next target point on the path\r\n   * @param index agent index returned by addAgent\r\n   * @param result output world space position\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentNextTargetPathToRef = function (index, result) {\n    var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  };\n  /**\r\n   * Gets the agent state\r\n   * @param index agent index returned by addAgent\r\n   * @returns agent state\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgentState = function (index) {\n    return this.recastCrowd.getAgentState(index);\n  };\n  /**\r\n   * returns true if the agent in over an off mesh link connection\r\n   * @param index agent index returned by addAgent\r\n   * @returns true if over an off mesh link connection\r\n   */\n\n\n  RecastJSCrowd.prototype.overOffmeshConnection = function (index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  };\n  /**\r\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n   * @param index agent index returned by addAgent\r\n   * @param destination targeted world position\r\n   */\n\n\n  RecastJSCrowd.prototype.agentGoto = function (index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  };\n  /**\r\n   * Teleport the agent to a new position\r\n   * @param index agent index returned by addAgent\r\n   * @param destination targeted world position\r\n   */\n\n\n  RecastJSCrowd.prototype.agentTeleport = function (index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  };\n  /**\r\n   * Update agent parameters\r\n   * @param index agent index returned by addAgent\r\n   * @param parameters agent parameters\r\n   */\n\n\n  RecastJSCrowd.prototype.updateAgentParameters = function (index, parameters) {\n    var agentParams = this.recastCrowd.getAgentParameters(index);\n\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  };\n  /**\r\n   * remove a particular agent previously created\r\n   * @param index agent index returned by addAgent\r\n   */\n\n\n  RecastJSCrowd.prototype.removeAgent = function (index) {\n    this.recastCrowd.removeAgent(index);\n    var item = this.agents.indexOf(index);\n\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n    }\n  };\n  /**\r\n   * get the list of all agents attached to this crowd\r\n   * @returns list of agent indices\r\n   */\n\n\n  RecastJSCrowd.prototype.getAgents = function () {\n    return this.agents;\n  };\n  /**\r\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n   * @param deltaTime in seconds\r\n   */\n\n\n  RecastJSCrowd.prototype.update = function (deltaTime) {\n    // update crowd\n    var timeStep = this.bjsRECASTPlugin.getTimeStep();\n    var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      var iterationCount = deltaTime / timeStep;\n\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n\n      for (var i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(timeStep);\n      }\n    } // update transforms\n\n\n    for (var index = 0; index < this.agents.length; index++) {\n      this.transforms[index].position = this.getAgentPosition(this.agents[index]);\n    }\n  };\n  /**\r\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n   * The queries will try to find a solution within those bounds\r\n   * default is (1,1,1)\r\n   * @param extent x,y,z value that define the extent around the queries point of reference\r\n   */\n\n\n  RecastJSCrowd.prototype.setDefaultQueryExtent = function (extent) {\n    var ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  };\n  /**\r\n   * Get the Bounding box extent specified by setDefaultQueryExtent\r\n   * @returns the box extent values\r\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtent = function () {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  };\n  /**\r\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n   * @param result output the box extent values\r\n   */\n\n\n  RecastJSCrowd.prototype.getDefaultQueryExtentToRef = function (result) {\n    var p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  };\n  /**\r\n   * Release all resources\r\n   */\n\n\n  RecastJSCrowd.prototype.dispose = function () {\n    this.recastCrowd.destroy();\n\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n\n    this._onBeforeAnimationsObserver = null;\n  };\n\n  return RecastJSCrowd;\n}();\n\nexport { RecastJSCrowd };","map":{"version":3,"sources":["../../../../sourceES6/core/Navigation/Plugins/recastJSPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3 } from '../../Maths/math';\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\n\r\ndeclare var Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            recastInjection(this.bjsRECAST);\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number\r\n    {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigatio mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void {\r\n        const rc = new this.bjsRECAST.rcConfig();\r\n        rc.cs = parameters.cs;\r\n        rc.ch = parameters.ch;\r\n        rc.borderSize = 0;\r\n        rc.tileSize = 0;\r\n        rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n        rc.walkableHeight = parameters.walkableHeight;\r\n        rc.walkableClimb = parameters.walkableClimb;\r\n        rc.walkableRadius = parameters.walkableRadius;\r\n        rc.maxEdgeLen = parameters.maxEdgeLen;\r\n        rc.maxSimplificationError = parameters.maxSimplificationError;\r\n        rc.minRegionArea = parameters.minRegionArea;\r\n        rc.mergeRegionArea = parameters.mergeRegionArea;\r\n        rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n        rc.detailSampleDist = parameters.detailSampleDist;\r\n        rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        var index: number;\r\n        var tri: number;\r\n        var pt: number;\r\n\r\n        var indices = [];\r\n        var positions = [];\r\n        var offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                var mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const wm = mesh.computeWorldMatrix(true);\r\n\r\n                for (tri = 0; tri < meshIndices.length; tri++) {\r\n                    indices.push(meshIndices[tri] + offset);\r\n                }\r\n\r\n                var transformed = Vector3.Zero();\r\n                var position = Vector3.Zero();\r\n                for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                    Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                    Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                    positions.push(transformed.x, transformed.y, transformed.z);\r\n                }\r\n\r\n                offset += meshPositions.length / 3;\r\n            }\r\n        }\r\n\r\n        this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        var tri: number;\r\n        var pt: number;\r\n        var debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        let triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        var indices = [];\r\n        var positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++)\r\n        {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++)\r\n        {\r\n            for (pt = 0; pt < 3 ; pt++)\r\n            {\r\n                let point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        var mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        var vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3) : Vector3\r\n    {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getClosestPoint(p);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3) : void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getClosestPoint(p);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getRandomPointAround(p, maxRadius);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var ret = this.navMesh.getRandomPointAround(p, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\r\n        var ret = this.navMesh.moveAlong(p, d);\r\n        var pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        var p = new this.bjsRECAST.Vec3(position.x, position.y, position.z);\r\n        var d = new this.bjsRECAST.Vec3(destination.x, destination.y, destination.z);\r\n        var ret = this.navMesh.moveAlong(p, d);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[]\r\n    {\r\n        var pt: number;\r\n        let startPos = new this.bjsRECAST.Vec3(start.x, start.y, start.z);\r\n        let endPos = new this.bjsRECAST.Vec3(end.x, end.y, end.z);\r\n        let navPath = this.navMesh.computePath(startPos, endPos);\r\n        let pointCount = navPath.getPointCount();\r\n        var positions = [];\r\n        for (pt = 0; pt < pointCount; pt++)\r\n        {\r\n            let p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene) : ICrowd\r\n    {\r\n        var crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void\r\n    {\r\n        let ext = new this.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.navMesh.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3\r\n    {\r\n        let p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void\r\n    {\r\n        var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        var dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        var dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        let buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array\r\n    {\r\n        let navmeshData = this.navMesh.getNavmeshData();\r\n        var arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        var ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void\r\n    {\r\n        let p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {\r\n\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number\r\n    {\r\n        var agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        var agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        var agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        var agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        var agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        var agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        var pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        var agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        var item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update crowd\r\n        var timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        var maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            var iterationCount = deltaTime / timeStep;\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(timeStep);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            this.transforms[index].position = this.getAgentPosition(this.agents[index]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void\r\n    {\r\n        let ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3\r\n    {\r\n        let p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void\r\n    {\r\n        let p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose() : void\r\n    {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}