{"ast":null,"code":"import { SceneComponentConstants } from \"../sceneComponent\";\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\n\nvar LayerSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function LayerSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_LAYER;\n    this.scene = scene;\n    this._engine = scene.getEngine();\n    scene.layers = new Array();\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  LayerSceneComponent.prototype.register = function () {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\n\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\n\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\n\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  LayerSceneComponent.prototype.rebuild = function () {\n    var layers = this.scene.layers;\n\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\n      var layer = layers_1[_i];\n\n      layer._rebuild();\n    }\n  };\n  /**\r\n   * Disposes the component and the associated ressources.\r\n   */\n\n\n  LayerSceneComponent.prototype.dispose = function () {\n    var layers = this.scene.layers;\n\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  };\n\n  LayerSceneComponent.prototype._draw = function (predicate) {\n    var layers = this.scene.layers;\n\n    if (layers.length) {\n      this._engine.setDepthBuffer(false);\n\n      for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\n        var layer = layers_2[_i];\n\n        if (predicate(layer)) {\n          layer.render();\n        }\n      }\n\n      this._engine.setDepthBuffer(true);\n    }\n  };\n\n  LayerSceneComponent.prototype._drawCameraPredicate = function (layer, isBackground, cameraLayerMask) {\n    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && (layer.layerMask & cameraLayerMask) !== 0;\n  };\n\n  LayerSceneComponent.prototype._drawCameraBackground = function (camera) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawCameraPredicate(layer, true, camera.layerMask);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawCameraForeground = function (camera) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawCameraPredicate(layer, false, camera.layerMask);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetPredicate = function (layer, isBackground, cameraLayerMask, renderTargetTexture) {\n    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetBackground = function (renderTarget) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawRenderTargetPredicate(layer, true, _this.scene.activeCamera.layerMask, renderTarget);\n    });\n  };\n\n  LayerSceneComponent.prototype._drawRenderTargetForeground = function (renderTarget) {\n    var _this = this;\n\n    this._draw(function (layer) {\n      return _this._drawRenderTargetPredicate(layer, false, _this.scene.activeCamera.layerMask, renderTarget);\n    });\n  };\n  /**\r\n   * Adds all the elements from the container to the scene\r\n   * @param container the container holding the elements\r\n   */\n\n\n  LayerSceneComponent.prototype.addFromContainer = function (container) {\n    var _this = this;\n\n    if (!container.layers) {\n      return;\n    }\n\n    container.layers.forEach(function (layer) {\n      _this.scene.layers.push(layer);\n    });\n  };\n  /**\r\n   * Removes all the elements in the container from the scene\r\n   * @param container contains the elements to remove\r\n   * @param dispose if the removed element should be disposed (default: false)\r\n   */\n\n\n  LayerSceneComponent.prototype.removeFromContainer = function (container, dispose) {\n    var _this = this;\n\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    if (!container.layers) {\n      return;\n    }\n\n    container.layers.forEach(function (layer) {\n      var index = _this.scene.layers.indexOf(layer);\n\n      if (index !== -1) {\n        _this.scene.layers.splice(index, 1);\n      }\n\n      if (dispose) {\n        layer.dispose();\n      }\n    });\n  };\n\n  return LayerSceneComponent;\n}();\n\nexport { LayerSceneComponent };","map":{"version":3,"sources":["../../../sourceES6/core/Layers/layerSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { SceneComponentConstants, ISceneComponent } from \"../sceneComponent\";\r\nimport { Layer } from \"./layer\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { AbstractScene } from '../abstractScene';\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForeground);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForeground);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        let layers = this.scene.layers;\r\n\r\n        for (let layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        let layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        let layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (let layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number): boolean {\r\n        return !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            ((layer.layerMask & cameraLayerMask) !== 0);\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForeground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (layer.renderTargetTextures.length > 0) &&\r\n            layer.isBackground === isBackground &&\r\n            (layer.renderTargetTextures.indexOf(renderTargetTexture) > -1) &&\r\n            ((layer.layerMask & cameraLayerMask) !== 0);\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForeground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            var index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}