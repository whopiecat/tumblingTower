{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { TargetCamera } from \"./targetCamera\";\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager\";\nimport { Tools } from '../Misc/tools';\n/**\r\n * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n * such as in a 3D Space Shooter or a Flight Simulator.\r\n */\n\nvar FlyCamera =\n/** @class */\nfunction (_super) {\n  __extends(FlyCamera, _super);\n  /**\r\n   * Instantiates a FlyCamera.\r\n   * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n   * such as in a 3D Space Shooter or a Flight Simulator.\r\n   * @param name Define the name of the camera in the scene.\r\n   * @param position Define the starting position of the camera in the scene.\r\n   * @param scene Define the scene the camera belongs to.\r\n   * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.\r\n  */\n\n\n  function FlyCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful for simulating a camera body, like a player's body.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\n\n\n    _this.ellipsoid = new Vector3(1, 1, 1);\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful if the camera is attached away from the player's body center,\r\n     * such as at its head.\r\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\n\n    _this.checkCollisions = false;\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\n\n    _this.applyGravity = false;\n    /**\r\n     * Define the current direction the camera is moving to.\r\n     */\n\n    _this.cameraDirection = Vector3.Zero();\n    /**\r\n     * Track Roll to maintain the wanted Rolling when looking around.\r\n     */\n\n    _this._trackRoll = 0;\n    /**\r\n    * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\r\n    */\n\n    _this.rollCorrect = 100;\n    /**\r\n     * Mimic a banked turn, Rolling the camera when Yawing.\r\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\r\n     */\n\n    _this.bankedTurn = false;\n    /**\r\n     * Limit in radians for how much Roll banking will add. (Default: 90Â°)\r\n     */\n\n    _this.bankedTurnLimit = Math.PI / 2;\n    /**\r\n     * Value of 0 disables the banked Roll.\r\n     * Value of 1 is equal to the Yaw angle in radians.\r\n     */\n\n    _this.bankedTurnMultiplier = 1;\n    _this._needMoveForGravity = false;\n    _this._oldPosition = Vector3.Zero();\n    _this._diffPosition = Vector3.Zero();\n    _this._newPosition = Vector3.Zero(); // Collisions.\n\n    _this._collisionMask = -1;\n    /** @hidden */\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      var updatePosition = function (newPos) {\n        _this._newPosition.copyFrom(newPos);\n\n        _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);\n\n        if (_this._diffPosition.length() > Engine.CollisionsEpsilon) {\n          _this.position.addInPlace(_this._diffPosition);\n\n          if (_this.onCollide && collidedMesh) {\n            _this.onCollide(collidedMesh);\n          }\n        }\n      };\n\n      updatePosition(newPosition);\n    };\n\n    _this.inputs = new FlyCameraInputsManager(_this);\n\n    _this.inputs.addKeyboard().addMouse();\n\n    return _this;\n  }\n\n  Object.defineProperty(FlyCamera.prototype, \"angularSensibility\", {\n    /**\r\n     * Gets the input sensibility for mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\n    get: function () {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        return mouse.angularSensibility;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Sets the input sensibility for a mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\n    set: function (value) {\n      var mouse = this.inputs.attached[\"mouse\"];\n\n      if (mouse) {\n        mouse.angularSensibility = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysForward\", {\n    /**\r\n     * Get the keys for camera movement forward.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysForward;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement forward.\r\n    */\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysForward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysBackward\", {\n    /**\r\n     * Get the keys for camera movement backward.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysBackward;\n      }\n\n      return [];\n    },\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysBackward = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysUp\", {\n    /**\r\n     * Get the keys for camera movement up.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysUp;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement up.\r\n    */\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysUp = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysDown\", {\n    /**\r\n     * Get the keys for camera movement down.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysDown;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement down.\r\n    */\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysDown = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysLeft\", {\n    /**\r\n     * Get the keys for camera movement left.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysLeft;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement left.\r\n    */\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysLeft = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FlyCamera.prototype, \"keysRight\", {\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\n    get: function () {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        return keyboard.keysRight;\n      }\n\n      return [];\n    },\n\n    /**\r\n    * Set the keys for camera movement right.\r\n    */\n    set: function (value) {\n      var keyboard = this.inputs.attached[\"keyboard\"];\n\n      if (keyboard) {\n        keyboard.keysRight = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Attached controls to the current camera.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n  FlyCamera.prototype.attachControl = function (ignored, noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  };\n  /**\r\n   * Detach a control from the HTML DOM element.\r\n   * The camera will stop reacting to that input.\r\n   */\n\n\n  FlyCamera.prototype.detachControl = function () {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n  };\n\n  Object.defineProperty(FlyCamera.prototype, \"collisionMask\", {\n    /**\r\n     * Get the mask that the camera ignores in collision events.\r\n     */\n    get: function () {\n      return this._collisionMask;\n    },\n\n    /**\r\n    * Set the mask that the camera ignores in collision events.\r\n    */\n    set: function (mask) {\n      this._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  FlyCamera.prototype._collideWithWorld = function (displacement) {\n    var globalPosition;\n\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask; // No need for clone, as long as gravity is not on.\n\n    var actualDisplacement = displacement; // Add gravity to direction to prevent dual-collision checking.\n\n    if (this.applyGravity) {\n      // This prevents mending with cameraDirection, a global variable of the fly camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._checkInputs = function () {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n\n    this.inputs.checkInputs();\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._decideIfNeedsToMove = function () {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  FlyCamera.prototype._updatePosition = function () {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      _super.prototype._updatePosition.call(this);\n    }\n  };\n  /**\r\n   * Restore the Roll to its target value at the rate specified.\r\n   * @param rate - Higher means slower restoring.\r\n   * @hidden\r\n   */\n\n\n  FlyCamera.prototype.restoreRoll = function (rate) {\n    var limit = this._trackRoll; // Target Roll.\n\n    var z = this.rotation.z; // Current Roll.\n\n    var delta = limit - z; // Difference in Roll.\n\n    var minRad = 0.001; // Tenth of a radian is a barely noticable difference.\n    // If the difference is noticable, restore the Roll.\n\n    if (Math.abs(delta) >= minRad) {\n      // Change Z rotation towards the target Roll.\n      this.rotation.z += delta / rate; // Match when near enough.\n\n      if (Math.abs(limit - this.rotation.z) <= minRad) {\n        this.rotation.z = limit;\n      }\n    }\n  };\n  /**\r\n   * Destroy the camera and release the current resources held by it.\r\n   */\n\n\n  FlyCamera.prototype.dispose = function () {\n    this.inputs.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Get the current object class name.\r\n   * @returns the class name.\r\n   */\n\n\n  FlyCamera.prototype.getClassName = function () {\n    return \"FlyCamera\";\n  };\n\n  __decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoid\", void 0);\n\n  __decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoidOffset\", void 0);\n\n  __decorate([serialize()], FlyCamera.prototype, \"checkCollisions\", void 0);\n\n  __decorate([serialize()], FlyCamera.prototype, \"applyGravity\", void 0);\n\n  return FlyCamera;\n}(TargetCamera);\n\nexport { FlyCamera };","map":{"version":3,"sources":["../../../sourceES6/core/Cameras/flyCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager\";\r\nimport { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput\";\r\nimport { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput\";\r\nimport { Tools } from '../Misc/tools';\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n * such as in a 3D Space Shooter or a Flight Simulator.\r\n */\r\nexport class FlyCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful for simulating a camera body, like a player's body.\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful if the camera is attached away from the player's body center,\r\n     * such as at its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to.\r\n     */\r\n    public cameraDirection = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current local rotation of the camera as a quaternion to prevent Gimbal lock.\r\n     * This overrides and empties cameraRotation.\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Track Roll to maintain the wanted Rolling when looking around.\r\n     */\r\n    public _trackRoll: number = 0;\r\n\r\n    /**\r\n    * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\r\n    */\r\n    public rollCorrect: number = 100;\r\n\r\n    /**\r\n     * Mimic a banked turn, Rolling the camera when Yawing.\r\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\r\n     */\r\n    public bankedTurn: boolean = false;\r\n\r\n    /**\r\n     * Limit in radians for how much Roll banking will add. (Default: 90Â°)\r\n     */\r\n    public bankedTurnLimit: number = Math.PI / 2;\r\n\r\n    /**\r\n     * Value of 0 disables the banked Roll.\r\n     * Value of 1 is equal to the Yaw angle in radians.\r\n     */\r\n    public bankedTurnMultiplier: number = 1;\r\n\r\n    /**\r\n     * The inputs manager loads all the input sources, such as keyboard and mouse.\r\n     */\r\n    public inputs: FlyCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        var mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        var mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement forward.\r\n     */\r\n    public get keysForward(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysForward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n    * Set the keys for camera movement forward.\r\n    */\r\n    public set keysForward(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysForward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement backward.\r\n     */\r\n    public get keysBackward(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysBackward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysBackward(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysBackward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement up.\r\n     */\r\n    public get keysUp(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n    * Set the keys for camera movement up.\r\n    */\r\n    public set keysUp(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement down.\r\n     */\r\n    public get keysDown(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n    * Set the keys for camera movement down.\r\n    */\r\n    public set keysDown(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement left.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n    * Set the keys for camera movement left.\r\n    */\r\n    public set keysLeft(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\r\n    public get keysRight(): number[] {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n    * Set the keys for camera movement right.\r\n    */\r\n    public set keysRight(value: number[]) {\r\n        var keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collides with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _localDirection: Vector3;\r\n    /** @hidden */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a FlyCamera.\r\n     * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n     * such as in a 3D Space Shooter or a Flight Simulator.\r\n     * @param name Define the name of the camera in the scene.\r\n     * @param position Define the starting position of the camera in the scene.\r\n     * @param scene Define the scene the camera belongs to.\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active, if no other camera has been defined as active.\r\n    */\r\n    constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FlyCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach a control from the HTML DOM element.\r\n     * The camera will stop reacting to that input.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n    }\r\n\r\n    // Collisions.\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Get the mask that the camera ignores in collision events.\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    /**\r\n    * Set the mask that the camera ignores in collision events.\r\n    */\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        var globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n        let coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        // No need for clone, as long as gravity is not on.\r\n        var actualDisplacement = displacement;\r\n\r\n        // Add gravity to direction to prevent dual-collision checking.\r\n        if (this.applyGravity) {\r\n            // This prevents mending with cameraDirection, a global variable of the fly camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    /** @hidden */\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n\r\n        var updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore the Roll to its target value at the rate specified.\r\n     * @param rate - Higher means slower restoring.\r\n     * @hidden\r\n     */\r\n    public restoreRoll(rate: number): void {\r\n        let limit = this._trackRoll;    // Target Roll.\r\n        let z = this.rotation.z; // Current Roll.\r\n        let delta = limit - z;          // Difference in Roll.\r\n\r\n        let minRad = 0.001; // Tenth of a radian is a barely noticable difference.\r\n\r\n        // If the difference is noticable, restore the Roll.\r\n        if (Math.abs(delta) >= minRad) {\r\n            // Change Z rotation towards the target Roll.\r\n            this.rotation.z += delta / rate;\r\n\r\n            // Match when near enough.\r\n            if (Math.abs(limit - this.rotation.z) <= minRad) {\r\n                this.rotation.z = limit;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources held by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Get the current object class name.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCamera\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}