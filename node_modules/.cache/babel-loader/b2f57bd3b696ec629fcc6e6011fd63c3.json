{"ast":null,"code":"/**\r\n * Base class of the scene acting as a container for the different elements composing a scene.\r\n * This class is dynamically extended by the different components of the scene increasing\r\n * flexibility and reducing coupling\r\n */\nvar AbstractScene =\n/** @class */\nfunction () {\n  function AbstractScene() {\n    /**\r\n     * Gets the list of root nodes (ie. nodes with no parent)\r\n     */\n    this.rootNodes = new Array();\n    /** All of the cameras added to this scene\r\n     * @see https://doc.babylonjs.com/babylon101/cameras\r\n     */\n\n    this.cameras = new Array();\n    /**\r\n    * All of the lights added to this scene\r\n    * @see https://doc.babylonjs.com/babylon101/lights\r\n    */\n\n    this.lights = new Array();\n    /**\r\n    * All of the (abstract) meshes added to this scene\r\n    */\n\n    this.meshes = new Array();\n    /**\r\n     * The list of skeletons added to the scene\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\n\n    this.skeletons = new Array();\n    /**\r\n    * All of the particle systems added to this scene\r\n    * @see https://doc.babylonjs.com/babylon101/particles\r\n    */\n\n    this.particleSystems = new Array();\n    /**\r\n     * Gets a list of Animations associated with the scene\r\n     */\n\n    this.animations = [];\n    /**\r\n    * All of the animation groups added to this scene\r\n    * @see https://doc.babylonjs.com/how_to/group\r\n    */\n\n    this.animationGroups = new Array();\n    /**\r\n    * All of the multi-materials added to this scene\r\n    * @see https://doc.babylonjs.com/how_to/multi_materials\r\n    */\n\n    this.multiMaterials = new Array();\n    /**\r\n    * All of the materials added to this scene\r\n    * In the context of a Scene, it is not supposed to be modified manually.\r\n    * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\r\n    * Note also that the order of the Material within the array is not significant and might change.\r\n    * @see https://doc.babylonjs.com/babylon101/materials\r\n    */\n\n    this.materials = new Array();\n    /**\r\n     * The list of morph target managers added to the scene\r\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh\r\n     */\n\n    this.morphTargetManagers = new Array();\n    /**\r\n     * The list of geometries used in the scene.\r\n     */\n\n    this.geometries = new Array();\n    /**\r\n    * All of the tranform nodes added to this scene\r\n    * In the context of a Scene, it is not supposed to be modified manually.\r\n    * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\r\n    * Note also that the order of the TransformNode wihin the array is not significant and might change.\r\n    * @see https://doc.babylonjs.com/how_to/transformnode\r\n    */\n\n    this.transformNodes = new Array();\n    /**\r\n     * ActionManagers available on the scene.\r\n     */\n\n    this.actionManagers = new Array();\n    /**\r\n     * Textures to keep.\r\n     */\n\n    this.textures = new Array();\n    /** @hidden */\n\n    this._environmentTexture = null;\n    /**\r\n     * The list of postprocesses added to the scene\r\n     */\n\n    this.postProcesses = new Array();\n  }\n  /**\r\n   * Adds a parser in the list of available ones\r\n   * @param name Defines the name of the parser\r\n   * @param parser Defines the parser to add\r\n   */\n\n\n  AbstractScene.AddParser = function (name, parser) {\n    this._BabylonFileParsers[name] = parser;\n  };\n  /**\r\n   * Gets a general parser from the list of avaialble ones\r\n   * @param name Defines the name of the parser\r\n   * @returns the requested parser or null\r\n   */\n\n\n  AbstractScene.GetParser = function (name) {\n    if (this._BabylonFileParsers[name]) {\n      return this._BabylonFileParsers[name];\n    }\n\n    return null;\n  };\n  /**\r\n   * Adds n individual parser in the list of available ones\r\n   * @param name Defines the name of the parser\r\n   * @param parser Defines the parser to add\r\n   */\n\n\n  AbstractScene.AddIndividualParser = function (name, parser) {\n    this._IndividualBabylonFileParsers[name] = parser;\n  };\n  /**\r\n   * Gets an individual parser from the list of avaialble ones\r\n   * @param name Defines the name of the parser\r\n   * @returns the requested parser or null\r\n   */\n\n\n  AbstractScene.GetIndividualParser = function (name) {\n    if (this._IndividualBabylonFileParsers[name]) {\n      return this._IndividualBabylonFileParsers[name];\n    }\n\n    return null;\n  };\n  /**\r\n   * Parser json data and populate both a scene and its associated container object\r\n   * @param jsonData Defines the data to parse\r\n   * @param scene Defines the scene to parse the data for\r\n   * @param container Defines the container attached to the parsing sequence\r\n   * @param rootUrl Defines the root url of the data\r\n   */\n\n\n  AbstractScene.Parse = function (jsonData, scene, container, rootUrl) {\n    for (var parserName in this._BabylonFileParsers) {\n      if (this._BabylonFileParsers.hasOwnProperty(parserName)) {\n        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\n      }\n    }\n  };\n\n  Object.defineProperty(AbstractScene.prototype, \"environmentTexture\", {\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\n    get: function () {\n      return this._environmentTexture;\n    },\n    set: function (value) {\n      this._environmentTexture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * @returns all meshes, lights, cameras, transformNodes and bones\r\n   */\n\n  AbstractScene.prototype.getNodes = function () {\n    var nodes = new Array();\n    nodes = nodes.concat(this.meshes);\n    nodes = nodes.concat(this.lights);\n    nodes = nodes.concat(this.cameras);\n    nodes = nodes.concat(this.transformNodes); // dummies\n\n    this.skeletons.forEach(function (skeleton) {\n      return nodes = nodes.concat(skeleton.bones);\n    });\n    return nodes;\n  };\n  /**\r\n   * Stores the list of available parsers in the application.\r\n   */\n\n\n  AbstractScene._BabylonFileParsers = {};\n  /**\r\n   * Stores the list of available individual parsers in the application.\r\n   */\n\n  AbstractScene._IndividualBabylonFileParsers = {};\n  return AbstractScene;\n}();\n\nexport { AbstractScene };","map":{"version":3,"sources":["../../sourceES6/core/abstractScene.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"./scene\";\r\nimport { Nullable } from \"./types\";\r\nimport { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport { TransformNode } from \"./Meshes/transformNode\";\r\nimport { Geometry } from \"./Meshes/geometry\";\r\nimport { Skeleton } from \"./Bones/skeleton\";\r\nimport { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport { AssetContainer } from \"./assetContainer\";\r\nimport { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport { Material } from \"./Materials/material\";\r\nimport { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport { Camera } from \"./Cameras/camera\";\r\nimport { Light } from \"./Lights/light\";\r\nimport { Node } from \"./node\";\r\n\r\ndeclare type Animation = import(\"./Animations/animation\").Animation;\r\ndeclare type PostProcess = import(\"./PostProcesses/postProcess\").PostProcess;\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Base class of the scene acting as a container for the different elements composing a scene.\r\n * This class is dynamically extended by the different components of the scene increasing\r\n * flexibility and reducing coupling\r\n */\r\nexport abstract class AbstractScene {\r\n    /**\r\n     * Stores the list of available parsers in the application.\r\n     */\r\n    private static _BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n    /**\r\n     * Stores the list of available individual parsers in the application.\r\n     */\r\n    private static _IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n    /**\r\n     * Adds a parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddParser(name: string, parser: BabylonFileParser): void {\r\n        this._BabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets a general parser from the list of avaialble ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetParser(name: string): Nullable<BabylonFileParser> {\r\n        if (this._BabylonFileParsers[name]) {\r\n            return this._BabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adds n individual parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n        this._IndividualBabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets an individual parser from the list of avaialble ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n        if (this._IndividualBabylonFileParsers[name]) {\r\n            return this._IndividualBabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parser json data and populate both a scene and its associated container object\r\n     * @param jsonData Defines the data to parse\r\n     * @param scene Defines the scene to parse the data for\r\n     * @param container Defines the container attached to the parsing sequence\r\n     * @param rootUrl Defines the root url of the data\r\n     */\r\n    public static Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n        for (let parserName in this._BabylonFileParsers) {\r\n            if (this._BabylonFileParsers.hasOwnProperty(parserName)) {\r\n                this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of root nodes (ie. nodes with no parent)\r\n     */\r\n    public rootNodes = new Array<Node>();\r\n\r\n    /** All of the cameras added to this scene\r\n     * @see https://doc.babylonjs.com/babylon101/cameras\r\n     */\r\n    public cameras = new Array<Camera>();\r\n\r\n    /**\r\n    * All of the lights added to this scene\r\n    * @see https://doc.babylonjs.com/babylon101/lights\r\n    */\r\n    public lights = new Array<Light>();\r\n\r\n    /**\r\n    * All of the (abstract) meshes added to this scene\r\n    */\r\n    public meshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * The list of skeletons added to the scene\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\r\n    public skeletons = new Array<Skeleton>();\r\n\r\n    /**\r\n    * All of the particle systems added to this scene\r\n    * @see https://doc.babylonjs.com/babylon101/particles\r\n    */\r\n    public particleSystems = new Array<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets a list of Animations associated with the scene\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n    * All of the animation groups added to this scene\r\n    * @see https://doc.babylonjs.com/how_to/group\r\n    */\r\n    public animationGroups = new Array<AnimationGroup>();\r\n\r\n    /**\r\n    * All of the multi-materials added to this scene\r\n    * @see https://doc.babylonjs.com/how_to/multi_materials\r\n    */\r\n    public multiMaterials = new Array<MultiMaterial>();\r\n\r\n    /**\r\n    * All of the materials added to this scene\r\n    * In the context of a Scene, it is not supposed to be modified manually.\r\n    * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\r\n    * Note also that the order of the Material within the array is not significant and might change.\r\n    * @see https://doc.babylonjs.com/babylon101/materials\r\n    */\r\n    public materials = new Array<Material>();\r\n\r\n    /**\r\n     * The list of morph target managers added to the scene\r\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh\r\n     */\r\n    public morphTargetManagers = new Array<MorphTargetManager>();\r\n\r\n    /**\r\n     * The list of geometries used in the scene.\r\n     */\r\n    public geometries = new Array<Geometry>();\r\n\r\n    /**\r\n    * All of the tranform nodes added to this scene\r\n    * In the context of a Scene, it is not supposed to be modified manually.\r\n    * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\r\n    * Note also that the order of the TransformNode wihin the array is not significant and might change.\r\n    * @see https://doc.babylonjs.com/how_to/transformnode\r\n    */\r\n    public transformNodes = new Array<TransformNode>();\r\n\r\n    /**\r\n     * ActionManagers available on the scene.\r\n     */\r\n    public actionManagers = new Array<AbstractActionManager>();\r\n\r\n    /**\r\n     * Textures to keep.\r\n     */\r\n    public textures = new Array<BaseTexture>();\r\n\r\n    /** @hidden */\r\n    protected _environmentTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        this._environmentTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The list of postprocesses added to the scene\r\n     */\r\n    public postProcesses = new Array<PostProcess>();\r\n\r\n    /**\r\n     * @returns all meshes, lights, cameras, transformNodes and bones\r\n     */\r\n    public getNodes(): Array<Node> {\r\n        let nodes = new Array<Node>();\r\n        nodes = nodes.concat(this.meshes);\r\n        nodes = nodes.concat(this.lights);\r\n        nodes = nodes.concat(this.cameras);\r\n        nodes = nodes.concat(this.transformNodes); // dummies\r\n        this.skeletons.forEach((skeleton) => nodes = nodes.concat(skeleton.bones));\r\n        return nodes;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}