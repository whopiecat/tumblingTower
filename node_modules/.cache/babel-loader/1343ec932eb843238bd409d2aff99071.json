{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SerializationHelper } from \"../../Misc/decorators\";\nimport { EnvironmentTextureTools } from \"../../Misc/environmentTextureTools\";\nimport { InternalTextureSource } from \"./internalTexture\";\nimport { CubeTexture } from \"./cubeTexture\";\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\n\nvar RawCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawCubeTexture, _super);\n  /**\r\n   * Creates a cube texture where the raw buffers are passed in.\r\n   * @param scene defines the scene the texture is attached to\r\n   * @param data defines the array of data to use to create each face\r\n   * @param size defines the size of the textures\r\n   * @param format defines the format of the data\r\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n   * @param generateMipMaps  defines if the engine should generate the mip levels\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n   * @param compression defines the compression used (null by default)\r\n   */\n\n\n  function RawCubeTexture(scene, data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n    if (format === void 0) {\n      format = 5;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    var _this = _super.call(this, \"\", scene) || this;\n\n    _this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n    return _this;\n  }\n  /**\r\n   * Updates the raw cube texture.\r\n   * @param data defines the data to store\r\n   * @param format defines the data format\r\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param compression defines the compression used (null by default)\r\n   * @param level defines which level of the texture to update\r\n   */\n\n\n  RawCubeTexture.prototype.update = function (data, format, type, invertY, compression) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n  };\n  /**\r\n   * Updates a raw cube texture with RGBD encoded data.\r\n   * @param data defines the array of data [mipmap][face] to use to create each face\r\n   * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n   * @returns a promsie that resolves when the operation is complete\r\n   */\n\n\n  RawCubeTexture.prototype.updateRGBDAsync = function (data, sphericalPolynomial, lodScale, lodOffset) {\n    if (sphericalPolynomial === void 0) {\n      sphericalPolynomial = null;\n    }\n\n    if (lodScale === void 0) {\n      lodScale = 0.8;\n    }\n\n    if (lodOffset === void 0) {\n      lodOffset = 0;\n    }\n\n    return RawCubeTexture._UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset);\n  };\n  /**\r\n   * Clones the raw cube texture.\r\n   * @return a new cube texture\r\n   */\n\n\n  RawCubeTexture.prototype.clone = function () {\n    var _this = this;\n\n    return SerializationHelper.Clone(function () {\n      var scene = _this.getScene();\n\n      var internalTexture = _this._texture;\n      var texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n\n      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n      }\n\n      return texture;\n    }, this);\n  };\n  /** @hidden */\n\n\n  RawCubeTexture._UpdateRGBDAsync = function (internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(function () {\n      internalTexture.isReady = true;\n    });\n  };\n\n  return RawCubeTexture;\n}(CubeTexture);\n\nexport { RawCubeTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/rawCubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { SerializationHelper } from \"../../Misc/decorators\";\r\nimport { EnvironmentTextureTools } from \"../../Misc/environmentTextureTools\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"./internalTexture\";\r\nimport { CubeTexture } from \"./cubeTexture\";\r\n\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Engine } from '../../Engines/engine';\r\n\r\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\r\nexport class RawCubeTexture extends CubeTexture {\r\n    /**\r\n     * Creates a cube texture where the raw buffers are passed in.\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    constructor(scene: Scene, data: Nullable<ArrayBufferView[]>, size: number,\r\n        format: number = 5, type: number = 0,\r\n        generateMipMaps: boolean = false, invertY: boolean = false, samplingMode: number = 3,\r\n        compression: Nullable<string> = null) {\r\n        super(\"\", scene);\r\n\r\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates the raw cube texture.\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     * @param level defines which level of the texture to update\r\n     */\r\n    public update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null): void {\r\n        (this._texture!.getEngine() as Engine).updateRawCubeTexture(this._texture!, data, format, type, invertY, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates a raw cube texture with RGBD encoded data.\r\n     * @param data defines the array of data [mipmap][face] to use to create each face\r\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns a promsie that resolves when the operation is complete\r\n     */\r\n    public updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial> = null, lodScale: number = 0.8, lodOffset: number = 0): Promise<void> {\r\n        return RawCubeTexture._UpdateRGBDAsync(this._texture!, data, sphericalPolynomial, lodScale, lodOffset);\r\n    }\r\n\r\n    /**\r\n     * Clones the raw cube texture.\r\n     * @return a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        return SerializationHelper.Clone(() => {\r\n            const scene = this.getScene()!;\r\n            const internalTexture = this._texture!;\r\n\r\n            const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray!, internalTexture.width, internalTexture.format, internalTexture.type,\r\n                internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\r\n\r\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\r\n                texture.updateRGBDAsync(internalTexture._bufferViewArrayArray!, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\r\n            }\r\n\r\n            return texture;\r\n        }, this);\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _UpdateRGBDAsync(internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number): Promise<void> {\r\n        internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n        internalTexture._bufferViewArrayArray = data;\r\n        internalTexture._lodGenerationScale = lodScale;\r\n        internalTexture._lodGenerationOffset = lodOffset;\r\n        internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n        return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(() => {\r\n            internalTexture.isReady = true;\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}