{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\n\nvar WebXRHitTest =\n/** @class */\nfunction (_super) {\n  __extends(WebXRHitTest, _super);\n  /**\r\n   * Creates a new instance of the hit test feature\r\n   * @param _xrSessionManager an instance of WebXRSessionManager\r\n   * @param options options to use when constructing this feature\r\n   */\n\n\n  function WebXRHitTest(_xrSessionManager,\n  /**\r\n   * options to use when constructing this feature\r\n   */\n  options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this.options = options;\n    _this._tmpMat = new Matrix();\n    _this._tmpPos = new Vector3();\n    _this._tmpQuat = new Quaternion();\n\n    _this.initHitTestSource = function (referenceSpace) {\n      if (!referenceSpace) {\n        return;\n      }\n\n      var offsetRay = new XRRay(_this.options.offsetRay || {});\n      var hitTestOptions = {\n        space: _this.options.useReferenceSpace ? referenceSpace : _this._xrSessionManager.viewerReferenceSpace,\n        offsetRay: offsetRay\n      };\n\n      if (_this.options.entityTypes) {\n        hitTestOptions.entityTypes = _this.options.entityTypes;\n      }\n\n      if (!hitTestOptions.space) {\n        Tools.Warn(\"waiting for viewer reference space to initialize\");\n        return;\n      }\n\n      _this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(function (hitTestSource) {\n        if (_this._xrHitTestSource) {\n          _this._xrHitTestSource.cancel();\n        }\n\n        _this._xrHitTestSource = hitTestSource;\n      });\n    };\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\n\n\n    _this.autoCloneTransformation = false;\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\n\n    _this.onHitTestResultObservable = new Observable();\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\n\n    _this.paused = false;\n    _this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n    return _this;\n  }\n  /**\r\n   * attach this feature\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTest.prototype.attach = function () {\n    var _this = this;\n\n    if (!_super.prototype.attach.call(this)) {\n      return false;\n    } // Feature enabled, but not available\n\n\n    if (!this._xrSessionManager.session.requestHitTestSource) {\n      return false;\n    }\n\n    if (!this.options.disablePermanentHitTest) {\n      if (this._xrSessionManager.referenceSpace) {\n        this.initHitTestSource(this._xrSessionManager.referenceSpace);\n      }\n\n      this._xrSessionManager.onXRReferenceSpaceChanged.add(this.initHitTestSource);\n    }\n\n    if (this.options.enableTransientHitTest) {\n      var offsetRay = new XRRay(this.options.transientOffsetRay || {});\n\n      this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n        profile: \"generic-touchscreen\",\n        offsetRay: offsetRay,\n        entityTypes: this.options.entityTypes\n      }).then(function (hitSource) {\n        _this._transientXrHitTestSource = hitSource;\n      });\n    }\n\n    return true;\n  };\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRHitTest.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (this._xrHitTestSource) {\n      this._xrHitTestSource.cancel();\n\n      this._xrHitTestSource = null;\n    }\n\n    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this.initHitTestSource);\n\n    if (this._transientXrHitTestSource) {\n      this._transientXrHitTestSource.cancel();\n\n      this._transientXrHitTestSource = null;\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRHitTest.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onHitTestResultObservable.clear();\n  };\n\n  WebXRHitTest.prototype._onXRFrame = function (frame) {\n    var _this = this; // make sure we do nothing if (async) not attached\n\n\n    if (!this.attached || this.paused) {\n      return;\n    }\n\n    if (this._xrHitTestSource) {\n      var results = frame.getHitTestResults(this._xrHitTestSource);\n\n      this._processWebXRHitTestResult(results);\n    }\n\n    if (this._transientXrHitTestSource) {\n      var hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n      hitTestResultsPerInputSource.forEach(function (resultsPerInputSource) {\n        _this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n      });\n    }\n  };\n\n  WebXRHitTest.prototype._processWebXRHitTestResult = function (hitTestResults, inputSource) {\n    var _this = this;\n\n    var results = [];\n    hitTestResults.forEach(function (hitTestResult) {\n      var pose = hitTestResult.getPose(_this._xrSessionManager.referenceSpace);\n\n      if (!pose) {\n        return;\n      }\n\n      var pos = pose.transform.position;\n      var quat = pose.transform.orientation;\n\n      _this._tmpPos.set(pos.x, pos.y, pos.z);\n\n      _this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n\n      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, _this._tmpMat);\n\n      if (!_this._xrSessionManager.scene.useRightHandedSystem) {\n        _this._tmpPos.z *= -1;\n        _this._tmpQuat.z *= -1;\n        _this._tmpQuat.w *= -1;\n\n        _this._tmpMat.toggleModelMatrixHandInPlace();\n      }\n\n      var result = {\n        position: _this.autoCloneTransformation ? _this._tmpPos.clone() : _this._tmpPos,\n        rotationQuaternion: _this.autoCloneTransformation ? _this._tmpQuat.clone() : _this._tmpQuat,\n        transformationMatrix: _this.autoCloneTransformation ? _this._tmpMat.clone() : _this._tmpMat,\n        inputSource: inputSource,\n        isTransient: !!inputSource,\n        xrHitResult: hitTestResult\n      };\n      results.push(result);\n    });\n    this.onHitTestResultObservable.notifyObservers(results);\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRHitTest.Version = 2;\n  return WebXRHitTest;\n}(WebXRAbstractFeature);\n\nexport { WebXRHitTest }; //register the plugin versions\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRHitTest(xrSessionManager, options);\n  };\n}, WebXRHitTest.Version, false);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRHitTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { IWebXRLegacyHitTestOptions, IWebXRLegacyHitResult, IWebXRHitTestFeature } from \"./WebXRHitTestLegacy\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options used for hit testing (version 2)\r\n */\r\nexport interface IWebXRHitTestOptions extends IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Do not create a permanent hit test. Will usually be used when only\r\n     * transient inputs are needed.\r\n     */\r\n    disablePermanentHitTest?: boolean;\r\n    /**\r\n     * Enable transient (for example touch-based) hit test inspections\r\n     */\r\n    enableTransientHitTest?: boolean;\r\n    /**\r\n     * Offset ray for the permanent hit test\r\n     */\r\n    offsetRay?: Vector3;\r\n    /**\r\n     * Offset ray for the transient hit test\r\n     */\r\n    transientOffsetRay?: Vector3;\r\n    /**\r\n     * Instead of using viewer space for hit tests, use the reference space defined in the session manager\r\n     */\r\n    useReferenceSpace?: boolean;\r\n\r\n    /**\r\n     * Override the default entity type(s) of the hit-test result\r\n     */\r\n    entityTypes?: XRHitTestTrackableType[];\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of hit-test\r\n */\r\nexport interface IWebXRHitResult extends IWebXRLegacyHitResult {\r\n    /**\r\n     * The input source that generated this hit test (if transient)\r\n     */\r\n    inputSource?: XRInputSource;\r\n    /**\r\n     * Is this a transient hit test\r\n     */\r\n    isTransient?: boolean;\r\n    /**\r\n     * Position of the hit test result\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * Rotation of the hit test result\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\r\nexport class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {\r\n    private _tmpMat: Matrix = new Matrix();\r\n    private _tmpPos: Vector3 = new Vector3();\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _transientXrHitTestSource: Nullable<XRTransientInputHitTestSource>;\r\n    // in XR space z-forward is negative\r\n    private _xrHitTestSource: Nullable<XRHitTestSource>;\r\n    private initHitTestSource = (referenceSpace: XRReferenceSpace) => {\r\n        if (!referenceSpace) {\r\n            return;\r\n        }\r\n        const offsetRay = new XRRay(this.options.offsetRay || {});\r\n        const hitTestOptions: XRHitTestOptionsInit = {\r\n            space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\r\n            offsetRay: offsetRay,\r\n        };\r\n        if (this.options.entityTypes) {\r\n            hitTestOptions.entityTypes = this.options.entityTypes;\r\n        }\r\n        if (!hitTestOptions.space) {\r\n            Tools.Warn(\"waiting for viewer reference space to initialize\");\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.requestHitTestSource!(hitTestOptions).then((hitTestSource) => {\r\n            if (this._xrHitTestSource) {\r\n                this._xrHitTestSource.cancel();\r\n            }\r\n            this._xrHitTestSource = hitTestSource;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 2;\r\n\r\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\r\n    public autoCloneTransformation: boolean = false;\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRHitResult[]> = new Observable();\r\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\r\n    public paused: boolean = false;\r\n\r\n    /**\r\n     * Creates a new instance of the hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"Hit test is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Feature enabled, but not available\r\n        if (!this._xrSessionManager.session.requestHitTestSource) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.options.disablePermanentHitTest) {\r\n            if (this._xrSessionManager.referenceSpace) {\r\n                this.initHitTestSource(this._xrSessionManager.referenceSpace);\r\n            }\r\n            this._xrSessionManager.onXRReferenceSpaceChanged.add(this.initHitTestSource);\r\n        }\r\n        if (this.options.enableTransientHitTest) {\r\n            const offsetRay = new XRRay(this.options.transientOffsetRay || {});\r\n            this._xrSessionManager.session\r\n                .requestHitTestSourceForTransientInput!({\r\n                    profile: \"generic-touchscreen\",\r\n                    offsetRay,\r\n                    entityTypes: this.options.entityTypes,\r\n                })\r\n                .then((hitSource) => {\r\n                    this._transientXrHitTestSource = hitSource;\r\n                });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        if (this._xrHitTestSource) {\r\n            this._xrHitTestSource.cancel();\r\n            this._xrHitTestSource = null;\r\n        }\r\n        this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this.initHitTestSource);\r\n        if (this._transientXrHitTestSource) {\r\n            this._transientXrHitTestSource.cancel();\r\n            this._transientXrHitTestSource = null;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.paused) {\r\n            return;\r\n        }\r\n\r\n        if (this._xrHitTestSource) {\r\n            const results = frame.getHitTestResults(this._xrHitTestSource);\r\n            this._processWebXRHitTestResult(results);\r\n        }\r\n        if (this._transientXrHitTestSource) {\r\n            let hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\r\n\r\n            hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {\r\n                this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _processWebXRHitTestResult(hitTestResults: XRHitTestResult[], inputSource?: XRInputSource) {\r\n        const results: IWebXRHitResult[] = [];\r\n        hitTestResults.forEach((hitTestResult) => {\r\n            const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\r\n            if (!pose) {\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            const quat = pose.transform.orientation;\r\n            this._tmpPos.set(pos.x, pos.y, pos.z);\r\n            this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\r\n            Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                this._tmpPos.z *= -1;\r\n                this._tmpQuat.z *= -1;\r\n                this._tmpQuat.w *= -1;\r\n                this._tmpMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            const result: IWebXRHitResult = {\r\n                position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\r\n                rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\r\n                transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\r\n                inputSource: inputSource,\r\n                isTransient: !!inputSource,\r\n                xrHitResult: hitTestResult,\r\n            };\r\n            results.push(result);\r\n        });\r\n\r\n        this.onHitTestResultObservable.notifyObservers(results);\r\n    }\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTest.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTest(xrSessionManager, options);\r\n    },\r\n    WebXRHitTest.Version,\r\n    false\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}