{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Matrix } from \"../../Maths/math.vector\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport { GUID } from '../../Misc/guid';\nimport \"../../Misc/fileTools\";\nimport { ThinTexture } from './thinTexture';\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\n\nvar BaseTexture =\n/** @class */\nfunction (_super) {\n  __extends(BaseTexture, _super);\n  /**\r\n   * Instantiates a new BaseTexture.\r\n   * Base class of all the textures in babylon.\r\n   * It groups all the common properties the materials, post process, lights... might need\r\n   * in order to make a correct use of the texture.\r\n   * @param sceneOrEngine Define the scene or engine the texture blongs to\r\n   */\n\n\n  function BaseTexture(sceneOrEngine) {\n    var _this = _super.call(this, null) || this;\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\n\n\n    _this.metadata = null;\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\n\n    _this.reservedDataStore = null;\n    _this._hasAlpha = false;\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\n\n    _this.getAlphaFromRGB = false;\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\n\n    _this.level = 1;\n    /**\r\n     * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\n\n    _this.coordinatesIndex = 0;\n    _this._coordinatesMode = 0;\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\n\n    _this.wrapR = 1;\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\n\n    _this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    _this._isCube = false;\n    _this._gammaSpace = true;\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\n\n    _this.invertZ = false;\n    /**\r\n     * @hidden\r\n     */\n\n    _this.lodLevelInAlpha = false;\n    /**\r\n     * Define if the texture is a render target.\r\n     */\n\n    _this.isRenderTarget = false;\n    /** @hidden */\n\n    _this._prefiltered = false;\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\n\n    _this.animations = new Array();\n    /**\r\n    * An event triggered when the texture is disposed.\r\n    */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    _this._scene = null;\n    /** @hidden */\n\n    _this._texture = null;\n    _this._uid = null;\n\n    if (sceneOrEngine) {\n      if (BaseTexture._isScene(sceneOrEngine)) {\n        _this._scene = sceneOrEngine;\n      } else {\n        _this._engine = sceneOrEngine;\n      }\n    } else {\n      _this._scene = EngineStore.LastCreatedScene;\n    }\n\n    if (_this._scene) {\n      _this.uniqueId = _this._scene.getUniqueId();\n\n      _this._scene.addTexture(_this);\n\n      _this._engine = _this._scene.getEngine();\n    }\n\n    _this._uid = null;\n    return _this;\n  }\n\n  Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\n    get: function () {\n      return this._hasAlpha;\n    },\n\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\n    set: function (value) {\n      if (this._hasAlpha === value) {\n        return;\n      }\n\n      this._hasAlpha = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1 | 16);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\n    get: function () {\n      return this._coordinatesMode;\n    },\n\n    /**\r\n    * How a texture is mapped.\r\n    *\r\n    * | Value | Type                                | Description |\r\n    * | ----- | ----------------------------------- | ----------- |\r\n    * | 0     | EXPLICIT_MODE                       |             |\r\n    * | 1     | SPHERICAL_MODE                      |             |\r\n    * | 2     | PLANAR_MODE                         |             |\r\n    * | 3     | CUBIC_MODE                          |             |\r\n    * | 4     | PROJECTION_MODE                     |             |\r\n    * | 5     | SKYBOX_MODE                         |             |\r\n    * | 6     | INVCUBIC_MODE                       |             |\r\n    * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n    * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n    * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n    */\n    set: function (value) {\n      if (this._coordinatesMode === value) {\n        return;\n      }\n\n      this._coordinatesMode = value;\n\n      if (this._scene) {\n        this._scene.markAllMaterialsAsDirty(1);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapU\", {\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n    get: function () {\n      return this._wrapU;\n    },\n    set: function (value) {\n      this._wrapU = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"wrapV\", {\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\n    get: function () {\n      return this._wrapV;\n    },\n    set: function (value) {\n      this._wrapV = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isCube\", {\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return this._isCube;\n      }\n\n      return this._texture.isCube;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        this._isCube = value;\n      } else {\n        this._texture.isCube = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is3D\", {\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is3D;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is3D = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"is2DArray\", {\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return false;\n      }\n\n      return this._texture.is2DArray;\n    },\n    set: function (value) {\n      if (!this._texture) {\n        return;\n      }\n\n      this._texture.is2DArray = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"gammaSpace\", {\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return this._gammaSpace;\n      } else {\n        if (this._texture._gammaSpace === null) {\n          this._texture._gammaSpace = this._gammaSpace;\n        }\n      }\n\n      return this._texture._gammaSpace;\n    },\n    set: function (gamma) {\n      if (!this._texture) {\n        if (this._gammaSpace === gamma) {\n          return;\n        }\n\n        this._gammaSpace = gamma;\n      } else {\n        if (this._texture._gammaSpace === gamma) {\n          return;\n        }\n\n        this._texture._gammaSpace = gamma;\n      }\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isRGBD\", {\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\n    get: function () {\n      return this._texture != null && this._texture._isRGBD;\n    },\n    set: function (value) {\n      if (this._texture) {\n        this._texture._isRGBD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"noMipmap\", {\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationOffset\", {\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\n    get: function () {\n      if (this._texture) {\n        return this._texture._lodGenerationOffset;\n      }\n\n      return 0.0;\n    },\n    set: function (value) {\n      if (this._texture) {\n        this._texture._lodGenerationOffset = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"lodGenerationScale\", {\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\n    get: function () {\n      if (this._texture) {\n        return this._texture._lodGenerationScale;\n      }\n\n      return 0.0;\n    },\n    set: function (value) {\n      if (this._texture) {\n        this._texture._lodGenerationScale = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"linearSpecularLOD\", {\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\n    get: function () {\n      if (this._texture) {\n        return this._texture._linearSpecularLOD;\n      }\n\n      return false;\n    },\n    set: function (value) {\n      if (this._texture) {\n        this._texture._linearSpecularLOD = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"irradianceTexture\", {\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\n    get: function () {\n      if (this._texture) {\n        return this._texture._irradianceTexture;\n      }\n\n      return null;\n    },\n    set: function (value) {\n      if (this._texture) {\n        this._texture._irradianceTexture = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"uid\", {\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\n    get: function () {\n      if (!this._uid) {\n        this._uid = GUID.RandomId();\n      }\n\n      return this._uid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Return a string representation of the texture.\r\n   * @returns the texture as a string\r\n   */\n\n  BaseTexture.prototype.toString = function () {\n    return this.name;\n  };\n  /**\r\n   * Get the class name of the texture.\r\n   * @returns \"BaseTexture\"\r\n   */\n\n\n  BaseTexture.prototype.getClassName = function () {\n    return \"BaseTexture\";\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\n    set: function (callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\n    /**\r\n     * Define if the texture is preventinga material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the scene the texture belongs to.\r\n   * @returns the scene or null if undefined\r\n   */\n\n  BaseTexture.prototype.getScene = function () {\n    return this._scene;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * Checks if the texture has the same transform matrix than another texture\r\n   * @param texture texture to check against\r\n   * @returns true if the transforms are the same, else false\r\n   */\n\n\n  BaseTexture.prototype.checkTransformsAreIdentical = function (texture) {\n    return texture !== null;\n  };\n  /**\r\n   * Get the texture transform matrix used to offset tile the texture for istance.\r\n   * @returns the transformation matrix\r\n   */\n\n\n  BaseTexture.prototype.getTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\r\n   * Get the texture reflection matrix used to rotate/transform the reflection.\r\n   * @returns the reflection matrix\r\n   */\n\n\n  BaseTexture.prototype.getReflectionTextureMatrix = function () {\n    return Matrix.IdentityReadOnly;\n  };\n  /**\r\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n   * @returns true if ready or not blocking\r\n   */\n\n\n  BaseTexture.prototype.isReadyOrNotBlocking = function () {\n    return !this.isBlocking || this.isReady();\n  };\n  /**\r\n   * Scales the texture if is `canRescale()`\r\n   * @param ratio the resize factor we want to use to rescale\r\n   */\n\n\n  BaseTexture.prototype.scale = function (ratio) {};\n\n  Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\n    /**\r\n     * Get if the texture can rescale.\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling, invertY) {\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    var texturesCache = engine.getLoadedTexturesCache();\n\n    for (var index = 0; index < texturesCache.length; index++) {\n      var texturesCacheEntry = texturesCache[index];\n\n      if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n        if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n          if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n            texturesCacheEntry.incrementReferences();\n            return texturesCacheEntry;\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n  /** @hidden */\n\n\n  BaseTexture.prototype._rebuild = function () {};\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  BaseTexture.prototype.clone = function () {\n    return null;\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"textureType\", {\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return 0;\n      }\n\n      return this._texture.type !== undefined ? this._texture.type : 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\n    get: function () {\n      if (!this._texture) {\n        return 5;\n      }\n\n      return this._texture.format !== undefined ? this._texture.format : 5;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Indicates that textures need to be re-calculated for all materials\r\n   */\n\n  BaseTexture.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return;\n    }\n\n    scene.markAllMaterialsAsDirty(1);\n  };\n  /**\r\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n   * This will returns an RGBA array buffer containing either in values (0-255) or\r\n   * float values (0-1) depending of the underlying buffer type.\r\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n   * @param buffer defines a user defined buffer to fill with data (can be null)\r\n   * @returns The Array buffer containing the pixels data.\r\n   */\n\n\n  BaseTexture.prototype.readPixels = function (faceIndex, level, buffer) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (!this._texture) {\n      return null;\n    }\n\n    var size = this.getSize();\n    var width = size.width;\n    var height = size.height;\n\n    var engine = this._getEngine();\n\n    if (!engine) {\n      return null;\n    }\n\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\n      }\n\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\n    } catch (e) {\n      return null;\n    }\n  };\n\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\n    /** @hidden */\n    get: function () {\n      if (this._texture) {\n        return this._texture._lodTextureHigh;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\n    /** @hidden */\n    get: function () {\n      if (this._texture) {\n        return this._texture._lodTextureMid;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\n    /** @hidden */\n    get: function () {\n      if (this._texture) {\n        return this._texture._lodTextureLow;\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n  BaseTexture.prototype.dispose = function () {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      } // Remove from scene\n\n\n      this._scene._removePendingData(this);\n\n      var index = this._scene.textures.indexOf(this);\n\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n\n      this._scene = null;\n    } // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Serialize the texture into a JSON representation that can be parsed later on.\r\n   * @returns the JSON representation of the texture\r\n   */\n\n\n  BaseTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = SerializationHelper.Serialize(this); // Animations\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\r\n   * Helper function to be called back once a list of texture contains only ready textures.\r\n   * @param textures Define the list of textures to wait for\r\n   * @param callback Define the callback triggered once the entire list will be ready\r\n   */\n\n\n  BaseTexture.WhenAllReady = function (textures, callback) {\n    var numRemaining = textures.length;\n\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n\n    for (var i = 0; i < textures.length; i++) {\n      var texture = textures[i];\n\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        var onLoadObservable = texture.onLoadObservable;\n\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(function () {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        }\n      }\n    }\n  };\n\n  BaseTexture._isScene = function (sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  };\n  /**\r\n   * Default anisotropic filtering level for the application.\r\n   * It is set to 4 as a good tradeoff between perf and quality.\r\n   */\n\n\n  BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n\n  __decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n\n  __decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"getAlphaFromRGB\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"coordinatesIndex\", void 0);\n\n  __decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n\n  __decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n\n  __decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);\n\n  return BaseTexture;\n}(ThinTexture);\n\nexport { BaseTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/baseTexture.ts"],"names":[],"mappings":";AAAA,SAAS,SAAT,EAAoB,mBAApB,EAAyC,kBAAzC,QAAmE,uBAAnE;AACA,SAAmB,UAAnB,QAAqC,uBAArC;AAGA,SAAS,MAAT,QAAuB,yBAAvB;AACA,SAAS,WAAT,QAA4B,2BAA5B;AAIA,SAAS,IAAT,QAAqB,iBAArB;AAEA,OAAO,sBAAP;AAEA,SAAS,WAAT,QAA4B,eAA5B;AAIA;;;;;;AAKA,IAAA,WAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAiC,EAAA,SAAA,CAAA,WAAA,EAAA,MAAA,CAAA;AAkZ7B;;;;;;;;;AAOA,WAAA,WAAA,CAAY,aAAZ,EAAuD;AAAvD,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,KAAW,IADf;AAtYA;;;;;AAIO,IAAA,KAAA,CAAA,QAAA,GAAgB,IAAhB;AAEP;;;;AAGO,IAAA,KAAA,CAAA,iBAAA,GAAyB,IAAzB;AAGC,IAAA,KAAA,CAAA,SAAA,GAAY,KAAZ;AAiBR;;;;;AAKO,IAAA,KAAA,CAAA,eAAA,GAAkB,KAAlB;AAEP;;;;;AAKO,IAAA,KAAA,CAAA,KAAA,GAAQ,CAAR;AAEP;;;;;AAKO,IAAA,KAAA,CAAA,gBAAA,GAAmB,CAAnB;AAGG,IAAA,KAAA,CAAA,gBAAA,GAAmB,CAAnB;AA6DV;;;;;;;;AAQO,IAAA,KAAA,CAAA,KAAA,GAAQ,CAAR;AAEP;;;;;;AAMO,IAAA,KAAA,CAAA,yBAAA,GAA4B,WAAW,CAAC,mCAAxC;AAEC,IAAA,KAAA,CAAA,OAAA,GAAU,KAAV;AA6DA,IAAA,KAAA,CAAA,WAAA,GAAc,IAAd;AA8CR;;;;AAIO,IAAA,KAAA,CAAA,OAAA,GAAU,KAAV;AASP;;;;AAIO,IAAA,KAAA,CAAA,eAAA,GAAkB,KAAlB;AA0DP;;;;AAIO,IAAA,KAAA,CAAA,cAAA,GAAiB,KAAjB;AAYP;;AACO,IAAA,KAAA,CAAA,YAAA,GAAwB,KAAxB;AAkBP;;;;AAGO,IAAA,KAAA,CAAA,UAAA,GAAa,IAAI,KAAJ,EAAb;AAEP;;;;AAGO,IAAA,KAAA,CAAA,mBAAA,GAAsB,IAAI,UAAJ,EAAtB;AAEC,IAAA,KAAA,CAAA,kBAAA,GAAsD,IAAtD;AAYE,IAAA,KAAA,CAAA,MAAA,GAA0B,IAA1B;AAEV;;AACO,IAAA,KAAA,CAAA,QAAA,GAAsC,IAAtC;AACC,IAAA,KAAA,CAAA,IAAA,GAAyB,IAAzB;;AAoBJ,QAAI,aAAJ,EAAmB;AACf,UAAI,WAAW,CAAC,QAAZ,CAAqB,aAArB,CAAJ,EAAyC;AACrC,QAAA,KAAI,CAAC,MAAL,GAAc,aAAd;AACH,OAFD,MAGK;AACD,QAAA,KAAI,CAAC,OAAL,GAAe,aAAf;AACH;AACJ,KAPD,MAQK;AACD,MAAA,KAAI,CAAC,MAAL,GAAc,WAAW,CAAC,gBAA1B;AACH;;AAED,QAAI,KAAI,CAAC,MAAT,EAAiB;AACb,MAAA,KAAI,CAAC,QAAL,GAAgB,KAAI,CAAC,MAAL,CAAY,WAAZ,EAAhB;;AACA,MAAA,KAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,KAAvB;;AACA,MAAA,KAAI,CAAC,OAAL,GAAe,KAAI,CAAC,MAAL,CAAY,SAAZ,EAAf;AACH;;AAED,IAAA,KAAI,CAAC,IAAL,GAAY,IAAZ;;AACH;;AA5YD,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;SASnB,YAAA;AACI,aAAO,KAAK,SAAZ;AACH,KAXkB;;AAHnB;;;SAGA,UAAoB,KAApB,EAAkC;AAC9B,UAAI,KAAK,SAAL,KAAmB,KAAvB,EAA8B;AAC1B;AACH;;AACD,WAAK,SAAL,GAAiB,KAAjB;;AACA,UAAI,KAAK,MAAT,EAAiB;AACb,aAAK,MAAL,CAAY,uBAAZ,CAAoC,IAAI,EAAxC;AACH;AACJ,KARkB;qBAAA;;AAAA,GAAnB;AAqDA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;SAS1B,YAAA;AACI,aAAO,KAAK,gBAAZ;AACH,KAXyB;;AAhB1B;;;;;;;;;;;;;;;;SAgBA,UAA2B,KAA3B,EAAwC;AACpC,UAAI,KAAK,gBAAL,KAA0B,KAA9B,EAAqC;AACjC;AACH;;AACD,WAAK,gBAAL,GAAwB,KAAxB;;AACA,UAAI,KAAK,MAAT,EAAiB;AACb,aAAK,MAAL,CAAY,uBAAZ,CAAoC,CAApC;AACH;AACJ,KARyB;qBAAA;;AAAA,GAA1B;AAqBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,OAAX,EAAgB;AARhB;;;;;;;SAQA,YAAA;AACI,aAAO,KAAK,MAAZ;AACH,KAFe;SAGhB,UAAiB,KAAjB,EAA8B;AAC1B,WAAK,MAAL,GAAc,KAAd;AACH,KALe;qBAAA;;AAAA,GAAhB;AAeA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,OAAX,EAAgB;AARhB;;;;;;;SAQA,YAAA;AACI,aAAO,KAAK,MAAZ;AACH,KAFe;SAGhB,UAAiB,KAAjB,EAA8B;AAC1B,WAAK,MAAL,GAAc,KAAd;AACH,KALe;qBAAA;;AAAA,GAAhB;AA8BA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAJjB;;;SAIA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,KAAK,OAAZ;AACH;;AAED,aAAO,KAAK,QAAL,CAAc,MAArB;AACH,KANgB;SAQjB,UAAkB,KAAlB,EAAgC;AAC5B,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,aAAK,OAAL,GAAe,KAAf;AACH,OAFD,MAEO;AACH,aAAK,QAAL,CAAc,MAAd,GAAuB,KAAvB;AACH;AACJ,KAdgB;qBAAA;;AAAA,GAAjB;AAoBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAJf;;;SAIA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,KAAP;AACH;;AAED,aAAO,KAAK,QAAL,CAAc,IAArB;AACH,KANc;SAQf,UAAgB,KAAhB,EAA8B;AAC1B,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB;AACH;;AAED,WAAK,QAAL,CAAc,IAAd,GAAqB,KAArB;AACH,KAdc;qBAAA;;AAAA,GAAf;AAoBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAJpB;;;SAIA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,KAAP;AACH;;AAED,aAAO,KAAK,QAAL,CAAc,SAArB;AACH,KANmB;SAQpB,UAAqB,KAArB,EAAmC;AAC/B,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB;AACH;;AAED,WAAK,QAAL,CAAc,SAAd,GAA0B,KAA1B;AACH,KAdmB;qBAAA;;AAAA,GAApB;AAuBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AANrB;;;;;SAMA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,KAAK,WAAZ;AACH,OAFD,MAEO;AACH,YAAI,KAAK,QAAL,CAAc,WAAd,KAA8B,IAAlC,EAAwC;AACpC,eAAK,QAAL,CAAc,WAAd,GAA4B,KAAK,WAAjC;AACH;AACJ;;AAED,aAAO,KAAK,QAAL,CAAc,WAArB;AACH,KAVoB;SAYrB,UAAsB,KAAtB,EAAoC;AAChC,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,YAAI,KAAK,WAAL,KAAqB,KAAzB,EAAgC;AAC5B;AACH;;AAED,aAAK,WAAL,GAAmB,KAAnB;AACH,OAND,MAMO;AACH,YAAI,KAAK,QAAL,CAAc,WAAd,KAA8B,KAAlC,EAAyC;AACrC;AACH;;AACD,aAAK,QAAL,CAAc,WAAd,GAA4B,KAA5B;AACH;;AAED,WAAK,gCAAL;AACH,KA3BoB;qBAAA;;AAAA,GAArB;AAgCA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAHjB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,IAAiB,IAAjB,IAAyB,KAAK,QAAL,CAAc,OAA9C;AACH,KAFgB;SAGjB,UAAkB,KAAlB,EAAgC;AAC5B,UAAI,KAAK,QAAT,EAAmB;AAAE,aAAK,QAAL,CAAc,OAAd,GAAwB,KAAxB;AAAgC;AACxD,KALgB;qBAAA;;AAAA,GAAjB;AAgBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,UAAX,EAAmB;AAHnB;;;SAGA,YAAA;AACI,aAAO,KAAP;AACH,KAFkB;qBAAA;;AAAA,GAAnB;AAcA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,qBAAX,EAA8B;AAJ9B;;;SAIA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AAAE,eAAO,KAAK,QAAL,CAAc,oBAArB;AAA4C;;AAEjE,aAAO,GAAP;AACH,KAJ6B;SAK9B,UAA+B,KAA/B,EAA4C;AACxC,UAAI,KAAK,QAAT,EAAmB;AAAE,aAAK,QAAL,CAAc,oBAAd,GAAqC,KAArC;AAA6C;AACrE,KAP6B;qBAAA;;AAAA,GAA9B;AAaA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,oBAAX,EAA6B;AAJ7B;;;SAIA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AAAE,eAAO,KAAK,QAAL,CAAc,mBAArB;AAA2C;;AAEhE,aAAO,GAAP;AACH,KAJ4B;SAK7B,UAA8B,KAA9B,EAA2C;AACvC,UAAI,KAAK,QAAT,EAAmB;AAAE,aAAK,QAAL,CAAc,mBAAd,GAAoC,KAApC;AAA4C;AACpE,KAP4B;qBAAA;;AAAA,GAA7B;AAeA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,mBAAX,EAA4B;AAN5B;;;;;SAMA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AAAE,eAAO,KAAK,QAAL,CAAc,kBAArB;AAA0C;;AAE/D,aAAO,KAAP;AACH,KAJ2B;SAK5B,UAA6B,KAA7B,EAA2C;AACvC,UAAI,KAAK,QAAT,EAAmB;AAAE,aAAK,QAAL,CAAc,kBAAd,GAAmC,KAAnC;AAA2C;AACnE,KAP2B;qBAAA;;AAAA,GAA5B;AAeA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,mBAAX,EAA4B;AAN5B;;;;;SAMA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AAAE,eAAO,KAAK,QAAL,CAAc,kBAArB;AAA0C;;AAE/D,aAAO,IAAP;AACH,KAJ2B;SAK5B,UAA6B,KAA7B,EAAyD;AACrD,UAAI,KAAK,QAAT,EAAmB;AAAE,aAAK,QAAL,CAAc,kBAAd,GAAmC,KAAnC;AAA2C;AACnE,KAP2B;qBAAA;;AAAA,GAA5B;AAkBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,KAAX,EAAc;AAHd;;;SAGA,YAAA;AACI,UAAI,CAAC,KAAK,IAAV,EAAgB;AACZ,aAAK,IAAL,GAAY,IAAI,CAAC,QAAL,EAAZ;AACH;;AACD,aAAO,KAAK,IAAZ;AACH,KALa;qBAAA;;AAAA,GAAd;AAUA;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,KAAK,IAAZ;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,aAAP;AACH,GAFM;;AAmBP,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAJpB;;;;SAIA,UAAqB,QAArB,EAAyC;AACrC,UAAI,KAAK,kBAAT,EAA6B;AACzB,aAAK,mBAAL,CAAyB,MAAzB,CAAgC,KAAK,kBAArC;AACH;;AACD,WAAK,kBAAL,GAA0B,KAAK,mBAAL,CAAyB,GAAzB,CAA6B,QAA7B,CAA1B;AACH,KALmB;qBAAA;;AAAA,GAApB;AAiBA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAJrB;;;;SAIA,YAAA;AACI,aAAO,IAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAmCA;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,KAAK,MAAZ;AACH,GAFM;AAIP;;;AACU,EAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAV,YAAA;AACI,WAAO,KAAK,OAAZ;AACH,GAFS;AAIV;;;;;;;AAKO,EAAA,WAAA,CAAA,SAAA,CAAA,2BAAA,GAAP,UAAmC,OAAnC,EAAiE;AAC7D,WAAO,OAAO,KAAK,IAAnB;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,YAAA;AACI,WAAe,MAAM,CAAC,gBAAtB;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,0BAAA,GAAP,YAAA;AACI,WAAe,MAAM,CAAC,gBAAtB;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACI,WAAO,CAAC,KAAK,UAAN,IAAoB,KAAK,OAAL,EAA3B;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,KAAb,EAA0B,CACzB,CADM;;AAMP,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAIA;;AACO,EAAA,WAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,GAArB,EAA4C,QAA5C,EAA+D,QAA/D,EAAkF,OAAlF,EAAmG;AAC/F,QAAM,MAAM,GAAG,KAAK,UAAL,EAAf;;AACA,QAAI,CAAC,MAAL,EAAa;AACT,aAAO,IAAP;AACH;;AAED,QAAI,aAAa,GAAG,MAAM,CAAC,sBAAP,EAApB;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,aAAa,CAAC,MAA1C,EAAkD,KAAK,EAAvD,EAA2D;AACvD,UAAI,kBAAkB,GAAG,aAAa,CAAC,KAAD,CAAtC;;AAEA,UAAI,OAAO,KAAK,SAAZ,IAAyB,OAAO,KAAK,kBAAkB,CAAC,OAA5D,EAAqE;AACjE,YAAI,kBAAkB,CAAC,GAAnB,KAA2B,GAA3B,IAAkC,kBAAkB,CAAC,eAAnB,KAAuC,CAAC,QAA9E,EAAwF;AACpF,cAAI,CAAC,QAAD,IAAa,QAAQ,KAAK,kBAAkB,CAAC,YAAjD,EAA+D;AAC3D,YAAA,kBAAkB,CAAC,mBAAnB;AACA,mBAAO,kBAAP;AACH;AACJ;AACJ;AACJ;;AAED,WAAO,IAAP;AACH,GArBM;AAuBP;;;AACO,EAAA,WAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA,CAEC,CAFM;AAIP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAP;AACH,GAFM;;AAOP,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,CAAP;AACH;;AAED,aAAQ,KAAK,QAAL,CAAc,IAAd,KAAuB,SAAxB,GAAqC,KAAK,QAAL,CAAc,IAAnD,GAA0D,CAAjE;AACH,KANqB;qBAAA;;AAAA,GAAtB;AAWA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA,YAAA;AACI,UAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,eAAO,CAAP;AACH;;AAED,aAAQ,KAAK,QAAL,CAAc,MAAd,KAAyB,SAA1B,GAAuC,KAAK,QAAL,CAAc,MAArD,GAA8D,CAArE;AACH,KANuB;qBAAA;;AAAA,GAAxB;AAQA;;;;AAGU,EAAA,WAAA,CAAA,SAAA,CAAA,gCAAA,GAAV,YAAA;AACI,QAAI,KAAK,GAAG,KAAK,QAAL,EAAZ;;AAEA,QAAI,CAAC,KAAL,EAAY;AACR;AACH;;AAED,IAAA,KAAK,CAAC,uBAAN,CAA8B,CAA9B;AACH,GARS;AAUV;;;;;;;;;;;AASO,EAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,SAAlB,EAAiC,KAAjC,EAA4C,MAA5C,EAAoF;AAAlE,QAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,SAAA,GAAA,CAAA;AAAa;;AAAE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,CAAA;AAAS;;AAAE,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,IAAA;AAAwC;;AAChF,QAAI,CAAC,KAAK,QAAV,EAAoB;AAChB,aAAO,IAAP;AACH;;AAED,QAAI,IAAI,GAAG,KAAK,OAAL,EAAX;AACA,QAAI,KAAK,GAAG,IAAI,CAAC,KAAjB;AACA,QAAI,MAAM,GAAG,IAAI,CAAC,MAAlB;;AAEA,QAAM,MAAM,GAAG,KAAK,UAAL,EAAf;;AACA,QAAI,CAAC,MAAL,EAAa;AACT,aAAO,IAAP;AACH;;AAED,QAAI,KAAK,IAAI,CAAb,EAAgB;AACZ,MAAA,KAAK,GAAG,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAZ,CAAhB;AACA,MAAA,MAAM,GAAG,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAZ,CAAlB;AAEA,MAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAR;AACA,MAAA,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,MAAX,CAAT;AACH;;AAED,QAAI;AACA,UAAI,KAAK,QAAL,CAAc,MAAlB,EAA0B;AACtB,eAAO,MAAM,CAAC,kBAAP,CAA0B,KAAK,QAA/B,EAAyC,KAAzC,EAAgD,MAAhD,EAAwD,SAAxD,EAAmE,KAAnE,EAA0E,MAA1E,CAAP;AACH;;AAED,aAAO,MAAM,CAAC,kBAAP,CAA0B,KAAK,QAA/B,EAAyC,KAAzC,EAAgD,MAAhD,EAAwD,CAAC,CAAzD,EAA4D,KAA5D,EAAmE,MAAnE,CAAP;AACH,KAND,CAME,OAAO,CAAP,EAAU;AACR,aAAO,IAAP;AACH;AACJ,GA/BM;;AAkCP,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,iBAAX,EAA0B;AAD1B;SACA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AACf,eAAO,KAAK,QAAL,CAAc,eAArB;AACH;;AACD,aAAO,IAAP;AACH,KALyB;qBAAA;;AAAA,GAA1B;AAQA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AADzB;SACA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AACf,eAAO,KAAK,QAAL,CAAc,cAArB;AACH;;AACD,aAAO,IAAP;AACH,KALwB;qBAAA;;AAAA,GAAzB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AADzB;SACA,YAAA;AACI,UAAI,KAAK,QAAT,EAAmB;AACf,eAAO,KAAK,QAAL,CAAc,cAArB;AACH;;AACD,aAAO,IAAP;AACH,KALwB;qBAAA;;AAAA,GAAzB;AAOA;;;;AAGO,EAAA,WAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,KAAK,MAAT,EAAiB;AACb;AACA,UAAI,KAAK,MAAL,CAAY,aAAhB,EAA+B;AAC3B,aAAK,MAAL,CAAY,aAAZ,CAA0B,IAA1B;AACH,OAJY,CAMb;;;AACA,WAAK,MAAL,CAAY,kBAAZ,CAA+B,IAA/B;;AACA,UAAI,KAAK,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAqB,OAArB,CAA6B,IAA7B,CAAZ;;AAEA,UAAI,KAAK,IAAI,CAAb,EAAgB;AACZ,aAAK,MAAL,CAAY,QAAZ,CAAqB,MAArB,CAA4B,KAA5B,EAAmC,CAAnC;AACH;;AACD,WAAK,MAAL,CAAY,0BAAZ,CAAuC,eAAvC,CAAuD,IAAvD;;AACA,WAAK,MAAL,GAAc,IAAd;AACH,KAhBL,CAkBI;;;AACA,SAAK,mBAAL,CAAyB,eAAzB,CAAyC,IAAzC;AACA,SAAK,mBAAL,CAAyB,KAAzB;;AAEA,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;AACH,GAvBM;AAyBP;;;;;;AAIO,EAAA,WAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,CAAC,KAAK,IAAV,EAAgB;AACZ,aAAO,IAAP;AACH;;AAED,QAAI,mBAAmB,GAAG,mBAAmB,CAAC,SAApB,CAA8B,IAA9B,CAA1B,CALJ,CAOI;;AACA,IAAA,mBAAmB,CAAC,0BAApB,CAA+C,IAA/C,EAAqD,mBAArD;AAEA,WAAO,mBAAP;AACH,GAXM;AAaP;;;;;;;AAKc,EAAA,WAAA,CAAA,YAAA,GAAd,UAA2B,QAA3B,EAAoD,QAApD,EAAwE;AACpE,QAAI,YAAY,GAAG,QAAQ,CAAC,MAA5B;;AACA,QAAI,YAAY,KAAK,CAArB,EAAwB;AACpB,MAAA,QAAQ;AACR;AACH;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACtC,UAAI,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAtB;;AAEA,UAAI,OAAO,CAAC,OAAR,EAAJ,EAAuB;AACnB,YAAI,EAAE,YAAF,KAAmB,CAAvB,EAA0B;AACtB,UAAA,QAAQ;AACX;AACJ,OAJD,MAKK;AACD,YAAI,gBAAgB,GAAI,OAAe,CAAC,gBAAxC;;AAEA,YAAI,gBAAJ,EAAsB;AAClB,UAAA,gBAAgB,CAAC,OAAjB,CAAyB,YAAA;AACrB,gBAAI,EAAE,YAAF,KAAmB,CAAvB,EAA0B;AACtB,cAAA,QAAQ;AACX;AACJ,WAJD;AAKH;AACJ;AACJ;AACJ,GA3Ba;;AA6BC,EAAA,WAAA,CAAA,QAAA,GAAf,UAAwB,aAAxB,EAAyD;AACrD,WAAO,aAAa,CAAC,YAAd,OAAiC,OAAxC;AACH,GAFc;AArsBf;;;;;;AAIc,EAAA,WAAA,CAAA,mCAAA,GAAsC,CAAtC;;AAMd,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,UAAA,E,KAAwB,CAAxB,CAAA;;AAMA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,MAAA,E,KAAoB,CAApB,CAAA;;AAMA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,UAAA,E,KAA4B,CAA5B,CAAA;;AAQA,EAAA,UAAA,CAAA,CADC,SAAS,CAAC,UAAD,CACV,CAAA,E,qBAAA,E,WAAA,E,KAA0B,CAA1B,CAAA;;AAsBA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,iBAAA,E,KAA+B,CAA/B,CAAA;;AAOA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,OAAA,E,KAAiB,CAAjB,CAAA;;AAOA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,kBAAA,E,KAA4B,CAA5B,CAAA;;AAGA,EAAA,UAAA,CAAA,CADC,SAAS,CAAC,iBAAD,CACV,CAAA,E,qBAAA,E,kBAAA,E,KAA+B,CAA/B,CAAA;;AAuCA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,OAAA,EAEC,IAFD,CAAA;;AAeA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,OAAA,EAEC,IAFD,CAAA;;AAeA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,OAAA,E,KAAiB,CAAjB,CAAA;;AAQA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,2BAAA,E,KAAmF,CAAnF,CAAA;;AAOA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,QAAA,EAMC,IAND,CAAA;;AAoBA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,MAAA,EAMC,IAND,CAAA;;AAoBA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,WAAA,EAMC,IAND,CAAA;;AAuBA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,YAAA,EAUC,IAVD,CAAA;;AA2CA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,SAAA,E,KAAuB,CAAvB,CAAA;;AAaA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,iBAAA,E,KAA+B,CAA/B,CAAA;;AAMA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,qBAAA,EAIC,IAJD,CAAA;;AAaA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,oBAAA,EAIC,IAJD,CAAA;;AAeA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,mBAAA,EAIC,IAJD,CAAA;;AAeA,EAAA,UAAA,CAAA,CADC,kBAAkB,EACnB,CAAA,E,qBAAA,E,mBAAA,EAIC,IAJD,CAAA;;AAaA,EAAA,UAAA,CAAA,CADC,SAAS,EACV,CAAA,E,qBAAA,E,gBAAA,E,KAA8B,CAA9B,CAAA;;AA0XJ,SAAA,WAAA;AAAC,CAzsBD,CAAiC,WAAjC,CAAA;;SAAa,W","sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\n\r\nimport { IAnimatable } from '../../Animations/animatable.interface';\r\nimport { GUID } from '../../Misc/guid';\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport { ThinEngine } from '../../Engines/thinEngine';\r\nimport { ThinTexture } from './thinTexture';\r\n\r\ndeclare type Animation = import(\"../../Animations/animation\").Animation;\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(1 | 16);\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    @serialize()\r\n    public getAlphaFromRGB = false;\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    /**\r\n     * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    @serialize()\r\n    public coordinatesIndex = 0;\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = 0;\r\n\r\n    /**\r\n    * How a texture is mapped.\r\n    *\r\n    * | Value | Type                                | Description |\r\n    * | ----- | ----------------------------------- | ----------- |\r\n    * | 0     | EXPLICIT_MODE                       |             |\r\n    * | 1     | SPHERICAL_MODE                      |             |\r\n    * | 2     | PLANAR_MODE                         |             |\r\n    * | 3     | CUBIC_MODE                          |             |\r\n    * | 4     | PROJECTION_MODE                     |             |\r\n    * | 5     | SKYBOX_MODE                         |             |\r\n    * | 6     | INVCUBIC_MODE                       |             |\r\n    * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n    * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n    * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n    */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(1);\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    @serialize()\r\n    public wrapR = 1;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    private _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    public set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    public set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    public set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    private _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (this._texture) { this._texture._isRGBD = value; }\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) { return this._texture._lodGenerationOffset; }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) { this._texture._lodGenerationOffset = value; }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) { return this._texture._lodGenerationScale; }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) { this._texture._lodGenerationScale = value; }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) { return this._texture._linearSpecularLOD; }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) { this._texture._linearSpecularLOD = value; }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) { return this._texture._irradianceTexture; }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) { this._texture._irradianceTexture = value; }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = GUID.RandomId();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _prefiltered: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n    * An event triggered when the texture is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @hidden */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventinga material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture blongs to\r\n     */\r\n    constructor(sceneOrEngine: Nullable<Scene | ThinEngine>) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._isScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            }\r\n            else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        }\r\n        else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for istance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready or not blocking\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady();\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    public scale(ratio: number): void {\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        var texturesCache = engine.getLoadedTexturesCache();\r\n        for (var index = 0; index < texturesCache.length; index++) {\r\n            var texturesCacheEntry = texturesCache[index];\r\n\r\n            if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                    if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                        texturesCacheEntry.incrementReferences();\r\n                        return texturesCacheEntry;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return 0;\r\n        }\r\n\r\n        return (this._texture.type !== undefined) ? this._texture.type : 0;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return 5;\r\n        }\r\n\r\n        return (this._texture.format !== undefined) ? this._texture.format : 5;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(1);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @returns The Array buffer containing the pixels data.\r\n     */\r\n    public readPixels(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene._removePendingData(this);\r\n            var index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < textures.length; i++) {\r\n            var texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            }\r\n            else {\r\n                var onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _isScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}