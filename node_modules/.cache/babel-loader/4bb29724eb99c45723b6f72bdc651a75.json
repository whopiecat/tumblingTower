{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Material } from \"./material\";\nimport { serialize, expandToProperty, serializeAsTexture, SerializationHelper } from '../Misc/decorators';\nimport { MaterialFlags } from './materialFlags';\nimport { MaterialHelper } from './materialHelper';\n/**\r\n * Define the code related to the detail map parameters of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\n\nvar DetailMapConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new detail map\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   */\n  function DetailMapConfiguration(markAllSubMeshesAsTexturesDirty) {\n    this._texture = null;\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\n\n    this.diffuseBlendLevel = 1;\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\n\n    this.roughnessBlendLevel = 1;\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\n\n    this.bumpLevel = 1;\n    this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\n    this._isEnabled = false;\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\n\n    this.isEnabled = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n  }\n  /** @hidden */\n\n\n  DetailMapConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /**\r\n   * Gets whether the submesh is ready to be used or not.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  DetailMapConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    var engine = scene.getEngine();\n\n    if (defines._areTexturesDirty && scene.texturesEnabled) {\n      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\n        // Detail texture cannot be not blocking.\n        if (!this._texture.isReady()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Update the defines for detail map usage\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   */\n\n\n  DetailMapConfiguration.prototype.prepareDefines = function (defines, scene) {\n    if (this._isEnabled) {\n      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\n      var engine = scene.getEngine();\n\n      if (defines._areTexturesDirty) {\n        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\n          MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\n          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\n        } else {\n          defines.DETAIL = false;\n        }\n      }\n    } else {\n      defines.DETAIL = false;\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param isFrozen defines whether the material is frozen or not.\r\n   */\n\n\n  DetailMapConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.DetailTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\n      }\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.DetailTextureEnabled) {\n        uniformBuffer.setTexture(\"detailSampler\", this._texture);\n      }\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  DetailMapConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  DetailMapConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  DetailMapConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  DetailMapConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    var _a;\n\n    if (forceDisposeTextures) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n  };\n  /**\r\n  * Get the current class name useful for serialization or dynamic coding.\r\n  * @returns \"DetailMap\"\r\n  */\n\n\n  DetailMapConfiguration.prototype.getClassName = function () {\n    return \"DetailMap\";\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  DetailMapConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vDetailInfos\");\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  DetailMapConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"detailSampler\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  DetailMapConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vDetailInfos\", 4);\n    uniformBuffer.addUniform(\"detailMatrix\", 16);\n  };\n  /**\r\n   * Makes a duplicate of the current instance into another one.\r\n   * @param detailMap define the instance where to copy the info\r\n   */\n\n\n  DetailMapConfiguration.prototype.copyTo = function (detailMap) {\n    SerializationHelper.Clone(function () {\n      return detailMap;\n    }, this);\n  };\n  /**\r\n   * Serializes this detail map instance\r\n   * @returns - An object with the serialized instance.\r\n   */\n\n\n  DetailMapConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a detail map setting from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  DetailMapConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serializeAsTexture(\"detailTexture\"), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], DetailMapConfiguration.prototype, \"texture\", void 0);\n\n  __decorate([serialize()], DetailMapConfiguration.prototype, \"diffuseBlendLevel\", void 0);\n\n  __decorate([serialize()], DetailMapConfiguration.prototype, \"roughnessBlendLevel\", void 0);\n\n  __decorate([serialize()], DetailMapConfiguration.prototype, \"bumpLevel\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], DetailMapConfiguration.prototype, \"normalBlendMethod\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], DetailMapConfiguration.prototype, \"isEnabled\", void 0);\n\n  return DetailMapConfiguration;\n}();\n\nexport { DetailMapConfiguration };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/material.detailMapConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from \"../Misc/typeStore\";\r\nimport { serialize, expandToProperty, serializeAsTexture, SerializationHelper } from '../Misc/decorators';\r\nimport { MaterialFlags } from './materialFlags';\r\nimport { MaterialHelper } from './materialHelper';\r\nimport { BaseTexture } from './Textures/baseTexture';\r\nimport { UniformBuffer } from './uniformBuffer';\r\nimport { IAnimatable } from '../Animations/animatable.interface';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialDetailMapDefines {\r\n    DETAIL: boolean;\r\n    DETAILDIRECTUV : number;\r\n    DETAIL_NORMALBLENDMETHOD: number;\r\n\r\n    /** @hidden */\r\n    _areTexturesDirty: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the detail map parameters of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nexport class DetailMapConfiguration {\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The detail texture of the material.\r\n     */\r\n    @serializeAsTexture(\"detailTexture\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\r\n    @serialize()\r\n    public diffuseBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\r\n    @serialize()\r\n    public roughnessBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\r\n    @serialize()\r\n    public bumpLevel = 1;\r\n\r\n    private _normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n    /**\r\n     * The method used to blend the bump and detail normals together\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalBlendMethod: number;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new detail map\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the submesh is ready to be used or not.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialDetailMapDefines, scene: Scene): boolean {\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update the defines for detail map usage\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialDetailMapDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n\r\n            const engine = scene.getEngine();\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                } else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.DETAIL = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines whether the material is frozen or not.\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name useful for serialization or dynamic coding.\r\n    * @returns \"DetailMap\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"DetailMap\";\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"vDetailInfos\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"detailSampler\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vDetailInfos\", 4);\r\n        uniformBuffer.addUniform(\"detailMatrix\", 16);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current instance into another one.\r\n     * @param detailMap define the instance where to copy the info\r\n     */\r\n    public copyTo(detailMap: DetailMapConfiguration): void {\r\n        SerializationHelper.Clone(() => detailMap, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this detail map instance\r\n     * @returns - An object with the serialized instance.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a detail map setting from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}