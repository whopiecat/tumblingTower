{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Tools } from \"../../Misc/tools\";\nimport { serialize } from \"../../Misc/decorators\";\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\n\nvar PostProcessRenderPipeline =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a PostProcessRenderPipeline\r\n   * @param engine engine to add the pipeline to\r\n   * @param name name of the pipeline\r\n   */\n  function PostProcessRenderPipeline(engine, name) {\n    this.engine = engine;\n    this._name = name;\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n    this._cameras = [];\n  }\n\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"name\", {\n    /**\r\n     * Gets pipeline name\r\n     */\n    get: function () {\n      return this._name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"cameras\", {\n    /** Gets the list of attached cameras */\n    get: function () {\n      return this._cameras;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the class name\r\n   * @returns \"PostProcessRenderPipeline\"\r\n   */\n\n  PostProcessRenderPipeline.prototype.getClassName = function () {\n    return \"PostProcessRenderPipeline\";\n  };\n\n  Object.defineProperty(PostProcessRenderPipeline.prototype, \"isSupported\", {\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\n    get: function () {\n      for (var renderEffectName in this._renderEffects) {\n        if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n          if (!this._renderEffects[renderEffectName].isSupported) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Adds an effect to the pipeline\r\n   * @param renderEffect the effect to add\r\n   */\n\n  PostProcessRenderPipeline.prototype.addEffect = function (renderEffect) {\n    this._renderEffects[renderEffect._name] = renderEffect;\n  }; // private\n\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._rebuild = function () {};\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._enableEffect = function (renderEffectName, cameras) {\n    var renderEffects = this._renderEffects[renderEffectName];\n\n    if (!renderEffects) {\n      return;\n    }\n\n    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._disableEffect = function (renderEffectName, cameras) {\n    var renderEffects = this._renderEffects[renderEffectName];\n\n    if (!renderEffects) {\n      return;\n    }\n\n    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._attachCameras = function (cameras, unique) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    var indicesToDelete = [];\n    var i;\n\n    for (i = 0; i < cams.length; i++) {\n      var camera = cams[i];\n\n      if (!camera) {\n        continue;\n      }\n\n      var cameraName = camera.name;\n\n      if (this._cameras.indexOf(camera) === -1) {\n        this._cameras[cameraName] = camera;\n      } else if (unique) {\n        indicesToDelete.push(i);\n      }\n    }\n\n    for (i = 0; i < indicesToDelete.length; i++) {\n      cameras.splice(indicesToDelete[i], 1);\n    }\n\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._attachCameras(cams);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._detachCameras = function (cameras) {\n    var cams = Tools.MakeArray(cameras || this._cameras);\n\n    if (!cams) {\n      return;\n    }\n\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._detachCameras(cams);\n      }\n    }\n\n    for (var i = 0; i < cams.length; i++) {\n      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._update = function () {\n    for (var renderEffectName in this._renderEffects) {\n      if (this._renderEffects.hasOwnProperty(renderEffectName)) {\n        this._renderEffects[renderEffectName]._update();\n      }\n    }\n\n    for (var i = 0; i < this._cameras.length; i++) {\n      if (!this._cameras[i]) {\n        continue;\n      }\n\n      var cameraName = this._cameras[i].name;\n\n      if (this._renderEffectsForIsolatedPass[cameraName]) {\n        this._renderEffectsForIsolatedPass[cameraName]._update();\n      }\n    }\n  };\n  /** @hidden */\n\n\n  PostProcessRenderPipeline.prototype._reset = function () {\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n  };\n\n  PostProcessRenderPipeline.prototype._enableMSAAOnFirstPostProcess = function (sampleCount) {\n    if (this.engine.webGLVersion === 1) {\n      return false;\n    } // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\n\n\n    var effectKeys = Object.keys(this._renderEffects);\n\n    if (effectKeys.length > 0) {\n      var postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\n\n      if (postProcesses) {\n        postProcesses[0].samples = sampleCount;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Sets the required values to the prepass renderer.\r\n   * @param prePassRenderer defines the prepass renderer to setup.\r\n   * @returns true if the pre pass is needed.\r\n   */\n\n\n  PostProcessRenderPipeline.prototype.setPrePassRenderer = function (prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  };\n  /**\r\n   * Disposes of the pipeline\r\n   */\n\n\n  PostProcessRenderPipeline.prototype.dispose = function () {// Must be implemented by children\n  };\n\n  __decorate([serialize()], PostProcessRenderPipeline.prototype, \"_name\", void 0);\n\n  return PostProcessRenderPipeline;\n}();\n\nexport { PostProcessRenderPipeline };","map":{"version":3,"sources":["../../../../sourceES6/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { PostProcessRenderEffect } from \"./postProcessRenderEffect\";\r\nimport { IInspectable } from '../../Misc/iInspectable';\r\n\r\ndeclare type PrePassRenderer = import(\"../../Rendering/prePassRenderer\").PrePassRenderer;\r\n\r\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline\r\n */\r\nexport class PostProcessRenderPipeline {\r\n\r\n    private _renderEffects: { [key: string]: PostProcessRenderEffect };\r\n    private _renderEffectsForIsolatedPass: PostProcessRenderEffect[];\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    protected _cameras: Camera[];\r\n\r\n    /** @hidden */\r\n    @serialize()\r\n    public _name: string;\r\n\r\n    /**\r\n     * Gets pipeline name\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the list of attached cameras */\r\n    public get cameras() {\r\n        return this._cameras;\r\n    }\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipeline\r\n     * @param engine engine to add the pipeline to\r\n     * @param name name of the pipeline\r\n     */\r\n    constructor(private engine: Engine, name: string) {\r\n        this._name = name;\r\n\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n\r\n        this._cameras = [];\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns \"PostProcessRenderPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcessRenderPipeline\";\r\n    }\r\n\r\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (var renderEffectName in this._renderEffects) {\r\n            if (this._renderEffects.hasOwnProperty(renderEffectName)) {\r\n                if (!this._renderEffects[renderEffectName].isSupported) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds an effect to the pipeline\r\n     * @param renderEffect the effect to add\r\n     */\r\n    public addEffect(renderEffect: PostProcessRenderEffect): void {\r\n        (<any>this._renderEffects)[renderEffect._name] = renderEffect;\r\n    }\r\n\r\n    // private\r\n\r\n    /** @hidden */\r\n    public _rebuild() {\r\n\r\n    }\r\n\r\n    /** @hidden */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera): void;\r\n    /** @hidden */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera[]): void;\r\n    /** @hidden */\r\n    public _enableEffect(renderEffectName: string, cameras: any): void {\r\n        var renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @hidden */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /** @hidden */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /** @hidden */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void {\r\n        var renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @hidden */\r\n    public _attachCameras(cameras: Camera, unique: boolean): void;\r\n    /** @hidden */\r\n    public _attachCameras(cameras: Camera[], unique: boolean): void;\r\n    /** @hidden */\r\n    public _attachCameras(cameras: any, unique: boolean): void {\r\n        var cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        var indicesToDelete = [];\r\n        var i: number;\r\n        for (i = 0; i < cams.length; i++) {\r\n            var camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n            var cameraName = camera.name;\r\n\r\n            if (this._cameras.indexOf(camera) === -1) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n            else if (unique) {\r\n                indicesToDelete.push(i);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < indicesToDelete.length; i++) {\r\n            cameras.splice(indicesToDelete[i], 1);\r\n        }\r\n\r\n        for (var renderEffectName in this._renderEffects) {\r\n            if (this._renderEffects.hasOwnProperty(renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._attachCameras(cams);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /** @hidden */\r\n    public _detachCameras(cameras: Nullable<Camera[]>): void;\r\n    /** @hidden */\r\n    public _detachCameras(cameras: any): void {\r\n        var cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (var renderEffectName in this._renderEffects) {\r\n            if (this._renderEffects.hasOwnProperty(renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._detachCameras(cams);\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < cams.length; i++) {\r\n            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _update(): void {\r\n        for (var renderEffectName in this._renderEffects) {\r\n            if (this._renderEffects.hasOwnProperty(renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._update();\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < this._cameras.length; i++) {\r\n            if (! this._cameras[i]) {\r\n                continue;\r\n            }\r\n            var cameraName = this._cameras[i].name;\r\n            if ((<any>this._renderEffectsForIsolatedPass)[cameraName]) {\r\n                (<any>this._renderEffectsForIsolatedPass)[cameraName]._update();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _reset(): void {\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n    }\r\n\r\n    protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean {\r\n        if (this.engine.webGLVersion === 1) {\r\n            return false;\r\n        }\r\n\r\n        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\r\n        var effectKeys = Object.keys(this._renderEffects);\r\n        if (effectKeys.length > 0) {\r\n            var postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\r\n            if (postProcesses) {\r\n                postProcesses[0].samples = sampleCount;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the pipeline\r\n     */\r\n    public dispose() {\r\n        // Must be implemented by children\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}