{"ast":null,"code":"import { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { DiscBuilder } from \"../Meshes/Builders/discBuilder\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { Axis } from '../Maths/math.axis';\nimport { SubMesh } from '../Meshes/subMesh';\nimport { StandardMaterial } from '../Materials/standardMaterial';\nimport { MultiMaterial } from '../Materials/multiMaterial';\nimport { Tools } from '../Misc/tools';\n/**\r\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\r\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The SPS is also a particle system. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System\r\n */\n\nvar SolidParticleSystem =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a SPS (Solid Particle System) object.\r\n   * @param name (String) is the SPS name, this will be the underlying mesh name.\r\n   * @param scene (Scene) is the scene in which the SPS is added.\r\n   * @param options defines the options of the sps e.g.\r\n   * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\r\n   * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\r\n   * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\r\n   * * useModelMaterial (optional boolean, defaut false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\r\n   * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\r\n   * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\r\n   * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\r\n   * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\r\n   * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.\r\n   * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\r\n   */\n  function SolidParticleSystem(name, scene, options) {\n    /**\r\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\n    this.particles = new Array();\n    /**\r\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\r\n     */\n\n    this.nbParticles = 0;\n    /**\r\n     * If the particles must ever face the camera (default false). Useful for planar particles.\r\n     */\n\n    this.billboard = false;\n    /**\r\n     * Recompute normals when adding a shape\r\n     */\n\n    this.recomputeNormals = false;\n    /**\r\n     * This a counter ofr your own usage. It's not set by any SPS functions.\r\n     */\n\n    this.counter = 0;\n    /**\r\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns\r\n     */\n\n    this.vars = {};\n    /**\r\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\r\n     * @hidden\r\n     */\n\n    this._bSphereOnly = false;\n    /**\r\n     * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)\r\n     * @hidden\r\n     */\n\n    this._bSphereRadiusFactor = 1.0;\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._index = 0; // indices index\n\n    this._updatable = true;\n    this._pickable = false;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._depthSort = false;\n    this._expandable = false;\n    this._shapeCounter = 0;\n    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\n    this._color = new Color4(0, 0, 0, 0);\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeParticleVertex = false;\n    this._computeBoundingBox = false;\n    this._depthSortParticles = true;\n    this._mustUnrotateFixedNormals = false;\n    this._particlesIntersect = false;\n    this._needs32Bits = false;\n    this._isNotBuilt = true;\n    this._lastParticleId = 0;\n    this._idxOfId = []; // array : key = particle.id / value = particle.idx\n\n    this._multimaterialEnabled = false;\n    this._useModelMaterial = false;\n\n    this._depthSortFunction = function (p1, p2) {\n      return p2.sqDistance - p1.sqDistance;\n    };\n\n    this._materialSortFunction = function (p1, p2) {\n      return p1.materialIndex - p2.materialIndex;\n    };\n\n    this._autoUpdateSubMeshes = false;\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._camera = scene.activeCamera;\n    this._pickable = options ? options.isPickable : false;\n    this._depthSort = options ? options.enableDepthSort : false;\n    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;\n    this._useModelMaterial = options ? options.useModelMaterial : false;\n    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\n    this._expandable = options ? options.expandable : false;\n    this._particlesIntersect = options ? options.particleIntersection : false;\n    this._bSphereOnly = options ? options.boundingSphereOnly : false;\n    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\n\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    if (this._multimaterialEnabled) {\n      this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n      this._materials = [];\n      this._materialIndexesById = {};\n    }\n\n    this._tmpVertex = new SolidParticleVertex();\n  }\n  /**\r\n   * Builds the SPS underlying mesh. Returns a standard Mesh.\r\n   * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\r\n   * @returns the created mesh\r\n   */\n\n\n  SolidParticleSystem.prototype.buildMesh = function () {\n    if (!this._isNotBuilt && this.mesh) {\n      return this.mesh;\n    }\n\n    if (this.nbParticles === 0 && !this.mesh) {\n      var triangle = DiscBuilder.CreateDisc(\"\", {\n        radius: 1,\n        tessellation: 3\n      }, this._scene);\n      this.addShape(triangle, 1);\n      triangle.dispose();\n    }\n\n    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n\n    if (!this.mesh) {\n      // in case it's already expanded\n      var mesh = new Mesh(this.name, this._scene);\n      this.mesh = mesh;\n    }\n\n    if (!this._updatable && this._multimaterialEnabled) {\n      this._sortParticlesByMaterial(); // this may reorder the indices32\n\n    }\n\n    if (this.recomputeNormals) {\n      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\n    }\n\n    this._normals32 = new Float32Array(this._normals);\n    this._fixedNormal32 = new Float32Array(this._normals);\n\n    if (this._mustUnrotateFixedNormals) {\n      // the particles could be created already rotated in the mesh with a positionFunction\n      this._unrotateFixedNormals();\n    }\n\n    var vertexData = new VertexData();\n    vertexData.indices = this._depthSort ? this._indices : this._indices32;\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    vertexData.set(this._normals32, VertexBuffer.NormalKind);\n\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n\n    if (this._colors32.length > 0) {\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n\n    vertexData.applyToMesh(this.mesh, this._updatable);\n    this.mesh.isPickable = this._pickable;\n\n    if (this._pickable) {\n      var faceId = 0;\n\n      for (var p = 0; p < this.nbParticles; p++) {\n        var part = this.particles[p];\n        var lind = part._model._indicesLength;\n\n        for (var i = 0; i < lind; i++) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = {\n              idx: part.idx,\n              faceId: faceId\n            };\n            this.pickedParticles[faceId] = pickedData;\n            faceId++;\n          }\n        }\n      }\n    }\n\n    if (this._multimaterialEnabled) {\n      this.setMultiMaterial(this._materials);\n    }\n\n    if (!this._expandable) {\n      // free memory\n      if (!this._depthSort && !this._multimaterialEnabled) {\n        this._indices = null;\n      }\n\n      this._positions = null;\n      this._normals = null;\n      this._uvs = null;\n      this._colors = null;\n\n      if (!this._updatable) {\n        this.particles.length = 0;\n      }\n    }\n\n    this._isNotBuilt = false;\n    this.recomputeNormals = false;\n    return this.mesh;\n  };\n  /**\r\n   * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\r\n   * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\r\n   * Thus the particles generated from `digest()` have their property `position` set yet.\r\n   * @param mesh ( Mesh ) is the mesh to be digested\r\n   * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any\r\n   * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\r\n   * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\r\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n   * @returns the current SPS\r\n   */\n\n\n  SolidParticleSystem.prototype.digest = function (mesh, options) {\n    var size = options && options.facetNb || 1;\n    var number = options && options.number || 0;\n    var delta = options && options.delta || 0;\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    var storage = options && options.storage ? options.storage : null;\n    var f = 0; // facet counter\n\n    var totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n    // compute size from number\n\n    if (number) {\n      number = number > totalFacets ? totalFacets : number;\n      size = Math.round(totalFacets / number);\n      delta = 0;\n    } else {\n      size = size > totalFacets ? totalFacets : size;\n    }\n\n    var facetPos = []; // submesh positions\n\n    var facetNor = [];\n    var facetInd = []; // submesh indices\n\n    var facetUV = []; // submesh UV\n\n    var facetCol = []; // submesh colors\n\n    var barycenter = Vector3.Zero();\n    var sizeO = size;\n\n    while (f < totalFacets) {\n      size = sizeO + Math.floor((1 + delta) * Math.random());\n\n      if (f > totalFacets - size) {\n        size = totalFacets - f;\n      } // reset temp arrays\n\n\n      facetPos.length = 0;\n      facetNor.length = 0;\n      facetInd.length = 0;\n      facetUV.length = 0;\n      facetCol.length = 0; // iterate over \"size\" facets\n\n      var fi = 0;\n\n      for (var j = f * 3; j < (f + size) * 3; j++) {\n        facetInd.push(fi);\n        var i = meshInd[j];\n        var i3 = i * 3;\n        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\n        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\n\n        if (meshUV) {\n          var i2 = i * 2;\n          facetUV.push(meshUV[i2], meshUV[i2 + 1]);\n        }\n\n        if (meshCol) {\n          var i4 = i * 4;\n          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\n        }\n\n        fi++;\n      } // create a model shape for each single particle\n\n\n      var idx = this.nbParticles;\n\n      var shape = this._posToShape(facetPos);\n\n      var shapeUV = this._uvsToShapeUV(facetUV);\n\n      var shapeInd = Tools.Slice(facetInd);\n      var shapeCol = Tools.Slice(facetCol);\n      var shapeNor = Tools.Slice(facetNor); // compute the barycenter of the shape\n\n      barycenter.copyFromFloats(0, 0, 0);\n      var v;\n\n      for (v = 0; v < shape.length; v++) {\n        barycenter.addInPlace(shape[v]);\n      }\n\n      barycenter.scaleInPlace(1 / shape.length); // shift the shape from its barycenter to the origin\n      // and compute the BBox required for intersection.\n\n      var minimum = new Vector3(Infinity, Infinity, Infinity);\n      var maximum = new Vector3(-Infinity, -Infinity, -Infinity);\n\n      for (v = 0; v < shape.length; v++) {\n        shape[v].subtractInPlace(barycenter);\n        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n      }\n\n      var bInfo;\n\n      if (this._particlesIntersect) {\n        bInfo = new BoundingInfo(minimum, maximum);\n      }\n\n      var material = null;\n\n      if (this._useModelMaterial) {\n        material = mesh.material ? mesh.material : this._setDefaultMaterial();\n      }\n\n      var modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material); // add the particle in the SPS\n\n      var currentPos = this._positions.length;\n      var currentInd = this._indices.length;\n\n      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\n\n      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage); // initialize the particle position\n\n\n      this.particles[this.nbParticles].position.addInPlace(barycenter);\n\n      if (!storage) {\n        this._index += shape.length;\n        idx++;\n        this.nbParticles++;\n        this._lastParticleId++;\n      }\n\n      this._shapeCounter++;\n      f += size;\n    }\n\n    this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\r\n   * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._unrotateFixedNormals = function () {\n    var index = 0;\n    var idx = 0;\n    var tmpNormal = TmpVectors.Vector3[0];\n    var quaternion = TmpVectors.Quaternion[0];\n    var invertedRotMatrix = TmpVectors.Matrix[0];\n\n    for (var p = 0; p < this.particles.length; p++) {\n      var particle = this.particles[p];\n      var shape = particle._model._shape; // computing the inverse of the rotation matrix from the quaternion\n      // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\n\n      if (particle.rotationQuaternion) {\n        particle.rotationQuaternion.conjugateToRef(quaternion);\n      } else {\n        var rotation = particle.rotation;\n        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        quaternion.conjugateInPlace();\n      }\n\n      quaternion.toRotationMatrix(invertedRotMatrix);\n\n      for (var pt = 0; pt < shape.length; pt++) {\n        idx = index + pt * 3;\n        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\n        tmpNormal.toArray(this._fixedNormal32, idx);\n      }\n\n      index = idx + 3;\n    }\n  };\n  /**\r\n   * Resets the temporary working copy particle\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._resetCopy = function () {\n    var copy = this._copy;\n    copy.position.setAll(0);\n    copy.rotation.setAll(0);\n    copy.rotationQuaternion = null;\n    copy.scaling.setAll(1);\n    copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\n    copy.color = null;\n    copy.translateFromPivot = false;\n    copy.shapeId = 0;\n    copy.materialIndex = null;\n  };\n  /**\r\n   * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\r\n   * @param p the current index in the positions array to be updated\r\n   * @param ind the current index in the indices array\r\n   * @param shape a Vector3 array, the shape geometry\r\n   * @param positions the positions array to be updated\r\n   * @param meshInd the shape indices array\r\n   * @param indices the indices array to be updated\r\n   * @param meshUV the shape uv array\r\n   * @param uvs the uv array to be updated\r\n   * @param meshCol the shape color array\r\n   * @param colors the color array to be updated\r\n   * @param meshNor the shape normals array\r\n   * @param normals the normals array to be updated\r\n   * @param idx the particle index\r\n   * @param idxInShape the particle index in its shape\r\n   * @param options the addShape() method  passed options\r\n   * @model the particle model\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._meshBuilder = function (p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {\n    var i;\n    var u = 0;\n    var c = 0;\n    var n = 0;\n\n    this._resetCopy();\n\n    var copy = this._copy;\n    var storeApart = options && options.storage ? true : false;\n    copy.idx = idx;\n    copy.idxInShape = idxInShape;\n    copy.shapeId = model.shapeID;\n\n    if (this._useModelMaterial) {\n      var materialId = model._material.uniqueId;\n      var materialIndexesById = this._materialIndexesById;\n\n      if (!materialIndexesById.hasOwnProperty(materialId)) {\n        materialIndexesById[materialId] = this._materials.length;\n\n        this._materials.push(model._material);\n      }\n\n      var matIdx = materialIndexesById[materialId];\n      copy.materialIndex = matIdx;\n    }\n\n    if (options && options.positionFunction) {\n      // call to custom positionFunction\n      options.positionFunction(copy, idx, idxInShape);\n      this._mustUnrotateFixedNormals = true;\n    } // in case the particle geometry must NOT be inserted in the SPS mesh geometry\n\n\n    if (storeApart) {\n      return copy;\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv;\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    Matrix.IdentityToRef(rotMatrix);\n    copy.getRotationMatrix(rotMatrix);\n    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.setAll(0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var someVertexFunction = options && options.vertexFunction;\n\n    for (i = 0; i < shape.length; i++) {\n      tmpVector.copyFrom(shape[i]);\n\n      if (copy.color) {\n        tmpColor.copyFrom(copy.color);\n      }\n\n      if (meshUV) {\n        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\n      }\n\n      if (someVertexFunction) {\n        options.vertexFunction(copy, tmpVertex, i);\n      }\n\n      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\n      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\n\n      if (meshUV) {\n        var copyUvs = copy.uvs;\n        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\n        u += 2;\n      }\n\n      if (copy.color) {\n        this._color.copyFrom(tmpColor);\n      } else {\n        var color = this._color;\n\n        if (meshCol && meshCol[c] !== undefined) {\n          color.r = meshCol[c];\n          color.g = meshCol[c + 1];\n          color.b = meshCol[c + 2];\n          color.a = meshCol[c + 3];\n        } else {\n          color.r = 1.0;\n          color.g = 1.0;\n          color.b = 1.0;\n          color.a = 1.0;\n        }\n      }\n\n      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n      c += 4;\n\n      if (!this.recomputeNormals && meshNor) {\n        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\n        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\n        n += 3;\n      }\n    }\n\n    for (i = 0; i < meshInd.length; i++) {\n      var current_ind = p + meshInd[i];\n      indices.push(current_ind);\n\n      if (current_ind > 65535) {\n        this._needs32Bits = true;\n      }\n    }\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      var matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\n      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\n    }\n\n    return copy;\n  };\n  /**\r\n   * Returns a shape Vector3 array from positions float array\r\n   * @param positions float array\r\n   * @returns a vector3 array\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._posToShape = function (positions) {\n    var shape = [];\n\n    for (var i = 0; i < positions.length; i += 3) {\n      shape.push(Vector3.FromArray(positions, i));\n    }\n\n    return shape;\n  };\n  /**\r\n   * Returns a shapeUV array from a float uvs (array deep copy)\r\n   * @param uvs as a float array\r\n   * @returns a shapeUV array\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._uvsToShapeUV = function (uvs) {\n    var shapeUV = [];\n\n    if (uvs) {\n      for (var i = 0; i < uvs.length; i++) {\n        shapeUV.push(uvs[i]);\n      }\n    }\n\n    return shapeUV;\n  };\n  /**\r\n   * Adds a new particle object in the particles array\r\n   * @param idx particle index in particles array\r\n   * @param id particle id\r\n   * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\r\n   * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\r\n   * @param model particle ModelShape object\r\n   * @param shapeId model shape identifier\r\n   * @param idxInShape index of the particle in the current model\r\n   * @param bInfo model bounding info object\r\n   * @param storage target storage array, if any\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._addParticle = function (idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo, storage) {\n    if (bInfo === void 0) {\n      bInfo = null;\n    }\n\n    if (storage === void 0) {\n      storage = null;\n    }\n\n    var sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\n    var target = storage ? storage : this.particles;\n    target.push(sp);\n    return sp;\n  };\n  /**\r\n   * Adds some particles to the SPS from the model shape. Returns the shape id.\r\n   * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps\r\n   * @param mesh is any Mesh object that will be used as a model for the solid particles.\r\n   * @param nb (positive integer) the number of particles to be created from this model\r\n   * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\r\n   * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\r\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n   * @returns the number of shapes in the system\r\n   */\n\n\n  SolidParticleSystem.prototype.addShape = function (mesh, nb, options) {\n    var meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    var meshInd = mesh.getIndices();\n    var meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    var meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    var meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    this.recomputeNormals = meshNor ? false : true;\n    var indices = Tools.SliceToArray(meshInd);\n    var shapeNormals = Tools.SliceToArray(meshNor);\n    var shapeColors = meshCol ? Tools.SliceToArray(meshCol) : [];\n    var storage = options && options.storage ? options.storage : null;\n    var bbInfo = null;\n\n    if (this._particlesIntersect) {\n      bbInfo = mesh.getBoundingInfo();\n    }\n\n    var shape = this._posToShape(meshPos);\n\n    var shapeUV = this._uvsToShapeUV(meshUV);\n\n    var posfunc = options ? options.positionFunction : null;\n    var vtxfunc = options ? options.vertexFunction : null;\n    var material = null;\n\n    if (this._useModelMaterial) {\n      material = mesh.material ? mesh.material : this._setDefaultMaterial();\n    }\n\n    var modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material); // particles\n\n    for (var i = 0; i < nb; i++) {\n      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\n    }\n\n    this._shapeCounter++;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this._shapeCounter - 1;\n  };\n  /**\r\n   * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._rebuildParticle = function (particle, reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    this._resetCopy();\n\n    var copy = this._copy;\n\n    if (particle._model._positionFunction) {\n      // recall to stored custom positionFunction\n      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\n    }\n\n    var rotMatrix = TmpVectors.Matrix[0];\n    var tmpVertex = TmpVectors.Vector3[0];\n    var tmpRotated = TmpVectors.Vector3[1];\n    var pivotBackTranslation = TmpVectors.Vector3[2];\n    var scaledPivot = TmpVectors.Vector3[3];\n    copy.getRotationMatrix(rotMatrix);\n    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\n\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n\n    var shape = particle._model._shape;\n\n    for (var pt = 0; pt < shape.length; pt++) {\n      tmpVertex.copyFrom(shape[pt]);\n\n      if (particle._model._vertexFunction) {\n        particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\n\n      }\n\n      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\n    }\n\n    if (reset) {\n      particle.position.setAll(0.0);\n      particle.rotation.setAll(0.0);\n      particle.rotationQuaternion = null;\n      particle.scaling.setAll(1.0);\n      particle.uvs.setAll(0.0);\n      particle.pivot.setAll(0.0);\n      particle.translateFromPivot = false;\n      particle.parentId = null;\n    }\n  };\n  /**\r\n   * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\r\n   * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.rebuildMesh = function (reset) {\n    if (reset === void 0) {\n      reset = false;\n    }\n\n    for (var p = 0; p < this.particles.length; p++) {\n      this._rebuildParticle(this.particles[p], reset);\n    }\n\n    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\n    return this;\n  };\n  /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\r\n   *  Returns an array with the removed particles.\r\n   *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\r\n   *  The SPS can't be empty so at least one particle needs to remain in place.\r\n   *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\r\n   * @param start index of the first particle to remove\r\n   * @param end index of the last particle to remove (included)\r\n   * @returns an array populated with the removed particles\r\n   */\n\n\n  SolidParticleSystem.prototype.removeParticles = function (start, end) {\n    var nb = end - start + 1;\n\n    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\n      return [];\n    }\n\n    var particles = this.particles;\n    var currentNb = this.nbParticles;\n\n    if (end < currentNb - 1) {\n      // update the particle indexes in the positions array in case they're remaining particles after the last removed\n      var firstRemaining = end + 1;\n      var shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\n      var shifInd = particles[firstRemaining]._ind - particles[start]._ind;\n\n      for (var i = firstRemaining; i < currentNb; i++) {\n        var part = particles[i];\n        part._pos -= shiftPos;\n        part._ind -= shifInd;\n      }\n    }\n\n    var removed = particles.splice(start, nb);\n    this._positions.length = 0;\n    this._indices.length = 0;\n    this._colors.length = 0;\n    this._uvs.length = 0;\n    this._normals.length = 0;\n    this._index = 0;\n    this._idxOfId.length = 0;\n\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n\n    var ind = 0;\n    var particlesLength = particles.length;\n\n    for (var p = 0; p < particlesLength; p++) {\n      var particle = particles[p];\n      var model = particle._model;\n      var shape = model._shape;\n      var modelIndices = model._indices;\n      var modelNormals = model._normals;\n      var modelColors = model._shapeColors;\n      var modelUVs = model._shapeUV;\n      particle.idx = p;\n      this._idxOfId[particle.id] = p;\n\n      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\n\n      this._index += shape.length;\n      ind += modelIndices.length;\n    }\n\n    this.nbParticles -= nb;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return removed;\n  };\n  /**\r\n   * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\r\n   * @param solidParticleArray an array populated with Solid Particles objects\r\n   * @returns the SPS\r\n   */\n\n\n  SolidParticleSystem.prototype.insertParticlesFromArray = function (solidParticleArray) {\n    if (!this._expandable) {\n      return this;\n    }\n\n    var idxInShape = 0;\n    var currentShapeId = solidParticleArray[0].shapeId;\n    var nb = solidParticleArray.length;\n\n    for (var i = 0; i < nb; i++) {\n      var sp = solidParticleArray[i];\n      var model = sp._model;\n      var shape = model._shape;\n      var meshInd = model._indices;\n      var meshUV = model._shapeUV;\n      var meshCol = model._shapeColors;\n      var meshNor = model._normals;\n      var noNor = meshNor ? false : true;\n      this.recomputeNormals = noNor || this.recomputeNormals;\n      var bbInfo = sp._boundingInfo;\n\n      var newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\n\n      sp.copyToRef(newPart);\n      idxInShape++;\n\n      if (currentShapeId != sp.shapeId) {\n        currentShapeId = sp.shapeId;\n        idxInShape = 0;\n      }\n    }\n\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n\n    return this;\n  };\n  /**\r\n   * Creates a new particle and modifies the SPS mesh geometry :\r\n   * - calls _meshBuilder() to increase the SPS mesh geometry step by step\r\n   * - calls _addParticle() to populate the particle array\r\n   * factorized code from addShape() and insertParticlesFromArray()\r\n   * @param idx particle index in the particles array\r\n   * @param i particle index in its shape\r\n   * @param modelShape particle ModelShape object\r\n   * @param shape shape vertex array\r\n   * @param meshInd shape indices array\r\n   * @param meshUV shape uv array\r\n   * @param meshCol shape color array\r\n   * @param meshNor shape normals array\r\n   * @param bbInfo shape bounding info\r\n   * @param storage target particle storage\r\n   * @options addShape() passed options\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._insertNewParticle = function (idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {\n    var currentPos = this._positions.length;\n    var currentInd = this._indices.length;\n\n    var currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\n\n    var sp = null;\n\n    if (this._updatable) {\n      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\n      sp.position.copyFrom(currentCopy.position);\n      sp.rotation.copyFrom(currentCopy.rotation);\n\n      if (currentCopy.rotationQuaternion) {\n        if (sp.rotationQuaternion) {\n          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n        } else {\n          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\n        }\n      }\n\n      if (currentCopy.color) {\n        if (sp.color) {\n          sp.color.copyFrom(currentCopy.color);\n        } else {\n          sp.color = currentCopy.color.clone();\n        }\n      }\n\n      sp.scaling.copyFrom(currentCopy.scaling);\n      sp.uvs.copyFrom(currentCopy.uvs);\n\n      if (currentCopy.materialIndex !== null) {\n        sp.materialIndex = currentCopy.materialIndex;\n      }\n\n      if (this.expandable) {\n        this._idxOfId[sp.id] = sp.idx;\n      }\n    }\n\n    if (!storage) {\n      this._index += shape.length;\n      this.nbParticles++;\n      this._lastParticleId++;\n    }\n\n    return sp;\n  };\n  /**\r\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n   *  This method calls `updateParticle()` for each particle of the SPS.\r\n   *  For an animated SPS, it is usually called within the render loop.\r\n   * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\r\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.setParticles = function (start, end, update) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (end === void 0) {\n      end = this.nbParticles - 1;\n    }\n\n    if (update === void 0) {\n      update = true;\n    }\n\n    if (!this._updatable || this._isNotBuilt) {\n      return this;\n    } // custom beforeUpdate\n\n\n    this.beforeUpdateParticles(start, end, update);\n    var rotMatrix = TmpVectors.Matrix[0];\n    var invertedMatrix = TmpVectors.Matrix[1];\n    var mesh = this.mesh;\n    var colors32 = this._colors32;\n    var positions32 = this._positions32;\n    var normals32 = this._normals32;\n    var uvs32 = this._uvs32;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var fixedNormal32 = this._fixedNormal32;\n    var tempVectors = TmpVectors.Vector3;\n    var camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    var camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    var camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    var minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    var maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    var camInvertedPosition = tempVectors[10].setAll(0);\n    var tmpVertex = this._tmpVertex;\n    var tmpVector = tmpVertex.position;\n    var tmpColor = tmpVertex.color;\n    var tmpUV = tmpVertex.uv; // cases when the World Matrix is to be computed first\n\n    if (this.billboard || this._depthSort) {\n      this.mesh.computeWorldMatrix(true);\n\n      this.mesh._worldMatrix.invertToRef(invertedMatrix);\n    } // if the particles will always face the camera\n\n\n    if (this.billboard) {\n      // compute the camera position and un-rotate it by the current mesh rotation\n      var tmpVector0 = tempVectors[0];\n\n      this._camera.getDirectionToRef(Axis.Z, tmpVector0);\n\n      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\n      camAxisZ.normalize(); // same for camera up vector extracted from the cam view matrix\n\n      var view = this._camera.getViewMatrix(true);\n\n      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\n      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\n      camAxisY.normalize();\n      camAxisX.normalize();\n    } // if depthSort, compute the camera global position in the mesh local system\n\n\n    if (this._depthSort) {\n      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\n    }\n\n    Matrix.IdentityToRef(rotMatrix);\n    var idx = 0; // current position index in the global array positions32\n\n    var index = 0; // position start index in the global array positions32 of the current particle\n\n    var colidx = 0; // current color index in the global array colors32\n\n    var colorIndex = 0; // color start index in the global array colors32 of the current particle\n\n    var uvidx = 0; // current uv index in the global array uvs32\n\n    var uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n\n    var pt = 0; // current index in the particle model shape\n\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        var boundingInfo = this.mesh._boundingInfo;\n\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    } // particle loop\n\n\n    index = this.particles[start]._pos;\n    var vpos = index / 3 | 0;\n    colorIndex = vpos * 4;\n    uvIndex = vpos * 2;\n\n    for (var p = start; p <= end; p++) {\n      var particle = this.particles[p]; // call to custom user function to update the particle properties\n\n      this.updateParticle(particle);\n      var shape = particle._model._shape;\n      var shapeUV = particle._model._shapeUV;\n      var particleRotationMatrix = particle._rotationMatrix;\n      var particlePosition = particle.position;\n      var particleRotation = particle.rotation;\n      var particleScaling = particle.scaling;\n      var particleGlobalPosition = particle._globalPosition; // camera-particle distance for depth sorting\n\n      if (this._depthSort && this._depthSortParticles) {\n        var dsp = this.depthSortedParticles[p];\n        dsp.idx = particle.idx;\n        dsp.ind = particle._ind;\n        dsp.indicesLength = particle._model._indicesLength;\n        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\n      } // skip the computations for inactive or already invisible particles\n\n\n      if (!particle.alive || particle._stillInvisible && !particle.isVisible) {\n        // increment indexes for the next particle\n        pt = shape.length;\n        index += pt * 3;\n        colorIndex += pt * 4;\n        uvIndex += pt * 2;\n        continue;\n      }\n\n      if (particle.isVisible) {\n        particle._stillInvisible = false; // un-mark permanent invisibility\n\n        var scaledPivot = tempVectors[12];\n        particle.pivot.multiplyToRef(particleScaling, scaledPivot); // particle rotation matrix\n\n        if (this.billboard) {\n          particleRotation.x = 0.0;\n          particleRotation.y = 0.0;\n        }\n\n        if (this._computeParticleRotation || this.billboard) {\n          particle.getRotationMatrix(rotMatrix);\n        }\n\n        var particleHasParent = particle.parentId !== null;\n\n        if (particleHasParent) {\n          var parent_1 = this.getParticleById(particle.parentId);\n\n          if (parent_1) {\n            var parentRotationMatrix = parent_1._rotationMatrix;\n            var parentGlobalPosition = parent_1._globalPosition;\n            var rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n            var rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n            var rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n\n            if (this._computeParticleRotation || this.billboard) {\n              var rotMatrixValues = rotMatrix.m;\n              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n            }\n          } else {\n            // in case the parent were removed at some moment\n            particle.parentId = null;\n          }\n        } else {\n          particleGlobalPosition.x = particlePosition.x;\n          particleGlobalPosition.y = particlePosition.y;\n          particleGlobalPosition.z = particlePosition.z;\n\n          if (this._computeParticleRotation || this.billboard) {\n            var rotMatrixValues = rotMatrix.m;\n            particleRotationMatrix[0] = rotMatrixValues[0];\n            particleRotationMatrix[1] = rotMatrixValues[1];\n            particleRotationMatrix[2] = rotMatrixValues[2];\n            particleRotationMatrix[3] = rotMatrixValues[4];\n            particleRotationMatrix[4] = rotMatrixValues[5];\n            particleRotationMatrix[5] = rotMatrixValues[6];\n            particleRotationMatrix[6] = rotMatrixValues[8];\n            particleRotationMatrix[7] = rotMatrixValues[9];\n            particleRotationMatrix[8] = rotMatrixValues[10];\n          }\n        }\n\n        var pivotBackTranslation = tempVectors[11];\n\n        if (particle.translateFromPivot) {\n          pivotBackTranslation.setAll(0.0);\n        } else {\n          pivotBackTranslation.copyFrom(scaledPivot);\n        } // particle vertex loop\n\n\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          var iu = 2 * pt;\n          var iv = iu + 1;\n          tmpVector.copyFrom(shape[pt]);\n\n          if (this._computeParticleColor && particle.color) {\n            tmpColor.copyFrom(particle.color);\n          }\n\n          if (this._computeParticleTexture) {\n            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\n          }\n\n          if (this._computeParticleVertex) {\n            this.updateParticleVertex(particle, tmpVertex, pt);\n          } // positions\n\n\n          var vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\n          var vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\n          var vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\n          var rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n          var rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n          var rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n          rotatedX += pivotBackTranslation.x;\n          rotatedY += pivotBackTranslation.y;\n          rotatedZ += pivotBackTranslation.z;\n          var px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n          var py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n          var pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n\n          if (this._computeBoundingBox) {\n            minimum.minimizeInPlaceFromFloats(px, py, pz);\n            maximum.maximizeInPlaceFromFloats(px, py, pz);\n          } // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n\n\n          if (!this._computeParticleVertex) {\n            var normalx = fixedNormal32[idx];\n            var normaly = fixedNormal32[idx + 1];\n            var normalz = fixedNormal32[idx + 2];\n            var rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\n            var rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\n            var rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\n            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\n            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\n            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\n          }\n\n          if (this._computeParticleColor && particle.color) {\n            var colors32_1 = this._colors32;\n            colors32_1[colidx] = tmpColor.r;\n            colors32_1[colidx + 1] = tmpColor.g;\n            colors32_1[colidx + 2] = tmpColor.b;\n            colors32_1[colidx + 3] = tmpColor.a;\n          }\n\n          if (this._computeParticleTexture) {\n            var uvs = particle.uvs;\n            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      } // particle just set invisible : scaled to zero and positioned at the origin\n      else {\n          particle._stillInvisible = true; // mark the particle as invisible\n\n          for (pt = 0; pt < shape.length; pt++) {\n            idx = index + pt * 3;\n            colidx = colorIndex + pt * 4;\n            uvidx = uvIndex + pt * 2;\n            positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\n            normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\n\n            if (this._computeParticleColor && particle.color) {\n              var color = particle.color;\n              colors32[colidx] = color.r;\n              colors32[colidx + 1] = color.g;\n              colors32[colidx + 2] = color.b;\n              colors32[colidx + 3] = color.a;\n            }\n\n            if (this._computeParticleTexture) {\n              var uvs = particle.uvs;\n              uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\n              uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\n            }\n          }\n        } // if the particle intersections must be computed : update the bbInfo\n\n\n      if (this._particlesIntersect) {\n        var bInfo = particle._boundingInfo;\n        var bBox = bInfo.boundingBox;\n        var bSphere = bInfo.boundingSphere;\n        var modelBoundingInfo = particle._modelBoundingInfo;\n\n        if (!this._bSphereOnly) {\n          // place, scale and rotate the particle bbox within the SPS local system, then update it\n          var modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\n          var tempMin = tempVectors[1];\n          var tempMax = tempVectors[2];\n          tempMin.setAll(Number.MAX_VALUE);\n          tempMax.setAll(-Number.MAX_VALUE);\n\n          for (var b = 0; b < 8; b++) {\n            var scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\n            var scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\n            var scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\n            var rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\n            var rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\n            var rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\n            var x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n            var y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n            var z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n            tempMin.minimizeInPlaceFromFloats(x, y, z);\n            tempMax.maximizeInPlaceFromFloats(x, y, z);\n          }\n\n          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\n        } // place and scale the particle bouding sphere in the SPS local system, then update it\n\n\n        var minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\n        var maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\n        var bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\n        var halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\n        var bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\n        var bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\n        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\n      } // increment indexes for the next particle\n\n\n      index = idx + 3;\n      colorIndex = colidx + 4;\n      uvIndex = uvidx + 2;\n    } // if the VBO must be updated\n\n\n    if (update) {\n      if (this._computeParticleColor) {\n        mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n      }\n\n      if (this._computeParticleTexture) {\n        mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n      }\n\n      mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n\n      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\n        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\n          // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n          var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\n          VertexData.ComputeNormals(positions32, indices32, normals32, params);\n\n          for (var i = 0; i < normals32.length; i++) {\n            fixedNormal32[i] = normals32[i];\n          }\n        }\n\n        if (!mesh.areNormalsFrozen) {\n          mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\n        }\n      }\n\n      if (this._depthSort && this._depthSortParticles) {\n        var depthSortedParticles = this.depthSortedParticles;\n        depthSortedParticles.sort(this._depthSortFunction);\n        var dspl = depthSortedParticles.length;\n        var sid = 0;\n        var faceId = 0;\n\n        for (var sorted = 0; sorted < dspl; sorted++) {\n          var sortedParticle = depthSortedParticles[sorted];\n          var lind = sortedParticle.indicesLength;\n          var sind = sortedParticle.ind;\n\n          for (var i = 0; i < lind; i++) {\n            indices32[sid] = indices[sind + i];\n            sid++;\n\n            if (this._pickable) {\n              var f = i % 3;\n\n              if (f == 0) {\n                var pickedData = this.pickedParticles[faceId];\n                pickedData.idx = sortedParticle.idx;\n                pickedData.faceId = faceId;\n                faceId++;\n              }\n            }\n          }\n        }\n\n        mesh.updateIndices(indices32);\n      }\n    }\n\n    if (this._computeBoundingBox) {\n      if (mesh._boundingInfo) {\n        mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n\n    if (this._autoUpdateSubMeshes) {\n      this.computeSubMeshes();\n    }\n\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  };\n  /**\r\n  * Disposes the SPS.\r\n  */\n\n\n  SolidParticleSystem.prototype.dispose = function () {\n    this.mesh.dispose();\n    this.vars = null; // drop references to internal big arrays for the GC\n\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._normals32 = null;\n    this._fixedNormal32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n    this.pickedParticles = null;\n    this.pickedBySubMesh = null;\n    this._materials = null;\n    this._materialIndexes = null;\n    this._indicesByMaterial = null;\n    this._idxOfId = null;\n  };\n  /** Returns an object {idx: numbern faceId: number} for the picked particle from the passed pickingInfo object.\r\n   * idx is the particle index in the SPS\r\n   * faceId is the picked face index counted within this particle.\r\n   * Returns null if the pickInfo can't identify a picked particle.\r\n   * @param pickingInfo (PickingInfo object)\r\n   * @returns {idx: number, faceId: number} or null\r\n   */\n\n\n  SolidParticleSystem.prototype.pickedParticle = function (pickingInfo) {\n    if (pickingInfo.hit) {\n      var subMesh = pickingInfo.subMeshId;\n      var faceId = pickingInfo.faceId;\n      var picked = this.pickedBySubMesh;\n\n      if (picked[subMesh] && picked[subMesh][faceId]) {\n        return picked[subMesh][faceId];\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns a SolidParticle object from its identifier : particle.id\r\n   * @param id (integer) the particle Id\r\n   * @returns the searched particle or null if not found in the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticleById = function (id) {\n    var p = this.particles[id];\n\n    if (p && p.id == id) {\n      return p;\n    }\n\n    var particles = this.particles;\n    var idx = this._idxOfId[id];\n\n    if (idx !== undefined) {\n      return particles[idx];\n    }\n\n    var i = 0;\n    var nb = this.nbParticles;\n\n    while (i < nb) {\n      var particle = particles[i];\n\n      if (particle.id == id) {\n        return particle;\n      }\n\n      i++;\n    }\n\n    return null;\n  };\n  /**\r\n   * Returns a new array populated with the particles having the passed shapeId.\r\n   * @param shapeId (integer) the shape identifier\r\n   * @returns a new solid particle array\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeId = function (shapeId) {\n    var ref = [];\n    this.getParticlesByShapeIdToRef(shapeId, ref);\n    return ref;\n  };\n  /**\r\n   * Populates the passed array \"ref\" with the particles having the passed shapeId.\r\n   * @param shapeId the shape identifier\r\n   * @returns the SPS\r\n   * @param ref\r\n   */\n\n\n  SolidParticleSystem.prototype.getParticlesByShapeIdToRef = function (shapeId, ref) {\n    ref.length = 0;\n\n    for (var i = 0; i < this.nbParticles; i++) {\n      var p = this.particles[i];\n\n      if (p.shapeId == shapeId) {\n        ref.push(p);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Computes the required SubMeshes according the materials assigned to the particles.\r\n   * @returns the solid particle system.\r\n   * Does nothing if called before the SPS mesh is built.\r\n   */\n\n\n  SolidParticleSystem.prototype.computeSubMeshes = function () {\n    if (!this.mesh || !this._multimaterialEnabled) {\n      return this;\n    }\n\n    var depthSortedParticles = this.depthSortedParticles;\n\n    if (this.particles.length > 0) {\n      for (var p = 0; p < this.particles.length; p++) {\n        var part = this.particles[p];\n\n        if (!part.materialIndex) {\n          part.materialIndex = 0;\n        }\n\n        var sortedPart = depthSortedParticles[p];\n        sortedPart.materialIndex = part.materialIndex;\n        sortedPart.ind = part._ind;\n        sortedPart.indicesLength = part._model._indicesLength;\n        sortedPart.idx = part.idx;\n      }\n    }\n\n    this._sortParticlesByMaterial();\n\n    var indicesByMaterial = this._indicesByMaterial;\n    var materialIndexes = this._materialIndexes;\n    var mesh = this.mesh;\n    mesh.subMeshes = [];\n    var vcount = mesh.getTotalVertices();\n\n    for (var m = 0; m < materialIndexes.length; m++) {\n      var start = indicesByMaterial[m];\n      var count = indicesByMaterial[m + 1] - start;\n      var matIndex = materialIndexes[m];\n      new SubMesh(matIndex, 0, vcount, start, count, mesh);\n    }\n\n    return this;\n  };\n  /**\r\n   * Sorts the solid particles by material when MultiMaterial is enabled.\r\n   * Updates the indices32 array.\r\n   * Updates the indicesByMaterial array.\r\n   * Updates the mesh indices array.\r\n   * @returns the SPS\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._sortParticlesByMaterial = function () {\n    var indicesByMaterial = [0];\n    this._indicesByMaterial = indicesByMaterial;\n    var materialIndexes = [];\n    this._materialIndexes = materialIndexes;\n    var depthSortedParticles = this.depthSortedParticles;\n    depthSortedParticles.sort(this._materialSortFunction);\n    var length = depthSortedParticles.length;\n    var indices32 = this._indices32;\n    var indices = this._indices;\n    var subMeshIndex = 0;\n    var subMeshFaceId = 0;\n    var sid = 0;\n    var lastMatIndex = depthSortedParticles[0].materialIndex;\n    materialIndexes.push(lastMatIndex);\n\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n\n    for (var sorted = 0; sorted < length; sorted++) {\n      var sortedPart = depthSortedParticles[sorted];\n      var lind = sortedPart.indicesLength;\n      var sind = sortedPart.ind;\n\n      if (sortedPart.materialIndex !== lastMatIndex) {\n        lastMatIndex = sortedPart.materialIndex;\n        indicesByMaterial.push(sid);\n        materialIndexes.push(lastMatIndex);\n\n        if (this._pickable) {\n          subMeshIndex++;\n          this.pickedBySubMesh[subMeshIndex] = [];\n          subMeshFaceId = 0;\n        }\n      }\n\n      var faceId = 0;\n\n      for (var i = 0; i < lind; i++) {\n        indices32[sid] = indices[sind + i];\n\n        if (this._pickable) {\n          var f = i % 3;\n\n          if (f == 0) {\n            var pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\n\n            if (pickedData) {\n              pickedData.idx = sortedPart.idx;\n              pickedData.faceId = faceId;\n            } else {\n              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = {\n                idx: sortedPart.idx,\n                faceId: faceId\n              };\n            }\n\n            subMeshFaceId++;\n            faceId++;\n          }\n        }\n\n        sid++;\n      }\n    }\n\n    indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\n\n    if (this._updatable) {\n      this.mesh.updateIndices(indices32);\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets the material indexes by id materialIndexesById[id] = materialIndex\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._setMaterialIndexesById = function () {\n    this._materialIndexesById = {};\n\n    for (var i = 0; i < this._materials.length; i++) {\n      var id = this._materials[i].uniqueId;\n      this._materialIndexesById[id] = i;\n    }\n  };\n  /**\r\n   * Returns an array with unique values of Materials from the passed array\r\n   * @param array the material array to be checked and filtered\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._filterUniqueMaterialId = function (array) {\n    var filtered = array.filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    });\n    return filtered;\n  };\n  /**\r\n   * Sets a new Standard Material as _defaultMaterial if not already set.\r\n   * @hidden\r\n   */\n\n\n  SolidParticleSystem.prototype._setDefaultMaterial = function () {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\n    }\n\n    return this._defaultMaterial;\n  };\n  /**\r\n   * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n   * @returns the SPS.\r\n   */\n\n\n  SolidParticleSystem.prototype.refreshVisibleSize = function () {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n\n    return this;\n  };\n  /**\r\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n   * @param size the size (float) of the visibility box\r\n   * note : this doesn't lock the SPS mesh bounding box.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n   */\n\n\n  SolidParticleSystem.prototype.setVisibilityBox = function (size) {\n    var vis = size / 2;\n    this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"isAlwaysVisible\", {\n    /**\r\n     * Gets whether the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    get: function () {\n      return this._alwaysVisible;\n    },\n\n    /**\r\n     * Sets the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    set: function (val) {\n      this._alwaysVisible = val;\n      this.mesh.alwaysSelectAsActiveMesh = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"isVisibilityBoxLocked\", {\n    /**\r\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    get: function () {\n      return this._isVisibilityBoxLocked;\n    },\n\n    /**\r\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\n    set: function (val) {\n      this._isVisibilityBoxLocked = val;\n      var boundingInfo = this.mesh.getBoundingInfo();\n      boundingInfo.isLocked = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleRotation\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\n    get: function () {\n      return this._computeParticleRotation;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\n    set: function (val) {\n      this._computeParticleRotation = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleColor\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    get: function () {\n      return this._computeParticleColor;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\n    set: function (val) {\n      this._computeParticleColor = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleTexture\", {\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\n    get: function () {\n      return this._computeParticleTexture;\n    },\n    set: function (val) {\n      this._computeParticleTexture = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleVertex\", {\n    /**\r\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\n    get: function () {\n      return this._computeParticleVertex;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\n    set: function (val) {\n      this._computeParticleVertex = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"computeBoundingBox\", {\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\n    get: function () {\n      return this._computeBoundingBox;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\n    set: function (val) {\n      this._computeBoundingBox = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"depthSortParticles\", {\n    /**\r\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\n    get: function () {\n      return this._depthSortParticles;\n    },\n\n    /**\r\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\n    set: function (val) {\n      this._depthSortParticles = val;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"expandable\", {\n    /**\r\n     * Gets if the SPS is created as expandable at construction time.\r\n     * Default : `false`\r\n     */\n    get: function () {\n      return this._expandable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterialEnabled\", {\n    /**\r\n     * Gets if the SPS supports the Multi Materials\r\n     */\n    get: function () {\n      return this._multimaterialEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"useModelMaterial\", {\n    /**\r\n     * Gets if the SPS uses the model materials for its own multimaterial.\r\n     */\n    get: function () {\n      return this._useModelMaterial;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"materials\", {\n    /**\r\n     * The SPS used material array.\r\n    */\n    get: function () {\n      return this._materials;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Sets the SPS MultiMaterial from the passed materials.\r\n   * Note : the passed array is internally copied and not used then by reference.\r\n   * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\r\n   */\n\n  SolidParticleSystem.prototype.setMultiMaterial = function (materials) {\n    this._materials = this._filterUniqueMaterialId(materials);\n\n    this._setMaterialIndexesById();\n\n    if (this._multimaterial) {\n      this._multimaterial.dispose();\n    }\n\n    this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n\n    for (var m = 0; m < this._materials.length; m++) {\n      this._multimaterial.subMaterials.push(this._materials[m]);\n    }\n\n    this.computeSubMeshes();\n    this.mesh.material = this._multimaterial;\n  };\n\n  Object.defineProperty(SolidParticleSystem.prototype, \"multimaterial\", {\n    /**\r\n     * The SPS computed multimaterial object\r\n     */\n    get: function () {\n      return this._multimaterial;\n    },\n    set: function (mm) {\n      this._multimaterial = mm;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SolidParticleSystem.prototype, \"autoUpdateSubMeshes\", {\n    /**\r\n     * If the subMeshes must be updated on the next call to setParticles()\r\n     */\n    get: function () {\n      return this._autoUpdateSubMeshes;\n    },\n    set: function (val) {\n      this._autoUpdateSubMeshes = val;\n    },\n    enumerable: false,\n    configurable: true\n  }); // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by the user to fit his needs\n\n  /**\r\n   * This function does nothing. It may be overwritten to set all the particle first values.\r\n   * The SPS doesn't call this function, you may have to call it by your own.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   */\n\n  SolidParticleSystem.prototype.initParticles = function () {};\n  /**\r\n   * This function does nothing. It may be overwritten to recycle a particle.\r\n   * The SPS doesn't call this function, you may have to call it by your own.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   * @param particle The particle to recycle\r\n   * @returns the recycled particle\r\n   */\n\n\n  SolidParticleSystem.prototype.recycleParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a particle : this function should  be overwritten by the user.\r\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n   * @example : just set a particle position or velocity and recycle conditions\r\n   * @param particle The particle to update\r\n   * @returns the updated particle\r\n   */\n\n\n  SolidParticleSystem.prototype.updateParticle = function (particle) {\n    return particle;\n  };\n  /**\r\n   * Updates a vertex of a particle : it can be overwritten by the user.\r\n   * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\r\n   * @param particle the current particle\r\n   * @param vertex the current vertex of the current particle : a SolidParticleVertex object\r\n   * @param pt the index of the current vertex in the particle shape\r\n   * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape\r\n   * @example : just set a vertex particle position or color\r\n   * @returns the sps\r\n   */\n\n\n  SolidParticleSystem.prototype.updateParticleVertex = function (particle, vertex, pt) {\n    return this;\n  };\n  /**\r\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  SolidParticleSystem.prototype.beforeUpdateParticles = function (start, stop, update) {};\n  /**\r\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n   * This will be passed three parameters.\r\n   * This does nothing and may be overwritten by the user.\r\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n   * @param update the boolean update value actually passed to setParticles()\r\n   */\n\n\n  SolidParticleSystem.prototype.afterUpdateParticles = function (start, stop, update) {};\n\n  return SolidParticleSystem;\n}();\n\nexport { SolidParticleSystem };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/solidParticleSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, IndicesArray, FloatArray } from \"../types\";\r\nimport { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color4 } from '../Maths/math.color';\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { DiscBuilder } from \"../Meshes/Builders/discBuilder\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Axis } from '../Maths/math.axis';\r\nimport { SubMesh } from '../Meshes/subMesh';\r\nimport { Material } from '../Materials/material';\r\nimport { StandardMaterial } from '../Materials/standardMaterial';\r\nimport { MultiMaterial } from '../Materials/multiMaterial';\r\nimport { PickingInfo } from '../Collisions/pickingInfo';\r\nimport { Tools } from '../Misc/tools';\r\n\r\n/**\r\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\r\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The SPS is also a particle system. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : https://doc.babylonjs.com/how_to/Solid_Particle_System\r\n */\r\nexport class SolidParticleSystem implements IDisposable {\r\n    /**\r\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: SolidParticle[] = new Array<SolidParticle>();\r\n    /**\r\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * If the particles must ever face the camera (default false). Useful for planar particles.\r\n     */\r\n    public billboard: boolean = false;\r\n    /**\r\n     * Recompute normals when adding a shape\r\n     */\r\n    public recomputeNormals: boolean = false;\r\n    /**\r\n     * This a counter ofr your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The SPS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.\r\n     */\r\n    public mesh: Mesh;\r\n    /**\r\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#garbage-collector-concerns\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * This array is populated when the SPS is set as 'pickable'.\r\n     * Each key of this array is a `faceId` value that you can get from a pickResult object.\r\n     * Each element of this array is an object `{idx: int, faceId: int}`.\r\n     * `idx` is the picked particle index in the `SPS.particles` array\r\n     * `faceId` is the picked face index counted within this particle.\r\n     * This array is the first element of the pickedBySubMesh array : sps.pickBySubMesh[0].\r\n     * It's not pertinent to use it when using a SPS with the support for MultiMaterial enabled.\r\n     * Use the method SPS.pickedParticle(pickingInfo) instead.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles\r\n     */\r\n    public pickedParticles: { idx: number; faceId: number }[];\r\n    /**\r\n     * This array is populated when the SPS is set as 'pickable'\r\n     * Each key of this array is a submesh index.\r\n     * Each element of this array is a second array defined like this :\r\n     * Each key of this second array is a `faceId` value that you can get from a pickResult object.\r\n     * Each element of this second array is an object `{idx: int, faceId: int}`.\r\n     * `idx` is the picked particle index in the `SPS.particles` array\r\n     * `faceId` is the picked face index counted within this particle.\r\n     * It's better to use the method SPS.pickedParticle(pickingInfo) rather than using directly this array.\r\n     * Please read : https://doc.babylonjs.com/how_to/Solid_Particle_System#pickable-particles\r\n     */\r\n    public pickedBySubMesh: { idx: number; faceId: number}[][];\r\n    /**\r\n     * This array is populated when `enableDepthSort` is set to true.\r\n     * Each element of this array is an instance of the class DepthSortedParticle.\r\n     */\r\n    public depthSortedParticles: DepthSortedParticle[];\r\n\r\n    /**\r\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereOnly: boolean = false;\r\n    /**\r\n     * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereRadiusFactor: number = 1.0;\r\n\r\n    private _scene: Scene;\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray;           // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array;         // updated positions for the VBO\r\n    private _normals32: Float32Array;           // updated normals for the VBO\r\n    private _fixedNormal32: Float32Array;       // initial normal references\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _index: number = 0;  // indices index\r\n    private _updatable: boolean = true;\r\n    private _pickable: boolean = false;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _depthSort: boolean = false;\r\n    private _expandable: boolean = false;\r\n    private _shapeCounter: number = 0;\r\n    private _copy: SolidParticle = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\r\n    private _color: Color4 = new Color4(0, 0, 0, 0);\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeParticleVertex: boolean = false;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _depthSortParticles: boolean = true;\r\n    private _camera: TargetCamera;\r\n    private _mustUnrotateFixedNormals = false;\r\n    private _particlesIntersect: boolean = false;\r\n    private _needs32Bits: boolean = false;\r\n    private _isNotBuilt: boolean = true;\r\n    private _lastParticleId: number = 0;\r\n    private _idxOfId: number[] = [];            // array : key = particle.id / value = particle.idx\r\n    private _multimaterialEnabled: boolean = false;\r\n    private _useModelMaterial: boolean = false;\r\n    private _indicesByMaterial: number[];\r\n    private _materialIndexes: number[];\r\n    private _depthSortFunction = (p1: DepthSortedParticle, p2: DepthSortedParticle) => p2.sqDistance - p1.sqDistance;\r\n    private _materialSortFunction = (p1: DepthSortedParticle, p2: DepthSortedParticle) => p1.materialIndex - p2.materialIndex;\r\n    private _materials: Material[];\r\n    private _multimaterial: MultiMaterial;\r\n    private _materialIndexesById: any;\r\n    private _defaultMaterial: Material;\r\n    private _autoUpdateSubMeshes: boolean = false;\r\n    private _tmpVertex: SolidParticleVertex;\r\n\r\n    /**\r\n     * Creates a SPS (Solid Particle System) object.\r\n     * @param name (String) is the SPS name, this will be the underlying mesh name.\r\n     * @param scene (Scene) is the scene in which the SPS is added.\r\n     * @param options defines the options of the sps e.g.\r\n     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\r\n     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\r\n     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\r\n     * * useModelMaterial (optional boolean, defaut false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\r\n     * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\r\n     * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\r\n     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\r\n     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\r\n     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.\r\n     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\r\n     */\r\n    constructor(name: string, scene: Scene, options?: { updatable?: boolean; isPickable?: boolean; enableDepthSort?: boolean; particleIntersection?: boolean; boundingSphereOnly?: boolean; bSphereRadiusFactor?: number; expandable?: boolean; useModelMaterial?: boolean; enableMultiMaterial?: boolean; }) {\r\n\r\n        this.name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._camera = <TargetCamera>scene.activeCamera;\r\n        this._pickable = options ? <boolean>options.isPickable : false;\r\n        this._depthSort = options ? <boolean>options.enableDepthSort : false;\r\n        this._multimaterialEnabled = options ? <boolean>options.enableMultiMaterial : false;\r\n        this._useModelMaterial = options ? <boolean>options.useModelMaterial : false;\r\n        this._multimaterialEnabled = (this._useModelMaterial) ? true : this._multimaterialEnabled;\r\n        this._expandable = options ? <boolean>options.expandable : false;\r\n        this._particlesIntersect = options ? <boolean>options.particleIntersection : false;\r\n        this._bSphereOnly = options ? <boolean>options.boundingSphereOnly : false;\r\n        this._bSphereRadiusFactor = (options && options.bSphereRadiusFactor) ? options.bSphereRadiusFactor : 1.0;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n        if (this._pickable) {\r\n            this.pickedBySubMesh = [[]];\r\n            this.pickedParticles = this.pickedBySubMesh[0];\r\n        }\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            this.depthSortedParticles = [];\r\n        }\r\n        if (this._multimaterialEnabled) {\r\n            this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\r\n            this._materials = [];\r\n            this._materialIndexesById = {};\r\n        }\r\n        this._tmpVertex = new SolidParticleVertex();\r\n    }\r\n\r\n    /**\r\n     * Builds the SPS underlying mesh. Returns a standard Mesh.\r\n     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\r\n     * @returns the created mesh\r\n     */\r\n    public buildMesh(): Mesh {\r\n        if (!this._isNotBuilt && this.mesh) {\r\n            return this.mesh;\r\n        }\r\n        if (this.nbParticles === 0 && !this.mesh) {\r\n            var triangle = DiscBuilder.CreateDisc(\"\", { radius: 1, tessellation: 3 }, this._scene);\r\n            this.addShape(triangle, 1);\r\n            triangle.dispose();\r\n        }\r\n        this._indices32 = (this._needs32Bits) ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        if (!this.mesh) {       // in case it's already expanded\r\n            var mesh = new Mesh(this.name, this._scene);\r\n            this.mesh = mesh;\r\n        }\r\n        if (!this._updatable && this._multimaterialEnabled) {\r\n            this._sortParticlesByMaterial();    // this may reorder the indices32\r\n        }\r\n        if (this.recomputeNormals) {\r\n            VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\r\n        }\r\n\r\n        this._normals32 = new Float32Array(this._normals);\r\n        this._fixedNormal32 = new Float32Array(this._normals);\r\n        if (this._mustUnrotateFixedNormals) {  // the particles could be created already rotated in the mesh with a positionFunction\r\n            this._unrotateFixedNormals();\r\n        }\r\n        var vertexData = new VertexData();\r\n        vertexData.indices = (this._depthSort) ? this._indices : this._indices32;\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n        vertexData.set(this._normals32, VertexBuffer.NormalKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        if (this._colors32.length > 0) {\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n\r\n        vertexData.applyToMesh(this.mesh, this._updatable);\r\n        this.mesh.isPickable = this._pickable;\r\n\r\n        if (this._pickable) {\r\n            let faceId = 0;\r\n            for (let p = 0; p < this.nbParticles; p++) {\r\n                let part = this.particles[p];\r\n                let lind = part._model._indicesLength;\r\n                for (let i = 0; i < lind; i++) {\r\n                    let f = i % 3;\r\n                    if (f == 0) {\r\n                        const pickedData = {idx: part.idx, faceId: faceId};\r\n                        this.pickedParticles[faceId] = pickedData;\r\n                        faceId++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._multimaterialEnabled) {\r\n            this.setMultiMaterial(this._materials);\r\n        }\r\n\r\n        if (!this._expandable) {\r\n            // free memory\r\n            if (!this._depthSort && !this._multimaterialEnabled) {\r\n                (<any>this._indices) = null;\r\n            }\r\n            (<any>this._positions) = null;\r\n            (<any>this._normals) = null;\r\n            (<any>this._uvs) = null;\r\n            (<any>this._colors) = null;\r\n\r\n            if (!this._updatable) {\r\n                this.particles.length = 0;\r\n            }\r\n        }\r\n        this._isNotBuilt = false;\r\n        this.recomputeNormals = false;\r\n        return this.mesh;\r\n    }\r\n\r\n    /**\r\n     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\r\n     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\r\n     * Thus the particles generated from `digest()` have their property `position` set yet.\r\n     * @param mesh ( Mesh ) is the mesh to be digested\r\n     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any\r\n     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\r\n     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\r\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n     * @returns the current SPS\r\n     */\r\n    public digest(mesh: Mesh, options?: { facetNb?: number; number?: number; delta?: number; storage?: [] }): SolidParticleSystem {\r\n        var size: number = (options && options.facetNb) || 1;\r\n        var number: number = (options && options.number) || 0;\r\n        var delta: number = (options && options.delta) || 0;\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n        var meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        var meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        var meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        var storage = (options && options.storage) ? options.storage : null;\r\n\r\n        var f: number = 0;                              // facet counter\r\n        var totalFacets: number = meshInd.length / 3;   // a facet is a triangle, so 3 indices\r\n        // compute size from number\r\n        if (number) {\r\n            number = (number > totalFacets) ? totalFacets : number;\r\n            size = Math.round(totalFacets / number);\r\n            delta = 0;\r\n        } else {\r\n            size = (size > totalFacets) ? totalFacets : size;\r\n        }\r\n\r\n        var facetPos: number[] = [];      // submesh positions\r\n        var facetNor: number[] = [];\r\n        var facetInd: number[] = [];      // submesh indices\r\n        var facetUV: number[] = [];       // submesh UV\r\n        var facetCol: number[] = [];      // submesh colors\r\n        var barycenter: Vector3 = Vector3.Zero();\r\n        var sizeO: number = size;\r\n\r\n        while (f < totalFacets) {\r\n            size = sizeO + Math.floor((1 + delta) * Math.random());\r\n            if (f > totalFacets - size) {\r\n                size = totalFacets - f;\r\n            }\r\n            // reset temp arrays\r\n            facetPos.length = 0;\r\n            facetNor.length = 0;\r\n            facetInd.length = 0;\r\n            facetUV.length = 0;\r\n            facetCol.length = 0;\r\n\r\n            // iterate over \"size\" facets\r\n            var fi: number = 0;\r\n            for (var j = f * 3; j < (f + size) * 3; j++) {\r\n                facetInd.push(fi);\r\n                var i: number = meshInd[j];\r\n                var i3: number = i * 3;\r\n                facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\r\n                facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\r\n                if (meshUV) {\r\n                    var i2: number = i * 2;\r\n                    facetUV.push(meshUV[i2], meshUV[i2 + 1]);\r\n                }\r\n                if (meshCol) {\r\n                    var i4: number = i * 4;\r\n                    facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\r\n                }\r\n                fi++;\r\n            }\r\n\r\n            // create a model shape for each single particle\r\n            var idx: number = this.nbParticles;\r\n            var shape: Vector3[] = this._posToShape(facetPos);\r\n            var shapeUV: number[] = this._uvsToShapeUV(facetUV);\r\n            var shapeInd = Tools.Slice(facetInd);\r\n            var shapeCol = Tools.Slice(facetCol);\r\n            var shapeNor = Tools.Slice(facetNor);\r\n\r\n            // compute the barycenter of the shape\r\n            barycenter.copyFromFloats(0, 0, 0);\r\n            var v: number;\r\n            for (v = 0; v < shape.length; v++) {\r\n                barycenter.addInPlace(shape[v]);\r\n            }\r\n            barycenter.scaleInPlace(1 / shape.length);\r\n\r\n            // shift the shape from its barycenter to the origin\r\n            // and compute the BBox required for intersection.\r\n            var minimum: Vector3 = new Vector3(Infinity, Infinity, Infinity);\r\n            var maximum: Vector3 = new Vector3(-Infinity, -Infinity, -Infinity);\r\n            for (v = 0; v < shape.length; v++) {\r\n                shape[v].subtractInPlace(barycenter);\r\n                minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\r\n                maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\r\n            }\r\n            var bInfo;\r\n            if (this._particlesIntersect) {\r\n                bInfo = new BoundingInfo(minimum, maximum);\r\n            }\r\n            var material = null;\r\n            if (this._useModelMaterial) {\r\n                material = (mesh.material) ? mesh.material : this._setDefaultMaterial();\r\n            }\r\n            var modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);\r\n\r\n            // add the particle in the SPS\r\n            var currentPos = this._positions.length;\r\n            var currentInd = this._indices.length;\r\n            this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\r\n            this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);\r\n            // initialize the particle position\r\n            this.particles[this.nbParticles].position.addInPlace(barycenter);\r\n\r\n            if (!storage) {\r\n                this._index += shape.length;\r\n                idx++;\r\n                this.nbParticles++;\r\n                this._lastParticleId++;\r\n            }\r\n            this._shapeCounter++;\r\n            f += size;\r\n        }\r\n        this._isNotBuilt = true;        // buildMesh() is now expected for setParticles() to work\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\r\n     * @hidden\r\n     */\r\n    private _unrotateFixedNormals() {\r\n        var index = 0;\r\n        var idx = 0;\r\n        const tmpNormal = TmpVectors.Vector3[0];\r\n        const quaternion = TmpVectors.Quaternion[0];\r\n        const invertedRotMatrix = TmpVectors.Matrix[0];\r\n        for (var p = 0; p < this.particles.length; p++) {\r\n            const particle = this.particles[p];\r\n            const shape = particle._model._shape;\r\n\r\n            // computing the inverse of the rotation matrix from the quaternion\r\n            // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\r\n            if (particle.rotationQuaternion) {\r\n                particle.rotationQuaternion.conjugateToRef(quaternion);\r\n            }\r\n            else {\r\n                const rotation = particle.rotation;\r\n                Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n                quaternion.conjugateInPlace();\r\n            }\r\n            quaternion.toRotationMatrix(invertedRotMatrix);\r\n\r\n            for (var pt = 0; pt < shape.length; pt++) {\r\n                idx = index + pt * 3;\r\n                Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\r\n                tmpNormal.toArray(this._fixedNormal32, idx);\r\n            }\r\n            index = idx + 3;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the temporary working copy particle\r\n     * @hidden\r\n     */\r\n    private _resetCopy() {\r\n        const copy = this._copy;\r\n        copy.position.setAll(0);\r\n        copy.rotation.setAll(0);\r\n        copy.rotationQuaternion = null;\r\n        copy.scaling.setAll(1);\r\n        copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\r\n        copy.color = null;\r\n        copy.translateFromPivot = false;\r\n        copy.shapeId = 0;\r\n        copy.materialIndex = null;\r\n    }\r\n\r\n    /**\r\n     * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\r\n     * @param p the current index in the positions array to be updated\r\n     * @param ind the current index in the indices array\r\n     * @param shape a Vector3 array, the shape geometry\r\n     * @param positions the positions array to be updated\r\n     * @param meshInd the shape indices array\r\n     * @param indices the indices array to be updated\r\n     * @param meshUV the shape uv array\r\n     * @param uvs the uv array to be updated\r\n     * @param meshCol the shape color array\r\n     * @param colors the color array to be updated\r\n     * @param meshNor the shape normals array\r\n     * @param normals the normals array to be updated\r\n     * @param idx the particle index\r\n     * @param idxInShape the particle index in its shape\r\n     * @param options the addShape() method  passed options\r\n     * @model the particle model\r\n     * @hidden\r\n     */\r\n    private _meshBuilder(p: number, ind: number, shape: Vector3[], positions: number[], meshInd: IndicesArray, indices: number[], meshUV: number[] | Float32Array, uvs: number[], meshCol: number[] | Float32Array, colors: number[], meshNor: number[] | Float32Array, normals: number[], idx: number, idxInShape: number, options: any, model: ModelShape): SolidParticle {\r\n        var i;\r\n        var u = 0;\r\n        var c = 0;\r\n        var n = 0;\r\n\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        const storeApart = (options && options.storage) ? true : false;\r\n        copy.idx = idx;\r\n        copy.idxInShape = idxInShape;\r\n        copy.shapeId = model.shapeID;\r\n        if (this._useModelMaterial) {\r\n            var materialId = model._material!.uniqueId;\r\n            const materialIndexesById = this._materialIndexesById;\r\n            if (!materialIndexesById.hasOwnProperty(materialId)) {\r\n                materialIndexesById[materialId] = this._materials.length;\r\n                this._materials.push(model._material!);\r\n            }\r\n            var matIdx = materialIndexesById[materialId];\r\n            copy.materialIndex = matIdx;\r\n        }\r\n\r\n        if (options && options.positionFunction) {        // call to custom positionFunction\r\n            options.positionFunction(copy, idx, idxInShape);\r\n            this._mustUnrotateFixedNormals = true;\r\n        }\r\n\r\n        // in case the particle geometry must NOT be inserted in the SPS mesh geometry\r\n        if (storeApart) {\r\n            return copy;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const tmpVertex = this._tmpVertex;\r\n        const tmpVector = tmpVertex.position;\r\n        const tmpColor = tmpVertex.color;\r\n        const tmpUV = tmpVertex.uv;\r\n        const tmpRotated = TmpVectors.Vector3[1];\r\n        const pivotBackTranslation = TmpVectors.Vector3[2];\r\n        const scaledPivot = TmpVectors.Vector3[3];\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.setAll(0.0);\r\n        }\r\n        else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        var someVertexFunction = (options && options.vertexFunction);\r\n        for (i = 0; i < shape.length; i++) {\r\n            tmpVector.copyFrom(shape[i]);\r\n            if (copy.color) {\r\n                tmpColor.copyFrom(copy.color);\r\n            }\r\n            if (meshUV) {\r\n                tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\r\n            }\r\n            if (someVertexFunction) {\r\n                options.vertexFunction(copy, tmpVertex, i);\r\n            }\r\n\r\n            tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\r\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\r\n            positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\r\n\r\n            if (meshUV) {\r\n                const copyUvs = copy.uvs;\r\n                uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\r\n                u += 2;\r\n            }\r\n\r\n            if (copy.color) {\r\n                this._color.copyFrom(tmpColor);\r\n            } else {\r\n                const color = this._color;\r\n                if (meshCol && meshCol[c] !== undefined) {\r\n                    color.r = meshCol[c];\r\n                    color.g = meshCol[c + 1];\r\n                    color.b = meshCol[c + 2];\r\n                    color.a = meshCol[c + 3];\r\n                } else {\r\n                    color.r = 1.0;\r\n                    color.g = 1.0;\r\n                    color.b = 1.0;\r\n                    color.a = 1.0;\r\n                }\r\n            }\r\n            colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\r\n            c += 4;\r\n\r\n            if (!this.recomputeNormals && meshNor) {\r\n                Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\r\n                normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\r\n                n += 3;\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < meshInd.length; i++) {\r\n            var current_ind = p + meshInd[i];\r\n            indices.push(current_ind);\r\n            if (current_ind > 65535) {\r\n                this._needs32Bits = true;\r\n            }\r\n        }\r\n\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            var matIndex = (copy.materialIndex !== null) ? copy.materialIndex : 0;\r\n            this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Returns a shape Vector3 array from positions float array\r\n     * @param positions float array\r\n     * @returns a vector3 array\r\n     * @hidden\r\n     */\r\n    private _posToShape(positions: number[] | Float32Array): Vector3[] {\r\n        var shape = [];\r\n        for (var i = 0; i < positions.length; i += 3) {\r\n            shape.push(Vector3.FromArray(positions, i));\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    /**\r\n     * Returns a shapeUV array from a float uvs (array deep copy)\r\n     * @param uvs as a float array\r\n     * @returns a shapeUV array\r\n     * @hidden\r\n     */\r\n    private _uvsToShapeUV(uvs: number[] | Float32Array): number[] {\r\n        var shapeUV = [];\r\n        if (uvs) {\r\n            for (var i = 0; i < uvs.length; i++) {\r\n                shapeUV.push(uvs[i]);\r\n            }\r\n        }\r\n        return shapeUV;\r\n    }\r\n\r\n    /**\r\n     * Adds a new particle object in the particles array\r\n     * @param idx particle index in particles array\r\n     * @param id particle id\r\n     * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\r\n     * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\r\n     * @param model particle ModelShape object\r\n     * @param shapeId model shape identifier\r\n     * @param idxInShape index of the particle in the current model\r\n     * @param bInfo model bounding info object\r\n     * @param storage target storage array, if any\r\n     * @hidden\r\n     */\r\n    private _addParticle(idx: number, id: number, idxpos: number, idxind: number, model: ModelShape, shapeId: number, idxInShape: number, bInfo: Nullable<BoundingInfo> = null, storage: Nullable<[]> = null): SolidParticle {\r\n        var sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\r\n        var target = (storage) ? storage : this.particles;\r\n        target.push(sp);\r\n        return sp;\r\n    }\r\n\r\n    /**\r\n     * Adds some particles to the SPS from the model shape. Returns the shape id.\r\n     * Please read the doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#create-an-immutable-sps\r\n     * @param mesh is any Mesh object that will be used as a model for the solid particles.\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\r\n     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\r\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\r\n     * @returns the number of shapes in the system\r\n     */\r\n    public addShape(mesh: Mesh, nb: number, options?: { positionFunction?: any; vertexFunction?: any; storage?: [] }): number {\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n        var meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        var meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        var meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        this.recomputeNormals = (meshNor) ? false : true;\r\n        var indices = Tools.SliceToArray<IndicesArray, number>(meshInd);\r\n        var shapeNormals = Tools.SliceToArray<number[] | Float32Array, number>(meshNor);\r\n        var shapeColors = (meshCol) ? Tools.SliceToArray<number[] | Float32Array, number>(meshCol) : [];\r\n        var storage = (options && options.storage) ? options.storage : null;\r\n        var bbInfo: Nullable<BoundingInfo> = null;\r\n        if (this._particlesIntersect) {\r\n            bbInfo = mesh.getBoundingInfo();\r\n        }\r\n\r\n        var shape = this._posToShape(meshPos);\r\n        var shapeUV = this._uvsToShapeUV(meshUV);\r\n\r\n        var posfunc = options ? options.positionFunction : null;\r\n        var vtxfunc = options ? options.vertexFunction : null;\r\n        var material = null;\r\n        if (this._useModelMaterial) {\r\n            material = (mesh.material) ? mesh.material : this._setDefaultMaterial();\r\n        }\r\n        var modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);\r\n\r\n        // particles\r\n        for (var i = 0; i < nb; i++) {\r\n            this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\r\n        }\r\n        this._shapeCounter++;\r\n        this._isNotBuilt = true;        // buildMesh() call is now expected for setParticles() to work\r\n        return this._shapeCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\r\n     * @hidden\r\n     */\r\n    private _rebuildParticle(particle: SolidParticle, reset: boolean = false): void {\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        if (particle._model._positionFunction) {        // recall to stored custom positionFunction\r\n            particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const tmpVertex = TmpVectors.Vector3[0];\r\n        const tmpRotated = TmpVectors.Vector3[1];\r\n        const pivotBackTranslation = TmpVectors.Vector3[2];\r\n        const scaledPivot = TmpVectors.Vector3[3];\r\n\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\r\n        }\r\n        else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        const shape = particle._model._shape;\r\n\r\n        for (var pt = 0; pt < shape.length; pt++) {\r\n            tmpVertex.copyFrom(shape[pt]);\r\n            if (particle._model._vertexFunction) {\r\n                particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\r\n            }\r\n\r\n            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\r\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\r\n        }\r\n        if (reset) {\r\n            particle.position.setAll(0.0);\r\n            particle.rotation.setAll(0.0);\r\n            particle.rotationQuaternion = null;\r\n            particle.scaling.setAll(1.0);\r\n            particle.uvs.setAll(0.0);\r\n            particle.pivot.setAll(0.0);\r\n            particle.translateFromPivot = false;\r\n            particle.parentId = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\r\n     * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\r\n     * @returns the SPS.\r\n     */\r\n    public rebuildMesh(reset: boolean = false): SolidParticleSystem {\r\n        for (var p = 0; p < this.particles.length; p++) {\r\n            this._rebuildParticle(this.particles[p], reset);\r\n        }\r\n        this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\r\n        return this;\r\n    }\r\n\r\n    /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\r\n     *  Returns an array with the removed particles.\r\n     *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\r\n     *  The SPS can't be empty so at least one particle needs to remain in place.\r\n     *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\r\n     * @param start index of the first particle to remove\r\n     * @param end index of the last particle to remove (included)\r\n     * @returns an array populated with the removed particles\r\n     */\r\n    public removeParticles(start: number, end: number): SolidParticle[] {\r\n        var nb = end - start + 1;\r\n        if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\r\n            return [];\r\n        }\r\n        const particles = this.particles;\r\n        const currentNb = this.nbParticles;\r\n        if (end < currentNb - 1) {              // update the particle indexes in the positions array in case they're remaining particles after the last removed\r\n            var firstRemaining = end + 1;\r\n            var shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\r\n            var shifInd = particles[firstRemaining]._ind - particles[start]._ind;\r\n            for (var i = firstRemaining; i < currentNb; i++) {\r\n                var part = particles[i];\r\n                part._pos -= shiftPos;\r\n                part._ind -= shifInd;\r\n            }\r\n        }\r\n        var removed = particles.splice(start, nb);\r\n        this._positions.length = 0;\r\n        this._indices.length = 0;\r\n        this._colors.length = 0;\r\n        this._uvs.length = 0;\r\n        this._normals.length = 0;\r\n        this._index = 0;\r\n        this._idxOfId.length = 0;\r\n        if (this._depthSort || this._multimaterialEnabled) {\r\n            this.depthSortedParticles = [];\r\n        }\r\n        var ind = 0;\r\n        const particlesLength = particles.length;\r\n        for (var p = 0; p < particlesLength; p++) {\r\n            var particle = particles[p];\r\n            var model = particle._model;\r\n            var shape = model._shape;\r\n            var modelIndices = model._indices;\r\n            var modelNormals = model._normals;\r\n            var modelColors = model._shapeColors;\r\n            var modelUVs = model._shapeUV;\r\n            particle.idx = p;\r\n            this._idxOfId[particle.id] = p;\r\n            this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\r\n            this._index += shape.length;\r\n            ind += modelIndices.length;\r\n        }\r\n        this.nbParticles -= nb;\r\n        this._isNotBuilt = true;        // buildMesh() call is now expected for setParticles() to work\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\r\n     * @param solidParticleArray an array populated with Solid Particles objects\r\n     * @returns the SPS\r\n     */\r\n    public insertParticlesFromArray(solidParticleArray: SolidParticle[]): SolidParticleSystem {\r\n        if (!this._expandable) {\r\n            return this;\r\n        }\r\n        var idxInShape = 0;\r\n        var  currentShapeId = solidParticleArray[0].shapeId;\r\n        const nb = solidParticleArray.length;\r\n        for (var i = 0; i < nb; i++) {\r\n            var sp = solidParticleArray[i];\r\n            var model = sp._model;\r\n            var shape = model._shape;\r\n            var meshInd = model._indices;\r\n            var meshUV = model._shapeUV;\r\n            var meshCol = model._shapeColors;\r\n            var meshNor = model._normals;\r\n            var noNor = (meshNor) ? false : true;\r\n            this.recomputeNormals = (noNor || this.recomputeNormals);\r\n            var bbInfo = sp._boundingInfo;\r\n            var newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\r\n            sp.copyToRef(newPart!);\r\n            idxInShape++;\r\n            if (currentShapeId != sp.shapeId) {\r\n                currentShapeId = sp.shapeId;\r\n                idxInShape = 0;\r\n            }\r\n        }\r\n        this._isNotBuilt = true;        // buildMesh() call is now expected for setParticles() to work\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new particle and modifies the SPS mesh geometry :\r\n     * - calls _meshBuilder() to increase the SPS mesh geometry step by step\r\n     * - calls _addParticle() to populate the particle array\r\n     * factorized code from addShape() and insertParticlesFromArray()\r\n     * @param idx particle index in the particles array\r\n     * @param i particle index in its shape\r\n     * @param modelShape particle ModelShape object\r\n     * @param shape shape vertex array\r\n     * @param meshInd shape indices array\r\n     * @param meshUV shape uv array\r\n     * @param meshCol shape color array\r\n     * @param meshNor shape normals array\r\n     * @param bbInfo shape bounding info\r\n     * @param storage target particle storage\r\n     * @options addShape() passed options\r\n     * @hidden\r\n     */\r\n    private _insertNewParticle(idx: number, i: number, modelShape: ModelShape, shape: Vector3[], meshInd: IndicesArray, meshUV: number[] | Float32Array, meshCol: number[] | Float32Array, meshNor: number[] | Float32Array, bbInfo: Nullable<BoundingInfo>, storage: Nullable<[]> , options: any): Nullable<SolidParticle> {\r\n        var currentPos = this._positions.length;\r\n        var currentInd = this._indices.length;\r\n        var currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\r\n        var sp: Nullable<SolidParticle> = null;\r\n        if (this._updatable) {\r\n            sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\r\n            sp.position.copyFrom(currentCopy.position);\r\n            sp.rotation.copyFrom(currentCopy.rotation);\r\n            if (currentCopy.rotationQuaternion) {\r\n                if (sp.rotationQuaternion) {\r\n                    sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\r\n                }\r\n                else {\r\n                    sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\r\n                }\r\n            }\r\n            if (currentCopy.color) {\r\n                if (sp.color) {\r\n                    sp.color.copyFrom(currentCopy.color);\r\n                }\r\n                else {\r\n                    sp.color = currentCopy.color.clone();\r\n                }\r\n            }\r\n            sp.scaling.copyFrom(currentCopy.scaling);\r\n            sp.uvs.copyFrom(currentCopy.uvs);\r\n            if (currentCopy.materialIndex !== null) {\r\n                sp.materialIndex = currentCopy.materialIndex;\r\n            }\r\n            if (this.expandable) {\r\n                this._idxOfId[sp.id] = sp.idx;\r\n            }\r\n        }\r\n        if (!storage) {\r\n            this._index += shape.length;\r\n            this.nbParticles++;\r\n            this._lastParticleId++;\r\n        }\r\n        return sp;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the SPS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): SolidParticleSystem {\r\n        if (!this._updatable || this._isNotBuilt) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const invertedMatrix = TmpVectors.Matrix[1];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const normals32 = this._normals32;\r\n        const uvs32 = this._uvs32;\r\n        const indices32 = this._indices32;\r\n        const indices = this._indices;\r\n        const fixedNormal32 = this._fixedNormal32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n        const camInvertedPosition = tempVectors[10].setAll(0);\r\n\r\n        const tmpVertex = this._tmpVertex;\r\n        const tmpVector = tmpVertex.position;\r\n        const tmpColor = tmpVertex.color;\r\n        const tmpUV = tmpVertex.uv;\r\n\r\n        // cases when the World Matrix is to be computed first\r\n        if (this.billboard || this._depthSort) {\r\n            this.mesh.computeWorldMatrix(true);\r\n            this.mesh._worldMatrix.invertToRef(invertedMatrix);\r\n        }\r\n        // if the particles will always face the camera\r\n        if (this.billboard) {\r\n            // compute the camera position and un-rotate it by the current mesh rotation\r\n            const tmpVector0 = tempVectors[0];\r\n            this._camera.getDirectionToRef(Axis.Z, tmpVector0);\r\n            Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\r\n            camAxisZ.normalize();\r\n            // same for camera up vector extracted from the cam view matrix\r\n            var view = this._camera.getViewMatrix(true);\r\n            Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\r\n            Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\r\n            camAxisY.normalize();\r\n            camAxisX.normalize();\r\n        }\r\n\r\n        // if depthSort, compute the camera global position in the mesh local system\r\n        if (this._depthSort) {\r\n            Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\r\n        }\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        var idx = 0;            // current position index in the global array positions32\r\n        var index = 0;          // position start index in the global array positions32 of the current particle\r\n        var colidx = 0;         // current color index in the global array colors32\r\n        var colorIndex = 0;     // color start index in the global array colors32 of the current particle\r\n        var uvidx = 0;          // current uv index in the global array uvs32\r\n        var uvIndex = 0;        // uv start index in the global array uvs32 of the current particle\r\n        var pt = 0;             // current index in the particle model shape\r\n\r\n        if (this.mesh.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = (end >= this.nbParticles) ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) { // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh._boundingInfo;\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        // particle loop\r\n        index = this.particles[start]._pos;\r\n        const vpos = (index / 3) | 0;\r\n        colorIndex = vpos * 4;\r\n        uvIndex = vpos * 2;\r\n\r\n        for (var p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const shape = particle._model._shape;\r\n            const shapeUV = particle._model._shapeUV;\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleRotation = particle.rotation;\r\n            const particleScaling = particle.scaling;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            // camera-particle distance for depth sorting\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                var dsp = this.depthSortedParticles[p];\r\n                dsp.idx = particle.idx;\r\n                dsp.ind = particle._ind;\r\n                dsp.indicesLength = particle._model._indicesLength;\r\n                dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\r\n            }\r\n\r\n            // skip the computations for inactive or already invisible particles\r\n            if (!particle.alive || (particle._stillInvisible && !particle.isVisible)) {\r\n                // increment indexes for the next particle\r\n                pt = shape.length;\r\n                index += pt * 3;\r\n                colorIndex += pt * 4;\r\n                uvIndex += pt * 2;\r\n                continue;\r\n            }\r\n\r\n            if (particle.isVisible) {\r\n                particle._stillInvisible = false; // un-mark permanent invisibility\r\n\r\n                const scaledPivot = tempVectors[12];\r\n                particle.pivot.multiplyToRef(particleScaling, scaledPivot);\r\n\r\n                // particle rotation matrix\r\n                if (this.billboard) {\r\n                    particleRotation.x = 0.0;\r\n                    particleRotation.y = 0.0;\r\n                }\r\n                if (this._computeParticleRotation || this.billboard) {\r\n                    particle.getRotationMatrix(rotMatrix);\r\n                }\r\n\r\n                const particleHasParent = (particle.parentId !== null);\r\n                if (particleHasParent) {\r\n                    const parent = this.getParticleById(particle.parentId!);\r\n                    if (parent) {\r\n                        const parentRotationMatrix = parent._rotationMatrix;\r\n                        const parentGlobalPosition = parent._globalPosition;\r\n\r\n                        const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                        const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                        const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                        if (this._computeParticleRotation || this.billboard) {\r\n                            const rotMatrixValues = rotMatrix.m;\r\n                            particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                            particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                            particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                            particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                            particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                        }\r\n                    }\r\n                    else {      // in case the parent were removed at some moment\r\n                        particle.parentId = null;\r\n                    }\r\n                }\r\n                else {\r\n                    particleGlobalPosition.x = particlePosition.x;\r\n                    particleGlobalPosition.y = particlePosition.y;\r\n                    particleGlobalPosition.z = particlePosition.z;\r\n\r\n                    if (this._computeParticleRotation || this.billboard) {\r\n                        const rotMatrixValues = rotMatrix.m;\r\n                        particleRotationMatrix[0] = rotMatrixValues[0];\r\n                        particleRotationMatrix[1] = rotMatrixValues[1];\r\n                        particleRotationMatrix[2] = rotMatrixValues[2];\r\n                        particleRotationMatrix[3] = rotMatrixValues[4];\r\n                        particleRotationMatrix[4] = rotMatrixValues[5];\r\n                        particleRotationMatrix[5] = rotMatrixValues[6];\r\n                        particleRotationMatrix[6] = rotMatrixValues[8];\r\n                        particleRotationMatrix[7] = rotMatrixValues[9];\r\n                        particleRotationMatrix[8] = rotMatrixValues[10];\r\n                    }\r\n                }\r\n\r\n                const pivotBackTranslation = tempVectors[11];\r\n                if (particle.translateFromPivot) {\r\n                    pivotBackTranslation.setAll(0.0);\r\n                }\r\n                else {\r\n                    pivotBackTranslation.copyFrom(scaledPivot);\r\n                }\r\n\r\n                // particle vertex loop\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n                    const iu  = 2 * pt;\r\n                    const iv = iu + 1;\r\n\r\n                    tmpVector.copyFrom(shape[pt]);\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        tmpColor.copyFrom(particle.color);\r\n                    }\r\n                    if (this._computeParticleTexture) {\r\n                        tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\r\n                    }\r\n                    if (this._computeParticleVertex) {\r\n                        this.updateParticleVertex(particle, tmpVertex, pt);\r\n                    }\r\n\r\n                    // positions\r\n                    const vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\r\n                    const vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\r\n                    const vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\r\n\r\n                    let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n                    let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n                    let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n                    rotatedX += pivotBackTranslation.x;\r\n                    rotatedY += pivotBackTranslation.y;\r\n                    rotatedZ += pivotBackTranslation.z;\r\n\r\n                    const px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n                    const py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n                    const pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n\r\n                    if (this._computeBoundingBox) {\r\n                        minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                        maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n                    }\r\n\r\n                    // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\r\n                    if (!this._computeParticleVertex) {\r\n                        const normalx = fixedNormal32[idx];\r\n                        const normaly = fixedNormal32[idx + 1];\r\n                        const normalz = fixedNormal32[idx + 2];\r\n\r\n                        const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\r\n                        const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\r\n                        const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\r\n\r\n                        normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\r\n                        normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\r\n                        normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\r\n                    }\r\n\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const colors32 = this._colors32;\r\n                        colors32[colidx] = tmpColor.r;\r\n                        colors32[colidx + 1] = tmpColor.g;\r\n                        colors32[colidx + 2] = tmpColor.b;\r\n                        colors32[colidx + 3] = tmpColor.a;\r\n                    }\r\n\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n            // particle just set invisible : scaled to zero and positioned at the origin\r\n            else {\r\n                particle._stillInvisible = true;      // mark the particle as invisible\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n\r\n                    positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\r\n                    normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const color = particle.color;\r\n                        colors32[colidx] = color.r;\r\n                        colors32[colidx + 1] = color.g;\r\n                        colors32[colidx + 2] = color.b;\r\n                        colors32[colidx + 3] = color.a;\r\n                    }\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if the particle intersections must be computed : update the bbInfo\r\n            if (this._particlesIntersect) {\r\n                const bInfo = particle._boundingInfo;\r\n                const bBox = bInfo.boundingBox;\r\n                const bSphere = bInfo.boundingSphere;\r\n                const modelBoundingInfo = particle._modelBoundingInfo;\r\n                if (!this._bSphereOnly) {\r\n                    // place, scale and rotate the particle bbox within the SPS local system, then update it\r\n                    const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\r\n\r\n                    const tempMin = tempVectors[1];\r\n                    const tempMax = tempVectors[2];\r\n                    tempMin.setAll(Number.MAX_VALUE);\r\n                    tempMax.setAll(-Number.MAX_VALUE);\r\n                    for (var b = 0; b < 8; b++) {\r\n                        const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\r\n                        const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\r\n                        const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\r\n                        const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\r\n                        const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\r\n                        const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\r\n                        const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n                        const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n                        const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n                        tempMin.minimizeInPlaceFromFloats(x, y, z);\r\n                        tempMax.maximizeInPlaceFromFloats(x, y, z);\r\n                    }\r\n\r\n                    bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\r\n                }\r\n\r\n                // place and scale the particle bouding sphere in the SPS local system, then update it\r\n                const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\r\n                const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\r\n\r\n                const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\r\n                const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\r\n                const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\r\n                const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\r\n                bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\r\n            }\r\n\r\n            // increment indexes for the next particle\r\n            index = idx + 3;\r\n            colorIndex = colidx + 4;\r\n            uvIndex = uvidx + 2;\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (update) {\r\n            if (this._computeParticleColor) {\r\n                mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n            }\r\n            if (this._computeParticleTexture) {\r\n                mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n            }\r\n            mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\r\n                if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\r\n                    // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\r\n                    var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\r\n                    VertexData.ComputeNormals(positions32, indices32, normals32, params);\r\n                    for (var i = 0; i < normals32.length; i++) {\r\n                        fixedNormal32[i] = normals32[i];\r\n                    }\r\n                }\r\n                if (!mesh.areNormalsFrozen) {\r\n                    mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\r\n                }\r\n            }\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                const depthSortedParticles = this.depthSortedParticles;\r\n                depthSortedParticles.sort(this._depthSortFunction);\r\n                const dspl = depthSortedParticles.length;\r\n                let sid = 0;\r\n                let faceId = 0;\r\n                for (let sorted = 0; sorted < dspl; sorted++) {\r\n                    const sortedParticle = depthSortedParticles[sorted];\r\n                    const lind = sortedParticle.indicesLength;\r\n                    const sind = sortedParticle.ind;\r\n                    for (var i = 0; i < lind; i++) {\r\n                        indices32[sid] = indices[sind + i];\r\n                        sid++;\r\n                        if (this._pickable) {\r\n                            let f = i % 3;\r\n                            if (f == 0) {\r\n                                let pickedData = this.pickedParticles[faceId];\r\n                                pickedData.idx = sortedParticle.idx;\r\n                                pickedData.faceId = faceId;\r\n                                faceId++;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                mesh.updateIndices(indices32);\r\n            }\r\n        }\r\n        if (this._computeBoundingBox) {\r\n            if (mesh._boundingInfo) {\r\n                mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n            else {\r\n                mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n        }\r\n        if (this._autoUpdateSubMeshes) {\r\n            this.computeSubMeshes();\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Disposes the SPS.\r\n    */\r\n    public dispose(): void {\r\n        this.mesh.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._normals32) = null;\r\n        (<any>this._fixedNormal32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n        (<any>this.pickedParticles) = null;\r\n        (<any>this.pickedBySubMesh) = null;\r\n        (<any>this._materials) = null;\r\n        (<any>this._materialIndexes) = null;\r\n        (<any>this._indicesByMaterial) = null;\r\n        (<any>this._idxOfId) = null;\r\n    }\r\n    /** Returns an object {idx: numbern faceId: number} for the picked particle from the passed pickingInfo object.\r\n     * idx is the particle index in the SPS\r\n     * faceId is the picked face index counted within this particle.\r\n     * Returns null if the pickInfo can't identify a picked particle.\r\n     * @param pickingInfo (PickingInfo object)\r\n     * @returns {idx: number, faceId: number} or null\r\n     */\r\n    public pickedParticle(pickingInfo: PickingInfo): Nullable<{idx: number, faceId: number}> {\r\n        if (pickingInfo.hit) {\r\n            const subMesh = pickingInfo.subMeshId;\r\n            const faceId = pickingInfo.faceId;\r\n            const picked = this.pickedBySubMesh;\r\n            if (picked[subMesh] && picked[subMesh][faceId]) {\r\n                return picked[subMesh][faceId];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a SolidParticle object from its identifier : particle.id\r\n     * @param id (integer) the particle Id\r\n     * @returns the searched particle or null if not found in the SPS.\r\n     */\r\n    public getParticleById(id: number): Nullable<SolidParticle> {\r\n        const p = this.particles[id];\r\n        if (p && p.id == id) {\r\n            return p;\r\n        }\r\n        const particles = this.particles;\r\n        const idx = this._idxOfId[id];\r\n        if (idx !== undefined) {\r\n            return particles[idx];\r\n        }\r\n        var i = 0;\r\n        const nb = this.nbParticles;\r\n        while (i < nb) {\r\n            var particle = particles[i];\r\n            if (particle.id == id) {\r\n                return particle;\r\n            }\r\n            i++;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns a new array populated with the particles having the passed shapeId.\r\n     * @param shapeId (integer) the shape identifier\r\n     * @returns a new solid particle array\r\n     */\r\n    public getParticlesByShapeId(shapeId: number): SolidParticle[] {\r\n        var ref: SolidParticle[] = [];\r\n        this.getParticlesByShapeIdToRef(shapeId, ref);\r\n        return ref;\r\n    }\r\n\r\n    /**\r\n     * Populates the passed array \"ref\" with the particles having the passed shapeId.\r\n     * @param shapeId the shape identifier\r\n     * @returns the SPS\r\n     * @param ref\r\n     */\r\n    public getParticlesByShapeIdToRef(shapeId: number, ref: SolidParticle[]): SolidParticleSystem {\r\n        ref.length = 0;\r\n        for (var i = 0; i < this.nbParticles; i++) {\r\n            var p = this.particles[i];\r\n            if (p.shapeId == shapeId) {\r\n                ref.push(p);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Computes the required SubMeshes according the materials assigned to the particles.\r\n     * @returns the solid particle system.\r\n     * Does nothing if called before the SPS mesh is built.\r\n     */\r\n    public computeSubMeshes(): SolidParticleSystem {\r\n        if (!this.mesh || !this._multimaterialEnabled) {\r\n            return this;\r\n        }\r\n        const depthSortedParticles = this.depthSortedParticles;\r\n        if (this.particles.length > 0) {\r\n            for (let p = 0; p < this.particles.length; p++) {\r\n                let part = this.particles[p];\r\n                if (!part.materialIndex) {\r\n                    part.materialIndex = 0;\r\n                }\r\n                let sortedPart = depthSortedParticles[p];\r\n                sortedPart.materialIndex = part.materialIndex;\r\n                sortedPart.ind = part._ind;\r\n                sortedPart.indicesLength = part._model._indicesLength;\r\n                sortedPart.idx = part.idx;\r\n            }\r\n        }\r\n        this._sortParticlesByMaterial();\r\n        const indicesByMaterial = this._indicesByMaterial;\r\n        const materialIndexes = this._materialIndexes;\r\n        const mesh = this.mesh;\r\n        mesh.subMeshes = [];\r\n        const vcount = mesh.getTotalVertices();\r\n        for (let m = 0; m < materialIndexes.length; m++) {\r\n            let start = indicesByMaterial[m];\r\n            let count = indicesByMaterial[m + 1] - start;\r\n            let matIndex = materialIndexes[m];\r\n            new SubMesh(matIndex, 0, vcount, start, count, mesh);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sorts the solid particles by material when MultiMaterial is enabled.\r\n     * Updates the indices32 array.\r\n     * Updates the indicesByMaterial array.\r\n     * Updates the mesh indices array.\r\n     * @returns the SPS\r\n     * @hidden\r\n     */\r\n    private _sortParticlesByMaterial(): SolidParticleSystem {\r\n        const indicesByMaterial = [0];\r\n        this._indicesByMaterial = indicesByMaterial;\r\n        const materialIndexes: number[] = [];\r\n        this._materialIndexes = materialIndexes;\r\n        const depthSortedParticles = this.depthSortedParticles;\r\n        depthSortedParticles.sort(this._materialSortFunction);\r\n        const length = depthSortedParticles.length;\r\n        const indices32 = this._indices32;\r\n        const indices = this._indices;\r\n\r\n        let subMeshIndex = 0;\r\n        let subMeshFaceId = 0;\r\n        let sid = 0;\r\n        let lastMatIndex = depthSortedParticles[0].materialIndex;\r\n        materialIndexes.push(lastMatIndex);\r\n        if (this._pickable) {\r\n            this.pickedBySubMesh = [[]];\r\n            this.pickedParticles = this.pickedBySubMesh[0];\r\n        }\r\n        for (let sorted = 0; sorted < length; sorted++) {\r\n            let sortedPart = depthSortedParticles[sorted];\r\n            let lind = sortedPart.indicesLength;\r\n            let sind = sortedPart.ind;\r\n            if (sortedPart.materialIndex !== lastMatIndex) {\r\n                lastMatIndex = sortedPart.materialIndex;\r\n                indicesByMaterial.push(sid);\r\n                materialIndexes.push(lastMatIndex);\r\n                if (this._pickable) {\r\n                    subMeshIndex++;\r\n                    this.pickedBySubMesh[subMeshIndex] = [];\r\n                    subMeshFaceId = 0;\r\n                }\r\n            }\r\n            let faceId = 0;\r\n            for (let i = 0; i < lind; i++) {\r\n                indices32[sid] = indices[sind + i];\r\n                if (this._pickable) {\r\n                    let f = i % 3;\r\n                    if (f == 0) {\r\n                        let pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\r\n                        if (pickedData) {\r\n                            pickedData.idx = sortedPart.idx;\r\n                            pickedData.faceId = faceId;\r\n                        }\r\n                        else {\r\n                            this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = {idx: sortedPart.idx, faceId: faceId};\r\n                        }\r\n                        subMeshFaceId++;\r\n                        faceId++;\r\n                    }\r\n                }\r\n                sid++;\r\n            }\r\n        }\r\n\r\n        indicesByMaterial.push(indices32.length);   // add the last number to ease the indices start/count values for subMeshes creation\r\n        if (this._updatable) {\r\n            this.mesh.updateIndices(indices32);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the material indexes by id materialIndexesById[id] = materialIndex\r\n     * @hidden\r\n     */\r\n    private _setMaterialIndexesById() {\r\n        this._materialIndexesById = {};\r\n        for (var i = 0; i < this._materials.length; i++) {\r\n            var id = this._materials[i].uniqueId;\r\n            this._materialIndexesById[id] = i;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array with unique values of Materials from the passed array\r\n     * @param array the material array to be checked and filtered\r\n     * @hidden\r\n     */\r\n    private _filterUniqueMaterialId(array: Material[]): Material[] {\r\n        var filtered = array.filter(function(value, index, self) {\r\n            return self.indexOf(value) === index;\r\n        });\r\n        return filtered;\r\n    }\r\n    /**\r\n     * Sets a new Standard Material as _defaultMaterial if not already set.\r\n     * @hidden\r\n     */\r\n    private _setDefaultMaterial(): Material {\r\n        if (!this._defaultMaterial) {\r\n            this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\r\n        }\r\n        return this._defaultMaterial;\r\n    }\r\n    /**\r\n     * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     * @returns the SPS.\r\n     */\r\n    public refreshVisibleSize(): SolidParticleSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the SPS mesh bounding box.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        var vis = size / 2;\r\n        this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS as always visible or not\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isVisibilityBoxLocked(val: boolean) {\r\n        this._isVisibilityBoxLocked = val;\r\n\r\n        let boundingInfo = this.mesh.getBoundingInfo();\r\n\r\n        boundingInfo.isLocked = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isVisibilityBoxLocked(): boolean {\r\n        return this._isVisibilityBoxLocked;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public set computeParticleVertex(val: boolean) {\r\n        this._computeParticleVertex = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public set depthSortParticles(val: boolean) {\r\n        this._depthSortParticles = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public get computeParticleRotation(): boolean {\r\n        return this._computeParticleRotation;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public get computeParticleVertex(): boolean {\r\n        return this._computeParticleVertex;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public get depthSortParticles(): boolean {\r\n        return this._depthSortParticles;\r\n    }\r\n\r\n    /**\r\n     * Gets if the SPS is created as expandable at construction time.\r\n     * Default : `false`\r\n     */\r\n    public get expandable(): boolean {\r\n        return this._expandable;\r\n    }\r\n    /**\r\n     * Gets if the SPS supports the Multi Materials\r\n     */\r\n    public get multimaterialEnabled(): boolean {\r\n        return this._multimaterialEnabled;\r\n    }\r\n    /**\r\n     * Gets if the SPS uses the model materials for its own multimaterial.\r\n     */\r\n    public get useModelMaterial(): boolean {\r\n        return this._useModelMaterial;\r\n    }\r\n    /**\r\n     * The SPS used material array.\r\n    */\r\n    public get materials(): Material[] {\r\n        return this._materials;\r\n    }\r\n    /**\r\n     * Sets the SPS MultiMaterial from the passed materials.\r\n     * Note : the passed array is internally copied and not used then by reference.\r\n     * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\r\n     */\r\n    public setMultiMaterial(materials: Material[]) {\r\n        this._materials = this._filterUniqueMaterialId(materials);\r\n        this._setMaterialIndexesById();\r\n        if (this._multimaterial) {\r\n            this._multimaterial.dispose();\r\n        }\r\n        this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\r\n        for (var m = 0; m < this._materials.length; m++) {\r\n            this._multimaterial.subMaterials.push(this._materials[m]);\r\n        }\r\n        this.computeSubMeshes();\r\n        this.mesh.material = this._multimaterial;\r\n    }\r\n    /**\r\n     * The SPS computed multimaterial object\r\n     */\r\n    public get multimaterial(): MultiMaterial {\r\n        return this._multimaterial;\r\n    }\r\n    public set multimaterial(mm) {\r\n        this._multimaterial = mm;\r\n    }\r\n    /**\r\n     * If the subMeshes must be updated on the next call to setParticles()\r\n     */\r\n    public get autoUpdateSubMeshes(): boolean {\r\n        return this._autoUpdateSubMeshes;\r\n    }\r\n    public set autoUpdateSubMeshes(val: boolean) {\r\n        this._autoUpdateSubMeshes = val;\r\n    }\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by the user to fit his needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     */\r\n    public initParticles(): void {\r\n    }\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#particle-management\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a vertex of a particle : it can be overwritten by the user.\r\n     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\r\n     * @param particle the current particle\r\n     * @param vertex the current vertex of the current particle : a SolidParticleVertex object\r\n     * @param pt the index of the current vertex in the particle shape\r\n     * doc : https://doc.babylonjs.com/how_to/Solid_Particle_System#update-each-particle-shape\r\n     * @example : just set a vertex particle position or color\r\n     * @returns the sps\r\n     */\r\n    public updateParticleVertex(particle: SolidParticle, vertex: SolidParticleVertex, pt: number): SolidParticleSystem {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}