{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { DomManagement } from \"../Misc/domManagement\";\nimport { Logger } from \"../Misc/logger\";\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\n\nvar Effect =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates an effect.\r\n   * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n   * @param baseName Name of the effect.\r\n   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n   * @param samplers List of sampler variables that will be passed to the shader.\r\n   * @param engine Engine to be used to render the effect\r\n   * @param defines Define statements to be added to the shader.\r\n   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n   * @param onCompiled Callback that will be called when the shader is compiled.\r\n   * @param onError Callback that will be called if an error occurs during shader compilation.\r\n   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n   */\n  function Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters) {\n    var _this = this;\n\n    if (samplers === void 0) {\n      samplers = null;\n    }\n\n    if (defines === void 0) {\n      defines = null;\n    }\n\n    if (fallbacks === void 0) {\n      fallbacks = null;\n    }\n\n    if (onCompiled === void 0) {\n      onCompiled = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _a;\n    /**\r\n     * Name of the effect.\r\n     */\n\n\n    this.name = null;\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\n\n    this.defines = \"\";\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\n\n    this.onCompiled = null;\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\n\n    this.onError = null;\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\n\n    this.onBind = null;\n    /**\r\n     * Unique ID of the effect.\r\n     */\n\n    this.uniqueId = 0;\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\n\n    this.onCompileObservable = new Observable();\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\n\n    this.onErrorObservable = new Observable();\n    /** @hidden */\n\n    this._onBindObservable = null;\n    /**\r\n     * @hidden\r\n     * Specifies if the effect was previously ready\r\n     */\n\n    this._wasPreviouslyReady = false;\n    /** @hidden */\n\n    this._bonesComputationForcedToCPU = false;\n    /** @hidden */\n\n    this._multiTarget = false;\n    this._uniformBuffersNames = {};\n    this._samplers = {};\n    this._isReady = false;\n    this._compilationError = \"\";\n    this._allFallbacksProcessed = false;\n    this._uniforms = {};\n    /**\r\n     * Key for the effect.\r\n     * @hidden\r\n     */\n\n    this._key = \"\";\n    this._fallbacks = null;\n    this._vertexSourceCode = \"\";\n    this._fragmentSourceCode = \"\";\n    this._vertexSourceCodeOverride = \"\";\n    this._fragmentSourceCodeOverride = \"\";\n    this._transformFeedbackVaryings = null;\n    this._rawVertexSourceCode = \"\";\n    this._rawFragmentSourceCode = \"\";\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @hidden\r\n     */\n\n    this._pipelineContext = null;\n    this._valueCache = {};\n    this.name = baseName;\n    var processFinalCode = null;\n\n    if (attributesNamesOrOptions.attributes) {\n      var options = attributesNamesOrOptions;\n      this._engine = uniformsNamesOrEngine;\n      this._attributesNames = options.attributes;\n      this._uniformsNames = options.uniformsNames.concat(options.samplers);\n      this._samplerList = options.samplers.slice();\n      this.defines = options.defines;\n      this.onError = options.onError;\n      this.onCompiled = options.onCompiled;\n      this._fallbacks = options.fallbacks;\n      this._indexParameters = options.indexParameters;\n      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\n      this._multiTarget = !!options.multiTarget;\n\n      if (options.uniformBuffersNames) {\n        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\n\n        for (var i = 0; i < options.uniformBuffersNames.length; i++) {\n          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n        }\n      }\n\n      processFinalCode = (_a = options.processFinalCode) !== null && _a !== void 0 ? _a : null;\n    } else {\n      this._engine = engine;\n      this.defines = defines == null ? \"\" : defines;\n      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n      this._samplerList = samplers ? samplers.slice() : [];\n      this._attributesNames = attributesNamesOrOptions;\n      this._uniformBuffersNamesList = [];\n      this.onError = onError;\n      this.onCompiled = onCompiled;\n      this._indexParameters = indexParameters;\n      this._fallbacks = fallbacks;\n    }\n\n    this._attributeLocationByName = {};\n    this.uniqueId = Effect._uniqueIdSeed++;\n    var vertexSource;\n    var fragmentSource;\n    var hostDocument = DomManagement.IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n\n    if (baseName.vertexSource) {\n      vertexSource = \"source:\" + baseName.vertexSource;\n    } else if (baseName.vertexElement) {\n      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\n\n      if (!vertexSource) {\n        vertexSource = baseName.vertexElement;\n      }\n    } else {\n      vertexSource = baseName.vertex || baseName;\n    }\n\n    if (baseName.fragmentSource) {\n      fragmentSource = \"source:\" + baseName.fragmentSource;\n    } else if (baseName.fragmentElement) {\n      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\n\n      if (!fragmentSource) {\n        fragmentSource = baseName.fragmentElement;\n      }\n    } else {\n      fragmentSource = baseName.fragment || baseName;\n    }\n\n    var processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: this._indexParameters,\n      isFragment: false,\n      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n      processor: this._engine._shaderProcessor,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: Effect.ShadersRepository,\n      includesShadersStore: Effect.IncludesShadersStore,\n      version: (this._engine.webGLVersion * 100).toString(),\n      platformName: this._engine.webGLVersion >= 2 ? \"WEBGL2\" : \"WEBGL1\"\n    };\n\n    this._loadShader(vertexSource, \"Vertex\", \"\", function (vertexCode) {\n      _this._rawVertexSourceCode = vertexCode;\n\n      _this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", function (fragmentCode) {\n        _this._rawFragmentSourceCode = fragmentCode;\n        ShaderProcessor.Process(vertexCode, processorOptions, function (migratedVertexCode) {\n          if (processFinalCode) {\n            migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\n          }\n\n          processorOptions.isFragment = true;\n          ShaderProcessor.Process(fragmentCode, processorOptions, function (migratedFragmentCode) {\n            if (processFinalCode) {\n              migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\n            }\n\n            _this._useFinalCode(migratedVertexCode, migratedFragmentCode, baseName);\n          }, _this._engine);\n        }, _this._engine);\n      });\n    });\n  }\n\n  Object.defineProperty(Effect.prototype, \"onBindObservable\", {\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\n    get: function () {\n      if (!this._onBindObservable) {\n        this._onBindObservable = new Observable();\n      }\n\n      return this._onBindObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Effect.prototype._useFinalCode = function (migratedVertexCode, migratedFragmentCode, baseName) {\n    if (baseName) {\n      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\n      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\n      this._vertexSourceCode = \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\n      this._fragmentSourceCode = \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\n    } else {\n      this._vertexSourceCode = migratedVertexCode;\n      this._fragmentSourceCode = migratedFragmentCode;\n    }\n\n    this._prepareEffect();\n  };\n\n  Object.defineProperty(Effect.prototype, \"key\", {\n    /**\r\n     * Unique key for this effect\r\n     */\n    get: function () {\n      return this._key;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * If the effect has been compiled and prepared.\r\n   * @returns if the effect is compiled and prepared.\r\n   */\n\n  Effect.prototype.isReady = function () {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  Effect.prototype._isReadyInternal = function () {\n    if (this._isReady) {\n      return true;\n    }\n\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n\n    return false;\n  };\n  /**\r\n   * The engine the effect was initialized with.\r\n   * @returns the engine.\r\n   */\n\n\n  Effect.prototype.getEngine = function () {\n    return this._engine;\n  };\n  /**\r\n   * The pipeline context for this effect\r\n   * @returns the associated pipeline context\r\n   */\n\n\n  Effect.prototype.getPipelineContext = function () {\n    return this._pipelineContext;\n  };\n  /**\r\n   * The set of names of attribute variables for the shader.\r\n   * @returns An array of attribute names.\r\n   */\n\n\n  Effect.prototype.getAttributesNames = function () {\n    return this._attributesNames;\n  };\n  /**\r\n   * Returns the attribute at the given index.\r\n   * @param index The index of the attribute.\r\n   * @returns The location of the attribute.\r\n   */\n\n\n  Effect.prototype.getAttributeLocation = function (index) {\n    return this._attributes[index];\n  };\n  /**\r\n   * Returns the attribute based on the name of the variable.\r\n   * @param name of the attribute to look up.\r\n   * @returns the attribute location.\r\n   */\n\n\n  Effect.prototype.getAttributeLocationByName = function (name) {\n    return this._attributeLocationByName[name];\n  };\n  /**\r\n   * The number of attributes.\r\n   * @returns the numnber of attributes.\r\n   */\n\n\n  Effect.prototype.getAttributesCount = function () {\n    return this._attributes.length;\n  };\n  /**\r\n   * Gets the index of a uniform variable.\r\n   * @param uniformName of the uniform to look up.\r\n   * @returns the index.\r\n   */\n\n\n  Effect.prototype.getUniformIndex = function (uniformName) {\n    return this._uniformsNames.indexOf(uniformName);\n  };\n  /**\r\n   * Returns the attribute based on the name of the variable.\r\n   * @param uniformName of the uniform to look up.\r\n   * @returns the location of the uniform.\r\n   */\n\n\n  Effect.prototype.getUniform = function (uniformName) {\n    return this._uniforms[uniformName];\n  };\n  /**\r\n   * Returns an array of sampler variable names\r\n   * @returns The array of sampler variable names.\r\n   */\n\n\n  Effect.prototype.getSamplers = function () {\n    return this._samplerList;\n  };\n  /**\r\n   * Returns an array of uniform variable names\r\n   * @returns The array of uniform variable names.\r\n   */\n\n\n  Effect.prototype.getUniformNames = function () {\n    return this._uniformsNames;\n  };\n  /**\r\n   * Returns an array of uniform buffer variable names\r\n   * @returns The array of uniform buffer variable names.\r\n   */\n\n\n  Effect.prototype.getUniformBuffersNames = function () {\n    return this._uniformBuffersNamesList;\n  };\n  /**\r\n   * Returns the index parameters used to create the effect\r\n   * @returns The index parameters object\r\n   */\n\n\n  Effect.prototype.getIndexParameters = function () {\n    return this._indexParameters;\n  };\n  /**\r\n   * The error from the last compilation.\r\n   * @returns the error string.\r\n   */\n\n\n  Effect.prototype.getCompilationError = function () {\n    return this._compilationError;\n  };\n  /**\r\n   * Gets a boolean indicating that all fallbacks were used during compilation\r\n   * @returns true if all fallbacks were used\r\n   */\n\n\n  Effect.prototype.allFallbacksProcessed = function () {\n    return this._allFallbacksProcessed;\n  };\n  /**\r\n   * Adds a callback to the onCompiled observable and call the callback imediatly if already ready.\r\n   * @param func The callback to be used.\r\n   */\n\n\n  Effect.prototype.executeWhenCompiled = function (func) {\n    var _this = this;\n\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n\n    this.onCompileObservable.add(function (effect) {\n      func(effect);\n    });\n\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(function () {\n        _this._checkIsReady(null);\n      }, 16);\n    }\n  };\n\n  Effect.prototype._checkIsReady = function (previousPipelineContext) {\n    var _this = this;\n\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n\n      return;\n    }\n\n    setTimeout(function () {\n      _this._checkIsReady(previousPipelineContext);\n    }, 16);\n  };\n\n  Effect.prototype._loadShader = function (shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        var shaderCode = DomManagement.GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    } // Direct source ?\n\n\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    } // Base64 encoded ?\n\n\n    if (shader.substr(0, 7) === \"base64:\") {\n      var shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    } // Is in local store ?\n\n\n    if (Effect.ShadersStore[shader + key + \"Shader\"]) {\n      callback(Effect.ShadersStore[shader + key + \"Shader\"]);\n      return;\n    }\n\n    if (optionalKey && Effect.ShadersStore[shader + optionalKey + \"Shader\"]) {\n      callback(Effect.ShadersStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n\n    var shaderUrl;\n\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = Effect.ShadersRepository + shader;\n    } // Vertex shader\n\n\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  };\n\n  Object.defineProperty(Effect.prototype, \"vertexSourceCode\", {\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     */\n    get: function () {\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._vertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"fragmentSourceCode\", {\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     */\n    get: function () {\n      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawVertexSourceCode\", {\n    /**\r\n     * Gets the vertex shader source code before it has been processed by the preprocessor\r\n     */\n    get: function () {\n      return this._rawVertexSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Effect.prototype, \"rawFragmentSourceCode\", {\n    /**\r\n     * Gets the fragment shader source code before it has been processed by the preprocessor\r\n     */\n    get: function () {\n      return this._rawFragmentSourceCode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Recompiles the webGL program\r\n   * @param vertexSourceCode The source code for the vertex shader.\r\n   * @param fragmentSourceCode The source code for the fragment shader.\r\n   * @param onCompiled Callback called when completed.\r\n   * @param onError Callback called on error.\r\n   * @hidden\r\n   */\n\n  Effect.prototype._rebuildProgram = function (vertexSourceCode, fragmentSourceCode, onCompiled, onError) {\n    var _this = this;\n\n    this._isReady = false;\n    this._vertexSourceCodeOverride = vertexSourceCode;\n    this._fragmentSourceCodeOverride = fragmentSourceCode;\n\n    this.onError = function (effect, error) {\n      if (onError) {\n        onError(error);\n      }\n    };\n\n    this.onCompiled = function () {\n      var scenes = _this.getEngine().scenes;\n\n      if (scenes) {\n        for (var i = 0; i < scenes.length; i++) {\n          scenes[i].markAllMaterialsAsDirty(63);\n        }\n      }\n\n      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);\n    };\n\n    this._fallbacks = null;\n\n    this._prepareEffect();\n  };\n  /**\r\n   * Prepares the effect\r\n   * @hidden\r\n   */\n\n\n  Effect.prototype._prepareEffect = function () {\n    var _this = this;\n\n    var attributesNames = this._attributesNames;\n    var defines = this.defines;\n    this._valueCache = {};\n    var previousPipelineContext = this._pipelineContext;\n\n    try {\n      var engine_1 = this._engine;\n      this._pipelineContext = engine_1.createPipelineContext();\n\n      var rebuildRebind = this._rebuildProgram.bind(this);\n\n      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, rebuildRebind, null, this._transformFeedbackVaryings);\n      } else {\n        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, rebuildRebind, defines, this._transformFeedbackVaryings);\n      }\n\n      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function () {\n        if (engine_1.supportsUniformBuffers) {\n          for (var name in _this._uniformBuffersNames) {\n            _this.bindUniformBlock(name, _this._uniformBuffersNames[name]);\n          }\n        }\n\n        var uniforms = engine_1.getUniforms(_this._pipelineContext, _this._uniformsNames);\n        uniforms.forEach(function (uniform, index) {\n          _this._uniforms[_this._uniformsNames[index]] = uniform;\n        });\n        _this._attributes = engine_1.getAttributes(_this._pipelineContext, attributesNames);\n\n        if (attributesNames) {\n          for (var i = 0; i < attributesNames.length; i++) {\n            var name_1 = attributesNames[i];\n            _this._attributeLocationByName[name_1] = _this._attributes[i];\n          }\n        }\n\n        var index;\n\n        for (index = 0; index < _this._samplerList.length; index++) {\n          var sampler = _this.getUniform(_this._samplerList[index]);\n\n          if (sampler == null) {\n            _this._samplerList.splice(index, 1);\n\n            index--;\n          }\n        }\n\n        _this._samplerList.forEach(function (name, index) {\n          _this._samplers[name] = index;\n        });\n\n        engine_1.bindSamplers(_this);\n        _this._compilationError = \"\";\n        _this._isReady = true;\n\n        if (_this.onCompiled) {\n          _this.onCompiled(_this);\n        }\n\n        _this.onCompileObservable.notifyObservers(_this);\n\n        _this.onCompileObservable.clear(); // Unbind mesh reference in fallbacks\n\n\n        if (_this._fallbacks) {\n          _this._fallbacks.unBindMesh();\n        }\n\n        if (previousPipelineContext) {\n          _this.getEngine()._deletePipelineContext(previousPipelineContext);\n        }\n      });\n\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  };\n\n  Effect.prototype._getShaderCodeAndErrorLine = function (code, error, isFragment) {\n    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\n    var errorLine = null;\n\n    if (error && code) {\n      var res = error.match(regexp);\n\n      if (res && res.length === 2) {\n        var lineNumber = parseInt(res[1]);\n        var lines = code.split(\"\\n\", -1);\n\n        if (lines.length >= lineNumber) {\n          errorLine = \"Offending line [\" + lineNumber + \"] in \" + (isFragment ? \"fragment\" : \"vertex\") + \" code: \" + lines[lineNumber - 1];\n        }\n      }\n    }\n\n    return [code, errorLine];\n  };\n\n  Effect.prototype._processCompilationErrors = function (e, previousPipelineContext) {\n    var _a, _b;\n\n    var _c, _d, _e;\n\n    if (previousPipelineContext === void 0) {\n      previousPipelineContext = null;\n    }\n\n    this._compilationError = e.message;\n    var attributesNames = this._attributesNames;\n    var fallbacks = this._fallbacks; // Let's go through fallbacks then\n\n    Logger.Error(\"Unable to compile effect:\");\n    Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n      return \" \" + uniform;\n    }));\n    Logger.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n      return \" \" + attribute;\n    }));\n    Logger.Error(\"Defines:\\r\\n\" + this.defines);\n\n    if (Effect.LogShaderCodeOnCompilationError) {\n      var lineErrorVertex = null,\n          lineErrorFragment = null,\n          code = null;\n\n      if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {\n        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];\n\n        if (code) {\n          Logger.Error(\"Vertex code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {\n        _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];\n\n        if (code) {\n          Logger.Error(\"Fragment code:\");\n          Logger.Error(code);\n        }\n      }\n\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n\n      if (lineErrorFragment) {\n        Logger.Error(lineErrorFragment);\n      }\n    }\n\n    Logger.Error(\"Error: \" + this._compilationError);\n\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n\n      this.onErrorObservable.notifyObservers(this);\n    }\n\n    if (fallbacks) {\n      this._pipelineContext = null;\n\n      if (fallbacks.hasMoreFallbacks) {\n        this._allFallbacksProcessed = false;\n        Logger.Error(\"Trying next fallback.\");\n        this.defines = fallbacks.reduce(this.defines, this);\n\n        this._prepareEffect();\n      } else {\n        // Sorry we did everything we can\n        this._allFallbacksProcessed = true;\n\n        if (this.onError) {\n          this.onError(this, this._compilationError);\n        }\n\n        this.onErrorObservable.notifyObservers(this);\n        this.onErrorObservable.clear(); // Unbind mesh reference in fallbacks\n\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n      }\n    } else {\n      this._allFallbacksProcessed = true;\n    }\n  };\n\n  Object.defineProperty(Effect.prototype, \"isSupported\", {\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\n    get: function () {\n      return this._compilationError === \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Binds a texture to the engine to be used as output of the shader.\r\n   * @param channel Name of the output variable.\r\n   * @param texture Texture to bind.\r\n   * @hidden\r\n   */\n\n  Effect.prototype._bindTexture = function (channel, texture) {\n    this._engine._bindTexture(this._samplers[channel], texture);\n  };\n  /**\r\n   * Sets a texture on the engine to be used in the shader.\r\n   * @param channel Name of the sampler variable.\r\n   * @param texture Texture to set.\r\n   */\n\n\n  Effect.prototype.setTexture = function (channel, texture) {\n    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture);\n  };\n  /**\r\n   * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n   * @param channel Name of the sampler variable.\r\n   * @param texture Texture to set.\r\n   */\n\n\n  Effect.prototype.setDepthStencilTexture = function (channel, texture) {\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture);\n  };\n  /**\r\n   * Sets an array of textures on the engine to be used in the shader.\r\n   * @param channel Name of the variable.\r\n   * @param textures Textures to set.\r\n   */\n\n\n  Effect.prototype.setTextureArray = function (channel, textures) {\n    var exName = channel + \"Ex\";\n\n    if (this._samplerList.indexOf(exName + \"0\") === -1) {\n      var initialPos = this._samplerList.indexOf(channel);\n\n      for (var index = 1; index < textures.length; index++) {\n        var currentExName = exName + (index - 1).toString();\n\n        this._samplerList.splice(initialPos + index, 0, currentExName);\n      } // Reset every channels\n\n\n      var channelIndex = 0;\n\n      for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {\n        var key = _a[_i];\n        this._samplers[key] = channelIndex;\n        channelIndex += 1;\n      }\n    }\n\n    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures);\n  };\n  /**\r\n   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n   * @param channel Name of the sampler variable.\r\n   * @param postProcess Post process to get the input texture from.\r\n   */\n\n\n  Effect.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess);\n  };\n  /**\r\n   * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n   * @param channel Name of the sampler variable.\r\n   * @param postProcess Post process to get the output texture from.\r\n   */\n\n\n  Effect.prototype.setTextureFromPostProcessOutput = function (channel, postProcess) {\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess);\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheMatrix = function (uniformName, matrix) {\n    var cache = this._valueCache[uniformName];\n    var flag = matrix.updateFlag;\n\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n\n    this._valueCache[uniformName] = flag;\n    return true;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat2 = function (uniformName, x, y) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 2) {\n      cache = [x, y];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat3 = function (uniformName, x, y, z) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 3) {\n      cache = [x, y, z];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    if (cache[2] !== z) {\n      cache[2] = z;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /** @hidden */\n\n\n  Effect.prototype._cacheFloat4 = function (uniformName, x, y, z, w) {\n    var cache = this._valueCache[uniformName];\n\n    if (!cache || cache.length !== 4) {\n      cache = [x, y, z, w];\n      this._valueCache[uniformName] = cache;\n      return true;\n    }\n\n    var changed = false;\n\n    if (cache[0] !== x) {\n      cache[0] = x;\n      changed = true;\n    }\n\n    if (cache[1] !== y) {\n      cache[1] = y;\n      changed = true;\n    }\n\n    if (cache[2] !== z) {\n      cache[2] = z;\n      changed = true;\n    }\n\n    if (cache[3] !== w) {\n      cache[3] = w;\n      changed = true;\n    }\n\n    return changed;\n  };\n  /**\r\n   * Binds a buffer to a uniform.\r\n   * @param buffer Buffer to bind.\r\n   * @param name Name of the uniform variable to bind to.\r\n   */\n\n\n  Effect.prototype.bindUniformBuffer = function (buffer, name) {\n    var bufferName = this._uniformBuffersNames[name];\n\n    if (bufferName === undefined || Effect._baseCache[bufferName] === buffer) {\n      return;\n    }\n\n    Effect._baseCache[bufferName] = buffer;\n\n    this._engine.bindUniformBufferBase(buffer, bufferName);\n  };\n  /**\r\n   * Binds block to a uniform.\r\n   * @param blockName Name of the block to bind.\r\n   * @param index Index to bind.\r\n   */\n\n\n  Effect.prototype.bindUniformBlock = function (blockName, index) {\n    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);\n  };\n  /**\r\n   * Sets an interger value on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param value Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setInt = function (uniformName, value) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === value) {\n      return this;\n    }\n\n    if (this._engine.setInt(this._uniforms[uniformName], value)) {\n      this._valueCache[uniformName] = value;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets an int array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setIntArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setIntArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloatArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray2 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray2(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray3 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray3(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n   * @param uniformName Name of the variable.\r\n   * @param array array to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setArray4 = function (uniformName, array) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setArray4(this._uniforms[uniformName], array);\n\n    return this;\n  };\n  /**\r\n   * Sets matrices on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param matrices matrices to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrices = function (uniformName, matrices) {\n    if (!matrices) {\n      return this;\n    }\n\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrices(this._uniforms[uniformName], matrices); // the cast is ok because it is gl.uniformMatrix4fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets matrix on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix = function (uniformName, matrix) {\n    if (this._cacheMatrix(uniformName, matrix)) {\n      if (!this._engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix3x3 = function (uniformName, matrix) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrix3x3(this._uniforms[uniformName], matrix); // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n   * @param uniformName Name of the variable.\r\n   * @param matrix matrix to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setMatrix2x2 = function (uniformName, matrix) {\n    this._valueCache[uniformName] = null;\n\n    this._engine.setMatrix2x2(this._uniforms[uniformName], matrix); // the cast is ok because it is gl.uniformMatrix2fv() which is called at the end, and this function accepts Float32Array and Array<number>\n\n\n    return this;\n  };\n  /**\r\n   * Sets a float on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param value value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat = function (uniformName, value) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === value) {\n      return this;\n    }\n\n    if (this._engine.setFloat(this._uniforms[uniformName], value)) {\n      this._valueCache[uniformName] = value;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a boolean on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param bool value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setBool = function (uniformName, bool) {\n    var cache = this._valueCache[uniformName];\n\n    if (cache !== undefined && cache === bool) {\n      return this;\n    }\n\n    if (this._engine.setInt(this._uniforms[uniformName], bool ? 1 : 0)) {\n      this._valueCache[uniformName] = bool;\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector2 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector2 vector2 to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector2 = function (uniformName, vector2) {\n    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\n      if (!this._engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float2 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float2.\r\n   * @param y Second float in float2.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat2 = function (uniformName, x, y) {\n    if (this._cacheFloat2(uniformName, x, y)) {\n      if (!this._engine.setFloat2(this._uniforms[uniformName], x, y)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector3 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector3 = function (uniformName, vector3) {\n    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float3.\r\n   * @param y Second float in float3.\r\n   * @param z Third float in float3.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat3 = function (uniformName, x, y, z) {\n    if (this._cacheFloat3(uniformName, x, y, z)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Vector4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param vector4 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setVector4 = function (uniformName, vector4) {\n    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a float4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param x First float in float4.\r\n   * @param y Second float in float4.\r\n   * @param z Third float in float4.\r\n   * @param w Fourth float in float4.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setFloat4 = function (uniformName, x, y, z, w) {\n    if (this._cacheFloat4(uniformName, x, y, z, w)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color3 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param color3 Value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setColor3 = function (uniformName, color3) {\n    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\n      if (!this._engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color4 on a uniform variable.\r\n   * @param uniformName Name of the variable.\r\n   * @param color3 Value to be set.\r\n   * @param alpha Alpha value to be set.\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setColor4 = function (uniformName, color3, alpha) {\n    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets a Color4 on a uniform variable\r\n   * @param uniformName defines the name of the variable\r\n   * @param color4 defines the value to be set\r\n   * @returns this effect.\r\n   */\n\n\n  Effect.prototype.setDirectColor4 = function (uniformName, color4) {\n    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\n      if (!this._engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\n        this._valueCache[uniformName] = null;\n      }\n    }\n\n    return this;\n  };\n  /** Release all associated resources */\n\n\n  Effect.prototype.dispose = function () {\n    this._engine._releaseEffect(this);\n  };\n  /**\r\n   * This function will add a new shader to the shader store\r\n   * @param name the name of the shader\r\n   * @param pixelShader optional pixel shader content\r\n   * @param vertexShader optional vertex shader content\r\n   */\n\n\n  Effect.RegisterShader = function (name, pixelShader, vertexShader) {\n    if (pixelShader) {\n      Effect.ShadersStore[name + \"PixelShader\"] = pixelShader;\n    }\n\n    if (vertexShader) {\n      Effect.ShadersStore[name + \"VertexShader\"] = vertexShader;\n    }\n  };\n  /**\r\n   * Resets the cache of effects.\r\n   */\n\n\n  Effect.ResetCache = function () {\n    Effect._baseCache = {};\n  };\n  /**\r\n   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n   */\n\n\n  Effect.ShadersRepository = \"src/Shaders/\";\n  /**\r\n   * Enable logging of the shader code when a compilation error occurs\r\n   */\n\n  Effect.LogShaderCodeOnCompilationError = true;\n  Effect._uniqueIdSeed = 0;\n  Effect._baseCache = {};\n  /**\r\n   * Store of each shader (The can be looked up using effect.key)\r\n   */\n\n  Effect.ShadersStore = {};\n  /**\r\n   * Store of each included file for a shader (The can be looked up using effect.key)\r\n   */\n\n  Effect.IncludesShadersStore = {};\n  return Effect;\n}();\n\nexport { Effect };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/effect.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\n\r\nimport { DomManagement } from \"../Misc/domManagement\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { IDisposable } from '../scene';\r\nimport { IPipelineContext } from '../Engines/IPipelineContext';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\r\nimport { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like } from '../Maths/math.like';\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\nimport { IEffectFallbacks } from './iEffectFallbacks';\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type ThinTexture = import(\"../Materials/Textures/thinTexture\").ThinTexture;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type PostProcess = import(\"../PostProcesses/postProcess\").PostProcess;\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Atrributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform varible names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(shaderType: string, code: string) => string>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static ShadersRepository = \"src/Shaders/\";\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @hidden */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    /**\r\n     * @hidden\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @hidden */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _uniqueIdSeed = 0;\r\n    private _engine: Engine;\r\n    private _uniformBuffersNames: { [key: string]: number } = {};\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    private _samplerList: string[];\r\n    private _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string] : number };\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @hidden\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCode: string = \"\";\r\n    private _fragmentSourceCode: string = \"\";\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _rawVertexSourceCode: string = \"\";\r\n    private _rawFragmentSourceCode: string = \"\";\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @hidden\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private static _baseCache: { [key: number]: DataBuffer } = {};\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})\r\n     */\r\n    constructor(baseName: any, attributesNamesOrOptions: string[] | IEffectCreationOptions, uniformsNamesOrEngine: string[] | ThinEngine, samplers: Nullable<string[]> = null,\r\n        engine?: ThinEngine, defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null, onCompiled: Nullable<(effect: Effect) => void> = null, onError: Nullable<(effect: Effect, errors: string) => void> = null, indexParameters?: any) {\r\n        this.name = baseName;\r\n\r\n        let processFinalCode: Nullable<(shaderType: string, code: string) => string> = null;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            var options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <Engine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (var i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            processFinalCode = options.processFinalCode ?? null;\r\n        } else {\r\n            this._engine = <Engine>engine;\r\n            this.defines = (defines == null ? \"\" : defines);\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? <string[]>samplers.slice() : [];\r\n            this._attributesNames = (<string[]>attributesNamesOrOptions);\r\n            this._uniformBuffersNamesList = [];\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        this._attributeLocationByName = { };\r\n\r\n        this.uniqueId = Effect._uniqueIdSeed++;\r\n\r\n        var vertexSource: any;\r\n        var fragmentSource: any;\r\n\r\n        let hostDocument = DomManagement.IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.vertexSource) {\r\n            vertexSource = \"source:\" + baseName.vertexSource;\r\n        } else if (baseName.vertexElement) {\r\n            vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\r\n\r\n            if (!vertexSource) {\r\n                vertexSource = baseName.vertexElement;\r\n            }\r\n        } else {\r\n            vertexSource = baseName.vertex || baseName;\r\n        }\r\n\r\n        if (baseName.fragmentSource) {\r\n            fragmentSource = \"source:\" + baseName.fragmentSource;\r\n        } else if (baseName.fragmentElement) {\r\n            fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\r\n\r\n            if (!fragmentSource) {\r\n                fragmentSource = baseName.fragmentElement;\r\n            }\r\n        } else {\r\n            fragmentSource = baseName.fragment || baseName;\r\n        }\r\n\r\n        let processorOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: this._engine._shaderProcessor,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: Effect.ShadersRepository,\r\n            includesShadersStore: Effect.IncludesShadersStore,\r\n            version: (this._engine.webGLVersion * 100).toString(),\r\n            platformName: this._engine.webGLVersion >= 2 ? \"WEBGL2\" : \"WEBGL1\"\r\n        };\r\n\r\n        this._loadShader(vertexSource, \"Vertex\", \"\", (vertexCode) => {\r\n            this._rawVertexSourceCode = vertexCode;\r\n            this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", (fragmentCode) => {\r\n                this._rawFragmentSourceCode = fragmentCode;\r\n                ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode) => {\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    processorOptions.isFragment = true;\r\n                    ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode) => {\r\n                        if (processFinalCode) {\r\n                            migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                        }\r\n                        this._useFinalCode(migratedVertexCode, migratedFragmentCode, baseName);\r\n                    }, this._engine);\r\n                }, this._engine);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any) {\r\n        if (baseName) {\r\n            var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n            var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n            this._vertexSourceCode = \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\r\n            this._fragmentSourceCode = \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\r\n        } else {\r\n            this._vertexSourceCode = migratedVertexCode;\r\n            this._fragmentSourceCode = migratedFragmentCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        }\r\n        catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the numnber of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback imediatly if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof(HTMLElement) !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                var shaderCode = DomManagement.GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            var shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (Effect.ShadersStore[shader + key + \"Shader\"]) {\r\n            callback(Effect.ShadersStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && Effect.ShadersStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(Effect.ShadersStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        var shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = Effect.ShadersRepository + shader;\r\n        }\r\n\r\n        // Vertex shader\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._vertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @hidden\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            var scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (var i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(63);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @hidden\r\n     */\r\n    public _prepareEffect() {\r\n        let attributesNames = this._attributesNames;\r\n        let defines = this.defines;\r\n        this._valueCache = {};\r\n\r\n        var previousPipelineContext = this._pipelineContext;\r\n\r\n        try {\r\n            let engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createPipelineContext();\r\n\r\n            let rebuildRebind = this._rebuildProgram.bind(this);\r\n            if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\r\n                engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, rebuildRebind, null, this._transformFeedbackVaryings);\r\n            }\r\n            else {\r\n                engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, rebuildRebind, defines, this._transformFeedbackVaryings);\r\n            }\r\n\r\n            engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\r\n                if (engine.supportsUniformBuffers) {\r\n                    for (var name in this._uniformBuffersNames) {\r\n                        this.bindUniformBlock(name, this._uniformBuffersNames[name]);\r\n                    }\r\n                }\r\n\r\n                let uniforms = engine.getUniforms(this._pipelineContext!, this._uniformsNames);\r\n                uniforms.forEach((uniform, index) => {\r\n                    this._uniforms[this._uniformsNames[index]] = uniform;\r\n                });\r\n\r\n                this._attributes = engine.getAttributes(this._pipelineContext!, attributesNames);\r\n                if (attributesNames) {\r\n                    for (let i = 0; i < attributesNames.length; i++) {\r\n                        const name = attributesNames[i];\r\n                        this._attributeLocationByName[name] = this._attributes[i];\r\n                    }\r\n                }\r\n\r\n                var index: number;\r\n                for (index = 0; index < this._samplerList.length; index++) {\r\n                    var sampler = this.getUniform(this._samplerList[index]);\r\n\r\n                    if (sampler == null) {\r\n                        this._samplerList.splice(index, 1);\r\n                        index--;\r\n                    }\r\n                }\r\n\r\n                this._samplerList.forEach((name, index) => {\r\n                    this._samplers[name] = index;\r\n                });\r\n\r\n                engine.bindSamplers(this);\r\n\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deletePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n\r\n        } catch (e) {\r\n           this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        let attributesNames = this._attributesNames;\r\n        let fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function(uniform) {\r\n            return \" \" + uniform;\r\n        }));\r\n        Logger.Error(\"Attributes: \" + attributesNames.map(function(attribute) {\r\n            return \" \" + attribute;\r\n        }));\r\n        Logger.Error(\"Defines:\\r\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null, lineErrorFragment = null, code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else { // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                if (this.onError) {\r\n                    this.onError(this, this._compilationError);\r\n                }\r\n                this.onErrorObservable.notifyObservers(this);\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @hidden\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture);\r\n    }\r\n\r\n    /**\r\n     * Sets a depth stencil texture from a render target on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setDepthStencilTexture(channel: string, texture: Nullable<RenderTargetTexture>): void {\r\n        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        let exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (var index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (var key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the input texture from.\r\n     */\r\n    public setTextureFromPostProcess(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess);\r\n    }\r\n\r\n    /**\r\n     * (Warning! setTextureFromPostProcessOutput may be desired instead)\r\n     * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\r\n     * @param channel Name of the sampler variable.\r\n     * @param postProcess Post process to get the output texture from.\r\n     */\r\n    public setTextureFromPostProcessOutput(channel: string, postProcess: Nullable<PostProcess>): void {\r\n        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        var cache = this._valueCache[uniformName];\r\n        var flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        var cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 2) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        var changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        var cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 3) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        var changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        var cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 4) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        var changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        let bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || Effect._baseCache[bufferName] === buffer) {\r\n            return;\r\n        }\r\n        Effect._baseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an interger value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        var cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return this;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray2(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray3(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setIntArray4(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: Float32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: Float32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray2(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: Float32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray3(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: Float32Array): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray4(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray2(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray3(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setArray4(this._uniforms[uniformName], array);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        if (!matrices) {\r\n            return this;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrices(this._uniforms[uniformName], matrices as Float32Array); // the cast is ok because it is gl.uniformMatrix4fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this._engine.setMatrices(this._uniforms[uniformName], matrix.toArray() as Float32Array)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix3x3(this._uniforms[uniformName], matrix as Float32Array); // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        this._valueCache[uniformName] = null;\r\n        this._engine.setMatrix2x2(this._uniforms[uniformName], matrix as Float32Array); // the cast is ok because it is gl.uniformMatrix2fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        var cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return this;\r\n        }\r\n\r\n        if (this._engine.setFloat(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        var cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === bool) {\r\n            return this;\r\n        }\r\n\r\n        if (this._engine.setInt(this._uniforms[uniformName], bool ? 1 : 0)) {\r\n            this._valueCache[uniformName] = bool;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this._engine.setFloat2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this._engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this._engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** Release all associated resources */\r\n    public dispose() {\r\n        this._engine._releaseEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string) {\r\n        if (pixelShader) {\r\n            Effect.ShadersStore[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            Effect.ShadersStore[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = {};\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = {};\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._baseCache = {};\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}