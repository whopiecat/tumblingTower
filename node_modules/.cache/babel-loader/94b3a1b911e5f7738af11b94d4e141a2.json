{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\nimport { Camera } from \"../Cameras/camera\";\nimport { FreeCamera } from \"../Cameras/freeCamera\";\nimport { TargetCamera } from \"../Cameras/targetCamera\";\nimport { Viewport } from \"../Maths/math.viewport\";\nimport { Observable } from \"../Misc/observable\";\nimport { WebXRTrackingState } from \"./webXRTypes\";\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/how_to/webxr_camera\r\n */\n\nvar WebXRCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebXRCamera, _super);\n  /**\r\n   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n   * @param name the name of the camera\r\n   * @param scene the scene to add the camera to\r\n   * @param _xrSessionManager a constructed xr session manager\r\n   */\n\n\n  function WebXRCamera(name, scene, _xrSessionManager) {\n    var _this = _super.call(this, name, Vector3.Zero(), scene) || this;\n\n    _this._xrSessionManager = _xrSessionManager;\n    _this._firstFrame = false;\n    _this._referenceQuaternion = Quaternion.Identity();\n    _this._referencedPosition = new Vector3();\n    _this._xrInvPositionCache = new Vector3();\n    _this._xrInvQuaternionCache = Quaternion.Identity();\n    _this._trackingState = WebXRTrackingState.NOT_TRACKING;\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\n\n    _this.onBeforeCameraTeleport = new Observable();\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\n\n    _this.onAfterCameraTeleport = new Observable();\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\n\n    _this.onTrackingStateChanged = new Observable();\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\n\n    _this.compensateOnFirstFrame = true;\n    _this._rotate180 = new Quaternion(0, 1, 0, 0); // Initial camera configuration\n\n    _this.minZ = 0.1;\n    _this.rotationQuaternion = new Quaternion();\n    _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\n    _this.updateUpVectorFromRotation = true;\n\n    _this._updateNumberOfRigCameras(1); // freeze projection matrix, which will be copied later\n\n\n    _this.freezeProjectionMatrix();\n\n    _this._xrSessionManager.onXRSessionInit.add(function () {\n      _this._referencedPosition.copyFromFloats(0, 0, 0);\n\n      _this._referenceQuaternion.copyFromFloats(0, 0, 0, 1); // first frame - camera's y position should be 0 for the correct offset\n\n\n      _this._firstFrame = _this.compensateOnFirstFrame;\n    }); // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\n    // applied to the rest of the elements using the referenceSpace object\n\n\n    _this._xrSessionManager.onXRFrameObservable.add(function (frame) {\n      if (_this._firstFrame) {\n        _this._updateFromXRSession();\n      }\n\n      _this._updateReferenceSpace();\n\n      _this._updateFromXRSession();\n    }, undefined, true);\n\n    return _this;\n  }\n\n  Object.defineProperty(WebXRCamera.prototype, \"trackingState\", {\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\n    get: function () {\n      return this._trackingState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  WebXRCamera.prototype._setTrackingState = function (newState) {\n    if (this._trackingState !== newState) {\n      this._trackingState = newState;\n      this.onTrackingStateChanged.notifyObservers(newState);\n    }\n  };\n\n  Object.defineProperty(WebXRCamera.prototype, \"realWorldHeight\", {\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\n    get: function () {\n      var basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\n\n      if (basePose && basePose.transform) {\n        return basePose.transform.position.y;\n      } else {\n        return 0;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  WebXRCamera.prototype._updateForDualEyeDebugging = function ()\n  /*pupilDistance = 0.01*/\n  {\n    // Create initial camera rigs\n    this._updateNumberOfRigCameras(2);\n\n    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0); // this.rigCameras[0].position.x = -pupilDistance / 2;\n\n    this.rigCameras[0].outputRenderTarget = null;\n    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0); // this.rigCameras[1].position.x = pupilDistance / 2;\n\n    this.rigCameras[1].outputRenderTarget = null;\n  };\n  /**\r\n   * Sets this camera's transformation based on a non-vr camera\r\n   * @param otherCamera the non-vr camera to copy the transformation from\r\n   * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n   */\n\n\n  WebXRCamera.prototype.setTransformationFromNonVRCamera = function (otherCamera, resetToBaseReferenceSpace) {\n    if (otherCamera === void 0) {\n      otherCamera = this.getScene().activeCamera;\n    }\n\n    if (resetToBaseReferenceSpace === void 0) {\n      resetToBaseReferenceSpace = true;\n    }\n\n    if (!otherCamera || otherCamera === this) {\n      return;\n    }\n\n    var mat = otherCamera.computeWorldMatrix();\n    mat.decompose(undefined, this.rotationQuaternion, this.position); // set the ground level\n\n    this.position.y = 0;\n    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\n    this._firstFrame = true;\n\n    if (resetToBaseReferenceSpace) {\n      this._xrSessionManager.resetReferenceSpace();\n    }\n  };\n  /**\r\n   * Gets the current instance class name (\"WebXRCamera\").\r\n   * @returns the class name\r\n   */\n\n\n  WebXRCamera.prototype.getClassName = function () {\n    return \"WebXRCamera\";\n  };\n\n  WebXRCamera.prototype._updateFromXRSession = function () {\n    var _this = this;\n\n    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n\n    if (!pose) {\n      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\n\n      return;\n    } // Set the tracking state. if it didn't change it is a no-op\n\n\n    var trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\n\n    this._setTrackingState(trackingState);\n\n    if (pose.transform) {\n      var pos = pose.transform.position;\n\n      this._referencedPosition.set(pos.x, pos.y, pos.z);\n\n      var orientation_1 = pose.transform.orientation;\n\n      this._referenceQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);\n\n      if (!this._scene.useRightHandedSystem) {\n        this._referencedPosition.z *= -1;\n        this._referenceQuaternion.z *= -1;\n        this._referenceQuaternion.w *= -1;\n      }\n\n      if (this._firstFrame) {\n        this._firstFrame = false; // we have the XR reference, now use this to find the offset to get the camera to be\n        // in the right position\n        // set the height to correlate to the current height\n\n        this.position.y += this._referencedPosition.y; // avoid using the head rotation on the first frame.\n\n        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else {\n        // update position and rotation as reference\n        this.rotationQuaternion.copyFrom(this._referenceQuaternion);\n        this.position.copyFrom(this._referencedPosition);\n      }\n    } // Update camera rigs\n\n\n    if (this.rigCameras.length !== pose.views.length) {\n      this._updateNumberOfRigCameras(pose.views.length);\n    }\n\n    pose.views.forEach(function (view, i) {\n      var currentRig = _this.rigCameras[i]; // update right and left, where applicable\n\n      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\n        if (view.eye === \"right\") {\n          currentRig._isRightCamera = true;\n        } else if (view.eye === \"left\") {\n          currentRig._isLeftCamera = true;\n        }\n      } // Update view/projection matrix\n\n\n      var pos = view.transform.position;\n      var orientation = view.transform.orientation;\n      currentRig.position.set(pos.x, pos.y, pos.z);\n      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig.position.z *= -1;\n        currentRig.rotationQuaternion.z *= -1;\n        currentRig.rotationQuaternion.w *= -1;\n      } else {\n        currentRig.rotationQuaternion.multiplyInPlace(_this._rotate180);\n      }\n\n      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\n\n      if (!_this._scene.useRightHandedSystem) {\n        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\n      } // first camera?\n\n\n      if (i === 0) {\n        _this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\n      } // Update viewport\n\n\n      if (_this._xrSessionManager.session.renderState.baseLayer) {\n        var viewport = _this._xrSessionManager.session.renderState.baseLayer.getViewport(view);\n\n        var width = _this._xrSessionManager.session.renderState.baseLayer.framebufferWidth;\n        var height = _this._xrSessionManager.session.renderState.baseLayer.framebufferHeight;\n        currentRig.viewport.width = viewport.width / width;\n        currentRig.viewport.height = viewport.height / height;\n        currentRig.viewport.x = viewport.x / width;\n        currentRig.viewport.y = viewport.y / height;\n      } // Set cameras to render to the session's render target\n\n\n      currentRig.outputRenderTarget = _this._xrSessionManager.getRenderTargetTextureForEye(view.eye);\n    });\n  };\n\n  WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {\n    if (viewCount === void 0) {\n      viewCount = 1;\n    }\n\n    while (this.rigCameras.length < viewCount) {\n      var newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\n      newCamera.minZ = 0.1;\n      newCamera.rotationQuaternion = new Quaternion();\n      newCamera.updateUpVectorFromRotation = true;\n      newCamera.isRigCamera = true;\n      newCamera.rigParent = this; // do not compute projection matrix, provided by XR\n\n      newCamera.freezeProjectionMatrix();\n      this.rigCameras.push(newCamera);\n    }\n\n    while (this.rigCameras.length > viewCount) {\n      var removedCamera = this.rigCameras.pop();\n\n      if (removedCamera) {\n        removedCamera.dispose();\n      }\n    }\n  };\n\n  WebXRCamera.prototype._updateReferenceSpace = function () {\n    // were position & rotation updated OUTSIDE of the xr update loop\n    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\n      this.position.subtractToRef(this._referencedPosition, this._referencedPosition);\n\n      this._referenceQuaternion.conjugateInPlace();\n\n      this._referenceQuaternion.multiplyToRef(this.rotationQuaternion, this._referenceQuaternion);\n\n      this._updateReferenceSpaceOffset(this._referencedPosition, this._referenceQuaternion.normalize());\n    }\n  };\n\n  WebXRCamera.prototype._updateReferenceSpaceOffset = function (positionOffset, rotationOffset, ignoreHeight) {\n    if (ignoreHeight === void 0) {\n      ignoreHeight = false;\n    }\n\n    if (!this._xrSessionManager.referenceSpace || !this._xrSessionManager.currentFrame) {\n      return;\n    } // Compute the origin offset based on player position/orientation.\n\n\n    this._xrInvPositionCache.copyFrom(positionOffset);\n\n    if (rotationOffset) {\n      this._xrInvQuaternionCache.copyFrom(rotationOffset);\n    } else {\n      this._xrInvQuaternionCache.copyFromFloats(0, 0, 0, 1);\n    } // right handed system\n\n\n    if (!this._scene.useRightHandedSystem) {\n      this._xrInvPositionCache.z *= -1;\n      this._xrInvQuaternionCache.z *= -1;\n      this._xrInvQuaternionCache.w *= -1;\n    }\n\n    this._xrInvPositionCache.negateInPlace();\n\n    this._xrInvQuaternionCache.conjugateInPlace(); // transform point according to rotation with pivot\n\n\n    this._xrInvPositionCache.rotateByQuaternionToRef(this._xrInvQuaternionCache, this._xrInvPositionCache);\n\n    if (ignoreHeight) {\n      this._xrInvPositionCache.y = 0;\n    }\n\n    var transform = new XRRigidTransform({\n      x: this._xrInvPositionCache.x,\n      y: this._xrInvPositionCache.y,\n      z: this._xrInvPositionCache.z\n    }, {\n      x: this._xrInvQuaternionCache.x,\n      y: this._xrInvQuaternionCache.y,\n      z: this._xrInvQuaternionCache.z,\n      w: this._xrInvQuaternionCache.w\n    }); // Update offset reference to use a new originOffset with the teleported\n    // player position and orientation.\n    // This new offset needs to be applied to the base ref space.\n\n    var referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\n\n    var pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(referenceSpace);\n\n    if (pose) {\n      var pos = new Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\n\n      if (!this._scene.useRightHandedSystem) {\n        pos.z *= -1;\n      }\n\n      this.position.subtractToRef(pos, pos);\n\n      if (!this._scene.useRightHandedSystem) {\n        pos.z *= -1;\n      }\n\n      pos.negateInPlace();\n      var transform2 = new XRRigidTransform({\n        x: pos.x,\n        y: pos.y,\n        z: pos.z\n      }); // Update offset reference to use a new originOffset with the teleported\n      // player position and orientation.\n      // This new offset needs to be applied to the base ref space.\n\n      this._xrSessionManager.referenceSpace = referenceSpace.getOffsetReferenceSpace(transform2);\n    }\n  };\n\n  return WebXRCamera;\n}(FreeCamera);\n\nexport { WebXRCamera };","map":{"version":3,"sources":["../../../sourceES6/core/XR/webXRCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/how_to/webxr_camera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _xrInvPositionCache: Vector3 = new Vector3();\r\n    private _xrInvQuaternionCache = Quaternion.Identity();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(name: string, scene: Scene, private _xrSessionManager: WebXRSessionManager) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            (frame) => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    private _rotate180 = new Quaternion(0, 1, 0, 0);\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        if (pose.transform) {\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z);\r\n            const orientation = pose.transform.orientation;\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            } else {\r\n                currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            // Update viewport\r\n            if (this._xrSessionManager.session.renderState.baseLayer) {\r\n                var viewport = this._xrSessionManager.session.renderState.baseLayer.getViewport(view);\r\n                var width = this._xrSessionManager.session.renderState.baseLayer.framebufferWidth;\r\n                var height = this._xrSessionManager.session.renderState.baseLayer.framebufferHeight;\r\n                currentRig.viewport.width = viewport.width / width;\r\n                currentRig.viewport.height = viewport.height / height;\r\n                currentRig.viewport.x = viewport.x / width;\r\n                currentRig.viewport.y = viewport.y / height;\r\n            }\r\n\r\n            // Set cameras to render to the session's render target\r\n            currentRig.outputRenderTarget = this._xrSessionManager.getRenderTargetTextureForEye(view.eye);\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            var newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            var removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            this.position.subtractToRef(this._referencedPosition, this._referencedPosition);\r\n            this._referenceQuaternion.conjugateInPlace();\r\n            this._referenceQuaternion.multiplyToRef(this.rotationQuaternion, this._referenceQuaternion);\r\n            this._updateReferenceSpaceOffset(this._referencedPosition, this._referenceQuaternion.normalize());\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpaceOffset(positionOffset: Vector3, rotationOffset?: Quaternion, ignoreHeight: boolean = false) {\r\n        if (!this._xrSessionManager.referenceSpace || !this._xrSessionManager.currentFrame) {\r\n            return;\r\n        }\r\n        // Compute the origin offset based on player position/orientation.\r\n        this._xrInvPositionCache.copyFrom(positionOffset);\r\n        if (rotationOffset) {\r\n            this._xrInvQuaternionCache.copyFrom(rotationOffset);\r\n        } else {\r\n            this._xrInvQuaternionCache.copyFromFloats(0, 0, 0, 1);\r\n        }\r\n\r\n        // right handed system\r\n        if (!this._scene.useRightHandedSystem) {\r\n            this._xrInvPositionCache.z *= -1;\r\n            this._xrInvQuaternionCache.z *= -1;\r\n            this._xrInvQuaternionCache.w *= -1;\r\n        }\r\n\r\n        this._xrInvPositionCache.negateInPlace();\r\n        this._xrInvQuaternionCache.conjugateInPlace();\r\n        // transform point according to rotation with pivot\r\n        this._xrInvPositionCache.rotateByQuaternionToRef(this._xrInvQuaternionCache, this._xrInvPositionCache);\r\n        if (ignoreHeight) {\r\n            this._xrInvPositionCache.y = 0;\r\n        }\r\n        const transform = new XRRigidTransform({ x: this._xrInvPositionCache.x, y: this._xrInvPositionCache.y, z: this._xrInvPositionCache.z }, { x: this._xrInvQuaternionCache.x, y: this._xrInvQuaternionCache.y, z: this._xrInvQuaternionCache.z, w: this._xrInvQuaternionCache.w });\r\n        // Update offset reference to use a new originOffset with the teleported\r\n        // player position and orientation.\r\n        // This new offset needs to be applied to the base ref space.\r\n        const referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(referenceSpace);\r\n\r\n        if (pose) {\r\n            const pos = new Vector3(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                pos.z *= -1;\r\n            }\r\n            this.position.subtractToRef(pos, pos);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                pos.z *= -1;\r\n            }\r\n            pos.negateInPlace();\r\n\r\n            const transform2 = new XRRigidTransform({ x: pos.x, y: pos.y, z: pos.z });\r\n            // Update offset reference to use a new originOffset with the teleported\r\n            // player position and orientation.\r\n            // This new offset needs to be applied to the base ref space.\r\n            this._xrSessionManager.referenceSpace = referenceSpace.getOffsetReferenceSpace(transform2);\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}