{"ast":null,"code":"import { SceneLoader } from \"../Loading/sceneLoader\";\nimport { Logger } from \"../Misc/logger\";\nimport { FilesInputStore } from \"./filesInputStore\";\n/**\r\n * Class used to help managing file picking and drag'n'drop\r\n */\n\nvar FilesInput =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new FilesInput\r\n   * @param engine defines the rendering engine\r\n   * @param scene defines the hosting scene\r\n   * @param sceneLoadedCallback callback called when scene is loaded\r\n   * @param progressCallback callback called to track progress\r\n   * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n   * @param textureLoadingCallback callback called when a texture is loading\r\n   * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n   * @param onReloadCallback callback called when a reload is requested\r\n   * @param errorCallback callback call if an error occurs\r\n   */\n  function FilesInput(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback) {\n    /**\r\n     * Callback called when a file is processed\r\n     */\n    this.onProcessFileCallback = function () {\n      return true;\n    };\n\n    this._engine = engine;\n    this._currentScene = scene;\n    this._sceneLoadedCallback = sceneLoadedCallback;\n    this._progressCallback = progressCallback;\n    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n    this._textureLoadingCallback = textureLoadingCallback;\n    this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n    this._onReloadCallback = onReloadCallback;\n    this._errorCallback = errorCallback;\n  }\n\n  Object.defineProperty(FilesInput, \"FilesToLoad\", {\n    /**\r\n     * List of files ready to be loaded\r\n     */\n    get: function () {\n      return FilesInputStore.FilesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n   * @param elementToMonitor defines the DOM element to track\r\n   */\n\n  FilesInput.prototype.monitorElementForDragNDrop = function (elementToMonitor) {\n    var _this = this;\n\n    if (elementToMonitor) {\n      this._elementToMonitor = elementToMonitor;\n\n      this._dragEnterHandler = function (e) {\n        _this.drag(e);\n      };\n\n      this._dragOverHandler = function (e) {\n        _this.drag(e);\n      };\n\n      this._dropHandler = function (e) {\n        _this.drop(e);\n      };\n\n      this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n\n      this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n\n      this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n    }\n  };\n\n  Object.defineProperty(FilesInput.prototype, \"filesToLoad\", {\n    /** Gets the current list of files to load */\n    get: function () {\n      return this._filesToLoad;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Release all associated resources\r\n   */\n\n  FilesInput.prototype.dispose = function () {\n    if (!this._elementToMonitor) {\n      return;\n    }\n\n    this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n\n    this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n\n    this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n  };\n\n  FilesInput.prototype.renderFunction = function () {\n    if (this._additionalRenderLoopLogicCallback) {\n      this._additionalRenderLoopLogicCallback();\n    }\n\n    if (this._currentScene) {\n      if (this._textureLoadingCallback) {\n        var remaining = this._currentScene.getWaitingItemsCount();\n\n        if (remaining > 0) {\n          this._textureLoadingCallback(remaining);\n        }\n      }\n\n      this._currentScene.render();\n    }\n  };\n\n  FilesInput.prototype.drag = function (e) {\n    e.stopPropagation();\n    e.preventDefault();\n  };\n\n  FilesInput.prototype.drop = function (eventDrop) {\n    eventDrop.stopPropagation();\n    eventDrop.preventDefault();\n    this.loadFiles(eventDrop);\n  };\n\n  FilesInput.prototype._traverseFolder = function (folder, files, remaining, callback) {\n    var _this = this;\n\n    var reader = folder.createReader();\n    var relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n    reader.readEntries(function (entries) {\n      remaining.count += entries.length;\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n\n        if (entry.isFile) {\n          entry.file(function (file) {\n            file.correctName = relativePath + file.name;\n            files.push(file);\n\n            if (--remaining.count === 0) {\n              callback();\n            }\n          });\n        } else if (entry.isDirectory) {\n          _this._traverseFolder(entry, files, remaining, callback);\n        }\n      }\n\n      if (--remaining.count === 0) {\n        callback();\n      }\n    });\n  };\n\n  FilesInput.prototype._processFiles = function (files) {\n    for (var i = 0; i < files.length; i++) {\n      var name = files[i].correctName.toLowerCase();\n      var extension = name.split('.').pop();\n\n      if (!this.onProcessFileCallback(files[i], name, extension)) {\n        continue;\n      }\n\n      if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n        this._sceneFileToLoad = files[i];\n      }\n\n      FilesInput.FilesToLoad[name] = files[i];\n    }\n  };\n  /**\r\n   * Load files from a drop event\r\n   * @param event defines the drop event to use as source\r\n   */\n\n\n  FilesInput.prototype.loadFiles = function (event) {\n    var _this = this; // Handling data transfer via drag'n'drop\n\n\n    if (event && event.dataTransfer && event.dataTransfer.files) {\n      this._filesToLoad = event.dataTransfer.files;\n    } // Handling files from input files\n\n\n    if (event && event.target && event.target.files) {\n      this._filesToLoad = event.target.files;\n    }\n\n    if (!this._filesToLoad || this._filesToLoad.length === 0) {\n      return;\n    }\n\n    if (this._startingProcessingFilesCallback) {\n      this._startingProcessingFilesCallback(this._filesToLoad);\n    }\n\n    if (this._filesToLoad && this._filesToLoad.length > 0) {\n      var files_1 = new Array();\n      var folders = [];\n      var items = event.dataTransfer ? event.dataTransfer.items : null;\n\n      for (var i = 0; i < this._filesToLoad.length; i++) {\n        var fileToLoad = this._filesToLoad[i];\n        var name_1 = fileToLoad.name.toLowerCase();\n        var entry = void 0;\n        fileToLoad.correctName = name_1;\n\n        if (items) {\n          var item = items[i];\n\n          if (item.getAsEntry) {\n            entry = item.getAsEntry();\n          } else if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n          }\n        }\n\n        if (!entry) {\n          files_1.push(fileToLoad);\n        } else {\n          if (entry.isDirectory) {\n            folders.push(entry);\n          } else {\n            files_1.push(fileToLoad);\n          }\n        }\n      }\n\n      if (folders.length === 0) {\n        this._processFiles(files_1);\n\n        this._processReload();\n      } else {\n        var remaining = {\n          count: folders.length\n        };\n\n        for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {\n          var folder = folders_1[_i];\n\n          this._traverseFolder(folder, files_1, remaining, function () {\n            _this._processFiles(files_1);\n\n            if (remaining.count === 0) {\n              _this._processReload();\n            }\n          });\n        }\n      }\n    }\n  };\n\n  FilesInput.prototype._processReload = function () {\n    if (this._onReloadCallback) {\n      this._onReloadCallback(this._sceneFileToLoad);\n    } else {\n      this.reload();\n    }\n  };\n  /**\r\n   * Reload the current scene from the loaded files\r\n   */\n\n\n  FilesInput.prototype.reload = function () {\n    var _this = this; // If a scene file has been provided\n\n\n    if (this._sceneFileToLoad) {\n      if (this._currentScene) {\n        if (Logger.errorsCount > 0) {\n          Logger.ClearLogCache();\n        }\n\n        this._engine.stopRenderLoop();\n      }\n\n      SceneLoader.ShowLoadingScreen = false;\n\n      this._engine.displayLoadingUI();\n\n      SceneLoader.LoadAsync(\"file:\", this._sceneFileToLoad, this._engine, function (progress) {\n        if (_this._progressCallback) {\n          _this._progressCallback(progress);\n        }\n      }).then(function (scene) {\n        if (_this._currentScene) {\n          _this._currentScene.dispose();\n        }\n\n        _this._currentScene = scene;\n\n        if (_this._sceneLoadedCallback) {\n          _this._sceneLoadedCallback(_this._sceneFileToLoad, _this._currentScene);\n        } // Wait for textures and shaders to be ready\n\n\n        _this._currentScene.executeWhenReady(function () {\n          _this._engine.hideLoadingUI();\n\n          _this._engine.runRenderLoop(function () {\n            _this.renderFunction();\n          });\n        });\n      }).catch(function (error) {\n        _this._engine.hideLoadingUI();\n\n        if (_this._errorCallback) {\n          _this._errorCallback(_this._sceneFileToLoad, _this._currentScene, error.message);\n        }\n      });\n    } else {\n      Logger.Error(\"Please provide a valid .babylon file.\");\n    }\n  };\n\n  return FilesInput;\n}();\n\nexport { FilesInput };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/filesInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISceneLoaderProgressEvent, SceneLoader } from \"../Loading/sceneLoader\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { FilesInputStore } from \"./filesInputStore\";\r\nimport { Nullable } from '../types';\r\n\r\n/**\r\n * Class used to help managing file picking and drag'n'drop\r\n */\r\nexport class FilesInput {\r\n    /**\r\n     * List of files ready to be loaded\r\n     */\r\n    public static get FilesToLoad() {\r\n        return FilesInputStore.FilesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Callback called when a file is processed\r\n     */\r\n    public onProcessFileCallback: (file: File, name: string, extension: string) => boolean = () => { return true; };\r\n\r\n    private _engine: Engine;\r\n    private _currentScene: Nullable<Scene>;\r\n    private _sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>;\r\n    private _progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>;\r\n    private _additionalRenderLoopLogicCallback: Nullable<() => void>;\r\n    private _textureLoadingCallback: Nullable<(remaining: number) => void>;\r\n    private _startingProcessingFilesCallback: Nullable<(files?: File[]) => void>;\r\n    private _onReloadCallback: Nullable<(sceneFile: File) => void>;\r\n    private _errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>;\r\n    private _elementToMonitor: HTMLElement;\r\n\r\n    private _sceneFileToLoad: File;\r\n    private _filesToLoad: File[];\r\n\r\n    /**\r\n     * Creates a new FilesInput\r\n     * @param engine defines the rendering engine\r\n     * @param scene defines the hosting scene\r\n     * @param sceneLoadedCallback callback called when scene is loaded\r\n     * @param progressCallback callback called to track progress\r\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\r\n     * @param textureLoadingCallback callback called when a texture is loading\r\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\r\n     * @param onReloadCallback callback called when a reload is requested\r\n     * @param errorCallback callback call if an error occurs\r\n     */\r\n    constructor(engine: Engine, scene: Nullable<Scene>,\r\n        sceneLoadedCallback: Nullable<(sceneFile: File, scene: Scene) => void>,\r\n        progressCallback: Nullable<(progress: ISceneLoaderProgressEvent) => void>,\r\n        additionalRenderLoopLogicCallback: Nullable<() => void>,\r\n        textureLoadingCallback: Nullable<(remaining: number) => void>,\r\n        startingProcessingFilesCallback: Nullable<(files?: File[]) => void>,\r\n        onReloadCallback: Nullable<(sceneFile: File) => void>,\r\n        errorCallback: Nullable<(sceneFile: File, scene: Nullable<Scene>, message: string) => void>) {\r\n        this._engine = engine;\r\n        this._currentScene = scene;\r\n\r\n        this._sceneLoadedCallback = sceneLoadedCallback;\r\n        this._progressCallback = progressCallback;\r\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\r\n        this._textureLoadingCallback = textureLoadingCallback;\r\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\r\n        this._onReloadCallback = onReloadCallback;\r\n        this._errorCallback = errorCallback;\r\n    }\r\n\r\n    private _dragEnterHandler: (e: any) => void;\r\n    private _dragOverHandler: (e: any) => void;\r\n    private _dropHandler: (e: any) => void;\r\n\r\n    /**\r\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\r\n     * @param elementToMonitor defines the DOM element to track\r\n     */\r\n    public monitorElementForDragNDrop(elementToMonitor: HTMLElement): void {\r\n        if (elementToMonitor) {\r\n            this._elementToMonitor = elementToMonitor;\r\n\r\n            this._dragEnterHandler = (e) => { this.drag(e); };\r\n            this._dragOverHandler = (e) => { this.drag(e); };\r\n            this._dropHandler = (e) => { this.drop(e); };\r\n\r\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\r\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\r\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\r\n        }\r\n    }\r\n\r\n    /** Gets the current list of files to load */\r\n    public get filesToLoad() {\r\n        return this._filesToLoad;\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources\r\n     */\r\n    public dispose() {\r\n        if (!this._elementToMonitor) {\r\n            return;\r\n        }\r\n\r\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\r\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\r\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\r\n    }\r\n\r\n    private renderFunction(): void {\r\n        if (this._additionalRenderLoopLogicCallback) {\r\n            this._additionalRenderLoopLogicCallback();\r\n        }\r\n\r\n        if (this._currentScene) {\r\n            if (this._textureLoadingCallback) {\r\n                var remaining = this._currentScene.getWaitingItemsCount();\r\n\r\n                if (remaining > 0) {\r\n                    this._textureLoadingCallback(remaining);\r\n                }\r\n            }\r\n            this._currentScene.render();\r\n        }\r\n    }\r\n\r\n    private drag(e: DragEvent): void {\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n    }\r\n\r\n    private drop(eventDrop: DragEvent): void {\r\n        eventDrop.stopPropagation();\r\n        eventDrop.preventDefault();\r\n\r\n        this.loadFiles(eventDrop);\r\n    }\r\n\r\n    private _traverseFolder(folder: any, files: Array<any>, remaining: { count: number }, callback: () => void) {\r\n        var reader = folder.createReader();\r\n        var relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\r\n        reader.readEntries((entries: any) => {\r\n            remaining.count += entries.length;\r\n            for (let entry of entries) {\r\n                if (entry.isFile) {\r\n                    entry.file((file: any) => {\r\n                        file.correctName = relativePath + file.name;\r\n                        files.push(file);\r\n\r\n                        if (--remaining.count === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                }\r\n                else if (entry.isDirectory) {\r\n                    this._traverseFolder(entry, files, remaining, callback);\r\n                }\r\n            }\r\n\r\n            if (--remaining.count === 0) {\r\n                callback();\r\n            }\r\n        });\r\n    }\r\n\r\n    private _processFiles(files: Array<any>): void {\r\n        for (var i = 0; i < files.length; i++) {\r\n            var name = files[i].correctName.toLowerCase();\r\n            var extension = name.split('.').pop();\r\n\r\n            if (!this.onProcessFileCallback(files[i], name, extension)) {\r\n                continue;\r\n            }\r\n\r\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\r\n                this._sceneFileToLoad = files[i];\r\n            }\r\n\r\n            FilesInput.FilesToLoad[name] = files[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load files from a drop event\r\n     * @param event defines the drop event to use as source\r\n     */\r\n    public loadFiles(event: any): void {\r\n        // Handling data transfer via drag'n'drop\r\n        if (event && event.dataTransfer && event.dataTransfer.files) {\r\n            this._filesToLoad = event.dataTransfer.files;\r\n        }\r\n\r\n        // Handling files from input files\r\n        if (event && event.target && event.target.files) {\r\n            this._filesToLoad = event.target.files;\r\n        }\r\n\r\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this._startingProcessingFilesCallback) {\r\n            this._startingProcessingFilesCallback(this._filesToLoad);\r\n        }\r\n\r\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\r\n            let files = new Array<File>();\r\n            let folders = [];\r\n            var items = event.dataTransfer ? event.dataTransfer.items : null;\r\n\r\n            for (var i = 0; i < this._filesToLoad.length; i++) {\r\n                let fileToLoad: any = this._filesToLoad[i];\r\n                let name = fileToLoad.name.toLowerCase();\r\n                let entry;\r\n\r\n                fileToLoad.correctName = name;\r\n\r\n                if (items) {\r\n                    let item = items[i];\r\n                    if (item.getAsEntry) {\r\n                        entry = item.getAsEntry();\r\n                    } else if (item.webkitGetAsEntry) {\r\n                        entry = item.webkitGetAsEntry();\r\n                    }\r\n                }\r\n\r\n                if (!entry) {\r\n                    files.push(fileToLoad);\r\n                } else {\r\n                    if (entry.isDirectory) {\r\n                        folders.push(entry);\r\n                    } else {\r\n                        files.push(fileToLoad);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (folders.length === 0) {\r\n                this._processFiles(files);\r\n                this._processReload();\r\n            } else {\r\n                var remaining = { count: folders.length };\r\n                for (var folder of folders) {\r\n                    this._traverseFolder(folder, files, remaining, () => {\r\n                        this._processFiles(files);\r\n\r\n                        if (remaining.count === 0) {\r\n                            this._processReload();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private _processReload() {\r\n        if (this._onReloadCallback) {\r\n            this._onReloadCallback(this._sceneFileToLoad);\r\n        }\r\n        else {\r\n            this.reload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reload the current scene from the loaded files\r\n     */\r\n    public reload() {\r\n        // If a scene file has been provided\r\n        if (this._sceneFileToLoad) {\r\n            if (this._currentScene) {\r\n                if (Logger.errorsCount > 0) {\r\n                    Logger.ClearLogCache();\r\n                }\r\n                this._engine.stopRenderLoop();\r\n            }\r\n\r\n            SceneLoader.ShowLoadingScreen = false;\r\n            this._engine.displayLoadingUI();\r\n            SceneLoader.LoadAsync(\"file:\", this._sceneFileToLoad, this._engine, (progress) => {\r\n                if (this._progressCallback) {\r\n                    this._progressCallback(progress);\r\n                }\r\n            }).then((scene) => {\r\n                if (this._currentScene) {\r\n                    this._currentScene.dispose();\r\n                }\r\n\r\n                this._currentScene = scene;\r\n\r\n                if (this._sceneLoadedCallback) {\r\n                    this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\r\n                }\r\n\r\n                // Wait for textures and shaders to be ready\r\n                this._currentScene.executeWhenReady(() => {\r\n                    this._engine.hideLoadingUI();\r\n                    this._engine.runRenderLoop(() => {\r\n                        this.renderFunction();\r\n                    });\r\n                });\r\n            }).catch((error) => {\r\n                this._engine.hideLoadingUI();\r\n                if (this._errorCallback) {\r\n                    this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            Logger.Error(\"Please provide a valid .babylon file.\");\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}