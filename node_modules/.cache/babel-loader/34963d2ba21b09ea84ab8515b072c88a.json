{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\n\nvar MorphTarget =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new MorphTarget\r\n   * @param name defines the name of the target\r\n   * @param influence defines the influence to use\r\n   * @param scene defines the scene the morphtarget belongs to\r\n   */\n  function MorphTarget(\n  /** defines the name of the target */\n  name, influence, scene) {\n    if (influence === void 0) {\n      influence = 0;\n    }\n\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    /**\r\n     * Gets or sets the list of animations\r\n     */\n\n    this.animations = new Array();\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\r\n     * Observable raised when the influence changes\r\n     */\n\n    this.onInfluenceChanged = new Observable();\n    /** @hidden */\n\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n\n  Object.defineProperty(MorphTarget.prototype, \"influence\", {\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\n    get: function () {\n      return this._influence;\n    },\n    set: function (influence) {\n      if (this._influence === influence) {\n        return;\n      }\n\n      var previous = this._influence;\n      this._influence = influence;\n\n      if (this.onInfluenceChanged.hasObservers()) {\n        this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"animationPropertiesOverride\", {\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\n    get: function () {\n      if (!this._animationPropertiesOverride && this._scene) {\n        return this._scene.animationPropertiesOverride;\n      }\n\n      return this._animationPropertiesOverride;\n    },\n    set: function (value) {\n      this._animationPropertiesOverride = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"uniqueId\", {\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\n    get: function () {\n      return this._uniqueId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasPositions\", {\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\n    get: function () {\n      return !!this._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasNormals\", {\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\n    get: function () {\n      return !!this._normals;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasTangents\", {\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\n    get: function () {\n      return !!this._tangents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTarget.prototype, \"hasUVs\", {\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\n    get: function () {\n      return !!this._uvs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Affects position data to this target\r\n   * @param data defines the position data to use\r\n   */\n\n  MorphTarget.prototype.setPositions = function (data) {\n    var hadPositions = this.hasPositions;\n    this._positions = data;\n\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the position data stored in this target\r\n   * @returns a FloatArray containing the position data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getPositions = function () {\n    return this._positions;\n  };\n  /**\r\n   * Affects normal data to this target\r\n   * @param data defines the normal data to use\r\n   */\n\n\n  MorphTarget.prototype.setNormals = function (data) {\n    var hadNormals = this.hasNormals;\n    this._normals = data;\n\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the normal data stored in this target\r\n   * @returns a FloatArray containing the normal data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getNormals = function () {\n    return this._normals;\n  };\n  /**\r\n   * Affects tangent data to this target\r\n   * @param data defines the tangent data to use\r\n   */\n\n\n  MorphTarget.prototype.setTangents = function (data) {\n    var hadTangents = this.hasTangents;\n    this._tangents = data;\n\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the tangent data stored in this target\r\n   * @returns a FloatArray containing the tangent data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getTangents = function () {\n    return this._tangents;\n  };\n  /**\r\n   * Affects texture coordinates data to this target\r\n   * @param data defines the texture coordinates data to use\r\n   */\n\n\n  MorphTarget.prototype.setUVs = function (data) {\n    var hadUVs = this.hasUVs;\n    this._uvs = data;\n\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  };\n  /**\r\n   * Gets the texture coordinates data stored in this target\r\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n   */\n\n\n  MorphTarget.prototype.getUVs = function () {\n    return this._uvs;\n  };\n  /**\r\n   * Clone the current target\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.prototype.clone = function () {\n    var _this = this;\n\n    var newOne = SerializationHelper.Clone(function () {\n      return new MorphTarget(_this.name, _this.influence, _this._scene);\n    }, this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  };\n  /**\r\n   * Serializes the current target into a Serialization object\r\n   * @returns the serialized object\r\n   */\n\n\n  MorphTarget.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    } // Animations\n\n\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  };\n  /**\r\n   * Returns the string \"MorphTarget\"\r\n   * @returns \"MorphTarget\"\r\n   */\n\n\n  MorphTarget.prototype.getClassName = function () {\n    return \"MorphTarget\";\n  }; // Statics\n\n  /**\r\n   * Creates a new target from serialized data\r\n   * @param serializationObject defines the serialized data to use\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.Parse = function (serializationObject) {\n    var result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    } // Animations\n\n\n    if (serializationObject.animations) {\n      for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        var parsedAnimation = serializationObject.animations[animationIndex];\n\n        var internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\n\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Creates a MorphTarget from mesh data\r\n   * @param mesh defines the source mesh\r\n   * @param name defines the name to use for the new target\r\n   * @param influence defines the influence to attach to the target\r\n   * @returns a new MorphTarget\r\n   */\n\n\n  MorphTarget.FromMesh = function (mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n\n    var result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n\n    return result;\n  };\n\n  __decorate([serialize()], MorphTarget.prototype, \"id\", void 0);\n\n  return MorphTarget;\n}();\n\nexport { MorphTarget };","map":{"version":3,"sources":["../../../sourceES6/core/Morph/morphTarget.ts"],"names":[],"mappings":"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","sourcesContent":["import { IAnimatable } from '../Animations/animatable.interface';\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable, FloatArray } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @hidden */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        var previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string, influence = 0, scene: Nullable<Scene> = null) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        let newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any): MorphTarget {\r\n        var result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (var animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                var parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        var result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}