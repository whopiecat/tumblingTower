{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matrix } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { _TypeStore } from \"../../Misc/typeStore\"; // Ensures Raw texture are included\n\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\n\nvar ColorGradingTexture =\n/** @class */\nfunction (_super) {\n  __extends(ColorGradingTexture, _super);\n  /**\r\n   * Instantiates a ColorGradingTexture from the following parameters.\r\n   *\r\n   * @param url The location of the color gradind data (currently only supporting 3dl)\r\n   * @param sceneOrEngine The scene or engine the texture will be used in\r\n   * @param onLoad defines a callback triggered when the texture has been loaded\r\n   */\n\n\n  function ColorGradingTexture(url, sceneOrEngine, onLoad) {\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    var _this = _super.call(this, sceneOrEngine) || this;\n\n    if (!url) {\n      return _this;\n    }\n\n    _this._textureMatrix = Matrix.Identity();\n    _this.name = url;\n    _this.url = url;\n    _this._onLoad = onLoad;\n    _this._texture = _this._getFromCache(url, true);\n\n    if (!_this._texture) {\n      var scene = _this.getScene();\n\n      if (scene) {\n        if (!scene.useDelayedTextureLoading) {\n          _this.loadTexture();\n        } else {\n          _this.delayLoadState = 4;\n        }\n      } else {\n        _this.loadTexture();\n      }\n    } else {\n      _this._triggerOnLoad();\n    }\n\n    return _this;\n  }\n  /**\r\n   * Fires the onload event from the constructor if requested.\r\n   */\n\n\n  ColorGradingTexture.prototype._triggerOnLoad = function () {\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  };\n  /**\r\n   * Returns the texture matrix used in most of the material.\r\n   * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n   */\n\n\n  ColorGradingTexture.prototype.getTextureMatrix = function () {\n    return this._textureMatrix;\n  };\n  /**\r\n   * Occurs when the file being loaded is a .3dl LUT file.\r\n   */\n\n\n  ColorGradingTexture.prototype.load3dlTexture = function () {\n    var _this = this;\n\n    var engine = this._getEngine();\n\n    var texture;\n\n    if (engine.webGLVersion === 1) {\n      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n    } else {\n      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n    }\n\n    this._texture = texture;\n    this._texture.isReady = false;\n    this.isCube = false;\n    this.is3D = engine.webGLVersion > 1;\n    this.wrapU = 0;\n    this.wrapV = 0;\n    this.wrapR = 0;\n    this.anisotropicFilteringLevel = 1;\n\n    var callback = function (text) {\n      if (typeof text !== \"string\") {\n        return;\n      }\n\n      var data = null;\n      var tempData = null;\n      var line;\n      var lines = text.split('\\n');\n      var size = 0,\n          pixelIndexW = 0,\n          pixelIndexH = 0,\n          pixelIndexSlice = 0;\n      var maxColor = 0;\n\n      for (var i = 0; i < lines.length; i++) {\n        line = lines[i];\n\n        if (!ColorGradingTexture._noneEmptyLineRegex.test(line)) {\n          continue;\n        }\n\n        if (line.indexOf('#') === 0) {\n          continue;\n        }\n\n        var words = line.split(\" \");\n\n        if (size === 0) {\n          // Number of space + one\n          size = words.length;\n          data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n\n          tempData = new Float32Array(size * size * size * 4);\n          continue;\n        }\n\n        if (size != 0) {\n          var r = Math.max(parseInt(words[0]), 0);\n          var g = Math.max(parseInt(words[1]), 0);\n          var b = Math.max(parseInt(words[2]), 0);\n          maxColor = Math.max(r, maxColor);\n          maxColor = Math.max(g, maxColor);\n          maxColor = Math.max(b, maxColor);\n          var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n\n          if (tempData) {\n            tempData[pixelStorageIndex + 0] = r;\n            tempData[pixelStorageIndex + 1] = g;\n            tempData[pixelStorageIndex + 2] = b;\n          } // Keep for reference in case of back compat problems.\n          // pixelIndexSlice++;\n          // if (pixelIndexSlice % size == 0) {\n          //     pixelIndexH++;\n          //     pixelIndexSlice = 0;\n          //     if (pixelIndexH % size == 0) {\n          //         pixelIndexW++;\n          //         pixelIndexH = 0;\n          //     }\n          // }\n\n\n          pixelIndexH++;\n\n          if (pixelIndexH % size == 0) {\n            pixelIndexSlice++;\n            pixelIndexH = 0;\n\n            if (pixelIndexSlice % size == 0) {\n              pixelIndexW++;\n              pixelIndexSlice = 0;\n            }\n          }\n        }\n      }\n\n      if (tempData && data) {\n        for (var i = 0; i < tempData.length; i++) {\n          if (i > 0 && (i + 1) % 4 === 0) {\n            data[i] = 255;\n          } else {\n            var value = tempData[i];\n            data[i] = value / maxColor * 255;\n          }\n        }\n      }\n\n      if (texture.is3D) {\n        texture.updateSize(size, size, size);\n        engine.updateRawTexture3D(texture, data, 5, false);\n      } else {\n        texture.updateSize(size * size, size);\n        engine.updateRawTexture(texture, data, 5, false);\n      }\n\n      texture.isReady = true;\n\n      _this._triggerOnLoad();\n    };\n\n    var scene = this.getScene();\n\n    if (scene) {\n      scene._loadFile(this.url, callback);\n    } else {\n      engine._loadFile(this.url, callback);\n    }\n\n    return this._texture;\n  };\n  /**\r\n   * Starts the loading process of the texture.\r\n   */\n\n\n  ColorGradingTexture.prototype.loadTexture = function () {\n    if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n      this.load3dlTexture();\n    }\n  };\n  /**\r\n   * Clones the color gradind texture.\r\n   */\n\n\n  ColorGradingTexture.prototype.clone = function () {\n    var newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()); // Base texture\n\n    newTexture.level = this.level;\n    return newTexture;\n  };\n  /**\r\n   * Called during delayed load for textures.\r\n   */\n\n\n  ColorGradingTexture.prototype.delayLoad = function () {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, true);\n\n    if (!this._texture) {\n      this.loadTexture();\n    }\n  };\n  /**\r\n   * Parses a color grading texture serialized by Babylon.\r\n   * @param parsedTexture The texture information being parsedTexture\r\n   * @param scene The scene to load the texture in\r\n   * @param rootUrl The root url of the data assets to load\r\n   * @return A color gradind texture\r\n   */\n\n\n  ColorGradingTexture.Parse = function (parsedTexture, scene) {\n    var texture = null;\n\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new ColorGradingTexture(parsedTexture.name, scene);\n      texture.name = parsedTexture.name;\n      texture.level = parsedTexture.level;\n    }\n\n    return texture;\n  };\n  /**\r\n   * Serializes the LUT texture to json format.\r\n   */\n\n\n  ColorGradingTexture.prototype.serialize = function () {\n    if (!this.name) {\n      return null;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.level = this.level;\n    serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n    return serializationObject;\n  };\n  /**\r\n   * Empty line regex stored for GC.\r\n   */\n\n\n  ColorGradingTexture._noneEmptyLineRegex = /\\S+/;\n  return ColorGradingTexture;\n}(BaseTexture);\n\nexport { ColorGradingTexture };\n_TypeStore.RegisteredTypes[\"BABYLON.ColorGradingTexture\"] = ColorGradingTexture;","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/colorGradingTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\n\r\nimport { _TypeStore } from \"../../Misc/typeStore\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\n// Ensures Raw texture are included\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\r\nexport class ColorGradingTexture extends BaseTexture {\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * Empty line regex stored for GC.\r\n     */\r\n    private static _noneEmptyLineRegex = /\\S+/;\r\n\r\n    private _textureMatrix: Matrix;\r\n    private _onLoad: Nullable<() => void>;\r\n\r\n    /**\r\n     * Instantiates a ColorGradingTexture from the following parameters.\r\n     *\r\n     * @param url The location of the color gradind data (currently only supporting 3dl)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     */\r\n    constructor(url: string, sceneOrEngine: Scene | ThinEngine, onLoad: Nullable<() => void> = null) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.name = url;\r\n        this.url = url;\r\n        this._onLoad = onLoad;\r\n\r\n        this._texture = this._getFromCache(url, true);\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (scene) {\r\n                if (!scene.useDelayedTextureLoading) {\r\n                    this.loadTexture();\r\n                } else {\r\n                    this.delayLoadState = 4;\r\n                }\r\n            }\r\n            else {\r\n                this.loadTexture();\r\n            }\r\n        }\r\n        else {\r\n            this._triggerOnLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fires the onload event from the constructor if requested.\r\n     */\r\n    private _triggerOnLoad(): void {\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture matrix used in most of the material.\r\n     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file being loaded is a .3dl LUT file.\r\n     */\r\n    private load3dlTexture() {\r\n        var engine = this._getEngine()!;\r\n        var texture: InternalTexture;\r\n        if (engine.webGLVersion === 1) {\r\n            texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\r\n        }\r\n        else {\r\n            texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\r\n        }\r\n\r\n        this._texture = texture;\r\n        this._texture.isReady = false;\r\n\r\n        this.isCube = false;\r\n        this.is3D = engine.webGLVersion > 1;\r\n        this.wrapU = 0;\r\n        this.wrapV = 0;\r\n        this.wrapR = 0;\r\n        this.anisotropicFilteringLevel = 1;\r\n\r\n        var callback = (text: string | ArrayBuffer) => {\r\n\r\n            if (typeof text !== \"string\") {\r\n                return;\r\n            }\r\n\r\n            var data: Nullable<Uint8Array> = null;\r\n            var tempData: Nullable<Float32Array> = null;\r\n\r\n            var line: string;\r\n            var lines = text.split('\\n');\r\n            var size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;\r\n            var maxColor = 0;\r\n\r\n            for (let i = 0; i < lines.length; i++) {\r\n                line = lines[i];\r\n\r\n                if (!ColorGradingTexture._noneEmptyLineRegex.test(line)) {\r\n                    continue;\r\n                }\r\n\r\n                if (line.indexOf('#') === 0) {\r\n                    continue;\r\n                }\r\n\r\n                var words = line.split(\" \");\r\n                if (size === 0) {\r\n                    // Number of space + one\r\n                    size = words.length;\r\n                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\r\n                    tempData = new Float32Array(size * size * size * 4);\r\n                    continue;\r\n                }\r\n\r\n                if (size != 0) {\r\n                    var r = Math.max(parseInt(words[0]), 0);\r\n                    var g = Math.max(parseInt(words[1]), 0);\r\n                    var b = Math.max(parseInt(words[2]), 0);\r\n\r\n                    maxColor = Math.max(r, maxColor);\r\n                    maxColor = Math.max(g, maxColor);\r\n                    maxColor = Math.max(b, maxColor);\r\n\r\n                    var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\r\n\r\n                    if (tempData) {\r\n                        tempData[pixelStorageIndex + 0] = r;\r\n                        tempData[pixelStorageIndex + 1] = g;\r\n                        tempData[pixelStorageIndex + 2] = b;\r\n                    }\r\n\r\n                    // Keep for reference in case of back compat problems.\r\n                    // pixelIndexSlice++;\r\n                    // if (pixelIndexSlice % size == 0) {\r\n                    //     pixelIndexH++;\r\n                    //     pixelIndexSlice = 0;\r\n                    //     if (pixelIndexH % size == 0) {\r\n                    //         pixelIndexW++;\r\n                    //         pixelIndexH = 0;\r\n                    //     }\r\n                    // }\r\n\r\n                    pixelIndexH++;\r\n                    if (pixelIndexH % size == 0) {\r\n                        pixelIndexSlice++;\r\n                        pixelIndexH = 0;\r\n                        if (pixelIndexSlice % size == 0) {\r\n                            pixelIndexW++;\r\n                            pixelIndexSlice = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (tempData && data) {\r\n                for (let i = 0; i < tempData.length; i++) {\r\n                    if (i > 0 && (i + 1) % 4 === 0) {\r\n                        data[i] = 255;\r\n                    }\r\n                    else {\r\n                        var value = tempData[i];\r\n                        data[i] = (value / maxColor * 255);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture.is3D) {\r\n                texture.updateSize(size, size, size);\r\n                engine.updateRawTexture3D(texture, data, 5, false);\r\n            }\r\n            else {\r\n                texture.updateSize(size * size, size);\r\n                engine.updateRawTexture(texture, data, 5, false);\r\n            }\r\n\r\n            texture.isReady = true;\r\n            this._triggerOnLoad();\r\n        };\r\n\r\n        let scene = this.getScene();\r\n        if (scene) {\r\n            scene._loadFile(this.url, callback);\r\n        }\r\n        else {\r\n            engine._loadFile(this.url, callback);\r\n        }\r\n\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Starts the loading process of the texture.\r\n     */\r\n    private loadTexture() {\r\n        if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == (this.url.length - 4)) {\r\n            this.load3dlTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the color gradind texture.\r\n     */\r\n    public clone(): ColorGradingTexture {\r\n        var newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()!);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Called during delayed load for textures.\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== 4) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = 1;\r\n        this._texture = this._getFromCache(this.url, true);\r\n\r\n        if (!this._texture) {\r\n            this.loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a color grading texture serialized by Babylon.\r\n     * @param parsedTexture The texture information being parsedTexture\r\n     * @param scene The scene to load the texture in\r\n     * @param rootUrl The root url of the data assets to load\r\n     * @return A color gradind texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): Nullable<ColorGradingTexture> {\r\n        var texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new ColorGradingTexture(parsedTexture.name, scene);\r\n            texture.name = parsedTexture.name;\r\n            texture.level = parsedTexture.level;\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the LUT texture to json format.\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.level = this.level;\r\n        serializationObject.customType = \"BABYLON.ColorGradingTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ColorGradingTexture\"] = ColorGradingTexture;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}