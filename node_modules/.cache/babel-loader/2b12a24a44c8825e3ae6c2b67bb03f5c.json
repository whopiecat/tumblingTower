{"ast":null,"code":"import { Tools } from \"../Misc/tools\";\nimport { Color4 } from '../Maths/math.color';\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { ParticleSystemSet } from \"./particleSystemSet\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { WebRequest } from '../Misc/webRequest';\n/**\r\n * This class is made for on one-liner static method to help creating particle system set.\r\n */\n\nvar ParticleHelper =\n/** @class */\nfunction () {\n  function ParticleHelper() {}\n  /**\r\n   * Create a default particle system that you can tweak\r\n   * @param emitter defines the emitter to use\r\n   * @param capacity defines the system capacity (default is 500 particles)\r\n   * @param scene defines the hosting scene\r\n   * @param useGPU defines if a GPUParticleSystem must be created (default is false)\r\n   * @returns the new Particle system\r\n   */\n\n\n  ParticleHelper.CreateDefault = function (emitter, capacity, scene, useGPU) {\n    if (capacity === void 0) {\n      capacity = 500;\n    }\n\n    if (useGPU === void 0) {\n      useGPU = false;\n    }\n\n    var system;\n\n    if (useGPU) {\n      system = new GPUParticleSystem(\"default system\", {\n        capacity: capacity\n      }, scene);\n    } else {\n      system = new ParticleSystem(\"default system\", capacity, scene);\n    }\n\n    system.emitter = emitter;\n    system.particleTexture = new Texture(\"https://www.babylonjs.com/assets/Flare.png\", system.getScene());\n    system.createConeEmitter(0.1, Math.PI / 4); // Particle color\n\n    system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0); // Particle Size\n\n    system.minSize = 0.1;\n    system.maxSize = 0.1; // Emission speed\n\n    system.minEmitPower = 2;\n    system.maxEmitPower = 2; // Update speed\n\n    system.updateSpeed = 1 / 60;\n    system.emitRate = 30;\n    return system;\n  };\n  /**\r\n   * This is the main static method (one-liner) of this helper to create different particle systems\r\n   * @param type This string represents the type to the particle system to create\r\n   * @param scene The scene where the particle system should live\r\n   * @param gpu If the system will use gpu\r\n   * @returns the ParticleSystemSet created\r\n   */\n\n\n  ParticleHelper.CreateAsync = function (type, scene, gpu) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    var token = {};\n\n    scene._addPendingData(token);\n\n    return new Promise(function (resolve, reject) {\n      if (gpu && !GPUParticleSystem.IsSupported) {\n        scene._removePendingData(token);\n\n        return reject(\"Particle system with GPU is not supported.\");\n      }\n\n      Tools.LoadFile(ParticleHelper.BaseAssetsUrl + \"/systems/\" + type + \".json\", function (data) {\n        scene._removePendingData(token);\n\n        var newData = JSON.parse(data.toString());\n        return resolve(ParticleSystemSet.Parse(newData, scene, gpu));\n      }, undefined, undefined, undefined, function () {\n        scene._removePendingData(token);\n\n        return reject(\"An error occured while the creation of your particle system. Check if your type '\" + type + \"' exists.\");\n      });\n    });\n  };\n  /**\r\n   * Static function used to export a particle system to a ParticleSystemSet variable.\r\n   * Please note that the emitter shape is not exported\r\n   * @param systems defines the particle systems to export\r\n   * @returns the created particle system set\r\n   */\n\n\n  ParticleHelper.ExportSet = function (systems) {\n    var set = new ParticleSystemSet();\n\n    for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {\n      var system = systems_1[_i];\n      set.systems.push(system);\n    }\n\n    return set;\n  };\n  /**\r\n   * Creates a particle system from a snippet saved in a remote file\r\n   * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @param gpu If the system will use gpu\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new particle system\r\n   */\n\n\n  ParticleHelper.ParseFromFileAsync = function (name, url, scene, gpu, rootUrl) {\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n            var output = void 0;\n\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n            }\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the particle system\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a particle system from a snippet saved by the particle system editor\r\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n   * @param scene defines the hosting scene\r\n   * @param gpu If the system will use gpu\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new particle system\r\n   */\n\n\n  ParticleHelper.CreateFromSnippetAsync = function (snippetId, scene, gpu, rootUrl) {\n    var _this = this;\n\n    if (gpu === void 0) {\n      gpu = false;\n    }\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      var system = this.CreateDefault(null);\n      system.start();\n      return Promise.resolve(system);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.particleSystem);\n            var output = void 0;\n\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n            }\n\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\r\n   * Gets or sets base Assets URL\r\n   */\n\n\n  ParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n  /** Define the Url to load snippets */\n\n  ParticleHelper.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return ParticleHelper;\n}();\n\nexport { ParticleHelper };","map":{"version":3,"sources":["../../../sourceES6/core/Particles/particleHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\nimport { Scene } from \"../scene\";\nimport { Tools } from \"../Misc/tools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Color4 } from '../Maths/math.color';\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { IParticleSystem } from \"./IParticleSystem\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { ParticleSystemSet } from \"./particleSystemSet\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { WebRequest } from '../Misc/webRequest';\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\nexport class ParticleHelper {\n    /**\n     * Gets or sets base Assets URL\n     */\n    public static BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n\n    /** Define the Url to load snippets */\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\n\n    /**\n     * Create a default particle system that you can tweak\n     * @param emitter defines the emitter to use\n     * @param capacity defines the system capacity (default is 500 particles)\n     * @param scene defines the hosting scene\n     * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n     * @returns the new Particle system\n     */\n    public static CreateDefault(emitter: Nullable<AbstractMesh | Vector3>, capacity = 500, scene?: Scene, useGPU = false): IParticleSystem {\n        var system: IParticleSystem;\n\n        if (useGPU) {\n            system = new GPUParticleSystem(\"default system\", { capacity: capacity }, scene!);\n        } else {\n            system = new ParticleSystem(\"default system\", capacity, scene!);\n        }\n\n        system.emitter = emitter;\n        system.particleTexture = new Texture(\"https://www.babylonjs.com/assets/Flare.png\", system.getScene());\n        system.createConeEmitter(0.1, Math.PI / 4);\n\n        // Particle color\n        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\n\n        // Particle Size\n        system.minSize = 0.1;\n        system.maxSize = 0.1;\n\n        // Emission speed\n        system.minEmitPower = 2;\n        system.maxEmitPower = 2;\n\n        // Update speed\n        system.updateSpeed = 1 / 60;\n\n        system.emitRate = 30;\n\n        return system;\n    }\n\n    /**\n     * This is the main static method (one-liner) of this helper to create different particle systems\n     * @param type This string represents the type to the particle system to create\n     * @param scene The scene where the particle system should live\n     * @param gpu If the system will use gpu\n     * @returns the ParticleSystemSet created\n     */\n    public static CreateAsync(type: string, scene: Nullable<Scene>, gpu: boolean = false): Promise<ParticleSystemSet> {\n\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n\n        let token = {};\n\n        scene!._addPendingData(token);\n\n        return new Promise((resolve, reject) => {\n            if (gpu && !GPUParticleSystem.IsSupported) {\n                scene!._removePendingData(token);\n                return reject(\"Particle system with GPU is not supported.\");\n            }\n\n            Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, (data) => {\n                scene!._removePendingData(token);\n                const newData = JSON.parse(data.toString());\n                return resolve(ParticleSystemSet.Parse(newData, scene!, gpu));\n            }, undefined, undefined, undefined, () => {\n                scene!._removePendingData(token);\n                return reject(`An error occured while the creation of your particle system. Check if your type '${type}' exists.`);\n            });\n\n        });\n    }\n\n    /**\n     * Static function used to export a particle system to a ParticleSystemSet variable.\n     * Please note that the emitter shape is not exported\n     * @param systems defines the particle systems to export\n     * @returns the created particle system set\n     */\n    public static ExportSet(systems: IParticleSystem[]): ParticleSystemSet {\n        var set = new ParticleSystemSet();\n\n        for (var system of systems) {\n            set.systems.push(system);\n        }\n\n        return set;\n    }\n\n    /**\n     * Creates a particle system from a snippet saved in a remote file\n     * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new particle system\n     */\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\"): Promise<IParticleSystem> {\n\n        return new Promise((resolve, reject) => {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        let serializationObject = JSON.parse(request.responseText);\n                        let output: IParticleSystem;\n\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        } else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        }\n\n                        if (name) {\n                            output.name = name;\n                        }\n\n                        resolve(output);\n                    } else {\n                        reject(\"Unable to load the particle system\");\n                    }\n                }\n            });\n\n            request.open(\"GET\", url);\n            request.send();\n        });\n    }\n\n    /**\n     * Creates a particle system from a snippet saved by the particle system editor\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n     * @param scene defines the hosting scene\n     * @param gpu If the system will use gpu\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new particle system\n     */\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\"): Promise<IParticleSystem> {\n        if (snippetId === \"_BLANK\") {\n            let system = this.CreateDefault(null);\n            system.start();\n            return Promise.resolve(system);\n        }\n\n        return new Promise((resolve, reject) => {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        let serializationObject = JSON.parse(snippet.particleSystem);\n                        let output: IParticleSystem;\n\n                        if (gpu) {\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        } else {\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl);\n                        }\n                        output.snippetId = snippetId;\n\n                        resolve(output);\n                    } else {\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}