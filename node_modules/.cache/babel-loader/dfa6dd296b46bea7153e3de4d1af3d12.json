{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractScene } from \"./abstractScene\";\nimport { Mesh } from \"./Meshes/mesh\";\nimport { Logger } from './Misc/logger';\nimport { EngineStore } from './Engines/engineStore';\n/**\r\n * Set of assets to keep when moving a scene into an asset container.\r\n */\n\nvar KeepAssets =\n/** @class */\nfunction (_super) {\n  __extends(KeepAssets, _super);\n\n  function KeepAssets() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return KeepAssets;\n}(AbstractScene);\n\nexport { KeepAssets };\n/**\r\n * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function\r\n */\n\nvar InstantiatedEntries =\n/** @class */\nfunction () {\n  function InstantiatedEntries() {\n    /**\r\n     * List of new root nodes (eg. nodes with no parent)\r\n     */\n    this.rootNodes = [];\n    /**\r\n     * List of new skeletons\r\n     */\n\n    this.skeletons = [];\n    /**\r\n     * List of new animation groups\r\n     */\n\n    this.animationGroups = [];\n  }\n\n  return InstantiatedEntries;\n}();\n\nexport { InstantiatedEntries };\n/**\r\n * Container with a set of assets that can be added or removed from a scene.\r\n */\n\nvar AssetContainer =\n/** @class */\nfunction (_super) {\n  __extends(AssetContainer, _super);\n  /**\r\n   * Instantiates an AssetContainer.\r\n   * @param scene The scene the AssetContainer belongs to.\r\n   */\n\n\n  function AssetContainer(scene) {\n    var _this = _super.call(this) || this;\n\n    _this._wasAddedToScene = false;\n    _this.scene = scene;\n    _this[\"sounds\"] = [];\n    _this[\"effectLayers\"] = [];\n    _this[\"layers\"] = [];\n    _this[\"lensFlareSystems\"] = [];\n    _this[\"proceduralTextures\"] = [];\n    _this[\"reflectionProbes\"] = [];\n    scene.onDisposeObservable.add(function () {\n      if (!_this._wasAddedToScene) {\n        _this.dispose();\n      }\n    });\n    return _this;\n  }\n  /**\r\n   * Instantiate or clone all meshes and add the new ones to the scene.\r\n   * Skeletons and animation groups will all be cloned\r\n   * @param nameFunction defines an optional function used to get new names for clones\r\n   * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)\r\n   * @returns a list of rootNodes, skeletons and aniamtion groups that were duplicated\r\n   */\n\n\n  AssetContainer.prototype.instantiateModelsToScene = function (nameFunction, cloneMaterials) {\n    var _this = this;\n\n    if (cloneMaterials === void 0) {\n      cloneMaterials = false;\n    }\n\n    var convertionMap = {};\n    var storeMap = {};\n    var result = new InstantiatedEntries();\n    var alreadySwappedSkeletons = [];\n    var alreadySwappedMaterials = [];\n    var options = {\n      doNotInstantiate: true\n    };\n\n    var onClone = function (source, clone) {\n      convertionMap[source.uniqueId] = clone.uniqueId;\n      storeMap[clone.uniqueId] = clone;\n\n      if (nameFunction) {\n        clone.name = nameFunction(source.name);\n      }\n\n      if (clone instanceof Mesh) {\n        var clonedMesh = clone;\n\n        if (clonedMesh.morphTargetManager) {\n          var oldMorphTargetManager = source.morphTargetManager;\n          clonedMesh.morphTargetManager = oldMorphTargetManager.clone();\n\n          for (var index = 0; index < oldMorphTargetManager.numTargets; index++) {\n            var oldTarget = oldMorphTargetManager.getTarget(index);\n            var newTarget = clonedMesh.morphTargetManager.getTarget(index);\n            convertionMap[oldTarget.uniqueId] = newTarget.uniqueId;\n            storeMap[newTarget.uniqueId] = newTarget;\n          }\n        }\n      }\n    };\n\n    this.transformNodes.forEach(function (o) {\n      if (!o.parent) {\n        var newOne = o.instantiateHierarchy(null, options, function (source, clone) {\n          onClone(source, clone);\n        });\n\n        if (newOne) {\n          result.rootNodes.push(newOne);\n        }\n      }\n    });\n    this.meshes.forEach(function (o) {\n      if (!o.parent) {\n        var newOne = o.instantiateHierarchy(null, options, function (source, clone) {\n          onClone(source, clone);\n\n          if (clone.material) {\n            var mesh = clone;\n\n            if (mesh.material) {\n              if (cloneMaterials) {\n                var sourceMaterial = source.material;\n\n                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {\n                  var swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : \"Clone of \" + sourceMaterial.name);\n                  alreadySwappedMaterials.push(sourceMaterial);\n                  convertionMap[sourceMaterial.uniqueId] = swap.uniqueId;\n                  storeMap[swap.uniqueId] = swap;\n\n                  if (sourceMaterial.getClassName() === \"MultiMaterial\") {\n                    var multi = sourceMaterial;\n\n                    for (var _i = 0, _a = multi.subMaterials; _i < _a.length; _i++) {\n                      var material = _a[_i];\n\n                      if (!material) {\n                        continue;\n                      }\n\n                      swap = material.clone(nameFunction ? nameFunction(material.name) : \"Clone of \" + material.name);\n                      alreadySwappedMaterials.push(material);\n                      convertionMap[material.uniqueId] = swap.uniqueId;\n                      storeMap[swap.uniqueId] = swap;\n                    }\n\n                    multi.subMaterials = multi.subMaterials.map(function (m) {\n                      return m && storeMap[convertionMap[m.uniqueId]];\n                    });\n                  }\n                }\n\n                mesh.material = storeMap[convertionMap[sourceMaterial.uniqueId]];\n              } else {\n                if (mesh.material.getClassName() === \"MultiMaterial\") {\n                  if (_this.scene.multiMaterials.indexOf(mesh.material) === -1) {\n                    _this.scene.addMultiMaterial(mesh.material);\n                  }\n                } else {\n                  if (_this.scene.materials.indexOf(mesh.material) === -1) {\n                    _this.scene.addMaterial(mesh.material);\n                  }\n                }\n              }\n            }\n          }\n        });\n\n        if (newOne) {\n          result.rootNodes.push(newOne);\n        }\n      }\n    });\n    this.skeletons.forEach(function (s) {\n      var clone = s.clone(nameFunction ? nameFunction(s.name) : \"Clone of \" + s.name);\n\n      if (s.overrideMesh) {\n        clone.overrideMesh = storeMap[convertionMap[s.overrideMesh.uniqueId]];\n      }\n\n      for (var _i = 0, _a = _this.meshes; _i < _a.length; _i++) {\n        var m = _a[_i];\n\n        if (m.skeleton === s && !m.isAnInstance) {\n          var copy = storeMap[convertionMap[m.uniqueId]];\n          copy.skeleton = clone;\n\n          if (alreadySwappedSkeletons.indexOf(clone) !== -1) {\n            continue;\n          }\n\n          alreadySwappedSkeletons.push(clone); // Check if bones are mesh linked\n\n          for (var _b = 0, _c = clone.bones; _b < _c.length; _b++) {\n            var bone = _c[_b];\n\n            if (bone._linkedTransformNode) {\n              bone._linkedTransformNode = storeMap[convertionMap[bone._linkedTransformNode.uniqueId]];\n            }\n          }\n        }\n      }\n\n      result.skeletons.push(clone);\n    });\n    this.animationGroups.forEach(function (o) {\n      var clone = o.clone(o.name, function (oldTarget) {\n        var newTarget = storeMap[convertionMap[oldTarget.uniqueId]];\n        return newTarget || oldTarget;\n      });\n      result.animationGroups.push(clone);\n    });\n    return result;\n  };\n  /**\r\n   * Adds all the assets from the container to the scene.\r\n   */\n\n\n  AssetContainer.prototype.addAllToScene = function () {\n    var _this = this;\n\n    this._wasAddedToScene = true;\n    this.cameras.forEach(function (o) {\n      _this.scene.addCamera(o);\n    });\n    this.lights.forEach(function (o) {\n      _this.scene.addLight(o);\n    });\n    this.meshes.forEach(function (o) {\n      _this.scene.addMesh(o);\n    });\n    this.skeletons.forEach(function (o) {\n      _this.scene.addSkeleton(o);\n    });\n    this.animations.forEach(function (o) {\n      _this.scene.addAnimation(o);\n    });\n    this.animationGroups.forEach(function (o) {\n      _this.scene.addAnimationGroup(o);\n    });\n    this.multiMaterials.forEach(function (o) {\n      _this.scene.addMultiMaterial(o);\n    });\n    this.materials.forEach(function (o) {\n      _this.scene.addMaterial(o);\n    });\n    this.morphTargetManagers.forEach(function (o) {\n      _this.scene.addMorphTargetManager(o);\n    });\n    this.geometries.forEach(function (o) {\n      _this.scene.addGeometry(o);\n    });\n    this.transformNodes.forEach(function (o) {\n      _this.scene.addTransformNode(o);\n    });\n    this.actionManagers.forEach(function (o) {\n      _this.scene.addActionManager(o);\n    });\n    this.textures.forEach(function (o) {\n      _this.scene.addTexture(o);\n    });\n    this.reflectionProbes.forEach(function (o) {\n      _this.scene.addReflectionProbe(o);\n    });\n\n    if (this.environmentTexture) {\n      this.scene.environmentTexture = this.environmentTexture;\n    }\n\n    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {\n      var component = _a[_i];\n      component.addFromContainer(this);\n    }\n  };\n  /**\r\n   * Removes all the assets in the container from the scene\r\n   */\n\n\n  AssetContainer.prototype.removeAllFromScene = function () {\n    var _this = this;\n\n    this._wasAddedToScene = false;\n    this.cameras.forEach(function (o) {\n      _this.scene.removeCamera(o);\n    });\n    this.lights.forEach(function (o) {\n      _this.scene.removeLight(o);\n    });\n    this.meshes.forEach(function (o) {\n      _this.scene.removeMesh(o);\n    });\n    this.skeletons.forEach(function (o) {\n      _this.scene.removeSkeleton(o);\n    });\n    this.animations.forEach(function (o) {\n      _this.scene.removeAnimation(o);\n    });\n    this.animationGroups.forEach(function (o) {\n      _this.scene.removeAnimationGroup(o);\n    });\n    this.multiMaterials.forEach(function (o) {\n      _this.scene.removeMultiMaterial(o);\n    });\n    this.materials.forEach(function (o) {\n      _this.scene.removeMaterial(o);\n    });\n    this.morphTargetManagers.forEach(function (o) {\n      _this.scene.removeMorphTargetManager(o);\n    });\n    this.geometries.forEach(function (o) {\n      _this.scene.removeGeometry(o);\n    });\n    this.transformNodes.forEach(function (o) {\n      _this.scene.removeTransformNode(o);\n    });\n    this.actionManagers.forEach(function (o) {\n      _this.scene.removeActionManager(o);\n    });\n    this.textures.forEach(function (o) {\n      _this.scene.removeTexture(o);\n    });\n    this.reflectionProbes.forEach(function (o) {\n      _this.scene.removeReflectionProbe(o);\n    });\n\n    if (this.environmentTexture === this.scene.environmentTexture) {\n      this.scene.environmentTexture = null;\n    }\n\n    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {\n      var component = _a[_i];\n      component.removeFromContainer(this);\n    }\n  };\n  /**\r\n   * Disposes all the assets in the container\r\n   */\n\n\n  AssetContainer.prototype.dispose = function () {\n    this.cameras.forEach(function (o) {\n      o.dispose();\n    });\n    this.cameras = [];\n    this.lights.forEach(function (o) {\n      o.dispose();\n    });\n    this.lights = [];\n    this.meshes.forEach(function (o) {\n      o.dispose();\n    });\n    this.meshes = [];\n    this.skeletons.forEach(function (o) {\n      o.dispose();\n    });\n    this.skeletons = [];\n    this.animationGroups.forEach(function (o) {\n      o.dispose();\n    });\n    this.animationGroups = [];\n    this.multiMaterials.forEach(function (o) {\n      o.dispose();\n    });\n    this.multiMaterials = [];\n    this.materials.forEach(function (o) {\n      o.dispose();\n    });\n    this.materials = [];\n    this.geometries.forEach(function (o) {\n      o.dispose();\n    });\n    this.geometries = [];\n    this.transformNodes.forEach(function (o) {\n      o.dispose();\n    });\n    this.transformNodes = [];\n    this.actionManagers.forEach(function (o) {\n      o.dispose();\n    });\n    this.actionManagers = [];\n    this.textures.forEach(function (o) {\n      o.dispose();\n    });\n    this.textures = [];\n    this.reflectionProbes.forEach(function (o) {\n      o.dispose();\n    });\n    this.reflectionProbes = [];\n\n    if (this.environmentTexture) {\n      this.environmentTexture.dispose();\n      this.environmentTexture = null;\n    }\n\n    for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {\n      var component = _a[_i];\n      component.removeFromContainer(this, true);\n    }\n  };\n\n  AssetContainer.prototype._moveAssets = function (sourceAssets, targetAssets, keepAssets) {\n    if (!sourceAssets) {\n      return;\n    }\n\n    for (var _i = 0, sourceAssets_1 = sourceAssets; _i < sourceAssets_1.length; _i++) {\n      var asset = sourceAssets_1[_i];\n      var move = true;\n\n      if (keepAssets) {\n        for (var _a = 0, keepAssets_1 = keepAssets; _a < keepAssets_1.length; _a++) {\n          var keepAsset = keepAssets_1[_a];\n\n          if (asset === keepAsset) {\n            move = false;\n            break;\n          }\n        }\n      }\n\n      if (move) {\n        targetAssets.push(asset);\n      }\n    }\n  };\n  /**\r\n   * Removes all the assets contained in the scene and adds them to the container.\r\n   * @param keepAssets Set of assets to keep in the scene. (default: empty)\r\n   */\n\n\n  AssetContainer.prototype.moveAllFromScene = function (keepAssets) {\n    this._wasAddedToScene = false;\n\n    if (keepAssets === undefined) {\n      keepAssets = new KeepAssets();\n    }\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key)) {\n        this[key] = this[key] || (key === \"environmentTexture\" ? null : []);\n\n        this._moveAssets(this.scene[key], this[key], keepAssets[key]);\n      }\n    }\n\n    this.environmentTexture = this.scene.environmentTexture;\n    this.removeAllFromScene();\n  };\n  /**\r\n   * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.\r\n   * @returns the root mesh\r\n   */\n\n\n  AssetContainer.prototype.createRootMesh = function () {\n    var rootMesh = new Mesh(\"assetContainerRootMesh\", this.scene);\n    this.meshes.forEach(function (m) {\n      if (!m.parent) {\n        rootMesh.addChild(m);\n      }\n    });\n    this.meshes.unshift(rootMesh);\n    return rootMesh;\n  };\n  /**\r\n   * Merge animations (direct and animation groups) from this asset container into a scene\r\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n   * @param animatables set of animatables to retarget to a node from the scene\r\n   * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)\r\n   * @returns an array of the new AnimationGroup added to the scene (empty array if none)\r\n   */\n\n\n  AssetContainer.prototype.mergeAnimationsTo = function (scene, animatables, targetConverter) {\n    if (scene === void 0) {\n      scene = EngineStore.LastCreatedScene;\n    }\n\n    if (targetConverter === void 0) {\n      targetConverter = null;\n    }\n\n    if (!scene) {\n      Logger.Error(\"No scene available to merge animations to\");\n      return [];\n    }\n\n    var _targetConverter = targetConverter ? targetConverter : function (target) {\n      var node = null;\n      var targetProperty = target.animations.length ? target.animations[0].targetProperty : \"\";\n      /*\r\n          BabylonJS adds special naming to targets that are children of nodes.\r\n          This name attempts to remove that special naming to get the parent nodes name in case the target\r\n          can't be found in the node tree\r\n            Ex: Torso_primitive0 likely points to a Mesh primitive. We take away primitive0 and are left with \"Torso\" which is the name\r\n          of the primitive's parent.\r\n      */\n\n      var name = target.name.split(\".\").join(\"\").split(\"_primitive\")[0];\n\n      switch (targetProperty) {\n        case \"position\":\n        case \"rotationQuaternion\":\n          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);\n          break;\n\n        case \"influence\":\n          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);\n          break;\n\n        default:\n          node = scene.getNodeByName(target.name) || scene.getNodeByName(name);\n      }\n\n      return node;\n    }; // Copy new node animations\n\n\n    var nodesInAC = this.getNodes();\n    nodesInAC.forEach(function (nodeInAC) {\n      var nodeInScene = _targetConverter(nodeInAC);\n\n      if (nodeInScene !== null) {\n        var _loop_1 = function (animationInAC) {\n          // Doing treatment on an array for safety measure\n          var animationsWithSameProperty = nodeInScene.animations.filter(function (animationInScene) {\n            return animationInScene.targetProperty === animationInAC.targetProperty;\n          });\n\n          for (var _i = 0, animationsWithSameProperty_1 = animationsWithSameProperty; _i < animationsWithSameProperty_1.length; _i++) {\n            var animationWithSameProperty = animationsWithSameProperty_1[_i];\n            var index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);\n\n            if (index > -1) {\n              nodeInScene.animations.splice(index, 1);\n            }\n          }\n        }; // Remove old animations with same target property as a new one\n\n\n        for (var _i = 0, _a = nodeInAC.animations; _i < _a.length; _i++) {\n          var animationInAC = _a[_i];\n\n          _loop_1(animationInAC);\n        } // Append new animations\n\n\n        nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);\n      }\n    });\n    var newAnimationGroups = new Array(); // Copy new animation groups\n\n    this.animationGroups.slice().forEach(function (animationGroupInAC) {\n      // Clone the animation group and all its animatables\n      newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter)); // Remove animatables related to the asset container\n\n      animationGroupInAC.animatables.forEach(function (animatable) {\n        animatable.stop();\n      });\n    }); // Retarget animatables\n\n    animatables.forEach(function (animatable) {\n      var target = _targetConverter(animatable.target);\n\n      if (target) {\n        // Clone the animatable and retarget it\n        scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : undefined, undefined, true, undefined, animatable.onAnimationLoop ? animatable.onAnimationLoop : undefined); // Stop animation for the target in the asset container\n\n        scene.stopAnimation(animatable.target);\n      }\n    });\n    return newAnimationGroups;\n  };\n\n  return AssetContainer;\n}(AbstractScene);\n\nexport { AssetContainer };","map":{"version":3,"sources":["../../sourceES6/core/assetContainer.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractScene } from \"./abstractScene\";\r\nimport { Scene } from \"./scene\";\r\nimport { Mesh } from \"./Meshes/mesh\";\r\nimport { TransformNode } from './Meshes/transformNode';\r\nimport { Skeleton } from './Bones/skeleton';\r\nimport { AnimationGroup } from './Animations/animationGroup';\r\nimport { Animatable } from './Animations/animatable';\r\nimport { AbstractMesh } from './Meshes/abstractMesh';\r\nimport { MultiMaterial } from './Materials/multiMaterial';\r\nimport { Material } from './Materials/material';\r\nimport { Logger } from './Misc/logger';\r\nimport { EngineStore } from './Engines/engineStore';\r\nimport { Nullable } from './types';\r\nimport { Node } from './node';\r\n\r\n/**\r\n * Set of assets to keep when moving a scene into an asset container.\r\n */\r\nexport class KeepAssets extends AbstractScene { }\r\n\r\n/**\r\n * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function\r\n */\r\nexport class InstantiatedEntries {\r\n    /**\r\n     * List of new root nodes (eg. nodes with no parent)\r\n     */\r\n    public rootNodes: TransformNode[] = [];\r\n\r\n    /**\r\n     * List of new skeletons\r\n     */\r\n    public skeletons: Skeleton[] = [];\r\n\r\n    /**\r\n     * List of new animation groups\r\n     */\r\n    public animationGroups: AnimationGroup[] = [];\r\n}\r\n\r\n/**\r\n * Container with a set of assets that can be added or removed from a scene.\r\n */\r\nexport class AssetContainer extends AbstractScene {\r\n    private _wasAddedToScene = false;\r\n\r\n    /**\r\n     * The scene the AssetContainer belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Instantiates an AssetContainer.\r\n     * @param scene The scene the AssetContainer belongs to.\r\n     */\r\n    constructor(scene: Scene) {\r\n        super();\r\n        this.scene = scene;\r\n        this[\"sounds\"] = [];\r\n        this[\"effectLayers\"] = [];\r\n        this[\"layers\"] = [];\r\n        this[\"lensFlareSystems\"] = [];\r\n        this[\"proceduralTextures\"] = [];\r\n        this[\"reflectionProbes\"] = [];\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            if (!this._wasAddedToScene) {\r\n                this.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiate or clone all meshes and add the new ones to the scene.\r\n     * Skeletons and animation groups will all be cloned\r\n     * @param nameFunction defines an optional function used to get new names for clones\r\n     * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)\r\n     * @returns a list of rootNodes, skeletons and aniamtion groups that were duplicated\r\n     */\r\n    public instantiateModelsToScene(nameFunction?: (sourceName: string) => string, cloneMaterials = false): InstantiatedEntries {\r\n        let convertionMap: {[key: number]: number} = {};\r\n        let storeMap: {[key: number]: any} = {};\r\n        let result = new InstantiatedEntries();\r\n        let alreadySwappedSkeletons: Skeleton[] = [];\r\n        let alreadySwappedMaterials: Material[] = [];\r\n\r\n        let options = {\r\n            doNotInstantiate: true\r\n        };\r\n\r\n        let onClone = (source: TransformNode, clone: TransformNode) => {\r\n            convertionMap[source.uniqueId] = clone.uniqueId;\r\n            storeMap[clone.uniqueId] = clone;\r\n\r\n            if (nameFunction) {\r\n                clone.name = nameFunction(source.name);\r\n            }\r\n\r\n            if (clone instanceof Mesh) {\r\n                let clonedMesh = clone as Mesh;\r\n\r\n                if (clonedMesh.morphTargetManager) {\r\n                    let oldMorphTargetManager = (source as Mesh).morphTargetManager!;\r\n                    clonedMesh.morphTargetManager = oldMorphTargetManager.clone();\r\n\r\n                    for (var index = 0; index < oldMorphTargetManager.numTargets; index++) {\r\n                        let oldTarget = oldMorphTargetManager.getTarget(index);\r\n                        let newTarget = clonedMesh.morphTargetManager.getTarget(index);\r\n\r\n                        convertionMap[oldTarget.uniqueId] = newTarget.uniqueId;\r\n                        storeMap[newTarget.uniqueId] = newTarget;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.transformNodes.forEach((o) => {\r\n            if (!o.parent) {\r\n                let newOne = o.instantiateHierarchy(null, options, (source, clone) => {\r\n                    onClone(source, clone);\r\n                });\r\n\r\n                if (newOne) {\r\n                    result.rootNodes.push(newOne);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.meshes.forEach((o) => {\r\n            if (!o.parent) {\r\n                let newOne = o.instantiateHierarchy(null, options, (source, clone) => {\r\n                    onClone(source, clone);\r\n\r\n                    if ((clone as any).material) {\r\n                        let mesh = clone as AbstractMesh;\r\n\r\n                        if (mesh.material) {\r\n                            if (cloneMaterials) {\r\n                                let sourceMaterial = (source as AbstractMesh).material!;\r\n\r\n                                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {\r\n                                    let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : \"Clone of \" + sourceMaterial.name)!;\r\n                                    alreadySwappedMaterials.push(sourceMaterial);\r\n                                    convertionMap[sourceMaterial.uniqueId] = swap.uniqueId;\r\n                                    storeMap[swap.uniqueId] = swap;\r\n\r\n                                    if (sourceMaterial.getClassName() === \"MultiMaterial\") {\r\n                                        let multi = sourceMaterial as MultiMaterial;\r\n\r\n                                        for (var material of multi.subMaterials) {\r\n                                            if (!material) {\r\n                                                continue;\r\n                                            }\r\n                                            swap = material.clone(nameFunction ? nameFunction(material.name) : \"Clone of \" + material.name)!;\r\n                                            alreadySwappedMaterials.push(material);\r\n                                            convertionMap[material.uniqueId] = swap.uniqueId;\r\n                                            storeMap[swap.uniqueId] = swap;\r\n                                        }\r\n\r\n                                        multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[convertionMap[m.uniqueId]]);\r\n                                    }\r\n                                }\r\n\r\n                                mesh.material = storeMap[convertionMap[sourceMaterial.uniqueId]];\r\n                            } else {\r\n                                if (mesh.material.getClassName() === \"MultiMaterial\") {\r\n                                    if (this.scene.multiMaterials.indexOf(mesh.material as MultiMaterial) === -1) {\r\n                                        this.scene.addMultiMaterial(mesh.material as MultiMaterial);\r\n                                    }\r\n                                } else {\r\n                                    if (this.scene.materials.indexOf(mesh.material) === -1) {\r\n                                        this.scene.addMaterial(mesh.material);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                if (newOne) {\r\n                    result.rootNodes.push(newOne);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.skeletons.forEach((s) => {\r\n            let clone =  s.clone(nameFunction ? nameFunction(s.name) : \"Clone of \" + s.name);\r\n\r\n            if (s.overrideMesh) {\r\n                clone.overrideMesh = storeMap[convertionMap[s.overrideMesh.uniqueId]];\r\n            }\r\n\r\n            for (var m of this.meshes) {\r\n                if (m.skeleton === s && !m.isAnInstance) {\r\n                    let copy = storeMap[convertionMap[m.uniqueId]];\r\n                    (copy as Mesh).skeleton = clone;\r\n\r\n                    if (alreadySwappedSkeletons.indexOf(clone) !== -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    alreadySwappedSkeletons.push(clone);\r\n\r\n                    // Check if bones are mesh linked\r\n                    for (var bone of clone.bones) {\r\n                        if (bone._linkedTransformNode) {\r\n                            bone._linkedTransformNode = storeMap[convertionMap[bone._linkedTransformNode.uniqueId]];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            result.skeletons.push(clone);\r\n        });\r\n\r\n        this.animationGroups.forEach((o) => {\r\n            let clone = o.clone(o.name, (oldTarget) => {\r\n                let newTarget = storeMap[convertionMap[oldTarget.uniqueId]];\r\n\r\n                return newTarget || oldTarget;\r\n            });\r\n\r\n            result.animationGroups.push(clone);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds all the assets from the container to the scene.\r\n     */\r\n    public addAllToScene() {\r\n        this._wasAddedToScene = true;\r\n\r\n        this.cameras.forEach((o) => {\r\n            this.scene.addCamera(o);\r\n        });\r\n        this.lights.forEach((o) => {\r\n            this.scene.addLight(o);\r\n        });\r\n        this.meshes.forEach((o) => {\r\n            this.scene.addMesh(o);\r\n        });\r\n        this.skeletons.forEach((o) => {\r\n            this.scene.addSkeleton(o);\r\n        });\r\n        this.animations.forEach((o) => {\r\n            this.scene.addAnimation(o);\r\n        });\r\n        this.animationGroups.forEach((o) => {\r\n            this.scene.addAnimationGroup(o);\r\n        });\r\n        this.multiMaterials.forEach((o) => {\r\n            this.scene.addMultiMaterial(o);\r\n        });\r\n        this.materials.forEach((o) => {\r\n            this.scene.addMaterial(o);\r\n        });\r\n        this.morphTargetManagers.forEach((o) => {\r\n            this.scene.addMorphTargetManager(o);\r\n        });\r\n        this.geometries.forEach((o) => {\r\n            this.scene.addGeometry(o);\r\n        });\r\n        this.transformNodes.forEach((o) => {\r\n            this.scene.addTransformNode(o);\r\n        });\r\n        this.actionManagers.forEach((o) => {\r\n            this.scene.addActionManager(o);\r\n        });\r\n        this.textures.forEach((o) => {\r\n            this.scene.addTexture(o);\r\n        });\r\n        this.reflectionProbes.forEach((o) => {\r\n            this.scene.addReflectionProbe(o);\r\n        });\r\n\r\n        if (this.environmentTexture) {\r\n            this.scene.environmentTexture = this.environmentTexture;\r\n        }\r\n\r\n        for (let component of this.scene._serializableComponents) {\r\n            component.addFromContainer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets in the container from the scene\r\n     */\r\n    public removeAllFromScene() {\r\n        this._wasAddedToScene = false;\r\n\r\n        this.cameras.forEach((o) => {\r\n            this.scene.removeCamera(o);\r\n        });\r\n        this.lights.forEach((o) => {\r\n            this.scene.removeLight(o);\r\n        });\r\n        this.meshes.forEach((o) => {\r\n            this.scene.removeMesh(o);\r\n        });\r\n        this.skeletons.forEach((o) => {\r\n            this.scene.removeSkeleton(o);\r\n        });\r\n        this.animations.forEach((o) => {\r\n            this.scene.removeAnimation(o);\r\n        });\r\n        this.animationGroups.forEach((o) => {\r\n            this.scene.removeAnimationGroup(o);\r\n        });\r\n        this.multiMaterials.forEach((o) => {\r\n            this.scene.removeMultiMaterial(o);\r\n        });\r\n        this.materials.forEach((o) => {\r\n            this.scene.removeMaterial(o);\r\n        });\r\n        this.morphTargetManagers.forEach((o) => {\r\n            this.scene.removeMorphTargetManager(o);\r\n        });\r\n        this.geometries.forEach((o) => {\r\n            this.scene.removeGeometry(o);\r\n        });\r\n        this.transformNodes.forEach((o) => {\r\n            this.scene.removeTransformNode(o);\r\n        });\r\n        this.actionManagers.forEach((o) => {\r\n            this.scene.removeActionManager(o);\r\n        });\r\n        this.textures.forEach((o) => {\r\n            this.scene.removeTexture(o);\r\n        });\r\n        this.reflectionProbes.forEach((o) => {\r\n            this.scene.removeReflectionProbe(o);\r\n        });\r\n\r\n        if (this.environmentTexture === this.scene.environmentTexture) {\r\n            this.scene.environmentTexture = null;\r\n        }\r\n\r\n        for (let component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes all the assets in the container\r\n     */\r\n    public dispose() {\r\n        this.cameras.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.cameras = [];\r\n\r\n        this.lights.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.lights = [];\r\n\r\n        this.meshes.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.meshes = [];\r\n\r\n        this.skeletons.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.skeletons = [];\r\n\r\n        this.animationGroups.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.animationGroups = [];\r\n\r\n        this.multiMaterials.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.multiMaterials = [];\r\n\r\n        this.materials.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.materials = [];\r\n\r\n        this.geometries.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.geometries = [];\r\n\r\n        this.transformNodes.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.transformNodes = [];\r\n\r\n        this.actionManagers.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.actionManagers = [];\r\n\r\n        this.textures.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.textures = [];\r\n\r\n        this.reflectionProbes.forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.reflectionProbes = [];\r\n\r\n        if (this.environmentTexture) {\r\n            this.environmentTexture.dispose();\r\n            this.environmentTexture = null;\r\n        }\r\n\r\n        for (let component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this, true);\r\n        }\r\n    }\r\n\r\n    private _moveAssets<T>(sourceAssets: T[], targetAssets: T[], keepAssets: T[]): void {\r\n        if (!sourceAssets) {\r\n            return;\r\n        }\r\n\r\n        for (let asset of sourceAssets) {\r\n            let move = true;\r\n            if (keepAssets) {\r\n                for (let keepAsset of keepAssets) {\r\n                    if (asset === keepAsset) {\r\n                        move = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (move) {\r\n                targetAssets.push(asset);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets contained in the scene and adds them to the container.\r\n     * @param keepAssets Set of assets to keep in the scene. (default: empty)\r\n     */\r\n    public moveAllFromScene(keepAssets?: KeepAssets): void {\r\n        this._wasAddedToScene = false;\r\n\r\n        if (keepAssets === undefined) {\r\n            keepAssets = new KeepAssets();\r\n        }\r\n\r\n        for (let key in this) {\r\n            if (this.hasOwnProperty(key)) {\r\n                (<any>this)[key] = (<any>this)[key] || (key === \"environmentTexture\" ? null : []);\r\n                this._moveAssets((<any>this.scene)[key], (<any>this)[key], (<any>keepAssets)[key]);\r\n            }\r\n        }\r\n\r\n        this.environmentTexture = this.scene.environmentTexture;\r\n\r\n        this.removeAllFromScene();\r\n    }\r\n\r\n    /**\r\n     * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.\r\n     * @returns the root mesh\r\n     */\r\n    public createRootMesh() {\r\n        var rootMesh = new Mesh(\"assetContainerRootMesh\", this.scene);\r\n        this.meshes.forEach((m) => {\r\n            if (!m.parent) {\r\n                rootMesh.addChild(m);\r\n            }\r\n        });\r\n        this.meshes.unshift(rootMesh);\r\n        return rootMesh;\r\n    }\r\n\r\n    /**\r\n     * Merge animations (direct and animation groups) from this asset container into a scene\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param animatables set of animatables to retarget to a node from the scene\r\n     * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)\r\n     * @returns an array of the new AnimationGroup added to the scene (empty array if none)\r\n     */\r\n    public mergeAnimationsTo(scene: Nullable<Scene> = EngineStore.LastCreatedScene, animatables: Animatable[], targetConverter: Nullable<(target: any) => Nullable<Node>> = null): AnimationGroup[] {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to merge animations to\");\r\n            return [];\r\n        }\r\n\r\n        let _targetConverter = targetConverter ? targetConverter : (target: any) => {\r\n            let node = null;\r\n\r\n            const targetProperty = target.animations.length ? target.animations[0].targetProperty : \"\";\r\n            /*\r\n                BabylonJS adds special naming to targets that are children of nodes.\r\n                This name attempts to remove that special naming to get the parent nodes name in case the target\r\n                can't be found in the node tree\r\n\r\n                Ex: Torso_primitive0 likely points to a Mesh primitive. We take away primitive0 and are left with \"Torso\" which is the name\r\n                of the primitive's parent.\r\n            */\r\n            const name = target.name.split(\".\").join(\"\").split(\"_primitive\")[0];\r\n\r\n            switch (targetProperty) {\r\n                case \"position\":\r\n                case \"rotationQuaternion\":\r\n                    node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);\r\n                    break;\r\n                case \"influence\":\r\n                    node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);\r\n                    break;\r\n                default:\r\n                    node = scene.getNodeByName(target.name) || scene.getNodeByName(name);\r\n            }\r\n\r\n            return node;\r\n        };\r\n\r\n        // Copy new node animations\r\n        let nodesInAC = this.getNodes();\r\n        nodesInAC.forEach((nodeInAC) => {\r\n            let nodeInScene = _targetConverter(nodeInAC);\r\n            if (nodeInScene !== null) {\r\n                // Remove old animations with same target property as a new one\r\n                for (let animationInAC of nodeInAC.animations) {\r\n                    // Doing treatment on an array for safety measure\r\n                    let animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {\r\n                        return animationInScene.targetProperty === animationInAC.targetProperty;\r\n                    });\r\n                    for (let animationWithSameProperty of animationsWithSameProperty) {\r\n                        const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);\r\n                        if (index > -1) {\r\n                            nodeInScene.animations.splice(index, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Append new animations\r\n                nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);\r\n            }\r\n        });\r\n\r\n        let newAnimationGroups = new Array<AnimationGroup>();\r\n\r\n        // Copy new animation groups\r\n        this.animationGroups.slice().forEach((animationGroupInAC) => {\r\n            // Clone the animation group and all its animatables\r\n            newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));\r\n\r\n            // Remove animatables related to the asset container\r\n            animationGroupInAC.animatables.forEach((animatable) => {\r\n                animatable.stop();\r\n            });\r\n        });\r\n\r\n        // Retarget animatables\r\n        animatables.forEach((animatable) => {\r\n            let target = _targetConverter(animatable.target);\r\n\r\n            if (target) {\r\n                // Clone the animatable and retarget it\r\n                scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : undefined, undefined, true, undefined, animatable.onAnimationLoop ? animatable.onAnimationLoop : undefined);\r\n\r\n                // Stop animation for the target in the asset container\r\n                scene.stopAnimation(animatable.target);\r\n            }\r\n        });\r\n\r\n        return newAnimationGroups;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}