{"ast":null,"code":"import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport \"./animatable\";\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\n\nvar TargetedAnimation =\n/** @class */\nfunction () {\n  function TargetedAnimation() {}\n  /**\r\n   * Returns the string \"TargetedAnimation\"\r\n   * @returns \"TargetedAnimation\"\r\n   */\n\n\n  TargetedAnimation.prototype.getClassName = function () {\n    return \"TargetedAnimation\";\n  };\n  /**\r\n   * Serialize the object\r\n   * @returns the JSON object representing the current entity\r\n   */\n\n\n  TargetedAnimation.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.animation = this.animation.serialize();\n    serializationObject.targetId = this.target.id;\n    return serializationObject;\n  };\n\n  return TargetedAnimation;\n}();\n\nexport { TargetedAnimation };\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\n\nvar AnimationGroup =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new Animation Group.\r\n   * This helps managing several animations at once.\r\n   * @see https://doc.babylonjs.com/how_to/group\r\n   * @param name Defines the name of the group\r\n   * @param scene Defines the scene the group belongs to\r\n   */\n  function AnimationGroup(\n  /** The name of the animation group */\n  name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    this.name = name;\n    this._targetedAnimations = new Array();\n    this._animatables = new Array();\n    this._from = Number.MAX_VALUE;\n    this._to = -Number.MAX_VALUE;\n    this._speedRatio = 1;\n    this._loopAnimation = false;\n    this._isAdditive = false;\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\n\n    this.onAnimationEndObservable = new Observable();\n    /**\r\n     * Observer raised when one animation loops\r\n     */\n\n    this.onAnimationLoopObservable = new Observable();\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\n\n    this.onAnimationGroupLoopObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\n\n    this.onAnimationGroupEndObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\n\n    this.onAnimationGroupPauseObservable = new Observable();\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\n\n    this.onAnimationGroupPlayObservable = new Observable();\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.uniqueId = this._scene.getUniqueId();\n\n    this._scene.addAnimationGroup(this);\n  }\n\n  Object.defineProperty(AnimationGroup.prototype, \"from\", {\n    /**\r\n     * Gets the first frame\r\n     */\n    get: function () {\n      return this._from;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"to\", {\n    /**\r\n     * Gets the last frame\r\n     */\n    get: function () {\n      return this._to;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isStarted\", {\n    /**\r\n     * Define if the animations are started\r\n     */\n    get: function () {\n      return this._isStarted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isPlaying\", {\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\n    get: function () {\n      return this._isStarted && !this._isPaused;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"speedRatio\", {\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\n    get: function () {\n      return this._speedRatio;\n    },\n\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\n    set: function (value) {\n      if (this._speedRatio === value) {\n        return;\n      }\n\n      this._speedRatio = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.speedRatio = this._speedRatio;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"loopAnimation\", {\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\n    get: function () {\n      return this._loopAnimation;\n    },\n    set: function (value) {\n      if (this._loopAnimation === value) {\n        return;\n      }\n\n      this._loopAnimation = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.loopAnimation = this._loopAnimation;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"isAdditive\", {\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\n    get: function () {\n      return this._isAdditive;\n    },\n    set: function (value) {\n      if (this._isAdditive === value) {\n        return;\n      }\n\n      this._isAdditive = value;\n\n      for (var index = 0; index < this._animatables.length; index++) {\n        var animatable = this._animatables[index];\n        animatable.isAdditive = this._isAdditive;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"targetedAnimations\", {\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\n    get: function () {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"animatables\", {\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\n    get: function () {\n      return this._animatables;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AnimationGroup.prototype, \"children\", {\n    /**\r\n     * Gets the list of target animations\r\n     */\n    get: function () {\n      return this._targetedAnimations;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Add an animation (with its target) in the group\r\n   * @param animation defines the animation we want to add\r\n   * @param target defines the target of the animation\r\n   * @returns the TargetedAnimation object\r\n   */\n\n  AnimationGroup.prototype.addTargetedAnimation = function (animation, target) {\n    var targetedAnimation = new TargetedAnimation();\n    targetedAnimation.animation = animation;\n    targetedAnimation.target = target;\n    var keys = animation.getKeys();\n\n    if (this._from > keys[0].frame) {\n      this._from = keys[0].frame;\n    }\n\n    if (this._to < keys[keys.length - 1].frame) {\n      this._to = keys[keys.length - 1].frame;\n    }\n\n    this._targetedAnimations.push(targetedAnimation);\n\n    return targetedAnimation;\n  };\n  /**\r\n   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n   * It can add constant keys at begin or end\r\n   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.normalize = function (beginFrame, endFrame) {\n    if (beginFrame === void 0) {\n      beginFrame = null;\n    }\n\n    if (endFrame === void 0) {\n      endFrame = null;\n    }\n\n    if (beginFrame == null) {\n      beginFrame = this._from;\n    }\n\n    if (endFrame == null) {\n      endFrame = this._to;\n    }\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      var targetedAnimation = this._targetedAnimations[index];\n      var keys = targetedAnimation.animation.getKeys();\n      var startKey = keys[0];\n      var endKey = keys[keys.length - 1];\n\n      if (startKey.frame > beginFrame) {\n        var newKey = {\n          frame: beginFrame,\n          value: startKey.value,\n          inTangent: startKey.inTangent,\n          outTangent: startKey.outTangent,\n          interpolation: startKey.interpolation\n        };\n        keys.splice(0, 0, newKey);\n      }\n\n      if (endKey.frame < endFrame) {\n        var newKey = {\n          frame: endFrame,\n          value: endKey.value,\n          inTangent: endKey.inTangent,\n          outTangent: endKey.outTangent,\n          interpolation: endKey.interpolation\n        };\n        keys.push(newKey);\n      }\n    }\n\n    this._from = beginFrame;\n    this._to = endFrame;\n    return this;\n  };\n\n  AnimationGroup.prototype._processLoop = function (animatable, targetedAnimation, index) {\n    var _this = this;\n\n    animatable.onAnimationLoop = function () {\n      _this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n\n      if (_this._animationLoopFlags[index]) {\n        return;\n      }\n\n      _this._animationLoopFlags[index] = true;\n      _this._animationLoopCount++;\n\n      if (_this._animationLoopCount === _this._targetedAnimations.length) {\n        _this.onAnimationGroupLoopObservable.notifyObservers(_this);\n\n        _this._animationLoopCount = 0;\n        _this._animationLoopFlags = [];\n      }\n    };\n  };\n  /**\r\n   * Start all animations on given targets\r\n   * @param loop defines if animations must loop\r\n   * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n   * @param from defines the from key (optional)\r\n   * @param to defines the to key (optional)\r\n   * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n   * @returns the current animation group\r\n   */\n\n\n  AnimationGroup.prototype.start = function (loop, speedRatio, from, to, isAdditive) {\n    var _this = this;\n\n    if (loop === void 0) {\n      loop = false;\n    }\n\n    if (speedRatio === void 0) {\n      speedRatio = 1;\n    }\n\n    if (this._isStarted || this._targetedAnimations.length === 0) {\n      return this;\n    }\n\n    this._loopAnimation = loop;\n    this._animationLoopCount = 0;\n    this._animationLoopFlags = [];\n\n    var _loop_1 = function () {\n      var targetedAnimation = this_1._targetedAnimations[index];\n\n      var animatable = this_1._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this_1._from, to !== undefined ? to : this_1._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this_1._isAdditive);\n\n      animatable.onAnimationEnd = function () {\n        _this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n\n        _this._checkAnimationGroupEnded(animatable);\n      };\n\n      this_1._processLoop(animatable, targetedAnimation, index);\n\n      this_1._animatables.push(animatable);\n    };\n\n    var this_1 = this;\n\n    for (var index = 0; index < this._targetedAnimations.length; index++) {\n      _loop_1();\n    }\n\n    this._speedRatio = speedRatio;\n\n    if (from !== undefined && to !== undefined) {\n      if (from < to && this._speedRatio < 0) {\n        var temp = to;\n        to = from;\n        from = temp;\n      } else if (from > to && this._speedRatio > 0) {\n        this._speedRatio = -speedRatio;\n      }\n    }\n\n    this._isStarted = true;\n    this._isPaused = false;\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Pause all animations\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.pause = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    this._isPaused = true;\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.pause();\n    }\n\n    this.onAnimationGroupPauseObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Play all animations to initial state\r\n   * This function will start() the animations if they were not started or will restart() them if they were paused\r\n   * @param loop defines if animations must loop\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.play = function (loop) {\n    // only if all animatables are ready and exist\n    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n      if (loop !== undefined) {\n        this.loopAnimation = loop;\n      }\n\n      this.restart();\n    } else {\n      this.stop();\n      this.start(loop, this._speedRatio);\n    }\n\n    this._isPaused = false;\n    return this;\n  };\n  /**\r\n   * Reset all animations to initial state\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.reset = function () {\n    if (!this._isStarted) {\n      this.play();\n      this.goToFrame(0);\n      this.stop();\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.reset();\n    }\n\n    return this;\n  };\n  /**\r\n   * Restart animations from key 0\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.restart = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.restart();\n    }\n\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  };\n  /**\r\n   * Stop all animations\r\n   * @returns the animation group\r\n   */\n\n\n  AnimationGroup.prototype.stop = function () {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    var list = this._animatables.slice();\n\n    for (var index = 0; index < list.length; index++) {\n      list[index].stop();\n    }\n\n    this._isStarted = false;\n    return this;\n  };\n  /**\r\n   * Set animation weight for all animatables\r\n   * @param weight defines the weight to use\r\n   * @return the animationGroup\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n   */\n\n\n  AnimationGroup.prototype.setWeightForAllAnimatables = function (weight) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.weight = weight;\n    }\n\n    return this;\n  };\n  /**\r\n   * Synchronize and normalize all animatables with a source animatable\r\n   * @param root defines the root animatable to synchronize with\r\n   * @return the animationGroup\r\n   * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n   */\n\n\n  AnimationGroup.prototype.syncAllAnimationsWith = function (root) {\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.syncWith(root);\n    }\n\n    return this;\n  };\n  /**\r\n   * Goes to a specific frame in this animation group\r\n   * @param frame the frame number to go to\r\n   * @return the animationGroup\r\n   */\n\n\n  AnimationGroup.prototype.goToFrame = function (frame) {\n    if (!this._isStarted) {\n      return this;\n    }\n\n    for (var index = 0; index < this._animatables.length; index++) {\n      var animatable = this._animatables[index];\n      animatable.goToFrame(frame);\n    }\n\n    return this;\n  };\n  /**\r\n   * Dispose all associated resources\r\n   */\n\n\n  AnimationGroup.prototype.dispose = function () {\n    this._targetedAnimations = [];\n    this._animatables = [];\n\n    var index = this._scene.animationGroups.indexOf(this);\n\n    if (index > -1) {\n      this._scene.animationGroups.splice(index, 1);\n    }\n\n    this.onAnimationEndObservable.clear();\n    this.onAnimationGroupEndObservable.clear();\n    this.onAnimationGroupPauseObservable.clear();\n    this.onAnimationGroupPlayObservable.clear();\n    this.onAnimationLoopObservable.clear();\n    this.onAnimationGroupLoopObservable.clear();\n  };\n\n  AnimationGroup.prototype._checkAnimationGroupEnded = function (animatable) {\n    // animatable should be taken out of the array\n    var idx = this._animatables.indexOf(animatable);\n\n    if (idx > -1) {\n      this._animatables.splice(idx, 1);\n    } // all animatables were removed? animation group ended!\n\n\n    if (this._animatables.length === 0) {\n      this._isStarted = false;\n      this.onAnimationGroupEndObservable.notifyObservers(this);\n    }\n  };\n  /**\r\n   * Clone the current animation group and returns a copy\r\n   * @param newName defines the name of the new group\r\n   * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n   * @returns the new aniamtion group\r\n   */\n\n\n  AnimationGroup.prototype.clone = function (newName, targetConverter) {\n    var newGroup = new AnimationGroup(newName || this.name, this._scene);\n\n    for (var _i = 0, _a = this._targetedAnimations; _i < _a.length; _i++) {\n      var targetAnimation = _a[_i];\n      newGroup.addTargetedAnimation(targetAnimation.animation.clone(), targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n    }\n\n    return newGroup;\n  };\n  /**\r\n   * Serializes the animationGroup to an object\r\n   * @returns Serialized object\r\n   */\n\n\n  AnimationGroup.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.from = this.from;\n    serializationObject.to = this.to;\n    serializationObject.targetedAnimations = [];\n\n    for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n      var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n    }\n\n    return serializationObject;\n  }; // Statics\n\n  /**\r\n   * Returns a new AnimationGroup object parsed from the source provided.\r\n   * @param parsedAnimationGroup defines the source\r\n   * @param scene defines the scene that will receive the animationGroup\r\n   * @returns a new AnimationGroup\r\n   */\n\n\n  AnimationGroup.Parse = function (parsedAnimationGroup, scene) {\n    var animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\n\n    for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n      var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n      var animation = Animation.Parse(targetedAnimation.animation);\n      var id = targetedAnimation.targetId;\n\n      if (targetedAnimation.animation.property === \"influence\") {\n        // morph target animation\n        var morphTarget = scene.getMorphTargetById(id);\n\n        if (morphTarget) {\n          animationGroup.addTargetedAnimation(animation, morphTarget);\n        }\n      } else {\n        var targetNode = scene.getNodeByID(id);\n\n        if (targetNode != null) {\n          animationGroup.addTargetedAnimation(animation, targetNode);\n        }\n      }\n    }\n\n    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n    }\n\n    return animationGroup;\n  };\n  /**\r\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n   * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n   * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n   * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n   * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n   * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n   */\n\n\n  AnimationGroup.MakeAnimationAdditive = function (sourceAnimationGroup, referenceFrame, range, cloneOriginal, clonedName) {\n    if (referenceFrame === void 0) {\n      referenceFrame = 0;\n    }\n\n    if (cloneOriginal === void 0) {\n      cloneOriginal = false;\n    }\n\n    var animationGroup = sourceAnimationGroup;\n\n    if (cloneOriginal) {\n      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\n    }\n\n    var targetedAnimations = animationGroup.targetedAnimations;\n\n    for (var index = 0; index < targetedAnimations.length; index++) {\n      var targetedAnimation = targetedAnimations[index];\n      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\n    }\n\n    animationGroup.isAdditive = true;\n    return animationGroup;\n  };\n  /**\r\n   * Returns the string \"AnimationGroup\"\r\n   * @returns \"AnimationGroup\"\r\n   */\n\n\n  AnimationGroup.prototype.getClassName = function () {\n    return \"AnimationGroup\";\n  };\n  /**\r\n   * Creates a detailled string about the object\r\n   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n   * @returns a string representing the object\r\n   */\n\n\n  AnimationGroup.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n\n    if (fullDetails) {\n      ret += \", from: \" + this._from;\n      ret += \", to: \" + this._to;\n      ret += \", isStarted: \" + this._isStarted;\n      ret += \", speedRatio: \" + this._speedRatio;\n      ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n      ret += \", animatables length: \" + this._animatables;\n    }\n\n    return ret;\n  };\n\n  return AnimationGroup;\n}();\n\nexport { AnimationGroup };","map":{"version":3,"sources":["../../../sourceES6/core/Animations/animationGroup.ts"],"names":[],"mappings":"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","sourcesContent":["import { Animatable } from \"./animatable\";\r\nimport { Animation } from \"./animation\";\r\nimport { IAnimationKey } from \"./animationKey\";\r\n\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport \"./animatable\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    /**\r\n     * Gets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/how_to/group\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        let targetedAnimation = new TargetedAnimation();\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        let keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) { beginFrame = this._from; }\r\n        if (endFrame == null) { endFrame = this._to; }\r\n\r\n        for (var index = 0; index < this._targetedAnimations.length; index++) {\r\n            let targetedAnimation = this._targetedAnimations[index];\r\n            let keys = targetedAnimation.animation.getKeys();\r\n            let startKey = keys[0];\r\n            let endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                let newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                let newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._targetedAnimations.length) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags = [];\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags = [];\r\n\r\n        for (var index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            let animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        if (from !== undefined && to !== undefined) {\r\n            if (from < to && this._speedRatio < 0) {\r\n                let temp = to;\r\n                to = from;\r\n                from = temp;\r\n            } else if (from > to && this._speedRatio > 0) {\r\n                this._speedRatio = -speedRatio;\r\n            }\r\n        }\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if all animatables are ready and exist\r\n        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        this._isPaused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop();\r\n            return this;\r\n        }\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from key 0\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @returns the animation group\r\n     */\r\n    public stop(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        var list = this._animatables.slice();\r\n        for (var index = 0; index < list.length; index++) {\r\n            list[index].stop();\r\n        }\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     * @param weight defines the weight to use\r\n     * @return the animationGroup\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with\r\n     * @return the animationGroup\r\n     * @see https://doc.babylonjs.com/babylon101/animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Animatable): AnimationGroup {\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group\r\n     * @param frame the frame number to go to\r\n     * @return the animationGroup\r\n     */\r\n    public goToFrame(frame: number): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (var index = 0; index < this._animatables.length; index++) {\r\n            let animatable = this._animatables[index];\r\n            animatable.goToFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._targetedAnimations = [];\r\n        this._animatables = [];\r\n\r\n        var index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable) {\r\n        // animatable should be taken out of the array\r\n        let idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === 0) {\r\n            this._isStarted = false;\r\n            this.onAnimationGroupEndObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @returns the new aniamtion group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any): AnimationGroup {\r\n        let newGroup = new AnimationGroup(newName || this.name, this._scene);\r\n\r\n        for (var targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(targetAnimation.animation.clone(), targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.targetedAnimations = [];\r\n        for (var targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            var targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup {\r\n        var animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\r\n        for (var i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            var targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            var animation = Animation.Parse(targetedAnimation.animation);\r\n            var id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") { // morph target animation\r\n                let morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            }\r\n            else {\r\n                var targetNode = scene.getNodeByID(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): AnimationGroup {\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (cloneOriginal) {\r\n            animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\r\n        }\r\n\r\n        let targetedAnimations = animationGroup.targetedAnimations;\r\n        for (var index = 0; index < targetedAnimations.length; index++) {\r\n            let targetedAnimation = targetedAnimations[index];\r\n            Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailled string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}