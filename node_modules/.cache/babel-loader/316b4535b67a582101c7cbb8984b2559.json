{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { TmpVectors } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\nimport { TransformNode } from './transformNode';\nimport { VertexBuffer } from './buffer';\nimport { BoundingInfo } from '../Culling/boundingInfo';\nimport { Tools } from '../Misc/tools';\n\nMesh._instancedMeshFactory = function (name, mesh) {\n  var instance = new InstancedMesh(name, mesh);\n\n  if (mesh.instancedBuffers) {\n    instance.instancedBuffers = {};\n\n    for (var key in mesh.instancedBuffers) {\n      instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n    }\n  }\n\n  return instance;\n};\n/**\r\n * Creates an instance based on a source mesh.\r\n */\n\n\nvar InstancedMesh =\n/** @class */\nfunction (_super) {\n  __extends(InstancedMesh, _super);\n\n  function InstancedMesh(name, source) {\n    var _this = _super.call(this, name, source.getScene()) || this;\n    /** @hidden */\n\n\n    _this._indexInSourceMeshInstanceArray = -1;\n    source.addInstance(_this);\n    _this._sourceMesh = source;\n    _this._unIndexed = source._unIndexed;\n\n    _this.position.copyFrom(source.position);\n\n    _this.rotation.copyFrom(source.rotation);\n\n    _this.scaling.copyFrom(source.scaling);\n\n    if (source.rotationQuaternion) {\n      _this.rotationQuaternion = source.rotationQuaternion.clone();\n    }\n\n    _this.animations = Tools.Slice(source.animations);\n\n    for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\n      var range = _a[_i];\n\n      if (range != null) {\n        _this.createAnimationRange(range.name, range.from, range.to);\n      }\n    }\n\n    _this.infiniteDistance = source.infiniteDistance;\n\n    _this.setPivotMatrix(source.getPivotMatrix());\n\n    _this.refreshBoundingInfo();\n\n    _this._syncSubMeshes();\n\n    return _this;\n  }\n  /**\r\n   * Returns the string \"InstancedMesh\".\r\n   */\n\n\n  InstancedMesh.prototype.getClassName = function () {\n    return \"InstancedMesh\";\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function () {\n      return this._sourceMesh._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  InstancedMesh.prototype._resyncLightSources = function () {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._resyncLightSource = function (light) {// Do nothing as all the work will be done by source mesh\n  };\n\n  InstancedMesh.prototype._removeLightSource = function (light, dispose) {// Do nothing as all the work will be done by source mesh\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\n    // Methods\n\n    /**\r\n     * If the source mesh receives shadows\r\n     */\n    get: function () {\n      return this._sourceMesh.receiveShadows;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"material\", {\n    /**\r\n     * The material of the source mesh\r\n     */\n    get: function () {\n      return this._sourceMesh.material;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\n    /**\r\n     * Visibility of the source mesh\r\n     */\n    get: function () {\n      return this._sourceMesh.visibility;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\n    /**\r\n     * Skeleton of the source mesh\r\n     */\n    get: function () {\n      return this._sourceMesh.skeleton;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\n    get: function () {\n      return this._sourceMesh.renderingGroupId;\n    },\n    set: function (value) {\n      if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n        return;\n      } //no-op with warning\n\n\n      Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the total number of vertices (integer).\r\n   */\n\n  InstancedMesh.prototype.getTotalVertices = function () {\n    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n  };\n  /**\r\n   * Returns a positive integer : the total number of indices in this mesh geometry.\r\n   * @returns the numner of indices or zero if the mesh has no geometry.\r\n   */\n\n\n  InstancedMesh.prototype.getTotalIndices = function () {\n    return this._sourceMesh.getTotalIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\n    /**\r\n     * The source mesh of the instance\r\n     */\n    get: function () {\n      return this._sourceMesh;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Creates a new InstancedMesh object from the mesh model.\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n   * @param name defines the name of the new instance\r\n   * @returns a new InstancedMesh\r\n   */\n\n  InstancedMesh.prototype.createInstance = function (name) {\n    return this._sourceMesh.createInstance(name);\n  };\n  /**\r\n   * Is this node ready to be used/rendered\r\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n   * @return {boolean} is it ready\r\n   */\n\n\n  InstancedMesh.prototype.isReady = function (completeCheck) {\n    if (completeCheck === void 0) {\n      completeCheck = false;\n    }\n\n    return this._sourceMesh.isReady(completeCheck, true);\n  };\n  /**\r\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n   * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n   * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n   */\n\n\n  InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\n    return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n  };\n  /**\r\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n   * The `data` are either a numeric array either a Float32Array.\r\n   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n   * Note that a new underlying VertexBuffer object is created each call.\r\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   *\r\n   * Possible `kind` values :\r\n   * - VertexBuffer.PositionKind\r\n   * - VertexBuffer.UVKind\r\n   * - VertexBuffer.UV2Kind\r\n   * - VertexBuffer.UV3Kind\r\n   * - VertexBuffer.UV4Kind\r\n   * - VertexBuffer.UV5Kind\r\n   * - VertexBuffer.UV6Kind\r\n   * - VertexBuffer.ColorKind\r\n   * - VertexBuffer.MatricesIndicesKind\r\n   * - VertexBuffer.MatricesIndicesExtraKind\r\n   * - VertexBuffer.MatricesWeightsKind\r\n   * - VertexBuffer.MatricesWeightsExtraKind\r\n   *\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, it is simply returned as it is.\r\n   * The `data` are either a numeric array either a Float32Array.\r\n   * No new underlying VertexBuffer object is created.\r\n   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n   *\r\n   * Possible `kind` values :\r\n   * - VertexBuffer.PositionKind\r\n   * - VertexBuffer.UVKind\r\n   * - VertexBuffer.UV2Kind\r\n   * - VertexBuffer.UV3Kind\r\n   * - VertexBuffer.UV4Kind\r\n   * - VertexBuffer.UV5Kind\r\n   * - VertexBuffer.UV6Kind\r\n   * - VertexBuffer.ColorKind\r\n   * - VertexBuffer.MatricesIndicesKind\r\n   * - VertexBuffer.MatricesIndicesExtraKind\r\n   * - VertexBuffer.MatricesWeightsKind\r\n   * - VertexBuffer.MatricesWeightsExtraKind\r\n   *\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    if (this.sourceMesh) {\n      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Sets the mesh indices.\r\n   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n   * This method creates a new index buffer each call.\r\n   * Returns the Mesh.\r\n   */\n\n\n  InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\n    if (totalVertices === void 0) {\n      totalVertices = null;\n    }\n\n    if (this.sourceMesh) {\n      this.sourceMesh.setIndices(indices, totalVertices);\n    }\n\n    return this.sourceMesh;\n  };\n  /**\r\n   * Boolean : True if the mesh owns the requested kind of data.\r\n   */\n\n\n  InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\n    return this._sourceMesh.isVerticesDataPresent(kind);\n  };\n  /**\r\n   * Returns an array of indices (IndicesArray).\r\n   */\n\n\n  InstancedMesh.prototype.getIndices = function () {\n    return this._sourceMesh.getIndices();\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\n    get: function () {\n      return this._sourceMesh._positions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n   * This means the mesh underlying bounding box and sphere are recomputed.\r\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n   * @returns the current mesh\r\n   */\n\n  InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (this._boundingInfo && this._boundingInfo.isLocked) {\n      return this;\n    }\n\n    var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n\n    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._preActivate = function () {\n    if (this._currentLOD) {\n      this._currentLOD._preActivate();\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\n    if (!this._sourceMesh.subMeshes) {\n      Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n    }\n\n    if (this._currentLOD) {\n      var differentSign = this._currentLOD._getWorldMatrixDeterminant() > 0 !== this._getWorldMatrixDeterminant() > 0;\n\n      if (differentSign) {\n        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n        return true;\n      }\n\n      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n\n      this._currentLOD._registerInstanceForRenderId(this, renderId);\n\n      if (intermediateRendering) {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n          return true;\n        }\n      } else {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._postActivate = function () {\n    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer of the source mesh\n      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n\n      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer defined for this instance\n      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n    }\n  };\n\n  InstancedMesh.prototype.getWorldMatrix = function () {\n    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n      var tempMaster = this._currentLOD._masterMesh;\n      this._currentLOD._masterMesh = this;\n      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n\n      this._currentLOD.position.set(0, 0, 0);\n\n      TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\n\n      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n\n      this._currentLOD._masterMesh = tempMaster;\n      return TmpVectors.Matrix[0];\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n\n  Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the current associated LOD AbstractMesh.\r\n   */\n\n  InstancedMesh.prototype.getLOD = function (camera) {\n    if (!camera) {\n      return this;\n    }\n\n    var boundingInfo = this.getBoundingInfo();\n    this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n\n    if (this._currentLOD === this.sourceMesh) {\n      return this.sourceMesh;\n    }\n\n    return this._currentLOD;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n    return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._syncSubMeshes = function () {\n    this.releaseSubMeshes();\n\n    if (this._sourceMesh.subMeshes) {\n      for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._generatePointsArray = function () {\n    return this._sourceMesh._generatePointsArray();\n  };\n  /** @hidden */\n\n\n  InstancedMesh.prototype._updateBoundingInfo = function () {\n    var effectiveMesh = this;\n\n    if (this._boundingInfo) {\n      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\n    } else {\n      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\n\n    return this;\n  };\n  /**\r\n   * Creates a new InstancedMesh from the current mesh.\r\n   * - name (string) : the cloned mesh name\r\n   * - newParent (optional Node) : the optional Node to parent the clone to.\r\n   * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n   *\r\n   * Returns the clone.\r\n   */\n\n\n  InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    if (newParent === void 0) {\n      newParent = null;\n    }\n\n    var result = this._sourceMesh.createInstance(name); // Deep copy\n\n\n    DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\", \"receiveShadows\", \"material\", \"visibility\", \"skeleton\", \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\", \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"], []); // Bounding info\n\n    this.refreshBoundingInfo(); // Parent\n\n    if (newParent) {\n      result.parent = newParent;\n    }\n\n    if (!doNotCloneChildren) {\n      // Children\n      for (var index = 0; index < this.getScene().meshes.length; index++) {\n        var mesh = this.getScene().meshes[index];\n\n        if (mesh.parent === this) {\n          mesh.clone(mesh.name, result);\n        }\n      }\n    }\n\n    result.computeWorldMatrix(true);\n    return result;\n  };\n  /**\r\n   * Disposes the InstancedMesh.\r\n   * Returns nothing.\r\n   */\n\n\n  InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    } // Remove from mesh\n\n\n    this._sourceMesh.removeInstance(this);\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n\n  return InstancedMesh;\n}(AbstractMesh);\n\nexport { InstancedMesh };\nMesh.prototype.edgesShareWithInstances = false;\n\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n  // Remove existing one\n  this.removeVerticesData(kind); // Creates the instancedBuffer field if not present\n\n  if (!this.instancedBuffers) {\n    this.instancedBuffers = {};\n\n    for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\n      var instance = _a[_i];\n      instance.instancedBuffers = {};\n    }\n\n    this._userInstancedBuffersStorage = {\n      data: {},\n      vertexBuffers: {},\n      strides: {},\n      sizes: {}\n    };\n  } // Creates an empty property for this kind\n\n\n  this.instancedBuffers[kind] = null;\n  this._userInstancedBuffersStorage.strides[kind] = stride;\n  this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n\n  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\n\n  for (var _b = 0, _c = this.instances; _b < _c.length; _b++) {\n    var instance = _c[_b];\n    instance.instancedBuffers[kind] = null;\n  }\n};\n\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n  var instanceCount = visibleInstances.length;\n\n  for (var kind in this.instancedBuffers) {\n    var size = this._userInstancedBuffersStorage.sizes[kind];\n    var stride = this._userInstancedBuffersStorage.strides[kind]; // Resize if required\n\n    var expectedSize = (instanceCount + 1) * stride;\n\n    while (size < expectedSize) {\n      size *= 2;\n    }\n\n    if (this._userInstancedBuffersStorage.data[kind].length != size) {\n      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n      this._userInstancedBuffersStorage.sizes[kind] = size;\n\n      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n\n        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n      }\n    }\n\n    var data = this._userInstancedBuffersStorage.data[kind]; // Update data buffer\n\n    var offset = 0;\n\n    if (renderSelf) {\n      var value = this.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else {\n        value.copyToArray(data, offset);\n      }\n\n      offset += stride;\n    }\n\n    for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n      var instance = visibleInstances[instanceIndex];\n      var value = instance.instancedBuffers[kind];\n\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else {\n        value.copyToArray(data, offset);\n      }\n\n      offset += stride;\n    } // Update vertex buffer\n\n\n    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]);\n    } else {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n    }\n  }\n};\n\nMesh.prototype._disposeInstanceSpecificData = function () {\n  if (this._instanceDataStorage.instancesBuffer) {\n    this._instanceDataStorage.instancesBuffer.dispose();\n\n    this._instanceDataStorage.instancesBuffer = null;\n  }\n\n  while (this.instances.length) {\n    this.instances[0].dispose();\n  }\n\n  for (var kind in this.instancedBuffers) {\n    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n    }\n  }\n\n  this.instancedBuffers = {};\n};","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/instancedMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh, _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from './transformNode';\r\nimport { Light } from '../Lights/light';\r\nimport { VertexBuffer } from './buffer';\r\nimport { BoundingInfo } from '../Culling/boundingInfo';\r\nimport { Tools } from '../Misc/tools';\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    let instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (var key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n\r\n    /** @hidden */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = Tools.Slice(source.animations);\r\n        for (let range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo();\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(light: Light): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false): InstancedMesh {\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            let differentSign = (this._currentLOD._getWorldMatrixDeterminant() > 0) !== (this._getWorldMatrixDeterminant() > 0);\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            let tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            TmpVectors.Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return TmpVectors.Matrix[0];\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n\r\n        if (this._currentLOD === this.sourceMesh) {\r\n            return this.sourceMesh;\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        const effectiveMesh = this as AbstractMesh;\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node>= null, doNotCloneChildren?: boolean): InstancedMesh {\r\n        var result = this._sourceMesh.createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(this, result, [\r\n            \"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\",\r\n            \"receiveShadows\", \"material\", \"visibility\", \"skeleton\",\r\n            \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\",\r\n            \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\",\r\n            \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\",\r\n            \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\"\r\n        ], []);\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\r\n                var mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @hidden */\r\n        _userInstancedBuffersStorage: {\r\n            data: {[key: string]: Float32Array},\r\n            sizes: {[key: string]: number},\r\n            vertexBuffers: {[key: string]: Nullable<VertexBuffer>},\r\n            strides: {[key: string]: number}\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances#custom-buffers\r\n         */\r\n        instancedBuffers: {[key: string]: any};\r\n    }\r\n}\r\n\r\nMesh.prototype.edgesShareWithInstances = false;\r\n\r\nMesh.prototype.registerInstancedBuffer = function(kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this.removeVerticesData(kind);\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (var instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {}\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n    this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]!);\r\n\r\n    for (var instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function(visibleInstances: InstancedMesh[], renderSelf: boolean) {\r\n    let instanceCount = visibleInstances.length;\r\n\r\n    for (var kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        let stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        let expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        let data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            let value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            let instance = visibleInstances[instanceIndex]!;\r\n\r\n            let value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else {\r\n                value.copyToArray(data, offset);\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n            this.setVerticesBuffer(this._userInstancedBuffersStorage.vertexBuffers[kind]!);\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function() {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (var kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}