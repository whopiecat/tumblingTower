{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\nimport { Logger } from '../../Misc/logger';\nimport { Tools } from '../../Misc/tools';\nimport { ThinEngine } from '../thinEngine';\n\nThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  if (!texture) {\n    return;\n  } // Babylon's internalSizedFomat but gl's texImage2D internalFormat\n\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format); // Babylon's internalFormat but gl's texImage2D format\n\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var textureType = this._getWebGLTextureType(type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n    texture.format = format;\n    texture.type = type;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n\n  if (texture.width % 4 !== 0) {\n    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n  }\n\n  if (compression && data) {\n    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);\n  } else {\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\n  }\n\n  if (texture.generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null); //  this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (type === void 0) {\n    type = 0;\n  }\n\n  var texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n\n  this.updateRawTexture(texture, data, format, invertY, compression, type);\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true); // Filters\n\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n  if (generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n\n  this._internalTexturesCache.push(texture);\n\n  return texture;\n};\n\nThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  var gl = this._gl;\n  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  texture.isCube = true;\n  texture.format = format;\n  texture.type = type;\n\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n  } // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\n\n\n  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n\n  var width = size;\n  var height = width;\n  texture.width = width;\n  texture.height = height; // Double check on POT to generate Mips.\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (!isPot) {\n    generateMipMaps = false;\n  } // Upload data if needed. The texture won't be ready until then.\n\n\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true); // Filters\n\n\n  if (data && generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n\n  texture.generateMipMaps = generateMipMaps;\n  return texture;\n};\n\nThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression, level) {\n  if (compression === void 0) {\n    compression = null;\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  texture._bufferViewArray = data;\n  texture.format = format;\n  texture.type = type;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  var gl = this._gl;\n\n  var textureType = this._getWebGLTextureType(type);\n\n  var internalFormat = this._getInternalFormat(format);\n\n  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n\n  var needConversion = false;\n\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n    needConversion = true;\n  }\n\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n  if (texture.width % 4 !== 0) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  } // Data are known to be in +X +Y +Z -X -Y -Z\n\n\n  for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n    var faceData = data[faceIndex];\n\n    if (compression) {\n      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);\n    } else {\n      if (needConversion) {\n        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\n      }\n\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\n    }\n  }\n\n  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);\n\n  if (isPot && texture.generateMipMaps && level === 0) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null); // this.resetTextureCache();\n\n\n  texture.isReady = true;\n};\n\nThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {\n  var _this = this;\n\n  if (onLoad === void 0) {\n    onLoad = null;\n  }\n\n  if (onError === void 0) {\n    onError = null;\n  }\n\n  if (samplingMode === void 0) {\n    samplingMode = 3;\n  }\n\n  if (invertY === void 0) {\n    invertY = false;\n  }\n\n  var gl = this._gl;\n  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);\n  texture.url = url;\n\n  this._internalTexturesCache.push(texture);\n\n  var onerror = function (request, exception) {\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n\n  var internalCallback = function (data) {\n    var width = texture.width;\n    var faceDataArrays = callback(data);\n\n    if (!faceDataArrays) {\n      return;\n    }\n\n    if (mipmapGenerator) {\n      var textureType = _this._getWebGLTextureType(type);\n\n      var internalFormat = _this._getInternalFormat(format);\n\n      var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);\n\n      var needConversion = false;\n\n      if (internalFormat === gl.RGB) {\n        internalFormat = gl.RGBA;\n        needConversion = true;\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n\n      _this._unpackFlipY(false);\n\n      var mipData = mipmapGenerator(faceDataArrays);\n\n      for (var level = 0; level < mipData.length; level++) {\n        var mipSize = width >> level;\n\n        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n          var mipFaceData = mipData[level][faceIndex];\n\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n\n          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n        }\n      }\n\n      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n    }\n\n    texture.isReady = true; // this.resetTextureCache();\n\n    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);\n\n    if (onLoad) {\n      onLoad();\n    }\n  };\n\n  this._loadFile(url, function (data) {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n\n  return texture;\n};\n/** @hidden */\n\n\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  var rgbaData;\n\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint32Array(width * height * 4);\n  } // Convert each pixel.\n\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var index = (y * width + x) * 3;\n      var newIndex = (y * width + x) * 4; // Map Old Value to new value.\n\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2]; // Add fully opaque alpha channel.\n\n      rgbaData[newIndex + 3] = 1;\n    }\n  }\n\n  return rgbaData;\n}\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\n\n\nfunction _makeCreateRawTextureFunction(is3D) {\n  return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\n    var texture = new InternalTexture(this, source);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n\n    if (is3D) {\n      texture.is3D = true;\n    } else {\n      texture.is2DArray = true;\n    }\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n\n    if (is3D) {\n      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n    } else {\n      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n    }\n\n    this._bindTextureDirectly(target, texture, true); // Filters\n\n\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n\n    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n\n    if (generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null);\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n}\n\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\n\nfunction _makeUpdateRawTextureFunction(is3D) {\n  return function (texture, data, format, invertY, compression, textureType) {\n    if (compression === void 0) {\n      compression = null;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n\n    var internalType = this._getWebGLTextureType(textureType);\n\n    var internalFormat = this._getInternalFormat(format);\n\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\n\n    this._bindTextureDirectly(target, texture, true);\n\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n    }\n\n    if (texture.width % 4 !== 0) {\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n    }\n\n    if (compression && data) {\n      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);\n    } else {\n      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\n    }\n\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n\n    this._bindTextureDirectly(target, null); // this.resetTextureCache();\n\n\n    texture.isReady = true;\n  };\n}\n\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Extensions/engine.rawTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { Tools } from '../../Misc/tools';\r\nimport { Scene } from '../../scene';\r\n\r\nimport { ThinEngine } from '../thinEngine';\r\nimport { IWebRequest } from '../../Misc/interfaces/iWebRequest';\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, type: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, type: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(url: string, scene: Nullable<Scene>, size: number, format: number, type: number, noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(url: string, scene: Nullable<Scene>, size: number, format: number, type: number, noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string> = null, type: number = 0): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    var internalFormat = this._getInternalFormat(format);\r\n    var textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string> = null, type: number = 0): InternalTexture {\r\n    var texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number,\r\n    generateMipMaps: boolean, invertY: boolean, samplingMode: number,\r\n    compression: Nullable<string> = null): InternalTexture {\r\n    var gl = this._gl;\r\n    var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    var textureType = this._getWebGLTextureType(type);\r\n    var internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = 1;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    }\r\n    else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = 1;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    }\r\n    else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n    else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    var width = size;\r\n    var height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n\r\n    // Double check on POT to generate Mips.\r\n    var isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null, level: number = 0): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    var gl = this._gl;\r\n    var textureType = this._getWebGLTextureType(type);\r\n    var internalFormat = this._getInternalFormat(format);\r\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    var needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, (<any>(this.getCaps().s3tc))[compression], texture.width, texture.height, 0, <DataView>faceData);\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    var isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function(url: string, scene: Nullable<Scene>, size: number, format: number, type: number, noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = 3,\r\n    invertY: boolean = false): InternalTexture {\r\n\r\n    var gl = this._gl;\r\n    var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?._addPendingData(texture);\r\n    texture.url = url;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    var onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?._removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    var internalCallback = (data: any) => {\r\n        var width = texture.width;\r\n        var faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            var textureType = this._getWebGLTextureType(type);\r\n            var internalFormat = this._getInternalFormat(format);\r\n            var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            var needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            var mipData = mipmapGenerator(faceDataArrays);\r\n            for (var level = 0; level < mipData.length; level++) {\r\n                var mipSize = width >> level;\r\n\r\n                for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        }\r\n        else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?._removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, (data) => {\r\n        internalCallback(data);\r\n    }, undefined, scene?.offlineProvider, true, onerror);\r\n\r\n    return texture;\r\n};\r\n\r\n/** @hidden */\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    var rgbaData: any;\r\n    if (textureType === 1) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    }\r\n    else {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            let index = (y * width + x) * 3;\r\n            let newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = 1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function(this: ThinEngine, data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string> = null, textureType: number = 0): InternalTexture {\r\n        var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        var texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function(this: ThinEngine, texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string> = null, textureType: number = 0): void {\r\n        var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        var internalType = this._getWebGLTextureType(textureType);\r\n        var internalFormat = this._getInternalFormat(format);\r\n        var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}