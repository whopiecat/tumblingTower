{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matrix } from \"../Maths/math.vector\";\nimport { Material } from \"../Materials/material\";\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\n\nvar PushMaterial =\n/** @class */\nfunction (_super) {\n  __extends(PushMaterial, _super);\n\n  function PushMaterial(name, scene) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._normalMatrix = new Matrix();\n    _this._storeEffectOnSubMeshes = true;\n    return _this;\n  }\n\n  PushMaterial.prototype.getEffect = function () {\n    return this._activeEffect;\n  };\n\n  PushMaterial.prototype.isReady = function (mesh, useInstances) {\n    if (!mesh) {\n      return false;\n    }\n\n    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n      return true;\n    }\n\n    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n  };\n\n  PushMaterial.prototype._isReadyForSubMesh = function (subMesh) {\n    var defines = subMesh._materialDefines;\n\n    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\n      if (defines._renderId === this.getScene().getRenderId()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n  * Binds the given world matrix to the active effect\r\n  *\r\n  * @param world the matrix to bind\r\n  */\n\n\n  PushMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n    this._activeEffect.setMatrix(\"world\", world);\n  };\n  /**\r\n   * Binds the given normal matrix to the active effect\r\n   *\r\n   * @param normalMatrix the matrix to bind\r\n   */\n\n\n  PushMaterial.prototype.bindOnlyNormalMatrix = function (normalMatrix) {\n    this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\n  };\n\n  PushMaterial.prototype.bind = function (world, mesh) {\n    if (!mesh) {\n      return;\n    }\n\n    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n  };\n\n  PushMaterial.prototype._afterBind = function (mesh, effect) {\n    if (effect === void 0) {\n      effect = null;\n    }\n\n    _super.prototype._afterBind.call(this, mesh);\n\n    this.getScene()._cachedEffect = effect;\n  };\n\n  PushMaterial.prototype._mustRebind = function (scene, effect, visibility) {\n    if (visibility === void 0) {\n      visibility = 1;\n    }\n\n    return scene.isCachedMaterialInvalid(this, effect, visibility);\n  };\n\n  return PushMaterial;\n}(Material);\n\nexport { PushMaterial };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/pushMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { SubMesh } from '../Meshes/subMesh';\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @hidden\r\n */\r\nexport class PushMaterial extends Material {\r\n\r\n    protected _activeEffect: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = true;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._activeEffect;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh._materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Binds the given world matrix to the active effect\r\n    *\r\n    * @param world the matrix to bind\r\n    */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh: Mesh, effect: Nullable<Effect> = null): void {\r\n        super._afterBind(mesh);\r\n        this.getScene()._cachedEffect = effect;\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, visibility: number = 1) {\r\n        return scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}