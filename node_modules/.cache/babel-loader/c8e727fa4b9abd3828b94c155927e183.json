{"ast":null,"code":"import { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Logger } from \"../../Misc/logger\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\nimport { ShapeBuilder } from \"../../Meshes/Builders/shapeBuilder\";\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\nimport { Scalar } from \"../../Maths/math.scalar\";\nimport { Epsilon } from '../../Maths/math.constants';\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\n\nvar AmmoJSPlugin =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the ammoJS plugin\r\n   * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n   * @param ammoInjection can be used to inject your own ammo reference\r\n   * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n   */\n  function AmmoJSPlugin(_useDeltaForWorldStep, ammoInjection, overlappingPairCache) {\n    var _this = this;\n\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (ammoInjection === void 0) {\n      ammoInjection = Ammo;\n    }\n\n    if (overlappingPairCache === void 0) {\n      overlappingPairCache = null;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    /**\r\n     * Reference to the Ammo library\r\n     */\n\n    this.bjsAMMO = {};\n    /**\r\n     * Name of the plugin\r\n     */\n\n    this.name = \"AmmoJSPlugin\";\n    this._timeStep = 1 / 60;\n    this._fixedTimeStep = 1 / 60;\n    this._maxSteps = 5;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpContactCallbackResult = false;\n    this._tmpContactPoint = new Vector3();\n    this._tmpMatrix = new Matrix();\n\n    if (typeof ammoInjection === \"function\") {\n      ammoInjection(this.bjsAMMO);\n    } else {\n      this.bjsAMMO = ammoInjection;\n    }\n\n    if (!this.isSupported()) {\n      Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\n      return;\n    } // Initialize the physics world\n\n\n    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\n    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\n    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\n    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\n    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\n    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\n    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\n\n    this._tmpAmmoConcreteContactResultCallback.addSingleResult = function (contactPoint, colObj0Wrap, partId0, index0) {\n      contactPoint = _this.bjsAMMO.wrapPointer(contactPoint, Ammo.btManifoldPoint);\n      var worldPoint = contactPoint.getPositionWorldOnA();\n      _this._tmpContactPoint.x = worldPoint.x();\n      _this._tmpContactPoint.y = worldPoint.y();\n      _this._tmpContactPoint.z = worldPoint.z();\n      _this._tmpContactCallbackResult = true;\n    };\n\n    this._raycastResult = new PhysicsRaycastResult(); // Create temp ammo variables\n\n    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\n\n    this._tmpAmmoTransform.setIdentity();\n\n    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\n    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\n  }\n  /**\r\n   * Sets the gravity of the physics world (m/(s^2))\r\n   * @param gravity Gravity to set\r\n   */\n\n\n  AmmoJSPlugin.prototype.setGravity = function (gravity) {\n    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\n\n    this.world.setGravity(this._tmpAmmoVectorA);\n    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\n  };\n  /**\r\n   * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n   * @param timeStep timestep to use in seconds\r\n   */\n\n\n  AmmoJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this._timeStep = timeStep;\n  };\n  /**\r\n   * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n   * @param fixedTimeStep fixedTimeStep to use in seconds\r\n   */\n\n\n  AmmoJSPlugin.prototype.setFixedTimeStep = function (fixedTimeStep) {\n    this._fixedTimeStep = fixedTimeStep;\n  };\n  /**\r\n   * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n   * @param maxSteps the maximum number of steps by the physics engine per frame\r\n   */\n\n\n  AmmoJSPlugin.prototype.setMaxSteps = function (maxSteps) {\n    this._maxSteps = maxSteps;\n  };\n  /**\r\n   * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n   * @returns the current timestep in seconds\r\n   */\n\n\n  AmmoJSPlugin.prototype.getTimeStep = function () {\n    return this._timeStep;\n  }; // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\n\n\n  AmmoJSPlugin.prototype._isImpostorInContact = function (impostor) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }; // Ammo's collision events have some weird quirks\n  // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\n  // so only fire event if both contactTest and contactPairTest have a hit\n\n\n  AmmoJSPlugin.prototype._isImpostorPairInContact = function (impostorA, impostorB) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }; // Ammo's behavior when maxSteps > 0 does not behave as described in docs\n  // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n  //\n  // When maxSteps is 0 do the entire simulation in one step\n  // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\n  // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\n\n\n  AmmoJSPlugin.prototype._stepSimulation = function (timeStep, maxSteps, fixedTimeStep) {\n    if (timeStep === void 0) {\n      timeStep = 1 / 60;\n    }\n\n    if (maxSteps === void 0) {\n      maxSteps = 10;\n    }\n\n    if (fixedTimeStep === void 0) {\n      fixedTimeStep = 1 / 60;\n    }\n\n    if (maxSteps == 0) {\n      this.world.stepSimulation(timeStep, 0);\n    } else {\n      while (maxSteps > 0 && timeStep > 0) {\n        if (timeStep - fixedTimeStep < fixedTimeStep) {\n          this.world.stepSimulation(timeStep, 0);\n          timeStep = 0;\n        } else {\n          timeStep -= fixedTimeStep;\n          this.world.stepSimulation(fixedTimeStep, 0);\n        }\n\n        maxSteps--;\n      }\n    }\n  };\n  /**\r\n   * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n   * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n   * After the step the babylon meshes are set to the position of the physics imposters\r\n   * @param delta amount of time to step forward\r\n   * @param impostors array of imposters to update before/after the step\r\n   */\n\n\n  AmmoJSPlugin.prototype.executeStep = function (delta, impostors) {\n    for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {\n      var impostor = impostors_1[_i]; // Update physics world objects to match babylon world\n\n      if (!impostor.soft) {\n        impostor.beforeStep();\n      }\n    }\n\n    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\n\n    for (var _a = 0, impostors_2 = impostors; _a < impostors_2.length; _a++) {\n      var mainImpostor = impostors_2[_a]; // After physics update make babylon world objects match physics world objects\n\n      if (mainImpostor.soft) {\n        this._afterSoftStep(mainImpostor);\n      } else {\n        mainImpostor.afterStep();\n      } // Handle collision event\n\n\n      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\n        if (this._isImpostorInContact(mainImpostor)) {\n          for (var _b = 0, _c = mainImpostor._onPhysicsCollideCallbacks; _b < _c.length; _b++) {\n            var collideCallback = _c[_b];\n\n            for (var _d = 0, _e = collideCallback.otherImpostors; _d < _e.length; _d++) {\n              var otherImpostor = _e[_d];\n\n              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\n                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\n                  mainImpostor.onCollide({\n                    body: otherImpostor.physicsBody,\n                    point: this._tmpContactPoint\n                  });\n                  otherImpostor.onCollide({\n                    body: mainImpostor.physicsBody,\n                    point: this._tmpContactPoint\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Update babylon mesh to match physics world object\r\n   * @param impostor imposter to match\r\n   */\n\n\n  AmmoJSPlugin.prototype._afterSoftStep = function (impostor) {\n    if (impostor.type === PhysicsImpostor.RopeImpostor) {\n      this._ropeStep(impostor);\n    } else {\n      this._softbodyOrClothStep(impostor);\n    }\n  };\n  /**\r\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n   * @param impostor imposter to match\r\n   */\n\n\n  AmmoJSPlugin.prototype._ropeStep = function (impostor) {\n    var bodyVertices = impostor.physicsBody.get_m_nodes();\n    var nbVertices = bodyVertices.size();\n    var node;\n    var nodePositions;\n    var x, y, z;\n    var path = new Array();\n\n    for (var n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z();\n      path.push(new Vector3(x, y, z));\n    }\n\n    var object = impostor.object;\n    var shape = impostor.getParam(\"shape\");\n\n    if (impostor._isFromLine) {\n      impostor.object = LinesBuilder.CreateLines(\"lines\", {\n        points: path,\n        instance: object\n      });\n    } else {\n      impostor.object = ShapeBuilder.ExtrudeShape(\"ext\", {\n        shape: shape,\n        path: path,\n        instance: object\n      });\n    }\n  };\n  /**\r\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n   * @param impostor imposter to match\r\n   */\n\n\n  AmmoJSPlugin.prototype._softbodyOrClothStep = function (impostor) {\n    var normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\n    var object = impostor.object;\n    var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n    if (!vertexPositions) {\n      vertexPositions = [];\n    }\n\n    var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n\n    if (!vertexNormals) {\n      vertexNormals = [];\n    }\n\n    var nbVertices = vertexPositions.length / 3;\n    var bodyVertices = impostor.physicsBody.get_m_nodes();\n    var node;\n    var nodePositions;\n    var nodeNormals;\n    var x, y, z;\n    var nx, ny, nz;\n\n    for (var n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z() * normalDirection;\n      var nodeNormals = node.get_m_n();\n      nx = nodeNormals.x();\n      ny = nodeNormals.y();\n      nz = nodeNormals.z() * normalDirection;\n      vertexPositions[3 * n] = x;\n      vertexPositions[3 * n + 1] = y;\n      vertexPositions[3 * n + 2] = z;\n      vertexNormals[3 * n] = nx;\n      vertexNormals[3 * n + 1] = ny;\n      vertexNormals[3 * n + 2] = nz;\n    }\n\n    var vertex_data = new VertexData();\n    vertex_data.positions = vertexPositions;\n    vertex_data.normals = vertexNormals;\n    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n\n    if (object && object.getIndices) {\n      vertex_data.indices = object.getIndices();\n    }\n\n    vertex_data.applyToMesh(object);\n  };\n  /**\r\n   * Applies an impulse on the imposter\r\n   * @param impostor imposter to apply impulse to\r\n   * @param force amount of force to be applied to the imposter\r\n   * @param contactPoint the location to apply the impulse on the imposter\r\n   */\n\n\n  AmmoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      var worldPoint = this._tmpAmmoVectorA;\n      var impulse = this._tmpAmmoVectorB; // Convert contactPoint relative to center of mass\n\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n      }\n\n      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyImpulse(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  };\n  /**\r\n   * Applies a force on the imposter\r\n   * @param impostor imposter to apply force\r\n   * @param force amount of force to be applied to the imposter\r\n   * @param contactPoint the location to apply the force on the imposter\r\n   */\n\n\n  AmmoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      var worldPoint = this._tmpAmmoVectorA;\n      var impulse = this._tmpAmmoVectorB; // Convert contactPoint relative to center of mass\n\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n      }\n\n      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyForce(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  };\n  /**\r\n   * Creates a physics body using the plugin\r\n   * @param impostor the imposter to create the physics body on\r\n   */\n\n\n  AmmoJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    // Note: this method will not be called on child imposotrs for compound impostors\n    impostor._pluginData.toDispose = []; //parent-child relationship\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        impostor.forceUpdate();\n      }\n\n      return;\n    }\n\n    if (impostor.isBodyInitRequired()) {\n      var colShape = this._createShape(impostor);\n\n      var mass = impostor.getParam(\"mass\");\n      impostor._pluginData.mass = mass;\n\n      if (impostor.soft) {\n        colShape.get_m_cfg().set_collisions(0x11);\n        colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\n        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\n        colShape.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\n        this.world.addSoftBody(colShape, 1, -1);\n        impostor.physicsBody = colShape;\n\n        impostor._pluginData.toDispose.push(colShape);\n\n        this.setBodyPressure(impostor, 0);\n\n        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n          this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\n        }\n\n        this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\n        this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\n        this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\n      } else {\n        var localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\n        var startTransform = new this.bjsAMMO.btTransform();\n        startTransform.setIdentity();\n\n        if (mass !== 0) {\n          colShape.calculateLocalInertia(mass, localInertia);\n        }\n\n        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\n\n        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);\n\n        startTransform.setOrigin(this._tmpAmmoVectorA);\n        startTransform.setRotation(this._tmpAmmoQuaternion);\n        var myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\n        var rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\n        var body = new this.bjsAMMO.btRigidBody(rbInfo); // Make objects kinematic if it's mass is 0\n\n        if (mass === 0) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.KINEMATIC_FLAG);\n          body.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\n        } // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\n\n\n        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.DISABLE_COLLISION_FLAG);\n        }\n\n        var group = impostor.getParam(\"group\");\n        var mask = impostor.getParam(\"mask\");\n\n        if (group && mask) {\n          this.world.addRigidBody(body, group, mask);\n        } else {\n          this.world.addRigidBody(body);\n        }\n\n        impostor.physicsBody = body;\n        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\n      }\n\n      this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\n      this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\n    }\n  };\n  /**\r\n   * Removes the physics body from the imposter and disposes of the body's memory\r\n   * @param impostor imposter to remove the physics body from\r\n   */\n\n\n  AmmoJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    var _this = this;\n\n    if (this.world) {\n      if (impostor.soft) {\n        this.world.removeSoftBody(impostor.physicsBody);\n      } else {\n        this.world.removeRigidBody(impostor.physicsBody);\n      }\n\n      if (impostor._pluginData) {\n        impostor._pluginData.toDispose.forEach(function (d) {\n          _this.bjsAMMO.destroy(d);\n        });\n\n        impostor._pluginData.toDispose = [];\n      }\n    }\n  };\n  /**\r\n   * Generates a joint\r\n   * @param impostorJoint the imposter joint to create the joint with\r\n   */\n\n\n  AmmoJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var jointData = impostorJoint.joint.jointData;\n\n    if (!jointData.mainPivot) {\n      jointData.mainPivot = new Vector3(0, 0, 0);\n    }\n\n    if (!jointData.connectedPivot) {\n      jointData.connectedPivot = new Vector3(0, 0, 0);\n    }\n\n    var joint;\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.DistanceJoint:\n        var distance = jointData.maxDistance;\n\n        if (distance) {\n          jointData.mainPivot = new Vector3(0, -distance / 2, 0);\n          jointData.connectedPivot = new Vector3(0, distance / 2, 0);\n        }\n\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n\n      case PhysicsJoint.HingeJoint:\n        if (!jointData.mainAxis) {\n          jointData.mainAxis = new Vector3(0, 0, 0);\n        }\n\n        if (!jointData.connectedAxis) {\n          jointData.connectedAxis = new Vector3(0, 0, 0);\n        }\n\n        var mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\n        var connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\n        joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\n        break;\n\n      case PhysicsJoint.BallAndSocketJoint:\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n\n      default:\n        Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n    }\n\n    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\n    impostorJoint.joint.physicsJoint = joint;\n  };\n  /**\r\n   * Removes a joint\r\n   * @param impostorJoint the imposter joint to remove the joint from\r\n   */\n\n\n  AmmoJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    if (this.world) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    }\n  }; // adds all verticies (including child verticies) to the triangle mesh\n\n\n  AmmoJSPlugin.prototype._addMeshVerts = function (btTriangleMesh, topLevelObject, object) {\n    var _this = this;\n\n    var triangleCount = 0;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      object.computeWorldMatrix(false);\n      var faceCount = indices.length / 3;\n\n      for (var i = 0; i < faceCount; i++) {\n        var triPoints = [];\n\n        for (var point = 0; point < 3; point++) {\n          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]); // Adjust for initial scaling\n\n          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n          v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n          var vec;\n\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n\n        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\n        triangleCount++;\n      }\n\n      object.getChildMeshes().forEach(function (m) {\n        triangleCount += _this._addMeshVerts(btTriangleMesh, topLevelObject, m);\n      });\n    }\n\n    return triangleCount;\n  };\n  /**\r\n   * Initialise the soft body vertices to match its object's (mesh) vertices\r\n   * Softbody vertices (nodes) are in world space and to match this\r\n   * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n   * @param impostor to create the softbody for\r\n   */\n\n\n  AmmoJSPlugin.prototype._softVertexData = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n\n      if (!vertexNormals) {\n        vertexNormals = [];\n      }\n\n      object.computeWorldMatrix(false);\n      var newPoints = [];\n      var newNorms = [];\n\n      for (var i = 0; i < vertexPositions.length; i += 3) {\n        var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n        var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\n        n = Vector3.TransformNormal(n, object.getWorldMatrix());\n        newPoints.push(v.x, v.y, v.z);\n        newNorms.push(n.x, n.y, n.z);\n      }\n\n      var vertex_data = new VertexData();\n      vertex_data.positions = newPoints;\n      vertex_data.normals = newNorms;\n      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n\n      if (object && object.getIndices) {\n        vertex_data.indices = object.getIndices();\n      }\n\n      vertex_data.applyToMesh(object);\n      object.position = Vector3.Zero();\n      object.rotationQuaternion = null;\n      object.rotation = Vector3.Zero();\n      object.computeWorldMatrix(true);\n      return vertex_data;\n    }\n\n    return VertexData.ExtractFromMesh(object);\n  };\n  /**\r\n   * Create an impostor's soft body\r\n   * @param impostor to create the softbody for\r\n   */\n\n\n  AmmoJSPlugin.prototype._createSoftbody = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertex_data = this._softVertexData(impostor);\n\n      var vertexPositions = vertex_data.positions;\n      var vertexNormals = vertex_data.normals;\n\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        var triPoints = [];\n        var triNorms = [];\n\n        for (var i = 0; i < vertexPositions.length; i += 3) {\n          var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n          var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n          triPoints.push(v.x, v.y, -v.z);\n          triNorms.push(n.x, n.y, -n.z);\n        }\n\n        var softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\n        var nbVertices = vertexPositions.length / 3;\n        var bodyVertices = softBody.get_m_nodes();\n        var node;\n        var nodeNormals;\n\n        for (var i = 0; i < nbVertices; i++) {\n          node = bodyVertices.at(i);\n          var nodeNormals = node.get_m_n();\n          nodeNormals.setX(triNorms[3 * i]);\n          nodeNormals.setY(triNorms[3 * i + 1]);\n          nodeNormals.setZ(triNorms[3 * i + 2]);\n        }\n\n        return softBody;\n      }\n    }\n  };\n  /**\r\n   * Create cloth for an impostor\r\n   * @param impostor to create the softbody for\r\n   */\n\n\n  AmmoJSPlugin.prototype._createCloth = function (impostor) {\n    var object = impostor.object;\n\n    if (object && object.getIndices) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertex_data = this._softVertexData(impostor);\n\n      var vertexPositions = vertex_data.positions;\n      var vertexNormals = vertex_data.normals;\n\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        var len = vertexPositions.length;\n        var segments = Math.sqrt(len / 3);\n        impostor.segments = segments;\n        var segs = segments - 1;\n\n        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n\n        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\n\n        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n\n        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\n\n        var clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam(\"fixedPoints\"), true);\n        return clothBody;\n      }\n    }\n  };\n  /**\r\n   * Create rope for an impostor\r\n   * @param impostor to create the softbody for\r\n   */\n\n\n  AmmoJSPlugin.prototype._createRope = function (impostor) {\n    var len;\n    var segments;\n\n    var vertex_data = this._softVertexData(impostor);\n\n    var vertexPositions = vertex_data.positions;\n    var vertexNormals = vertex_data.normals;\n\n    if (vertexPositions === null || vertexNormals === null) {\n      return new this.bjsAMMO.btCompoundShape();\n    } //force the mesh to be updatable\n\n\n    vertex_data.applyToMesh(impostor.object, true);\n    impostor._isFromLine = true; // If in lines mesh all normals will be zero\n\n    var vertexSquared = vertexNormals.map(function (x) {\n      return x * x;\n    });\n\n    var reducer = function (accumulator, currentValue) {\n      return accumulator + currentValue;\n    };\n\n    var reduced = vertexSquared.reduce(reducer);\n\n    if (reduced === 0) {\n      // line mesh\n      len = vertexPositions.length;\n      segments = len / 3 - 1;\n\n      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n\n      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n    } else {\n      //extruded mesh\n      impostor._isFromLine = false;\n      var pathVectors = impostor.getParam(\"path\");\n      var shape = impostor.getParam(\"shape\");\n\n      if (shape === null) {\n        Logger.Warn(\"No shape available for extruded mesh\");\n        return new this.bjsAMMO.btCompoundShape();\n      }\n\n      if (vertexPositions.length % (3 * pathVectors.length) !== 0) {\n        Logger.Warn(\"Path does not match extrusion\");\n        return new this.bjsAMMO.btCompoundShape();\n      }\n\n      len = pathVectors.length;\n      segments = len - 1;\n\n      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\n\n      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\n    }\n\n    impostor.segments = segments;\n    var fixedPoints = impostor.getParam(\"fixedPoints\");\n    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\n    var ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\n    ropeBody.get_m_cfg().set_collisions(0x11);\n    return ropeBody;\n  };\n  /**\r\n   * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n   * @param impostor to create the custom physics shape for\r\n   */\n\n\n  AmmoJSPlugin.prototype._createCustom = function (impostor) {\n    var returnValue = null;\n\n    if (this.onCreateCustomShape) {\n      returnValue = this.onCreateCustomShape(impostor);\n    }\n\n    if (returnValue == null) {\n      returnValue = new this.bjsAMMO.btCompoundShape();\n    }\n\n    return returnValue;\n  }; // adds all verticies (including child verticies) to the convex hull shape\n\n\n  AmmoJSPlugin.prototype._addHullVerts = function (btConvexHullShape, topLevelObject, object) {\n    var _this = this;\n\n    var triangleCount = 0;\n\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      var indices = object.getIndices();\n\n      if (!indices) {\n        indices = [];\n      }\n\n      var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n\n      object.computeWorldMatrix(false);\n      var faceCount = indices.length / 3;\n\n      for (var i = 0; i < faceCount; i++) {\n        var triPoints = [];\n\n        for (var point = 0; point < 3; point++) {\n          var v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]); // Adjust for initial scaling\n\n          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n          v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n          var vec;\n\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n\n        btConvexHullShape.addPoint(triPoints[0], true);\n        btConvexHullShape.addPoint(triPoints[1], true);\n        btConvexHullShape.addPoint(triPoints[2], true);\n        triangleCount++;\n      }\n\n      object.getChildMeshes().forEach(function (m) {\n        triangleCount += _this._addHullVerts(btConvexHullShape, topLevelObject, m);\n      });\n    }\n\n    return triangleCount;\n  };\n\n  AmmoJSPlugin.prototype._createShape = function (impostor, ignoreChildren) {\n    var _this = this;\n\n    if (ignoreChildren === void 0) {\n      ignoreChildren = false;\n    }\n\n    var object = impostor.object;\n    var returnValue;\n    var extendSize = impostor.getObjectExtendSize();\n\n    if (!ignoreChildren) {\n      var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\n      returnValue = new this.bjsAMMO.btCompoundShape(); // Add shape of all children to the compound shape\n\n      var childrenAdded = 0;\n      meshChildren.forEach(function (childMesh) {\n        var childImpostor = childMesh.getPhysicsImpostor();\n\n        if (childImpostor) {\n          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\n            throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\n          }\n\n          var shape = _this._createShape(childImpostor); // Position needs to be scaled based on parent's scaling\n\n\n          var parentMat = childMesh.parent.getWorldMatrix().clone();\n          var s = new Vector3();\n          parentMat.decompose(s);\n\n          _this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\n\n          _this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);\n\n          _this._tmpAmmoTransform.setRotation(_this._tmpAmmoQuaternion);\n\n          returnValue.addChildShape(_this._tmpAmmoTransform, shape);\n          childImpostor.dispose();\n          childrenAdded++;\n        }\n      });\n\n      if (childrenAdded > 0) {\n        // Add parents shape as a child if present\n        if (impostor.type != PhysicsImpostor.NoImpostor) {\n          var shape = this._createShape(impostor, true);\n\n          if (shape) {\n            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\n\n            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\n\n            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n\n            returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          }\n        }\n\n        return returnValue;\n      } else {\n        // If no children with impostors create the actual shape below instead\n        this.bjsAMMO.destroy(returnValue);\n        returnValue = null;\n      }\n    }\n\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        // Is there a better way to compare floats number? With an epsylon or with a Math function\n        if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 0.0001) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 0.0001)) {\n          returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\n        } else {\n          // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\n          var positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\n          var radii = [1];\n          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\n          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));\n        }\n\n        break;\n\n      case PhysicsImpostor.CapsuleImpostor:\n        returnValue = new this.bjsAMMO.btCapsuleShape(extendSize.x / 2, extendSize.y / 2);\n        break;\n\n      case PhysicsImpostor.CylinderImpostor:\n        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\n\n        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\n        break;\n\n      case PhysicsImpostor.PlaneImpostor:\n      case PhysicsImpostor.BoxImpostor:\n        this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\n\n        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\n        break;\n\n      case PhysicsImpostor.MeshImpostor:\n        if (impostor.getParam(\"mass\") == 0) {\n          // Only create btBvhTriangleMeshShape impostor is static\n          // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\n          var tetraMesh = new this.bjsAMMO.btTriangleMesh();\n\n          impostor._pluginData.toDispose.push(tetraMesh);\n\n          var triangeCount = this._addMeshVerts(tetraMesh, object, object);\n\n          if (triangeCount == 0) {\n            returnValue = new this.bjsAMMO.btCompoundShape();\n          } else {\n            returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);\n          }\n\n          break;\n        }\n\n      // Otherwise create convexHullImpostor\n\n      case PhysicsImpostor.ConvexHullImpostor:\n        var convexMesh = new this.bjsAMMO.btConvexHullShape();\n\n        var triangeCount = this._addHullVerts(convexMesh, object, object);\n\n        if (triangeCount == 0) {\n          // Cleanup Unused Convex Hull Shape\n          impostor._pluginData.toDispose.push(convexMesh);\n\n          returnValue = new this.bjsAMMO.btCompoundShape();\n        } else {\n          returnValue = convexMesh;\n        }\n\n        break;\n\n      case PhysicsImpostor.NoImpostor:\n        // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\n        returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\n        break;\n\n      case PhysicsImpostor.CustomImpostor:\n        // Only usable when the plugin's onCreateCustomShape is set\n        returnValue = this._createCustom(impostor);\n        break;\n\n      case PhysicsImpostor.SoftbodyImpostor:\n        // Only usable with a mesh that has sufficient and shared vertices\n        returnValue = this._createSoftbody(impostor);\n        break;\n\n      case PhysicsImpostor.ClothImpostor:\n        // Only usable with a ground mesh that has sufficient and shared vertices\n        returnValue = this._createCloth(impostor);\n        break;\n\n      case PhysicsImpostor.RopeImpostor:\n        // Only usable with a line mesh or an extruded mesh that is updatable\n        returnValue = this._createRope(impostor);\n        break;\n\n      default:\n        Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\n        break;\n    }\n\n    return returnValue;\n  };\n  /**\r\n   * Sets the physics body position/rotation from the babylon mesh's position/rotation\r\n   * @param impostor imposter containing the physics body and babylon object\r\n   */\n\n\n  AmmoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\n\n    if (!impostor.object.rotationQuaternion) {\n      if (impostor.object.rotation) {\n        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n\n        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\n      }\n    } else {\n      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n    }\n  };\n  /**\r\n   * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n   * @param impostor imposter containing the physics body and babylon object\r\n   * @param newPosition new position\r\n   * @param newRotation new rotation\r\n   */\n\n\n  AmmoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    var trans = impostor.physicsBody.getWorldTransform(); // If rotation/position has changed update and activate rigged body\n\n    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {\n      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\n\n      trans.setOrigin(this._tmpAmmoVectorA);\n\n      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n\n      trans.setRotation(this._tmpAmmoQuaternion);\n      impostor.physicsBody.setWorldTransform(trans);\n\n      if (impostor.mass == 0) {\n        // Kinematic objects must be updated using motion state\n        var motionState = impostor.physicsBody.getMotionState();\n\n        if (motionState) {\n          motionState.setWorldTransform(trans);\n        }\n      } else {\n        impostor.physicsBody.activate();\n      }\n    }\n  };\n  /**\r\n   * If this plugin is supported\r\n   * @returns true if its supported\r\n   */\n\n\n  AmmoJSPlugin.prototype.isSupported = function () {\n    return this.bjsAMMO !== undefined;\n  };\n  /**\r\n   * Sets the linear velocity of the physics body\r\n   * @param impostor imposter to set the velocity on\r\n   * @param velocity velocity to set\r\n   */\n\n\n  AmmoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n\n    if (impostor.soft) {\n      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\n    }\n  };\n  /**\r\n   * Sets the angular velocity of the physics body\r\n   * @param impostor imposter to set the velocity on\r\n   * @param velocity velocity to set\r\n   */\n\n\n  AmmoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n\n    if (impostor.soft) {\n      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\n    }\n  };\n  /**\r\n   * gets the linear velocity\r\n   * @param impostor imposter to get linear velocity from\r\n   * @returns linear velocity\r\n   */\n\n\n  AmmoJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    if (impostor.soft) {\n      var v = impostor.physicsBody.linearVelocity();\n    } else {\n      var v = impostor.physicsBody.getLinearVelocity();\n    }\n\n    if (!v) {\n      return null;\n    }\n\n    var result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  };\n  /**\r\n   * gets the angular velocity\r\n   * @param impostor imposter to get angular velocity from\r\n   * @returns angular velocity\r\n   */\n\n\n  AmmoJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    if (impostor.soft) {\n      var v = impostor.physicsBody.angularVelocity();\n    } else {\n      var v = impostor.physicsBody.getAngularVelocity();\n    }\n\n    if (!v) {\n      return null;\n    }\n\n    var result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  };\n  /**\r\n   * Sets the mass of physics body\r\n   * @param impostor imposter to set the mass on\r\n   * @param mass mass to set\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    if (impostor.soft) {\n      impostor.physicsBody.setTotalMass(mass, false);\n    } else {\n      impostor.physicsBody.setMassProps(mass);\n    }\n\n    impostor._pluginData.mass = mass;\n  };\n  /**\r\n   * Gets the mass of the physics body\r\n   * @param impostor imposter to get the mass from\r\n   * @returns mass\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor._pluginData.mass || 0;\n  };\n  /**\r\n   * Gets friction of the impostor\r\n   * @param impostor impostor to get friction from\r\n   * @returns friction value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor._pluginData.friction || 0;\n  };\n  /**\r\n   * Sets friction of the impostor\r\n   * @param impostor impostor to set friction on\r\n   * @param friction friction value\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    if (impostor.soft) {\n      impostor.physicsBody.get_m_cfg().set_kDF(friction);\n    } else {\n      impostor.physicsBody.setFriction(friction);\n    }\n\n    impostor._pluginData.friction = friction;\n  };\n  /**\r\n   * Gets restitution of the impostor\r\n   * @param impostor impostor to get restitution from\r\n   * @returns restitution value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor._pluginData.restitution || 0;\n  };\n  /**\r\n   * Sets resitution of the impostor\r\n   * @param impostor impostor to set resitution on\r\n   * @param restitution resitution value\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.setRestitution(restitution);\n    impostor._pluginData.restitution = restitution;\n  };\n  /**\r\n   * Gets pressure inside the impostor\r\n   * @param impostor impostor to get pressure from\r\n   * @returns pressure value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyPressure = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Pressure is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.pressure || 0;\n  };\n  /**\r\n   * Sets pressure inside a soft body impostor\r\n   * Cloth and rope must remain 0 pressure\r\n   * @param impostor impostor to set pressure on\r\n   * @param pressure pressure value\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyPressure = function (impostor, pressure) {\n    if (impostor.soft) {\n      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n        impostor.physicsBody.get_m_cfg().set_kPR(pressure);\n        impostor._pluginData.pressure = pressure;\n      } else {\n        impostor.physicsBody.get_m_cfg().set_kPR(0);\n        impostor._pluginData.pressure = 0;\n      }\n    } else {\n      Logger.Warn(\"Pressure can only be applied to a softbody\");\n    }\n  };\n  /**\r\n   * Gets stiffness of the impostor\r\n   * @param impostor impostor to get stiffness from\r\n   * @returns pressure value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyStiffness = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Stiffness is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.stiffness || 0;\n  };\n  /**\r\n   * Sets stiffness of the impostor\r\n   * @param impostor impostor to set stiffness on\r\n   * @param stiffness stiffness value from 0 to 1\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyStiffness = function (impostor, stiffness) {\n    if (impostor.soft) {\n      stiffness = stiffness < 0 ? 0 : stiffness;\n      stiffness = stiffness > 1 ? 1 : stiffness;\n      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\n      impostor._pluginData.stiffness = stiffness;\n    } else {\n      Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\n    }\n  };\n  /**\r\n   * Gets velocityIterations of the impostor\r\n   * @param impostor impostor to get velocity iterations from\r\n   * @returns velocityIterations value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyVelocityIterations = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.velocityIterations || 0;\n  };\n  /**\r\n   * Sets velocityIterations of the impostor\r\n   * @param impostor impostor to set velocity iterations on\r\n   * @param velocityIterations velocityIterations value\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyVelocityIterations = function (impostor, velocityIterations) {\n    if (impostor.soft) {\n      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\n      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\n      impostor._pluginData.velocityIterations = velocityIterations;\n    } else {\n      Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\n    }\n  };\n  /**\r\n   * Gets positionIterations of the impostor\r\n   * @param impostor impostor to get position iterations from\r\n   * @returns positionIterations value\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBodyPositionIterations = function (impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Position iterations is not a property of a rigid body\");\n      return 0;\n    }\n\n    return impostor._pluginData.positionIterations || 0;\n  };\n  /**\r\n   * Sets positionIterations of the impostor\r\n   * @param impostor impostor to set position on\r\n   * @param positionIterations positionIterations value\r\n   */\n\n\n  AmmoJSPlugin.prototype.setBodyPositionIterations = function (impostor, positionIterations) {\n    if (impostor.soft) {\n      positionIterations = positionIterations < 0 ? 0 : positionIterations;\n      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\n      impostor._pluginData.positionIterations = positionIterations;\n    } else {\n      Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\n    }\n  };\n  /**\r\n  * Append an anchor to a cloth object\r\n  * @param impostor is the cloth impostor to add anchor to\r\n  * @param otherImpostor is the rigid impostor to anchor to\r\n  * @param width ratio across width from 0 to 1\r\n  * @param height ratio up height from 0 to 1\r\n  * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech\r\n  * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n  */\n\n\n  AmmoJSPlugin.prototype.appendAnchor = function (impostor, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {\n    if (influence === void 0) {\n      influence = 1;\n    }\n\n    if (noCollisionBetweenLinkedBodies === void 0) {\n      noCollisionBetweenLinkedBodies = false;\n    }\n\n    var segs = impostor.segments;\n    var nbAcross = Math.round((segs - 1) * width);\n    var nbUp = Math.round((segs - 1) * height);\n    var nbDown = segs - 1 - nbUp;\n    var node = nbAcross + segs * nbDown;\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  };\n  /**\r\n   * Append an hook to a rope object\r\n   * @param impostor is the rope impostor to add hook to\r\n   * @param otherImpostor is the rigid impostor to hook to\r\n   * @param length ratio along the rope from 0 to 1\r\n   * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech\r\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n   */\n\n\n  AmmoJSPlugin.prototype.appendHook = function (impostor, otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {\n    if (influence === void 0) {\n      influence = 1;\n    }\n\n    if (noCollisionBetweenLinkedBodies === void 0) {\n      noCollisionBetweenLinkedBodies = false;\n    }\n\n    var node = Math.round(impostor.segments * length);\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  };\n  /**\r\n   * Sleeps the physics body and stops it from being active\r\n   * @param impostor impostor to sleep\r\n   */\n\n\n  AmmoJSPlugin.prototype.sleepBody = function (impostor) {\n    Logger.Warn(\"sleepBody is not currently supported by the Ammo physics plugin\");\n  };\n  /**\r\n   * Activates the physics body\r\n   * @param impostor impostor to activate\r\n   */\n\n\n  AmmoJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.activate();\n  };\n  /**\r\n   * Updates the distance parameters of the joint\r\n   * @param joint joint to update\r\n   * @param maxDistance maximum distance of the joint\r\n   * @param minDistance minimum distance of the joint\r\n   */\n\n\n  AmmoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {\n    Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\n  };\n  /**\r\n   * Sets a motor on the joint\r\n   * @param joint joint to set motor on\r\n   * @param speed speed of the motor\r\n   * @param maxForce maximum force of the motor\r\n   * @param motorIndex index of the motor\r\n   */\n\n\n  AmmoJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\n  };\n  /**\r\n   * Sets the motors limit\r\n   * @param joint joint to set limit on\r\n   * @param upperLimit upper limit\r\n   * @param lowerLimit lower limit\r\n   */\n\n\n  AmmoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {\n    Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\n  };\n  /**\r\n   * Syncs the position and rotation of a mesh with the impostor\r\n   * @param mesh mesh to sync\r\n   * @param impostor impostor to update the mesh with\r\n   */\n\n\n  AmmoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\n    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\n    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\n      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\n      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\n      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\n    }\n  };\n  /**\r\n   * Gets the radius of the impostor\r\n   * @param impostor impostor to get radius from\r\n   * @returns the radius\r\n   */\n\n\n  AmmoJSPlugin.prototype.getRadius = function (impostor) {\n    var exntend = impostor.getObjectExtendSize();\n    return exntend.x / 2;\n  };\n  /**\r\n   * Gets the box size of the impostor\r\n   * @param impostor impostor to get box size from\r\n   * @param result the resulting box size\r\n   */\n\n\n  AmmoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var exntend = impostor.getObjectExtendSize();\n    result.x = exntend.x;\n    result.y = exntend.y;\n    result.z = exntend.z;\n  };\n  /**\r\n   * Disposes of the impostor\r\n   */\n\n\n  AmmoJSPlugin.prototype.dispose = function () {\n    // Dispose of world\n    this.bjsAMMO.destroy(this.world);\n    this.bjsAMMO.destroy(this._solver);\n    this.bjsAMMO.destroy(this._overlappingPairCache);\n    this.bjsAMMO.destroy(this._dispatcher);\n    this.bjsAMMO.destroy(this._collisionConfiguration); // Dispose of tmp variables\n\n    this.bjsAMMO.destroy(this._tmpAmmoVectorA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorB);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorC);\n    this.bjsAMMO.destroy(this._tmpAmmoTransform);\n    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\n    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\n    this.world = null;\n  };\n  /**\r\n   * Does a raycast in the physics world\r\n   * @param from when should the ray start?\r\n   * @param to when should the ray end?\r\n   * @returns PhysicsRaycastResult\r\n   */\n\n\n  AmmoJSPlugin.prototype.raycast = function (from, to) {\n    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\n    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\n    var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\n    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\n\n    this._raycastResult.reset(from, to);\n\n    if (rayCallback.hasHit()) {\n      // TODO: do we want/need the body? If so, set all the data\n\n      /*\r\n      var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n          rayCallback.get_m_collisionObject()\r\n      );\r\n      var body = {};\r\n      */\n      this._raycastResult.setHitData({\n        x: rayCallback.get_m_hitNormalWorld().x(),\n        y: rayCallback.get_m_hitNormalWorld().y(),\n        z: rayCallback.get_m_hitNormalWorld().z()\n      }, {\n        x: rayCallback.get_m_hitPointWorld().x(),\n        y: rayCallback.get_m_hitPointWorld().y(),\n        z: rayCallback.get_m_hitPointWorld().z()\n      });\n\n      this._raycastResult.calculateHitDistance();\n    }\n\n    this.bjsAMMO.destroy(rayCallback);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\n    return this._raycastResult;\n  };\n\n  AmmoJSPlugin.DISABLE_COLLISION_FLAG = 4;\n  AmmoJSPlugin.KINEMATIC_FLAG = 2;\n  AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG = 4;\n  return AmmoJSPlugin;\n}();\n\nexport { AmmoJSPlugin };","map":{"version":3,"sources":["../../../../sourceES6/core/Physics/Plugins/ammoJSPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Quaternion, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { PhysicsImpostor, IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsJoint, IMotorEnabledJoint, DistanceJointData } from \"../../Physics/physicsJoint\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Nullable } from \"../../types\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { ShapeBuilder } from \"../../Meshes/Builders/shapeBuilder\";\r\nimport { LinesBuilder } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { LinesMesh } from '../../Meshes/linesMesh';\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Epsilon } from '../../Maths/math.constants';\r\n\r\ndeclare var Ammo: any;\r\n\r\n/**\r\n * AmmoJS Physics plugin\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine\r\n * @see https://github.com/kripken/ammo.js/\r\n */\r\nexport class AmmoJSPlugin implements IPhysicsEnginePlugin {\r\n    /**\r\n     * Reference to the Ammo library\r\n     */\r\n    public bjsAMMO: any = {};\r\n    /**\r\n     * Created ammoJS world which physics bodies are added to\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"AmmoJSPlugin\";\r\n\r\n    private _timeStep: number = 1 / 60;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxSteps = 5;\r\n    private _tmpQuaternion = new Quaternion();\r\n    private _tmpAmmoTransform: any;\r\n    private _tmpAmmoQuaternion: any;\r\n    private _tmpAmmoConcreteContactResultCallback: any;\r\n    private _collisionConfiguration: any;\r\n    private _dispatcher: any;\r\n    private _overlappingPairCache: any;\r\n    private _solver: any;\r\n    private _softBodySolver: any;\r\n    private _tmpAmmoVectorA: any;\r\n    private _tmpAmmoVectorB: any;\r\n    private _tmpAmmoVectorC: any;\r\n    private _tmpAmmoVectorD: any;\r\n    private _tmpContactCallbackResult = false;\r\n    private _tmpAmmoVectorRCA: any;\r\n    private _tmpAmmoVectorRCB: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _tmpContactPoint = new Vector3();\r\n\r\n    private static readonly DISABLE_COLLISION_FLAG = 4;\r\n    private static readonly KINEMATIC_FLAG = 2;\r\n    private static readonly DISABLE_DEACTIVATION_FLAG = 4;\r\n\r\n    /**\r\n     * Initializes the ammoJS plugin\r\n     * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\r\n     * @param ammoInjection can be used to inject your own ammo reference\r\n     * @param overlappingPairCache can be used to specify your own overlapping pair cache\r\n     */\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, ammoInjection: any = Ammo, overlappingPairCache: any = null) {\r\n        if (typeof ammoInjection === \"function\") {\r\n            ammoInjection(this.bjsAMMO);\r\n        } else {\r\n            this.bjsAMMO = ammoInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        // Initialize the physics world\r\n        this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\r\n        this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\r\n        this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\r\n        this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\r\n        this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\r\n        this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\r\n\r\n        this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\r\n        this._tmpAmmoConcreteContactResultCallback.addSingleResult = (contactPoint: any, colObj0Wrap: any, partId0: any, index0: any) => {\r\n            contactPoint = this.bjsAMMO.wrapPointer(contactPoint, Ammo.btManifoldPoint);\r\n            const worldPoint = contactPoint.getPositionWorldOnA();\r\n            this._tmpContactPoint.x = worldPoint.x();\r\n            this._tmpContactPoint.y = worldPoint.y();\r\n            this._tmpContactPoint.z = worldPoint.z();\r\n            this._tmpContactCallbackResult = true;\r\n        };\r\n\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n\r\n        // Create temp ammo variables\r\n        this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\r\n        this._tmpAmmoTransform.setIdentity();\r\n        this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\r\n        this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\r\n        this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world (m/(s^2))\r\n     * @param gravity Gravity to set\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\r\n        this.world.setGravity(this._tmpAmmoVectorA);\r\n        this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\r\n    }\r\n\r\n    /**\r\n     * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @param timeStep timestep to use in seconds\r\n     */\r\n    public setTimeStep(timeStep: number) {\r\n        this._timeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\r\n     * @param fixedTimeStep fixedTimeStep to use in seconds\r\n     */\r\n    public setFixedTimeStep(fixedTimeStep: number) {\r\n        this._fixedTimeStep = fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of steps by the physics engine per frame (Default: 5)\r\n     * @param maxSteps the maximum number of steps by the physics engine per frame\r\n     */\r\n    public setMaxSteps(maxSteps: number) {\r\n        this._maxSteps = maxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\r\n     * @returns the current timestep in seconds\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * The create custom shape handler function to be called when using BABYLON.PhysicsImposter.CustomImpostor\r\n     */\r\n    public onCreateCustomShape: (impostor: PhysicsImpostor) => any;\r\n\r\n    // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\r\n    private _isImpostorInContact(impostor: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n    // Ammo's collision events have some weird quirks\r\n    // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\r\n    // so only fire event if both contactTest and contactPairTest have a hit\r\n    private _isImpostorPairInContact(impostorA: PhysicsImpostor, impostorB: PhysicsImpostor) {\r\n        this._tmpContactCallbackResult = false;\r\n        this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\r\n        return this._tmpContactCallbackResult;\r\n    }\r\n\r\n    // Ammo's behavior when maxSteps > 0 does not behave as described in docs\r\n    // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\r\n    //\r\n    // When maxSteps is 0 do the entire simulation in one step\r\n    // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\r\n    // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\r\n    private _stepSimulation(timeStep: number = 1 / 60, maxSteps: number = 10, fixedTimeStep: number = 1 / 60) {\r\n        if (maxSteps == 0) {\r\n            this.world.stepSimulation(timeStep, 0);\r\n        } else {\r\n            while (maxSteps > 0 && timeStep > 0) {\r\n                if (timeStep - fixedTimeStep < fixedTimeStep) {\r\n                    this.world.stepSimulation(timeStep, 0);\r\n                    timeStep = 0;\r\n                } else {\r\n                    timeStep -= fixedTimeStep;\r\n                    this.world.stepSimulation(fixedTimeStep, 0);\r\n                }\r\n                maxSteps--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves the physics simulation forward delta seconds and updates the given physics imposters\r\n     * Prior to the step the imposters physics location is set to the position of the babylon meshes\r\n     * After the step the babylon meshes are set to the position of the physics imposters\r\n     * @param delta amount of time to step forward\r\n     * @param impostors array of imposters to update before/after the step\r\n     */\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        for (var impostor of impostors) {\r\n            // Update physics world objects to match babylon world\r\n            if (!impostor.soft) {\r\n                impostor.beforeStep();\r\n            }\r\n        }\r\n\r\n        this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\r\n\r\n        for (var mainImpostor of impostors) {\r\n            // After physics update make babylon world objects match physics world objects\r\n            if (mainImpostor.soft) {\r\n                this._afterSoftStep(mainImpostor);\r\n            }\r\n            else {\r\n                mainImpostor.afterStep();\r\n            }\r\n\r\n            // Handle collision event\r\n            if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\r\n                if (this._isImpostorInContact(mainImpostor)) {\r\n                    for (var collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\r\n                        for (var otherImpostor of collideCallback.otherImpostors) {\r\n                            if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\r\n                                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\r\n                                    mainImpostor.onCollide({ body: otherImpostor.physicsBody, point: this._tmpContactPoint });\r\n                                    otherImpostor.onCollide({ body: mainImpostor.physicsBody, point: this._tmpContactPoint });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh to match physics world object\r\n     * @param impostor imposter to match\r\n     */\r\n    private _afterSoftStep(impostor: PhysicsImpostor): void {\r\n        if (impostor.type === PhysicsImpostor.RopeImpostor) {\r\n            this._ropeStep(impostor);\r\n        }\r\n        else {\r\n            this._softbodyOrClothStep(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _ropeStep(impostor: PhysicsImpostor): void {\r\n        var bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        var nbVertices = bodyVertices.size();\r\n        var node: any;\r\n        var nodePositions: any;\r\n        var x, y, z: number;\r\n        var path: Array<Vector3> = new Array();\r\n        for (var n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z();\r\n            path.push(new Vector3(x, y, z));\r\n        }\r\n        var object = impostor.object;\r\n        var shape = impostor.getParam(\"shape\");\r\n        if (impostor._isFromLine) {\r\n            impostor.object = LinesBuilder.CreateLines(\"lines\", { points: path, instance: <LinesMesh>object });\r\n        }\r\n        else {\r\n            impostor.object = ShapeBuilder.ExtrudeShape(\"ext\", { shape: shape, path: path, instance: <Mesh>object });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Update babylon mesh vertices vertices to match physics world softbody or cloth\r\n     * @param impostor imposter to match\r\n     */\r\n    private _softbodyOrClothStep(impostor: PhysicsImpostor): void {\r\n        var normalDirection = (impostor.type === PhysicsImpostor.ClothImpostor) ? 1 : -1;\r\n        var object = impostor.object;\r\n        var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n        if (!vertexPositions) {\r\n            vertexPositions = [];\r\n        }\r\n        var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n        if (!vertexNormals) {\r\n            vertexNormals = [];\r\n        }\r\n\r\n        var nbVertices = vertexPositions.length / 3;\r\n        var bodyVertices = impostor.physicsBody.get_m_nodes();\r\n        var node: any;\r\n        var nodePositions: any;\r\n        var nodeNormals: any;\r\n        var x, y, z: number;\r\n        var nx, ny, nz: number;\r\n        for (var n = 0; n < nbVertices; n++) {\r\n            node = bodyVertices.at(n);\r\n            nodePositions = node.get_m_x();\r\n            x = nodePositions.x();\r\n            y = nodePositions.y();\r\n            z = nodePositions.z() * normalDirection;\r\n            var nodeNormals = node.get_m_n();\r\n            nx = nodeNormals.x();\r\n            ny = nodeNormals.y();\r\n            nz = nodeNormals.z() * normalDirection;\r\n\r\n            vertexPositions[3 * n] = x;\r\n            vertexPositions[3 * n + 1] = y;\r\n            vertexPositions[3 * n + 2] = z;\r\n            vertexNormals[3 * n] = nx;\r\n            vertexNormals[3 * n + 1] = ny;\r\n            vertexNormals[3 * n + 2] = nz;\r\n        }\r\n\r\n        var vertex_data = new VertexData();\r\n\r\n        vertex_data.positions = vertexPositions;\r\n        vertex_data.normals = vertexNormals;\r\n        vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n        vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n        if (object && object.getIndices) {\r\n            vertex_data.indices = object.getIndices();\r\n        }\r\n\r\n        vertex_data.applyToMesh(<Mesh>object);\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * Applies an impulse on the imposter\r\n     * @param impostor imposter to apply impulse to\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the impulse on the imposter\r\n     */\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            var worldPoint = this._tmpAmmoVectorA;\r\n            var impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n        }\r\n        else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a force on the imposter\r\n     * @param impostor imposter to apply force\r\n     * @param force amount of force to be applied to the imposter\r\n     * @param contactPoint the location to apply the force on the imposter\r\n     */\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        if (!impostor.soft) {\r\n            impostor.physicsBody.activate();\r\n            var worldPoint = this._tmpAmmoVectorA;\r\n            var impulse = this._tmpAmmoVectorB;\r\n\r\n            // Convert contactPoint relative to center of mass\r\n            if (impostor.object && impostor.object.getWorldMatrix) {\r\n                contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\r\n            }\r\n\r\n            worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\r\n            impulse.setValue(force.x, force.y, force.z);\r\n\r\n            impostor.physicsBody.applyForce(impulse, worldPoint);\r\n        }\r\n        else {\r\n            Logger.Warn(\"Cannot be applied to a soft body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a physics body using the plugin\r\n     * @param impostor the imposter to create the physics body on\r\n     */\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // Note: this method will not be called on child imposotrs for compound impostors\r\n\r\n        impostor._pluginData.toDispose = [];\r\n\r\n        //parent-child relationship\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            var colShape = this._createShape(impostor);\r\n            var mass = impostor.getParam(\"mass\");\r\n            impostor._pluginData.mass = mass;\r\n            if (impostor.soft) {\r\n                colShape.get_m_cfg().set_collisions(0x11);\r\n                colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\r\n                this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\r\n                colShape.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\r\n                this.world.addSoftBody(colShape, 1, -1);\r\n                impostor.physicsBody = colShape;\r\n                impostor._pluginData.toDispose.push(colShape);\r\n                this.setBodyPressure(impostor, 0);\r\n                if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                    this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\r\n                }\r\n                this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\r\n                this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\r\n                this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\r\n            }\r\n            else {\r\n                var localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\r\n                var startTransform = new this.bjsAMMO.btTransform();\r\n                startTransform.setIdentity();\r\n                if (mass !== 0) {\r\n                    colShape.calculateLocalInertia(mass, localInertia);\r\n                }\r\n                this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\r\n                this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion!.x, impostor.object.rotationQuaternion!.y, impostor.object.rotationQuaternion!.z, impostor.object.rotationQuaternion!.w);\r\n                startTransform.setOrigin(this._tmpAmmoVectorA);\r\n                startTransform.setRotation(this._tmpAmmoQuaternion);\r\n                var myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\r\n                var rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\r\n                var body = new this.bjsAMMO.btRigidBody(rbInfo);\r\n\r\n                // Make objects kinematic if it's mass is 0\r\n                if (mass === 0) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.KINEMATIC_FLAG);\r\n                    body.setActivationState(AmmoJSPlugin.DISABLE_DEACTIVATION_FLAG);\r\n                }\r\n\r\n                // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\r\n                if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\r\n                    body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin.DISABLE_COLLISION_FLAG);\r\n                }\r\n\r\n                let group = impostor.getParam(\"group\");\r\n                let mask = impostor.getParam(\"mask\");\r\n                if (group && mask) {\r\n                    this.world.addRigidBody(body, group, mask);\r\n                } else {\r\n                    this.world.addRigidBody(body);\r\n                }\r\n                impostor.physicsBody = body;\r\n                impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\r\n            }\r\n            this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\r\n            this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the physics body from the imposter and disposes of the body's memory\r\n     * @param impostor imposter to remove the physics body from\r\n     */\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        if (this.world) {\r\n            if (impostor.soft) {\r\n                this.world.removeSoftBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.removeRigidBody(impostor.physicsBody);\r\n            }\r\n\r\n            if (impostor._pluginData) {\r\n                impostor._pluginData.toDispose.forEach((d: any) => {\r\n                    this.bjsAMMO.destroy(d);\r\n                });\r\n                impostor._pluginData.toDispose = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates a joint\r\n     * @param impostorJoint the imposter joint to create the joint with\r\n     */\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        var mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        var connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n\r\n        var jointData = impostorJoint.joint.jointData;\r\n        if (!jointData.mainPivot) {\r\n            jointData.mainPivot = new Vector3(0, 0, 0);\r\n        }\r\n        if (!jointData.connectedPivot) {\r\n            jointData.connectedPivot = new Vector3(0, 0, 0);\r\n        }\r\n\r\n        var joint: any;\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.DistanceJoint:\r\n                var distance = (<DistanceJointData>jointData).maxDistance;\r\n                if (distance) {\r\n                    jointData.mainPivot = new Vector3(0, -distance / 2, 0);\r\n                    jointData.connectedPivot = new Vector3(0, distance / 2, 0);\r\n                }\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n                if (!jointData.mainAxis) {\r\n                    jointData.mainAxis = new Vector3(0, 0, 0);\r\n                }\r\n                if (!jointData.connectedAxis) {\r\n                    jointData.connectedAxis = new Vector3(0, 0, 0);\r\n                }\r\n                var mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\r\n                var connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\r\n                joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\r\n                break;\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n            default:\r\n                Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\r\n                joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\r\n                break;\r\n        }\r\n        this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\r\n        impostorJoint.joint.physicsJoint = joint;\r\n    }\r\n\r\n    /**\r\n     * Removes a joint\r\n     * @param impostorJoint the imposter joint to remove the joint from\r\n     */\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (this.world) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        }\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the triangle mesh\r\n    private _addMeshVerts(btTriangleMesh: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        var triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var faceCount = indices.length / 3;\r\n            for (var i = 0; i < faceCount; i++) {\r\n                var triPoints = [];\r\n                for (var point = 0; point < 3; point++) {\r\n                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    var vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    /**\r\n     * Initialise the soft body vertices to match its object's (mesh) vertices\r\n     * Softbody vertices (nodes) are in world space and to match this\r\n     * The object's position and rotation is set to zero and so its vertices are also then set in world space\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _softVertexData(impostor: PhysicsImpostor): VertexData {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            var vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\r\n            if (!vertexNormals) {\r\n                vertexNormals = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var newPoints = [];\r\n            var newNorms = [];\r\n            for (var i = 0; i < vertexPositions.length; i += 3) {\r\n                var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\r\n                n = Vector3.TransformNormal(n, object.getWorldMatrix());\r\n                newPoints.push(v.x, v.y, v.z);\r\n                newNorms.push(n.x, n.y, n.z);\r\n            }\r\n\r\n            var vertex_data = new VertexData();\r\n\r\n            vertex_data.positions = newPoints;\r\n            vertex_data.normals = newNorms;\r\n            vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\r\n            vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\r\n            if (object && object.getIndices) {\r\n                vertex_data.indices = object.getIndices();\r\n            }\r\n\r\n            vertex_data.applyToMesh(<Mesh>object);\r\n\r\n            object.position = Vector3.Zero();\r\n            object.rotationQuaternion = null;\r\n            object.rotation = Vector3.Zero();\r\n            object.computeWorldMatrix(true);\r\n\r\n            return vertex_data;\r\n        }\r\n        return VertexData.ExtractFromMesh(<Mesh>object);\r\n    }\r\n\r\n    /**\r\n     * Create an impostor's soft body\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createSoftbody(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            var vertex_data = this._softVertexData(impostor);\r\n            var vertexPositions = vertex_data.positions;\r\n            var vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            else {\r\n                var triPoints = [];\r\n                var triNorms = [];\r\n                for (var i = 0; i < vertexPositions.length; i += 3) {\r\n                    var v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\r\n                    var n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\r\n                    triPoints.push(v.x, v.y, -v.z);\r\n                    triNorms.push(n.x, n.y, -n.z);\r\n                }\r\n                var softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(\r\n                    this.world.getWorldInfo(),\r\n                    triPoints,\r\n                    object.getIndices(),\r\n                    indices.length / 3,\r\n                    true\r\n                );\r\n\r\n                var nbVertices = vertexPositions.length / 3;\r\n                var bodyVertices = softBody.get_m_nodes();\r\n                var node: any;\r\n                var nodeNormals: any;\r\n                for (var i = 0; i < nbVertices; i++) {\r\n                    node = bodyVertices.at(i);\r\n                    var nodeNormals = node.get_m_n();\r\n                    nodeNormals.setX(triNorms[3 * i]);\r\n                    nodeNormals.setY(triNorms[3 * i + 1]);\r\n                    nodeNormals.setZ(triNorms[3 * i + 2]);\r\n                }\r\n                return softBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create cloth for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createCloth(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n        if (object && object.getIndices) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n\r\n            var vertex_data = this._softVertexData(impostor);\r\n            var vertexPositions = vertex_data.positions;\r\n            var vertexNormals = vertex_data.normals;\r\n\r\n            if (vertexPositions === null || vertexNormals === null) {\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            else {\r\n                var len = vertexPositions.length;\r\n                var segments = Math.sqrt(len / 3);\r\n                impostor.segments = segments;\r\n                var segs = segments - 1;\r\n                this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n                this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\r\n                this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n                this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\r\n\r\n                var clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(\r\n                    this.world.getWorldInfo(),\r\n                    this._tmpAmmoVectorA,\r\n                    this._tmpAmmoVectorB,\r\n                    this._tmpAmmoVectorC,\r\n                    this._tmpAmmoVectorD,\r\n                    segments,\r\n                    segments,\r\n                    impostor.getParam(\"fixedPoints\"),\r\n                    true\r\n                );\r\n                return clothBody;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create rope for an impostor\r\n     * @param impostor to create the softbody for\r\n     */\r\n    private _createRope(impostor: PhysicsImpostor) {\r\n        var len: number;\r\n        var segments: number;\r\n        var vertex_data = this._softVertexData(impostor);\r\n        var vertexPositions = vertex_data.positions;\r\n        var vertexNormals = vertex_data.normals;\r\n\r\n        if (vertexPositions === null || vertexNormals === null) {\r\n            return new this.bjsAMMO.btCompoundShape();\r\n        }\r\n\r\n        //force the mesh to be updatable\r\n        vertex_data.applyToMesh(<Mesh>impostor.object, true);\r\n\r\n        impostor._isFromLine = true;\r\n\r\n        // If in lines mesh all normals will be zero\r\n        var vertexSquared: Array<number> = <Array<number>>vertexNormals.map((x: number) => x * x);\r\n        var reducer = (accumulator: number, currentValue: number): number => accumulator + currentValue;\r\n        var reduced: number = vertexSquared.reduce(reducer);\r\n\r\n        if (reduced === 0) { // line mesh\r\n            len = vertexPositions.length;\r\n            segments = len / 3 - 1;\r\n            this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\r\n            this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\r\n        }\r\n        else { //extruded mesh\r\n            impostor._isFromLine = false;\r\n            var pathVectors = impostor.getParam(\"path\");\r\n            var shape = impostor.getParam(\"shape\");\r\n            if (shape === null) {\r\n                Logger.Warn(\"No shape available for extruded mesh\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            if ((vertexPositions!.length % (3 * pathVectors.length)) !== 0) {\r\n                Logger.Warn(\"Path does not match extrusion\");\r\n                return new this.bjsAMMO.btCompoundShape();\r\n            }\r\n            len = pathVectors.length;\r\n            segments = len - 1;\r\n            this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\r\n            this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\r\n        }\r\n\r\n        impostor.segments = segments;\r\n\r\n        var fixedPoints = impostor.getParam(\"fixedPoints\");\r\n        fixedPoints = (fixedPoints > 3) ? 3 : fixedPoints;\r\n\r\n        var ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(\r\n            this.world.getWorldInfo(),\r\n            this._tmpAmmoVectorA,\r\n            this._tmpAmmoVectorB,\r\n            segments - 1,\r\n            fixedPoints\r\n        );\r\n        ropeBody.get_m_cfg().set_collisions(0x11);\r\n        return ropeBody;\r\n    }\r\n\r\n    /**\r\n     * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\r\n     * @param impostor to create the custom physics shape for\r\n     */\r\n    private _createCustom(impostor: PhysicsImpostor): any {\r\n        let returnValue: any = null;\r\n        if (this.onCreateCustomShape) {\r\n            returnValue = this.onCreateCustomShape(impostor);\r\n        }\r\n        if (returnValue == null) {\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    // adds all verticies (including child verticies) to the convex hull shape\r\n    private _addHullVerts(btConvexHullShape: any, topLevelObject: IPhysicsEnabledObject, object: IPhysicsEnabledObject) {\r\n        var triangleCount = 0;\r\n        if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\r\n            var indices = object.getIndices();\r\n            if (!indices) {\r\n                indices = [];\r\n            }\r\n            var vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\r\n            if (!vertexPositions) {\r\n                vertexPositions = [];\r\n            }\r\n            object.computeWorldMatrix(false);\r\n            var faceCount = indices.length / 3;\r\n            for (var i = 0; i < faceCount; i++) {\r\n                var triPoints = [];\r\n                for (var point = 0; point < 3; point++) {\r\n                    var v = new Vector3(vertexPositions[(indices[(i * 3) + point] * 3) + 0], vertexPositions[(indices[(i * 3) + point] * 3) + 1], vertexPositions[(indices[(i * 3) + point] * 3) + 2]);\r\n\r\n                    // Adjust for initial scaling\r\n                    Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\r\n                    v = Vector3.TransformCoordinates(v, this._tmpMatrix);\r\n\r\n                    var vec: any;\r\n                    if (point == 0) {\r\n                        vec = this._tmpAmmoVectorA;\r\n                    } else if (point == 1) {\r\n                        vec = this._tmpAmmoVectorB;\r\n                    } else {\r\n                        vec = this._tmpAmmoVectorC;\r\n                    }\r\n                    vec.setValue(v.x, v.y, v.z);\r\n\r\n                    triPoints.push(vec);\r\n                }\r\n                btConvexHullShape.addPoint(triPoints[0], true);\r\n                btConvexHullShape.addPoint(triPoints[1], true);\r\n                btConvexHullShape.addPoint(triPoints[2], true);\r\n                triangleCount++;\r\n            }\r\n\r\n            object.getChildMeshes().forEach((m) => {\r\n                triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\r\n            });\r\n        }\r\n        return triangleCount;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor, ignoreChildren = false) {\r\n        var object = impostor.object;\r\n\r\n        var returnValue: any;\r\n        var extendSize = impostor.getObjectExtendSize();\r\n\r\n        if (!ignoreChildren) {\r\n            var meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\r\n            returnValue = new this.bjsAMMO.btCompoundShape();\r\n\r\n            // Add shape of all children to the compound shape\r\n            var childrenAdded = 0;\r\n            meshChildren.forEach((childMesh) => {\r\n                var childImpostor = childMesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\r\n                        throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\r\n                    }\r\n                    var shape = this._createShape(childImpostor);\r\n\r\n                    // Position needs to be scaled based on parent's scaling\r\n                    var parentMat = childMesh.parent!.getWorldMatrix().clone();\r\n                    var s = new Vector3();\r\n                    parentMat.decompose(s);\r\n                    this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\r\n\r\n                    this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion!.x, childMesh.rotationQuaternion!.y, childMesh.rotationQuaternion!.z, childMesh.rotationQuaternion!.w);\r\n                    this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n                    returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    childImpostor.dispose();\r\n                    childrenAdded++;\r\n                }\r\n            });\r\n\r\n            if (childrenAdded > 0) {\r\n                // Add parents shape as a child if present\r\n                if (impostor.type != PhysicsImpostor.NoImpostor) {\r\n                    var shape = this._createShape(impostor, true);\r\n                    if (shape) {\r\n                        this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\r\n                        this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\r\n                        this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\r\n\r\n                        returnValue.addChildShape(this._tmpAmmoTransform, shape);\r\n                    }\r\n                }\r\n                return returnValue;\r\n            } else {\r\n                // If no children with impostors create the actual shape below instead\r\n                this.bjsAMMO.destroy(returnValue);\r\n                returnValue = null;\r\n            }\r\n        }\r\n\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                // Is there a better way to compare floats number? With an epsylon or with a Math function\r\n                if (Scalar.WithinEpsilon(extendSize.x, extendSize.y, 0.0001) && Scalar.WithinEpsilon(extendSize.x, extendSize.z, 0.0001)) {\r\n                    returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                } else {\r\n                    // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\r\n                    var positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\r\n                    var radii = [1];\r\n                    returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\r\n                    returnValue.setLocalScaling(new this.bjsAMMO.btVector3(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2));\r\n                }\r\n                break;\r\n            case PhysicsImpostor.CapsuleImpostor:\r\n                returnValue = new this.bjsAMMO.btCapsuleShape(extendSize.x / 2, extendSize.y / 2);\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n            case PhysicsImpostor.BoxImpostor:\r\n                this._tmpAmmoVectorA.setValue(extendSize.x / 2, extendSize.y / 2, extendSize.z / 2);\r\n                returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor:\r\n                if (impostor.getParam(\"mass\") == 0) {\r\n                    // Only create btBvhTriangleMeshShape impostor is static\r\n                    // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\r\n                    var tetraMesh = new this.bjsAMMO.btTriangleMesh();\r\n                    impostor._pluginData.toDispose.push(tetraMesh);\r\n                    var triangeCount = this._addMeshVerts(tetraMesh, object, object);\r\n                    if (triangeCount == 0) {\r\n                        returnValue = new this.bjsAMMO.btCompoundShape();\r\n                    } else {\r\n                        returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(tetraMesh);\r\n                    }\r\n                    break;\r\n                }\r\n            // Otherwise create convexHullImpostor\r\n            case PhysicsImpostor.ConvexHullImpostor:\r\n                var convexMesh = new this.bjsAMMO.btConvexHullShape();\r\n                var triangeCount = this._addHullVerts(convexMesh, object, object);\r\n                if (triangeCount == 0) {\r\n                    // Cleanup Unused Convex Hull Shape\r\n                    impostor._pluginData.toDispose.push(convexMesh);\r\n                    returnValue = new this.bjsAMMO.btCompoundShape();\r\n                } else {\r\n                    returnValue = convexMesh;\r\n                }\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\r\n                returnValue = new this.bjsAMMO.btSphereShape(extendSize.x / 2);\r\n                break;\r\n            case PhysicsImpostor.CustomImpostor:\r\n                // Only usable when the plugin's onCreateCustomShape is set\r\n                returnValue = this._createCustom(impostor);\r\n                break;\r\n            case PhysicsImpostor.SoftbodyImpostor:\r\n                // Only usable with a mesh that has sufficient and shared vertices\r\n                returnValue = this._createSoftbody(impostor);\r\n                break;\r\n            case PhysicsImpostor.ClothImpostor:\r\n                // Only usable with a ground mesh that has sufficient and shared vertices\r\n                returnValue = this._createCloth(impostor);\r\n                break;\r\n            case PhysicsImpostor.RopeImpostor:\r\n                // Only usable with a line mesh or an extruded mesh that is updatable\r\n                returnValue = this._createRope(impostor);\r\n                break;\r\n            default:\r\n                Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the physics body position/rotation from the babylon mesh's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     */\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n        impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\r\n\r\n        if (!impostor.object.rotationQuaternion) {\r\n            if (impostor.object.rotation) {\r\n                this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\r\n                this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\r\n            }\r\n        } else {\r\n            impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the babylon object's position/rotation from the physics body's position/rotation\r\n     * @param impostor imposter containing the physics body and babylon object\r\n     * @param newPosition new position\r\n     * @param newRotation new rotation\r\n     */\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        var trans = impostor.physicsBody.getWorldTransform();\r\n\r\n        // If rotation/position has changed update and activate rigged body\r\n        if (\r\n            Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon ||\r\n            Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon ||\r\n            Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon ||\r\n            Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon ||\r\n            Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon ||\r\n            Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon\r\n        ) {\r\n            this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\r\n            trans.setOrigin(this._tmpAmmoVectorA);\r\n\r\n            this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n            trans.setRotation(this._tmpAmmoQuaternion);\r\n            impostor.physicsBody.setWorldTransform(trans);\r\n\r\n            if (impostor.mass == 0) {\r\n                // Kinematic objects must be updated using motion state\r\n                var motionState = impostor.physicsBody.getMotionState();\r\n                if (motionState) {\r\n                    motionState.setWorldTransform(trans);\r\n                }\r\n            } else {\r\n                impostor.physicsBody.activate();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsAMMO !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of the physics body\r\n     * @param impostor imposter to set the velocity on\r\n     * @param velocity velocity to set\r\n     */\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * gets the linear velocity\r\n     * @param impostor imposter to get linear velocity from\r\n     * @returns linear velocity\r\n     */\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        if (impostor.soft) {\r\n            var v = impostor.physicsBody.linearVelocity();\r\n        }\r\n        else {\r\n            var v = impostor.physicsBody.getLinearVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        var result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * gets the angular velocity\r\n     * @param impostor imposter to get angular velocity from\r\n     * @returns angular velocity\r\n     */\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        if (impostor.soft) {\r\n            var v = impostor.physicsBody.angularVelocity();\r\n        }\r\n        else {\r\n            var v = impostor.physicsBody.getAngularVelocity();\r\n        }\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        var result = new Vector3(v.x(), v.y(), v.z());\r\n        this.bjsAMMO.destroy(v);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the mass of physics body\r\n     * @param impostor imposter to set the mass on\r\n     * @param mass mass to set\r\n     */\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.setTotalMass(mass, false);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setMassProps(mass);\r\n        }\r\n        impostor._pluginData.mass = mass;\r\n    }\r\n\r\n    /**\r\n     * Gets the mass of the physics body\r\n     * @param impostor imposter to get the mass from\r\n     * @returns mass\r\n     */\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.mass || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets friction of the impostor\r\n     * @param impostor impostor to get friction from\r\n     * @returns friction value\r\n     */\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.friction || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets friction of the impostor\r\n     * @param impostor impostor to set friction on\r\n     * @param friction friction value\r\n     */\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        if (impostor.soft) {\r\n            impostor.physicsBody.get_m_cfg().set_kDF(friction);\r\n        }\r\n        else {\r\n            impostor.physicsBody.setFriction(friction);\r\n        }\r\n        impostor._pluginData.friction = friction;\r\n    }\r\n\r\n    /**\r\n     * Gets restitution of the impostor\r\n     * @param impostor impostor to get restitution from\r\n     * @returns restitution value\r\n     */\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor._pluginData.restitution || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets resitution of the impostor\r\n     * @param impostor impostor to set resitution on\r\n     * @param restitution resitution value\r\n     */\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.setRestitution(restitution);\r\n        impostor._pluginData.restitution = restitution;\r\n    }\r\n\r\n    /**\r\n     * Gets pressure inside the impostor\r\n     * @param impostor impostor to get pressure from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyPressure(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Pressure is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.pressure || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets pressure inside a soft body impostor\r\n     * Cloth and rope must remain 0 pressure\r\n     * @param impostor impostor to set pressure on\r\n     * @param pressure pressure value\r\n     */\r\n    public setBodyPressure(impostor: PhysicsImpostor, pressure: number) {\r\n        if (impostor.soft) {\r\n            if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(pressure);\r\n                impostor._pluginData.pressure = pressure;\r\n            }\r\n            else {\r\n                impostor.physicsBody.get_m_cfg().set_kPR(0);\r\n                impostor._pluginData.pressure = 0;\r\n            }\r\n        }\r\n        else {\r\n            Logger.Warn(\"Pressure can only be applied to a softbody\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets stiffness of the impostor\r\n     * @param impostor impostor to get stiffness from\r\n     * @returns pressure value\r\n     */\r\n    public getBodyStiffness(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Stiffness is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.stiffness || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets stiffness of the impostor\r\n     * @param impostor impostor to set stiffness on\r\n     * @param stiffness stiffness value from 0 to 1\r\n     */\r\n    public setBodyStiffness(impostor: PhysicsImpostor, stiffness: number) {\r\n        if (impostor.soft) {\r\n            stiffness = stiffness < 0 ? 0 : stiffness;\r\n            stiffness = stiffness > 1 ? 1 : stiffness;\r\n            impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\r\n            impostor._pluginData.stiffness = stiffness;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets velocityIterations of the impostor\r\n     * @param impostor impostor to get velocity iterations from\r\n     * @returns velocityIterations value\r\n     */\r\n    public getBodyVelocityIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.velocityIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets velocityIterations of the impostor\r\n     * @param impostor impostor to set velocity iterations on\r\n     * @param velocityIterations velocityIterations value\r\n     */\r\n    public setBodyVelocityIterations(impostor: PhysicsImpostor, velocityIterations: number) {\r\n        if (impostor.soft) {\r\n            velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\r\n            impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\r\n            impostor._pluginData.velocityIterations = velocityIterations;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets positionIterations of the impostor\r\n     * @param impostor impostor to get position iterations from\r\n     * @returns positionIterations value\r\n     */\r\n    public getBodyPositionIterations(impostor: PhysicsImpostor): number {\r\n        if (!impostor.soft) {\r\n            Logger.Warn(\"Position iterations is not a property of a rigid body\");\r\n            return 0;\r\n        }\r\n        return impostor._pluginData.positionIterations || 0;\r\n    }\r\n\r\n    /**\r\n     * Sets positionIterations of the impostor\r\n     * @param impostor impostor to set position on\r\n     * @param positionIterations positionIterations value\r\n     */\r\n    public setBodyPositionIterations(impostor: PhysicsImpostor, positionIterations: number) {\r\n        if (impostor.soft) {\r\n            positionIterations = positionIterations < 0 ? 0 : positionIterations;\r\n            impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\r\n            impostor._pluginData.positionIterations = positionIterations;\r\n        }\r\n        else {\r\n            Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Append an anchor to a cloth object\r\n    * @param impostor is the cloth impostor to add anchor to\r\n    * @param otherImpostor is the rigid impostor to anchor to\r\n    * @param width ratio across width from 0 to 1\r\n    * @param height ratio up height from 0 to 1\r\n    * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little strech\r\n    * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n    */\r\n    public appendAnchor(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, width: number, height: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        var segs = impostor.segments;\r\n        var nbAcross = Math.round((segs - 1) * width);\r\n        var nbUp = Math.round((segs - 1) * height);\r\n        var nbDown = segs - 1 - nbUp;\r\n        var node = nbAcross + segs * nbDown;\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Append an hook to a rope object\r\n     * @param impostor is the rope impostor to add hook to\r\n     * @param otherImpostor is the rigid impostor to hook to\r\n     * @param length ratio along the rope from 0 to 1\r\n     * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little strech\r\n     * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\r\n     */\r\n    public appendHook(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number = 1, noCollisionBetweenLinkedBodies: boolean = false) {\r\n        var node = Math.round(impostor.segments * length);\r\n        impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\r\n    }\r\n\r\n    /**\r\n     * Sleeps the physics body and stops it from being active\r\n     * @param impostor impostor to sleep\r\n     */\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        Logger.Warn(\"sleepBody is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Activates the physics body\r\n     * @param impostor impostor to activate\r\n     */\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.activate();\r\n    }\r\n\r\n    /**\r\n     * Updates the distance parameters of the joint\r\n     * @param joint joint to update\r\n     * @param maxDistance maximum distance of the joint\r\n     * @param minDistance minimum distance of the joint\r\n     */\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Sets a motor on the joint\r\n     * @param joint joint to set motor on\r\n     * @param speed speed of the motor\r\n     * @param maxForce maximum force of the motor\r\n     * @param motorIndex index of the motor\r\n     */\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\r\n    }\r\n\r\n    /**\r\n     * Sets the motors limit\r\n     * @param joint joint to set limit on\r\n     * @param upperLimit upper limit\r\n     * @param lowerLimit lower limit\r\n     */\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number) {\r\n        Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\r\n    }\r\n\r\n    /**\r\n     * Syncs the position and rotation of a mesh with the impostor\r\n     * @param mesh mesh to sync\r\n     * @param impostor impostor to update the mesh with\r\n     */\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        var body = impostor.physicsBody;\r\n\r\n        body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\r\n\r\n        mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\r\n        mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\r\n        mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\r\n            mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\r\n            mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\r\n            mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the radius of the impostor\r\n     * @param impostor impostor to get radius from\r\n     * @returns the radius\r\n     */\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        var exntend = impostor.getObjectExtendSize();\r\n        return exntend.x / 2;\r\n    }\r\n\r\n    /**\r\n     * Gets the box size of the impostor\r\n     * @param impostor impostor to get box size from\r\n     * @param result the resulting box size\r\n     */\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        var exntend = impostor.getObjectExtendSize();\r\n        result.x = exntend.x;\r\n        result.y = exntend.y;\r\n        result.z = exntend.z;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the impostor\r\n     */\r\n    public dispose() {\r\n        // Dispose of world\r\n        this.bjsAMMO.destroy(this.world);\r\n        this.bjsAMMO.destroy(this._solver);\r\n        this.bjsAMMO.destroy(this._overlappingPairCache);\r\n        this.bjsAMMO.destroy(this._dispatcher);\r\n        this.bjsAMMO.destroy(this._collisionConfiguration);\r\n\r\n        // Dispose of tmp variables\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorB);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorC);\r\n        this.bjsAMMO.destroy(this._tmpAmmoTransform);\r\n        this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\r\n        this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\r\n\r\n        this.world = null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\r\n        this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\r\n\r\n        var rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\r\n        this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (rayCallback.hasHit()) {\r\n            // TODO: do we want/need the body? If so, set all the data\r\n            /*\r\n            var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\r\n                rayCallback.get_m_collisionObject()\r\n            );\r\n            var body = {};\r\n            */\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: rayCallback.get_m_hitNormalWorld().x(),\r\n                    y: rayCallback.get_m_hitNormalWorld().y(),\r\n                    z: rayCallback.get_m_hitNormalWorld().z(),\r\n                },\r\n                {\r\n                    x: rayCallback.get_m_hitPointWorld().x(),\r\n                    y: rayCallback.get_m_hitPointWorld().y(),\r\n                    z: rayCallback.get_m_hitPointWorld().z(),\r\n                }\r\n            );\r\n            this._raycastResult.calculateHitDistance();\r\n        }\r\n        this.bjsAMMO.destroy(rayCallback);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\r\n        this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\r\n        return this._raycastResult;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}