{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { DomManagement } from \"../Misc/domManagement\";\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController\";\nimport { Xbox360Pad } from \"./xboxGamepad\";\nimport { Gamepad, GenericPad } from \"./gamepad\";\nimport { Engine } from '../Engines/engine';\nimport { DualShockPad } from './dualShockGamepad';\n/**\r\n * Manager for handling gamepads\r\n */\n\nvar GamepadManager =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the gamepad manager\r\n   * @param _scene BabylonJS scene\r\n   */\n  function GamepadManager(_scene) {\n    var _this = this;\n\n    this._scene = _scene;\n    this._babylonGamepads = [];\n    this._oneGamepadConnected = false;\n    /** @hidden */\n\n    this._isMonitoring = false;\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\n\n    this.onGamepadDisconnectedObservable = new Observable();\n\n    if (!DomManagement.IsWindowObjectExist()) {\n      this._gamepadEventSupported = false;\n    } else {\n      this._gamepadEventSupported = 'GamepadEvent' in window;\n      this._gamepadSupport = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads;\n    }\n\n    this.onGamepadConnectedObservable = new Observable(function (observer) {\n      // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\n      for (var i in _this._babylonGamepads) {\n        var gamepad = _this._babylonGamepads[i];\n\n        if (gamepad && gamepad._isConnected) {\n          _this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\n        }\n      }\n    });\n\n    this._onGamepadConnectedEvent = function (evt) {\n      var gamepad = evt.gamepad;\n\n      if (gamepad.index in _this._babylonGamepads) {\n        if (_this._babylonGamepads[gamepad.index].isConnected) {\n          return;\n        }\n      }\n\n      var newGamepad;\n\n      if (_this._babylonGamepads[gamepad.index]) {\n        newGamepad = _this._babylonGamepads[gamepad.index];\n        newGamepad.browserGamepad = gamepad;\n        newGamepad._isConnected = true;\n      } else {\n        newGamepad = _this._addNewGamepad(gamepad);\n      }\n\n      _this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n\n      _this._startMonitoringGamepads();\n    };\n\n    this._onGamepadDisconnectedEvent = function (evt) {\n      var gamepad = evt.gamepad; // Remove the gamepad from the list of gamepads to monitor.\n\n      for (var i in _this._babylonGamepads) {\n        if (_this._babylonGamepads[i].index === gamepad.index) {\n          var disconnectedGamepad = _this._babylonGamepads[i];\n          disconnectedGamepad._isConnected = false;\n\n          _this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\n\n          disconnectedGamepad.dispose && disconnectedGamepad.dispose();\n          break;\n        }\n      }\n    };\n\n    if (this._gamepadSupport) {\n      //first add already-connected gamepads\n      this._updateGamepadObjects();\n\n      if (this._babylonGamepads.length) {\n        this._startMonitoringGamepads();\n      } // Checking if the gamepad connected event is supported (like in Firefox)\n\n\n      if (this._gamepadEventSupported) {\n        var hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\n\n        if (hostWindow) {\n          hostWindow.addEventListener('gamepadconnected', this._onGamepadConnectedEvent, false);\n          hostWindow.addEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent, false);\n        }\n      } else {\n        this._startMonitoringGamepads();\n      }\n    }\n  }\n\n  Object.defineProperty(GamepadManager.prototype, \"gamepads\", {\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\n    get: function () {\n      return this._babylonGamepads;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Get the gamepad controllers based on type\r\n   * @param type The type of gamepad controller\r\n   * @returns Nullable gamepad\r\n   */\n\n  GamepadManager.prototype.getGamepadByType = function (type) {\n    if (type === void 0) {\n      type = Gamepad.XBOX;\n    }\n\n    for (var _i = 0, _a = this._babylonGamepads; _i < _a.length; _i++) {\n      var gamepad = _a[_i];\n\n      if (gamepad && gamepad.type === type) {\n        return gamepad;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Disposes the gamepad manager\r\n   */\n\n\n  GamepadManager.prototype.dispose = function () {\n    if (this._gamepadEventSupported) {\n      if (this._onGamepadConnectedEvent) {\n        window.removeEventListener('gamepadconnected', this._onGamepadConnectedEvent);\n      }\n\n      if (this._onGamepadDisconnectedEvent) {\n        window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent);\n      }\n\n      this._onGamepadConnectedEvent = null;\n      this._onGamepadDisconnectedEvent = null;\n    }\n\n    this._babylonGamepads.forEach(function (gamepad) {\n      gamepad.dispose();\n    });\n\n    this.onGamepadConnectedObservable.clear();\n    this.onGamepadDisconnectedObservable.clear();\n    this._oneGamepadConnected = false;\n\n    this._stopMonitoringGamepads();\n\n    this._babylonGamepads = [];\n  };\n\n  GamepadManager.prototype._addNewGamepad = function (gamepad) {\n    if (!this._oneGamepadConnected) {\n      this._oneGamepadConnected = true;\n    }\n\n    var newGamepad;\n    var dualShock = gamepad.id.search(\"054c\") !== -1;\n    var xboxOne = gamepad.id.search(\"Xbox One\") !== -1;\n\n    if (xboxOne || gamepad.id.search(\"Xbox 360\") !== -1 || gamepad.id.search(\"xinput\") !== -1) {\n      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\n    } else if (dualShock) {\n      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\n    } // if pose is supported, use the (WebVR) pose enabled controller\n    else if (gamepad.pose) {\n        newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\n      } else {\n        newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\n      }\n\n    this._babylonGamepads[newGamepad.index] = newGamepad;\n    return newGamepad;\n  };\n\n  GamepadManager.prototype._startMonitoringGamepads = function () {\n    if (!this._isMonitoring) {\n      this._isMonitoring = true; //back-comp\n\n      if (!this._scene) {\n        this._checkGamepadsStatus();\n      }\n    }\n  };\n\n  GamepadManager.prototype._stopMonitoringGamepads = function () {\n    this._isMonitoring = false;\n  };\n  /** @hidden */\n\n\n  GamepadManager.prototype._checkGamepadsStatus = function () {\n    var _this = this; // Hack to be compatible Chrome\n\n\n    this._updateGamepadObjects();\n\n    for (var i in this._babylonGamepads) {\n      var gamepad = this._babylonGamepads[i];\n\n      if (!gamepad || !gamepad.isConnected) {\n        continue;\n      }\n\n      gamepad.update();\n    }\n\n    if (this._isMonitoring && !this._scene) {\n      Engine.QueueNewFrame(function () {\n        _this._checkGamepadsStatus();\n      });\n    }\n  }; // This function is called only on Chrome, which does not properly support\n  // connection/disconnection events and forces you to recopy again the gamepad object\n\n\n  GamepadManager.prototype._updateGamepadObjects = function () {\n    var gamepads = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [];\n\n    for (var i = 0; i < gamepads.length; i++) {\n      var gamepad = gamepads[i];\n\n      if (gamepad) {\n        if (!this._babylonGamepads[gamepad.index]) {\n          var newGamepad = this._addNewGamepad(gamepad);\n\n          this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n        } else {\n          // Forced to copy again this object for Chrome for unknown reason\n          this._babylonGamepads[i].browserGamepad = gamepad;\n\n          if (!this._babylonGamepads[i].isConnected) {\n            this._babylonGamepads[i]._isConnected = true;\n            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\n          }\n        }\n      }\n    }\n  };\n\n  return GamepadManager;\n}();\n\nexport { GamepadManager };","map":{"version":3,"sources":["../../../sourceES6/core/Gamepads/gamepadManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport { DomManagement } from \"../Misc/domManagement\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from '../Engines/engine';\r\nimport { DualShockPad } from './dualShockGamepad';\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @hidden */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!DomManagement.IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = 'GamepadEvent' in window;\r\n            this._gamepadSupport = (navigator.getGamepads ||\r\n                navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads);\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (var i in this._babylonGamepads) {\r\n                let gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            let gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            let gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (var i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    let disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                let hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener('gamepadconnected', this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            }\r\n            else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (var gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener('gamepadconnected', this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        var newGamepad;\r\n        var dualShock: boolean = ((<string>gamepad.id).search(\"054c\") !== -1);\r\n        var xboxOne: boolean = ((<string>gamepad.id).search(\"Xbox One\") !== -1);\r\n        if (xboxOne || (<string>gamepad.id).search(\"Xbox 360\") !== -1 || (<string>gamepad.id).search(\"xinput\") !== -1) {\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        }\r\n        else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        // if pose is supported, use the (WebVR) pose enabled controller\r\n        else if (gamepad.pose) {\r\n            newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\r\n        }\r\n        else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            if (!this._scene) {\r\n                this._checkGamepadsStatus();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (var i in this._babylonGamepads) {\r\n            let gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            gamepad.update();\r\n        }\r\n\r\n        if (this._isMonitoring && !this._scene) {\r\n            Engine.QueueNewFrame(() => { this._checkGamepadsStatus(); });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\r\n        for (var i = 0; i < gamepads.length; i++) {\r\n            let gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    var newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                }\r\n                else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}