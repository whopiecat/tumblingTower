{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\nimport { CylinderBuilder } from \"../Meshes/Builders/cylinderBuilder\";\nimport { Ray } from \"../Culling/ray\";\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the Physics helper\r\n   * @param scene Babylon.js scene\r\n   */\n  function PhysicsHelper(scene) {\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you can use the methods.');\n      return;\n    }\n  }\n  /**\r\n   * Applies a radial explosion impulse\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics radial explosion event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionImpulse = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call this method.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Applies a radial explosion force\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics radial explosion event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.applyRadialExplosionForce = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    var affectedImpostorsWithData = Array();\n    impostors.forEach(function (impostor) {\n      var impostorHitData = event.getImpostorHitData(impostor, origin);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a gravitational field\r\n   * @param origin the origin of the explosion\r\n   * @param radiusOrEventOptions the radius or the options of radial explosion\r\n   * @param strength the explosion strength\r\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n   * @returns A physics gravitational field event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.gravitationalField = function (origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    var impostors = this._physicsEngine.getImpostors();\n\n    if (impostors.length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n\n    var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a physics updraft event\r\n   * @param origin the origin of the updraft\r\n   * @param radiusOrEventOptions the radius or the options of the updraft\r\n   * @param strength the strength of the updraft\r\n   * @param height the height of the updraft\r\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n   * @returns A physics updraft event, or null\r\n   */\n\n\n  PhysicsHelper.prototype.updraft = function (origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\n    }\n\n    var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n  /**\r\n   * Creates a physics vortex event\r\n   * @param origin the of the vortex\r\n   * @param radiusOrEventOptions the radius or the options of the vortex\r\n   * @param strength the strength of the vortex\r\n   * @param height   the height of the vortex\r\n   * @returns a Physics vortex event, or null\r\n   * A physics vortex event or null\r\n   */\n\n\n  PhysicsHelper.prototype.vortex = function (origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\n      return null;\n    }\n\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n\n    if (typeof radiusOrEventOptions === 'number') {\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n    }\n\n    var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  };\n\n  return PhysicsHelper;\n}();\n\nexport { PhysicsHelper };\n/**\r\n * Represents a physics radial explosion event\r\n */\n\nvar PhysicsRadialExplosionEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a radial explosioin event\r\n   * @param _scene BabylonJS scene\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsRadialExplosionEvent(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n  }\n  /**\r\n   * Returns the data related to the radial explosion event (sphere).\r\n   * @returns The radial explosion event data\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\r\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n   * @param impostor A physics imposter\r\n   * @param origin the origin of the explosion\r\n   * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.getImpostorHitData = function (impostor, origin) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var direction = impostorObjectCenter.subtract(origin);\n    var ray = new Ray(origin, direction, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n\n    if (distanceFromOrigin > this._options.radius) {\n      return null;\n    }\n\n    var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: contactPoint,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n  /**\r\n   * Triggers affecterd impostors callbacks\r\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.triggerAffectedImpostorsCallback = function (affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force Specifies if the sphere should be disposed by force\r\n   */\n\n\n  PhysicsRadialExplosionEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n  /*** Helpers ***/\n\n\n  PhysicsRadialExplosionEvent.prototype._prepareSphere = function () {\n    if (!this._sphere) {\n      this._sphere = SphereBuilder.CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  };\n\n  PhysicsRadialExplosionEvent.prototype._intersectsWithSphere = function (impostor, origin, radius) {\n    var impostorObject = impostor.object;\n\n    this._prepareSphere();\n\n    this._sphere.position = origin;\n    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\n\n    this._sphere._updateBoundingInfo();\n\n    this._sphere.computeWorldMatrix(true);\n\n    return this._sphere.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsRadialExplosionEvent;\n}();\n/**\r\n * Represents a gravitational field event\r\n */\n\n\nvar PhysicsGravitationalFieldEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics gravitational field event\r\n   * @param _physicsHelper A physics helper\r\n   * @param _scene BabylonJS scene\r\n   * @param _origin The origin position of the gravitational field event\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsGravitationalFieldEvent(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._options = __assign(__assign({}, new PhysicsRadialExplosionEventOptions()), this._options);\n    this._tickCallback = this._tick.bind(this);\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\r\n   * Returns the data related to the gravitational field event (sphere).\r\n   * @returns A gravitational field event\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  };\n  /**\r\n   * Enables the gravitational field.\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the gravitational field.\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force The force to dispose from the gravitational field event\r\n   */\n\n\n  PhysicsGravitationalFieldEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._sphere.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsGravitationalFieldEvent.prototype._tick = function () {\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n\n      if (radialExplosionEvent) {\n        this._sphere = radialExplosionEvent.getData().sphere.clone('radialExplosionEventSphereClone');\n      }\n    }\n  };\n\n  return PhysicsGravitationalFieldEvent;\n}();\n/**\r\n * Represents a physics updraft event\r\n */\n\n\nvar PhysicsUpdraftEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics updraft event\r\n   * @param _scene BabylonJS scene\r\n   * @param _origin The origin position of the updraft\r\n   * @param _options The options for the updraft event\r\n   */\n  function PhysicsUpdraftEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsUpdraftEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\r\n   * Returns the data related to the updraft event (cylinder).\r\n   * @returns A physics updraft event\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\r\n   * Enables the updraft.\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the updraft.\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the cylinder.\r\n   * @param force Specifies if the updraft should be disposed by force\r\n   */\n\n\n  PhysicsUpdraftEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (!this._cylinder) {\n      return;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype.getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      var direction = this._originDirection;\n    } else {\n      var direction = impostorObjectCenter.subtract(this._originTop);\n    }\n\n    var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\n    var multiplier = this._options.strength * -1;\n    var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  };\n\n  PhysicsUpdraftEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this.getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsUpdraftEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CylinderBuilder.CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsUpdraftEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsUpdraftEvent;\n}();\n/**\r\n * Represents a physics vortex event\r\n */\n\n\nvar PhysicsVortexEvent =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes the physics vortex event\r\n   * @param _scene The BabylonJS scene\r\n   * @param _origin The origin position of the vortex\r\n   * @param _options The options for the vortex event\r\n   */\n  function PhysicsVortexEvent(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = __assign(__assign({}, new PhysicsVortexEventOptions()), this._options);\n\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n\n    this._tickCallback = this._tick.bind(this);\n\n    this._prepareCylinder();\n  }\n  /**\r\n   * Returns the data related to the vortex event (cylinder).\r\n   * @returns The physics vortex event data\r\n   */\n\n\n  PhysicsVortexEvent.prototype.getData = function () {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  };\n  /**\r\n   * Enables the vortex.\r\n   */\n\n\n  PhysicsVortexEvent.prototype.enable = function () {\n    this._tickCallback.call(this);\n\n    this._scene.registerBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disables the cortex.\r\n   */\n\n\n  PhysicsVortexEvent.prototype.disable = function () {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  };\n  /**\r\n   * Disposes the sphere.\r\n   * @param force\r\n   */\n\n\n  PhysicsVortexEvent.prototype.dispose = function (force) {\n    var _this = this;\n\n    if (force === void 0) {\n      force = true;\n    }\n\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(function () {\n        if (!_this._dataFetched) {\n          _this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  };\n\n  PhysicsVortexEvent.prototype.getImpostorHitData = function (impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n\n    if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\n      return null;\n    }\n\n    var impostorObjectCenter = impostor.getObjectCenter();\n    var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n\n    var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\n    var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\n    var hit = ray.intersectsMesh(impostor.object);\n    var contactPoint = hit.pickedPoint;\n\n    if (!contactPoint) {\n      return null;\n    }\n\n    var absoluteDistanceFromOrigin = hit.distance / this._options.radius;\n    var directionToOrigin = contactPoint.normalize();\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin = directionToOrigin.negate();\n    }\n\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      var forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      var forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      var forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\n      var forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      var forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      var forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n\n    var force = new Vector3(forceX, forceY, forceZ);\n    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: absoluteDistanceFromOrigin\n    };\n  };\n\n  PhysicsVortexEvent.prototype._tick = function () {\n    var _this = this;\n\n    this._physicsEngine.getImpostors().forEach(function (impostor) {\n      var impostorHitData = _this.getImpostorHitData(impostor);\n\n      if (!impostorHitData) {\n        return;\n      }\n\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  };\n  /*** Helpers ***/\n\n\n  PhysicsVortexEvent.prototype._prepareCylinder = function () {\n    if (!this._cylinder) {\n      this._cylinder = CylinderBuilder.CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  };\n\n  PhysicsVortexEvent.prototype._intersectsWithCylinder = function (impostor) {\n    var impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  };\n\n  return PhysicsVortexEvent;\n}();\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\n\nvar PhysicsRadialExplosionEventOptions =\n/** @class */\nfunction () {\n  function PhysicsRadialExplosionEventOptions() {\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the explosion.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The strenght of the force in correspondence to the distance of the affected object\r\n     */\n\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\n\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n\n  return PhysicsRadialExplosionEventOptions;\n}();\n\nexport { PhysicsRadialExplosionEventOptions };\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsUpdraftEventOptions =\n/** @class */\nfunction () {\n  function PhysicsUpdraftEventOptions() {\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the updraft.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\n\n    this.height = 10;\n    /**\r\n     * The mode for the the updraft.\r\n     */\n\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n\n  return PhysicsUpdraftEventOptions;\n}();\n\nexport { PhysicsUpdraftEventOptions };\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\nvar PhysicsVortexEventOptions =\n/** @class */\nfunction () {\n  function PhysicsVortexEventOptions() {\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\n    this.radius = 5;\n    /**\r\n     * The strenth of the vortex.\r\n     */\n\n    this.strength = 10;\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\n\n    this.height = 10;\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\n\n    this.centripetalForceThreshold = 0.7;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.\r\n     */\n\n    this.centripetalForceMultiplier = 5;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.\r\n     */\n\n    this.centrifugalForceMultiplier = 0.5;\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\n\n    this.updraftForceMultiplier = 0.02;\n  }\n\n  return PhysicsVortexEventOptions;\n}();\n\nexport { PhysicsVortexEventOptions };\n/**\r\n* The strenght of the force in correspondence to the distance of the affected object\r\n* @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n*/\n\nexport var PhysicsRadialImpulseFalloff;\n\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\n\n\nexport var PhysicsUpdraftMode;\n\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));","map":{"version":3,"sources":["../../../sourceES6/core/Physics/physicsHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SphereBuilder } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CylinderBuilder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Scene } from \"../scene\";\r\nimport { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport { PhysicsEngine } from \"./physicsEngine\";\r\nimport { PhysicsImpostor } from \"./physicsImpostor\";\r\n\r\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsHelper {\r\n\r\n    private _scene: Scene;\r\n    private _physicsEngine: Nullable<IPhysicsEngine>;\r\n\r\n    /**\r\n     * Initializes the Physics helper\r\n     * @param scene Babylon.js scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._physicsEngine = this._scene.getPhysicsEngine();\r\n\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you can use the methods.');\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion impulse\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionImpulse(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you call this method.');\r\n            return null;\r\n        }\r\n\r\n        var impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === 'number') {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number><any>radiusOrEventOptions;\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        var affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            var impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion force\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionForce(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\r\n            return null;\r\n        }\r\n\r\n        var impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === 'number') {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number><any>radiusOrEventOptions;\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        var event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        var affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            var impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a gravitational field\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics gravitational field event, or null\r\n     */\r\n    public gravitationalField(origin: Vector3, radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions, strength?: number, falloff?: PhysicsRadialImpulseFalloff): Nullable<PhysicsGravitationalFieldEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\r\n            return null;\r\n        }\r\n\r\n        var impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === 'number') {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number><any>radiusOrEventOptions;\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        var event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics updraft event\r\n     * @param origin the origin of the updraft\r\n     * @param radiusOrEventOptions the radius or the options of the updraft\r\n     * @param strength the strength of the updraft\r\n     * @param height the height of the updraft\r\n     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n     * @returns A physics updraft event, or null\r\n     */\r\n    public updraft(origin: Vector3, radiusOrEventOptions: number | PhysicsUpdraftEventOptions, strength?: number, height?: number, updraftMode?: PhysicsUpdraftMode): Nullable<PhysicsUpdraftEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === 'number') {\r\n            radiusOrEventOptions = new PhysicsUpdraftEventOptions();\r\n            radiusOrEventOptions.radius = <number><any>radiusOrEventOptions;\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n            radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\r\n        }\r\n\r\n        var event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics vortex event\r\n     * @param origin the of the vortex\r\n     * @param radiusOrEventOptions the radius or the options of the vortex\r\n     * @param strength the strength of the vortex\r\n     * @param height   the height of the vortex\r\n     * @returns a Physics vortex event, or null\r\n     * A physics vortex event or null\r\n     */\r\n    public vortex(origin: Vector3, radiusOrEventOptions: number | PhysicsVortexEventOptions, strength?: number, height?: number): Nullable<PhysicsVortexEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn('Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.');\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === 'number') {\r\n            radiusOrEventOptions = new PhysicsVortexEventOptions();\r\n            radiusOrEventOptions.radius = <number><any>radiusOrEventOptions;\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n        }\r\n\r\n        var event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics radial explosion event\r\n */\r\nclass PhysicsRadialExplosionEvent {\r\n\r\n    private _sphere: Mesh; // create a sphere, so we can get the intersecting meshes inside\r\n    private _dataFetched: boolean = false; // check if the data has been fetched. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes a radial explosioin event\r\n     * @param _scene BabylonJS scene\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...(new PhysicsRadialExplosionEventOptions()), ...this._options };\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the radial explosion event (sphere).\r\n     * @returns The radial explosion event data\r\n     */\r\n    public getData(): PhysicsRadialExplosionEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n     * @param impostor A physics imposter\r\n     * @param origin the origin of the explosion\r\n     * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\r\n     */\r\n    public getImpostorHitData(impostor: PhysicsImpostor, origin: Vector3): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\r\n            return null;\r\n        }\r\n\r\n        var impostorObjectCenter = impostor.getObjectCenter();\r\n        var direction = impostorObjectCenter.subtract(origin);\r\n\r\n        var ray = new Ray(origin, direction, this._options.radius);\r\n        var hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n\r\n        var contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n\r\n        var distanceFromOrigin = Vector3.Distance(origin, contactPoint);\r\n\r\n        if (distanceFromOrigin > this._options.radius) {\r\n            return null;\r\n        }\r\n\r\n        var multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant\r\n            ? this._options.strength\r\n            : this._options.strength * (1 - (distanceFromOrigin / this._options.radius));\r\n\r\n        var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: contactPoint, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    /**\r\n     * Triggers affecterd impostors callbacks\r\n     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n     */\r\n    public triggerAffectedImpostorsCallback(affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) {\r\n        if (this._options.affectedImpostorsCallback) {\r\n            this._options.affectedImpostorsCallback(affectedImpostorsWithData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force Specifies if the sphere should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareSphere(): void {\r\n        if (!this._sphere) {\r\n            this._sphere = SphereBuilder.CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\r\n            this._sphere.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithSphere(impostor: PhysicsImpostor, origin: Vector3, radius: number): boolean {\r\n        var impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._prepareSphere();\r\n\r\n        this._sphere.position = origin;\r\n        this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\r\n        this._sphere._updateBoundingInfo();\r\n        this._sphere.computeWorldMatrix(true);\r\n\r\n        return this._sphere.intersectsMesh(impostorObject, true);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Represents a gravitational field event\r\n */\r\nclass PhysicsGravitationalFieldEvent {\r\n\r\n    private _tickCallback: any;\r\n    private _sphere: Mesh;\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics gravitational field event\r\n     * @param _physicsHelper A physics helper\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the gravitational field event\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _physicsHelper: PhysicsHelper, private _scene: Scene, private _origin: Vector3, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...(new PhysicsRadialExplosionEventOptions()), ...this._options };\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._options.strength = this._options.strength * -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the gravitational field event (sphere).\r\n     * @returns A gravitational field event\r\n     */\r\n    public getData(): PhysicsGravitationalFieldEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the gravitational field.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the gravitational field.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force The force to dispose from the gravitational field event\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _tick() {\r\n        // Since the params won't change, we fetch the event only once\r\n        if (this._sphere) {\r\n            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n        } else {\r\n            var radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n            if (radialExplosionEvent) {\r\n                this._sphere = <Mesh>radialExplosionEvent.getData().sphere.clone('radialExplosionEventSphereClone');\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Represents a physics updraft event\r\n */\r\nclass PhysicsUpdraftEvent {\r\n\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _originDirection: Vector3 = Vector3.Zero(); // used if the updraftMode is perpendicular\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics updraft event\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the updraft\r\n     * @param _options The options for the updraft event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsUpdraftEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...(new PhysicsUpdraftEventOptions()), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            this._originDirection = this._origin.subtract(this._originTop).normalize();\r\n        }\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the updraft event (cylinder).\r\n     * @returns A physics updraft event\r\n     */\r\n    public getData(): PhysicsUpdraftEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the updraft.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the updraft.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the cylinder.\r\n     * @param force Specifies if the updraft should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._cylinder) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        var impostorObjectCenter = impostor.getObjectCenter();\r\n\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            var direction = this._originDirection;\r\n        } else {\r\n            var direction = impostorObjectCenter.subtract(this._originTop);\r\n        }\r\n\r\n        var distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\r\n\r\n        var multiplier = this._options.strength * -1;\r\n\r\n        var force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            var impostorHitData = this.getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CylinderBuilder.CreateCylinder(\"updraftEventCylinder\", {\r\n                height: this._options.height,\r\n                diameter: this._options.radius * 2,\r\n            }, this._scene);\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        var impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Represents a physics vortex event\r\n */\r\nclass PhysicsVortexEvent {\r\n\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics vortex event\r\n     * @param _scene The BabylonJS scene\r\n     * @param _origin The origin position of the vortex\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsVortexEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...(new PhysicsVortexEventOptions()), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the vortex event (cylinder).\r\n     * @returns The physics vortex event data\r\n     */\r\n    public getData(): PhysicsVortexEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the vortex.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the cortex.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== 'Mesh' && impostor.object.getClassName() !== 'InstancedMesh') {\r\n            return null;\r\n        }\r\n\r\n        var impostorObjectCenter = impostor.getObjectCenter();\r\n        var originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\r\n        var originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\r\n\r\n        var ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\r\n        var hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n        var contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n        var absoluteDistanceFromOrigin = hit.distance / this._options.radius;\r\n\r\n        var directionToOrigin = contactPoint.normalize();\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            directionToOrigin = directionToOrigin.negate();\r\n        }\r\n\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            var forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\r\n            var forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\r\n            var forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\r\n        } else {\r\n            var perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\r\n\r\n            var forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\r\n            var forceY = this._originTop.y * this._options.updraftForceMultiplier;\r\n            var forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\r\n        }\r\n\r\n        var force = new Vector3(forceX, forceY, forceZ);\r\n        force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            var impostorHitData = this.getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CylinderBuilder.CreateCylinder(\"vortexEventCylinder\", {\r\n                height: this._options.height,\r\n                diameter: this._options.radius * 2,\r\n            }, this._scene);\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        var impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsRadialExplosionEventOptions {\r\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strenth of the explosion.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The strenght of the force in correspondence to the distance of the affected object\r\n     */\r\n    falloff: PhysicsRadialImpulseFalloff = PhysicsRadialImpulseFalloff.Constant;\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    sphere: { segments: number, diameter: number } = { segments: 32, diameter: 1 };\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    affectedImpostorsCallback: (affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) => void;\r\n}\r\n\r\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsUpdraftEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strenth of the updraft.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * The mode for the the updraft.\r\n     */\r\n    updraftMode: PhysicsUpdraftMode = PhysicsUpdraftMode.Center;\r\n}\r\n\r\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsVortexEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strenth of the vortex.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\r\n    centripetalForceThreshold: number = 0.7;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the treshold.\r\n     */\r\n    centripetalForceMultiplier: number = 5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the treshold.\r\n     */\r\n    centrifugalForceMultiplier: number = 0.5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\r\n    updraftForceMultiplier: number = 0.02;\r\n}\r\n\r\n/**\r\n* The strenght of the force in correspondence to the distance of the affected object\r\n* @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n*/\r\nexport enum PhysicsRadialImpulseFalloff {\r\n    /** Defines that impulse is constant in strength across it's whole radius */\r\n    Constant,\r\n    /** Defines that impulse gets weaker if it's further from the origin */\r\n    Linear\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsUpdraftMode {\r\n    /** Defines that the upstream forces will pull towards the top center of the cylinder */\r\n    Center,\r\n    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\r\n    Perpendicular\r\n}\r\n\r\n/**\r\n * Interface for a physics hit data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsHitData {\r\n    /**\r\n     * The force applied at the contact point\r\n     */\r\n    force: Vector3;\r\n    /**\r\n     * The contact point\r\n     */\r\n    contactPoint: Vector3;\r\n    /**\r\n     * The distance from the origin to the contact point\r\n     */\r\n    distanceFromOrigin: number;\r\n}\r\n\r\n/**\r\n * Interface for radial explosion event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsRadialExplosionEventData {\r\n    /**\r\n     * A sphere used for the radial explosion event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for gravitational field event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsGravitationalFieldEventData {\r\n    /**\r\n     * A sphere mesh used for the gravitational field event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for updraft event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsUpdraftEventData {\r\n    /**\r\n     * A cylinder used for the updraft event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for vortex event data\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsVortexEventData {\r\n    /**\r\n     * A cylinder used for the vortex event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for an affected physics impostor\r\n * @see https://doc.babylonjs.com/how_to/using_the_physics_engine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsAffectedImpostorWithData {\r\n    /**\r\n     * The impostor affected by the effect\r\n     */\r\n    impostor: PhysicsImpostor;\r\n\r\n    /**\r\n     * The data about the hit/horce from the explosion\r\n     */\r\n    hitData: PhysicsHitData;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}