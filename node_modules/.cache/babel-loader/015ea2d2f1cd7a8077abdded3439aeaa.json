{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Sprite } from \"./sprite\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Logger } from \"../Misc/logger\";\nimport { Engine } from '../Engines/engine';\nimport { WebRequest } from '../Misc/webRequest';\nimport { SpriteRenderer } from './spriteRenderer';\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/babylon101/sprites\r\n */\n\nvar SpriteManager =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new sprite manager\r\n   * @param name defines the manager's name\r\n   * @param imgUrl defines the sprite sheet url\r\n   * @param capacity defines the maximum allowed number of sprites\r\n   * @param cellSize defines the size of a sprite cell\r\n   * @param scene defines the hosting scene\r\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n   * @param samplingMode defines the smapling mode to use with spritesheet\r\n   * @param fromPacked set to false; do not alter\r\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n   */\n  function SpriteManager(\n  /** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode, fromPacked, spriteJSON) {\n    var _this = this;\n\n    if (epsilon === void 0) {\n      epsilon = 0.01;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (fromPacked === void 0) {\n      fromPacked = false;\n    }\n\n    if (spriteJSON === void 0) {\n      spriteJSON = null;\n    }\n\n    this.name = name;\n    /** Gets the list of sprites */\n\n    this.sprites = new Array();\n    /** Gets or sets the rendering group id (0 by default) */\n\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n\n    this.layerMask = 0x0FFFFFFF;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n\n    this.isPickable = false;\n    /**\r\n    * An event triggered when the manager is disposed.\r\n    */\n\n    this.onDisposeObservable = new Observable();\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n    */\n\n    this.disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n\n    this._packedAndReady = false;\n\n    this._customUpdate = function (sprite, baseSize) {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n\n      var num = sprite.cellIndex;\n\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = _this._spriteMap[sprite.cellIndex];\n      }\n\n      sprite._xOffset = _this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = _this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = _this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = _this._cellData[sprite.cellRef].frame.h;\n    };\n\n    if (!scene) {\n      scene = Engine.LastCreatedScene;\n    }\n\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n\n    var engine = this._scene.getEngine();\n\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n\n    this._scene.spriteManagers.push(this);\n\n    this.uniqueId = this.scene.getUniqueId();\n\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n\n  Object.defineProperty(SpriteManager.prototype, \"onDispose\", {\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\n    set: function (callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"children\", {\n    /**\r\n     * Gets the array of sprites\r\n     */\n    get: function () {\n      return this.sprites;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"scene\", {\n    /**\r\n     * Gets the hosting scene\r\n     */\n    get: function () {\n      return this._scene;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"capacity\", {\n    /**\r\n     * Gets the capacity of the manager\r\n     */\n    get: function () {\n      return this._spriteRenderer.capacity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"texture\", {\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\n    get: function () {\n      return this._spriteRenderer.texture;\n    },\n    set: function (value) {\n      value.wrapU = Texture.CLAMP_ADDRESSMODE;\n      value.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._spriteRenderer.texture = value;\n      this._textureContent = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellWidth\", {\n    /** Defines the default width of a cell in the spritesheet */\n    get: function () {\n      return this._spriteRenderer.cellWidth;\n    },\n    set: function (value) {\n      this._spriteRenderer.cellWidth = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"cellHeight\", {\n    /** Defines the default height of a cell in the spritesheet */\n    get: function () {\n      return this._spriteRenderer.cellHeight;\n    },\n    set: function (value) {\n      this._spriteRenderer.cellHeight = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"fogEnabled\", {\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n    get: function () {\n      return this._spriteRenderer.fogEnabled;\n    },\n    set: function (value) {\n      this._spriteRenderer.fogEnabled = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpriteManager.prototype, \"blendMode\", {\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\n    get: function () {\n      return this._spriteRenderer.blendMode;\n    },\n    set: function (blendMode) {\n      this._spriteRenderer.blendMode = blendMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"SpriteManager\"\r\n   * @returns \"SpriteManager\"\r\n   */\n\n  SpriteManager.prototype.getClassName = function () {\n    return \"SpriteManager\";\n  };\n\n  SpriteManager.prototype._makePacked = function (imgUrl, spriteJSON) {\n    var _this = this;\n\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its stucture.  If its an array parse it if its a JSON sring etc...\n        var celldata = void 0;\n\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n\n        if (celldata.frames.length) {\n          var frametemp = {};\n\n          for (var i = 0; i < celldata.frames.length; i++) {\n            var _f = celldata.frames[i];\n\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n\n            var name_1 = _f[Object.keys(_f)[0]];\n\n            frametemp[name_1] = _f;\n          }\n\n          celldata.frames = frametemp;\n        }\n\n        var spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      var re = /\\./g;\n      var li = void 0;\n\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n\n      var jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n      var xmlhttp_1 = new XMLHttpRequest();\n      xmlhttp_1.open(\"GET\", jsonUrl, true);\n\n      xmlhttp_1.onerror = function () {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        _this._fromPacked = false;\n        _this._packedAndReady = false;\n      };\n\n      xmlhttp_1.onload = function () {\n        try {\n          var celldata = JSON.parse(xmlhttp_1.response);\n          var spritemap = Reflect.ownKeys(celldata.frames);\n          _this._spriteMap = spritemap;\n          _this._packedAndReady = true;\n          _this._cellData = celldata.frames;\n        } catch (e) {\n          _this._fromPacked = false;\n          _this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n\n      xmlhttp_1.send();\n    }\n  };\n\n  SpriteManager.prototype._checkTextureAlpha = function (sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n\n    var textureSize = this.texture.getSize();\n\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n\n    var contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    var contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n    var contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5; // Rotate\n\n    var angle = sprite.angle;\n    var rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n    var rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n    var u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;\n    var v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;\n    var alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  };\n  /**\r\n   * Intersects the sprites with a ray\r\n   * @param ray defines the ray to intersect with\r\n   * @param camera defines the current active camera\r\n   * @param predicate defines a predicate used to select candidate sprites\r\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n   * @returns null if no hit or a PickingInfo\r\n   */\n\n\n  SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance = Number.MAX_VALUE;\n    var currentSprite = null;\n    var pickedPoint = TmpVectors.Vector3[0];\n    var cameraSpacePosition = TmpVectors.Vector3[1];\n    var cameraView = camera.getViewMatrix();\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (ray.intersectsBoxMinMax(min, max)) {\n        var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);\n\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, ray, currentDistance, min, max)) {\n            continue;\n          }\n\n          distance = currentDistance;\n          currentSprite = sprite;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (currentSprite) {\n      var result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance; // Get picked point\n\n      var direction = TmpVectors.Vector3[2];\n      direction.copyFrom(ray.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      ray.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n\n    return null;\n  };\n  /**\r\n   * Intersects the sprites with a ray\r\n   * @param ray defines the ray to intersect with\r\n   * @param camera defines the current active camera\r\n   * @param predicate defines a predicate used to select candidate sprites\r\n   * @returns null if no hit or a PickingInfo array\r\n   */\n\n\n  SpriteManager.prototype.multiIntersects = function (ray, camera, predicate) {\n    var count = Math.min(this.capacity, this.sprites.length);\n    var min = Vector3.Zero();\n    var max = Vector3.Zero();\n    var distance;\n    var results = [];\n    var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    var cameraView = camera.getViewMatrix();\n\n    for (var index = 0; index < count; index++) {\n      var sprite = this.sprites[index];\n\n      if (!sprite) {\n        continue;\n      }\n\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n\n        var result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance; // Get picked point\n\n        var direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n\n    return results;\n  };\n  /**\r\n   * Render all child sprites\r\n   */\n\n\n  SpriteManager.prototype.render = function () {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n\n    var engine = this._scene.getEngine();\n\n    var deltaTime = engine.getDeltaTime();\n\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  };\n  /**\r\n   * Release associated resources\r\n   */\n\n\n  SpriteManager.prototype.dispose = function () {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n\n      this._spriteRenderer = null;\n    }\n\n    this._textureContent = null; // Remove from scene\n\n    var index = this._scene.spriteManagers.indexOf(this);\n\n    this._scene.spriteManagers.splice(index, 1); // Callback\n\n\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  };\n  /**\r\n   * Serializes the sprite manager to a JSON object\r\n   * @param serializeTexture defines if the texture must be serialized as well\r\n   * @returns the JSON object\r\n   */\n\n\n  SpriteManager.prototype.serialize = function (serializeTexture) {\n    if (serializeTexture === void 0) {\n      serializeTexture = false;\n    }\n\n    var serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n\n    serializationObject.sprites = [];\n\n    for (var _i = 0, _a = this.sprites; _i < _a.length; _i++) {\n      var sprite = _a[_i];\n      serializationObject.sprites.push(sprite.serialize());\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Parses a JSON object to create a new sprite manager.\r\n   * @param parsedManager The JSON object to parse\r\n   * @param scene The scene to create the sprite managerin\r\n   * @param rootUrl The root url to use to load external dependencies like texture\r\n   * @returns the new sprite manager\r\n   */\n\n\n  SpriteManager.Parse = function (parsedManager, scene, rootUrl) {\n    var manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n\n    for (var _i = 0, _a = parsedManager.sprites; _i < _a.length; _i++) {\n      var parsedSprite = _a[_i];\n      Sprite.Parse(parsedSprite, manager);\n    }\n\n    return manager;\n  };\n  /**\r\n   * Creates a sprite manager from a snippet saved in a remote file\r\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new sprite manager\r\n   */\n\n\n  SpriteManager.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n            var output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a sprite manager from a snippet saved by the sprite editor\r\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new sprite manager\r\n   */\n\n\n  SpriteManager.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.spriteManager);\n            var output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /** Define the Url to load snippets */\n\n\n  SpriteManager.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return SpriteManager;\n}();\n\nexport { SpriteManager };","map":{"version":3,"sources":["../../../sourceES6/core/Sprites/spriteManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Engine } from '../Engines/engine';\r\nimport { WebRequest } from '../Misc/webRequest';\r\nimport { SpriteRenderer } from './spriteRenderer';\r\nimport { ThinSprite } from './thinSprite';\r\nimport { ISize } from '../Maths/math.size';\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * Defines the minimum interface to fullfil in order to be a sprite manager.\r\n */\r\nexport interface ISpriteManager extends IDisposable {\r\n\r\n    /**\r\n     * Gets manager's name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    isPickable: boolean;\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Defines the list of sprites managed by the manager.\r\n     */\r\n    sprites: Array<Sprite>;\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    texture: Texture;\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    cellWidth: number;\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    cellHeight: number;\r\n\r\n    /**\r\n     * Tests the intersection of a sprite with a specific ray.\r\n     * @param ray The ray we are sending to test the collision\r\n     * @param camera The camera space we are sending rays in\r\n     * @param predicate A predicate allowing excluding sprites from the list of object to test\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info or null.\r\n     */\r\n    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;\r\n\r\n    /**\r\n     * Renders the list of sprites on screen.\r\n     */\r\n    render(): void;\r\n}\r\n\r\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/babylon101/sprites\r\n */\r\nexport class SpriteManager implements ISpriteManager {\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the manager was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Gets the list of sprites */\r\n    public sprites = new Array<Sprite>();\r\n    /** Gets or sets the rendering group id (0 by default) */\r\n    public renderingGroupId = 0;\r\n    /** Gets or sets camera layer mask */\r\n    public layerMask: number = 0x0FFFFFFF;\r\n    /** Gets or sets a boolean indicating if the sprites are pickable */\r\n    public isPickable = false;\r\n\r\n    /**\r\n    * An event triggered when the manager is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<SpriteManager>();\r\n\r\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the array of sprites\r\n     */\r\n    public get children() {\r\n        return this.sprites;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._spriteRenderer.capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    public get texture(): Texture {\r\n        return this._spriteRenderer.texture as Texture;\r\n    }\r\n    public set texture(value: Texture) {\r\n        value.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        value.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._spriteRenderer.texture = value;\r\n        this._textureContent = null;\r\n    }\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    public get cellWidth(): number {\r\n        return this._spriteRenderer.cellWidth;\r\n    }\r\n    public set cellWidth(value: number) {\r\n        this._spriteRenderer.cellWidth = value;\r\n    }\r\n\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    public get cellHeight(): number {\r\n        return this._spriteRenderer.cellHeight;\r\n    }\r\n    public set cellHeight(value: number) {\r\n        this._spriteRenderer.cellHeight = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\r\n    public get fogEnabled(): boolean {\r\n        return this._spriteRenderer.fogEnabled;\r\n    }\r\n    public set fogEnabled(value: boolean) {\r\n        this._spriteRenderer.fogEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static undefined properties provided in this class.\r\n     * Default value is 2\r\n     */\r\n    public get blendMode() {\r\n        return this._spriteRenderer.blendMode;\r\n    }\r\n    public set blendMode(blendMode: number) {\r\n        this._spriteRenderer.blendMode = blendMode;\r\n    }\r\n\r\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n    */\r\n    public disableDepthWrite: boolean = false;\r\n\r\n    private _spriteRenderer: SpriteRenderer;\r\n    /** Associative array from JSON sprite data file */\r\n    private _cellData: any;\r\n    /** Array of sprite names from JSON sprite data file */\r\n    private _spriteMap: Array<string>;\r\n    /** True when packed cell data from JSON file is ready*/\r\n    private _packedAndReady: boolean = false;\r\n    private _textureContent: Nullable<Uint8Array>;\r\n    private _onDisposeObserver: Nullable<Observer<SpriteManager>>;\r\n    private _fromPacked: boolean;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new sprite manager\r\n     * @param name defines the manager's name\r\n     * @param imgUrl defines the sprite sheet url\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param cellSize defines the size of a sprite cell\r\n     * @param scene defines the hosting scene\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param samplingMode defines the smapling mode to use with spritesheet\r\n     * @param fromPacked set to false; do not alter\r\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n     */\r\n    constructor(\r\n        /** defines the manager's name */\r\n        public name: string,\r\n        imgUrl: string, capacity: number, cellSize: any, scene: Scene, epsilon: number = 0.01, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE, fromPacked: boolean = false, spriteJSON: any | null = null) {\r\n\r\n        if (!scene) {\r\n            scene = Engine.LastCreatedScene!;\r\n        }\r\n\r\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\r\n            scene._addComponent(new SpriteSceneComponent(scene));\r\n        }\r\n        this._fromPacked = fromPacked;\r\n\r\n        this._scene = scene;\r\n        const engine = this._scene.getEngine();\r\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\r\n\r\n        if (cellSize.width && cellSize.height) {\r\n            this.cellWidth = cellSize.width;\r\n            this.cellHeight = cellSize.height;\r\n        } else if (cellSize !== undefined) {\r\n            this.cellWidth = cellSize;\r\n            this.cellHeight = cellSize;\r\n        } else {\r\n            this._spriteRenderer = <any>null;\r\n            return;\r\n        }\r\n\r\n        this._scene.spriteManagers.push(this);\r\n        this.uniqueId = this.scene.getUniqueId();\r\n\r\n        if (imgUrl) {\r\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\r\n        }\r\n\r\n        if (this._fromPacked) {\r\n            this._makePacked(imgUrl, spriteJSON);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpriteManager\"\r\n     * @returns \"SpriteManager\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"SpriteManager\";\r\n    }\r\n\r\n    private _makePacked(imgUrl: string, spriteJSON: any) {\r\n        if (spriteJSON !== null) {\r\n            try {\r\n                //Get the JSON and Check its stucture.  If its an array parse it if its a JSON sring etc...\r\n                let celldata: any;\r\n                if (typeof spriteJSON === \"string\") {\r\n                    celldata = JSON.parse(spriteJSON);\r\n                }else {\r\n                    celldata = spriteJSON;\r\n                }\r\n\r\n                if (celldata.frames.length) {\r\n                    let frametemp: any = {};\r\n                    for (let i = 0; i < celldata.frames.length; i++) {\r\n                        let _f = celldata.frames[i];\r\n                        if (typeof (Object.keys(_f))[0] !== \"string\") {\r\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\r\n                        }\r\n\r\n                        let name: string = _f[(Object.keys(_f))[0]];\r\n                        frametemp[name] = _f;\r\n                    }\r\n                    celldata.frames = frametemp;\r\n                }\r\n\r\n                let spritemap = (<string[]>(<any>Reflect).ownKeys(celldata.frames));\r\n\r\n                this._spriteMap = spritemap;\r\n                this._packedAndReady = true;\r\n                this._cellData = celldata.frames;\r\n            }\r\n            catch (e) {\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\r\n            }\r\n        }\r\n        else {\r\n            let re = /\\./g;\r\n            let li: number;\r\n            do {\r\n                li = re.lastIndex;\r\n                re.test(imgUrl);\r\n            } while (re.lastIndex > 0);\r\n            let jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\r\n            let xmlhttp = new XMLHttpRequest();\r\n            xmlhttp.open(\"GET\", jsonUrl, true);\r\n            xmlhttp.onerror = () => {\r\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n            };\r\n            xmlhttp.onload = () => {\r\n                try {\r\n                    let celldata  = JSON.parse(xmlhttp.response);\r\n                    let spritemap = (<string[]>(<any>Reflect).ownKeys(celldata.frames));\r\n                    this._spriteMap = spritemap;\r\n                    this._packedAndReady = true;\r\n                    this._cellData = celldata.frames;\r\n                }\r\n                catch (e) {\r\n                    this._fromPacked = false;\r\n                    this._packedAndReady = false;\r\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\r\n                }\r\n            };\r\n            xmlhttp.send();\r\n        }\r\n    }\r\n\r\n    private _checkTextureAlpha(sprite: Sprite, ray: Ray, distance: number, min: Vector3, max: Vector3) {\r\n        if (!sprite.useAlphaForPicking || !this.texture) {\r\n            return true;\r\n        }\r\n\r\n        let textureSize = this.texture.getSize();\r\n        if (!this._textureContent) {\r\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\r\n            this.texture.readPixels(0, 0, this._textureContent);\r\n        }\r\n\r\n        let contactPoint = TmpVectors.Vector3[0];\r\n\r\n        contactPoint.copyFrom(ray.direction);\r\n\r\n        contactPoint.normalize();\r\n        contactPoint.scaleInPlace(distance);\r\n        contactPoint.addInPlace(ray.origin);\r\n\r\n        let contactPointU = ((contactPoint.x - min.x) / (max.x - min.x)) - 0.5;\r\n        let contactPointV = (1.0 - (contactPoint.y - min.y) / (max.y - min.y)) - 0.5;\r\n\r\n        // Rotate\r\n        let angle = sprite.angle;\r\n        let rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\r\n        let rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\r\n\r\n        let u = (sprite._xOffset * textureSize.width + rotatedU * sprite._xSize) | 0;\r\n        let v = (sprite._yOffset * textureSize.height +  rotatedV * sprite._ySize) | 0;\r\n\r\n        let alpha = this._textureContent![(u + v * textureSize.width) * 4 + 3];\r\n\r\n        return (alpha > 0.5);\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n     * @returns null if no hit or a PickingInfo\r\n     */\r\n    public intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo> {\r\n        var count = Math.min(this.capacity, this.sprites.length);\r\n        var min = Vector3.Zero();\r\n        var max = Vector3.Zero();\r\n        var distance = Number.MAX_VALUE;\r\n        var currentSprite: Nullable<Sprite> = null;\r\n        var pickedPoint = TmpVectors.Vector3[0];\r\n        var cameraSpacePosition = TmpVectors.Vector3[1];\r\n        var cameraView = camera.getViewMatrix();\r\n\r\n        for (var index = 0; index < count; index++) {\r\n            var sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                var currentDistance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (distance > currentDistance) {\r\n\r\n                    if (!this._checkTextureAlpha(sprite, ray, currentDistance, min, max)) {\r\n                        continue;\r\n                    }\r\n\r\n                    distance = currentDistance;\r\n                    currentSprite = sprite;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentSprite) {\r\n            var result = new PickingInfo();\r\n\r\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n            result.hit = true;\r\n            result.pickedSprite = currentSprite;\r\n            result.distance = distance;\r\n\r\n            // Get picked point\r\n            let direction = TmpVectors.Vector3[2];\r\n            direction.copyFrom(ray.direction);\r\n            direction.normalize();\r\n            direction.scaleInPlace(distance);\r\n\r\n            ray.origin.addToRef(direction, pickedPoint);\r\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    public multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]> {\r\n        var count = Math.min(this.capacity, this.sprites.length);\r\n        var min = Vector3.Zero();\r\n        var max = Vector3.Zero();\r\n        var distance: number;\r\n        var results: Nullable<PickingInfo[]> = [];\r\n        var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\r\n        var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\r\n        var cameraView = camera.getViewMatrix();\r\n\r\n        for (var index = 0; index < count; index++) {\r\n            var sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\r\n                    continue;\r\n                }\r\n\r\n                var result = new PickingInfo();\r\n                results.push(result);\r\n\r\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n                result.hit = true;\r\n                result.pickedSprite = sprite;\r\n                result.distance = distance;\r\n\r\n                // Get picked point\r\n                let direction = TmpVectors.Vector3[2];\r\n                direction.copyFrom(ray.direction);\r\n                direction.normalize();\r\n                direction.scaleInPlace(distance);\r\n\r\n                ray.origin.addToRef(direction, pickedPoint);\r\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n            }\r\n\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     */\r\n    public render(): void {\r\n        // Check\r\n        if (this._fromPacked  && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._scene.getEngine();\r\n        var deltaTime = engine.getDeltaTime();\r\n        if (this._packedAndReady) {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\r\n        }\r\n        else {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\r\n        }\r\n    }\r\n\r\n    private _customUpdate = (sprite: ThinSprite, baseSize: ISize): void => {\r\n        if (!sprite.cellRef) {\r\n            sprite.cellIndex = 0;\r\n        }\r\n        let num = sprite.cellIndex;\r\n        if (typeof (num) === \"number\" && isFinite(num) && Math.floor(num) === num) {\r\n            sprite.cellRef = this._spriteMap[sprite.cellIndex];\r\n        }\r\n        sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\r\n        sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\r\n        sprite._xSize = this._cellData[sprite.cellRef].frame.w;\r\n        sprite._ySize = this._cellData[sprite.cellRef].frame.h;\r\n    };\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._spriteRenderer) {\r\n            this._spriteRenderer.dispose();\r\n            (<any>this._spriteRenderer) = null;\r\n        }\r\n\r\n        this._textureContent = null;\r\n\r\n        // Remove from scene\r\n        var index = this._scene.spriteManagers.indexOf(this);\r\n        this._scene.spriteManagers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite manager to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        var serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.capacity = this.capacity;\r\n        serializationObject.cellWidth = this.cellWidth;\r\n        serializationObject.cellHeight = this.cellHeight;\r\n\r\n        if (this.texture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = this.texture.serialize();\r\n            } else {\r\n                serializationObject.textureUrl = this.texture.name;\r\n                serializationObject.invertY = this.texture._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.sprites = [];\r\n\r\n        for (var sprite of this.sprites) {\r\n            serializationObject.sprites.push(sprite.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite manager.\r\n     * @param parsedManager The JSON object to parse\r\n     * @param scene The scene to create the sprite managerin\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @returns the new sprite manager\r\n     */\r\n    public static Parse(parsedManager: any, scene: Scene, rootUrl: string): SpriteManager {\r\n        var manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\r\n            width: parsedManager.cellWidth,\r\n            height: parsedManager.cellHeight,\r\n        }, scene);\r\n\r\n        if (parsedManager.texture) {\r\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl) as Texture;\r\n        } else if (parsedManager.textureName) {\r\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\r\n        }\r\n\r\n        for (var parsedSprite of parsedManager.sprites) {\r\n            Sprite.Parse(parsedSprite, manager);\r\n        }\r\n\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved in a remote file\r\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        let output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the sprite manager\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        let serializationObject = JSON.parse(snippet.spriteManager);\r\n                        let output = SpriteManager.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}