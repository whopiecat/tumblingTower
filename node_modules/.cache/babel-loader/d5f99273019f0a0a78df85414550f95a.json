{"ast":null,"code":"import { ShaderCodeNode } from './shaderCodeNode';\nimport { ShaderCodeCursor } from './shaderCodeCursor';\nimport { ShaderCodeConditionNode } from './shaderCodeConditionNode';\nimport { ShaderCodeTestNode } from './shaderCodeTestNode';\nimport { ShaderDefineIsDefinedOperator } from './Expressions/Operators/shaderDefineIsDefinedOperator';\nimport { ShaderDefineOrOperator } from './Expressions/Operators/shaderDefineOrOperator';\nimport { ShaderDefineAndOperator } from './Expressions/Operators/shaderDefineAndOperator';\nimport { ShaderDefineExpression } from './Expressions/shaderDefineExpression';\nimport { ShaderDefineArithmeticOperator } from './Expressions/Operators/shaderDefineArithmeticOperator';\nimport { _DevTools } from '../../Misc/devTools';\nvar regexSE = /defined\\s*?\\((.+?)\\)/g;\nvar regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\n/** @hidden */\n\nvar ShaderProcessor =\n/** @class */\nfunction () {\n  function ShaderProcessor() {}\n\n  ShaderProcessor.Process = function (sourceCode, options, callback, engine) {\n    var _this = this;\n\n    this._ProcessIncludes(sourceCode, options, function (codeWithIncludes) {\n      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);\n\n      callback(migratedCode);\n    });\n  };\n\n  ShaderProcessor._ProcessPrecision = function (source, options) {\n    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n\n    return source;\n  };\n\n  ShaderProcessor._ExtractOperation = function (expression) {\n    var regex = /defined\\((.+)\\)/;\n    var match = regex.exec(expression);\n\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n\n    var operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\n    var operator = \"\";\n    var indexOperator = 0;\n\n    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {\n      operator = operators_1[_i];\n      indexOperator = expression.indexOf(operator);\n\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n\n    var define = expression.substring(0, indexOperator).trim();\n    var value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  };\n\n  ShaderProcessor._BuildSubExpression = function (expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    var postfix = ShaderDefineExpression.infixToPostfix(expression);\n    var stack = [];\n\n    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {\n      var c = postfix_1[_i];\n\n      if (c !== '||' && c !== '&&') {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        var v1 = stack[stack.length - 1],\n            v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        var operator = c == '&&' ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n\n        if (typeof v1 === 'string') {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n\n        if (typeof v2 === 'string') {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n\n        operator.leftOperand = typeof v2 === 'string' ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === 'string' ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n\n    var result = stack[stack.length - 1];\n\n    if (typeof result === 'string') {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    } // note: stack.length !== 1 if there was an error in the parsing\n\n\n    return typeof result === 'string' ? this._ExtractOperation(result) : result;\n  };\n\n  ShaderProcessor._BuildExpression = function (line, start) {\n    var node = new ShaderCodeTestNode();\n    var command = line.substring(0, start);\n    var expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n\n    return node;\n  };\n\n  ShaderProcessor._MoveCursorWithinIf = function (cursor, rootNode, ifNode) {\n    var line = cursor.currentLine;\n\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      var first5 = line.substring(0, 5).toLowerCase();\n\n      if (first5 === \"#else\") {\n        var elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n\n        this._MoveCursor(cursor, elseNode);\n\n        return;\n      } else if (first5 === \"#elif\") {\n        var elifNode = this._BuildExpression(line, 5);\n\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  };\n\n  ShaderProcessor._MoveCursor = function (cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      var line = cursor.currentLine;\n      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\n      var matches = keywords.exec(line);\n\n      if (matches && matches.length) {\n        var keyword = matches[0];\n\n        switch (keyword) {\n          case \"#ifdef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 6);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#else\":\n          case \"#elif\":\n            return true;\n\n          case \"#endif\":\n            return false;\n\n          case \"#ifndef\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n\n              var ifNode = this._BuildExpression(line, 7);\n\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n\n          case \"#if\":\n            {\n              var newRootNode = new ShaderCodeConditionNode();\n\n              var ifNode = this._BuildExpression(line, 3);\n\n              rootNode.children.push(newRootNode);\n              newRootNode.children.push(ifNode);\n\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n\n              break;\n            }\n        }\n      } else {\n        var newNode = new ShaderCodeNode();\n        newNode.line = line;\n        rootNode.children.push(newNode); // Detect additional defines\n\n        if (line[0] === \"#\" && line[1] === \"d\") {\n          var split = line.replace(\";\", \"\").split(\" \");\n          newNode.additionalDefineKey = split[1];\n\n          if (split.length === 3) {\n            newNode.additionalDefineValue = split[2];\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  ShaderProcessor._EvaluatePreProcessors = function (sourceCode, preprocessors, options) {\n    var rootNode = new ShaderCodeNode();\n    var cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\"); // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n\n    this._MoveCursor(cursor, rootNode); // Recompose\n\n\n    return rootNode.process(preprocessors, options);\n  };\n\n  ShaderProcessor._PreparePreProcessors = function (options) {\n    var defines = options.defines;\n    var preprocessors = {};\n\n    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {\n      var define = defines_1[_i];\n      var keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      var split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n\n    preprocessors[\"GL_ES\"] = \"true\";\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n    return preprocessors;\n  };\n\n  ShaderProcessor._ProcessShaderConversion = function (sourceCode, options, engine) {\n    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n\n    if (!options.processor) {\n      return preparedSourceCode;\n    } // Already converted\n\n\n    if (preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      return preparedSourceCode.replace(\"#version 300 es\", \"\");\n    }\n\n    var defines = options.defines;\n\n    var preprocessors = this._PreparePreProcessors(options); // General pre processing\n\n\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment);\n    }\n\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options); // Post processing\n\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, engine);\n    }\n\n    return preparedSourceCode;\n  };\n\n  ShaderProcessor._ProcessIncludes = function (sourceCode, options, callback) {\n    var _this = this;\n\n    var regex = /#include<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\n    var match = regex.exec(sourceCode);\n    var returnValue = new String(sourceCode);\n    var keepProcessing = false;\n\n    while (match != null) {\n      var includeFile = match[1]; // Uniform declaration\n\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(/__decl__/, \"\");\n\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(/Vertex/, \"Ubo\");\n          includeFile = includeFile.replace(/Fragment/, \"Ubo\");\n        }\n\n        includeFile = includeFile + \"Declaration\";\n      }\n\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        var includeContent = options.includesShadersStore[includeFile];\n\n        if (match[2]) {\n          var splits = match[3].split(\",\");\n\n          for (var index = 0; index < splits.length; index += 2) {\n            var source = new RegExp(splits[index], \"g\");\n            var dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n\n        if (match[4]) {\n          var indexString = match[5];\n\n          if (indexString.indexOf(\"..\") !== -1) {\n            var indexSplits = indexString.split(\"..\");\n            var minIndex = parseInt(indexSplits[0]);\n            var maxIndex = parseInt(indexSplits[1]);\n            var sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n\n            for (var i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                  return p1 + \"{X}\";\n                });\n              }\n\n              includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                return p1 + \"{X}\";\n              });\n            }\n\n            includeContent = includeContent.replace(/\\{X\\}/g, indexString);\n          }\n        } // Replace\n\n\n        returnValue = returnValue.replace(match[0], includeContent);\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0;\n      } else {\n        var includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, function (fileContent) {\n          options.includesShadersStore[includeFile] = fileContent;\n\n          _this._ProcessIncludes(returnValue, options, callback);\n        });\n\n        return;\n      }\n\n      match = regex.exec(sourceCode);\n    }\n\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   * @hidden\r\n   */\n\n\n  ShaderProcessor._FileToolsLoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _DevTools.WarnImport(\"FileTools\");\n  };\n\n  return ShaderProcessor;\n}();\n\nexport { ShaderProcessor };","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Processors/shaderProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import { ShaderCodeNode } from './shaderCodeNode';\r\nimport { ShaderCodeCursor } from './shaderCodeCursor';\r\nimport { ShaderCodeConditionNode } from './shaderCodeConditionNode';\r\nimport { ShaderCodeTestNode } from './shaderCodeTestNode';\r\nimport { ShaderDefineIsDefinedOperator } from './Expressions/Operators/shaderDefineIsDefinedOperator';\r\nimport { ShaderDefineOrOperator } from './Expressions/Operators/shaderDefineOrOperator';\r\nimport { ShaderDefineAndOperator } from './Expressions/Operators/shaderDefineAndOperator';\r\nimport { ShaderDefineExpression } from './Expressions/shaderDefineExpression';\r\nimport { ShaderDefineArithmeticOperator } from './Expressions/Operators/shaderDefineArithmeticOperator';\r\nimport { ProcessingOptions } from './shaderProcessingOptions';\r\nimport { _DevTools } from '../../Misc/devTools';\r\n\r\ndeclare type WebRequest = import(\"../../Misc/webRequest\").WebRequest;\r\ndeclare type LoadFileError = import(\"../../Misc/fileTools\").LoadFileError;\r\ndeclare type IOfflineProvider = import(\"../../Offline/IOfflineProvider\").IOfflineProvider;\r\ndeclare type IFileRequest  = import(\"../../Misc/fileRequest\").IFileRequest;\r\ndeclare type ThinEngine = import(\"../thinEngine\").ThinEngine;\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\n\r\n/** @hidden */\r\nexport class ShaderProcessor {\r\n    public static Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string) => void, engine: ThinEngine) {\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            let migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\r\n            callback(migratedCode);\r\n        });\r\n    }\r\n\r\n    private static _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n        const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n        if (source.indexOf(\"precision highp float\") === -1) {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                source = \"precision mediump float;\\n\" + source;\r\n            } else {\r\n                source = \"precision highp float;\\n\" + source;\r\n            }\r\n        } else {\r\n            if (!shouldUseHighPrecisionShader) { // Moving highp to mediump\r\n                source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n            }\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    private static _ExtractOperation(expression: string) {\r\n        let regex = /defined\\((.+)\\)/;\r\n\r\n        let match = regex.exec(expression);\r\n\r\n        if (match && match.length) {\r\n            return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n        }\r\n\r\n        let operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\r\n        let operator = \"\";\r\n        let indexOperator = 0;\r\n\r\n        for (operator of operators) {\r\n            indexOperator = expression.indexOf(operator);\r\n\r\n            if (indexOperator > -1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (indexOperator === -1) {\r\n            return new ShaderDefineIsDefinedOperator(expression);\r\n        }\r\n\r\n        let define = expression.substring(0, indexOperator).trim();\r\n        let value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n        return new ShaderDefineArithmeticOperator(define, operator, value);\r\n    }\r\n\r\n    private static _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n        expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n        const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n        const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n        for (let c of postfix) {\r\n            if (c !== '||' && c !== '&&') {\r\n                stack.push(c);\r\n            } else if (stack.length >= 2) {\r\n                let v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n\r\n                let operator = c == '&&' ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n                if (typeof(v1) === 'string') {\r\n                    v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                if (typeof(v2) === 'string') {\r\n                    v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                operator.leftOperand = typeof(v2) === 'string' ? this._ExtractOperation(v2) : v2;\r\n                operator.rightOperand = typeof(v1) === 'string' ? this._ExtractOperation(v1) : v1;\r\n\r\n                stack.push(operator);\r\n            }\r\n        }\r\n\r\n        let result = stack[stack.length - 1];\r\n\r\n        if (typeof(result) === 'string') {\r\n            result = result.replace(regexSERevert, \"defined($1)\");\r\n        }\r\n\r\n        // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n        return typeof(result) === 'string' ? this._ExtractOperation(result) : result;\r\n    }\r\n\r\n    private static _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n        let node = new ShaderCodeTestNode();\r\n        let command = line.substring(0, start);\r\n        let expression = line.substring(start);\r\n\r\n        expression = expression.substring(0, ((expression.indexOf(\"//\") + 1) || (expression.length + 1)) - 1).trim();\r\n\r\n        if (command === \"#ifdef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n        } else if (command === \"#ifndef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n        } else {\r\n            node.testExpression = this._BuildSubExpression(expression);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private static _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n        let line = cursor.currentLine;\r\n        while (this._MoveCursor(cursor, ifNode)) {\r\n            line = cursor.currentLine;\r\n            let first5 = line.substring(0, 5).toLowerCase();\r\n\r\n            if (first5 === \"#else\") {\r\n                let elseNode = new ShaderCodeNode();\r\n                rootNode.children.push(elseNode);\r\n                this._MoveCursor(cursor, elseNode);\r\n                return;\r\n            } else if (first5 === \"#elif\") {\r\n                let elifNode = this._BuildExpression(line, 5);\r\n\r\n                rootNode.children.push(elifNode);\r\n                ifNode = elifNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n        while (cursor.canRead) {\r\n            cursor.lineIndex++;\r\n            let line = cursor.currentLine;\r\n            const keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n            const matches = keywords.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                let keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        let newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        let ifNode = this._BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        let newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        let ifNode = this._BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        let newRootNode = new ShaderCodeConditionNode();\r\n                        let ifNode = this._BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let newNode = new ShaderCodeNode();\r\n                newNode.line = line;\r\n                rootNode.children.push(newNode);\r\n\r\n                // Detect additional defines\r\n                if (line[0] === \"#\" && line[1] === \"d\") {\r\n                    let split = line.replace(\";\", \"\").split(\" \");\r\n                    newNode.additionalDefineKey = split[1];\r\n\r\n                    if (split.length === 3) {\r\n                        newNode.additionalDefineValue = split[2];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        const rootNode = new ShaderCodeNode();\r\n        let cursor = new ShaderCodeCursor();\r\n\r\n        cursor.lineIndex = -1;\r\n        cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n        // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n        this._MoveCursor(cursor, rootNode);\r\n\r\n        // Recompose\r\n        return rootNode.process(preprocessors, options);\r\n    }\r\n\r\n    private static _PreparePreProcessors(options: ProcessingOptions): { [key: string]: string } {\r\n        let defines = options.defines;\r\n        let preprocessors: { [key: string]: string } = {};\r\n\r\n        for (var define of defines) {\r\n            let keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n            let split = keyValue.split(\" \");\r\n            preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n        }\r\n\r\n        preprocessors[\"GL_ES\"] = \"true\";\r\n        preprocessors[\"__VERSION__\"] = options.version;\r\n        preprocessors[options.platformName] = \"true\";\r\n\r\n        return preprocessors;\r\n    }\r\n\r\n    private static _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n\r\n        var preparedSourceCode = this._ProcessPrecision(sourceCode, options);\r\n\r\n        if (!options.processor) {\r\n            return preparedSourceCode;\r\n        }\r\n\r\n        // Already converted\r\n        if (preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n            return preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n        }\r\n\r\n        let defines = options.defines;\r\n\r\n        let preprocessors = this._PreparePreProcessors(options);\r\n\r\n        // General pre processing\r\n        if (options.processor.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, engine);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n        var regex = /#include<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\n        var match = regex.exec(sourceCode);\r\n\r\n        var returnValue = new String(sourceCode);\r\n        var keepProcessing = false;\r\n\r\n        while (match != null) {\r\n            var includeFile = match[1];\r\n\r\n            // Uniform declaration\r\n            if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n                includeFile = includeFile.replace(/__decl__/, \"\");\r\n                if (options.supportsUniformBuffers) {\r\n                    includeFile = includeFile.replace(/Vertex/, \"Ubo\");\r\n                    includeFile = includeFile.replace(/Fragment/, \"Ubo\");\r\n                }\r\n                includeFile = includeFile + \"Declaration\";\r\n            }\r\n\r\n            if (options.includesShadersStore[includeFile]) {\r\n                // Substitution\r\n                var includeContent = options.includesShadersStore[includeFile];\r\n                if (match[2]) {\r\n                    var splits = match[3].split(\",\");\r\n\r\n                    for (var index = 0; index < splits.length; index += 2) {\r\n                        var source = new RegExp(splits[index], \"g\");\r\n                        var dest = splits[index + 1];\r\n\r\n                        includeContent = includeContent.replace(source, dest);\r\n                    }\r\n                }\r\n\r\n                if (match[4]) {\r\n                    var indexString = match[5];\r\n\r\n                    if (indexString.indexOf(\"..\") !== -1) {\r\n                        var indexSplits = indexString.split(\"..\");\r\n                        var minIndex = parseInt(indexSplits[0]);\r\n                        var maxIndex = parseInt(indexSplits[1]);\r\n                        var sourceIncludeContent = includeContent.slice(0);\r\n                        includeContent = \"\";\r\n\r\n                        if (isNaN(maxIndex)) {\r\n                            maxIndex = options.indexParameters[indexSplits[1]];\r\n                        }\r\n\r\n                        for (var i = minIndex; i < maxIndex; i++) {\r\n                            if (!options.supportsUniformBuffers) {\r\n                                // Ubo replacement\r\n                                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                    return p1 + \"{X}\";\r\n                                });\r\n                            }\r\n                            includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\r\n                        }\r\n                    } else {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent = includeContent.replace(/\\{X\\}/g, indexString);\r\n                    }\r\n                }\r\n\r\n                // Replace\r\n                returnValue = returnValue.replace(match[0], includeContent);\r\n\r\n                keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0;\r\n            } else {\r\n                var includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n                ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {\r\n                    options.includesShadersStore[includeFile] = fileContent as string;\r\n                    this._ProcessIncludes(<string>returnValue, options, callback);\r\n                });\r\n                return;\r\n            }\r\n\r\n            match = regex.exec(sourceCode);\r\n        }\r\n\r\n        if (keepProcessing) {\r\n            this._ProcessIncludes(returnValue.toString(), options, callback);\r\n        } else {\r\n            callback(returnValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @hidden\r\n     */\r\n    public static _FileToolsLoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest {\r\n        throw  _DevTools.WarnImport(\"FileTools\");\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}