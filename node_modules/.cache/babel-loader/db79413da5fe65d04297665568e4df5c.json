{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { MaterialHelper } from '../../../materialHelper';\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex\";\n/**\r\n * Block used to add light in the fragment shader\r\n */\n\nvar LightBlock =\n/** @class */\nfunction (_super) {\n  __extends(LightBlock, _super);\n  /**\r\n   * Create a new LightBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function LightBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;\n\n    _this._isUnique = true;\n\n    _this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n\n    _this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n\n    _this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n\n    _this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  LightBlock.prototype.getClassName = function () {\n    return \"LightBlock\";\n  };\n\n  Object.defineProperty(LightBlock.prototype, \"worldPosition\", {\n    /**\r\n     * Gets the world position input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"worldNormal\", {\n    /**\r\n     * Gets the world normal input component\r\n     */\n    get: function () {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"cameraPosition\", {\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\n    get: function () {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"glossiness\", {\n    /**\r\n    * Gets the glossiness component\r\n    */\n    get: function () {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"glossPower\", {\n    /**\r\n    * Gets the glossinness power component\r\n    */\n    get: function () {\n      return this._inputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"diffuseColor\", {\n    /**\r\n    * Gets the diffuse color component\r\n    */\n    get: function () {\n      return this._inputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"specularColor\", {\n    /**\r\n    * Gets the specular color component\r\n    */\n    get: function () {\n      return this._inputs[6];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"view\", {\n    /**\r\n    * Gets the view matrix component\r\n    */\n    get: function () {\n      return this._inputs[7];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"diffuseOutput\", {\n    /**\r\n     * Gets the diffuse output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"specularOutput\", {\n    /**\r\n     * Gets the specular output component\r\n     */\n    get: function () {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(LightBlock.prototype, \"shadow\", {\n    /**\r\n     * Gets the shadow output component\r\n     */\n    get: function () {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LightBlock.prototype.autoConfigure = function (material) {\n    if (!this.cameraPosition.isConnected) {\n      var cameraPositionInput = material.getInputBlockByPredicate(function (b) {\n        return b.systemValue === NodeMaterialSystemValues.CameraPosition;\n      });\n\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  };\n\n  LightBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty) {\n      return;\n    }\n\n    var scene = mesh.getScene();\n\n    if (!this.light) {\n      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      var state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  };\n\n  LightBlock.prototype.updateUniformsAndSamples = function (state, nodeMaterial, defines, uniformBuffers) {\n    for (var lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      var onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  };\n\n  LightBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n\n    var scene = mesh.getScene();\n\n    if (!this.light) {\n      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\n    }\n  };\n\n  LightBlock.prototype._injectVertexCode = function (state) {\n    var worldPos = this.worldPosition;\n    var comments = \"//\" + this.name; // Declaration\n\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    } // Inject code in vertex\n\n\n    var worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += worldPosVaryingName + \" = \" + worldPos.associatedVariableName + \";\\r\\n\";\n    }\n\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += \"vec4 worldPos = \" + worldPos.associatedVariableName + \";\\r\\n\";\n\n      if (this.view.isConnected) {\n        state.compilationString += \"mat4 view = \" + this.view.associatedVariableName + \";\\r\\n\";\n      }\n\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  };\n\n  LightBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    state.sharedData.bindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    var comments = \"//\" + this.name;\n    var worldPos = this.worldPosition;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: \"v_\" + worldPos.associatedVariableName + \".xyz\"\n      }]\n    });\n\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: \"v_\" + worldPos.associatedVariableName + \".xyz\"\n      }]\n    });\n\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    } // Code\n\n\n    if (this._lightId === 0) {\n      if (state._registerTempVariable(\"viewDirectionW\")) {\n        state.compilationString += \"vec3 viewDirectionW = normalize(\" + this.cameraPosition.associatedVariableName + \" - \" + (\"v_\" + worldPos.associatedVariableName) + \".xyz);\\r\\n\";\n      }\n\n      state.compilationString += \"lightingInfo info;\\r\\n\";\n      state.compilationString += \"float shadow = 1.;\\r\\n\";\n      state.compilationString += \"float glossiness = \" + (this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\") + \" * \" + (this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\") + \";\\r\\n\";\n      state.compilationString += \"vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n\";\n      state.compilationString += \"vec3 specularBase = vec3(0., 0., 0.);\\r\\n\";\n      state.compilationString += \"vec3 normalW = \" + this.worldNormal.associatedVariableName + \".xyz;\\r\\n\";\n    }\n\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n\n    var diffuseOutput = this.diffuseOutput;\n    var specularOutput = this.specularOutput;\n    state.compilationString += this._declareOutput(diffuseOutput, state) + (\" = diffuseBase\" + (this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\") + \";\\r\\n\");\n\n    if (specularOutput.hasEndpoints) {\n      state.compilationString += this._declareOutput(specularOutput, state) + (\" = specularBase\" + (this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\") + \";\\r\\n\");\n    }\n\n    if (this.shadow.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.shadow, state) + \" = shadow;\\r\\n\";\n    }\n\n    return this;\n  };\n\n  LightBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n\n    return serializationObject;\n  };\n\n  LightBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    if (serializationObject.lightId) {\n      this.light = scene.getLightByID(serializationObject.lightId);\n    }\n  };\n\n  return LightBlock;\n}(NodeMaterialBlock);\n\nexport { LightBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.LightBlock\"] = LightBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Dual/lightBlock.ts"],"names":[],"mappings":";AAAA,SAAS,iBAAT,QAAkC,yBAAlC;AACA,SAAS,wBAAT,QAAyC,sCAAzC;AACA,SAAS,qCAAT,QAAsD,mDAAtD;AAGA,SAAS,cAAT,QAA+B,yBAA/B;AAKA,SAAS,wBAAT,QAAyC,sCAAzC;AACA,SAAS,UAAT,QAA2B,qBAA3B;AAGA,SAAS,UAAT,QAA2B,4BAA3B;AAGA,OAAO,6DAAP;AACA,OAAO,wDAAP;AACA,OAAO,kDAAP;AACA,OAAO,oDAAP;AACA,OAAO,4DAAP;AACA,OAAO,6DAAP;AACA,OAAO,kDAAP;AAEA;;;;AAGA,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAgC,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;AAQ5B;;;;;;AAIA,WAAA,UAAA,CAAmB,IAAnB,EAA+B;AAA/B,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,wBAAwB,CAAC,iBAArC,KAAuD,IAD3D;;AAGI,IAAA,KAAI,CAAC,SAAL,GAAiB,IAAjB;;AAEA,IAAA,KAAI,CAAC,aAAL,CAAmB,eAAnB,EAAoC,qCAAqC,CAAC,OAA1E,EAAmF,KAAnF,EAA0F,wBAAwB,CAAC,MAAnH;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,aAAnB,EAAkC,qCAAqC,CAAC,OAAxE,EAAiF,KAAjF,EAAwF,wBAAwB,CAAC,QAAjH;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,gBAAnB,EAAqC,qCAAqC,CAAC,OAA3E,EAAoF,KAApF,EAA2F,wBAAwB,CAAC,QAApH;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,YAAnB,EAAiC,qCAAqC,CAAC,KAAvE,EAA8E,IAA9E,EAAoF,wBAAwB,CAAC,QAA7G;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,YAAnB,EAAiC,qCAAqC,CAAC,KAAvE,EAA8E,IAA9E,EAAoF,wBAAwB,CAAC,QAA7G;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,cAAnB,EAAmC,qCAAqC,CAAC,MAAzE,EAAiF,IAAjF,EAAuF,wBAAwB,CAAC,QAAhH;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,eAAnB,EAAoC,qCAAqC,CAAC,MAA1E,EAAkF,IAAlF,EAAwF,wBAAwB,CAAC,QAAjH;;AACA,IAAA,KAAI,CAAC,aAAL,CAAmB,MAAnB,EAA2B,qCAAqC,CAAC,MAAjE,EAAyE,IAAzE;;AAEA,IAAA,KAAI,CAAC,cAAL,CAAoB,eAApB,EAAqC,qCAAqC,CAAC,MAA3E,EAAmF,wBAAwB,CAAC,QAA5G;;AACA,IAAA,KAAI,CAAC,cAAL,CAAoB,gBAApB,EAAsC,qCAAqC,CAAC,MAA5E,EAAoF,wBAAwB,CAAC,QAA7G;;AACA,IAAA,KAAI,CAAC,cAAL,CAAoB,QAApB,EAA8B,qCAAqC,CAAC,KAApE,EAA2E,wBAAwB,CAAC,QAApG;;;AACH;AAED;;;;;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,YAAA;AACI,WAAO,YAAP;AACH,GAFM;;AAOP,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAHzB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFwB;qBAAA;;AAAA,GAAzB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAHf;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAL,CAAa,CAAb,CAAP;AACH,KAFc;qBAAA;;AAAA,GAAf;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,CAAd,CAAP;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,gBAAX,EAAyB;AAHzB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,CAAd,CAAP;AACH,KAFwB;qBAAA;;AAAA,GAAzB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAHjB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,CAAd,CAAP;AACH,KAFgB;qBAAA;;AAAA,GAAjB;;AAIO,EAAA,UAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,QAArB,EAA2C;AACvC,QAAI,CAAC,KAAK,cAAL,CAAoB,WAAzB,EAAsC;AAClC,UAAI,mBAAmB,GAAG,QAAQ,CAAC,wBAAT,CAAkC,UAAC,CAAD,EAAE;AAAK,eAAA,CAAC,CAAC,WAAF,KAAkB,wBAAwB,CAA1C,cAAA;AAAyD,OAAlG,CAA1B;;AAEA,UAAI,CAAC,mBAAL,EAA0B;AACtB,QAAA,mBAAmB,GAAG,IAAI,UAAJ,CAAe,gBAAf,CAAtB;AACA,QAAA,mBAAmB,CAAC,gBAApB,CAAqC,wBAAwB,CAAC,cAA9D;AACH;;AACD,MAAA,mBAAmB,CAAC,MAApB,CAA2B,SAA3B,CAAqC,KAAK,cAA1C;AACH;AACJ,GAVM;;AAYA,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,IAAtB,EAA0C,YAA1C,EAAsE,OAAtE,EAAkG;AAC9F,QAAI,CAAC,OAAO,CAAC,eAAb,EAA8B;AAC1B;AACH;;AAED,QAAM,KAAK,GAAG,IAAI,CAAC,QAAL,EAAd;;AAEA,QAAI,CAAC,KAAK,KAAV,EAAiB;AACb,MAAA,cAAc,CAAC,uBAAf,CAAuC,KAAvC,EAA8C,IAA9C,EAAoD,OAApD,EAA6D,IAA7D,EAAmE,YAAY,CAAC,qBAAhF;AACH,KAFD,MAEO;AACH,UAAI,KAAK,GAAG;AACR,QAAA,WAAW,EAAE,KADL;AAER,QAAA,WAAW,EAAE,KAFL;AAGR,QAAA,YAAY,EAAE,KAHN;AAIR,QAAA,aAAa,EAAE,KAJP;AAKR,QAAA,eAAe,EAAE;AALT,OAAZ;AAQA,MAAA,cAAc,CAAC,sBAAf,CAAsC,KAAtC,EAA6C,IAA7C,EAAmD,KAAK,KAAxD,EAA+D,KAAK,QAApE,EAA8E,OAA9E,EAAuF,IAAvF,EAA6F,KAA7F;;AAEA,UAAI,KAAK,CAAC,WAAV,EAAuB;AACnB,QAAA,OAAO,CAAC,OAAR;AACH;AACJ;AACJ,GAxBM;;AA0BA,EAAA,UAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,KAAhC,EAA+D,YAA/D,EAA2F,OAA3F,EAAyH,cAAzH,EAAiJ;AAC7I,SAAK,IAAI,UAAU,GAAG,CAAtB,EAAyB,UAAU,GAAG,YAAY,CAAC,qBAAnD,EAA0E,UAAU,EAApF,EAAwF;AACpF,UAAI,CAAC,OAAO,CAAC,UAAU,UAAX,CAAZ,EAAoC;AAChC;AACH;;AACD,UAAM,qBAAqB,GAAG,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,eAAe,UAAtC,KAAqD,CAAnF;AACA,MAAA,cAAc,CAAC,kCAAf,CAAkD,UAAlD,EAA8D,KAAK,CAAC,QAApE,EAA8E,KAAK,CAAC,QAApF,EAA8F,OAAO,CAAC,0BAA0B,UAA3B,CAArG,EAA6I,cAA7I,EAA6J,qBAA7J;AACH;AACJ,GARM;;AAUA,EAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAP,UAAY,MAAZ,EAA4B,YAA5B,EAAwD,IAAxD,EAAmE;AAC/D,QAAI,CAAC,IAAL,EAAW;AACP;AACH;;AAED,QAAM,KAAK,GAAG,IAAI,CAAC,QAAL,EAAd;;AAEA,QAAI,CAAC,KAAK,KAAV,EAAiB;AACb,MAAA,cAAc,CAAC,UAAf,CAA0B,KAA1B,EAAiC,IAAjC,EAAuC,MAAvC,EAA+C,IAA/C,EAAqD,YAAY,CAAC,qBAAlE;AACH,KAFD,MAEO;AACH,MAAA,cAAc,CAAC,SAAf,CAAyB,KAAK,KAA9B,EAAqC,KAAK,QAA1C,EAAoD,KAApD,EAA2D,MAA3D,EAAmE,IAAnE;AACH;AACJ,GAZM;;AAcC,EAAA,UAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,KAA1B,EAAuD;AACnD,QAAI,QAAQ,GAAG,KAAK,aAApB;AACA,QAAI,QAAQ,GAAG,OAAK,KAAK,IAAzB,CAFmD,CAInD;;AACA,QAAI,CAAC,KAAK,KAAV,EAAiB;AAAE;AACf,MAAA,KAAK,CAAC,wBAAN,CAA+B,KAAK,CAAC,qBAAN,GAA8B,qBAA9B,GAAsD,0BAArF,EAAiH,QAAjH,EAA2H;AACvH,QAAA,SAAS,EAAE;AAD4G,OAA3H;;AAGA,WAAK,QAAL,GAAgB,CAAhB;AAEA,MAAA,KAAK,CAAC,UAAN,CAAiB,oBAAjB,CAAsC,IAAtC,CAA2C,IAA3C;AACH,KAPD,MAOO;AAEH,WAAK,QAAL,GAAgB,CAAC,KAAK,CAAC,QAAN,CAAe,cAAf,MAAmC,SAAnC,GAA+C,KAAK,CAAC,QAAN,CAAe,cAAf,CAA/C,GAAgF,CAAC,CAAlF,IAAuF,CAAvG;AACA,MAAA,KAAK,CAAC,QAAN,CAAe,cAAf,IAAiC,KAAK,QAAtC;;AAEA,MAAA,KAAK,CAAC,wBAAN,CAA+B,KAAK,CAAC,qBAAN,GAA8B,qBAA9B,GAAsD,0BAArF,EAAiH,QAAjH,EAA2H;AACvH,QAAA,cAAc,EAAE,CAAC;AAAE,UAAA,MAAM,EAAE,MAAV;AAAkB,UAAA,OAAO,EAAE,KAAK,QAAL,CAAc,QAAd;AAA3B,SAAD;AADuG,OAA3H,EAEG,KAAK,QAAL,CAAc,QAAd,EAFH;AAGH,KApBkD,CAsBnD;;;AACA,QAAI,mBAAmB,GAAG,OAAO,QAAQ,CAAC,sBAA1C;;AACA,QAAI,KAAK,CAAC,sBAAN,CAA6B,mBAA7B,EAAkD,MAAlD,CAAJ,EAA+D;AAC3D,MAAA,KAAK,CAAC,iBAAN,IAA8B,mBAAmB,GAAA,KAAnB,GAAyB,QAAQ,CAAC,sBAAlC,GAAwD,OAAtF;AACH;;AAED,QAAI,KAAK,KAAT,EAAgB;AACZ,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,CAAC,oBAAN,CAA2B,eAA3B,EAA4C,QAA5C,EAAsD;AAC7E,QAAA,cAAc,EAAE,CACZ;AAAE,UAAA,MAAM,EAAE,MAAV;AAAkB,UAAA,OAAO,EAAE,KAAK,QAAL,CAAc,QAAd;AAA3B,SADY,EAEZ;AAAE,UAAA,MAAM,EAAE,WAAV;AAAuB,UAAA,OAAO,EAAE,QAAQ,CAAC;AAAzC,SAFY;AAD6D,OAAtD,CAA3B;AAMH,KAPD,MAOO;AACH,MAAA,KAAK,CAAC,iBAAN,IAA2B,qBAAmB,QAAQ,CAAC,sBAA5B,GAAkD,OAA7E;;AACA,UAAI,KAAK,IAAL,CAAU,WAAd,EAA2B;AACvB,QAAA,KAAK,CAAC,iBAAN,IAA2B,iBAAe,KAAK,IAAL,CAAU,sBAAzB,GAA+C,OAA1E;AACH;;AACD,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,CAAC,oBAAN,CAA2B,eAA3B,EAA4C,QAA5C,EAAsD;AAC7E,QAAA,SAAS,EAAE;AADkE,OAAtD,CAA3B;AAGH;AACJ,GA5CO;;AA8CE,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAV,UAAsB,KAAtB,EAAmD;AAC/C,IAAA,MAAA,CAAA,SAAA,CAAM,WAAN,CAAiB,IAAjB,CAAiB,IAAjB,EAAkB,KAAlB;;AAEA,QAAI,KAAK,CAAC,MAAN,KAAiB,wBAAwB,CAAC,QAA9C,EAAwD;AACpD;AACA,WAAK,iBAAL,CAAuB,KAAvB;;AAEA;AACH,KAR8C,CAU/C;;;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAArC;AACA,IAAA,KAAK,CAAC,UAAN,CAAiB,iBAAjB,CAAmC,IAAnC,CAAwC,IAAxC;AAEA,QAAI,QAAQ,GAAG,OAAK,KAAK,IAAzB;AACA,QAAI,QAAQ,GAAG,KAAK,aAApB;;AAEA,IAAA,KAAK,CAAC,wBAAN,CAA+B,iBAA/B,EAAkD,QAAlD;;AAEA,IAAA,KAAK,CAAC,wBAAN,CAA+B,yBAA/B,EAA0D,QAA1D,EAAoE;AAChE,MAAA,cAAc,EAAE,CACZ;AAAE,QAAA,MAAM,EAAE,aAAV;AAAyB,QAAA,OAAO,EAAE,OAAO,QAAQ,CAAC,sBAAhB,GAAyC;AAA3E,OADY;AADgD,KAApE;;AAMA,IAAA,KAAK,CAAC,wBAAN,CAA+B,0BAA/B,EAA2D,QAA3D,EAAqE;AACjE,MAAA,cAAc,EAAE,CACZ;AAAE,QAAA,MAAM,EAAE,aAAV;AAAyB,QAAA,OAAO,EAAE,OAAO,QAAQ,CAAC,sBAAhB,GAAyC;AAA3E,OADY;AADiD,KAArE;;AAMA,QAAI,CAAC,KAAK,KAAV,EAAiB;AAAE;AACf,MAAA,KAAK,CAAC,wBAAN,CAA+B,KAAK,CAAC,qBAAN,GAA8B,qBAA9B,GAAsD,0BAArF,EAAiH,QAAjH,EAA2H;AACvH,QAAA,SAAS,EAAE;AAD4G,OAA3H;AAGH,KAJD,MAIO;AACH,MAAA,KAAK,CAAC,wBAAN,CAA+B,KAAK,CAAC,qBAAN,GAA8B,qBAA9B,GAAsD,0BAArF,EAAiH,QAAjH,EAA2H;AACvH,QAAA,cAAc,EAAE,CAAC;AAAE,UAAA,MAAM,EAAE,MAAV;AAAkB,UAAA,OAAO,EAAE,KAAK,QAAL,CAAc,QAAd;AAA3B,SAAD;AADuG,OAA3H,EAEG,KAAK,QAAL,CAAc,QAAd,EAFH;AAGH,KAvC8C,CAyC/C;;;AACA,QAAI,KAAK,QAAL,KAAkB,CAAtB,EAAyB;AACrB,UAAI,KAAK,CAAC,qBAAN,CAA4B,gBAA5B,CAAJ,EAAmD;AAC/C,QAAA,KAAK,CAAC,iBAAN,IAA2B,qCAAmC,KAAK,cAAL,CAAoB,sBAAvD,GAA6E,KAA7E,IAAmF,OAAO,QAAQ,CAAC,sBAAnG,IAAyH,YAApJ;AACH;;AACD,MAAA,KAAK,CAAC,iBAAN,IAA2B,wBAA3B;AACA,MAAA,KAAK,CAAC,iBAAN,IAA2B,wBAA3B;AACA,MAAA,KAAK,CAAC,iBAAN,IAA2B,yBAAsB,KAAK,UAAL,CAAgB,WAAhB,GAA8B,KAAK,UAAL,CAAgB,sBAA9C,GAAuE,KAA7F,IAAkG,KAAlG,IAAwG,KAAK,UAAL,CAAgB,WAAhB,GAA8B,KAAK,UAAL,CAAgB,sBAA9C,GAAuE,QAA/K,IAAuL,OAAlN;AACA,MAAA,KAAK,CAAC,iBAAN,IAA2B,0CAA3B;AACA,MAAA,KAAK,CAAC,iBAAN,IAA2B,2CAA3B;AACA,MAAA,KAAK,CAAC,iBAAN,IAA2B,oBAAkB,KAAK,WAAL,CAAiB,sBAAnC,GAAyD,WAApF;AACH;;AAED,QAAI,KAAK,KAAT,EAAgB;AACZ,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,CAAC,oBAAN,CAA2B,eAA3B,EAA4C,QAA5C,EAAsD;AAC7E,QAAA,cAAc,EAAE,CACZ;AAAE,UAAA,MAAM,EAAE,MAAV;AAAkB,UAAA,OAAO,EAAE,KAAK,QAAL,CAAc,QAAd;AAA3B,SADY;AAD6D,OAAtD,CAA3B;AAKH,KAND,MAMO;AACH,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,CAAC,oBAAN,CAA2B,eAA3B,EAA4C,QAA5C,EAAsD;AAC7E,QAAA,SAAS,EAAE;AADkE,OAAtD,CAA3B;AAGH;;AAED,QAAI,aAAa,GAAG,KAAK,aAAzB;AACA,QAAI,cAAc,GAAG,KAAK,cAA1B;AAEA,IAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,cAAL,CAAoB,aAApB,EAAmC,KAAnC,KAA4C,oBAAiB,KAAK,YAAL,CAAkB,WAAlB,GAAgC,QAAQ,KAAK,YAAL,CAAkB,sBAA1D,GAAmF,EAApG,IAAsG,OAAlJ,CAA3B;;AACA,QAAI,cAAc,CAAC,YAAnB,EAAiC;AAC7B,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,cAAL,CAAoB,cAApB,EAAoC,KAApC,KAA6C,qBAAkB,KAAK,aAAL,CAAmB,WAAnB,GAAiC,QAAQ,KAAK,aAAL,CAAmB,sBAA5D,GAAqF,EAAvG,IAAyG,OAAtJ,CAA3B;AACH;;AAED,QAAI,KAAK,MAAL,CAAY,YAAhB,EAA8B;AAC1B,MAAA,KAAK,CAAC,iBAAN,IAA2B,KAAK,cAAL,CAAoB,KAAK,MAAzB,EAAiC,KAAjC,IAA0C,gBAArE;AACH;;AAED,WAAO,IAAP;AACH,GA/ES;;AAiFH,EAAA,UAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,QAAI,mBAAmB,GAAG,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf,CAA1B;;AAEA,QAAI,KAAK,KAAT,EAAgB;AACZ,MAAA,mBAAmB,CAAC,OAApB,GAA8B,KAAK,KAAL,CAAW,EAAzC;AACH;;AAED,WAAO,mBAAP;AACH,GARM;;AAUA,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,mBAApB,EAA8C,KAA9C,EAA4D,OAA5D,EAA2E;AACvE,IAAA,MAAA,CAAA,SAAA,CAAM,YAAN,CAAkB,IAAlB,CAAkB,IAAlB,EAAmB,mBAAnB,EAAwC,KAAxC,EAA+C,OAA/C;;AAEA,QAAI,mBAAmB,CAAC,OAAxB,EAAiC;AAC7B,WAAK,KAAL,GAAa,KAAK,CAAC,YAAN,CAAmB,mBAAmB,CAAC,OAAvC,CAAb;AACH;AACJ,GANM;;AAOX,SAAA,UAAA;AAAC,CAlUD,CAAgC,iBAAhC,CAAA;;;AAoUA,UAAU,CAAC,eAAX,CAA2B,oBAA3B,IAAmD,UAAnD","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { MaterialHelper } from '../../../materialHelper';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { Effect } from '../../../effect';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { Light } from '../../../../Lights/light';\r\nimport { Nullable } from '../../../../types';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { Scene } from '../../../../scene';\r\n\r\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightFragment\";\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex\";\r\n\r\n/**\r\n * Block used to add light in the fragment shader\r\n */\r\nexport class LightBlock extends NodeMaterialBlock {\r\n    private _lightId: number;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /**\r\n     * Create a new LightBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"LightBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n    * Gets the camera (or eye) position component\r\n    */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n    * Gets the glossiness component\r\n    */\r\n    public get glossiness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n    * Gets the glossinness power component\r\n    */\r\n    public get glossPower(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n    * Gets the diffuse color component\r\n    */\r\n    public get diffuseColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n    * Gets the specular color component\r\n    */\r\n    public get specularColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n    * Gets the view matrix component\r\n    */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse output component\r\n     */\r\n    public get diffuseOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular output component\r\n     */\r\n    public get specularOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow output component\r\n     */\r\n    public get shadow(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areLightsDirty) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            let state = {\r\n                needNormals: false,\r\n                needRebuild: false,\r\n                lightmapMode: false,\r\n                shadowEnabled: false,\r\n                specularEnabled: false\r\n            };\r\n\r\n            MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\r\n\r\n            if (state.needRebuild) {\r\n                defines.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        for (var lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\r\n            MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\r\n        }\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        let worldPos = this.worldPosition;\r\n        let comments = `//${this.name}`;\r\n\r\n        // Declaration\r\n        if (!this.light) { // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\"\r\n            });\r\n            this._lightId = 0;\r\n\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        } else {\r\n\r\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\r\n            state.counters[\"lightCounter\"] = this._lightId;\r\n\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]\r\n            }, this._lightId.toString());\r\n        }\r\n\r\n        // Inject code in vertex\r\n        let worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName }\r\n                ]\r\n            });\r\n        } else {\r\n            state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\r\\n`;\r\n            if (this.view.isConnected) {\r\n                state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\r\\n`;\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\"\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.bindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        let comments = `//${this.name}`;\r\n        let worldPos = this.worldPosition;\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\r\n            replaceStrings: [\r\n                { search: /vPositionW/g, replace: \"v_\" + worldPos.associatedVariableName + \".xyz\" }\r\n            ]\r\n        });\r\n\r\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\r\n            replaceStrings: [\r\n                { search: /vPositionW/g, replace: \"v_\" + worldPos.associatedVariableName + \".xyz\" }\r\n            ]\r\n        });\r\n\r\n        if (!this.light) { // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\"\r\n            });\r\n        } else {\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }]\r\n            }, this._lightId.toString());\r\n        }\r\n\r\n        // Code\r\n        if (this._lightId === 0) {\r\n            if (state._registerTempVariable(\"viewDirectionW\")) {\r\n                state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${\"v_\" + worldPos.associatedVariableName}.xyz);\\r\\n`;\r\n            }\r\n            state.compilationString += `lightingInfo info;\\r\\n`;\r\n            state.compilationString += `float shadow = 1.;\\r\\n`;\r\n            state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"};\\r\\n`;\r\n            state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n`;\r\n            state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\r\\n`;\r\n            state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\r\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() }\r\n                ]\r\n            });\r\n        } else {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\"\r\n            });\r\n        }\r\n\r\n        let diffuseOutput = this.diffuseOutput;\r\n        let specularOutput = this.specularOutput;\r\n\r\n        state.compilationString += this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\r\\n`;\r\n        if (specularOutput.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\r\\n`;\r\n        }\r\n\r\n        if (this.shadow.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(this.shadow, state) + ` = shadow;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightByID(serializationObject.lightId);\r\n        }\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.LightBlock\"] = LightBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}