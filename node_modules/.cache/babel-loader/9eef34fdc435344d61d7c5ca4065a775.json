{"ast":null,"code":"import { PointerDragBehavior } from \"./pointerDragBehavior\";\nimport { Vector3 } from \"../../Maths/math.vector\";\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\n\nvar MultiPointerScaleBehavior =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n   */\n  function MultiPointerScaleBehavior() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n\n  Object.defineProperty(MultiPointerScaleBehavior.prototype, \"name\", {\n    /**\r\n     *  The name of the behavior\r\n     */\n    get: function () {\n      return \"MultiPointerScale\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   *  Initializes the behavior\r\n   */\n\n  MultiPointerScaleBehavior.prototype.init = function () {};\n\n  MultiPointerScaleBehavior.prototype._getCurrentDistance = function () {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  };\n  /**\r\n   * Attaches the scale behavior the passed in mesh\r\n   * @param ownerNode The mesh that will be scaled around once attached\r\n   */\n\n\n  MultiPointerScaleBehavior.prototype.attach = function (ownerNode) {\n    var _this = this;\n\n    this._ownerNode = ownerNode; // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n\n    this._dragBehaviorA.onDragStartObservable.add(function (e) {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {\n          _this._dragBehaviorA.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    });\n\n    this._dragBehaviorB.onDragStartObservable.add(function (e) {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        if (_this._dragBehaviorA.currentDraggingPointerID == _this._dragBehaviorB.currentDraggingPointerID) {\n          _this._dragBehaviorB.releaseDrag();\n        } else {\n          _this._initialScale.copyFrom(ownerNode.scaling);\n\n          _this._startDistance = _this._getCurrentDistance();\n        }\n      }\n    }); // Once both drag behaviors are active scale based on the distance between the two pointers\n\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragObservable.add(function () {\n        if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n          var ratio = _this._getCurrentDistance() / _this._startDistance;\n\n          _this._initialScale.scaleToRef(ratio, _this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB); // On every frame move towards target scaling to avoid jitter caused by vr controllers\n\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {\n      if (_this._dragBehaviorA.dragging && _this._dragBehaviorB.dragging) {\n        var change = _this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  };\n  /**\r\n   *  Detaches the behavior from the mesh\r\n   */\n\n\n  MultiPointerScaleBehavior.prototype.detach = function () {\n    var _this = this;\n\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(function (behavior) {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n\n      _this._ownerNode.removeBehavior(behavior);\n    });\n  };\n\n  return MultiPointerScaleBehavior;\n}();\n\nexport { MultiPointerScaleBehavior };","map":{"version":3,"sources":["../../../../sourceES6/core/Behaviors/Meshes/multiPointerScaleBehavior.ts"],"names":[],"mappings":"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","sourcesContent":["import { Mesh } from \"../../Meshes/mesh\";\r\nimport { Behavior } from \"../behavior\";\r\nimport { PointerDragBehavior } from \"./pointerDragBehavior\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { Scene } from \"../../scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\r\nexport class MultiPointerScaleBehavior implements Behavior<Mesh> {\r\n    private _dragBehaviorA: PointerDragBehavior;\r\n    private _dragBehaviorB: PointerDragBehavior;\r\n    private _startDistance = 0;\r\n    private _initialScale = new Vector3(0, 0, 0);\r\n    private _targetScale = new Vector3(0, 0, 0);\r\n    private _ownerNode: Mesh;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n     */\r\n    constructor() {\r\n        this._dragBehaviorA = new PointerDragBehavior({});\r\n        this._dragBehaviorA.moveAttached = false;\r\n        this._dragBehaviorB = new PointerDragBehavior({});\r\n        this._dragBehaviorB.moveAttached = false;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"MultiPointerScale\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() { }\r\n\r\n    private _getCurrentDistance() {\r\n        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n\r\n        // Create 2 drag behaviors such that each will only be triggered by a separate pointer\r\n        this._dragBehaviorA.onDragStartObservable.add((e) => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerID == this._dragBehaviorB.currentDraggingPointerID) {\r\n                    this._dragBehaviorA.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n        this._dragBehaviorB.onDragStartObservable.add((e) => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerID == this._dragBehaviorB.currentDraggingPointerID) {\r\n                    this._dragBehaviorB.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Once both drag behaviors are active scale based on the distance between the two pointers\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragObservable.add(() => {\r\n                if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                    var ratio = this._getCurrentDistance() / this._startDistance;\r\n                    this._initialScale.scaleToRef(ratio, this._targetScale);\r\n                }\r\n            });\r\n        });\r\n\r\n        ownerNode.addBehavior(this._dragBehaviorA);\r\n        ownerNode.addBehavior(this._dragBehaviorB);\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                var change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\r\n                if (change.length() > 0.01) {\r\n                    ownerNode.scaling.addInPlace(change);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragStartObservable.clear();\r\n            behavior.onDragObservable.clear();\r\n            this._ownerNode.removeBehavior(behavior);\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}