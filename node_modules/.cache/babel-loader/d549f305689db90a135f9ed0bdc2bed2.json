{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Material } from \"../Materials/material\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { PostProcess } from \"./postProcess\";\nimport \"../Meshes/Builders/planeBuilder\";\nimport \"../Shaders/depth.vertex\";\nimport \"../Shaders/volumetricLightScattering.fragment\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\nimport { Color4, Color3 } from '../Maths/math.color';\nimport { Viewport } from '../Maths/math.viewport';\nimport { _TypeStore } from '../Misc/typeStore';\n/**\r\n *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\r\n */\n\nvar VolumetricLightScatteringPostProcess =\n/** @class */\nfunction (_super) {\n  __extends(VolumetricLightScatteringPostProcess, _super);\n  /**\r\n   * @constructor\r\n   * @param name The post-process name\r\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n   * @param camera The camera that the post-process will be attached to\r\n   * @param mesh The mesh used to create the light scattering\r\n   * @param samples The post-process quality, default 100\r\n   * @param samplingModeThe post-process filtering mode\r\n   * @param engine The babylon engine\r\n   * @param reusable If the post-process is reusable\r\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n   */\n\n\n  function VolumetricLightScatteringPostProcess(name, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {\n    if (samples === void 0) {\n      samples = 100;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    }\n\n    var _this = _super.call(this, name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples) || this;\n\n    _this._screenCoordinates = Vector2.Zero();\n    /**\r\n    * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n    */\n\n    _this.customMeshPosition = Vector3.Zero();\n    /**\r\n    * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n    */\n\n    _this.useCustomMeshPosition = false;\n    /**\r\n    * If the post-process should inverse the light scattering direction\r\n    */\n\n    _this.invert = true;\n    /**\r\n    * Array containing the excluded meshes not rendered in the internal pass\r\n    */\n\n    _this.excludedMeshes = new Array();\n    /**\r\n    * Controls the overall intensity of the post-process\r\n    */\n\n    _this.exposure = 0.3;\n    /**\r\n    * Dissipates each sample's contribution in range [0, 1]\r\n    */\n\n    _this.decay = 0.96815;\n    /**\r\n    * Controls the overall intensity of each sample\r\n    */\n\n    _this.weight = 0.58767;\n    /**\r\n    * Controls the density of each sample\r\n    */\n\n    _this.density = 0.926;\n    scene = camera === null ? scene : camera.getScene(); // parameter \"scene\" can be null.\n\n    engine = scene.getEngine();\n    _this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Configure mesh\n\n    _this.mesh = mesh !== null ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene); // Configure\n\n    _this._createPass(scene, ratio.passRatio || ratio);\n\n    _this.onActivate = function (camera) {\n      if (!_this.isSupported) {\n        _this.dispose(camera);\n      }\n\n      _this.onActivate = null;\n    };\n\n    _this.onApplyObservable.add(function (effect) {\n      _this._updateMeshScreenCoordinates(scene);\n\n      effect.setTexture(\"lightScatteringSampler\", _this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", _this.exposure);\n      effect.setFloat(\"decay\", _this.decay);\n      effect.setFloat(\"weight\", _this.weight);\n      effect.setFloat(\"density\", _this.density);\n      effect.setVector2(\"meshPositionOnScreen\", _this._screenCoordinates);\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(VolumetricLightScatteringPostProcess.prototype, \"useDiffuseColor\", {\n    /**\r\n     * @hidden\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\n    get: function () {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n      return false;\n    },\n    set: function (useDiffuseColor) {\n      Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n   * @returns \"VolumetricLightScatteringPostProcess\"\r\n   */\n\n  VolumetricLightScatteringPostProcess.prototype.getClassName = function () {\n    return \"VolumetricLightScatteringPostProcess\";\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._isReady = function (subMesh, useInstances) {\n    var mesh = subMesh.getMesh(); // Render this.mesh as default\n\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var material = subMesh.getMaterial(); // Alpha test\n\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      });\n    }\n\n    return this._volumetricLightScatteringPass.isReady();\n  };\n  /**\r\n   * Sets the new light position for light scattering effect\r\n   * @param position The new custom light position\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.setCustomMeshPosition = function (position) {\n    this.customMeshPosition = position;\n  };\n  /**\r\n   * Returns the light position for light scattering effect\r\n   * @return Vector3 The custom light position\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getCustomMeshPosition = function () {\n    return this.customMeshPosition;\n  };\n  /**\r\n   * Disposes the internal assets and detaches the post-process from the camera\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.dispose = function (camera) {\n    var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n\n    this._volumetricLightScatteringRTT.dispose();\n\n    _super.prototype.dispose.call(this, camera);\n  };\n  /**\r\n   * Returns the render target texture used by the post-process\r\n   * @return the render target texture used by the post-process\r\n   */\n\n\n  VolumetricLightScatteringPostProcess.prototype.getPass = function () {\n    return this._volumetricLightScatteringRTT;\n  }; // Private methods\n\n\n  VolumetricLightScatteringPostProcess.prototype._meshExcluded = function (mesh) {\n    if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._createPass = function (scene, ratio) {\n    var _this = this;\n\n    var engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    var camera = this.getCamera();\n\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } // Custom render function for submeshes\n\n\n    var renderSubMesh = function (subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n\n      if (_this._meshExcluded(renderingMesh)) {\n        return;\n      }\n\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        return;\n      }\n\n      var scene = renderingMesh.getScene();\n      var engine = scene.getEngine(); // Culling\n\n      engine.setState(material.backFaceCulling); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n\n      if (_this._isReady(subMesh, hardwareInstancedRendering)) {\n        var effect = _this._volumetricLightScatteringPass;\n\n        if (renderingMesh === _this.mesh) {\n          if (subMesh.effect) {\n            effect = subMesh.effect;\n          } else {\n            effect = material.getEffect();\n          }\n        }\n\n        engine.enableEffect(effect);\n\n        renderingMesh._bind(subMesh, effect, material.fillMode);\n\n        if (renderingMesh === _this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else {\n          _this._volumetricLightScatteringPass.setMatrix(\"viewProjection\", scene.getTransformMatrix()); // Alpha test\n\n\n          if (material && material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n\n            _this._volumetricLightScatteringPass.setTexture(\"diffuseSampler\", alphaTexture);\n\n            if (alphaTexture) {\n              _this._volumetricLightScatteringPass.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          } // Bones\n\n\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            _this._volumetricLightScatteringPass.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        } // Draw\n\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._volumetricLightScatteringPass, Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          return effect.setMatrix(\"world\", world);\n        });\n      }\n    }; // Render target texture callbacks\n\n\n    var savedSceneClearColor;\n    var sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {\n      scene.clearColor = savedSceneClearColor;\n    });\n\n    this._volumetricLightScatteringRTT.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var engine = scene.getEngine();\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          var submesh = transparentSubMeshes.data[index];\n          var boundingInfo = submesh.getBoundingInfo();\n\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n\n        var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort(function (a, b) {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          } // Then distance to camera\n\n\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n\n          return 0;\n        }); // Render sub meshes\n\n        engine.setAlphaMode(2);\n\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n\n        engine.setAlphaMode(0);\n      }\n    };\n  };\n\n  VolumetricLightScatteringPostProcess.prototype._updateMeshScreenCoordinates = function (scene) {\n    var transform = scene.getTransformMatrix();\n    var meshPosition;\n\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n\n    var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }; // Static methods\n\n  /**\r\n  * Creates a default mesh for the Volumeric Light Scattering post-process\r\n  * @param name The mesh name\r\n  * @param scene The scene where to create the mesh\r\n  * @return the default mesh\r\n  */\n\n\n  VolumetricLightScatteringPostProcess.CreateDefaultMesh = function (name, scene) {\n    var mesh = Mesh.CreatePlane(name, 1, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    var material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  };\n\n  __decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n\n  __decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n\n  __decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\n\n  return VolumetricLightScatteringPostProcess;\n}(PostProcess);\n\nexport { VolumetricLightScatteringPostProcess };\n_TypeStore.RegisteredTypes[\"BABYLON.VolumetricLightScatteringPostProcess\"] = VolumetricLightScatteringPostProcess;","map":{"version":3,"sources":["../../../sourceES6/core/PostProcesses/volumetricLightScatteringPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\n\r\nimport { Scene } from \"../scene\";\r\n\r\nimport \"../Meshes/Builders/planeBuilder\";\r\n\r\nimport \"../Shaders/depth.vertex\";\r\nimport \"../Shaders/volumetricLightScattering.fragment\";\r\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\r\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\r\nimport { Color4, Color3 } from '../Maths/math.color';\r\nimport { Viewport } from '../Maths/math.viewport';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n *  Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\r\n */\r\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\r\n    // Members\r\n    private _volumetricLightScatteringPass: Effect;\r\n    private _volumetricLightScatteringRTT: RenderTargetTexture;\r\n    private _viewPort: Viewport;\r\n    private _screenCoordinates: Vector2 = Vector2.Zero();\r\n    private _cachedDefines: string;\r\n\r\n    /**\r\n    * If not undefined, the mesh position is computed from the attached node position\r\n    */\r\n    public attachedNode: { position: Vector3 };\r\n\r\n    /**\r\n    * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n    */\r\n    @serializeAsVector3()\r\n    public customMeshPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n    * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n    */\r\n    @serialize()\r\n    public useCustomMeshPosition: boolean = false;\r\n\r\n    /**\r\n    * If the post-process should inverse the light scattering direction\r\n    */\r\n    @serialize()\r\n    public invert: boolean = true;\r\n\r\n    /**\r\n    * The internal mesh used by the post-process\r\n    */\r\n    @serializeAsMeshReference()\r\n    public mesh: Mesh;\r\n\r\n    /**\r\n     * @hidden\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\r\n    public get useDiffuseColor(): boolean {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n        return false;\r\n    }\r\n\r\n    public set useDiffuseColor(useDiffuseColor: boolean) {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n    }\r\n\r\n    /**\r\n    * Array containing the excluded meshes not rendered in the internal pass\r\n    */\r\n    @serialize()\r\n    public excludedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n    * Controls the overall intensity of the post-process\r\n    */\r\n    @serialize()\r\n    public exposure = 0.3;\r\n\r\n    /**\r\n    * Dissipates each sample's contribution in range [0, 1]\r\n    */\r\n    @serialize()\r\n    public decay = 0.96815;\r\n\r\n    /**\r\n    * Controls the overall intensity of each sample\r\n    */\r\n    @serialize()\r\n    public weight = 0.58767;\r\n\r\n    /**\r\n    * Controls the density of each sample\r\n    */\r\n    @serialize()\r\n    public density = 0.926;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The post-process name\r\n     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param camera The camera that the post-process will be attached to\r\n     * @param mesh The mesh used to create the light scattering\r\n     * @param samples The post-process quality, default 100\r\n     * @param samplingModeThe post-process filtering mode\r\n     * @param engine The babylon engine\r\n     * @param reusable If the post-process is reusable\r\n     * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n     */\r\n    constructor(name: string, ratio: any, camera: Camera, mesh?: Mesh, samples: number = 100, samplingMode: number = Texture.BILINEAR_SAMPLINGMODE, engine?: Engine, reusable?: boolean, scene?: Scene) {\r\n        super(name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples);\r\n        scene = <Scene>((camera === null) ? scene : camera.getScene()); // parameter \"scene\" can be null.\r\n\r\n        engine = scene.getEngine();\r\n        this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Configure mesh\r\n        this.mesh = (<Mesh>((mesh !== null) ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene)));\r\n\r\n        // Configure\r\n        this._createPass(scene, ratio.passRatio || ratio);\r\n\r\n        this.onActivate = (camera: Camera) => {\r\n            if (!this.isSupported) {\r\n                this.dispose(camera);\r\n            }\r\n\r\n            this.onActivate = null;\r\n        };\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this._updateMeshScreenCoordinates(<Scene>scene);\r\n\r\n            effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\r\n            effect.setFloat(\"exposure\", this.exposure);\r\n            effect.setFloat(\"decay\", this.decay);\r\n            effect.setFloat(\"weight\", this.weight);\r\n            effect.setFloat(\"density\", this.density);\r\n            effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n     * @returns \"VolumetricLightScatteringPostProcess\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VolumetricLightScatteringPostProcess\";\r\n    }\r\n\r\n    private _isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        var mesh = subMesh.getMesh();\r\n\r\n        // Render this.mesh as default\r\n        if (mesh === this.mesh && mesh.material) {\r\n            return mesh.material.isReady(mesh);\r\n        }\r\n\r\n        var defines = [];\r\n        var attribs = [VertexBuffer.PositionKind];\r\n        var material: any = subMesh.getMaterial();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n            }\r\n\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? (mesh.skeleton.bones.length + 1) : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect(\r\n                \"volumetricLightScatteringPass\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"],\r\n                [\"diffuseSampler\"],\r\n                join,\r\n                undefined, undefined, undefined,\r\n                { maxSimultaneousMorphTargets: mesh.numBoneInfluencers }\r\n            );\r\n        }\r\n\r\n        return this._volumetricLightScatteringPass.isReady();\r\n    }\r\n\r\n    /**\r\n     * Sets the new light position for light scattering effect\r\n     * @param position The new custom light position\r\n     */\r\n    public setCustomMeshPosition(position: Vector3): void {\r\n        this.customMeshPosition = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the light position for light scattering effect\r\n     * @return Vector3 The custom light position\r\n     */\r\n    public getCustomMeshPosition(): Vector3 {\r\n        return this.customMeshPosition;\r\n    }\r\n\r\n    /**\r\n     * Disposes the internal assets and detaches the post-process from the camera\r\n     */\r\n    public dispose(camera: Camera): void {\r\n        var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\r\n        if (rttIndex !== -1) {\r\n            camera.getScene().customRenderTargets.splice(rttIndex, 1);\r\n        }\r\n\r\n        this._volumetricLightScatteringRTT.dispose();\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Returns the render target texture used by the post-process\r\n     * @return the render target texture used by the post-process\r\n     */\r\n    public getPass(): RenderTargetTexture {\r\n        return this._volumetricLightScatteringRTT;\r\n    }\r\n\r\n    // Private methods\r\n    private _meshExcluded(mesh: AbstractMesh) {\r\n        if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _createPass(scene: Scene, ratio: number): void {\r\n        var engine = scene.getEngine();\r\n\r\n        this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio }, scene, false, true, 0);\r\n        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.renderList = null;\r\n        this._volumetricLightScatteringRTT.renderParticles = false;\r\n        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\r\n\r\n        var camera = this.getCamera();\r\n        if (camera) {\r\n            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        } else {\r\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        }\r\n\r\n        // Custom render function for submeshes\r\n        var renderSubMesh = (subMesh: SubMesh): void => {\r\n            var renderingMesh = subMesh.getRenderingMesh();\r\n            var effectiveMesh = subMesh.getEffectiveMesh();\r\n            if (this._meshExcluded(renderingMesh)) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            let material = subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            var scene = renderingMesh.getScene();\r\n            var engine = scene.getEngine();\r\n\r\n            // Culling\r\n            engine.setState(material.backFaceCulling);\r\n\r\n            // Managing instances\r\n            var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n            if (this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                var effect: Effect = this._volumetricLightScatteringPass;\r\n                if (renderingMesh === this.mesh) {\r\n                    if (subMesh.effect) {\r\n                        effect = subMesh.effect;\r\n                    } else {\r\n                        effect = <Effect>material.getEffect();\r\n                    }\r\n                }\r\n\r\n                engine.enableEffect(effect);\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n\r\n                if (renderingMesh === this.mesh) {\r\n                    material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\r\n                }\r\n                else {\r\n                    this._volumetricLightScatteringPass.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                    // Alpha test\r\n                    if (material && material.needAlphaTesting()) {\r\n                        var alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        this._volumetricLightScatteringPass.setTexture(\"diffuseSampler\", alphaTexture);\r\n\r\n                        if (alphaTexture) {\r\n                            this._volumetricLightScatteringPass.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        this._volumetricLightScatteringPass.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, this._volumetricLightScatteringPass, Material.TriangleFillMode, batch, hardwareInstancedRendering,\r\n                    (isInstance, world) => effect.setMatrix(\"world\", world));\r\n            }\r\n        };\r\n\r\n        // Render target texture callbacks\r\n        var savedSceneClearColor: Color4;\r\n        var sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\r\n\r\n        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((): void => {\r\n            savedSceneClearColor = scene.clearColor;\r\n            scene.clearColor = sceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.onAfterRenderObservable.add((): void => {\r\n            scene.clearColor = savedSceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.customRenderFunction = (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void => {\r\n            var engine = scene.getEngine();\r\n            var index: number;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (transparentSubMeshes.length) {\r\n                // Sort sub meshes\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    var submesh = transparentSubMeshes.data[index];\r\n                    let boundingInfo = submesh.getBoundingInfo();\r\n\r\n                    if (boundingInfo && scene.activeCamera) {\r\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\r\n                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\r\n                    }\r\n                }\r\n\r\n                var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\r\n                sortedArray.sort((a, b) => {\r\n                    // Alpha index first\r\n                    if (a._alphaIndex > b._alphaIndex) {\r\n                        return 1;\r\n                    }\r\n                    if (a._alphaIndex < b._alphaIndex) {\r\n                        return -1;\r\n                    }\r\n\r\n                    // Then distance to camera\r\n                    if (a._distanceToCamera < b._distanceToCamera) {\r\n                        return 1;\r\n                    }\r\n                    if (a._distanceToCamera > b._distanceToCamera) {\r\n                        return -1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n\r\n                // Render sub meshes\r\n                engine.setAlphaMode(2);\r\n                for (index = 0; index < sortedArray.length; index++) {\r\n                    renderSubMesh(sortedArray[index]);\r\n                }\r\n                engine.setAlphaMode(0);\r\n            }\r\n        };\r\n    }\r\n\r\n    private _updateMeshScreenCoordinates(scene: Scene): void {\r\n        var transform = scene.getTransformMatrix();\r\n        var meshPosition: Vector3;\r\n\r\n        if (this.useCustomMeshPosition) {\r\n            meshPosition = this.customMeshPosition;\r\n        }\r\n        else if (this.attachedNode) {\r\n            meshPosition = this.attachedNode.position;\r\n        }\r\n        else {\r\n            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\r\n        }\r\n\r\n        var pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\r\n\r\n        this._screenCoordinates.x = pos.x / this._viewPort.width;\r\n        this._screenCoordinates.y = pos.y / this._viewPort.height;\r\n\r\n        if (this.invert) {\r\n            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    // Static methods\r\n    /**\r\n    * Creates a default mesh for the Volumeric Light Scattering post-process\r\n    * @param name The mesh name\r\n    * @param scene The scene where to create the mesh\r\n    * @return the default mesh\r\n    */\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        var mesh = Mesh.CreatePlane(name, 1, scene);\r\n        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\r\n\r\n        var material = new StandardMaterial(name + \"Material\", scene);\r\n        material.emissiveColor = new Color3(1, 1, 1);\r\n\r\n        mesh.material = material;\r\n\r\n        return mesh;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.VolumetricLightScatteringPostProcess\"] = VolumetricLightScatteringPostProcess;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}