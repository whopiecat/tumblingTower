{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Tools } from \"../../Misc/tools\";\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar FreeCameraTouchInput =\n/** @class */\nfunction () {\n  /**\r\n   * Manage the touch inputs to control the movement of a free camera.\r\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n   * @param allowMouse Defines if mouse events can be treated as touch events\r\n   */\n  function FreeCameraTouchInput(\n  /**\r\n   * Define if mouse events can be treated as touch events\r\n   */\n  allowMouse) {\n    if (allowMouse === void 0) {\n      allowMouse = false;\n    }\n\n    this.allowMouse = allowMouse;\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\n\n    this.touchAngularSensibility = 200000.0;\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\n\n    this.touchMoveSensibility = 250.0;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._pointerPressed = new Array();\n  }\n  /**\r\n   * Attach the input controls to a specific dom element to get the input from.\r\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n   */\n\n\n  FreeCameraTouchInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    var previousPosition = null;\n\n    if (this._pointerInput === undefined) {\n      this._onLostFocus = function () {\n        _this._offsetX = null;\n        _this._offsetY = null;\n      };\n\n      this._pointerInput = function (p) {\n        var evt = p.event;\n        var isMouseEvent = !_this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\n\n        if (!_this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\n          return;\n        }\n\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          _this._pointerPressed.push(evt.pointerId);\n\n          if (_this._pointerPressed.length !== 1) {\n            return;\n          }\n\n          previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index === -1) {\n            return;\n          }\n\n          _this._pointerPressed.splice(index, 1);\n\n          if (index != 0) {\n            return;\n          }\n\n          previousPosition = null;\n          _this._offsetX = null;\n          _this._offsetY = null;\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n\n          if (!previousPosition) {\n            return;\n          }\n\n          var index = _this._pointerPressed.indexOf(evt.pointerId);\n\n          if (index != 0) {\n            return;\n          }\n\n          _this._offsetX = evt.clientX - previousPosition.x;\n          _this._offsetY = -(evt.clientY - previousPosition.y);\n        }\n      };\n    }\n\n    this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n\n    if (this._onLostFocus) {\n      var engine = this.camera.getEngine();\n      var element = engine.getInputElement();\n      element && element.addEventListener(\"blur\", this._onLostFocus);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FreeCameraTouchInput.prototype.detachControl = function (ignored) {\n    if (this._pointerInput) {\n      if (this._observer) {\n        this.camera.getScene().onPointerObservable.remove(this._observer);\n        this._observer = null;\n      }\n\n      if (this._onLostFocus) {\n        var engine = this.camera.getEngine();\n        var element = engine.getInputElement();\n        element && element.removeEventListener(\"blur\", this._onLostFocus);\n        this._onLostFocus = null;\n      }\n\n      this._pointerPressed = [];\n      this._offsetX = null;\n      this._offsetY = null;\n    }\n  };\n  /**\r\n   * Update the current camera state depending on the inputs that have been used this frame.\r\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n   */\n\n\n  FreeCameraTouchInput.prototype.checkInputs = function () {\n    if (this._offsetX === null || this._offsetY === null) {\n      return;\n    }\n\n    if (this._offsetX === 0 && this._offsetY === 0) {\n      return;\n    }\n\n    var camera = this.camera;\n    camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\n\n    if (this._pointerPressed.length > 1) {\n      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n    } else {\n      var speed = camera._computeLocalCameraSpeed();\n\n      var direction = new Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);\n      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n    }\n  };\n  /**\r\n   * Gets the class name of the current intput.\r\n   * @returns the class name\r\n   */\n\n\n  FreeCameraTouchInput.prototype.getClassName = function () {\n    return \"FreeCameraTouchInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input friendly name\r\n   */\n\n\n  FreeCameraTouchInput.prototype.getSimpleName = function () {\n    return \"touch\";\n  };\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n\n  __decorate([serialize()], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\n\n  return FreeCameraTouchInput;\n}();\n\nexport { FreeCameraTouchInput };\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;","map":{"version":3,"sources":["../../../../sourceES6/core/Cameras/Inputs/freeCameraTouchInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../../Misc/decorators\";\r\nimport { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { ICameraInput, CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { PointerInfo, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The higher the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The higher the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        var previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                var evt = <PointerEvent>p.event;\r\n\r\n                let isMouseEvent = !this.camera.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;\r\n                if (!this.allowMouse && (evt.pointerType === \"mouse\" || isMouseEvent)) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    var index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    var index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored?: any): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene().onPointerObservable.remove(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed = [];\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        var camera = this.camera;\r\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\r\n\r\n        if (this._pointerPressed.length > 1) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            var speed = camera._computeLocalCameraSpeed();\r\n            var direction = new Vector3(0, 0, (speed * this._offsetY) / this.touchMoveSensibility);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current intput.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}