{"ast":null,"code":"import { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateTiledBox = function (options) {\n  var nbFaces = 6;\n  var faceUV = options.faceUV || new Array(6);\n  var faceColors = options.faceColors;\n  var flipTile = options.pattern || Mesh.NO_FLIP;\n  var width = options.width || options.size || 1;\n  var height = options.height || options.size || 1;\n  var depth = options.depth || options.size || 1;\n  var tileWidth = options.tileWidth || options.tileSize || 1;\n  var tileHeight = options.tileHeight || options.tileSize || 1;\n  var alignH = options.alignHorizontal || 0;\n  var alignV = options.alignVertical || 0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // default face colors and UV if undefined\n\n  for (var f = 0; f < nbFaces; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var halfDepth = depth / 2;\n  var faceVertexData = [];\n\n  for (var f = 0; f < 2; f++) {\n    //front and back\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  for (var f = 2; f < 4; f++) {\n    //sides\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: depth,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var baseAlignV = alignV;\n\n  if (alignV === Mesh.BOTTOM) {\n    baseAlignV = Mesh.TOP;\n  } else if (alignV === Mesh.TOP) {\n    baseAlignV = Mesh.BOTTOM;\n  }\n\n  for (var f = 4; f < 6; f++) {\n    //top and bottom\n    faceVertexData[f] = VertexData.CreateTiledPlane({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: depth,\n      alignVertical: baseAlignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n\n  var positions = [];\n  var normals = [];\n  var uvs = [];\n  var indices = [];\n  var colors = [];\n  var facePositions = [];\n  var faceNormals = [];\n  var newFaceUV = [];\n  var len = 0;\n  var lu = 0;\n  var li = 0;\n\n  for (var f = 0; f < nbFaces; f++) {\n    var len = faceVertexData[f].positions.length;\n    facePositions[f] = [];\n    faceNormals[f] = [];\n\n    for (var p = 0; p < len / 3; p++) {\n      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n    } // uvs\n\n\n    lu = faceVertexData[f].uvs.length;\n    newFaceUV[f] = [];\n\n    for (var i = 0; i < lu; i += 2) {\n      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n    }\n\n    uvs = uvs.concat(newFaceUV[f]);\n    indices = indices.concat(faceVertexData[f].indices.map(function (x) {\n      return x + li;\n    }));\n    li += facePositions[f].length;\n\n    if (faceColors) {\n      for (var c = 0; c < 4; c++) {\n        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n      }\n    }\n  }\n\n  var vec0 = new Vector3(0, 0, halfDepth);\n  var mtrx0 = Matrix.RotationY(Math.PI);\n  positions = facePositions[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0).add(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  normals = faceNormals[0].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []);\n  positions = positions.concat(facePositions[1].map(function (entry) {\n    return entry.subtract(vec0);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[1].map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec2 = new Vector3(halfWidth, 0, 0);\n  var mtrx2 = Matrix.RotationY(-Math.PI / 2);\n  positions = positions.concat(facePositions[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2).add(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[2].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx3 = Matrix.RotationY(Math.PI / 2);\n  positions = positions.concat(facePositions[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3).subtract(vec2);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[3].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx3);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var vec4 = new Vector3(0, halfHeight, 0);\n  var mtrx4 = Matrix.RotationX(Math.PI / 2);\n  positions = positions.concat(facePositions[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4).add(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[4].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  var mtrx5 = Matrix.RotationX(-Math.PI / 2);\n  positions = positions.concat(facePositions[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5).subtract(vec4);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, []));\n  normals = normals.concat(faceNormals[5].map(function (entry) {\n    return Vector3.TransformNormal(entry, mtrx5);\n  }).map(function (entry) {\n    return [entry.x, entry.y, entry.z];\n  }).reduce(function (accumulator, currentValue) {\n    return accumulator.concat(currentValue);\n  }, [])); // sides\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs); // Result\n\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n\n  return vertexData;\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TiledBoxBuilder =\n/** @class */\nfunction () {\n  function TiledBoxBuilder() {}\n  /**\r\n   * Creates a box mesh\r\n   * faceTiles sets the pattern, tile size and number of tiles for a face     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n   * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the box mesh\r\n   */\n\n\n  TiledBoxBuilder.CreateTiledBox = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateTiledBox(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n  };\n\n  return TiledBoxBuilder;\n}();\n\nexport { TiledBoxBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/tiledBoxBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\nVertexData.CreateTiledBox = function(options: { pattern?: number, size?: number, width?: number, height?: number, depth: number, tileSize?: number, tileWidth?: number, tileHeight?: number, faceUV?: Vector4[], faceColors?: Color4[], alignHorizontal?: number, alignVertical?: number, sideOrientation?: number }): VertexData {\r\n    var nbFaces = 6;\r\n\r\n    var faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    var faceColors = options.faceColors;\r\n\r\n    var flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var depth = options.depth || options.size || 1;\r\n    var tileWidth = options.tileWidth || options.tileSize || 1;\r\n    var tileHeight = options.tileHeight || options.tileSize || 1;\r\n    var alignH = options.alignHorizontal || 0;\r\n    var alignV = options.alignVertical || 0;\r\n\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    var halfWidth = width / 2;\r\n    var halfHeight = height / 2;\r\n    var halfDepth = depth / 2;\r\n\r\n    var faceVertexData: Array<VertexData> = [];\r\n\r\n    for (var f = 0; f < 2; f++) { //front and back\r\n        faceVertexData[f] = VertexData.CreateTiledPlane({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation\r\n        });\r\n    }\r\n\r\n    for (var f = 2; f < 4; f++) { //sides\r\n        faceVertexData[f] = VertexData.CreateTiledPlane({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation\r\n        });\r\n    }\r\n\r\n    var baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    }\r\n    else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (var f = 4; f < 6; f++) { //top and bottom\r\n        faceVertexData[f] = VertexData.CreateTiledPlane({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation\r\n        });\r\n    }\r\n\r\n    var positions: Array<number> = [];\r\n    var normals: Array<number> = [];\r\n    var uvs: Array<number> = [];\r\n    var indices: Array<number> = [];\r\n    var colors: Array<number> = [];\r\n    var facePositions: Array<Array<Vector3>> = [];\r\n    var faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    var newFaceUV: Array<Array<number>> = [];\r\n    var len: number = 0;\r\n    var lu: number = 0;\r\n\r\n    var li: number = 0;\r\n\r\n    for (var f = 0; f < nbFaces; f++) {\r\n        var len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (var p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (var i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (var c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    var vec0 = new Vector3(0, 0, halfDepth);\r\n    var mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0].map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    );\r\n    normals = faceNormals[0].map((entry) => Vector3.TransformNormal(entry, mtrx0)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    );\r\n    positions = positions.concat(facePositions[1].map((entry) => entry.subtract(vec0)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n\r\n    var vec2 = new Vector3(halfWidth, 0, 0);\r\n    var mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(facePositions[2].map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    normals = normals.concat(faceNormals[2].map((entry) => Vector3.TransformNormal(entry, mtrx2)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    var mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(facePositions[3].map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    normals = normals.concat(faceNormals[3].map((entry) => Vector3.TransformNormal(entry, mtrx3)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n\r\n    var vec4 = new Vector3(0, halfHeight, 0);\r\n    var mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(facePositions[4].map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    normals = normals.concat(faceNormals[4].map((entry) => Vector3.TransformNormal(entry, mtrx4)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    var mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(facePositions[5].map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n    normals = normals.concat(faceNormals[5].map((entry) => Vector3.TransformNormal(entry, mtrx5)).map((entry) => [entry.x, entry.y, entry.z]).reduce(\r\n        (accumulator: Array<number>, currentValue) => accumulator.concat(currentValue),\r\n        []\r\n    ));\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TiledBoxBuilder {\r\n    /**\r\n     * Creates a box mesh\r\n     * faceTiles sets the pattern, tile size and number of tiles for a face     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    public static CreateTiledBox(name: string, options: { pattern?: number, width?: number, height?: number, depth?: number, tileSize?: number, tileWidth?: number, tileHeight?: number, alignHorizontal?: number, alignVertical?: number, faceUV?: Vector4[], faceColors?: Color4[], sideOrientation?: number, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var box = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateTiledBox(options);\r\n\r\n        vertexData.applyToMesh(box, options.updatable);\r\n\r\n        return box;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}