{"ast":null,"code":"import { ShadowGenerator } from \"./shadowGenerator\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\nimport { SceneComponentConstants } from \"../../sceneComponent\";\nimport { AbstractScene } from \"../../abstractScene\"; // Adds the parser to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, function (parsedData, scene) {\n  // Shadows\n  if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n    for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n      var parsedShadowGenerator = parsedData.shadowGenerators[index];\n\n      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } else {\n        ShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } // SG would be available on their associated lights\n\n    }\n  }\n});\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\n\nvar ShadowGeneratorSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function ShadowGeneratorSceneComponent(scene) {\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n    this.scene = scene;\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.register = function () {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.rebuild = function () {// Nothing To Do Here.\n  };\n  /**\r\n   * Serializes the component data to the specified json object\r\n   * @param serializationObject The object to serialize to\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.serialize = function (serializationObject) {\n    // Shadows\n    serializationObject.shadowGenerators = [];\n    var lights = this.scene.lights;\n\n    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {\n      var light = lights_1[_i];\n      var shadowGenerator = light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n      }\n    }\n  };\n  /**\r\n   * Adds all the elements from the container to the scene\r\n   * @param container the container holding the elements\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.addFromContainer = function (container) {// Nothing To Do Here. (directly attached to a light)\n  };\n  /**\r\n   * Removes all the elements in the container from the scene\r\n   * @param container contains the elements to remove\r\n   * @param dispose if the removed element should be disposed (default: false)\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.removeFromContainer = function (container, dispose) {// Nothing To Do Here. (directly attached to a light)\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  ShadowGeneratorSceneComponent.prototype.dispose = function () {// Nothing To Do Here.\n  };\n\n  ShadowGeneratorSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {\n    // Shadows\n    var scene = this.scene;\n\n    if (this.scene.shadowsEnabled) {\n      for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n        var light = scene.lights[lightIndex];\n        var shadowGenerator = light.getShadowGenerator();\n\n        if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {\n          var shadowMap = shadowGenerator.getShadowMap();\n\n          if (scene.textures.indexOf(shadowMap) !== -1) {\n            renderTargets.push(shadowMap);\n          }\n        }\n      }\n    }\n  };\n\n  return ShadowGeneratorSceneComponent;\n}();\n\nexport { ShadowGeneratorSceneComponent };\n\nShadowGenerator._SceneComponentInitialization = function (scene) {\n  var component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n\n  if (!component) {\n    component = new ShadowGeneratorSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Lights/Shadows/shadowGeneratorSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport { Scene } from \"../../scene\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport { SceneComponentConstants, ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            var parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        var lights = this.scene.lights;\r\n        for (let light of lights) {\r\n            let shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        var scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                var light = scene.lights[lightIndex];\r\n                var shadowGenerator = light.getShadowGenerator();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {\r\n                    var shadowMap = <RenderTargetTexture>(shadowGenerator.getShadowMap());\r\n                    if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                        renderTargets.push(shadowMap);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}