{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\nimport { RibbonBuilder } from \"./ribbonBuilder\";\nimport { Path3D } from '../../Maths/math.path';\n\nMesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\n  var options = {\n    path: path,\n    radius: radius,\n    tessellation: tessellation,\n    radiusFunction: radiusFunction,\n    arc: 1,\n    cap: cap,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  };\n  return TubeBuilder.CreateTube(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar TubeBuilder =\n/** @class */\nfunction () {\n  function TubeBuilder() {}\n  /**\r\n   * Creates a tube mesh.\r\n   * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n   * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n   * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n   * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n   * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n   * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n   * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n   * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n   * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the tube mesh\r\n   * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n   */\n\n\n  TubeBuilder.CreateTube = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var path = options.path;\n    var instance = options.instance;\n    var radius = 1.0;\n\n    if (options.radius !== undefined) {\n      radius = options.radius;\n    } else if (instance) {\n      radius = instance._creationDataStorage.radius;\n    }\n\n    var tessellation = options.tessellation || 64 | 0;\n    var radiusFunction = options.radiusFunction || null;\n    var cap = options.cap || Mesh.NO_CAP;\n    var invertUV = options.invertUV || false;\n    var updatable = options.updatable;\n\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0; // tube geometry\n\n    var tubePathArray = function (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\n      var tangents = path3D.getTangents();\n      var normals = path3D.getNormals();\n      var distances = path3D.getDistances();\n      var pi2 = Math.PI * 2;\n      var step = pi2 / tessellation * arc;\n\n      var returnRadius = function () {\n        return radius;\n      };\n\n      var radiusFunctionFinal = radiusFunction || returnRadius;\n      var circlePath;\n      var rad;\n      var normal;\n      var rotated;\n      var rotationMatrix = TmpVectors.Matrix[0];\n      var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n\n      for (var i = 0; i < path.length; i++) {\n        rad = radiusFunctionFinal(i, distances[i]); // current radius\n\n        circlePath = Array(); // current circle array\n\n        normal = normals[i]; // current normal\n\n        for (var t = 0; t < tessellation; t++) {\n          Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n          rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n          Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n          rotated.scaleInPlace(rad).addInPlace(path[i]);\n          circlePath[t] = rotated;\n        }\n\n        circlePaths[index] = circlePath;\n        index++;\n      } // cap\n\n\n      var capPath = function (nbPoints, pathIndex) {\n        var pointCap = Array();\n\n        for (var i = 0; i < nbPoints; i++) {\n          pointCap.push(path[pathIndex]);\n        }\n\n        return pointCap;\n      };\n\n      switch (cap) {\n        case Mesh.NO_CAP:\n          break;\n\n        case Mesh.CAP_START:\n          circlePaths[0] = capPath(tessellation, 0);\n          circlePaths[1] = circlePaths[2].slice(0);\n          break;\n\n        case Mesh.CAP_END:\n          circlePaths[index] = circlePaths[index - 1].slice(0);\n          circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n          break;\n\n        case Mesh.CAP_ALL:\n          circlePaths[0] = capPath(tessellation, 0);\n          circlePaths[1] = circlePaths[2].slice(0);\n          circlePaths[index] = circlePaths[index - 1].slice(0);\n          circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n          break;\n\n        default:\n          break;\n      }\n\n      return circlePaths;\n    };\n\n    var path3D;\n    var pathArray;\n\n    if (instance) {\n      // tube update\n      var storage = instance._creationDataStorage;\n      var arc = options.arc || storage.arc;\n      path3D = storage.path3D.update(path);\n      pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n      instance = RibbonBuilder.CreateRibbon(\"\", {\n        pathArray: pathArray,\n        instance: instance\n      }); // Update mode, no need to recreate the storage.\n\n      storage.path3D = path3D;\n      storage.pathArray = pathArray;\n      storage.arc = arc;\n      storage.radius = radius;\n      return instance;\n    } // tube creation\n\n\n    path3D = new Path3D(path);\n    var newPathArray = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n    var tube = RibbonBuilder.CreateRibbon(name, {\n      pathArray: pathArray,\n      closePath: true,\n      closeArray: false,\n      updatable: updatable,\n      sideOrientation: sideOrientation,\n      invertUV: invertUV,\n      frontUVs: options.frontUVs,\n      backUVs: options.backUVs\n    }, scene);\n    tube._creationDataStorage.pathArray = pathArray;\n    tube._creationDataStorage.path3D = path3D;\n    tube._creationDataStorage.tessellation = tessellation;\n    tube._creationDataStorage.cap = cap;\n    tube._creationDataStorage.arc = options.arc;\n    tube._creationDataStorage.radius = radius;\n    return tube;\n  };\n\n  return TubeBuilder;\n}();\n\nexport { TubeBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/tubeBuilder.ts"],"names":[],"mappings":"AAEA,SAAS,OAAT,EAAkB,UAAlB,EAAuC,MAAvC,QAAqD,yBAArD;AACA,SAAS,IAAT,QAA2C,SAA3C;AACA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,MAAT,QAAuB,uBAAvB;;AAEA,IAAI,CAAC,UAAL,GAAkB,UAAC,IAAD,EAAe,IAAf,EAAgC,MAAhC,EAAgD,YAAhD,EAAsE,cAAtE,EAAkI,GAAlI,EAA+I,KAA/I,EAA6J,SAA7J,EAAkL,eAAlL,EAA4M,QAA5M,EAA2N;AACzO,MAAI,OAAO,GAAG;AACV,IAAA,IAAI,EAAE,IADI;AAEV,IAAA,MAAM,EAAE,MAFE;AAGV,IAAA,YAAY,EAAE,YAHJ;AAIV,IAAA,cAAc,EAAE,cAJN;AAKV,IAAA,GAAG,EAAE,CALK;AAMV,IAAA,GAAG,EAAE,GANK;AAOV,IAAA,SAAS,EAAE,SAPD;AAQV,IAAA,eAAe,EAAE,eARP;AASV,IAAA,QAAQ,EAAE;AATA,GAAd;AAWA,SAAO,WAAW,CAAC,UAAZ,CAAuB,IAAvB,EAA6B,OAA7B,EAAsC,KAAtC,CAAP;AACH,CAbD;AAeA;;;;;AAGA,IAAA,WAAA;AAAA;AAAA,YAAA;AAAA,WAAA,WAAA,GAAA,CAwIC;AAvIG;;;;;;;;;;;;;;;;;;;;;;;;AAsBc,EAAA,WAAA,CAAA,UAAA,GAAd,UAAyB,IAAzB,EAAuC,OAAvC,EAAiU,KAAjU,EAA8V;AAA7B,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA6B;;AAC1V,QAAI,IAAI,GAAG,OAAO,CAAC,IAAnB;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,QAAvB;AACA,QAAI,MAAM,GAAG,GAAb;;AAEA,QAAI,OAAO,CAAC,MAAR,KAAmB,SAAvB,EAAkC;AAC9B,MAAA,MAAM,GAAG,OAAO,CAAC,MAAjB;AACH,KAFD,MAEO,IAAI,QAAJ,EAAc;AACjB,MAAA,MAAM,GAAG,QAAQ,CAAC,oBAAT,CAA+B,MAAxC;AACH;;AAED,QAAI,YAAY,GAAG,OAAO,CAAC,YAAR,IAAwB,KAAK,CAAhD;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,cAAR,IAA0B,IAA/C;AACA,QAAI,GAAG,GAAG,OAAO,CAAC,GAAR,IAAe,IAAI,CAAC,MAA9B;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,QAAR,IAAoB,KAAnC;AACA,QAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;;AACA,QAAI,eAAe,GAAG,IAAI,CAAC,0BAAL,CAAgC,OAAO,CAAC,eAAxC,CAAtB;;AACA,IAAA,OAAO,CAAC,GAAR,GAAc,OAAO,CAAC,GAAR,KAAgB,OAAO,CAAC,GAAR,IAAe,GAAf,IAAsB,OAAO,CAAC,GAAR,GAAc,GAApD,IAA2D,GAA3D,GAAiE,OAAO,CAAC,GAAR,IAAe,GAA9F,CAjB0V,CAmB1V;;AACA,QAAI,aAAa,GAAG,UAAC,IAAD,EAAkB,MAAlB,EAAkC,WAAlC,EAA4D,MAA5D,EAA4E,YAA5E,EAChB,cADgB,EACsD,GADtD,EACmE,GADnE,EAC8E;AAC9F,UAAI,QAAQ,GAAG,MAAM,CAAC,WAAP,EAAf;AACA,UAAI,OAAO,GAAG,MAAM,CAAC,UAAP,EAAd;AACA,UAAI,SAAS,GAAG,MAAM,CAAC,YAAP,EAAhB;AACA,UAAI,GAAG,GAAG,IAAI,CAAC,EAAL,GAAU,CAApB;AACA,UAAI,IAAI,GAAG,GAAG,GAAG,YAAN,GAAqB,GAAhC;;AACA,UAAI,YAAY,GAA+C,YAAA;AAAM,eAAA,MAAA;AAAM,OAA3E;;AACA,UAAI,mBAAmB,GAA+C,cAAc,IAAI,YAAxF;AAEA,UAAI,UAAJ;AACA,UAAI,GAAJ;AACA,UAAI,MAAJ;AACA,UAAI,OAAJ;AACA,UAAI,cAAc,GAAW,UAAU,CAAC,MAAX,CAAkB,CAAlB,CAA7B;AACA,UAAI,KAAK,GAAI,GAAG,KAAK,IAAI,CAAC,MAAb,IAAuB,GAAG,KAAK,IAAI,CAAC,OAArC,GAAgD,CAAhD,GAAoD,CAAhE;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,QAAA,GAAG,GAAG,mBAAmB,CAAC,CAAD,EAAI,SAAS,CAAC,CAAD,CAAb,CAAzB,CADkC,CACU;;AAC5C,QAAA,UAAU,GAAG,KAAK,EAAlB,CAFkC,CAEU;;AAC5C,QAAA,MAAM,GAAG,OAAO,CAAC,CAAD,CAAhB,CAHkC,CAGU;;AAC5C,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAApB,EAAkC,CAAC,EAAnC,EAAuC;AACnC,UAAA,MAAM,CAAC,iBAAP,CAAyB,QAAQ,CAAC,CAAD,CAAjC,EAAsC,IAAI,GAAG,CAA7C,EAAgD,cAAhD;AACA,UAAA,OAAO,GAAG,UAAU,CAAC,CAAD,CAAV,GAAgB,UAAU,CAAC,CAAD,CAA1B,GAAgC,OAAO,CAAC,IAAR,EAA1C;AACA,UAAA,OAAO,CAAC,yBAAR,CAAkC,MAAlC,EAA0C,cAA1C,EAA0D,OAA1D;AACA,UAAA,OAAO,CAAC,YAAR,CAAqB,GAArB,EAA0B,UAA1B,CAAqC,IAAI,CAAC,CAAD,CAAzC;AACA,UAAA,UAAU,CAAC,CAAD,CAAV,GAAgB,OAAhB;AACH;;AACD,QAAA,WAAW,CAAC,KAAD,CAAX,GAAqB,UAArB;AACA,QAAA,KAAK;AACR,OA5B6F,CA6B9F;;;AACA,UAAI,OAAO,GAAG,UAAC,QAAD,EAAmB,SAAnB,EAAoC;AAC9C,YAAI,QAAQ,GAAG,KAAK,EAApB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAApB,EAA8B,CAAC,EAA/B,EAAmC;AAC/B,UAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,SAAD,CAAlB;AACH;;AACD,eAAO,QAAP;AACH,OAND;;AAOA,cAAQ,GAAR;AACI,aAAK,IAAI,CAAC,MAAV;AACI;;AACJ,aAAK,IAAI,CAAC,SAAV;AACI,UAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,OAAO,CAAC,YAAD,EAAe,CAAf,CAAxB;AACA,UAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,WAAW,CAAC,CAAD,CAAX,CAAe,KAAf,CAAqB,CAArB,CAAjB;AACA;;AACJ,aAAK,IAAI,CAAC,OAAV;AACI,UAAA,WAAW,CAAC,KAAD,CAAX,GAAqB,WAAW,CAAC,KAAK,GAAG,CAAT,CAAX,CAAuB,KAAvB,CAA6B,CAA7B,CAArB;AACA,UAAA,WAAW,CAAC,KAAK,GAAG,CAAT,CAAX,GAAyB,OAAO,CAAC,YAAD,EAAe,IAAI,CAAC,MAAL,GAAc,CAA7B,CAAhC;AACA;;AACJ,aAAK,IAAI,CAAC,OAAV;AACI,UAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,OAAO,CAAC,YAAD,EAAe,CAAf,CAAxB;AACA,UAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,WAAW,CAAC,CAAD,CAAX,CAAe,KAAf,CAAqB,CAArB,CAAjB;AACA,UAAA,WAAW,CAAC,KAAD,CAAX,GAAqB,WAAW,CAAC,KAAK,GAAG,CAAT,CAAX,CAAuB,KAAvB,CAA6B,CAA7B,CAArB;AACA,UAAA,WAAW,CAAC,KAAK,GAAG,CAAT,CAAX,GAAyB,OAAO,CAAC,YAAD,EAAe,IAAI,CAAC,MAAL,GAAc,CAA7B,CAAhC;AACA;;AACJ;AACI;AAlBR;;AAoBA,aAAO,WAAP;AACH,KA3DD;;AA6DA,QAAI,MAAJ;AACA,QAAI,SAAJ;;AACA,QAAI,QAAJ,EAAc;AAAE;AACZ,UAAI,OAAO,GAAG,QAAQ,CAAC,oBAAvB;AACA,UAAI,GAAG,GAAG,OAAO,CAAC,GAAR,IAAe,OAAO,CAAC,GAAjC;AACA,MAAA,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,MAAf,CAAsB,IAAtB,CAAT;AACA,MAAA,SAAS,GAAG,aAAa,CAAC,IAAD,EAAO,MAAP,EAAe,OAAO,CAAC,SAAvB,EAAkC,MAAlC,EAA0C,OAAO,CAAC,YAAlD,EAAgE,cAAhE,EAAgF,OAAO,CAAC,GAAxF,EAA6F,GAA7F,CAAzB;AACA,MAAA,QAAQ,GAAG,aAAa,CAAC,YAAd,CAA2B,EAA3B,EAA+B;AAAE,QAAA,SAAS,EAAE,SAAb;AAAwB,QAAA,QAAQ,EAAE;AAAlC,OAA/B,CAAX,CALU,CAMV;;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAjB;AACA,MAAA,OAAO,CAAC,SAAR,GAAoB,SAApB;AACA,MAAA,OAAO,CAAC,GAAR,GAAc,GAAd;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,MAAjB;AAEA,aAAO,QAAP;AACH,KAhGyV,CAkG1V;;;AACA,IAAA,MAAM,GAAQ,IAAI,MAAJ,CAAW,IAAX,CAAd;AACA,QAAI,YAAY,GAAG,IAAI,KAAJ,EAAnB;AACA,IAAA,GAAG,GAAI,GAAG,GAAG,CAAN,IAAW,GAAG,GAAG,CAAlB,GAAuB,CAAvB,GAA2B,GAAjC;AACA,IAAA,SAAS,GAAG,aAAa,CAAC,IAAD,EAAO,MAAP,EAAe,YAAf,EAA6B,MAA7B,EAAqC,YAArC,EAAmD,cAAnD,EAAmE,GAAnE,EAAwE,OAAO,CAAC,GAAhF,CAAzB;AACA,QAAI,IAAI,GAAG,aAAa,CAAC,YAAd,CAA2B,IAA3B,EAAiC;AAAE,MAAA,SAAS,EAAE,SAAb;AAAwB,MAAA,SAAS,EAAE,IAAnC;AAAyC,MAAA,UAAU,EAAE,KAArD;AAA4D,MAAA,SAAS,EAAE,SAAvE;AAAkF,MAAA,eAAe,EAAE,eAAnG;AAAoH,MAAA,QAAQ,EAAE,QAA9H;AAAwI,MAAA,QAAQ,EAAE,OAAO,CAAC,QAA1J;AAAoK,MAAA,OAAO,EAAE,OAAO,CAAC;AAArL,KAAjC,EAAiO,KAAjO,CAAX;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,SAA3B,GAAuC,SAAvC;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,MAA3B,GAAoC,MAApC;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,YAA3B,GAA0C,YAA1C;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,GAA3B,GAAiC,GAAjC;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,GAA3B,GAAiC,OAAO,CAAC,GAAzC;AACA,IAAA,IAAI,CAAC,oBAAL,CAA2B,MAA3B,GAAoC,MAApC;AAEA,WAAO,IAAP;AACH,GAhHa;;AAiHlB,SAAA,WAAA;AAAC,CAxID,EAAA","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3, TmpVectors, Vector4, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { RibbonBuilder } from \"./ribbonBuilder\";\r\nimport { Path3D } from '../../Maths/math.path';\r\n\r\nMesh.CreateTube = (name: string, path: Vector3[], radius: number, tessellation: number, radiusFunction: { (i: number, distance: number): number; }, cap: number, scene: Scene, updatable?: boolean, sideOrientation?: number, instance?: Mesh): Mesh => {\r\n    var options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    };\r\n    return TubeBuilder.CreateTube(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class TubeBuilder {\r\n    /**\r\n     * Creates a tube mesh.\r\n     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n     * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tube mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n     */\r\n    public static CreateTube(name: string, options: { path: Vector3[], radius?: number, tessellation?: number, radiusFunction?: { (i: number, distance: number): number; }, cap?: number, arc?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, instance?: Mesh, invertUV?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var path = options.path;\r\n        var instance = options.instance;\r\n        var radius = 1.0;\r\n\r\n        if (options.radius !== undefined) {\r\n            radius = options.radius;\r\n        } else if (instance) {\r\n            radius = instance._creationDataStorage!.radius;\r\n        }\r\n\r\n        var tessellation = options.tessellation || 64 | 0;\r\n        var radiusFunction = options.radiusFunction || null;\r\n        var cap = options.cap || Mesh.NO_CAP;\r\n        var invertUV = options.invertUV || false;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n        // tube geometry\r\n        var tubePathArray = (path: Vector3[], path3D: Path3D, circlePaths: Vector3[][], radius: number, tessellation: number,\r\n            radiusFunction: Nullable<{ (i: number, distance: number): number; }>, cap: number, arc: number) => {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var distances = path3D.getDistances();\r\n            var pi2 = Math.PI * 2;\r\n            var step = pi2 / tessellation * arc;\r\n            var returnRadius: { (i: number, distance: number): number; } = () => radius;\r\n            var radiusFunctionFinal: { (i: number, distance: number): number; } = radiusFunction || returnRadius;\r\n\r\n            var circlePath: Vector3[];\r\n            var rad: number;\r\n            var normal: Vector3;\r\n            var rotated: Vector3;\r\n            var rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n            var index = (cap === Mesh.NO_CAP || cap === Mesh.CAP_END) ? 0 : 2;\r\n            for (var i = 0; i < path.length; i++) {\r\n                rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n                circlePath = Array<Vector3>();              // current circle array\r\n                normal = normals[i];                        // current normal\r\n                for (var t = 0; t < tessellation; t++) {\r\n                    Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                    rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                    Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                    circlePath[t] = rotated;\r\n                }\r\n                circlePaths[index] = circlePath;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n                var pointCap = Array<Vector3>();\r\n                for (var i = 0; i < nbPoints; i++) {\r\n                    pointCap.push(path[pathIndex]);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case Mesh.NO_CAP:\r\n                    break;\r\n                case Mesh.CAP_START:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    break;\r\n                case Mesh.CAP_END:\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                case Mesh.CAP_ALL:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return circlePaths;\r\n        };\r\n\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // tube update\r\n            let storage = instance._creationDataStorage!;\r\n            var arc = options.arc || storage.arc;\r\n            path3D = storage.path3D.update(path);\r\n            pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n            instance = RibbonBuilder.CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n            // Update mode, no need to recreate the storage.\r\n            storage.path3D = path3D;\r\n            storage.pathArray = pathArray;\r\n            storage.arc = arc;\r\n            storage.radius = radius;\r\n\r\n            return instance;\r\n        }\r\n\r\n        // tube creation\r\n        path3D = <any>new Path3D(path);\r\n        var newPathArray = new Array<Array<Vector3>>();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n        var tube = RibbonBuilder.CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\r\n        tube._creationDataStorage!.pathArray = pathArray;\r\n        tube._creationDataStorage!.path3D = path3D;\r\n        tube._creationDataStorage!.tessellation = tessellation;\r\n        tube._creationDataStorage!.cap = cap;\r\n        tube._creationDataStorage!.arc = options.arc;\r\n        tube._creationDataStorage!.radius = radius;\r\n\r\n        return tube;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}