{"ast":null,"code":"import { Tools } from \"./tools\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { Scalar } from \"../Maths/math.scalar\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\nimport { Scene } from \"../scene\";\nimport { PostProcess } from \"../PostProcesses/postProcess\";\nimport { Logger } from \"../Misc/logger\";\nimport \"../Engines/Extensions/engine.renderTargetCube\";\nimport \"../Engines/Extensions/engine.readTexture\";\nimport \"../Materials/Textures/baseTexture.polynomial\";\nimport \"../Shaders/rgbdEncode.fragment\";\nimport \"../Shaders/rgbdDecode.fragment\";\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\n\nvar EnvironmentTextureTools =\n/** @class */\nfunction () {\n  function EnvironmentTextureTools() {}\n  /**\r\n   * Gets the environment info from an env file.\r\n   * @param data The array buffer containing the .env bytes.\r\n   * @returns the environment file info (the json header) if successfully parsed.\r\n   */\n\n\n  EnvironmentTextureTools.GetEnvInfo = function (data) {\n    var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    var pos = 0;\n\n    for (var i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\n      if (dataView.getUint8(pos++) !== EnvironmentTextureTools._MagicBytes[i]) {\n        Logger.Error('Not a babylon environment map');\n        return null;\n      }\n    } // Read json manifest - collect characters up to null terminator\n\n\n    var manifestString = '';\n    var charCode = 0x00;\n\n    while (charCode = dataView.getUint8(pos++)) {\n      manifestString += String.fromCharCode(charCode);\n    }\n\n    var manifest = JSON.parse(manifestString);\n\n    if (manifest.specular) {\n      // Extend the header with the position of the payload.\n      manifest.specular.specularDataPosition = pos; // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n\n      manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n    }\n\n    return manifest;\n  };\n  /**\r\n   * Creates an environment texture from a loaded cube texture.\r\n   * @param texture defines the cube texture to convert in env file\r\n   * @return a promise containing the environment data if succesfull.\r\n   */\n\n\n  EnvironmentTextureTools.CreateEnvTextureAsync = function (texture) {\n    var _this = this;\n\n    var internalTexture = texture.getInternalTexture();\n\n    if (!internalTexture) {\n      return Promise.reject(\"The cube texture is invalid.\");\n    }\n\n    var engine = internalTexture.getEngine();\n\n    if (engine && engine.premultipliedAlpha) {\n      return Promise.reject(\"Env texture can only be created when the engine is created with the premultipliedAlpha option set to false.\");\n    }\n\n    if (texture.textureType === 0) {\n      return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n    }\n\n    var canvas = engine.getRenderingCanvas();\n\n    if (!canvas) {\n      return Promise.reject(\"Env texture can only be created when the engine is associated to a canvas.\");\n    }\n\n    var textureType = 1;\n\n    if (!engine.getCaps().textureFloatRender) {\n      textureType = 2;\n\n      if (!engine.getCaps().textureHalfFloatRender) {\n        return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n      }\n    }\n\n    var cubeWidth = internalTexture.width;\n    var hostingScene = new Scene(engine);\n    var specularTextures = {};\n    var promises = []; // Read and collect all mipmaps data from the cube.\n\n    var mipmapsCount = Scalar.Log2(internalTexture.width);\n    mipmapsCount = Math.round(mipmapsCount);\n\n    var _loop_1 = function (i) {\n      var faceWidth = Math.pow(2, mipmapsCount - i);\n\n      var _loop_2 = function (face) {\n        var data = texture.readPixels(face, i); // Creates a temp texture with the face data.\n\n        var tempTexture = engine.createRawTexture(data, faceWidth, faceWidth, 5, false, false, 1, null, textureType); // And rgbdEncode them.\n\n        var promise = new Promise(function (resolve, reject) {\n          var rgbdPostProcess = new PostProcess(\"rgbdEncode\", \"rgbdEncode\", null, null, 1, null, 1, engine, false, undefined, 0, undefined, null, false);\n          rgbdPostProcess.getEffect().executeWhenCompiled(function () {\n            rgbdPostProcess.onApply = function (effect) {\n              effect._bindTexture(\"textureSampler\", tempTexture);\n            }; // As the process needs to happen on the main canvas, keep track of the current size\n\n\n            var currentW = engine.getRenderWidth();\n            var currentH = engine.getRenderHeight(); // Set the desired size for the texture\n\n            engine.setSize(faceWidth, faceWidth);\n            hostingScene.postProcessManager.directRender([rgbdPostProcess], null); // Reading datas from WebGL\n\n            Tools.ToBlob(canvas, function (blob) {\n              var fileReader = new FileReader();\n\n              fileReader.onload = function (event) {\n                var arrayBuffer = event.target.result;\n                specularTextures[i * 6 + face] = arrayBuffer;\n                resolve();\n              };\n\n              fileReader.readAsArrayBuffer(blob);\n            }); // Reapply the previous canvas size\n\n            engine.setSize(currentW, currentH);\n          });\n        });\n        promises.push(promise);\n      }; // All faces of the cube.\n\n\n      for (var face = 0; face < 6; face++) {\n        _loop_2(face);\n      }\n    };\n\n    for (var i = 0; i <= mipmapsCount; i++) {\n      _loop_1(i);\n    } // Once all the textures haves been collected as RGBD stored in PNGs\n\n\n    return Promise.all(promises).then(function () {\n      // We can delete the hosting scene keeping track of all the creation objects\n      hostingScene.dispose(); // Creates the json header for the env texture\n\n      var info = {\n        version: 1,\n        width: cubeWidth,\n        irradiance: _this._CreateEnvTextureIrradiance(texture),\n        specular: {\n          mipmaps: [],\n          lodGenerationScale: texture.lodGenerationScale\n        }\n      }; // Sets the specular image data information\n\n      var position = 0;\n\n      for (var i = 0; i <= mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          var byteLength = specularTextures[i * 6 + face].byteLength;\n          info.specular.mipmaps.push({\n            length: byteLength,\n            position: position\n          });\n          position += byteLength;\n        }\n      } // Encode the JSON as an array buffer\n\n\n      var infoString = JSON.stringify(info);\n      var infoBuffer = new ArrayBuffer(infoString.length + 1);\n      var infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n\n      for (var i = 0, strLen = infoString.length; i < strLen; i++) {\n        infoView[i] = infoString.charCodeAt(i);\n      } // Ends up with a null terminator for easier parsing\n\n\n      infoView[infoString.length] = 0x00; // Computes the final required size and creates the storage\n\n      var totalSize = EnvironmentTextureTools._MagicBytes.length + position + infoBuffer.byteLength;\n      var finalBuffer = new ArrayBuffer(totalSize);\n      var finalBufferView = new Uint8Array(finalBuffer);\n      var dataView = new DataView(finalBuffer); // Copy the magic bytes identifying the file in\n\n      var pos = 0;\n\n      for (var i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\n        dataView.setUint8(pos++, EnvironmentTextureTools._MagicBytes[i]);\n      } // Add the json info\n\n\n      finalBufferView.set(new Uint8Array(infoBuffer), pos);\n      pos += infoBuffer.byteLength; // Finally inserts the texture data\n\n      for (var i = 0; i <= mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          var dataBuffer = specularTextures[i * 6 + face];\n          finalBufferView.set(new Uint8Array(dataBuffer), pos);\n          pos += dataBuffer.byteLength;\n        }\n      } // Voila\n\n\n      return finalBuffer;\n    });\n  };\n  /**\r\n   * Creates a JSON representation of the spherical data.\r\n   * @param texture defines the texture containing the polynomials\r\n   * @return the JSON representation of the spherical info\r\n   */\n\n\n  EnvironmentTextureTools._CreateEnvTextureIrradiance = function (texture) {\n    var polynmials = texture.sphericalPolynomial;\n\n    if (polynmials == null) {\n      return null;\n    }\n\n    return {\n      x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n      y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n      z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n      xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n      yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n      zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n      yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n      zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n      xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n    };\n  };\n  /**\r\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n   * @param data the image data\r\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n   * @return the views described by info providing access to the underlying buffer\r\n   */\n\n\n  EnvironmentTextureTools.CreateImageDataArrayBufferViews = function (data, info) {\n    if (info.version !== 1) {\n      throw new Error(\"Unsupported babylon environment map version \\\"\" + info.version + \"\\\"\");\n    }\n\n    var specularInfo = info.specular; // Double checks the enclosed info\n\n    var mipmapsCount = Scalar.Log2(info.width);\n    mipmapsCount = Math.round(mipmapsCount) + 1;\n\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n      throw new Error(\"Unsupported specular mipmaps number \\\"\" + specularInfo.mipmaps.length + \"\\\"\");\n    }\n\n    var imageData = new Array(mipmapsCount);\n\n    for (var i = 0; i < mipmapsCount; i++) {\n      imageData[i] = new Array(6);\n\n      for (var face = 0; face < 6; face++) {\n        var imageInfo = specularInfo.mipmaps[i * 6 + face];\n        imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n      }\n    }\n\n    return imageData;\n  };\n  /**\r\n   * Uploads the texture info contained in the env file to the GPU.\r\n   * @param texture defines the internal texture to upload to\r\n   * @param data defines the data to load\r\n   * @param info defines the texture info retrieved through the GetEnvInfo method\r\n   * @returns a promise\r\n   */\n\n\n  EnvironmentTextureTools.UploadEnvLevelsAsync = function (texture, data, info) {\n    if (info.version !== 1) {\n      throw new Error(\"Unsupported babylon environment map version \\\"\" + info.version + \"\\\"\");\n    }\n\n    var specularInfo = info.specular;\n\n    if (!specularInfo) {\n      // Nothing else parsed so far\n      return Promise.resolve();\n    }\n\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\n    var imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);\n    return EnvironmentTextureTools.UploadLevelsAsync(texture, imageData);\n  };\n\n  EnvironmentTextureTools._OnImageReadyAsync = function (image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n    return new Promise(function (resolve, reject) {\n      if (expandTexture) {\n        var tempTexture_1 = engine.createTexture(null, true, true, null, 1, null, function (message) {\n          reject(message);\n        }, image);\n        rgbdPostProcess.getEffect().executeWhenCompiled(function () {\n          // Uncompress the data to a RTT\n          rgbdPostProcess.onApply = function (effect) {\n            effect._bindTexture(\"textureSampler\", tempTexture_1);\n\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n\n          engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i); // Cleanup\n\n          engine.restoreDefaultFramebuffer();\n          tempTexture_1.dispose();\n          URL.revokeObjectURL(url);\n          resolve();\n        });\n      } else {\n        engine._uploadImageToTexture(texture, image, face, i); // Upload the face to the non lod texture support\n\n\n        if (generateNonLODTextures) {\n          var lodTexture = lodTextures[i];\n\n          if (lodTexture) {\n            engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n          }\n        }\n\n        resolve();\n      }\n    });\n  };\n  /**\r\n   * Uploads the levels of image data to the GPU.\r\n   * @param texture defines the internal texture to upload to\r\n   * @param imageData defines the array buffer views of image data [mipmap][face]\r\n   * @returns a promise\r\n   */\n\n\n  EnvironmentTextureTools.UploadLevelsAsync = function (texture, imageData) {\n    var _this = this;\n\n    if (!Tools.IsExponentOfTwo(texture.width)) {\n      throw new Error(\"Texture size must be a power of two\");\n    }\n\n    var mipmapsCount = Math.round(Scalar.Log2(texture.width)) + 1; // Gets everything ready.\n\n    var engine = texture.getEngine();\n    var expandTexture = false;\n    var generateNonLODTextures = false;\n    var rgbdPostProcess = null;\n    var cubeRtt = null;\n    var lodTextures = null;\n    var caps = engine.getCaps();\n    texture.format = 5;\n    texture.type = 0;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    engine.updateTextureSamplingMode(3, texture); // Add extra process if texture lod is not supported\n\n    if (!caps.textureLOD) {\n      expandTexture = false;\n      generateNonLODTextures = true;\n      lodTextures = {};\n    } // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n    else if (engine.webGLVersion < 2) {\n        expandTexture = false;\n      } // If half float available we can uncompress the texture\n      else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n          expandTexture = true;\n          texture.type = 2;\n        } // If full float available we can uncompress the texture\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n            expandTexture = true;\n            texture.type = 1;\n          } // Expand the texture if possible\n\n\n    if (expandTexture) {\n      // Simply run through the decode PP\n      rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n      texture._isRGBD = false;\n      texture.invertY = false;\n      cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n        generateDepthBuffer: false,\n        generateMipMaps: true,\n        generateStencilBuffer: false,\n        samplingMode: 3,\n        type: texture.type,\n        format: 5\n      });\n    } else {\n      texture._isRGBD = true;\n      texture.invertY = true; // In case of missing support, applies the same patch than DDS files.\n\n      if (generateNonLODTextures) {\n        var mipSlices = 3;\n        var scale = texture._lodGenerationScale;\n        var offset = texture._lodGenerationOffset;\n\n        for (var i = 0; i < mipSlices; i++) {\n          //compute LOD from even spacing in smoothness (matching shader calculation)\n          var smoothness = i / (mipSlices - 1);\n          var roughness = 1 - smoothness;\n          var minLODIndex = offset; // roughness = 0\n\n          var maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n\n          var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n          var mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n          var glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n          glTextureFromLod.isCube = true;\n          glTextureFromLod.invertY = true;\n          glTextureFromLod.generateMipMaps = false;\n          engine.updateTextureSamplingMode(2, glTextureFromLod); // Wrap in a base texture for easy binding.\n\n          var lodTexture = new BaseTexture(null);\n          lodTexture.isCube = true;\n          lodTexture._texture = glTextureFromLod;\n          lodTextures[mipmapIndex] = lodTexture;\n\n          switch (i) {\n            case 0:\n              texture._lodTextureLow = lodTexture;\n              break;\n\n            case 1:\n              texture._lodTextureMid = lodTexture;\n              break;\n\n            case 2:\n              texture._lodTextureHigh = lodTexture;\n              break;\n          }\n        }\n      }\n    }\n\n    var promises = [];\n\n    var _loop_3 = function (i) {\n      var _loop_4 = function (face) {\n        // Constructs an image element from image data\n        var bytes = imageData[i][face];\n        var blob = new Blob([bytes], {\n          type: 'image/png'\n        });\n        var url = URL.createObjectURL(blob);\n        var promise = void 0;\n\n        if (typeof Image === \"undefined\") {\n          promise = createImageBitmap(blob).then(function (img) {\n            return _this._OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n          });\n        } else {\n          var image_1 = new Image();\n          image_1.src = url; // Enqueue promise to upload to the texture.\n\n          promise = new Promise(function (resolve, reject) {\n            image_1.onload = function () {\n              _this._OnImageReadyAsync(image_1, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(function () {\n                return resolve();\n              }).catch(function (reason) {\n                reject(reason);\n              });\n            };\n\n            image_1.onerror = function (error) {\n              reject(error);\n            };\n          });\n        }\n\n        promises.push(promise);\n      }; // All faces\n\n\n      for (var face = 0; face < 6; face++) {\n        _loop_4(face);\n      }\n    }; // All mipmaps up to provided number of images\n\n\n    for (var i = 0; i < imageData.length; i++) {\n      _loop_3(i);\n    } // Fill remaining mipmaps with black textures.\n\n\n    if (imageData.length < mipmapsCount) {\n      var data = void 0;\n      var size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n      var dataLength = size * size * 4;\n\n      switch (texture.type) {\n        case 0:\n          {\n            data = new Uint8Array(dataLength);\n            break;\n          }\n\n        case 2:\n          {\n            data = new Uint16Array(dataLength);\n            break;\n          }\n\n        case 1:\n          {\n            data = new Float32Array(dataLength);\n            break;\n          }\n      }\n\n      for (var i = imageData.length; i < mipmapsCount; i++) {\n        for (var face = 0; face < 6; face++) {\n          engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n        }\n      }\n    } // Once all done, finishes the cleanup and return\n\n\n    return Promise.all(promises).then(function () {\n      // Release temp RTT.\n      if (cubeRtt) {\n        engine._releaseFramebufferObjects(cubeRtt);\n\n        engine._releaseTexture(texture);\n\n        cubeRtt._swapAndDie(texture);\n      } // Release temp Post Process.\n\n\n      if (rgbdPostProcess) {\n        rgbdPostProcess.dispose();\n      } // Flag internal texture as ready in case they are in use.\n\n\n      if (generateNonLODTextures) {\n        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n          texture._lodTextureHigh._texture.isReady = true;\n        }\n\n        if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n          texture._lodTextureMid._texture.isReady = true;\n        }\n\n        if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n          texture._lodTextureLow._texture.isReady = true;\n        }\n      }\n    });\n  };\n  /**\r\n   * Uploads spherical polynomials information to the texture.\r\n   * @param texture defines the texture we are trying to upload the information to\r\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n   */\n\n\n  EnvironmentTextureTools.UploadEnvSpherical = function (texture, info) {\n    if (info.version !== 1) {\n      Logger.Warn('Unsupported babylon environment map version \"' + info.version + '\"');\n    }\n\n    var irradianceInfo = info.irradiance;\n\n    if (!irradianceInfo) {\n      return;\n    }\n\n    var sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n    texture._sphericalPolynomial = sp;\n  };\n  /** @hidden */\n\n\n  EnvironmentTextureTools._UpdateRGBDAsync = function (internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(function () {\n      internalTexture.isReady = true;\n    });\n  };\n  /**\r\n   * Magic number identifying the env file.\r\n   */\n\n\n  EnvironmentTextureTools._MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n  return EnvironmentTextureTools;\n}();\n\nexport { EnvironmentTextureTools }; // References the dependencies.\n\nInternalTexture._UpdateRGBDAsync = EnvironmentTextureTools._UpdateRGBDAsync;","map":{"version":3,"sources":["../../../sourceES6/core/Misc/environmentTextureTools.ts"],"names":[],"mappings":"AACA,SAAS,KAAT,QAAsB,SAAtB;AACA,SAAS,OAAT,QAAwB,sBAAxB;AACA,SAAS,MAAT,QAAuB,sBAAvB;AACA,SAAS,mBAAT,QAAoC,8BAApC;AACA,SAAS,eAAT,EAA0B,qBAA1B,QAAuD,uCAAvD;AACA,SAAS,WAAT,QAA4B,mCAA5B;AAEA,SAAS,KAAT,QAAsB,UAAtB;AACA,SAAS,WAAT,QAA4B,8BAA5B;AACA,SAAS,MAAT,QAAuB,gBAAvB;AAEA,OAAO,+CAAP;AACA,OAAO,0CAAP;AACA,OAAO,8CAAP;AAEA,OAAO,gCAAP;AACA,OAAO,gCAAP;AA+EA;;;;;;AAKA,IAAA,uBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,uBAAA,GAAA,CAqjBC;AA9iBG;;;;;;;AAKc,EAAA,uBAAA,CAAA,UAAA,GAAd,UAAyB,IAAzB,EAA8C;AAC1C,QAAI,QAAQ,GAAG,IAAI,QAAJ,CAAa,IAAI,CAAC,MAAlB,EAA0B,IAAI,CAAC,UAA/B,EAA2C,IAAI,CAAC,UAAhD,CAAf;AACA,QAAI,GAAG,GAAG,CAAV;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,uBAAuB,CAAC,WAAxB,CAAoC,MAAxD,EAAgE,CAAC,EAAjE,EAAqE;AACjE,UAAI,QAAQ,CAAC,QAAT,CAAkB,GAAG,EAArB,MAA6B,uBAAuB,CAAC,WAAxB,CAAoC,CAApC,CAAjC,EAAyE;AACrE,QAAA,MAAM,CAAC,KAAP,CAAa,+BAAb;AACA,eAAO,IAAP;AACH;AACJ,KATyC,CAW1C;;;AACA,QAAI,cAAc,GAAG,EAArB;AACA,QAAI,QAAQ,GAAG,IAAf;;AACA,WAAQ,QAAQ,GAAG,QAAQ,CAAC,QAAT,CAAkB,GAAG,EAArB,CAAnB,EAA8C;AAC1C,MAAA,cAAc,IAAI,MAAM,CAAC,YAAP,CAAoB,QAApB,CAAlB;AACH;;AAED,QAAI,QAAQ,GAA2B,IAAI,CAAC,KAAL,CAAW,cAAX,CAAvC;;AACA,QAAI,QAAQ,CAAC,QAAb,EAAuB;AACnB;AACA,MAAA,QAAQ,CAAC,QAAT,CAAkB,oBAAlB,GAAyC,GAAzC,CAFmB,CAGnB;;AACA,MAAA,QAAQ,CAAC,QAAT,CAAkB,kBAAlB,GAAuC,QAAQ,CAAC,QAAT,CAAkB,kBAAlB,IAAwC,GAA/E;AACH;;AAED,WAAO,QAAP;AACH,GA3Ba;AA6Bd;;;;;;;AAKc,EAAA,uBAAA,CAAA,qBAAA,GAAd,UAAoC,OAApC,EAAwD;AAAxD,QAAA,KAAA,GAAA,IAAA;;AACI,QAAI,eAAe,GAAG,OAAO,CAAC,kBAAR,EAAtB;;AACA,QAAI,CAAC,eAAL,EAAsB;AAClB,aAAO,OAAO,CAAC,MAAR,CAAe,8BAAf,CAAP;AACH;;AAED,QAAI,MAAM,GAAG,eAAe,CAAC,SAAhB,EAAb;;AACA,QAAI,MAAM,IAAI,MAAM,CAAC,kBAArB,EAAyC;AACrC,aAAO,OAAO,CAAC,MAAR,CAAe,6GAAf,CAAP;AACH;;AAED,QAAI,OAAO,CAAC,WAAR,KAAwB,CAA5B,EAA+B;AAC3B,aAAO,OAAO,CAAC,MAAR,CAAe,+DAAf,CAAP;AACH;;AAED,QAAI,MAAM,GAAG,MAAM,CAAC,kBAAP,EAAb;;AACA,QAAI,CAAC,MAAL,EAAa;AACT,aAAO,OAAO,CAAC,MAAR,CAAe,4EAAf,CAAP;AACH;;AAED,QAAI,WAAW,GAAG,CAAlB;;AACA,QAAI,CAAC,MAAM,CAAC,OAAP,GAAiB,kBAAtB,EAA0C;AACtC,MAAA,WAAW,GAAG,CAAd;;AACA,UAAI,CAAC,MAAM,CAAC,OAAP,GAAiB,sBAAtB,EAA8C;AAC1C,eAAO,OAAO,CAAC,MAAR,CAAe,+FAAf,CAAP;AACH;AACJ;;AAED,QAAI,SAAS,GAAG,eAAe,CAAC,KAAhC;AACA,QAAI,YAAY,GAAG,IAAI,KAAJ,CAAU,MAAV,CAAnB;AACA,QAAI,gBAAgB,GAAmC,EAAvD;AACA,QAAI,QAAQ,GAAoB,EAAhC,CA/BoD,CAiCpD;;AACA,QAAI,YAAY,GAAG,MAAM,CAAC,IAAP,CAAY,eAAe,CAAC,KAA5B,CAAnB;AACA,IAAA,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAAf;;4BACS,C,EAAC;AACN,UAAI,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,YAAY,GAAG,CAA3B,CAAhB;;8BAGS,I,EAAI;AACT,YAAI,IAAI,GAAG,OAAO,CAAC,UAAR,CAAmB,IAAnB,EAAyB,CAAzB,CAAX,CADS,CAGT;;AACA,YAAI,WAAW,GAAG,MAAM,CAAC,gBAAP,CAAwB,IAAxB,EAA8B,SAA9B,EAAyC,SAAzC,EAAoD,CAApD,EAAuD,KAAvD,EAA8D,KAA9D,EAAqE,CAArE,EAAwE,IAAxE,EAA8E,WAA9E,CAAlB,CAJS,CAKT;;AACA,YAAI,OAAO,GAAG,IAAI,OAAJ,CAAkB,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC5C,cAAI,eAAe,GAAG,IAAI,WAAJ,CAAgB,YAAhB,EAA8B,YAA9B,EAA4C,IAA5C,EAAkD,IAAlD,EAAwD,CAAxD,EAA2D,IAA3D,EAAiE,CAAjE,EAAoE,MAApE,EAA4E,KAA5E,EAAmF,SAAnF,EAA8F,CAA9F,EAAiG,SAAjG,EAA4G,IAA5G,EAAkH,KAAlH,CAAtB;AACA,UAAA,eAAe,CAAC,SAAhB,GAA4B,mBAA5B,CAAgD,YAAA;AAC5C,YAAA,eAAe,CAAC,OAAhB,GAA0B,UAAC,MAAD,EAAO;AAC7B,cAAA,MAAM,CAAC,YAAP,CAAoB,gBAApB,EAAsC,WAAtC;AACH,aAFD,CAD4C,CAK5C;;;AACA,gBAAI,QAAQ,GAAG,MAAM,CAAC,cAAP,EAAf;AACA,gBAAI,QAAQ,GAAG,MAAM,CAAC,eAAP,EAAf,CAP4C,CAS5C;;AACA,YAAA,MAAM,CAAC,OAAP,CAAe,SAAf,EAA0B,SAA1B;AACA,YAAA,YAAY,CAAC,kBAAb,CAAgC,YAAhC,CAA6C,CAAC,eAAD,CAA7C,EAAgE,IAAhE,EAX4C,CAa5C;;AACA,YAAA,KAAK,CAAC,MAAN,CAAa,MAAb,EAAsB,UAAC,IAAD,EAAK;AACvB,kBAAI,UAAU,GAAG,IAAI,UAAJ,EAAjB;;AACA,cAAA,UAAU,CAAC,MAAX,GAAoB,UAAC,KAAD,EAAW;AAC3B,oBAAI,WAAW,GAAG,KAAK,CAAC,MAAN,CAAc,MAAhC;AACA,gBAAA,gBAAgB,CAAC,CAAC,GAAG,CAAJ,GAAQ,IAAT,CAAhB,GAAiC,WAAjC;AACA,gBAAA,OAAO;AACV,eAJD;;AAKA,cAAA,UAAU,CAAC,iBAAX,CAA6B,IAA7B;AACH,aARD,EAd4C,CAwB5C;;AACA,YAAA,MAAM,CAAC,OAAP,CAAe,QAAf,EAAyB,QAAzB;AACH,WA1BD;AA2BH,SA7Ba,CAAd;AA8BA,QAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;QAxCE,CAGN;;;AACA,WAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAmC;gBAA1B,I;AAqCR;;;AAzCL,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,YAArB,EAAmC,CAAC,EAApC,EAAsC;cAA7B,C;AA0CR,KA9EmD,CAgFpD;;;AACA,WAAO,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA2B,YAAA;AAC9B;AACA,MAAA,YAAY,CAAC,OAAb,GAF8B,CAI9B;;AACA,UAAI,IAAI,GAA2B;AAC/B,QAAA,OAAO,EAAE,CADsB;AAE/B,QAAA,KAAK,EAAE,SAFwB;AAG/B,QAAA,UAAU,EAAE,KAAI,CAAC,2BAAL,CAAiC,OAAjC,CAHmB;AAI/B,QAAA,QAAQ,EAAE;AACN,UAAA,OAAO,EAAE,EADH;AAEN,UAAA,kBAAkB,EAAE,OAAO,CAAC;AAFtB;AAJqB,OAAnC,CAL8B,CAe9B;;AACA,UAAI,QAAQ,GAAG,CAAf;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,YAArB,EAAmC,CAAC,EAApC,EAAwC;AACpC,aAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAqC;AACjC,cAAI,UAAU,GAAG,gBAAgB,CAAC,CAAC,GAAG,CAAJ,GAAQ,IAAT,CAAhB,CAA+B,UAAhD;AACA,UAAA,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,IAAtB,CAA2B;AACvB,YAAA,MAAM,EAAE,UADe;AAEvB,YAAA,QAAQ,EAAE;AAFa,WAA3B;AAIA,UAAA,QAAQ,IAAI,UAAZ;AACH;AACJ,OA1B6B,CA4B9B;;;AACA,UAAI,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,IAAf,CAAjB;AACA,UAAI,UAAU,GAAG,IAAI,WAAJ,CAAgB,UAAU,CAAC,MAAX,GAAoB,CAApC,CAAjB;AACA,UAAI,QAAQ,GAAG,IAAI,UAAJ,CAAe,UAAf,CAAf,CA/B8B,CA+Ba;;AAC3C,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,MAAM,GAAG,UAAU,CAAC,MAApC,EAA4C,CAAC,GAAG,MAAhD,EAAwD,CAAC,EAAzD,EAA6D;AACzD,QAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,UAAU,CAAC,UAAX,CAAsB,CAAtB,CAAd;AACH,OAlC6B,CAmC9B;;;AACA,MAAA,QAAQ,CAAC,UAAU,CAAC,MAAZ,CAAR,GAA8B,IAA9B,CApC8B,CAsC9B;;AACA,UAAI,SAAS,GAAG,uBAAuB,CAAC,WAAxB,CAAoC,MAApC,GAA6C,QAA7C,GAAwD,UAAU,CAAC,UAAnF;AACA,UAAI,WAAW,GAAG,IAAI,WAAJ,CAAgB,SAAhB,CAAlB;AACA,UAAI,eAAe,GAAG,IAAI,UAAJ,CAAe,WAAf,CAAtB;AACA,UAAI,QAAQ,GAAG,IAAI,QAAJ,CAAa,WAAb,CAAf,CA1C8B,CA4C9B;;AACA,UAAI,GAAG,GAAG,CAAV;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,uBAAuB,CAAC,WAAxB,CAAoC,MAAxD,EAAgE,CAAC,EAAjE,EAAqE;AACjE,QAAA,QAAQ,CAAC,QAAT,CAAkB,GAAG,EAArB,EAAyB,uBAAuB,CAAC,WAAxB,CAAoC,CAApC,CAAzB;AACH,OAhD6B,CAkD9B;;;AACA,MAAA,eAAe,CAAC,GAAhB,CAAoB,IAAI,UAAJ,CAAe,UAAf,CAApB,EAAgD,GAAhD;AACA,MAAA,GAAG,IAAI,UAAU,CAAC,UAAlB,CApD8B,CAsD9B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,YAArB,EAAmC,CAAC,EAApC,EAAwC;AACpC,aAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAqC;AACjC,cAAI,UAAU,GAAG,gBAAgB,CAAC,CAAC,GAAG,CAAJ,GAAQ,IAAT,CAAjC;AACA,UAAA,eAAe,CAAC,GAAhB,CAAoB,IAAI,UAAJ,CAAe,UAAf,CAApB,EAAgD,GAAhD;AACA,UAAA,GAAG,IAAI,UAAU,CAAC,UAAlB;AACH;AACJ,OA7D6B,CA+D9B;;;AACA,aAAO,WAAP;AACH,KAjEM,CAAP;AAkEH,GAnJa;AAqJd;;;;;;;AAKe,EAAA,uBAAA,CAAA,2BAAA,GAAf,UAA2C,OAA3C,EAA+D;AAC3D,QAAI,UAAU,GAAG,OAAO,CAAC,mBAAzB;;AACA,QAAI,UAAU,IAAI,IAAlB,EAAwB;AACpB,aAAO,IAAP;AACH;;AAED,WAAO;AACH,MAAA,CAAC,EAAE,CAAC,UAAU,CAAC,CAAX,CAAa,CAAd,EAAiB,UAAU,CAAC,CAAX,CAAa,CAA9B,EAAiC,UAAU,CAAC,CAAX,CAAa,CAA9C,CADA;AAEH,MAAA,CAAC,EAAE,CAAC,UAAU,CAAC,CAAX,CAAa,CAAd,EAAiB,UAAU,CAAC,CAAX,CAAa,CAA9B,EAAiC,UAAU,CAAC,CAAX,CAAa,CAA9C,CAFA;AAGH,MAAA,CAAC,EAAE,CAAC,UAAU,CAAC,CAAX,CAAa,CAAd,EAAiB,UAAU,CAAC,CAAX,CAAa,CAA9B,EAAiC,UAAU,CAAC,CAAX,CAAa,CAA9C,CAHA;AAKH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD,CALD;AAMH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD,CAND;AAOH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD,CAPD;AASH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD,CATD;AAUH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD,CAVD;AAWH,MAAA,EAAE,EAAE,CAAC,UAAU,CAAC,EAAX,CAAc,CAAf,EAAkB,UAAU,CAAC,EAAX,CAAc,CAAhC,EAAmC,UAAU,CAAC,EAAX,CAAc,CAAjD;AAXD,KAAP;AAaH,GAnBc;AAqBf;;;;;;;;AAMc,EAAA,uBAAA,CAAA,+BAAA,GAAd,UAA8C,IAA9C,EAAqE,IAArE,EAAiG;AAC7F,QAAI,IAAI,CAAC,OAAL,KAAiB,CAArB,EAAwB;AACpB,YAAM,IAAI,KAAJ,CAAU,mDAAgD,IAAI,CAAC,OAArD,GAA4D,IAAtE,CAAN;AACH;;AAED,QAAM,YAAY,GAAG,IAAI,CAAC,QAA1B,CAL6F,CAO7F;;AACA,QAAI,YAAY,GAAG,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,KAAjB,CAAnB;AACA,IAAA,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,IAA2B,CAA1C;;AACA,QAAI,YAAY,CAAC,OAAb,CAAqB,MAArB,KAAgC,IAAI,YAAxC,EAAsD;AAClD,YAAM,IAAI,KAAJ,CAAU,2CAAwC,YAAY,CAAC,OAAb,CAAqB,MAA7D,GAAmE,IAA7E,CAAN;AACH;;AAED,QAAM,SAAS,GAAG,IAAI,KAAJ,CAAkC,YAAlC,CAAlB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAApB,EAAkC,CAAC,EAAnC,EAAuC;AACnC,MAAA,SAAS,CAAC,CAAD,CAAT,GAAe,IAAI,KAAJ,CAA2B,CAA3B,CAAf;;AACA,WAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAqC;AACjC,YAAM,SAAS,GAAG,YAAY,CAAC,OAAb,CAAqB,CAAC,GAAG,CAAJ,GAAQ,IAA7B,CAAlB;AACA,QAAA,SAAS,CAAC,CAAD,CAAT,CAAa,IAAb,IAAqB,IAAI,UAAJ,CAAe,IAAI,CAAC,MAApB,EAA4B,IAAI,CAAC,UAAL,GAAkB,YAAY,CAAC,oBAA/B,GAAuD,SAAS,CAAC,QAA7F,EAAuG,SAAS,CAAC,MAAjH,CAArB;AACH;AACJ;;AAED,WAAO,SAAP;AACH,GAxBa;AA0Bd;;;;;;;;;AAOc,EAAA,uBAAA,CAAA,oBAAA,GAAd,UAAmC,OAAnC,EAA6D,IAA7D,EAAoF,IAApF,EAAgH;AAC5G,QAAI,IAAI,CAAC,OAAL,KAAiB,CAArB,EAAwB;AACpB,YAAM,IAAI,KAAJ,CAAU,mDAAgD,IAAI,CAAC,OAArD,GAA4D,IAAtE,CAAN;AACH;;AAED,QAAM,YAAY,GAAG,IAAI,CAAC,QAA1B;;AACA,QAAI,CAAC,YAAL,EAAmB;AACf;AACA,aAAO,OAAO,CAAC,OAAR,EAAP;AACH;;AAED,IAAA,OAAO,CAAC,mBAAR,GAA8B,YAAY,CAAC,kBAA3C;AAEA,QAAM,SAAS,GAAG,uBAAuB,CAAC,+BAAxB,CAAwD,IAAxD,EAA8D,IAA9D,CAAlB;AAEA,WAAO,uBAAuB,CAAC,iBAAxB,CAA0C,OAA1C,EAAmD,SAAnD,CAAP;AACH,GAhBa;;AAkBC,EAAA,uBAAA,CAAA,kBAAA,GAAf,UAAkC,KAAlC,EAAyE,MAAzE,EAAyF,aAAzF,EACI,eADJ,EAC6C,GAD7C,EAC0D,IAD1D,EACwE,CADxE,EACmF,sBADnF,EAEI,WAFJ,EAE2D,OAF3D,EAE+F,OAF/F,EAEuH;AAE/G,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC/B,UAAI,aAAJ,EAAmB;AACf,YAAI,aAAW,GAAG,MAAM,CAAC,aAAP,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,IAAjC,EAAuC,IAAvC,EAA6C,CAA7C,EAAgD,IAAhD,EACd,UAAC,OAAD,EAAQ;AACJ,UAAA,MAAM,CAAC,OAAD,CAAN;AACH,SAHa,EAId,KAJc,CAAlB;AAMA,QAAA,eAAgB,CAAC,SAAjB,GAA6B,mBAA7B,CAAiD,YAAA;AAC7C;AACA,UAAA,eAAgB,CAAC,OAAjB,GAA2B,UAAC,MAAD,EAAO;AAC9B,YAAA,MAAM,CAAC,YAAP,CAAoB,gBAApB,EAAsC,aAAtC;;AACA,YAAA,MAAM,CAAC,SAAP,CAAiB,OAAjB,EAA0B,CAA1B,EAA6B,CAA7B;AACH,WAHD;;AAKA,UAAA,MAAM,CAAC,MAAP,CAAc,CAAd,EAAiB,kBAAjB,CAAoC,YAApC,CAAiD,CAAC,eAAD,CAAjD,EAAqE,OAArE,EAA8E,IAA9E,EAAoF,IAApF,EAA0F,CAA1F,EAP6C,CAS7C;;AACA,UAAA,MAAM,CAAC,yBAAP;AACA,UAAA,aAAW,CAAC,OAAZ;AACA,UAAA,GAAG,CAAC,eAAJ,CAAoB,GAApB;AACA,UAAA,OAAO;AACV,SAdD;AAeH,OAtBD,MAuBK;AACD,QAAA,MAAM,CAAC,qBAAP,CAA6B,OAA7B,EAAsC,KAAtC,EAA6C,IAA7C,EAAmD,CAAnD,EADC,CAGD;;;AACA,YAAI,sBAAJ,EAA4B;AACxB,cAAI,UAAU,GAAG,WAAY,CAAC,CAAD,CAA7B;;AACA,cAAI,UAAJ,EAAgB;AACZ,YAAA,MAAM,CAAC,qBAAP,CAA6B,UAAU,CAAC,QAAxC,EAAmD,KAAnD,EAA0D,IAA1D,EAAgE,CAAhE;AACH;AACJ;;AACD,QAAA,OAAO;AACV;AACJ,KApCM,CAAP;AAsCP,GA1Cc;AA4Cf;;;;;;;;AAMc,EAAA,uBAAA,CAAA,iBAAA,GAAd,UAAgC,OAAhC,EAA0D,SAA1D,EAAwF;AAAxF,QAAA,KAAA,GAAA,IAAA;;AACI,QAAI,CAAC,KAAK,CAAC,eAAN,CAAsB,OAAO,CAAC,KAA9B,CAAL,EAA2C;AACvC,YAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACH;;AAED,QAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,KAApB,CAAX,IAAyC,CAA9D,CALoF,CAOpF;;AACA,QAAI,MAAM,GAAG,OAAO,CAAC,SAAR,EAAb;AACA,QAAI,aAAa,GAAG,KAApB;AACA,QAAI,sBAAsB,GAAG,KAA7B;AACA,QAAI,eAAe,GAA0B,IAA7C;AACA,QAAI,OAAO,GAA8B,IAAzC;AACA,QAAI,WAAW,GAA6C,IAA5D;AACA,QAAI,IAAI,GAAG,MAAM,CAAC,OAAP,EAAX;AAEA,IAAA,OAAO,CAAC,MAAR,GAAiB,CAAjB;AACA,IAAA,OAAO,CAAC,IAAR,GAAe,CAAf;AACA,IAAA,OAAO,CAAC,eAAR,GAA0B,IAA1B;AACA,IAAA,OAAO,CAAC,gCAAR,GAA2C,IAA3C;AACA,IAAA,MAAM,CAAC,yBAAP,CAAiC,CAAjC,EAAoC,OAApC,EApBoF,CAsBpF;;AACA,QAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AAClB,MAAA,aAAa,GAAG,KAAhB;AACA,MAAA,sBAAsB,GAAG,IAAzB;AACA,MAAA,WAAW,GAAG,EAAd;AACH,KAJD,CAKA;AALA,SAMK,IAAI,MAAM,CAAC,YAAP,GAAsB,CAA1B,EAA6B;AAC9B,QAAA,aAAa,GAAG,KAAhB;AACH,OAFI,CAGL;AAHK,WAIA,IAAI,IAAI,CAAC,sBAAL,IAA+B,IAAI,CAAC,+BAAxC,EAAyE;AAC1E,UAAA,aAAa,GAAG,IAAhB;AACA,UAAA,OAAO,CAAC,IAAR,GAAe,CAAf;AACH,SAHI,CAIL;AAJK,aAKA,IAAI,IAAI,CAAC,kBAAL,IAA2B,IAAI,CAAC,2BAApC,EAAiE;AAClE,YAAA,aAAa,GAAG,IAAhB;AACA,YAAA,OAAO,CAAC,IAAR,GAAe,CAAf;AACH,WAzCmF,CA2CpF;;;AACA,QAAI,aAAJ,EAAmB;AACf;AACA,MAAA,eAAe,GAAG,IAAI,WAAJ,CAAgB,YAAhB,EAA8B,YAA9B,EAA4C,IAA5C,EAAkD,IAAlD,EAAwD,CAAxD,EAA2D,IAA3D,EAAiE,CAAjE,EAAoE,MAApE,EAA4E,KAA5E,EAAmF,SAAnF,EAA8F,OAAO,CAAC,IAAtG,EAA4G,SAA5G,EAAuH,IAAvH,EAA6H,KAA7H,CAAlB;AAEA,MAAA,OAAO,CAAC,OAAR,GAAkB,KAAlB;AACA,MAAA,OAAO,CAAC,OAAR,GAAkB,KAAlB;AACA,MAAA,OAAO,GAAG,MAAM,CAAC,6BAAP,CAAqC,OAAO,CAAC,KAA7C,EAAoD;AAC1D,QAAA,mBAAmB,EAAE,KADqC;AAE1D,QAAA,eAAe,EAAE,IAFyC;AAG1D,QAAA,qBAAqB,EAAE,KAHmC;AAI1D,QAAA,YAAY,EAAE,CAJ4C;AAK1D,QAAA,IAAI,EAAE,OAAO,CAAC,IAL4C;AAM1D,QAAA,MAAM,EAAE;AANkD,OAApD,CAAV;AAQH,KAdD,MAeK;AACD,MAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB;AACA,MAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB,CAFC,CAID;;AACA,UAAI,sBAAJ,EAA4B;AACxB,YAAI,SAAS,GAAG,CAAhB;AACA,YAAI,KAAK,GAAG,OAAO,CAAC,mBAApB;AACA,YAAI,MAAM,GAAG,OAAO,CAAC,oBAArB;;AAEA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,EAAhC,EAAoC;AAChC;AACA,cAAI,UAAU,GAAG,CAAC,IAAI,SAAS,GAAG,CAAhB,CAAlB;AACA,cAAI,SAAS,GAAG,IAAI,UAApB;AAEA,cAAI,WAAW,GAAG,MAAlB,CALgC,CAKN;;AAC1B,cAAI,WAAW,GAAG,CAAC,YAAY,GAAG,CAAhB,IAAqB,KAArB,GAA6B,MAA/C,CANgC,CAMuB;;AAEvD,cAAI,QAAQ,GAAG,WAAW,GAAG,CAAC,WAAW,GAAG,WAAf,IAA8B,SAA3D;AACA,cAAI,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,CAAnB,CAAT,EAAgC,WAAhC,CAAX,CAAlB;AAEA,cAAI,gBAAgB,GAAG,IAAI,eAAJ,CAAoB,MAApB,EAA4B,qBAAqB,CAAC,IAAlD,CAAvB;AACA,UAAA,gBAAgB,CAAC,MAAjB,GAA0B,IAA1B;AACA,UAAA,gBAAgB,CAAC,OAAjB,GAA2B,IAA3B;AACA,UAAA,gBAAgB,CAAC,eAAjB,GAAmC,KAAnC;AACA,UAAA,MAAM,CAAC,yBAAP,CAAiC,CAAjC,EAAoC,gBAApC,EAfgC,CAiBhC;;AACA,cAAI,UAAU,GAAG,IAAI,WAAJ,CAAgB,IAAhB,CAAjB;AACA,UAAA,UAAU,CAAC,MAAX,GAAoB,IAApB;AACA,UAAA,UAAU,CAAC,QAAX,GAAsB,gBAAtB;AACA,UAAA,WAAY,CAAC,WAAD,CAAZ,GAA4B,UAA5B;;AAEA,kBAAQ,CAAR;AACI,iBAAK,CAAL;AACI,cAAA,OAAO,CAAC,cAAR,GAAyB,UAAzB;AACA;;AACJ,iBAAK,CAAL;AACI,cAAA,OAAO,CAAC,cAAR,GAAyB,UAAzB;AACA;;AACJ,iBAAK,CAAL;AACI,cAAA,OAAO,CAAC,eAAR,GAA0B,UAA1B;AACA;AATR;AAWH;AACJ;AACJ;;AAED,QAAI,QAAQ,GAAoB,EAAhC;;4BAES,C,EAAC;8BAEG,I,EAAI;AACT;AACA,YAAI,KAAK,GAAG,SAAS,CAAC,CAAD,CAAT,CAAa,IAAb,CAAZ;AACA,YAAI,IAAI,GAAG,IAAI,IAAJ,CAAS,CAAC,KAAD,CAAT,EAAkB;AAAE,UAAA,IAAI,EAAE;AAAR,SAAlB,CAAX;AACA,YAAI,GAAG,GAAG,GAAG,CAAC,eAAJ,CAAoB,IAApB,CAAV;AACA,YAAI,OAAO,GAAA,KAAA,CAAX;;AAEA,YAAI,OAAO,KAAP,KAAiB,WAArB,EAAkC;AAC9B,UAAA,OAAO,GAAG,iBAAiB,CAAC,IAAD,CAAjB,CAAwB,IAAxB,CAA6B,UAAC,GAAD,EAAI;AACvC,mBAAO,KAAI,CAAC,kBAAL,CAAwB,GAAxB,EAA6B,MAA7B,EAAqC,aAArC,EAAoD,eAApD,EAAqE,GAArE,EAA0E,IAA1E,EAAgF,CAAhF,EAAmF,sBAAnF,EAA2G,WAA3G,EAAwH,OAAxH,EAAiI,OAAjI,CAAP;AACH,WAFS,CAAV;AAGH,SAJD,MAIO;AACH,cAAI,OAAK,GAAG,IAAI,KAAJ,EAAZ;AACA,UAAA,OAAK,CAAC,GAAN,GAAY,GAAZ,CAFG,CAIH;;AACA,UAAA,OAAO,GAAG,IAAI,OAAJ,CAAkB,UAAC,OAAD,EAAU,MAAV,EAAgB;AACxC,YAAA,OAAK,CAAC,MAAN,GAAe,YAAA;AACX,cAAA,KAAI,CAAC,kBAAL,CAAwB,OAAxB,EAA+B,MAA/B,EAAuC,aAAvC,EAAsD,eAAtD,EAAuE,GAAvE,EAA4E,IAA5E,EAAkF,CAAlF,EAAqF,sBAArF,EAA6G,WAA7G,EAA0H,OAA1H,EAAmI,OAAnI,EACC,IADD,CACM,YAAA;AAAM,uBAAA,OAAA,EAAA;AAAS,eADrB,EAEC,KAFD,CAEO,UAAC,MAAD,EAAO;AACV,gBAAA,MAAM,CAAC,MAAD,CAAN;AACH,eAJD;AAKH,aAND;;AAOA,YAAA,OAAK,CAAC,OAAN,GAAgB,UAAC,KAAD,EAAM;AAClB,cAAA,MAAM,CAAC,KAAD,CAAN;AACH,aAFD;AAGH,WAXS,CAAV;AAYH;;AACD,QAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;QA/BE,CACN;;;AACA,WAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAmC;gBAA1B,I;AA8BR;MA7I+E,CA4GpF;;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAAyC;cAAhC,C;AAiCR,KA9ImF,CAgJpF;;;AACA,QAAI,SAAS,CAAC,MAAV,GAAmB,YAAvB,EAAqC;AACjC,UAAI,IAAI,GAAA,KAAA,CAAR;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,YAAY,GAAG,CAAf,GAAmB,SAAS,CAAC,MAAzC,CAAb;AACA,UAAM,UAAU,GAAG,IAAI,GAAG,IAAP,GAAc,CAAjC;;AACA,cAAQ,OAAO,CAAC,IAAhB;AACI,aAAK,CAAL;AAAQ;AACJ,YAAA,IAAI,GAAG,IAAI,UAAJ,CAAe,UAAf,CAAP;AACA;AACH;;AACD,aAAK,CAAL;AAAQ;AACJ,YAAA,IAAI,GAAG,IAAI,WAAJ,CAAgB,UAAhB,CAAP;AACA;AACH;;AACD,aAAK,CAAL;AAAQ;AACJ,YAAA,IAAI,GAAG,IAAI,YAAJ,CAAiB,UAAjB,CAAP;AACA;AACH;AAZL;;AAcA,WAAK,IAAI,CAAC,GAAG,SAAS,CAAC,MAAvB,EAA+B,CAAC,GAAG,YAAnC,EAAiD,CAAC,EAAlD,EAAsD;AAClD,aAAK,IAAI,IAAI,GAAG,CAAhB,EAAmB,IAAI,GAAG,CAA1B,EAA6B,IAAI,EAAjC,EAAqC;AACjC,UAAA,MAAM,CAAC,+BAAP,CAAuC,OAAvC,EAAgD,IAAhD,EAAuD,IAAvD,EAA6D,CAA7D;AACH;AACJ;AACJ,KAxKmF,CA0KpF;;;AACA,WAAO,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA2B,YAAA;AAC9B;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,MAAM,CAAC,0BAAP,CAAkC,OAAlC;;AACA,QAAA,MAAM,CAAC,eAAP,CAAuB,OAAvB;;AACA,QAAA,OAAO,CAAC,WAAR,CAAoB,OAApB;AACH,OAN6B,CAO9B;;;AACA,UAAI,eAAJ,EAAqB;AACjB,QAAA,eAAe,CAAC,OAAhB;AACH,OAV6B,CAW9B;;;AACA,UAAI,sBAAJ,EAA4B;AACxB,YAAI,OAAO,CAAC,eAAR,IAA2B,OAAO,CAAC,eAAR,CAAwB,QAAvD,EAAiE;AAC7D,UAAA,OAAO,CAAC,eAAR,CAAwB,QAAxB,CAAiC,OAAjC,GAA2C,IAA3C;AACH;;AACD,YAAI,OAAO,CAAC,cAAR,IAA0B,OAAO,CAAC,cAAR,CAAuB,QAArD,EAA+D;AAC3D,UAAA,OAAO,CAAC,cAAR,CAAuB,QAAvB,CAAgC,OAAhC,GAA0C,IAA1C;AACH;;AACD,YAAI,OAAO,CAAC,cAAR,IAA0B,OAAO,CAAC,cAAR,CAAuB,QAArD,EAA+D;AAC3D,UAAA,OAAO,CAAC,cAAR,CAAuB,QAAvB,CAAgC,OAAhC,GAA0C,IAA1C;AACH;AACJ;AACJ,KAvBM,CAAP;AAwBH,GAnMa;AAqMd;;;;;;;AAKc,EAAA,uBAAA,CAAA,kBAAA,GAAd,UAAiC,OAAjC,EAA2D,IAA3D,EAAuF;AACnF,QAAI,IAAI,CAAC,OAAL,KAAiB,CAArB,EAAwB;AACpB,MAAA,MAAM,CAAC,IAAP,CAAY,kDAAkD,IAAI,CAAC,OAAvD,GAAiE,GAA7E;AACH;;AAED,QAAI,cAAc,GAAG,IAAI,CAAC,UAA1B;;AACA,QAAI,CAAC,cAAL,EAAqB;AACjB;AACH;;AAED,QAAM,EAAE,GAAG,IAAI,mBAAJ,EAAX;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,CAAtC,EAAyC,CAAzC,EAA4C,EAAE,CAAC,CAA/C;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,CAAtC,EAAyC,CAAzC,EAA4C,EAAE,CAAC,CAA/C;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,CAAtC,EAAyC,CAAzC,EAA4C,EAAE,CAAC,CAA/C;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,cAAR,CAAuB,cAAc,CAAC,EAAtC,EAA0C,CAA1C,EAA6C,EAAE,CAAC,EAAhD;AACA,IAAA,OAAO,CAAC,oBAAR,GAA+B,EAA/B;AACH,GArBa;AAuBd;;;AACc,EAAA,uBAAA,CAAA,gBAAA,GAAd,UAA+B,eAA/B,EAAiE,IAAjE,EAA4F,mBAA5F,EAAgJ,QAAhJ,EAAkK,SAAlK,EAAmL;AAC/K,IAAA,eAAe,CAAC,OAAhB,GAA0B,qBAAqB,CAAC,WAAhD;AACA,IAAA,eAAe,CAAC,qBAAhB,GAAwC,IAAxC;AACA,IAAA,eAAe,CAAC,mBAAhB,GAAsC,QAAtC;AACA,IAAA,eAAe,CAAC,oBAAhB,GAAuC,SAAvC;AACA,IAAA,eAAe,CAAC,oBAAhB,GAAuC,mBAAvC;AAEA,WAAO,uBAAuB,CAAC,iBAAxB,CAA0C,eAA1C,EAA2D,IAA3D,EAAiE,IAAjE,CAAsE,YAAA;AACzE,MAAA,eAAe,CAAC,OAAhB,GAA0B,IAA1B;AACH,KAFM,CAAP;AAGH,GAVa;AAxiBd;;;;;AAGe,EAAA,uBAAA,CAAA,WAAA,GAAc,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAd;AAgjBnB,SAAA,uBAAA;AAAC,CArjBD,EAAA;;SAAa,uB,IAujBb;;AACA,eAAe,CAAC,gBAAhB,GAAmC,uBAAuB,CAAC,gBAA3D","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { Engine } from '../Engines/engine';\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport interface EnvironmentTextureInfo {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: number;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport class EnvironmentTextureTools {\r\n\r\n    /**\r\n     * Magic number identifying the env file.\r\n     */\r\n    private static _MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed.\r\n     */\r\n    public static GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfo> {\r\n        let dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        let pos = 0;\r\n\r\n        for (let i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\r\n            if (dataView.getUint8(pos++) !== EnvironmentTextureTools._MagicBytes[i]) {\r\n                Logger.Error('Not a babylon environment map');\r\n                return null;\r\n            }\r\n        }\r\n\r\n        // Read json manifest - collect characters up to null terminator\r\n        let manifestString = '';\r\n        let charCode = 0x00;\r\n        while ((charCode = dataView.getUint8(pos++))) {\r\n            manifestString += String.fromCharCode(charCode);\r\n        }\r\n\r\n        let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n        if (manifest.specular) {\r\n            // Extend the header with the position of the payload.\r\n            manifest.specular.specularDataPosition = pos;\r\n            // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n            manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n        }\r\n\r\n        return manifest;\r\n    }\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @return a promise containing the environment data if succesfull.\r\n     */\r\n    public static CreateEnvTextureAsync(texture: BaseTexture): Promise<ArrayBuffer> {\r\n        let internalTexture = texture.getInternalTexture();\r\n        if (!internalTexture) {\r\n            return Promise.reject(\"The cube texture is invalid.\");\r\n        }\r\n\r\n        let engine = internalTexture.getEngine() as Engine;\r\n        if (engine && engine.premultipliedAlpha) {\r\n            return Promise.reject(\"Env texture can only be created when the engine is created with the premultipliedAlpha option set to false.\");\r\n        }\r\n\r\n        if (texture.textureType === 0) {\r\n            return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n        }\r\n\r\n        let canvas = engine.getRenderingCanvas();\r\n        if (!canvas) {\r\n            return Promise.reject(\"Env texture can only be created when the engine is associated to a canvas.\");\r\n        }\r\n\r\n        let textureType = 1;\r\n        if (!engine.getCaps().textureFloatRender) {\r\n            textureType = 2;\r\n            if (!engine.getCaps().textureHalfFloatRender) {\r\n                return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n            }\r\n        }\r\n\r\n        let cubeWidth = internalTexture.width;\r\n        let hostingScene = new Scene(engine);\r\n        let specularTextures: { [key: number]: ArrayBuffer } = {};\r\n        let promises: Promise<void>[] = [];\r\n\r\n        // Read and collect all mipmaps data from the cube.\r\n        let mipmapsCount = Scalar.Log2(internalTexture.width);\r\n        mipmapsCount = Math.round(mipmapsCount);\r\n        for (let i = 0; i <= mipmapsCount; i++) {\r\n            let faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n            // All faces of the cube.\r\n            for (let face = 0; face < 6; face++) {\r\n                let data = texture.readPixels(face, i);\r\n\r\n                // Creates a temp texture with the face data.\r\n                let tempTexture = engine.createRawTexture(data, faceWidth, faceWidth, 5, false, false, 1, null, textureType);\r\n                // And rgbdEncode them.\r\n                let promise = new Promise<void>((resolve, reject) => {\r\n                    let rgbdPostProcess = new PostProcess(\"rgbdEncode\", \"rgbdEncode\", null, null, 1, null, 1, engine, false, undefined, 0, undefined, null, false);\r\n                    rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                        rgbdPostProcess.onApply = (effect) => {\r\n                            effect._bindTexture(\"textureSampler\", tempTexture);\r\n                        };\r\n\r\n                        // As the process needs to happen on the main canvas, keep track of the current size\r\n                        let currentW = engine.getRenderWidth();\r\n                        let currentH = engine.getRenderHeight();\r\n\r\n                        // Set the desired size for the texture\r\n                        engine.setSize(faceWidth, faceWidth);\r\n                        hostingScene.postProcessManager.directRender([rgbdPostProcess], null);\r\n\r\n                        // Reading datas from WebGL\r\n                        Tools.ToBlob(canvas!, (blob) => {\r\n                            let fileReader = new FileReader();\r\n                            fileReader.onload = (event: any) => {\r\n                                let arrayBuffer = event.target!.result as ArrayBuffer;\r\n                                specularTextures[i * 6 + face] = arrayBuffer;\r\n                                resolve();\r\n                            };\r\n                            fileReader.readAsArrayBuffer(blob!);\r\n                        });\r\n\r\n                        // Reapply the previous canvas size\r\n                        engine.setSize(currentW, currentH);\r\n                    });\r\n                });\r\n                promises.push(promise);\r\n            }\r\n        }\r\n\r\n        // Once all the textures haves been collected as RGBD stored in PNGs\r\n        return Promise.all(promises).then(() => {\r\n            // We can delete the hosting scene keeping track of all the creation objects\r\n            hostingScene.dispose();\r\n\r\n            // Creates the json header for the env texture\r\n            let info: EnvironmentTextureInfo = {\r\n                version: 1,\r\n                width: cubeWidth,\r\n                irradiance: this._CreateEnvTextureIrradiance(texture),\r\n                specular: {\r\n                    mipmaps: [],\r\n                    lodGenerationScale: texture.lodGenerationScale\r\n                }\r\n            };\r\n\r\n            // Sets the specular image data information\r\n            let position = 0;\r\n            for (let i = 0; i <= mipmapsCount; i++) {\r\n                for (let face = 0; face < 6; face++) {\r\n                    let byteLength = specularTextures[i * 6 + face].byteLength;\r\n                    info.specular.mipmaps.push({\r\n                        length: byteLength,\r\n                        position: position\r\n                    });\r\n                    position += byteLength;\r\n                }\r\n            }\r\n\r\n            // Encode the JSON as an array buffer\r\n            let infoString = JSON.stringify(info);\r\n            let infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n            let infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n            for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n                infoView[i] = infoString.charCodeAt(i);\r\n            }\r\n            // Ends up with a null terminator for easier parsing\r\n            infoView[infoString.length] = 0x00;\r\n\r\n            // Computes the final required size and creates the storage\r\n            let totalSize = EnvironmentTextureTools._MagicBytes.length + position + infoBuffer.byteLength;\r\n            let finalBuffer = new ArrayBuffer(totalSize);\r\n            let finalBufferView = new Uint8Array(finalBuffer);\r\n            let dataView = new DataView(finalBuffer);\r\n\r\n            // Copy the magic bytes identifying the file in\r\n            let pos = 0;\r\n            for (let i = 0; i < EnvironmentTextureTools._MagicBytes.length; i++) {\r\n                dataView.setUint8(pos++, EnvironmentTextureTools._MagicBytes[i]);\r\n            }\r\n\r\n            // Add the json info\r\n            finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n            pos += infoBuffer.byteLength;\r\n\r\n            // Finally inserts the texture data\r\n            for (let i = 0; i <= mipmapsCount; i++) {\r\n                for (let face = 0; face < 6; face++) {\r\n                    let dataBuffer = specularTextures[i * 6 + face];\r\n                    finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n                    pos += dataBuffer.byteLength;\r\n                }\r\n            }\r\n\r\n            // Voila\r\n            return finalBuffer;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a JSON representation of the spherical data.\r\n     * @param texture defines the texture containing the polynomials\r\n     * @return the JSON representation of the spherical info\r\n     */\r\n    private static _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n        let polynmials = texture.sphericalPolynomial;\r\n        if (polynmials == null) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n            y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n            z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n            xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n            yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n            zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n            yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n            zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n            xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\r\n        } as any;\r\n    }\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @return the views described by info providing access to the underlying buffer\r\n     */\r\n    public static CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n        if (info.version !== 1) {\r\n            throw new Error(`Unsupported babylon environment map version \"${info.version}\"`);\r\n        }\r\n\r\n        const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n        // Double checks the enclosed info\r\n        let mipmapsCount = Scalar.Log2(info.width);\r\n        mipmapsCount = Math.round(mipmapsCount) + 1;\r\n        if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n            throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n        }\r\n\r\n        const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n        for (let i = 0; i < mipmapsCount; i++) {\r\n            imageData[i] = new Array<ArrayBufferView>(6);\r\n            for (let face = 0; face < 6; face++) {\r\n                const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n                imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n            }\r\n        }\r\n\r\n        return imageData;\r\n    }\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    public static UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n        if (info.version !== 1) {\r\n            throw new Error(`Unsupported babylon environment map version \"${info.version}\"`);\r\n        }\r\n\r\n        const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n        if (!specularInfo) {\r\n            // Nothing else parsed so far\r\n            return Promise.resolve();\r\n        }\r\n\r\n        texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n        const imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);\r\n\r\n        return EnvironmentTextureTools.UploadLevelsAsync(texture, imageData);\r\n    }\r\n\r\n    private static _OnImageReadyAsync(image: HTMLImageElement | ImageBitmap, engine: Engine, expandTexture: boolean,\r\n        rgbdPostProcess:  Nullable<PostProcess>, url: string, face: number, i: number, generateNonLODTextures: boolean,\r\n        lodTextures: Nullable<{ [lod: number]: BaseTexture }>, cubeRtt: Nullable<InternalTexture>, texture: InternalTexture\r\n        ): Promise<void> {\r\n            return new Promise((resolve, reject) => {\r\n                if (expandTexture) {\r\n                    let tempTexture = engine.createTexture(null, true, true, null, 1, null,\r\n                        (message) => {\r\n                            reject(message);\r\n                        },\r\n                        image);\r\n\r\n                    rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                        // Uncompress the data to a RTT\r\n                        rgbdPostProcess!.onApply = (effect) => {\r\n                            effect._bindTexture(\"textureSampler\", tempTexture);\r\n                            effect.setFloat2(\"scale\", 1, 1);\r\n                        };\r\n\r\n                        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                        // Cleanup\r\n                        engine.restoreDefaultFramebuffer();\r\n                        tempTexture.dispose();\r\n                        URL.revokeObjectURL(url);\r\n                        resolve();\r\n                    });\r\n                }\r\n                else {\r\n                    engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n                    // Upload the face to the non lod texture support\r\n                    if (generateNonLODTextures) {\r\n                        let lodTexture = lodTextures![i];\r\n                        if (lodTexture) {\r\n                            engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                        }\r\n                    }\r\n                    resolve();\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @returns a promise\r\n     */\r\n    public static UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][]): Promise<void> {\r\n        if (!Tools.IsExponentOfTwo(texture.width)) {\r\n            throw new Error(\"Texture size must be a power of two\");\r\n        }\r\n\r\n        const mipmapsCount = Math.round(Scalar.Log2(texture.width)) + 1;\r\n\r\n        // Gets everything ready.\r\n        let engine = texture.getEngine() as Engine;\r\n        let expandTexture = false;\r\n        let generateNonLODTextures = false;\r\n        let rgbdPostProcess: Nullable<PostProcess> = null;\r\n        let cubeRtt: Nullable<InternalTexture> = null;\r\n        let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n        let caps = engine.getCaps();\r\n\r\n        texture.format = 5;\r\n        texture.type = 0;\r\n        texture.generateMipMaps = true;\r\n        texture._cachedAnisotropicFilteringLevel = null;\r\n        engine.updateTextureSamplingMode(3, texture);\r\n\r\n        // Add extra process if texture lod is not supported\r\n        if (!caps.textureLOD) {\r\n            expandTexture = false;\r\n            generateNonLODTextures = true;\r\n            lodTextures = {};\r\n        }\r\n        // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n        else if (engine.webGLVersion < 2) {\r\n            expandTexture = false;\r\n        }\r\n        // If half float available we can uncompress the texture\r\n        else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            texture.type = 2;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            texture.type = 1;\r\n        }\r\n\r\n        // Expand the texture if possible\r\n        if (expandTexture) {\r\n            // Simply run through the decode PP\r\n            rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\r\n\r\n            texture._isRGBD = false;\r\n            texture.invertY = false;\r\n            cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: true,\r\n                generateStencilBuffer: false,\r\n                samplingMode: 3,\r\n                type: texture.type,\r\n                format: 5\r\n            });\r\n        }\r\n        else {\r\n            texture._isRGBD = true;\r\n            texture.invertY = true;\r\n\r\n            // In case of missing support, applies the same patch than DDS files.\r\n            if (generateNonLODTextures) {\r\n                let mipSlices = 3;\r\n                let scale = texture._lodGenerationScale;\r\n                let offset = texture._lodGenerationOffset;\r\n\r\n                for (let i = 0; i < mipSlices; i++) {\r\n                    //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                    let smoothness = i / (mipSlices - 1);\r\n                    let roughness = 1 - smoothness;\r\n\r\n                    let minLODIndex = offset; // roughness = 0\r\n                    let maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                    let lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                    let mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                    let glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                    glTextureFromLod.isCube = true;\r\n                    glTextureFromLod.invertY = true;\r\n                    glTextureFromLod.generateMipMaps = false;\r\n                    engine.updateTextureSamplingMode(2, glTextureFromLod);\r\n\r\n                    // Wrap in a base texture for easy binding.\r\n                    let lodTexture = new BaseTexture(null);\r\n                    lodTexture.isCube = true;\r\n                    lodTexture._texture = glTextureFromLod;\r\n                    lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                    switch (i) {\r\n                        case 0:\r\n                            texture._lodTextureLow = lodTexture;\r\n                            break;\r\n                        case 1:\r\n                            texture._lodTextureMid = lodTexture;\r\n                            break;\r\n                        case 2:\r\n                            texture._lodTextureHigh = lodTexture;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let promises: Promise<void>[] = [];\r\n        // All mipmaps up to provided number of images\r\n        for (let i = 0; i < imageData.length; i++) {\r\n            // All faces\r\n            for (let face = 0; face < 6; face++) {\r\n                // Constructs an image element from image data\r\n                let bytes = imageData[i][face];\r\n                let blob = new Blob([bytes], { type: 'image/png' });\r\n                let url = URL.createObjectURL(blob);\r\n                let promise: Promise<void>;\r\n\r\n                if (typeof Image === \"undefined\") {\r\n                    promise = createImageBitmap(blob).then((img) => {\r\n                        return this._OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                    });\r\n                } else {\r\n                    let image = new Image();\r\n                    image.src = url;\r\n\r\n                    // Enqueue promise to upload to the texture.\r\n                    promise = new Promise<void>((resolve, reject) => {\r\n                        image.onload = () => {\r\n                            this._OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                        };\r\n                        image.onerror = (error) => {\r\n                            reject(error);\r\n                        };\r\n                    });\r\n                }\r\n                promises.push(promise);\r\n            }\r\n        }\r\n\r\n        // Fill remaining mipmaps with black textures.\r\n        if (imageData.length < mipmapsCount) {\r\n            let data: ArrayBufferView;\r\n            const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n            const dataLength = size * size * 4;\r\n            switch (texture.type) {\r\n                case 0: {\r\n                    data = new Uint8Array(dataLength);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    data = new Uint16Array(dataLength);\r\n                    break;\r\n                }\r\n                case 1: {\r\n                    data = new Float32Array(dataLength);\r\n                    break;\r\n                }\r\n            }\r\n            for (let i = imageData.length; i < mipmapsCount; i++) {\r\n                for (let face = 0; face < 6; face++) {\r\n                    engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Once all done, finishes the cleanup and return\r\n        return Promise.all(promises).then(() => {\r\n            // Release temp RTT.\r\n            if (cubeRtt) {\r\n                engine._releaseFramebufferObjects(cubeRtt);\r\n                engine._releaseTexture(texture);\r\n                cubeRtt._swapAndDie(texture);\r\n            }\r\n            // Release temp Post Process.\r\n            if (rgbdPostProcess) {\r\n                rgbdPostProcess.dispose();\r\n            }\r\n            // Flag internal texture as ready in case they are in use.\r\n            if (generateNonLODTextures) {\r\n                if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                    texture._lodTextureHigh._texture.isReady = true;\r\n                }\r\n                if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                    texture._lodTextureMid._texture.isReady = true;\r\n                }\r\n                if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                    texture._lodTextureLow._texture.isReady = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    public static UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n        if (info.version !== 1) {\r\n            Logger.Warn('Unsupported babylon environment map version \"' + info.version + '\"');\r\n        }\r\n\r\n        let irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n        if (!irradianceInfo) {\r\n            return;\r\n        }\r\n\r\n        const sp = new SphericalPolynomial();\r\n        Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n        Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n        Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n        Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n        Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n        Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n        Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n        Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n        Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n        texture._sphericalPolynomial = sp;\r\n    }\r\n\r\n    /** @hidden */\r\n    public static _UpdateRGBDAsync(internalTexture: InternalTexture, data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial>, lodScale: number, lodOffset: number): Promise<void> {\r\n        internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n        internalTexture._bufferViewArrayArray = data;\r\n        internalTexture._lodGenerationScale = lodScale;\r\n        internalTexture._lodGenerationOffset = lodOffset;\r\n        internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n        return EnvironmentTextureTools.UploadLevelsAsync(internalTexture, data).then(() => {\r\n            internalTexture.isReady = true;\r\n        });\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nInternalTexture._UpdateRGBDAsync = EnvironmentTextureTools._UpdateRGBDAsync;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}