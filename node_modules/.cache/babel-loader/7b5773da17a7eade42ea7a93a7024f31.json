{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\nimport { AbstractScene } from \"../abstractScene\";\nimport { Engine } from \"../Engines/engine\";\nimport { ParticleSystem } from \"./particleSystem\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport \"../Shaders/particles.vertex\"; // Adds the parsers to the scene parsers.\n\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedData, scene, container, rootUrl) {\n  var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n\n  if (!individualParser) {\n    return;\n  } // Particles Systems\n\n\n  if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n    for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n      var parsedParticleSystem = parsedData.particleSystems[index];\n      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\n    }\n  }\n});\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedParticleSystem, scene, rootUrl) {\n  if (parsedParticleSystem.activeParticleCount) {\n    var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  } else {\n    var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  }\n});\n\nEngine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError, particleSystem) {\n  var _a;\n\n  if (uniformsNames === void 0) {\n    uniformsNames = [];\n  }\n\n  if (samplers === void 0) {\n    samplers = [];\n  }\n\n  if (defines === void 0) {\n    defines = \"\";\n  }\n\n  var attributesNamesOrOptions = [];\n  var effectCreationOption = [];\n  var allSamplers = [];\n\n  if (particleSystem) {\n    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\n  } else {\n    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\n    effectCreationOption = ParticleSystem._GetEffectCreationOptions();\n  }\n\n  if (defines.indexOf(\" BILLBOARD\") === -1) {\n    defines += \"\\n#define BILLBOARD\\n\";\n  }\n\n  if (samplers.indexOf(\"diffuseSampler\") === -1) {\n    samplers.push(\"diffuseSampler\");\n  }\n\n  return this.createEffect({\n    vertex: (_a = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a !== void 0 ? _a : \"particles\",\n    fragmentElement: fragmentName\n  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\n};\n\nMesh.prototype.getEmittedParticleSystems = function () {\n  var results = new Array();\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n\n    if (particleSystem.emitter === this) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};\n\nMesh.prototype.getHierarchyEmittedParticleSystems = function () {\n  var results = new Array();\n  var descendants = this.getDescendants();\n  descendants.push(this);\n\n  for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n    var particleSystem = this.getScene().particleSystems[index];\n    var emitter = particleSystem.emitter;\n\n    if (emitter.position && descendants.indexOf(emitter) !== -1) {\n      results.push(particleSystem);\n    }\n  }\n\n  return results;\n};","map":{"version":3,"sources":["../../../sourceES6/core/Particles/particleSystemComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Mesh } from \"../Meshes/mesh\";\r\nimport { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { Scene } from \"../scene\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"../Shaders/particles.vertex\";\r\nimport { EffectFallbacks } from '../Materials/effectFallbacks';\r\n\r\n// Adds the parsers to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n\r\n    let individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n\r\n    if (!individualParser) {\r\n        return;\r\n    }\r\n\r\n    // Particles Systems\r\n    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n        for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n            var parsedParticleSystem = parsedData.particleSystems[index];\r\n            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\r\n        }\r\n    }\r\n});\r\n\r\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem: any, scene: Scene, rootUrl: string) => {\r\n    if (parsedParticleSystem.activeParticleCount) {\r\n        let ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    } else {\r\n        let ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    }\r\n});\r\n\r\ndeclare module \"../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Create an effect to use with particle systems.\r\n         * Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass\r\n         * the particle system for which you want to create a custom effect in the last parameter\r\n         * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)\r\n         * @param uniformsNames defines a list of attribute names\r\n         * @param samplers defines an array of string used to represent textures\r\n         * @param defines defines the string containing the defines to use to compile the shaders\r\n         * @param fallbacks defines the list of potential fallbacks to use if shader conmpilation fails\r\n         * @param onCompiled defines a function to call when the effect creation is successful\r\n         * @param onError defines a function to call when the effect creation has failed\r\n         * @param particleSystem the particle system you want to create the effect for\r\n         * @returns the new Effect\r\n         */\r\n        createEffectForParticles(fragmentName: string, uniformsNames: string[], samplers: string[], defines: string, fallbacks?: EffectFallbacks,\r\n            onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, particleSystem?: IParticleSystem): Effect;\r\n    }\r\n}\r\n\r\nEngine.prototype.createEffectForParticles = function(fragmentName: string, uniformsNames: string[] = [], samplers: string[] = [], defines = \"\", fallbacks?: EffectFallbacks,\r\n    onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, particleSystem?: IParticleSystem): Effect {\r\n\r\n    var attributesNamesOrOptions: Array<string> = [];\r\n    var effectCreationOption: Array<string> = [];\r\n    var allSamplers: Array<string> = [];\r\n\r\n    if (particleSystem) {\r\n        particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\r\n    } else {\r\n        attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\r\n        effectCreationOption = ParticleSystem._GetEffectCreationOptions();\r\n    }\r\n\r\n    if (defines.indexOf(\" BILLBOARD\") === -1) {\r\n        defines += \"\\n#define BILLBOARD\\n\";\r\n    }\r\n\r\n    if (samplers.indexOf(\"diffuseSampler\") === -1) {\r\n        samplers.push(\"diffuseSampler\");\r\n    }\r\n\r\n    return this.createEffect(\r\n        {\r\n            vertex: particleSystem?.vertexShaderName ?? \"particles\",\r\n            fragmentElement: fragmentName\r\n        },\r\n        attributesNamesOrOptions,\r\n        effectCreationOption.concat(uniformsNames),\r\n        allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\r\n};\r\n\r\ndeclare module \"../Meshes/mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh is the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getEmittedParticleSystems(): IParticleSystem[];\r\n\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getHierarchyEmittedParticleSystems(): IParticleSystem[];\r\n    }\r\n}\r\n\r\nMesh.prototype.getEmittedParticleSystems = function(): IParticleSystem[] {\r\n    var results = new Array<IParticleSystem>();\r\n    for (var index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        var particleSystem = this.getScene().particleSystems[index];\r\n        if (particleSystem.emitter === this) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n    return results;\r\n};\r\n\r\nMesh.prototype.getHierarchyEmittedParticleSystems = function(): IParticleSystem[] {\r\n    var results = new Array<IParticleSystem>();\r\n    var descendants = this.getDescendants();\r\n    descendants.push(this);\r\n\r\n    for (var index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        var particleSystem = this.getScene().particleSystems[index];\r\n        let emitter: any = particleSystem.emitter;\r\n\r\n        if (emitter.position && descendants.indexOf(emitter) !== -1) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}