{"ast":null,"code":"/**\r\n * Class used to evalaute queries containing `and` and `or` operators\r\n */\nvar AndOrNotEvaluator =\n/** @class */\nfunction () {\n  function AndOrNotEvaluator() {}\n  /**\r\n   * Evaluate a query\r\n   * @param query defines the query to evaluate\r\n   * @param evaluateCallback defines the callback used to filter result\r\n   * @returns true if the query matches\r\n   */\n\n\n  AndOrNotEvaluator.Eval = function (query, evaluateCallback) {\n    if (!query.match(/\\([^\\(\\)]*\\)/g)) {\n      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n    } else {\n      query = query.replace(/\\([^\\(\\)]*\\)/g, function (r) {\n        // remove parenthesis\n        r = r.slice(1, r.length - 1);\n        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n      });\n    }\n\n    if (query === \"true\") {\n      return true;\n    }\n\n    if (query === \"false\") {\n      return false;\n    }\n\n    return AndOrNotEvaluator.Eval(query, evaluateCallback);\n  };\n\n  AndOrNotEvaluator._HandleParenthesisContent = function (parenthesisContent, evaluateCallback) {\n    evaluateCallback = evaluateCallback || function (r) {\n      return r === \"true\" ? true : false;\n    };\n\n    var result;\n    var or = parenthesisContent.split(\"||\");\n\n    for (var i in or) {\n      if (or.hasOwnProperty(i)) {\n        var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n\n        var and = ori.split(\"&&\");\n\n        if (and.length > 1) {\n          for (var j = 0; j < and.length; ++j) {\n            var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n\n            if (andj !== \"true\" && andj !== \"false\") {\n              if (andj[0] === \"!\") {\n                result = !evaluateCallback(andj.substring(1));\n              } else {\n                result = evaluateCallback(andj);\n              }\n            } else {\n              result = andj === \"true\" ? true : false;\n            }\n\n            if (!result) {\n              // no need to continue since 'false && ... && ...' will always return false\n              ori = \"false\";\n              break;\n            }\n          }\n        }\n\n        if (result || ori === \"true\") {\n          // no need to continue since 'true || ... || ...' will always return true\n          result = true;\n          break;\n        } // result equals false (or undefined)\n\n\n        if (ori !== \"true\" && ori !== \"false\") {\n          if (ori[0] === \"!\") {\n            result = !evaluateCallback(ori.substring(1));\n          } else {\n            result = evaluateCallback(ori);\n          }\n        } else {\n          result = ori === \"true\" ? true : false;\n        }\n      }\n    } // the whole parenthesis scope is replaced by 'true' or 'false'\n\n\n    return result ? \"true\" : \"false\";\n  };\n\n  AndOrNotEvaluator._SimplifyNegation = function (booleanString) {\n    booleanString = booleanString.replace(/^[\\s!]+/, function (r) {\n      // remove whitespaces\n      r = r.replace(/[\\s]/g, function () {\n        return \"\";\n      });\n      return r.length % 2 ? \"!\" : \"\";\n    });\n    booleanString = booleanString.trim();\n\n    if (booleanString === \"!true\") {\n      booleanString = \"false\";\n    } else if (booleanString === \"!false\") {\n      booleanString = \"true\";\n    }\n\n    return booleanString;\n  };\n\n  return AndOrNotEvaluator;\n}();\n\nexport { AndOrNotEvaluator };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/andOrNotEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Class used to evalaute queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^\\(\\)]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        }\r\n        else {\r\n            query = query.replace(/\\([^\\(\\)]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback = evaluateCallback || ((r) => {\r\n            return r === \"true\" ? true : false;\r\n        });\r\n\r\n        var result;\r\n        var or = parenthesisContent.split(\"||\");\r\n\r\n        for (var i in or) {\r\n            if (or.hasOwnProperty(i)) {\r\n                var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                var and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (var j = 0; j < and.length; ++j) {\r\n                        var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            }\r\n                            else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        }\r\n                        else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) { // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") { // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    }\r\n                    else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                }\r\n                else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        }\r\n        else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}