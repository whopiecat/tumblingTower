{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nNode.AddNodeConstructor(\"Light_Type_1\", function (name, scene) {\n  return function () {\n    return new DirectionalLight(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/babylon101/lights\r\n */\n\nvar DirectionalLight =\n/** @class */\nfunction (_super) {\n  __extends(DirectionalLight, _super);\n  /**\r\n   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n   * The directional light is emitted from everywhere in the given direction.\r\n   * It can cast shadows.\r\n   * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n   * @param name The friendly name of the light\r\n   * @param direction The direction of the light\r\n   * @param scene The scene the light belongs to\r\n   */\n\n\n  function DirectionalLight(name, direction, scene) {\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._shadowFrustumSize = 0;\n    _this._shadowOrthoScale = 0.1;\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\n\n    _this.autoUpdateExtends = true;\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\n\n    _this.autoCalcShadowZBounds = false; // Cache\n\n    _this._orthoLeft = Number.MAX_VALUE;\n    _this._orthoRight = Number.MIN_VALUE;\n    _this._orthoTop = Number.MIN_VALUE;\n    _this._orthoBottom = Number.MAX_VALUE;\n    _this.position = direction.scale(-1.0);\n    _this.direction = direction;\n    return _this;\n  }\n\n  Object.defineProperty(DirectionalLight.prototype, \"shadowFrustumSize\", {\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\n    get: function () {\n      return this._shadowFrustumSize;\n    },\n\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\n    set: function (value) {\n      this._shadowFrustumSize = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DirectionalLight.prototype, \"shadowOrthoScale\", {\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\n    get: function () {\n      return this._shadowOrthoScale;\n    },\n\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\n    set: function (value) {\n      this._shadowOrthoScale = value;\n      this.forceProjectionMatrixCompute();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"DirectionalLight\".\r\n   * @return The class name\r\n   */\n\n  DirectionalLight.prototype.getClassName = function () {\n    return \"DirectionalLight\";\n  };\n  /**\r\n   * Returns the integer 1.\r\n   * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n   */\n\n\n  DirectionalLight.prototype.getTypeID = function () {\n    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    if (this.shadowFrustumSize > 0) {\n      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n    } else {\n      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function (matrix) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    }\n\n    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n  };\n  /**\r\n   * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n   * Returns the DirectionalLight Shadow projection matrix.\r\n   */\n\n\n  DirectionalLight.prototype._setDefaultAutoExtendShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n    var activeCamera = this.getScene().activeCamera;\n\n    if (!activeCamera) {\n      return;\n    } // Check extends\n\n\n    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n      var tempVector3 = Vector3.Zero();\n      this._orthoLeft = Number.MAX_VALUE;\n      this._orthoRight = Number.MIN_VALUE;\n      this._orthoTop = Number.MIN_VALUE;\n      this._orthoBottom = Number.MAX_VALUE;\n      var shadowMinZ = Number.MAX_VALUE;\n      var shadowMaxZ = Number.MIN_VALUE;\n\n      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        var mesh = renderList[meshIndex];\n\n        if (!mesh) {\n          continue;\n        }\n\n        var boundingInfo = mesh.getBoundingInfo();\n        var boundingBox = boundingInfo.boundingBox;\n\n        for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\n          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n\n          if (tempVector3.x < this._orthoLeft) {\n            this._orthoLeft = tempVector3.x;\n          }\n\n          if (tempVector3.y < this._orthoBottom) {\n            this._orthoBottom = tempVector3.y;\n          }\n\n          if (tempVector3.x > this._orthoRight) {\n            this._orthoRight = tempVector3.x;\n          }\n\n          if (tempVector3.y > this._orthoTop) {\n            this._orthoTop = tempVector3.y;\n          }\n\n          if (this.autoCalcShadowZBounds) {\n            if (tempVector3.z < shadowMinZ) {\n              shadowMinZ = tempVector3.z;\n            }\n\n            if (tempVector3.z > shadowMaxZ) {\n              shadowMaxZ = tempVector3.z;\n            }\n          }\n        }\n      }\n\n      if (this.autoCalcShadowZBounds) {\n        this._shadowMinZ = shadowMinZ;\n        this._shadowMaxZ = shadowMaxZ;\n      }\n    }\n\n    var xOffset = this._orthoRight - this._orthoLeft;\n    var yOffset = this._orthoTop - this._orthoBottom;\n    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n  };\n\n  DirectionalLight.prototype._buildUniformLayout = function () {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n\n    this._uniformBuffer.create();\n  };\n  /**\r\n   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n   * @param effect The effect to update\r\n   * @param lightIndex The index of the light in the effect to update\r\n   * @returns The directional light\r\n   */\n\n\n  DirectionalLight.prototype.transferToEffect = function (effect, lightIndex) {\n    if (this.computeTransformedInformation()) {\n      this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n\n      return this;\n    }\n\n    this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n\n    return this;\n  };\n\n  DirectionalLight.prototype.transferToNodeMaterialEffect = function (effect, lightDataUniformName) {\n    if (this.computeTransformedInformation()) {\n      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n      return this;\n    }\n\n    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n    return this;\n  };\n  /**\r\n   * Gets the minZ used for shadow according to both the scene and the light.\r\n   *\r\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n   * @param activeCamera The camera we are returning the min for\r\n   * @returns the depth min z\r\n   */\n\n\n  DirectionalLight.prototype.getDepthMinZ = function (activeCamera) {\n    return 1;\n  };\n  /**\r\n   * Gets the maxZ used for shadow according to both the scene and the light.\r\n   *\r\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n   * @param activeCamera The camera we are returning the max for\r\n   * @returns the depth max z\r\n   */\n\n\n  DirectionalLight.prototype.getDepthMaxZ = function (activeCamera) {\n    return 1;\n  };\n  /**\r\n   * Prepares the list of defines specific to the light type.\r\n   * @param defines the list of defines\r\n   * @param lightIndex defines the index of the light for the effect\r\n   */\n\n\n  DirectionalLight.prototype.prepareLightSpecificDefines = function (defines, lightIndex) {\n    defines[\"DIRLIGHT\" + lightIndex] = true;\n  };\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n\n  __decorate([serialize()], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n\n  return DirectionalLight;\n}(ShadowLight);\n\nexport { DirectionalLight };","map":{"version":3,"sources":["../../../sourceES6/core/Lights/directionalLight.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/babylon101/lights\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        }\r\n        else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        var activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        var activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            var tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = Number.MIN_VALUE;\r\n            this._orthoTop = Number.MIN_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            var shadowMinZ = Number.MAX_VALUE;\r\n            var shadowMaxZ = Number.MIN_VALUE;\r\n\r\n            for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                var mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                var boundingInfo = mesh.getBoundingInfo();\r\n                var boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        var xOffset = this._orthoRight - this._orthoLeft;\r\n        var yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}