{"ast":null,"code":"import { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\n\nVertexData.CreateDisc = function (options) {\n  var positions = new Array();\n  var indices = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var radius = options.radius || 0.5;\n  var tessellation = options.tessellation || 64;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE; // positions and uvs\n\n  positions.push(0, 0, 0); // disc center first\n\n  uvs.push(0.5, 0.5);\n  var theta = Math.PI * 2 * arc;\n  var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\n  var a = 0;\n\n  for (var t = 0; t < tessellation; t++) {\n    var x = Math.cos(a);\n    var y = Math.sin(a);\n    var u = (x + 1) / 2;\n    var v = (1 - y) / 2;\n    positions.push(radius * x, radius * y, 0);\n    uvs.push(u, v);\n    a += step;\n  }\n\n  if (arc === 1) {\n    positions.push(positions[3], positions[4], positions[5]); // close the circle\n\n    uvs.push(uvs[2], uvs[3]);\n  } //indices\n\n\n  var vertexNb = positions.length / 3;\n\n  for (var i = 1; i < vertexNb - 1; i++) {\n    indices.push(i + 1, 0, i);\n  } // result\n\n\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n};\n\nMesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\n  if (scene === void 0) {\n    scene = null;\n  }\n\n  var options = {\n    radius: radius,\n    tessellation: tessellation,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return DiscBuilder.CreateDisc(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar DiscBuilder =\n/** @class */\nfunction () {\n  function DiscBuilder() {}\n  /**\r\n   * Creates a plane polygonal mesh.  By default, this is a disc\r\n   * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n   * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n   * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the plane polygonal mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n   */\n\n\n  DiscBuilder.CreateDisc = function (name, options, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var disc = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    disc._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateDisc(options);\n    vertexData.applyToMesh(disc, options.updatable);\n    return disc;\n  };\n\n  return DiscBuilder;\n}();\n\nexport { DiscBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/discBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\nVertexData.CreateDisc = function(options: { radius?: number, tessellation?: number, arc?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var positions = new Array<number>();\r\n    var indices = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n\r\n    var radius = options.radius || 0.5;\r\n    var tessellation = options.tessellation || 64;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0);    // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    var theta = Math.PI * 2 * arc;\r\n    var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    var a = 0;\r\n    for (var t = 0; t < tessellation; t++) {\r\n        var x = Math.cos(a);\r\n        var y = Math.sin(a);\r\n        var u = (x + 1) / 2;\r\n        var v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    var vertexNb = positions.length / 3;\r\n    for (var i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return DiscBuilder.CreateDisc(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class DiscBuilder {\r\n    /**\r\n     * Creates a plane polygonal mesh.  By default, this is a disc\r\n     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane polygonal mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n     */\r\n    public static CreateDisc(name: string, options: { radius?: number, tessellation?: number, arc?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: Nullable<Scene> = null): Mesh {\r\n        var disc = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateDisc(options);\r\n\r\n        vertexData.applyToMesh(disc, options.updatable);\r\n\r\n        return disc;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}