{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebRequest } from './webRequest';\nimport { DomManagement } from './domManagement';\nimport { Observable } from './observable';\nimport { FilesInputStore } from './filesInputStore';\nimport { RetryStrategy } from './retryStrategy';\nimport { BaseError } from './baseError';\nimport { StringTools } from './stringTools';\nimport { ThinEngine } from '../Engines/thinEngine';\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\n/** @ignore */\n\nvar LoadFileError =\n/** @class */\nfunction (_super) {\n  __extends(LoadFileError, _super);\n  /**\r\n   * Creates a new LoadFileError\r\n   * @param message defines the message of the error\r\n   * @param request defines the optional web request\r\n   * @param file defines the optional file\r\n   */\n\n\n  function LoadFileError(message, object) {\n    var _this = _super.call(this, message) || this;\n\n    _this.name = \"LoadFileError\";\n\n    BaseError._setPrototypeOf(_this, LoadFileError.prototype);\n\n    if (object instanceof WebRequest) {\n      _this.request = object;\n    } else {\n      _this.file = object;\n    }\n\n    return _this;\n  }\n\n  return LoadFileError;\n}(BaseError);\n\nexport { LoadFileError };\n/** @ignore */\n\nvar RequestFileError =\n/** @class */\nfunction (_super) {\n  __extends(RequestFileError, _super);\n  /**\r\n   * Creates a new LoadFileError\r\n   * @param message defines the message of the error\r\n   * @param request defines the optional web request\r\n   */\n\n\n  function RequestFileError(message, request) {\n    var _this = _super.call(this, message) || this;\n\n    _this.request = request;\n    _this.name = \"RequestFileError\";\n\n    BaseError._setPrototypeOf(_this, RequestFileError.prototype);\n\n    return _this;\n  }\n\n  return RequestFileError;\n}(BaseError);\n\nexport { RequestFileError };\n/** @ignore */\n\nvar ReadFileError =\n/** @class */\nfunction (_super) {\n  __extends(ReadFileError, _super);\n  /**\r\n   * Creates a new ReadFileError\r\n   * @param message defines the message of the error\r\n   * @param file defines the optional file\r\n   */\n\n\n  function ReadFileError(message, file) {\n    var _this = _super.call(this, message) || this;\n\n    _this.file = file;\n    _this.name = \"ReadFileError\";\n\n    BaseError._setPrototypeOf(_this, ReadFileError.prototype);\n\n    return _this;\n  }\n\n  return ReadFileError;\n}(BaseError);\n\nexport { ReadFileError };\n/**\r\n * @hidden\r\n */\n\nvar FileTools =\n/** @class */\nfunction () {\n  function FileTools() {}\n  /**\r\n   * Removes unwanted characters from an url\r\n   * @param url defines the url to clean\r\n   * @returns the cleaned url\r\n   */\n\n\n  FileTools._CleanUrl = function (url) {\n    url = url.replace(/#/mg, \"%23\");\n    return url;\n  };\n  /**\r\n   * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n   * @param url define the url we are trying\r\n   * @param element define the dom element where to configure the cors policy\r\n   */\n\n\n  FileTools.SetCorsBehavior = function (url, element) {\n    if (url && url.indexOf(\"data:\") === 0) {\n      return;\n    }\n\n    if (FileTools.CorsBehavior) {\n      if (typeof FileTools.CorsBehavior === 'string' || this.CorsBehavior instanceof String) {\n        element.crossOrigin = FileTools.CorsBehavior;\n      } else {\n        var result = FileTools.CorsBehavior(url);\n\n        if (result) {\n          element.crossOrigin = result;\n        }\n      }\n    }\n  };\n  /**\r\n   * Loads an image as an HTMLImageElement.\r\n   * @param input url string, ArrayBuffer, or Blob to load\r\n   * @param onLoad callback called when the image successfully loads\r\n   * @param onError callback called when the image fails to load\r\n   * @param offlineProvider offline provider for caching\r\n   * @param mimeType optional mime type\r\n   * @returns the HTMLImageElement of the loaded image\r\n   */\n\n\n  FileTools.LoadImage = function (input, onLoad, onError, offlineProvider, mimeType) {\n    if (mimeType === void 0) {\n      mimeType = \"\";\n    }\n\n    var url;\n    var usingObjectURL = false;\n\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n      if (typeof Blob !== 'undefined') {\n        url = URL.createObjectURL(new Blob([input], {\n          type: mimeType\n        }));\n        usingObjectURL = true;\n      } else {\n        url = \"data:\" + mimeType + \";base64,\" + StringTools.EncodeArrayBufferToBase64(input);\n      }\n    } else if (input instanceof Blob) {\n      url = URL.createObjectURL(input);\n      usingObjectURL = true;\n    } else {\n      url = FileTools._CleanUrl(input);\n      url = FileTools.PreprocessUrl(input);\n    }\n\n    if (typeof Image === \"undefined\") {\n      FileTools.LoadFile(url, function (data) {\n        createImageBitmap(new Blob([data], {\n          type: mimeType\n        })).then(function (imgBmp) {\n          onLoad(imgBmp);\n\n          if (usingObjectURL) {\n            URL.revokeObjectURL(url);\n          }\n        }).catch(function (reason) {\n          if (onError) {\n            onError(\"Error while trying to load image: \" + input, reason);\n          }\n        });\n      }, undefined, offlineProvider || undefined, true, function (request, exception) {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, exception);\n        }\n      });\n      return null;\n    }\n\n    var img = new Image();\n    FileTools.SetCorsBehavior(url, img);\n\n    var loadHandler = function () {\n      img.removeEventListener(\"load\", loadHandler);\n      img.removeEventListener(\"error\", errorHandler);\n      onLoad(img); // Must revoke the URL after calling onLoad to avoid security exceptions in\n      // certain scenarios (e.g. when hosted in vscode).\n\n      if (usingObjectURL && img.src) {\n        URL.revokeObjectURL(img.src);\n      }\n    };\n\n    var errorHandler = function (err) {\n      img.removeEventListener(\"load\", loadHandler);\n      img.removeEventListener(\"error\", errorHandler);\n\n      if (onError) {\n        var inputText = input.toString();\n        onError(\"Error while trying to load image: \" + (inputText.length < 32 ? inputText : inputText.slice(0, 32) + \"...\"), err);\n      }\n\n      if (usingObjectURL && img.src) {\n        URL.revokeObjectURL(img.src);\n      }\n    };\n\n    img.addEventListener(\"load\", loadHandler);\n    img.addEventListener(\"error\", errorHandler);\n\n    var noOfflineSupport = function () {\n      img.src = url;\n    };\n\n    var loadFromOfflineSupport = function () {\n      if (offlineProvider) {\n        offlineProvider.loadImage(url, img);\n      }\n    };\n\n    if (url.substr(0, 5) !== \"data:\" && offlineProvider && offlineProvider.enableTexturesOffline) {\n      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    } else {\n      if (url.indexOf(\"file:\") !== -1) {\n        var textureName = decodeURIComponent(url.substring(5).toLowerCase());\n\n        if (FilesInputStore.FilesToLoad[textureName]) {\n          try {\n            var blobURL;\n\n            try {\n              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n            } catch (ex) {\n              // Chrome doesn't support oneTimeOnly parameter\n              blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n            }\n\n            img.src = blobURL;\n            usingObjectURL = true;\n          } catch (e) {\n            img.src = \"\";\n          }\n\n          return img;\n        }\n      }\n\n      noOfflineSupport();\n    }\n\n    return img;\n  };\n  /**\r\n   * Reads a file from a File object\r\n   * @param file defines the file to load\r\n   * @param onSuccess defines the callback to call when data is loaded\r\n   * @param onProgress defines the callback to call during loading process\r\n   * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n   * @param onError defines the callback to call when an error occurs\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.ReadFile = function (file, onSuccess, onProgress, useArrayBuffer, onError) {\n    var reader = new FileReader();\n    var request = {\n      onCompleteObservable: new Observable(),\n      abort: function () {\n        return reader.abort();\n      }\n    };\n\n    reader.onloadend = function (e) {\n      return request.onCompleteObservable.notifyObservers(request);\n    };\n\n    if (onError) {\n      reader.onerror = function (e) {\n        onError(new ReadFileError(\"Unable to read \" + file.name, file));\n      };\n    }\n\n    reader.onload = function (e) {\n      //target doesn't have result from ts 1.3\n      onSuccess(e.target['result']);\n    };\n\n    if (onProgress) {\n      reader.onprogress = onProgress;\n    }\n\n    if (!useArrayBuffer) {\n      // Asynchronous read\n      reader.readAsText(file);\n    } else {\n      reader.readAsArrayBuffer(file);\n    }\n\n    return request;\n  };\n  /**\r\n   * Loads a file from a url\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param offlineProvider defines the offline provider for caching\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.LoadFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    // If file and file input are set\n    if (url.indexOf(\"file:\") !== -1) {\n      var fileName = decodeURIComponent(url.substring(5).toLowerCase());\n\n      if (fileName.indexOf('./') === 0) {\n        fileName = fileName.substring(2);\n      }\n\n      var file = FilesInputStore.FilesToLoad[fileName];\n\n      if (file) {\n        return FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function (error) {\n          return onError(undefined, new LoadFileError(error.message, error.file));\n        } : undefined);\n      }\n    }\n\n    return FileTools.RequestFile(url, function (data, request) {\n      onSuccess(data, request ? request.responseURL : undefined);\n    }, onProgress, offlineProvider, useArrayBuffer, onError ? function (error) {\n      onError(error.request, new LoadFileError(error.message, error.request));\n    } : undefined);\n  };\n  /**\r\n   * Loads a file\r\n   * @param url url to load\r\n   * @param onSuccess callback called when the file successfully loads\r\n   * @param onProgress callback called while file is loading (if the server supports this mode)\r\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n   * @param onError callback called when the file fails to load\r\n   * @param onOpened callback called when the web request is opened\r\n   * @returns a file request object\r\n   */\n\n\n  FileTools.RequestFile = function (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {\n    url = FileTools._CleanUrl(url);\n    url = FileTools.PreprocessUrl(url);\n    var loadUrl = FileTools.BaseUrl + url;\n    var aborted = false;\n    var fileRequest = {\n      onCompleteObservable: new Observable(),\n      abort: function () {\n        return aborted = true;\n      }\n    };\n\n    var requestFile = function () {\n      var request = new WebRequest();\n      var retryHandle = null;\n\n      fileRequest.abort = function () {\n        aborted = true;\n\n        if (request.readyState !== (XMLHttpRequest.DONE || 4)) {\n          request.abort();\n        }\n\n        if (retryHandle !== null) {\n          clearTimeout(retryHandle);\n          retryHandle = null;\n        }\n      };\n\n      var retryLoop = function (retryIndex) {\n        request.open('GET', loadUrl);\n\n        if (onOpened) {\n          onOpened(request);\n        }\n\n        if (useArrayBuffer) {\n          request.responseType = \"arraybuffer\";\n        }\n\n        if (onProgress) {\n          request.addEventListener(\"progress\", onProgress);\n        }\n\n        var onLoadEnd = function () {\n          request.removeEventListener(\"loadend\", onLoadEnd);\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n          fileRequest.onCompleteObservable.clear();\n        };\n\n        request.addEventListener(\"loadend\", onLoadEnd);\n\n        var onReadyStateChange = function () {\n          if (aborted) {\n            return;\n          } // In case of undefined state in some browsers.\n\n\n          if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n            // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n            request.removeEventListener(\"readystatechange\", onReadyStateChange);\n\n            if (request.status >= 200 && request.status < 300 || request.status === 0 && (!DomManagement.IsWindowObjectExist() || FileTools.IsFileURL())) {\n              onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              return;\n            }\n\n            var retryStrategy = FileTools.DefaultRetryStrategy;\n\n            if (retryStrategy) {\n              var waitTime = retryStrategy(loadUrl, request, retryIndex);\n\n              if (waitTime !== -1) {\n                // Prevent the request from completing for retry.\n                request.removeEventListener(\"loadend\", onLoadEnd);\n                request = new WebRequest();\n                retryHandle = setTimeout(function () {\n                  return retryLoop(retryIndex + 1);\n                }, waitTime);\n                return;\n              }\n            }\n\n            var error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n\n            if (onError) {\n              onError(error);\n            }\n          }\n        };\n\n        request.addEventListener(\"readystatechange\", onReadyStateChange);\n        request.send();\n      };\n\n      retryLoop(0);\n    }; // Caching all files\n\n\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\n      var noOfflineSupport_1 = function (request) {\n        if (request && request.status > 400) {\n          if (onError) {\n            onError(request);\n          }\n        } else {\n          requestFile();\n        }\n      };\n\n      var loadFromOfflineSupport = function () {\n        // TODO: database needs to support aborting and should return a IFileRequest\n        if (offlineProvider) {\n          offlineProvider.loadFile(FileTools.BaseUrl + url, function (data) {\n            if (!aborted) {\n              onSuccess(data);\n            }\n\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n          }, onProgress ? function (event) {\n            if (!aborted) {\n              onProgress(event);\n            }\n          } : undefined, noOfflineSupport_1, useArrayBuffer);\n        }\n      };\n\n      offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);\n    } else {\n      requestFile();\n    }\n\n    return fileRequest;\n  };\n  /**\r\n   * Checks if the loaded document was accessed via `file:`-Protocol.\r\n   * @returns boolean\r\n   */\n\n\n  FileTools.IsFileURL = function () {\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\n  };\n  /**\r\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset\r\n   */\n\n\n  FileTools.DefaultRetryStrategy = RetryStrategy.ExponentialBackoff();\n  /**\r\n   * Gets or sets the base URL to use to load assets\r\n   */\n\n  FileTools.BaseUrl = \"\";\n  /**\r\n   * Default behaviour for cors in the application.\r\n   * It can be a string if the expected behavior is identical in the entire app.\r\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n   */\n\n  FileTools.CorsBehavior = \"anonymous\";\n  /**\r\n   * Gets or sets a function used to pre-process url before using them to load assets\r\n   */\n\n  FileTools.PreprocessUrl = function (url) {\n    return url;\n  };\n\n  return FileTools;\n}();\n\nexport { FileTools };\nThinEngine._FileToolsLoadImage = FileTools.LoadImage.bind(FileTools);\nThinEngine._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);\nShaderProcessor._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);","map":{"version":3,"sources":["../../../sourceES6/core/Misc/fileTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebRequest } from './webRequest';\r\nimport { DomManagement } from './domManagement';\r\nimport { Nullable } from '../types';\r\nimport { IOfflineProvider } from '../Offline/IOfflineProvider';\r\nimport { IFileRequest } from './fileRequest';\r\nimport { Observable } from './observable';\r\nimport { FilesInputStore } from './filesInputStore';\r\nimport { RetryStrategy } from './retryStrategy';\r\nimport { BaseError } from './baseError';\r\nimport { StringTools } from './stringTools';\r\nimport { ThinEngine } from '../Engines/thinEngine';\r\nimport { ShaderProcessor } from '../Engines/Processors/shaderProcessor';\r\n\r\n/** @ignore */\r\nexport class LoadFileError extends BaseError {\r\n    public request?: WebRequest;\r\n    public file?: File;\r\n\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param request defines the optional web request\r\n     * @param file defines the optional file\r\n     */\r\n    constructor(message: string, object?: WebRequest | File) {\r\n        super(message);\r\n\r\n        this.name = \"LoadFileError\";\r\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\r\n\r\n        if (object instanceof WebRequest) {\r\n            this.request = object;\r\n        }\r\n        else {\r\n            this.file = object;\r\n        }\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class RequestFileError extends BaseError {\r\n    /**\r\n     * Creates a new LoadFileError\r\n     * @param message defines the message of the error\r\n     * @param request defines the optional web request\r\n     */\r\n    constructor(message: string, public request: WebRequest) {\r\n        super(message);\r\n        this.name = \"RequestFileError\";\r\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport class ReadFileError extends BaseError {\r\n    /**\r\n     * Creates a new ReadFileError\r\n     * @param message defines the message of the error\r\n     * @param file defines the optional file\r\n     */\r\n    constructor(message: string, public file: File) {\r\n        super(message);\r\n        this.name = \"ReadFileError\";\r\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\r\n    }\r\n}\r\n/**\r\n * @hidden\r\n */\r\nexport class FileTools {\r\n    /**\r\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset\r\n     */\r\n    public static DefaultRetryStrategy = RetryStrategy.ExponentialBackoff();\r\n\r\n    /**\r\n     * Gets or sets the base URL to use to load assets\r\n     */\r\n    public static BaseUrl = \"\";\r\n\r\n    /**\r\n     * Default behaviour for cors in the application.\r\n     * It can be a string if the expected behavior is identical in the entire app.\r\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\r\n     */\r\n    public static CorsBehavior: string | ((url: string | string[]) => string) = \"anonymous\";\r\n\r\n    /**\r\n     * Gets or sets a function used to pre-process url before using them to load assets\r\n     */\r\n    public static PreprocessUrl = (url: string) => {\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Removes unwanted characters from an url\r\n     * @param url defines the url to clean\r\n     * @returns the cleaned url\r\n     */\r\n    private static _CleanUrl(url: string): string {\r\n        url = url.replace(/#/mg, \"%23\");\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\r\n     * @param url define the url we are trying\r\n     * @param element define the dom element where to configure the cors policy\r\n     */\r\n    public static SetCorsBehavior(url: string | string[], element: { crossOrigin: string | null }): void {\r\n        if (url && url.indexOf(\"data:\") === 0) {\r\n            return;\r\n        }\r\n\r\n        if (FileTools.CorsBehavior) {\r\n            if (typeof (FileTools.CorsBehavior) === 'string' || this.CorsBehavior instanceof String) {\r\n                element.crossOrigin = <string>FileTools.CorsBehavior;\r\n            }\r\n            else {\r\n                var result = FileTools.CorsBehavior(url);\r\n                if (result) {\r\n                    element.crossOrigin = result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads an image as an HTMLImageElement.\r\n     * @param input url string, ArrayBuffer, or Blob to load\r\n     * @param onLoad callback called when the image successfully loads\r\n     * @param onError callback called when the image fails to load\r\n     * @param offlineProvider offline provider for caching\r\n     * @param mimeType optional mime type\r\n     * @returns the HTMLImageElement of the loaded image\r\n     */\r\n    public static LoadImage(input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType: string = \"\"): Nullable<HTMLImageElement> {\r\n        let url: string;\r\n        let usingObjectURL = false;\r\n\r\n        if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\r\n            if (typeof Blob !== 'undefined') {\r\n                url = URL.createObjectURL(new Blob([input], { type: mimeType }));\r\n                usingObjectURL = true;\r\n            } else {\r\n                url = `data:${mimeType};base64,` + StringTools.EncodeArrayBufferToBase64(input);\r\n            }\r\n        }\r\n        else if (input instanceof Blob) {\r\n            url = URL.createObjectURL(input);\r\n            usingObjectURL = true;\r\n        }\r\n        else {\r\n            url = FileTools._CleanUrl(input);\r\n            url = FileTools.PreprocessUrl(input);\r\n        }\r\n\r\n        if (typeof Image === \"undefined\") {\r\n            FileTools.LoadFile(url, (data) => {\r\n                createImageBitmap(new Blob([data], { type: mimeType })).then((imgBmp) => {\r\n                    onLoad(imgBmp);\r\n                    if (usingObjectURL) {\r\n                        URL.revokeObjectURL(url);\r\n                    }\r\n                }).catch((reason) => {\r\n                    if (onError) {\r\n                        onError(\"Error while trying to load image: \" + input, reason);\r\n                    }\r\n                });\r\n            }, undefined, offlineProvider || undefined, true, (request, exception) => {\r\n                if (onError) {\r\n                    onError(\"Error while trying to load image: \" + input, exception);\r\n                }\r\n            });\r\n\r\n            return null;\r\n        }\r\n\r\n        var img = new Image();\r\n        FileTools.SetCorsBehavior(url, img);\r\n\r\n        const loadHandler = () => {\r\n            img.removeEventListener(\"load\", loadHandler);\r\n            img.removeEventListener(\"error\", errorHandler);\r\n\r\n            onLoad(img);\r\n\r\n            // Must revoke the URL after calling onLoad to avoid security exceptions in\r\n            // certain scenarios (e.g. when hosted in vscode).\r\n            if (usingObjectURL && img.src) {\r\n                URL.revokeObjectURL(img.src);\r\n            }\r\n        };\r\n\r\n        const errorHandler = (err: any) => {\r\n            img.removeEventListener(\"load\", loadHandler);\r\n            img.removeEventListener(\"error\", errorHandler);\r\n\r\n            if (onError) {\r\n                const inputText = input.toString();\r\n                onError(\"Error while trying to load image: \" + (inputText.length < 32 ? inputText : inputText.slice(0, 32) + \"...\"), err);\r\n            }\r\n\r\n            if (usingObjectURL && img.src) {\r\n                URL.revokeObjectURL(img.src);\r\n            }\r\n        };\r\n\r\n        img.addEventListener(\"load\", loadHandler);\r\n        img.addEventListener(\"error\", errorHandler);\r\n\r\n        var noOfflineSupport = () => {\r\n            img.src = url;\r\n        };\r\n\r\n        var loadFromOfflineSupport = () => {\r\n            if (offlineProvider) {\r\n                offlineProvider.loadImage(url, img);\r\n            }\r\n        };\r\n\r\n        if (url.substr(0, 5) !== \"data:\" && offlineProvider && offlineProvider.enableTexturesOffline) {\r\n            offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n        }\r\n        else {\r\n            if (url.indexOf(\"file:\") !== -1) {\r\n                var textureName = decodeURIComponent(url.substring(5).toLowerCase());\r\n                if (FilesInputStore.FilesToLoad[textureName]) {\r\n                    try {\r\n                        var blobURL;\r\n                        try {\r\n                            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                        }\r\n                        catch (ex) {\r\n                            // Chrome doesn't support oneTimeOnly parameter\r\n                            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\r\n                        }\r\n                        img.src = blobURL;\r\n                        usingObjectURL = true;\r\n                    }\r\n                    catch (e) {\r\n                        img.src = \"\";\r\n                    }\r\n                    return img;\r\n                }\r\n            }\r\n\r\n            noOfflineSupport();\r\n        }\r\n\r\n        return img;\r\n    }\r\n\r\n    /**\r\n     * Reads a file from a File object\r\n     * @param file defines the file to load\r\n     * @param onSuccess defines the callback to call when data is loaded\r\n     * @param onProgress defines the callback to call during loading process\r\n     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\r\n     * @param onError defines the callback to call when an error occurs\r\n     * @returns a file request object\r\n     */\r\n    public static ReadFile(file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest {\r\n        let reader = new FileReader();\r\n        let request: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => reader.abort(),\r\n        };\r\n\r\n        reader.onloadend = (e) => request.onCompleteObservable.notifyObservers(request);\r\n        if (onError) {\r\n            reader.onerror = (e) => {\r\n                onError(new ReadFileError(`Unable to read ${file.name}`, file));\r\n            };\r\n        }\r\n        reader.onload = (e) => {\r\n            //target doesn't have result from ts 1.3\r\n            onSuccess((<any>e.target)['result']);\r\n        };\r\n        if (onProgress) {\r\n            reader.onprogress = onProgress;\r\n        }\r\n        if (!useArrayBuffer) {\r\n            // Asynchronous read\r\n            reader.readAsText(file);\r\n        }\r\n        else {\r\n            reader.readAsArrayBuffer(file);\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    public static LoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void): IFileRequest {\r\n        // If file and file input are set\r\n        if (url.indexOf(\"file:\") !== -1) {\r\n            let fileName = decodeURIComponent(url.substring(5).toLowerCase());\r\n            if (fileName.indexOf('./') === 0) {\r\n                fileName = fileName.substring(2);\r\n            }\r\n            const file = FilesInputStore.FilesToLoad[fileName];\r\n            if (file) {\r\n                return FileTools.ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\r\n            }\r\n        }\r\n\r\n        return FileTools.RequestFile(url, (data, request) => {\r\n            onSuccess(data, request ? request.responseURL : undefined);\r\n        }, onProgress, offlineProvider, useArrayBuffer, onError ? (error) => {\r\n            onError(error.request, new LoadFileError(error.message, error.request));\r\n        } : undefined);\r\n    }\r\n\r\n    /**\r\n     * Loads a file\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @param onOpened callback called when the web request is opened\r\n     * @returns a file request object\r\n     */\r\n    public static RequestFile(url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (event: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest {\r\n        url = FileTools._CleanUrl(url);\r\n        url = FileTools.PreprocessUrl(url);\r\n\r\n        const loadUrl = FileTools.BaseUrl + url;\r\n\r\n        let aborted = false;\r\n        const fileRequest: IFileRequest = {\r\n            onCompleteObservable: new Observable<IFileRequest>(),\r\n            abort: () => aborted = true,\r\n        };\r\n\r\n        const requestFile = () => {\r\n            let request = new WebRequest();\r\n            let retryHandle: Nullable<number> = null;\r\n\r\n            fileRequest.abort = () => {\r\n                aborted = true;\r\n\r\n                if (request.readyState !== (XMLHttpRequest.DONE || 4)) {\r\n                    request.abort();\r\n                }\r\n\r\n                if (retryHandle !== null) {\r\n                    clearTimeout(retryHandle);\r\n                    retryHandle = null;\r\n                }\r\n            };\r\n\r\n            const retryLoop = (retryIndex: number) => {\r\n                request.open('GET', loadUrl);\r\n\r\n                if (onOpened) {\r\n                    onOpened(request);\r\n                }\r\n\r\n                if (useArrayBuffer) {\r\n                    request.responseType = \"arraybuffer\";\r\n                }\r\n\r\n                if (onProgress) {\r\n                    request.addEventListener(\"progress\", onProgress);\r\n                }\r\n\r\n                const onLoadEnd = () => {\r\n                    request.removeEventListener(\"loadend\", onLoadEnd);\r\n                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                    fileRequest.onCompleteObservable.clear();\r\n                };\r\n\r\n                request.addEventListener(\"loadend\", onLoadEnd);\r\n\r\n                const onReadyStateChange = () => {\r\n                    if (aborted) {\r\n                        return;\r\n                    }\r\n\r\n                    // In case of undefined state in some browsers.\r\n                    if (request.readyState === (XMLHttpRequest.DONE || 4)) {\r\n                        // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\r\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\r\n\r\n                        if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!DomManagement.IsWindowObjectExist() || FileTools.IsFileURL()))) {\r\n                            onSuccess(useArrayBuffer ? request.response : request.responseText, request);\r\n                            return;\r\n                        }\r\n\r\n                        let retryStrategy = FileTools.DefaultRetryStrategy;\r\n                        if (retryStrategy) {\r\n                            let waitTime = retryStrategy(loadUrl, request, retryIndex);\r\n                            if (waitTime !== -1) {\r\n                                // Prevent the request from completing for retry.\r\n                                request.removeEventListener(\"loadend\", onLoadEnd);\r\n                                request = new WebRequest();\r\n                                retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\r\n                        if (onError) {\r\n                            onError(error);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                request.addEventListener(\"readystatechange\", onReadyStateChange);\r\n\r\n                request.send();\r\n            };\r\n\r\n            retryLoop(0);\r\n        };\r\n\r\n        // Caching all files\r\n        if (offlineProvider && offlineProvider.enableSceneOffline) {\r\n            const noOfflineSupport = (request?: any) => {\r\n                if (request && request.status > 400) {\r\n                    if (onError) {\r\n                        onError(request);\r\n                    }\r\n                } else {\r\n                    requestFile();\r\n                }\r\n            };\r\n\r\n            const loadFromOfflineSupport = () => {\r\n                // TODO: database needs to support aborting and should return a IFileRequest\r\n\r\n                if (offlineProvider) {\r\n                    offlineProvider.loadFile(FileTools.BaseUrl + url, (data) => {\r\n                        if (!aborted) {\r\n                            onSuccess(data);\r\n                        }\r\n\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                    }, onProgress ? (event) => {\r\n                        if (!aborted) {\r\n                            onProgress(event);\r\n                        }\r\n                    } : undefined, noOfflineSupport, useArrayBuffer);\r\n                }\r\n            };\r\n\r\n            offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\r\n        }\r\n        else {\r\n            requestFile();\r\n        }\r\n\r\n        return fileRequest;\r\n    }\r\n\r\n    /**\r\n     * Checks if the loaded document was accessed via `file:`-Protocol.\r\n     * @returns boolean\r\n     */\r\n    public static IsFileURL(): boolean {\r\n        return typeof location !== \"undefined\" && location.protocol === \"file:\";\r\n    }\r\n}\r\n\r\nThinEngine._FileToolsLoadImage = FileTools.LoadImage.bind(FileTools);\r\nThinEngine._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);\r\nShaderProcessor._FileToolsLoadFile = FileTools.LoadFile.bind(FileTools);"],"sourceRoot":""},"metadata":{},"sourceType":"module"}