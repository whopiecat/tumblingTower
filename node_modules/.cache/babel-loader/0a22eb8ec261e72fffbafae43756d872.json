{"ast":null,"code":"var _jsxFileName = \"D:\\\\tumblingTower\\\\src\\\\index.js\";\nimport React from \"react\";\nimport * as BABYLON from \"@babylonjs/core\";\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\n\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\n\nimport Scene from \"./3dScene\";\nimport Gateway from \"../logic/GatewayLogic\";\nimport LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\nimport EventManager from \"../utilities/EventManager\";\nexport default class Lobby extends React.Component {\n  constructor(props) {\n    super();\n\n    this._updateSequin = (sequinInfo, region) => {\n      const sequin = this.scene.getMeshByName(sequinInfo.name);\n      sequin.isPickable = true;\n      sequin.metadata = {\n        id: sequinInfo.id,\n        name: sequinInfo.name,\n        region: region\n      };\n      this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\n    };\n\n    this._animateCamera = (trackName, speed = 1, reverse = false) => {\n      const track = this.scene.getMeshByName(trackName);\n      const keysLength = track.animations[0]._keys.length;\n      const start = 0;\n      const end = track.animations[0]._keys[keysLength - 1].frame;\n      const startFrame = reverse ? end : start;\n      const endFrame = reverse ? start : end;\n      this.camera.parent = track;\n      this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\n\n      return this.scene.beginAnimation(track, startFrame, endFrame, false, speed).waitAsync();\n    };\n\n    this._handleClickMain = () => {\n      const scene = this.scene;\n      let pickResult = scene.pick(scene.pointerX, scene.pointerY);\n\n      if (pickResult.hit) {\n        console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\n        let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\n\n        if (region) {\n          LobbyState.toRegionSelected(region);\n        }\n      }\n    };\n\n    this._handleMouseMoveMain = () => {\n      this.hlLayer.removeAllMeshes();\n      let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\n\n      if (pickResult.hit) {\n        const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\n\n        if (r) {\n          r.meshes.forEach(m => this.hlLayer.addMesh(m, BABYLON.Color3.Green()));\n        }\n      }\n    };\n\n    this._handleClickRegion = () => {\n      const scene = this.scene;\n      const region = LobbyState.current.newState.data.name;\n      let pickResult = scene.pick(scene.pointerX, scene.pointerY);\n\n      if (pickResult.hit) {\n        const mesh = pickResult.pickedMesh;\n        console.log(\"picked mesh: \" + mesh); // make sure a sequin was picked and the sequin is in the current region\n\n        if (mesh.name.indexOf(\"sequin\") === -1 || mesh.name.indexOf(region) === -1) return;\n        LobbyState.toSequinView(mesh.metadata);\n      }\n    };\n\n    this._handleStateChange = async (oldState, newState) => {\n      if (oldState) this._cleanUpOldState(oldState);\n      if (newState) await this._setUpNewState(oldState, newState);\n    };\n\n    this._cleanUpOldState = oldState => {\n      switch (oldState.type) {\n        case LobbyStates.main:\n        case LobbyStates.regionEntered:\n          EventManager.removeAllListeners(window, \"click\");\n          EventManager.removeAllListeners(window, \"mousemove\");\n          break;\n\n        default:\n          break;\n      }\n    };\n\n    this._setUpNewState = async (oldState, newState) => {\n      switch (newState.type) {\n        case LobbyStates.intro:\n          await this._animateCamera(\"introToWorldEmpty_2\", 2.6);\n          LobbyState.toMainView();\n          break;\n\n        case LobbyStates.main:\n          if (this.data$) this.data$.unsubscribe();\n\n          if (oldState.type === LobbyStates.regionEntered) {\n            const region = oldState.data;\n            await this._animateCamera(region.trackName, 2, true);\n          }\n\n          EventManager.addListener(window, \"click\", this._handleClickMain);\n          EventManager.addListener(window, \"mousemove\", this._handleMouseMoveMain);\n          break;\n\n        case LobbyStates.regionSelected:\n          this.hlLayer.removeAllMeshes();\n          let regionSelected = newState.data;\n\n          if (oldState.type === LobbyStates.main) {\n            await this._animateCamera(regionSelected.trackName, 2);\n          }\n\n          LobbyState.toRegionEntered(regionSelected);\n          break;\n\n        case LobbyStates.regionEntered:\n          let regionEntered = newState.data;\n          this.data$ = Gateway.getRegion(regionEntered.name).stream.subscribe(sequins => {\n            sequins.forEach(seq => {\n              this._updateSequin(seq, regionEntered);\n            });\n          });\n          setTimeout(() => EventManager.addListener(window, \"click\", this._handleClickRegion), 200); // slight pause prevents the sequin info modal from immediately popping back open\n\n          break;\n\n        case LobbyStates.sequin:\n          if (this.data$) this.data$.unsubscribe();\n          break;\n\n        case LobbyStates.sequinLink:\n          let regionLinked = newState.data.region;\n          await this._animateCamera(regionLinked.trackName, 2);\n          LobbyState.toSequinView(newState.data);\n          break;\n\n        default:\n          break;\n      }\n    };\n\n    this.onSceneReady = async e => {\n      let that = this;\n      const {\n        scene\n      } = e;\n      this.scene = scene; // maybe use DeviceOrientationCamera so that tilting works on devices?\n\n      this.camera = new BABYLON.UniversalCamera(\"mainCamera\", new BABYLON.Vector3(0, 0, 0), scene); // 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\n\n      /* \r\n          // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n          var camerasBorderFunction = function () {\r\n            let alpha = -Math.PI / 2;\r\n            let beta = Math.PI / 2;\r\n            console.log(\"----  this.camera.beta ----\" + beta);\r\n            if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n            else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n            if (this.camera.radius > 150) this.camera.radius = 150;\r\n            if (this.camera.radius < 30) this.camera.radius = 30;\r\n          };\r\n          scene.registerBeforeRender(camerasBorderFunction);\r\n          this.camera.attachControl(this.canvas, true);\r\n      \r\n       */\n\n      const light1 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);\n      light1.intensity = 1.8;\n      var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\"default\", true, scene, [this.camera]);\n      var curve = new BABYLON.ColorCurves();\n      curve.globalHue = 200;\n      curve.globalDensity = 80;\n      curve.globalSaturation = 80;\n      curve.highlightsHue = 240; // 20;\n\n      curve.highlightsDensity = 100; // 80;\n\n      curve.highlightsSaturation = 100; // -80;\n\n      curve.shadowsHue = 2;\n      curve.shadowsDensity = 80;\n      curve.shadowsSaturation = 40;\n      defaultPipeline.imageProcessing.colorCurves = curve;\n      defaultPipeline.depthOfField.focalLength = 150; // sequin Bloom\n\n      defaultPipeline.bloomEnabled = true;\n      defaultPipeline.bloomThreshold = 0.8;\n      defaultPipeline.bloomWeight = 0.3;\n      defaultPipeline.bloomKernel = 64;\n      defaultPipeline.bloomScale = 0.5;\n      defaultPipeline.imageProcessingEnabled = true;\n      const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\n\n      const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\n      skyboxMaterial.backFaceCulling = false; // WORKS with out below line\n\n      skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\"/textures/skybox/TropicalSunnyDay\", scene);\n      skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n      skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\n      skyboxMaterial.disableLighting = true;\n      skybox.material = skyboxMaterial;\n      skybox.position.y = -30.0;\n      skybox.isPickable = false; // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\n      // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      // hdrBox.isPickable = false;\n      // var hdrRotation = 180; // in degrees\n      // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n      // --- original skyBox -------------------------------------------------------------------------------------------------------\n      // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\n\n      let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true); //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\n      //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\n\n      let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\n      hdrBox.isPickable = false; //  var hdrRotation = -60; // in degrees //-50\n      //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\n\n      this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene); // Exclude Mesh from roll over\n\n      this.hlLayer.addExcludedMesh(skybox); // PLEASE ADJUST AS NEEDED //\n      // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\n      // init state for setSequinsPickable();\n      //   this.hasCompletedSequinPickableInitRun = false;\n      // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\n\n      /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n              if (hasCompletedSequinPickableInitRun == false) {\r\n                  for (var i = 0; i < scene.meshes.length; i++) {\r\n                      var mesh = scene.meshes[i];\r\n                      var re = /sequin/gi;\r\n                      var str = mesh.name;\r\n                      if (str.search(re) == -1) {\r\n                         // console.log(\"Does not contain sequin\");\r\n                      } else {\r\n                          if (mesh.isPickable == false) {\r\n                             // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                             // console.log(\" ---- setting pickable ----\");\r\n                              mesh.isPickable = true;\r\n                          }\r\n                      }\r\n                  }\r\n              }\r\n              return hasCompletedSequinPickableInitRun = true;\r\n          } */\n      // PLEASE ADJUST AS NEEDED //\n\n      BABYLON.SceneLoader.ShowLoadingScreen = false;\n      await Promise.all([BABYLON.SceneLoader.AppendAsync(\"/models/\", \"setNoSequin_1a.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinOnlyNonPick29_l.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraIntro_1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion1.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion2.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion3.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"sequinCameraRegion4.babylon\", scene), BABYLON.SceneLoader.AppendAsync(\"/models/\", \"cloud001.babylon\", scene // cloud mesh and animation of 'Curve.001'(cloud001) Action\n      )]); // preload region tree meshes\n\n      Gateway.allRegions().forEach(r => {\n        r.treeNames.forEach(n => {\n          r.meshes.push(scene.getMeshByName(n));\n        });\n      });\n      if (this.sceneLoadedHandler) this.sceneLoadedHandler();\n      this.lobbyState$ = LobbyState.stream.subscribe(async ({\n        oldState,\n        newState\n      }) => {\n        await this._handleStateChange(oldState, newState);\n      }); // var createReflectionProbes = function () {\n\n      let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene); //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\n\n      probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\n      //}\n\n      this.camera.onViewMatrixChangedObservable.add(function () {\n        if (that.camera) {// console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\n          // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\n        } else {\n          console.log(\"no camera!\");\n        }\n      }); // scene.debugLayer.show();\n      // not sure where the code for rthe debugLayer is, but needs below line\n      // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\n      // debug GUI needs above line otherwise Inspector window hides when mesh selected.\n    };\n\n    this.onSceneRender = e => {};\n\n    this.sceneLoadedHandler = props.sceneLoaded;\n    this.lobbyState$ = undefined;\n    this.data$ = undefined;\n    this.scene = undefined;\n    this.hlLayer = undefined;\n    this.camera = undefined;\n    this.materials = [];\n  }\n\n  componentWillUnmount() {\n    // unsubscribe from all observables\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\n    if (this.data$) this.data$.unsubscribe();\n  }\n\n  renderScene() {\n    return /*#__PURE__*/React.createElement(Scene, {\n      antialias: true,\n      onSceneReady: this.onSceneReady,\n      onRender: this.onSceneRender,\n      canvasId: \"lobbyCanvas\",\n      className: \"lobby-canvas\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 391,\n        columnNumber: 7\n      }\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"lobby-container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 402,\n        columnNumber: 12\n      }\n    }, this.renderScene());\n  }\n\n}","map":{"version":3,"sources":["D:/tumblingTower/src/index.js"],"names":["React","BABYLON","Scene","Gateway","LobbyState","LobbyStates","EventManager","Lobby","Component","constructor","props","_updateSequin","sequinInfo","region","sequin","scene","getMeshByName","name","isPickable","metadata","id","hlLayer","addMesh","Color3","Blue","_animateCamera","trackName","speed","reverse","track","keysLength","animations","_keys","length","start","end","frame","startFrame","endFrame","camera","parent","fov","beginAnimation","waitAsync","_handleClickMain","pickResult","pick","pointerX","pointerY","hit","console","log","pickedMesh","getRegionFromMesh","toRegionSelected","_handleMouseMoveMain","removeAllMeshes","r","meshes","forEach","m","Green","_handleClickRegion","current","newState","data","mesh","indexOf","toSequinView","_handleStateChange","oldState","_cleanUpOldState","_setUpNewState","type","main","regionEntered","removeAllListeners","window","intro","toMainView","data$","unsubscribe","addListener","regionSelected","toRegionEntered","getRegion","stream","subscribe","sequins","seq","setTimeout","sequinLink","regionLinked","onSceneReady","e","that","UniversalCamera","Vector3","light1","HemisphericLight","intensity","defaultPipeline","DefaultRenderingPipeline","curve","ColorCurves","globalHue","globalDensity","globalSaturation","highlightsHue","highlightsDensity","highlightsSaturation","shadowsHue","shadowsDensity","shadowsSaturation","imageProcessing","colorCurves","depthOfField","focalLength","bloomEnabled","bloomThreshold","bloomWeight","bloomKernel","bloomScale","imageProcessingEnabled","skybox","Mesh","CreateBox","skyboxMaterial","StandardMaterial","backFaceCulling","reflectionTexture","CubeTexture","coordinatesMode","Texture","SKYBOX_MODE","diffuseColor","specularColor","disableLighting","material","position","y","hdrTexture","HDRCubeTexture","hdrBox","createDefaultSkybox","HighlightLayer","addExcludedMesh","SceneLoader","ShowLoadingScreen","Promise","all","AppendAsync","allRegions","treeNames","n","push","sceneLoadedHandler","lobbyState$","probe","ReflectionProbe","renderList","onViewMatrixChangedObservable","add","onSceneRender","sceneLoaded","undefined","materials","componentWillUnmount","renderScene","render"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport * as BABYLON from \"@babylonjs/core\";\r\nimport \"@babylonjs/core/Debug/debugLayer\"; // Augments the scene with the debug methods\r\nimport \"@babylonjs/inspector\"; // Injects a local ES6 version of the inspector to prevent automatically relying on the none compatible version\r\n\r\nimport Scene from \"./3dScene\";\r\nimport Gateway from \"../logic/GatewayLogic\";\r\nimport LobbyState, { LobbyStates } from \"../logic/LobbyStateLogic\";\r\nimport EventManager from \"../utilities/EventManager\";\r\n\r\nexport default class Lobby extends React.Component {\r\n  constructor(props) {\r\n    super();\r\n\r\n    this.sceneLoadedHandler = props.sceneLoaded;\r\n    this.lobbyState$ = undefined;\r\n    this.data$ = undefined;\r\n    this.scene = undefined;\r\n    this.hlLayer = undefined;\r\n    this.camera = undefined;\r\n    this.materials = [];\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // unsubscribe from all observables\r\n    if (this.lobbyState$) this.lobbyState$.unsubscribe();\r\n    if (this.data$) this.data$.unsubscribe();\r\n  }\r\n\r\n  _updateSequin = (sequinInfo, region) => {\r\n    const sequin = this.scene.getMeshByName(sequinInfo.name);\r\n    sequin.isPickable = true;\r\n    sequin.metadata = {\r\n      id: sequinInfo.id,\r\n      name: sequinInfo.name,\r\n      region: region,\r\n    };\r\n    this.hlLayer.addMesh(sequin, BABYLON.Color3.Blue()); // Any color\r\n  };\r\n\r\n  _animateCamera = (trackName, speed = 1, reverse = false) => {\r\n    const track = this.scene.getMeshByName(trackName);\r\n    const keysLength = track.animations[0]._keys.length;\r\n    const start = 0;\r\n    const end = track.animations[0]._keys[keysLength - 1].frame;\r\n    const startFrame = reverse ? end : start;\r\n    const endFrame = reverse ? start : end;\r\n    this.camera.parent = track;\r\n    this.camera.fov = 0.5200; // fill more of camera frame with trees camera.fov = 0.5200;\r\n    return this.scene\r\n      .beginAnimation(track, startFrame, endFrame, false, speed)\r\n      .waitAsync();\r\n  };\r\n\r\n  _handleClickMain = () => {\r\n    const scene = this.scene;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      console.log(\"picked mesh: \" + pickResult.pickedMesh.name);\r\n      let region = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (region) {\r\n        LobbyState.toRegionSelected(region);\r\n      }\r\n    }\r\n  };\r\n\r\n  _handleMouseMoveMain = () => {\r\n    this.hlLayer.removeAllMeshes();\r\n\r\n    let pickResult = this.scene.pick(this.scene.pointerX, this.scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const r = Gateway.getRegionFromMesh(pickResult.pickedMesh.name);\r\n      if (r) {\r\n        r.meshes.forEach((m) =>\r\n          this.hlLayer.addMesh(m, BABYLON.Color3.Green())\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  _handleClickRegion = () => {\r\n    const scene = this.scene;\r\n    const region = LobbyState.current.newState.data.name;\r\n    let pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n\r\n    if (pickResult.hit) {\r\n      const mesh = pickResult.pickedMesh;\r\n      console.log(\"picked mesh: \" + mesh);\r\n      // make sure a sequin was picked and the sequin is in the current region\r\n      if (mesh.name.indexOf(\"sequin\") === -1 || mesh.name.indexOf(region) === -1)\r\n        return;\r\n\r\n      LobbyState.toSequinView(mesh.metadata);\r\n    }\r\n  };\r\n\r\n  _handleStateChange = async (oldState, newState) => {\r\n    if (oldState) this._cleanUpOldState(oldState);\r\n    if (newState) await this._setUpNewState(oldState, newState);\r\n  };\r\n\r\n  _cleanUpOldState = (oldState) => {\r\n    switch (oldState.type) {\r\n      case LobbyStates.main:\r\n      case LobbyStates.regionEntered:\r\n        EventManager.removeAllListeners(window, \"click\");\r\n        EventManager.removeAllListeners(window, \"mousemove\");\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  _setUpNewState = async (oldState, newState) => {\r\n    switch (newState.type) {\r\n      case LobbyStates.intro:\r\n        await this._animateCamera(\"introToWorldEmpty_2\", 2.6);\r\n        LobbyState.toMainView();\r\n        break;\r\n\r\n      case LobbyStates.main:\r\n        if (this.data$) this.data$.unsubscribe();\r\n\r\n        if (oldState.type === LobbyStates.regionEntered) {\r\n          const region = oldState.data;\r\n          await this._animateCamera(region.trackName, 2, true);\r\n        }\r\n        EventManager.addListener(window, \"click\", this._handleClickMain);\r\n        EventManager.addListener(\r\n          window,\r\n          \"mousemove\",\r\n          this._handleMouseMoveMain\r\n        );\r\n        break;\r\n\r\n      case LobbyStates.regionSelected:\r\n        this.hlLayer.removeAllMeshes();\r\n        let regionSelected = newState.data;\r\n        if (oldState.type === LobbyStates.main) {\r\n          await this._animateCamera(regionSelected.trackName, 2);\r\n        }\r\n        LobbyState.toRegionEntered(regionSelected);\r\n        break;\r\n\r\n      case LobbyStates.regionEntered:\r\n        let regionEntered = newState.data;\r\n        this.data$ = Gateway.getRegion(regionEntered.name).stream.subscribe(\r\n          (sequins) => {\r\n            sequins.forEach((seq) => {\r\n              this._updateSequin(seq, regionEntered);\r\n            });\r\n          }\r\n        );\r\n        setTimeout(\r\n          () =>\r\n            EventManager.addListener(window, \"click\", this._handleClickRegion),\r\n          200\r\n        ); // slight pause prevents the sequin info modal from immediately popping back open\r\n        break;\r\n\r\n      case LobbyStates.sequin:\r\n        if (this.data$) this.data$.unsubscribe();\r\n        break;\r\n\r\n      case LobbyStates.sequinLink:\r\n        let regionLinked = newState.data.region;\r\n        await this._animateCamera(regionLinked.trackName, 2);\r\n        LobbyState.toSequinView(newState.data);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  onSceneReady = async (e) => {\r\n    let that = this;\r\n    const { scene } = e;\r\n    this.scene = scene;\r\n\r\n    // maybe use DeviceOrientationCamera so that tilting works on devices?\r\n    this.camera = new BABYLON.UniversalCamera(\r\n      \"mainCamera\",\r\n      new BABYLON.Vector3(0, 0, 0),\r\n      scene\r\n    );\r\n\r\n// 1 * Math.PI / 3, Math.PI / 2.5, 100, BABYLON.Vector3.Zero(),\r\n\r\n/* \r\n    // PT-710 / provide User camera movement with limited horizional Angle and Zoom\r\n    var camerasBorderFunction = function () {\r\n      let alpha = -Math.PI / 2;\r\n      let beta = Math.PI / 2;\r\n      console.log(\"----  this.camera.beta ----\" + beta);\r\n      if (this.camera.beta < 0.1) this.camera.beta = 0.1; //Angle; // 0.1\r\n      else if (this.camera.beta > (Math.PI / 2) * 0.9) this.camera.beta = (Math.PI / 2) * 0.9;   //Zoom\r\n      if (this.camera.radius > 150) this.camera.radius = 150;\r\n      if (this.camera.radius < 30) this.camera.radius = 30;\r\n    };\r\n    scene.registerBeforeRender(camerasBorderFunction);\r\n    this.camera.attachControl(this.canvas, true);\r\n\r\n */\r\n    const light1 = new BABYLON.HemisphericLight(\r\n      \"light1\",\r\n      new BABYLON.Vector3(0, 1, 0),\r\n      scene\r\n    );\r\n    light1.intensity = 1.8;\r\n\r\n    var defaultPipeline = new BABYLON.DefaultRenderingPipeline(\r\n      \"default\",\r\n      true,\r\n      scene,\r\n      [this.camera]\r\n    );\r\n    var curve = new BABYLON.ColorCurves();\r\n    curve.globalHue = 200;\r\n    curve.globalDensity = 80;\r\n    curve.globalSaturation = 80;\r\n    curve.highlightsHue = 240; // 20;\r\n    curve.highlightsDensity = 100; // 80;\r\n    curve.highlightsSaturation = 100; // -80;\r\n    curve.shadowsHue = 2;\r\n    curve.shadowsDensity = 80;\r\n    curve.shadowsSaturation = 40;\r\n    defaultPipeline.imageProcessing.colorCurves = curve;\r\n    defaultPipeline.depthOfField.focalLength = 150;\r\n    // sequin Bloom\r\n    defaultPipeline.bloomEnabled = true;\r\n    defaultPipeline.bloomThreshold = 0.8;\r\n    defaultPipeline.bloomWeight = 0.3;\r\n    defaultPipeline.bloomKernel = 64;\r\n    defaultPipeline.bloomScale = 0.5;\r\n    defaultPipeline.imageProcessingEnabled = true;\r\n\r\n    const skybox = BABYLON.Mesh.CreateBox(\"skyBox\", 600.0, scene); // 1500.0\r\n    const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\r\n    skyboxMaterial.backFaceCulling = false;\r\n    // WORKS with out below line\r\n    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(\r\n      \"/textures/skybox/TropicalSunnyDay\",\r\n      scene\r\n    );\r\n    skyboxMaterial.reflectionTexture.coordinatesMode =\r\n      BABYLON.Texture.SKYBOX_MODE;\r\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\r\n    skyboxMaterial.disableLighting = true;\r\n    skybox.material = skyboxMaterial;\r\n    skybox.position.y = -30.0;\r\n    skybox.isPickable = false;\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n    // let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/environment.dds\",scene);\r\n    // let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    // hdrBox.isPickable = false;\r\n    // var hdrRotation = 180; // in degrees\r\n    // hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n    // --- original skyBox -------------------------------------------------------------------------------------------------------\r\n   // --let hdrTexture = new BABYLON.HDRCubeTexture(\"/textures/firework.hdr\", scene, 128, false, true, false, true);\r\n    let hdrTexture =   new BABYLON.HDRCubeTexture(\"/textures/environment/firework3.hdr\", scene, 128, false, true, false, true);\r\n  //  let hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(\"/textures/environment/studio.env\", scene);\r\n    //scene.createDefaultSkybox(new BABYLON.CubeTexture(\"textures/environment.env\", scene),false,100,0,false);\r\n    let hdrBox = scene.createDefaultSkybox(hdrTexture, true, 10000);\r\n    \r\n    hdrBox.isPickable = false;\r\n  //  var hdrRotation = -60; // in degrees //-50\r\n  //  hdrTexture.rotationY = BABYLON.Tools.ToRadians(hdrRotation);\r\n\r\n\r\n    this.hlLayer = new BABYLON.HighlightLayer(\"hl1\", scene);\r\n    // Exclude Mesh from roll over\r\n    this.hlLayer.addExcludedMesh(skybox);\r\n\r\n    // PLEASE ADJUST AS NEEDED //\r\n    // Description: Sets any mesh with 'sequin' in the mesh name to be pickable\r\n    // init state for setSequinsPickable();\r\n    //   this.hasCompletedSequinPickableInitRun = false;\r\n    // Call once all the meshes are loaded > setSequinsPickable(hasCompletedSequinPickableInitRun)\r\n    /*     this.setSequinsPickable = function (hasCompletedSequinPickableInitRun) {\r\n            if (hasCompletedSequinPickableInitRun == false) {\r\n                for (var i = 0; i < scene.meshes.length; i++) {\r\n                    var mesh = scene.meshes[i];\r\n                    var re = /sequin/gi;\r\n                    var str = mesh.name;\r\n                    if (str.search(re) == -1) {\r\n                       // console.log(\"Does not contain sequin\");\r\n                    } else {\r\n                        if (mesh.isPickable == false) {\r\n                           // console.log(\"Sequin named \" + str + \" is pickable \" + mesh.isPickable);\r\n                           // console.log(\" ---- setting pickable ----\");\r\n                            mesh.isPickable = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return hasCompletedSequinPickableInitRun = true;\r\n        } */\r\n    // PLEASE ADJUST AS NEEDED //\r\n\r\n    BABYLON.SceneLoader.ShowLoadingScreen = false;\r\n\r\n    await Promise.all([\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"setNoSequin_1a.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinOnlyNonPick29_l.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraIntro_1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion1.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion2.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion3.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"sequinCameraRegion4.babylon\",\r\n        scene\r\n      ),\r\n      BABYLON.SceneLoader.AppendAsync(\r\n        \"/models/\",\r\n        \"cloud001.babylon\",\r\n        scene\r\n        // cloud mesh and animation of 'Curve.001'(cloud001) Action\r\n      ), \r\n    ]);\r\n\r\n    // preload region tree meshes\r\n    Gateway.allRegions().forEach((r) => {\r\n      r.treeNames.forEach((n) => {\r\n        r.meshes.push(scene.getMeshByName(n));\r\n      });\r\n    });\r\n\r\n    if (this.sceneLoadedHandler) this.sceneLoadedHandler();\r\n\r\n    this.lobbyState$ = LobbyState.stream.subscribe(\r\n      async ({ oldState, newState }) => {\r\n        await this._handleStateChange(oldState, newState);\r\n      }\r\n    );\r\n\r\n    // var createReflectionProbes = function () {\r\n    let probe = new BABYLON.ReflectionProbe(\"main\", 512, scene);\r\n    //  slower ? >   probe.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\r\n    probe.renderList.push(hdrBox); // probe.renderList.push(skybox);\r\n    //}\r\n\r\n    this.camera.onViewMatrixChangedObservable.add(function () {\r\n      if (that.camera) {\r\n        // console.log(\"rotation: \" + that.camera.rotation.x + \", \" + that.camera.rotation.y + \", \" + that.camera.rotation.z);\r\n        // console.log(\"position: \" + that.camera.position.x + \", \" + that.camera.position.y + \", \" + that.camera.position.z);\r\n      } else {\r\n        console.log(\"no camera!\");\r\n      }\r\n    });\r\n\r\n    // scene.debugLayer.show();\r\n    // not sure where the code for rthe debugLayer is, but needs below line\r\n    // var nodeMaterial = new BABYLON.NodeMaterial(\"node material\", scene, { emitComments: true });\r\n    // debug GUI needs above line otherwise Inspector window hides when mesh selected.\r\n  };\r\n\r\n  onSceneRender = (e) => { };\r\n\r\n  renderScene() {\r\n    return (\r\n      <Scene\r\n        antialias={true}\r\n        onSceneReady={this.onSceneReady}\r\n        onRender={this.onSceneRender}\r\n        canvasId=\"lobbyCanvas\"\r\n        className=\"lobby-canvas\"\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return <div className=\"lobby-container\">{this.renderScene()}</div>;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}