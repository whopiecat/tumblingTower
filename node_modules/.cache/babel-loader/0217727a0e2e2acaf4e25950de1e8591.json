{"ast":null,"code":"import { Color4 } from \"../Maths/math.color\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { MaterialHelper } from \"../Materials/materialHelper\";\nimport \"../Shaders/depth.fragment\";\nimport \"../Shaders/depth.vertex\";\nimport { _DevTools } from '../Misc/devTools';\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\n\nvar DepthRenderer =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a depth renderer\r\n   * @param scene The scene the renderer belongs to\r\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n   */\n  function DepthRenderer(scene, type, camera, storeNonLinearDepth) {\n    var _this = this;\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    if (camera === void 0) {\n      camera = null;\n    }\n\n    if (storeNonLinearDepth === void 0) {\n      storeNonLinearDepth = false;\n    }\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n\n\n    this.enabled = true;\n    /**\r\n     * Specifiess that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\n\n    this.useOnlyInActiveCamera = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this.isPacked = type === 0;\n\n    if (this.isPacked) {\n      this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n    }\n\n    DepthRenderer._SceneComponentInitialization(this._scene);\n\n    this._camera = camera;\n    var engine = scene.getEngine(); // Render target\n\n    var format = this.isPacked || engine.webGLVersion === 1 ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(\"depthMap\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, undefined, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null; // Camera to get depth map from to support multiple concurrent cameras\n\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false; // set default depth value to 1.0 (far away)\n\n    this._depthMap.onClearObservable.add(function (engine) {\n      engine.clear(_this._clearColor, true, true, true);\n    }); // Custom render function\n\n\n    var renderSubMesh = function (subMesh) {\n      var renderingMesh = subMesh.getRenderingMesh();\n      var effectiveMesh = subMesh.getEffectiveMesh();\n      var scene = _this._scene;\n      var engine = scene.getEngine();\n      var material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n      if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      } // Culling and reverse (right handed system)\n\n\n      engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem); // Managing instances\n\n      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n\n      if (batch.mustReturn) {\n        return;\n      }\n\n      var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      var camera = _this._camera || scene.activeCamera;\n\n      if (_this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        engine.enableEffect(_this._effect);\n\n        renderingMesh._bind(subMesh, _this._effect, material.fillMode);\n\n        _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n\n        _this._effect.setFloat2(\"depthValues\", camera.minZ, camera.minZ + camera.maxZ); // Alpha test\n\n\n        if (material && material.needAlphaTesting()) {\n          var alphaTexture = material.getAlphaTestTexture();\n\n          if (alphaTexture) {\n            _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n\n            _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n          }\n        } // Bones\n\n\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          _this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n        } // Morph targets\n\n\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, _this._effect); // Draw\n\n        renderingMesh._processRendering(effectiveMesh, subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n          return _this._effect.setMatrix(\"world\", world);\n        });\n      }\n    };\n\n    this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n      var index;\n\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n\n        engine.setColorWrite(true);\n      }\n\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n    };\n  }\n  /**\r\n   * Creates the depth rendering effect and checks if the effect is ready.\r\n   * @param subMesh The submesh to be used to render the depth map of\r\n   * @param useInstances If multiple world instances should be used\r\n   * @returns if the depth renderer is ready to render the depth map\r\n   */\n\n\n  DepthRenderer.prototype.isReady = function (subMesh, useInstances) {\n    var material = subMesh.getMaterial();\n\n    if (material.disableDepthWrite) {\n      return false;\n    }\n\n    var defines = [];\n    var attribs = [VertexBuffer.PositionKind];\n    var mesh = subMesh.getMesh(); // Alpha test\n\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    } // Bones\n\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Morph targets\n\n\n    var morphTargetManager = mesh.morphTargetManager;\n    var numMorphInfluencers = 0;\n\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    } // Instances\n\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // None linear depth\n\n\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    } // Float Mode\n\n\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    } // Get correct effect\n\n\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = this._scene.getEngine().createEffect(\"depth\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      });\n    }\n\n    return this._effect.isReady();\n  };\n  /**\r\n   * Gets the texture which the depth map will be written to.\r\n   * @returns The depth map texture\r\n   */\n\n\n  DepthRenderer.prototype.getDepthMap = function () {\n    return this._depthMap;\n  };\n  /**\r\n   * Disposes of the depth renderer.\r\n   */\n\n\n  DepthRenderer.prototype.dispose = function () {\n    this._depthMap.dispose();\n  };\n  /** @hidden */\n\n\n  DepthRenderer._SceneComponentInitialization = function (_) {\n    throw _DevTools.WarnImport(\"DepthRendererSceneComponent\");\n  };\n\n  return DepthRenderer;\n}();\n\nexport { DepthRenderer };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/depthRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Camera } from \"../Cameras/camera\";\r\n\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _DevTools } from '../Misc/devTools';\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private _effect: Effect;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _cachedDefines: string;\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Specifiess that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /** @hidden */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _DevTools.WarnImport(\"DepthRendererSceneComponent\");\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     */\r\n    constructor(scene: Scene, type: number = 1, camera: Nullable<Camera> = null, storeNonLinearDepth = false) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this.isPacked = type === 0;\r\n        if (this.isPacked) {\r\n            this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        }\r\n        else {\r\n            this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        this._camera = camera;\r\n        var engine = scene.getEngine();\r\n\r\n        // Render target\r\n        var format = (this.isPacked || engine.webGLVersion === 1) ? 5 : 6;\r\n        this._depthMap = new RenderTargetTexture(\"depthMap\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type,\r\n            false, undefined, undefined, undefined, undefined,\r\n            format);\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this._clearColor, true, true, true);\r\n        });\r\n\r\n        // Custom render function\r\n        var renderSubMesh = (subMesh: SubMesh): void => {\r\n            var renderingMesh = subMesh.getRenderingMesh();\r\n            var effectiveMesh = subMesh.getEffectiveMesh();\r\n            var scene = this._scene;\r\n            var engine = scene.getEngine();\r\n            let material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling and reverse (right handed system)\r\n            engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem);\r\n\r\n            // Managing instances\r\n            var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\r\n\r\n            var camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                engine.enableEffect(this._effect);\r\n                renderingMesh._bind(subMesh, this._effect, material.fillMode);\r\n\r\n                this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                this._effect.setFloat2(\"depthValues\", camera.minZ, camera.minZ + camera.maxZ);\r\n\r\n                // Alpha test\r\n                if (material && material.needAlphaTesting()) {\r\n                    var alphaTexture = material.getAlphaTestTexture();\r\n\r\n                    if (alphaTexture) {\r\n                        this._effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                        this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                    }\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    this._effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, this._effect);\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, this._effect, material.fillMode, batch, hardwareInstancedRendering,\r\n                    (isInstance, world) => this._effect.setMatrix(\"world\", world));\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>): void => {\r\n            var index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        var material: any = subMesh.getMaterial();\r\n        if (material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        var defines = [];\r\n\r\n        var attribs = [VertexBuffer.PositionKind];\r\n\r\n        var mesh = subMesh.getMesh();\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effect = this._scene.getEngine().createEffect(\"depth\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\"],\r\n                [\"diffuseSampler\"], join,\r\n                undefined, undefined, undefined, { maxSimultaneousMorphTargets: numMorphInfluencers });\r\n        }\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        this._depthMap.dispose();\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}