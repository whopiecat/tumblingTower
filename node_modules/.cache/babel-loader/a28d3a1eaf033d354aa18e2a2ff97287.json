{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from './nodeMaterialBlockConnectionPoint';\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\nimport { UniqueIdGenerator } from '../../Misc/uniqueIdGenerator';\nimport { _TypeStore } from '../../Misc/typeStore';\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\n\nvar NodeMaterialBlock =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new NodeMaterialBlock\r\n   * @param name defines the block name\r\n   * @param target defines the target of that block (Vertex by default)\r\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n   * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n   */\n  function NodeMaterialBlock(name, target, isFinalMerger, isInput) {\n    if (target === void 0) {\n      target = NodeMaterialBlockTargets.Vertex;\n    }\n\n    if (isFinalMerger === void 0) {\n      isFinalMerger = false;\n    }\n\n    if (isInput === void 0) {\n      isInput = false;\n    }\n\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n\n    this.inputsAreExclusive = false;\n    /** @hidden */\n\n    this._codeVariableName = \"\";\n    /** @hidden */\n\n    this._inputs = new Array();\n    /** @hidden */\n\n    this._outputs = new Array();\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\n\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n\n    this.visibleInInspector = false;\n    this._target = target;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = isInput;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n\n  Object.defineProperty(NodeMaterialBlock.prototype, \"name\", {\n    /**\r\n     * Gets the name of the block\r\n     */\n    get: function () {\n      return this._name;\n    },\n\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\n    set: function (newName) {\n      if (!this.validateBlockName(newName)) {\n        return;\n      }\n\n      this._name = newName;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isUnique\", {\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\n    get: function () {\n      return this._isUnique;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isFinalMerger\", {\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\n    get: function () {\n      return this._isFinalMerger;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"isInput\", {\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\n    get: function () {\n      return this._isInput;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"buildId\", {\n    /**\r\n     * Gets or sets the build Id\r\n     */\n    get: function () {\n      return this._buildId;\n    },\n    set: function (value) {\n      this._buildId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"target\", {\n    /**\r\n     * Gets or sets the target of the block\r\n     */\n    get: function () {\n      return this._target;\n    },\n    set: function (value) {\n      if ((this._target & value) !== 0) {\n        return;\n      }\n\n      this._target = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"inputs\", {\n    /**\r\n     * Gets the list of input points\r\n     */\n    get: function () {\n      return this._inputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterialBlock.prototype, \"outputs\", {\n    /** Gets the list of output points */\n    get: function () {\n      return this._outputs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Find an input by its name\r\n   * @param name defines the name of the input to look for\r\n   * @returns the input or null if not found\r\n   */\n\n  NodeMaterialBlock.prototype.getInputByName = function (name) {\n    var filter = this._inputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\r\n   * Find an output by its name\r\n   * @param name defines the name of the outputto look for\r\n   * @returns the output or null if not found\r\n   */\n\n\n  NodeMaterialBlock.prototype.getOutputByName = function (name) {\n    var filter = this._outputs.filter(function (e) {\n      return e.name === name;\n    });\n\n    if (filter.length) {\n      return filter[0];\n    }\n\n    return null;\n  };\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n\n  NodeMaterialBlock.prototype.initialize = function (state) {// Do nothing\n  };\n  /**\r\n   * Bind data to effect. Will only be called for blocks with isBindable === true\r\n   * @param effect defines the effect to bind data to\r\n   * @param nodeMaterial defines the hosting NodeMaterial\r\n   * @param mesh defines the mesh that will be rendered\r\n   * @param subMesh defines the submesh that will be rendered\r\n   */\n\n\n  NodeMaterialBlock.prototype.bind = function (effect, nodeMaterial, mesh, subMesh) {// Do nothing\n  };\n\n  NodeMaterialBlock.prototype._declareOutput = function (output, state) {\n    return state._getGLType(output.type) + \" \" + output.associatedVariableName;\n  };\n\n  NodeMaterialBlock.prototype._writeVariable = function (currentPoint) {\n    var connectionPoint = currentPoint.connectedPoint;\n\n    if (connectionPoint) {\n      return \"\" + currentPoint.associatedVariableName;\n    }\n\n    return \"0.\";\n  };\n\n  NodeMaterialBlock.prototype._writeFloat = function (value) {\n    var stringVersion = value.toString();\n\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n\n    return \"\" + stringVersion;\n  };\n  /**\r\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n   * @returns the class name\r\n   */\n\n\n  NodeMaterialBlock.prototype.getClassName = function () {\n    return \"NodeMaterialBlock\";\n  };\n  /**\r\n   * Register a new input. Must be called inside a block constructor\r\n   * @param name defines the connection point name\r\n   * @param type defines the connection point type\r\n   * @param isOptional defines a boolean indicating that this input can be omitted\r\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n   * @param point an already created connection point. If not provided, create a new one\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.registerInput = function (name, type, isOptional, target, point) {\n    if (isOptional === void 0) {\n      isOptional = false;\n    }\n\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._inputs.push(point);\n\n    return this;\n  };\n  /**\r\n   * Register a new output. Must be called inside a block constructor\r\n   * @param name defines the connection point name\r\n   * @param type defines the connection point type\r\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n   * @param point an already created connection point. If not provided, create a new one\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.registerOutput = function (name, type, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n\n    if (target) {\n      point.target = target;\n    }\n\n    this._outputs.push(point);\n\n    return this;\n  };\n  /**\r\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n   * @param forOutput defines an optional connection point to check compatibility with\r\n   * @returns the first available input or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableInput = function (forOutput) {\n    if (forOutput === void 0) {\n      forOutput = null;\n    }\n\n    for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n   * @param forBlock defines an optional block to check compatibility with\r\n   * @returns the first available input or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getFirstAvailableOutput = function (forBlock) {\n    if (forBlock === void 0) {\n      forBlock = null;\n    }\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the sibling of the given output\r\n   * @param current defines the current output\r\n   * @returns the next output in the list or null\r\n   */\n\n\n  NodeMaterialBlock.prototype.getSiblingOutput = function (current) {\n    var index = this._outputs.indexOf(current);\n\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n\n    return this._outputs[index + 1];\n  };\n  /**\r\n   * Connect current block with another block\r\n   * @param other defines the block to connect with\r\n   * @param options define the various options to help pick the right connections\r\n   * @returns the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.connectTo = function (other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n\n    var output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    var notFound = true;\n\n    while (notFound) {\n      var input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n\n    return this;\n  };\n\n  NodeMaterialBlock.prototype._buildBlock = function (state) {// Empty. Must be defined by child nodes\n  };\n  /**\r\n   * Add uniforms, samplers and uniform buffers at compilation time\r\n   * @param state defines the state to update\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param uniformBuffers defines the list of uniform buffer names\r\n   */\n\n\n  NodeMaterialBlock.prototype.updateUniformsAndSamples = function (state, nodeMaterial, defines, uniformBuffers) {// Do nothing\n  };\n  /**\r\n   * Add potential fallbacks if shader compilation fails\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param fallbacks defines the current prioritized list of fallbacks\r\n   */\n\n\n  NodeMaterialBlock.prototype.provideFallbacks = function (mesh, fallbacks) {// Do nothing\n  };\n  /**\r\n   * Initialize defines for shader compilation\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   */\n\n\n  NodeMaterialBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n  };\n  /**\r\n   * Update defines for shader compilation\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   * @param subMesh defines which submesh to render\r\n   */\n\n\n  NodeMaterialBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines, useInstances, subMesh) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    } // Do nothing\n\n  };\n  /**\r\n   * Lets the block try to connect some inputs automatically\r\n   * @param material defines the hosting NodeMaterial\r\n   */\n\n\n  NodeMaterialBlock.prototype.autoConfigure = function (material) {// Do nothing\n  };\n  /**\r\n   * Function called when a block is declared as repeatable content generator\r\n   * @param vertexShaderState defines the current compilation state for the vertex shader\r\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param defines defines the material defines to update\r\n   */\n\n\n  NodeMaterialBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {// Do nothing\n  };\n  /**\r\n   * Checks if the block is ready\r\n   * @param mesh defines the mesh to be rendered\r\n   * @param nodeMaterial defines the node material requesting the update\r\n   * @param defines defines the material defines to update\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns true if the block is ready\r\n   */\n\n\n  NodeMaterialBlock.prototype.isReady = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    return true;\n  };\n\n  NodeMaterialBlock.prototype._linkConnectionTypes = function (inputIndex0, inputIndex1, looseCoupling) {\n    if (looseCoupling === void 0) {\n      looseCoupling = false;\n    }\n\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  };\n\n  NodeMaterialBlock.prototype._processBuild = function (block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    var localBlockIsFragment = state._vertexState != null;\n    var otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader\n      block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n          var connectedPoint = input.connectedPoint;\n\n          if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n            state._vertexState.compilationString += \"v_\" + connectedPoint.associatedVariableName + \" = \" + connectedPoint.associatedVariableName + \";\\r\\n\";\n          }\n\n          input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n          input._enforceAssociatedVariableName = true;\n        }\n    }\n  };\n  /**\r\n  * Validates the new name for the block node.\r\n  * @param newName the new name to be given to the node.\r\n  * @returns false if the name is a reserve word, else true.\r\n  */\n\n\n  NodeMaterialBlock.prototype.validateBlockName = function (newName) {\n    var reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n\n    for (var _i = 0, reservedNames_1 = reservedNames; _i < reservedNames_1.length; _i++) {\n      var reservedName = reservedNames_1[_i];\n\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Compile the current node and generate the shader code\r\n   * @param state defines the current compilation state (uniforms, samplers, current string)\r\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n   * @returns true if already built\r\n   */\n\n\n  NodeMaterialBlock.prototype.build = function (state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n        var output = _a[_i];\n\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    } // Check if \"parent\" blocks are compiled\n\n\n    for (var _b = 0, _c = this._inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n\n        continue;\n      }\n\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n\n      var block = input.connectedPoint.ownerBlock;\n\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    } // Logs\n\n\n    if (state.sharedData.verbose) {\n      console.log((state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\") + \": Building \" + this.name + \" [\" + this.getClassName() + \"]\");\n    } // Checks final outputs\n\n\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += \"\\r\\n//\" + this.name + \"\\r\\n\";\n    }\n\n    this._buildBlock(state);\n\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target; // Compile connected blocks\n\n    for (var _d = 0, _e = this._outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n\n      for (var _f = 0, _g = output.endpoints; _f < _g.length; _f++) {\n        var endpoint = _g[_f];\n        var block = endpoint.ownerBlock;\n\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n\n    return false;\n  };\n\n  NodeMaterialBlock.prototype._inputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._outputRename = function (name) {\n    return name;\n  };\n\n  NodeMaterialBlock.prototype._dumpPropertiesCode = function () {\n    var variableName = this._codeVariableName;\n    return variableName + \".visibleInInspector = \" + this.visibleInInspector + \";\\r\\n\";\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._dumpCode = function (uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    var codeString; // Get unique name\n\n    var nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || this.getClassName() + \"_\" + this.uniqueId;\n\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      var index = 0;\n\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n\n    uniqueNames.push(this._codeVariableName); // Declaration\n\n    codeString = \"\\r\\n// \" + this.getClassName() + \"\\r\\n\";\n\n    if (this.comments) {\n      codeString += \"// \" + this.comments + \"\\r\\n\";\n    }\n\n    codeString += \"var \" + this._codeVariableName + \" = new BABYLON.\" + this.getClassName() + \"(\\\"\" + this.name + \"\\\");\\r\\n\"; // Properties\n\n    codeString += this._dumpPropertiesCode(); // Inputs\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Outputs\n\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n\n      if (!output.hasEndpoints) {\n        continue;\n      }\n\n      for (var _d = 0, _e = output.endpoints; _d < _e.length; _d++) {\n        var endpoint = _e[_d];\n        var connectedBlock = endpoint.ownerBlock;\n\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n\n    return codeString;\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._dumpCodeForOutputConnections = function (alreadyDumped) {\n    var codeString = \"\";\n\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n\n    alreadyDumped.push(this);\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n\n      if (!input.isConnected) {\n        continue;\n      }\n\n      var connectedOutput = input.connectedPoint;\n      var connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += connectedBlock._codeVariableName + \".\" + connectedBlock._outputRename(connectedOutput.name) + \".connectTo(\" + this._codeVariableName + \".\" + this._inputRename(input.name) + \");\\r\\n\";\n    }\n\n    return codeString;\n  };\n  /**\r\n   * Clone the current block to a new identical block\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a copy of the current block\r\n   */\n\n\n  NodeMaterialBlock.prototype.clone = function (scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var serializationObject = this.serialize();\n\n    var blockType = _TypeStore.GetClass(serializationObject.customType);\n\n    if (blockType) {\n      var block = new blockType();\n\n      block._deserialize(serializationObject, scene, rootUrl);\n\n      return block;\n    }\n\n    return null;\n  };\n  /**\r\n   * Serializes this block in a JSON representation\r\n   * @returns the serialized block object\r\n   */\n\n\n  NodeMaterialBlock.prototype.serialize = function () {\n    var serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      serializationObject.inputs.push(input.serialize());\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      serializationObject.outputs.push(output.serialize(false));\n    }\n\n    return serializationObject;\n  };\n  /** @hidden */\n\n\n  NodeMaterialBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  };\n\n  NodeMaterialBlock.prototype._deserializePortDisplayNamesAndExposedOnFrame = function (serializationObject) {\n    var _this = this;\n\n    var serializedInputs = serializationObject.inputs;\n    var serializedOutputs = serializationObject.outputs;\n\n    if (serializedInputs) {\n      serializedInputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.inputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n\n    if (serializedOutputs) {\n      serializedOutputs.forEach(function (port, i) {\n        if (port.displayName) {\n          _this.outputs[i].displayName = port.displayName;\n        }\n\n        if (port.isExposedOnFrame) {\n          _this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          _this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  };\n  /**\r\n   * Release resources\r\n   */\n\n\n  NodeMaterialBlock.prototype.dispose = function () {\n    for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      input.dispose();\n    }\n\n    for (var _b = 0, _c = this.outputs; _b < _c.length; _b++) {\n      var output = _c[_b];\n      output.dispose();\n    }\n  };\n\n  return NodeMaterialBlock;\n}();\n\nexport { NodeMaterialBlock };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Node/nodeMaterialBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from './nodeMaterialBuildState';\r\nimport { Nullable } from '../../types';\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from './nodeMaterialBlockConnectionPoint';\r\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\r\nimport { Effect } from '../effect';\r\nimport { AbstractMesh } from '../../Meshes/abstractMesh';\r\nimport { Mesh } from '../../Meshes/mesh';\r\nimport { SubMesh } from '../../Meshes/subMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from './nodeMaterial';\r\nimport { InputBlock } from './Blocks/Input/inputBlock';\r\nimport { UniqueIdGenerator } from '../../Misc/uniqueIdGenerator';\r\nimport { Scene } from '../../scene';\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    private _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @hidden */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @hidden */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @hidden */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @hidden */\r\n    public _preparationId: number;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n         return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        let filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the outputto look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        let filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n     /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n     public visibleInInspector = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\r\n\r\n        this._target = target;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = isInput;\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        let connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeMaterialBlockConnectionPointTypes, isOptional: boolean = false, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (var input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || (forOutput.type === input.type) || (input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect)) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (var output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        let index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @returns the current block\r\n     */\r\n    public connectTo(other: NodeMaterialBlock, options?: {\r\n        input?: string,\r\n        output?: string,\r\n        outputSwizzle?: string\r\n    }) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            let input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     */\r\n    public autoConfigure(material: NodeMaterial) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = (state._vertexState != null);\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (localBlockIsFragment && (\r\n            ((block.target & block._buildTarget) === 0) ||\r\n            ((block.target & input.target) === 0) ||\r\n            (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)\r\n            )) { // context switch! We need a varying\r\n            if ((!block.isInput && state.target !== block._buildTarget) // block was already emitted by vertex shader\r\n                || (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                let connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Validates the new name for the block node.\r\n    * @param newName the new name to be given to the node.\r\n    * @returns false if the name is a reserve word, else true.\r\n    */\r\n    public validateBlockName(newName: string) {\r\n        let reservedNames: Array<string> = [\r\n        \"position\",\r\n        \"normal\",\r\n        \"tangent\",\r\n        \"particle_positionw\",\r\n        \"uv\",\r\n        \"uv2\",\r\n        \"position2d\",\r\n        \"particle_uv\",\r\n        \"matricesIndices\",\r\n        \"matricesWeights\",\r\n        \"world0\",\r\n        \"world1\",\r\n        \"world2\",\r\n        \"world3\",\r\n        \"particle_color\",\r\n        \"particle_texturemask\"];\r\n        for (var reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (var output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (var input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) { // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            let block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\r\\n//${this.name}\\r\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (var output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (var endpoint of output.endpoints) {\r\n                let block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\r\\n`;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        let codeString: string;\r\n\r\n        // Get unique name\r\n        let nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            }\r\n            while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\r\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (var input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            var connectedOutput = input.connectedPoint!;\r\n            var connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (var output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (var endpoint of output.endpoints) {\r\n                var connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (var input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            var connectedOutput = input.connectedPoint!;\r\n            var connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\r\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        let serializationObject = this.serialize();\r\n\r\n        let blockType = _TypeStore.GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            let block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        let serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (var input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (var output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (var input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (var output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}