{"ast":null,"code":"import { Logger } from \"../Misc/logger\";\nimport { Scene } from \"../scene\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Light } from \"../Lights/light\";\nimport { Color3 } from '../Maths/math.color';\nimport { ThinMaterialHelper } from './thinMaterialHelper';\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\n\nvar MaterialHelper =\n/** @class */\nfunction () {\n  function MaterialHelper() {}\n  /**\r\n   * Bind the current view position to an effect.\r\n   * @param effect The effect to be bound\r\n   * @param scene The scene the eyes position is used from\r\n   * @param variableName name of the shader variable that will hold the eye position\r\n   */\n\n\n  MaterialHelper.BindEyePosition = function (effect, scene, variableName) {\n    if (variableName === void 0) {\n      variableName = \"vEyePosition\";\n    }\n\n    if (scene._forcedViewPosition) {\n      effect.setVector3(variableName, scene._forcedViewPosition);\n      return;\n    }\n\n    var globalPosition = scene.activeCamera.globalPosition;\n\n    if (!globalPosition) {\n      // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\n      globalPosition = scene.activeCamera.devicePosition;\n    }\n\n    effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\n  };\n  /**\r\n   * Helps preparing the defines values about the UVs in used in the effect.\r\n   * UVs are shared as much as we can accross channels in the shaders.\r\n   * @param texture The texture we are preparing the UVs for\r\n   * @param defines The defines to update\r\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n\n    if (texture.getTextureMatrix().isIdentityAs3x2()) {\n      defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n\n      if (texture.coordinatesIndex === 0) {\n        defines[\"MAINUV1\"] = true;\n      } else {\n        defines[\"MAINUV2\"] = true;\n      }\n    } else {\n      defines[key + \"DIRECTUV\"] = 0;\n    }\n  };\n  /**\r\n   * Binds a texture matrix value to its corrsponding uniform\r\n   * @param texture The texture to bind the matrix for\r\n   * @param uniformBuffer The uniform buffer receivin the data\r\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n   */\n\n\n  MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\n    var matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n  };\n  /**\r\n   * Gets the current status of the fog (should it be enabled?)\r\n   * @param mesh defines the mesh to evaluate for fog support\r\n   * @param scene defines the hosting scene\r\n   * @returns true if fog must be enabled\r\n   */\n\n\n  MaterialHelper.GetFogState = function (mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;\n  };\n  /**\r\n   * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n   * @param mesh defines the current mesh\r\n   * @param scene defines the current scene\r\n   * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n   * @param pointsCloud defines if point cloud rendering has to be turned on\r\n   * @param fogEnabled defines if fog has to be turned on\r\n   * @param alphaTest defines if alpha testing has to be turned on\r\n   * @param defines defines the current list of defines\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\n    if (defines._areMiscDirty) {\n      defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n      defines[\"POINTSIZE\"] = pointsCloud;\n      defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\n      defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n      defines[\"ALPHATEST\"] = alphaTest;\n    }\n  };\n  /**\r\n   * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n   * @param scene defines the current scene\r\n   * @param engine defines the current engine\r\n   * @param defines specifies the list of active defines\r\n   * @param useInstances defines if instances have to be turned on\r\n   * @param useClipPlane defines if clip plane have to be turned on\r\n   * @param useInstances defines if instances have to be turned on\r\n   * @param useThinInstances defines if thin instances have to be turned on\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, useClipPlane, useThinInstances) {\n    if (useClipPlane === void 0) {\n      useClipPlane = null;\n    }\n\n    if (useThinInstances === void 0) {\n      useThinInstances = false;\n    }\n\n    var changed = false;\n    var useClipPlane1 = false;\n    var useClipPlane2 = false;\n    var useClipPlane3 = false;\n    var useClipPlane4 = false;\n    var useClipPlane5 = false;\n    var useClipPlane6 = false;\n    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== undefined && scene.clipPlane !== null : useClipPlane;\n    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== undefined && scene.clipPlane2 !== null : useClipPlane;\n    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== undefined && scene.clipPlane3 !== null : useClipPlane;\n    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== undefined && scene.clipPlane4 !== null : useClipPlane;\n    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== undefined && scene.clipPlane5 !== null : useClipPlane;\n    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== undefined && scene.clipPlane6 !== null : useClipPlane;\n\n    if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\n      defines[\"CLIPPLANE\"] = useClipPlane1;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\n      defines[\"CLIPPLANE2\"] = useClipPlane2;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\n      defines[\"CLIPPLANE3\"] = useClipPlane3;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\n      defines[\"CLIPPLANE4\"] = useClipPlane4;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\n      defines[\"CLIPPLANE5\"] = useClipPlane5;\n      changed = true;\n    }\n\n    if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\n      defines[\"CLIPPLANE6\"] = useClipPlane6;\n      changed = true;\n    }\n\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n      defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n      changed = true;\n    }\n\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines[\"INSTANCES\"] = useInstances;\n      changed = true;\n    }\n\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n      defines[\"THIN_INSTANCES\"] = useThinInstances;\n      changed = true;\n    }\n\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  };\n  /**\r\n   * Prepares the defines for bones\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForBones = function (mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n      var materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n\n      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n        defines[\"BONETEXTURE\"] = true;\n      } else {\n        defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n        defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n        var prePassRenderer = mesh.getScene().prePassRenderer;\n\n        if (prePassRenderer && prePassRenderer.enabled) {\n          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n          defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n        }\n      }\n    } else {\n      defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n      defines[\"BonesPerMesh\"] = 0;\n    }\n  };\n  /**\r\n   * Prepares the defines for morph targets\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMorphTargets = function (mesh, defines) {\n    var manager = mesh.morphTargetManager;\n\n    if (manager) {\n      defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n      defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n      defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n      defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n    } else {\n      defines[\"MORPHTARGETS_UV\"] = false;\n      defines[\"MORPHTARGETS_TANGENT\"] = false;\n      defines[\"MORPHTARGETS_NORMAL\"] = false;\n      defines[\"MORPHTARGETS\"] = false;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n  };\n  /**\r\n   * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n   * @param mesh The mesh containing the geometry data we will draw\r\n   * @param defines The defines to update\r\n   * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n   * @param useBones Precise whether bones should be used or not (override mesh info)\r\n   * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n   * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n   * @returns false if defines are considered not dirty and have not been checked\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha) {\n    if (useMorphTargets === void 0) {\n      useMorphTargets = false;\n    }\n\n    if (useVertexAlpha === void 0) {\n      useVertexAlpha = true;\n    }\n\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n      return false;\n    }\n\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n\n    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      defines[\"TANGENT\"] = true;\n    }\n\n    if (defines._needUVs) {\n      defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\n      defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\n    } else {\n      defines[\"UV1\"] = false;\n      defines[\"UV2\"] = false;\n    }\n\n    if (useVertexColor) {\n      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n      defines[\"VERTEXCOLOR\"] = hasVertexColors;\n      defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n\n    if (useBones) {\n      this.PrepareDefinesForBones(mesh, defines);\n    }\n\n    if (useMorphTargets) {\n      this.PrepareDefinesForMorphTargets(mesh, defines);\n    }\n\n    return true;\n  };\n  /**\r\n   * Prepares the defines related to multiview\r\n   * @param scene The scene we are intending to draw\r\n   * @param defines The defines to update\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForMultiview = function (scene, defines) {\n    if (scene.activeCamera) {\n      var previousMultiview = defines.MULTIVIEW;\n      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (defines.MULTIVIEW != previousMultiview) {\n        defines.markAsUnprocessed();\n      }\n    }\n  };\n  /**\r\n   * Prepares the defines related to the prepass\r\n   * @param scene The scene we are intending to draw\r\n   * @param defines The defines to update\r\n   * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForPrePass = function (scene, defines, canRenderToMRT) {\n    var previousPrePass = defines.PREPASS;\n\n    if (!defines._arePrePassDirty) {\n      return;\n    }\n\n    var texturesList = [{\n      type: 1,\n      define: \"PREPASS_POSITION\",\n      index: \"PREPASS_POSITION_INDEX\"\n    }, {\n      type: 2,\n      define: \"PREPASS_VELOCITY\",\n      index: \"PREPASS_VELOCITY_INDEX\"\n    }, {\n      type: 3,\n      define: \"PREPASS_REFLECTIVITY\",\n      index: \"PREPASS_REFLECTIVITY_INDEX\"\n    }, {\n      type: 0,\n      define: \"PREPASS_IRRADIANCE\",\n      index: \"PREPASS_IRRADIANCE_INDEX\"\n    }, {\n      type: 6,\n      define: \"PREPASS_ALBEDO\",\n      index: \"PREPASS_ALBEDO_INDEX\"\n    }, {\n      type: 5,\n      define: \"PREPASS_DEPTHNORMAL\",\n      index: \"PREPASS_DEPTHNORMAL_INDEX\"\n    }];\n\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n      defines.PREPASS = true;\n      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        var index = scene.prePassRenderer.getIndex(texturesList[i].type);\n\n        if (index !== -1) {\n          defines[texturesList[i].define] = true;\n          defines[texturesList[i].index] = index;\n        } else {\n          defines[texturesList[i].define] = false;\n        }\n      }\n    } else {\n      defines.PREPASS = false;\n\n      for (var i = 0; i < texturesList.length; i++) {\n        defines[texturesList[i].define] = false;\n      }\n    }\n\n    if (defines.PREPASS != previousPrePass) {\n      defines.markAsUnprocessed();\n      defines.markAsImageProcessingDirty();\n    }\n  };\n  /**\r\n   * Prepares the defines related to the light information passed in parameter\r\n   * @param scene The scene we are intending to draw\r\n   * @param mesh The mesh the effect is compiling for\r\n   * @param light The light the effect is compiling for\r\n   * @param lightIndex The index of the light\r\n   * @param defines The defines to update\r\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n   * @param state Defines the current state regarding what is needed (normals, etc...)\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForLight = function (scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    state.needNormals = true;\n\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex); // FallOff.\n\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n\n    switch (light.falloffType) {\n      case Light.FALLOFF_GLTF:\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_PHYSICAL:\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n        break;\n\n      case Light.FALLOFF_STANDARD:\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n        break;\n    } // Specular\n\n\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n      state.specularEnabled = true;\n    } // Shadows\n\n\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n      var shadowGenerator = light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        var shadowMap = shadowGenerator.getShadowMap();\n\n        if (shadowMap) {\n          if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n            state.shadowEnabled = true;\n            shadowGenerator.prepareDefines(defines, lightIndex);\n          }\n        }\n      }\n    }\n\n    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\n      state.lightmapMode = true;\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;\n    } else {\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n  };\n  /**\r\n   * Prepares the defines related to the light information passed in parameter\r\n   * @param scene The scene we are intending to draw\r\n   * @param mesh The mesh the effect is compiling for\r\n   * @param defines The defines to update\r\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n   * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n   * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n   * @returns true if normals will be required for the rest of the effect\r\n   */\n\n\n  MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (disableLighting === void 0) {\n      disableLighting = false;\n    }\n\n    if (!defines._areLightsDirty) {\n      return defines._needNormals;\n    }\n\n    var lightIndex = 0;\n    var state = {\n      needNormals: false,\n      needRebuild: false,\n      lightmapMode: false,\n      shadowEnabled: false,\n      specularEnabled: false\n    };\n\n    if (scene.lightsEnabled && !disableLighting) {\n      for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {\n        var light = _a[_i];\n        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n        lightIndex++;\n\n        if (lightIndex === maxSimultaneousLights) {\n          break;\n        }\n      }\n    }\n\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled; // Resetting all other lights if any\n\n    for (var index = lightIndex; index < maxSimultaneousLights; index++) {\n      if (defines[\"LIGHT\" + index] !== undefined) {\n        defines[\"LIGHT\" + index] = false;\n        defines[\"HEMILIGHT\" + index] = false;\n        defines[\"POINTLIGHT\" + index] = false;\n        defines[\"DIRLIGHT\" + index] = false;\n        defines[\"SPOTLIGHT\" + index] = false;\n        defines[\"SHADOW\" + index] = false;\n        defines[\"SHADOWCSM\" + index] = false;\n        defines[\"SHADOWCSMDEBUG\" + index] = false;\n        defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n        defines[\"SHADOWCSMNOBLEND\" + index] = false;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n        defines[\"SHADOWPCF\" + index] = false;\n        defines[\"SHADOWPCSS\" + index] = false;\n        defines[\"SHADOWPOISSON\" + index] = false;\n        defines[\"SHADOWESM\" + index] = false;\n        defines[\"SHADOWCLOSEESM\" + index] = false;\n        defines[\"SHADOWCUBE\" + index] = false;\n        defines[\"SHADOWLOWQUALITY\" + index] = false;\n        defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n      }\n    }\n\n    var caps = scene.getEngine().getCaps();\n\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n\n    if (state.needRebuild) {\n      defines.rebuild();\n    }\n\n    return state.needNormals;\n  };\n  /**\r\n   * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n   * @param lightIndex defines the light index\r\n   * @param uniformsList The uniform list\r\n   * @param samplersList The sampler list\r\n   * @param projectedLightTexture defines if projected texture must be used\r\n   * @param uniformBuffersList defines an optional list of uniform buffers\r\n   * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersForLight = function (lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {\n    if (uniformBuffersList === void 0) {\n      uniformBuffersList = null;\n    }\n\n    if (updateOnlyBuffersList === void 0) {\n      updateOnlyBuffersList = false;\n    }\n\n    if (uniformBuffersList) {\n      uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n\n    if (updateOnlyBuffersList) {\n      return;\n    }\n\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowSampler\" + lightIndex);\n    samplersList.push(\"depthSampler\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n\n    if (projectedLightTexture) {\n      samplersList.push(\"projectionLightSampler\" + lightIndex);\n      uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n  };\n  /**\r\n   * Prepares the uniforms and samplers list to be used in the effect\r\n   * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n   * @param samplersList The sampler list\r\n   * @param defines The defines helping in the list generation\r\n   * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n   */\n\n\n  MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    var uniformsList;\n    var uniformBuffersList = null;\n\n    if (uniformsListOrOptions.uniformsNames) {\n      var options = uniformsListOrOptions;\n      uniformsList = options.uniformsNames;\n      uniformBuffersList = options.uniformBuffersNames;\n      samplersList = options.samplers;\n      defines = options.defines;\n      maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    } else {\n      uniformsList = uniformsListOrOptions;\n\n      if (!samplersList) {\n        samplersList = [];\n      }\n    }\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n      uniformsList.push(\"morphTargetInfluences\");\n    }\n  };\n  /**\r\n   * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n   * @param defines The defines to update while falling back\r\n   * @param fallbacks The authorized effect fallbacks\r\n   * @param maxSimultaneousLights The maximum number of lights allowed\r\n   * @param rank the current rank of the Effect\r\n   * @returns The newly affected rank\r\n   */\n\n\n  MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights, rank) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (rank === void 0) {\n      rank = 0;\n    }\n\n    var lightFallbackRank = 0;\n\n    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      if (lightIndex > 0) {\n        lightFallbackRank = rank + lightIndex;\n        fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n      }\n\n      if (!defines[\"SHADOWS\"]) {\n        if (defines[\"SHADOW\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCF\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCSS\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n        }\n      }\n    }\n\n    return lightFallbackRank++;\n  };\n  /**\r\n   * Prepares the list of attributes required for morph targets according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the morph targets attributes for\r\n   * @param influencers The number of influencers\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargetsInfluencers = function (attribs, mesh, influencers) {\n    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\n  };\n  /**\r\n   * Prepares the list of attributes required for morph targets according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the morph targets attributes for\r\n   * @param defines The current Defines of the effect\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\n    var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\n      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n      var manager = mesh.morphTargetManager;\n      var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n      var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n      var uv = manager && manager.supportsUVs && defines[\"UV1\"];\n\n      for (var index = 0; index < influencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n\n        if (attribs.length > maxAttributesCount) {\n          Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n        }\n      }\n    }\n  };\n  /**\r\n   * Prepares the list of attributes required for bones according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param mesh The mesh to prepare the bones attributes for\r\n   * @param defines The current Defines of the effect\r\n   * @param fallbacks The current efffect fallback strategy\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n    }\n  };\n  /**\r\n   * Check and prepare the list of attributes required for instances according to the effect defines.\r\n   * @param attribs The current list of supported attribs\r\n   * @param defines The current MaterialDefines of the effect\r\n   */\n\n\n  MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n      this.PushAttributesForInstances(attribs);\n    }\n  };\n  /**\r\n   * Add the list of attributes required for instances to the attribs array.\r\n   * @param attribs The current list of supported attribs\r\n   */\n\n\n  MaterialHelper.PushAttributesForInstances = function (attribs) {\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n  };\n  /**\r\n   * Binds the light information to the effect.\r\n   * @param light The light containing the generator\r\n   * @param effect The effect we are binding the data to\r\n   * @param lightIndex The light index in the effect used to render\r\n   */\n\n\n  MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param light Light to bind\r\n   * @param lightIndex Light index\r\n   * @param scene The scene where the light belongs to\r\n   * @param effect The effect we are binding the data to\r\n   * @param useSpecular Defines if specular is supported\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  MaterialHelper.BindLight = function (light, lightIndex, scene, effect, useSpecular, rebuildInParallel) {\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\n  };\n  /**\r\n   * Binds the lights information from the scene to the effect for the given mesh.\r\n   * @param scene The scene the lights belongs to\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param defines The generated defines for the effect\r\n   * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n   * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n   */\n\n\n  MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights, rebuildInParallel) {\n    if (maxSimultaneousLights === void 0) {\n      maxSimultaneousLights = 4;\n    }\n\n    if (rebuildInParallel === void 0) {\n      rebuildInParallel = false;\n    }\n\n    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n\n    for (var i = 0; i < len; i++) {\n      var light = mesh.lightSources[i];\n      this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\n    }\n  };\n  /**\r\n   * Binds the fog information from the scene to the effect for the given mesh.\r\n   * @param scene The scene the lights belongs to\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param linearSpace Defines if the fog effect is applied in linear space\r\n   */\n\n\n  MaterialHelper.BindFogParameters = function (scene, mesh, effect, linearSpace) {\n    if (linearSpace === void 0) {\n      linearSpace = false;\n    }\n\n    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity); // Convert fog color to linear space if used in a linear space computed shader.\n\n      if (linearSpace) {\n        scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\n        effect.setColor3(\"vFogColor\", this._tempFogColor);\n      } else {\n        effect.setColor3(\"vFogColor\", scene.fogColor);\n      }\n    }\n  };\n  /**\r\n   * Binds the bones information from the mesh to the effect.\r\n   * @param mesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n   */\n\n\n  MaterialHelper.BindBonesParameters = function (mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n      return;\n    }\n\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n      mesh.computeBonesUsingShaders = false;\n    }\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      var skeleton = mesh.skeleton;\n\n      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n        var boneTexture = skeleton.getTransformMatrixTexture(mesh);\n        effect.setTexture(\"boneSampler\", boneTexture);\n        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n      } else {\n        var matrices = skeleton.getTransformMatrices(mesh);\n\n        if (matrices) {\n          effect.setMatrices(\"mBones\", matrices);\n\n          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n            if (prePassConfiguration.previousBones[mesh.uniqueId]) {\n              effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n            }\n\n            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n          }\n        }\n      }\n    }\n  }; // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  MaterialHelper._CopyBonesTransformationMatrices = function (source, target) {\n    target.set(source);\n    return target;\n  };\n  /**\r\n   * Binds the morph targets information from the mesh to the effect.\r\n   * @param abstractMesh The mesh we are binding the information to render\r\n   * @param effect The effect we are binding the data to\r\n   */\n\n\n  MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\n    var manager = abstractMesh.morphTargetManager;\n\n    if (!abstractMesh || !manager) {\n      return;\n    }\n\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n  };\n  /**\r\n   * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n   * @param defines The generated defines used in the effect\r\n   * @param effect The effect we are binding the data to\r\n   * @param scene The scene we are willing to render with logarithmic scale for\r\n   */\n\n\n  MaterialHelper.BindLogDepth = function (defines, effect, scene) {\n    if (defines[\"LOGARITHMICDEPTH\"]) {\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n  };\n  /**\r\n   * Binds the clip plane information from the scene to the effect.\r\n   * @param scene The scene the clip plane information are extracted from\r\n   * @param effect The effect we are binding the data to\r\n   */\n\n\n  MaterialHelper.BindClipPlane = function (effect, scene) {\n    ThinMaterialHelper.BindClipPlane(effect, scene);\n  };\n\n  MaterialHelper._TmpMorphInfluencers = {\n    \"NUM_MORPH_INFLUENCERS\": 0\n  };\n  MaterialHelper._tempFogColor = Color3.Black();\n  return MaterialHelper;\n}();\n\nexport { MaterialHelper };","map":{"version":3,"sources":["../../../sourceES6/core/Materials/materialHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\nimport { PrePassConfiguration } from \"../Materials/prePassConfiguration\";\r\n\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { WebVRFreeCamera } from '../Cameras/VR/webVRCamera';\r\nimport { MaterialDefines } from \"./materialDefines\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { ThinMaterialHelper } from './thinMaterialHelper';\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param scene The scene the eyes position is used from\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public static BindEyePosition(effect: Effect, scene: Scene, variableName = \"vEyePosition\"): void {\r\n        if (scene._forcedViewPosition) {\r\n            effect.setVector3(variableName, scene._forcedViewPosition);\r\n            return;\r\n        }\r\n        var globalPosition = scene.activeCamera!.globalPosition;\r\n        if (!globalPosition) {\r\n            // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\r\n            globalPosition = (scene.activeCamera! as WebVRFreeCamera).devicePosition;\r\n        }\r\n        effect.setVector3(variableName, scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\r\n    }\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can accross channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            if (texture.coordinatesIndex === 0) {\r\n                defines[\"MAINUV1\"] = true;\r\n            } else {\r\n                defines[\"MAINUV2\"] = true;\r\n            }\r\n        } else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corrsponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receivin the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n        var matrix = texture.getTextureMatrix();\r\n\r\n        uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    public static GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n        return (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE);\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    public static PrepareDefinesForMisc(mesh: AbstractMesh, scene: Scene, useLogarithmicDepth: boolean, pointsCloud: boolean, fogEnabled: boolean, alphaTest: boolean, defines: any): void {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues(scene: Scene, engine: Engine, defines: any, useInstances: boolean, useClipPlane: Nullable<boolean> = null, useThinInstances: boolean = false): void {\r\n        var changed = false;\r\n        let useClipPlane1 = false;\r\n        let useClipPlane2 = false;\r\n        let useClipPlane3 = false;\r\n        let useClipPlane4 = false;\r\n        let useClipPlane5 = false;\r\n        let useClipPlane6 = false;\r\n\r\n        useClipPlane1 = useClipPlane == null ? (scene.clipPlane !== undefined && scene.clipPlane !== null) : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? (scene.clipPlane2 !== undefined && scene.clipPlane2 !== null) : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? (scene.clipPlane3 !== undefined && scene.clipPlane3 !== null) : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? (scene.clipPlane4 !== undefined && scene.clipPlane4 !== null) : useClipPlane;\r\n        useClipPlane5 = useClipPlane == null ? (scene.clipPlane5 !== undefined && scene.clipPlane5 !== null) : useClipPlane;\r\n        useClipPlane6 = useClipPlane == null ? (scene.clipPlane6 !== undefined && scene.clipPlane6 !== null) : useClipPlane;\r\n\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE5\"] !== useClipPlane5) {\r\n            defines[\"CLIPPLANE5\"] = useClipPlane5;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE6\"] !== useClipPlane6) {\r\n            defines[\"CLIPPLANE6\"] = useClipPlane6;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n            defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n            const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n            if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                defines[\"BONETEXTURE\"] = true;\r\n            } else {\r\n                defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\r\n                defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n                const prePassRenderer = mesh.getScene().prePassRenderer;\r\n                if (prePassRenderer && prePassRenderer.enabled) {\r\n                    const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                    defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n                }\r\n            }\r\n        } else {\r\n            defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n            defines[\"BonesPerMesh\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n        var manager = (<Mesh>mesh).morphTargetManager;\r\n        if (manager) {\r\n            defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n            defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n            defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n            defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n        } else {\r\n            defines[\"MORPHTARGETS_UV\"] = false;\r\n            defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n            defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n            defines[\"MORPHTARGETS\"] = false;\r\n            defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes(mesh: AbstractMesh, defines: any, useVertexColor: boolean, useBones: boolean, useMorphTargets = false, useVertexAlpha = true): boolean {\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n\r\n        defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n\r\n        if (defines._needUVs) {\r\n            defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n            defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\r\n        } else {\r\n            defines[\"UV1\"] = false;\r\n            defines[\"UV2\"] = false;\r\n        }\r\n\r\n        if (useVertexColor) {\r\n            var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n\r\n        if (useBones) {\r\n            this.PrepareDefinesForBones(mesh, defines);\r\n        }\r\n\r\n        if (useMorphTargets) {\r\n            this.PrepareDefinesForMorphTargets(mesh, defines);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n        if (scene.activeCamera) {\r\n            var previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = (scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1);\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    public static PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n        const previousPrePass = defines.PREPASS;\r\n\r\n        if (!defines._arePrePassDirty) {\r\n            return;\r\n        }\r\n\r\n        const texturesList = [\r\n        {\r\n            type: 1,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: 2,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: 3,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: 0,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: 6,\r\n            define: \"PREPASS_ALBEDO\",\r\n            index: \"PREPASS_ALBEDO_INDEX\",\r\n        },\r\n        {\r\n            type: 5,\r\n            define: \"PREPASS_DEPTHNORMAL\",\r\n            index: \"PREPASS_DEPTHNORMAL_INDEX\",\r\n        }];\r\n\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n            defines.PREPASS = true;\r\n            defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n                if (index !== -1) {\r\n                    defines[texturesList[i].define] = true;\r\n                    defines[texturesList[i].index] = index;\r\n                } else {\r\n                    defines[texturesList[i].define] = false;\r\n                }\r\n            }\r\n\r\n        } else {\r\n            defines.PREPASS = false;\r\n            for (let i = 0; i < texturesList.length; i++) {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n\r\n        if (defines.PREPASS != previousPrePass) {\r\n            defines.markAsUnprocessed();\r\n            defines.markAsImageProcessingDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     */\r\n    public static PrepareDefinesForLight(scene: Scene, mesh: AbstractMesh, light: Light, lightIndex: number, defines: any, specularSupported: boolean, state: {\r\n        needNormals: boolean,\r\n        needRebuild: boolean,\r\n        shadowEnabled: boolean,\r\n        specularEnabled: boolean,\r\n        lightmapMode: boolean\r\n    }) {\r\n        state.needNormals = true;\r\n\r\n        if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n        defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n        defines[\"HEMILIGHT\" + lightIndex] = false;\r\n        defines[\"POINTLIGHT\" + lightIndex] = false;\r\n        defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n        light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n        // FallOff.\r\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n        switch (light.falloffType) {\r\n            case Light.FALLOFF_GLTF:\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_PHYSICAL:\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                break;\r\n            case Light.FALLOFF_STANDARD:\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                break;\r\n        }\r\n\r\n        // Specular\r\n        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n            state.specularEnabled = true;\r\n        }\r\n\r\n        // Shadows\r\n        defines[\"SHADOW\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n        defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n        defines[\"SHADOWPCF\" + lightIndex] = false;\r\n        defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n        defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n        defines[\"SHADOWESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n        defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n        defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n        defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n            var shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                const shadowMap = shadowGenerator.getShadowMap();\r\n                if (shadowMap) {\r\n                    if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                        state.shadowEnabled = true;\r\n                        shadowGenerator.prepareDefines(defines, lightIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n            state.lightmapMode = true;\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY);\r\n        } else {\r\n            defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n            defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n\r\n        var lightIndex = 0;\r\n        let state = {\r\n            needNormals: false,\r\n            needRebuild: false,\r\n            lightmapMode: false,\r\n            shadowEnabled: false,\r\n            specularEnabled: false\r\n        };\r\n\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (var light of mesh.lightSources) {\r\n                this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n        defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n        // Resetting all other lights if any\r\n        for (var index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWCSM\" + index] = false;\r\n                defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n                defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n                defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n                defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n                defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCLOSEESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n\r\n        let caps = scene.getEngine().getCaps();\r\n\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            state.needRebuild = true;\r\n        }\r\n\r\n        defines[\"SHADOWFLOAT\"] = state.shadowEnabled &&\r\n            ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\r\n                (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n        if (state.needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n\r\n        return state.needNormals;\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    public static PrepareUniformsAndSamplersForLight(lightIndex: number, uniformsList: string[], samplersList: string[], projectedLightTexture?: any, uniformBuffersList: Nullable<string[]> = null, updateOnlyBuffersList = false) {\r\n        if (uniformBuffersList) {\r\n            uniformBuffersList.push(\"Light\" + lightIndex);\r\n        }\r\n\r\n        if (updateOnlyBuffersList) {\r\n            return;\r\n        }\r\n\r\n        uniformsList.push(\r\n            \"vLightData\" + lightIndex,\r\n            \"vLightDiffuse\" + lightIndex,\r\n            \"vLightSpecular\" + lightIndex,\r\n            \"vLightDirection\" + lightIndex,\r\n            \"vLightFalloff\" + lightIndex,\r\n            \"vLightGround\" + lightIndex,\r\n            \"lightMatrix\" + lightIndex,\r\n            \"shadowsInfo\" + lightIndex,\r\n            \"depthValues\" + lightIndex,\r\n        );\r\n\r\n        samplersList.push(\"shadowSampler\" + lightIndex);\r\n        samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n        uniformsList.push(\r\n            \"viewFrustumZ\" + lightIndex,\r\n            \"cascadeBlendFactor\" + lightIndex,\r\n            \"lightSizeUVCorrection\" + lightIndex,\r\n            \"depthCorrection\" + lightIndex,\r\n            \"penumbraDarkness\" + lightIndex,\r\n            \"frustumLengths\" + lightIndex,\r\n        );\r\n\r\n        if (projectedLightTexture) {\r\n            samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n            uniformsList.push(\r\n                \"textureProjectionMatrix\" + lightIndex,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n        let uniformsList: string[];\r\n        let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n        if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n            var options = <IEffectCreationOptions>uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n        } else {\r\n            uniformsList = <string[]>uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n        }\r\n\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n        let lightFallbackRank = 0;\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    }\r\n\r\n    private static _TmpMorphInfluencers = { \"NUM_MORPH_INFLUENCERS\": 0 };\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    public static PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            var manager = (<Mesh>mesh).morphTargetManager;\r\n            var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            var uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n            for (var index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current efffect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n        if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n            this.PushAttributesForInstances(attribs);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     */\r\n    public static PushAttributesForInstances(attribs: string[]): void {\r\n        attribs.push(\"world0\");\r\n        attribs.push(\"world1\");\r\n        attribs.push(\"world2\");\r\n        attribs.push(\"world3\");\r\n    }\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public static BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel = false): void {\r\n        light._bindLight(lightIndex, scene, effect, useSpecular, rebuildInParallel);\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4, rebuildInParallel = false): void {\r\n        let len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n\r\n            let light = mesh.lightSources[i];\r\n            this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], rebuildInParallel);\r\n        }\r\n    }\r\n\r\n    private static _tempFogColor = Color3.Black();\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace = false): void {\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._tempFogColor);\r\n            }\r\n            else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    public static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            const skeleton = mesh.skeleton;\r\n\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            } else {\r\n                const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                    if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(2)) {\r\n                        if (prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                        }\r\n\r\n                        MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Copies the bones transformation matrices into the target array and returns the target's reference\r\n    private static _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n        target.set(source);\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n        let manager = (<Mesh>abstractMesh).morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    }\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n        if (defines[\"LOGARITHMICDEPTH\"]) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log((<Camera>scene.activeCamera).maxZ + 1.0) / Math.LN2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param scene The scene the clip plane information are extracted from\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindClipPlane(effect: Effect, scene: Scene): void {\r\n        ThinMaterialHelper.BindClipPlane(effect, scene);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}