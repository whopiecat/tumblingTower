{"ast":null,"code":"import { VertexData } from \"../mesh.vertexData\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { Mesh } from \"../mesh\";\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\n\nVertexData.CreateCapsule = function (options) {\n  if (options === void 0) {\n    options = {\n      subdivisions: 2,\n      tessellation: 16,\n      height: 1,\n      radius: 0.25,\n      capSubdivisions: 6\n    };\n  }\n\n  var subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n  var tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n  var height = Math.max(options.height ? options.height : 1, 0.);\n  var radius = Math.max(options.radius ? options.radius : 0.25, 0.);\n  var capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n  var radialSegments = tessellation;\n  var heightSegments = subdivisions;\n  var radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0.);\n  var radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0.);\n  var heightMinusCaps = height - (radiusTop + radiusBottom);\n  var thetaStart = 0.0;\n  var thetaLength = 2.0 * Math.PI;\n  var capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n  var capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n  var alpha = Math.acos((radiusBottom - radiusTop) / height);\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var index = 0,\n      indexArray = [],\n      halfHeight = heightMinusCaps * 0.5;\n  var pi2 = Math.PI * 0.5;\n  var x, y;\n  var normal = Vector3.Zero();\n  var vertex = Vector3.Zero();\n  var cosAlpha = Math.cos(alpha);\n  var sinAlpha = Math.sin(alpha);\n  var cone_length = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length(); // Total length for v texture coord\n\n  var vl = radiusTop * alpha + cone_length + radiusBottom * (pi2 - alpha);\n  var v = 0;\n\n  for (y = 0; y <= capsTopSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha * (y / capsTopSegments);\n    v += radiusTop * alpha / capsTopSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusTop;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + sinA * radiusTop;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  var cone_height = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n  var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;\n\n  for (y = 1; y <= heightSegments; y++) {\n    var indexRow = [];\n    v += cone_length / heightSegments; // calculate the radius of the current row\n\n    var _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + cosAlpha * radiusTop - y * cone_height / heightSegments;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(sinTheta, slope, cosTheta).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  }\n\n  for (y = 1; y <= capsBottomSegments; y++) {\n    var indexRow = [];\n    var a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n    v += radiusBottom * alpha / capsBottomSegments;\n    var cosA = Math.cos(a);\n    var sinA = Math.sin(a); // calculate the radius of the current row\n\n    var _radius = cosA * radiusBottom;\n\n    for (x = 0; x <= radialSegments; x++) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta); // vertex\n\n      vertex.x = _radius * sinTheta;\n      vertex.y = -halfHeight + sinA * radiusBottom;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, 1 - v / vl); // save index of vertex in respective row\n\n      indexRow.push(index); // increase index\n\n      index++;\n    } // now save vertices of the row in our index array\n\n\n    indexArray.push(indexRow);\n  } // generate indices\n\n\n  for (x = 0; x < radialSegments; x++) {\n    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n      // we use the index array to access the correct indices\n      var i1 = indexArray[y][x];\n      var i2 = indexArray[y + 1][x];\n      var i3 = indexArray[y + 1][x + 1];\n      var i4 = indexArray[y][x + 1]; // face one\n\n      indices.push(i1);\n      indices.push(i2);\n      indices.push(i4); // face two\n\n      indices.push(i2);\n      indices.push(i3);\n      indices.push(i4);\n    }\n  }\n\n  indices = indices.reverse();\n\n  if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n    var m = new Matrix();\n    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);\n    var v_1 = Vector3.Zero();\n\n    for (var i = 0; i < vertices.length; i += 3) {\n      v_1.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n      Vector3.TransformCoordinatesToRef(v_1.clone(), m, v_1);\n      vertices[i] = v_1.x;\n      vertices[i + 1] = v_1.y;\n      vertices[i + 2] = v_1.z;\n    }\n  }\n\n  var vDat = new VertexData();\n  vDat.positions = vertices;\n  vDat.normals = normals;\n  vDat.uvs = uvs;\n  vDat.indices = indices;\n  return vDat;\n};\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\n\n\nMesh.CreateCapsule = function (name, options, scene) {\n  return CapsuleBuilder.CreateCapsule(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar CapsuleBuilder =\n/** @class */\nfunction () {\n  function CapsuleBuilder() {}\n  /**\r\n   * Creates a capsule or a pill mesh\r\n   * @param name defines the name of the mesh\r\n   * @param options The constructors options.\r\n   * @param scene The scene the mesh is scoped to.\r\n   * @returns Capsule Mesh\r\n   */\n\n\n  CapsuleBuilder.CreateCapsule = function (name, options, scene) {\n    if (options === void 0) {\n      options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6\n      };\n    }\n\n    var capsule = new Mesh(name, scene);\n    var vertexData = VertexData.CreateCapsule(options);\n    vertexData.applyToMesh(capsule);\n    return capsule;\n  };\n\n  return CapsuleBuilder;\n}();\n\nexport { CapsuleBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/capsuleBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\nVertexData.CreateCapsule = function(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6\r\n    }): VertexData {\r\n\r\n    let subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\r\n    let tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\r\n    let height = Math.max(options.height ? options.height : 1, 0.);\r\n    let radius = Math.max(options.radius ? options.radius : 0.25, 0.);\r\n    let capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\r\n\r\n    let  radialSegments = tessellation;\r\n    let  heightSegments = subdivisions;\r\n\r\n    let radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0.);\r\n    let radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0.);\r\n\r\n    let heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    let thetaStart = 0.0;\r\n    let thetaLength = (2.0 * Math.PI);\r\n\r\n    let capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    let capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    var alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    var index = 0,\r\n    indexArray = [],\r\n    halfHeight = heightMinusCaps * 0.5;\r\n    let pi2 = Math.PI * 0.5;\r\n\r\n    var x, y;\r\n    var normal = Vector3.Zero();\r\n    var vertex = Vector3.Zero();\r\n\r\n    var cosAlpha = Math.cos(alpha);\r\n    var sinAlpha = Math.sin(alpha);\r\n\r\n    var cone_length =\r\n        new Vector2(\r\n            radiusTop * sinAlpha,\r\n            halfHeight + radiusTop * cosAlpha\r\n            ).subtract(new Vector2(\r\n                radiusBottom * sinAlpha,\r\n                -halfHeight + radiusBottom * cosAlpha\r\n            )\r\n        ).length();\r\n\r\n    // Total length for v texture coord\r\n    var vl = radiusTop * alpha + cone_length + radiusBottom * (pi2 - alpha);\r\n\r\n    var v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n\r\n        var indexRow = [];\r\n\r\n        var a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += radiusTop * alpha / capsTopSegments;\r\n\r\n        var cosA = Math.cos(a);\r\n        var sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        var _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x ++) {\r\n            var u = x / radialSegments;\r\n            var theta = u * thetaLength + thetaStart;\r\n            var sinTheta = Math.sin(theta);\r\n            var cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index ++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    var cone_height = (height - radiusTop - radiusBottom) + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        var indexRow = [];\r\n        v += cone_length / heightSegments;\r\n        // calculate the radius of the current row\r\n        var _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x ++) {\r\n            var u = x / radialSegments;\r\n            var theta = u * thetaLength + thetaStart;\r\n            var sinTheta = Math.sin(theta);\r\n            var cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - y * cone_height / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index ++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        var indexRow = [];\r\n        var a = (pi2 - alpha) - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += radiusBottom * alpha / capsBottomSegments;\r\n        var cosA = Math.cos(a);\r\n        var sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        var _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x ++) {\r\n            var u = x / radialSegments;\r\n            var theta = u * thetaLength + thetaStart;\r\n            var sinTheta = Math.sin(theta);\r\n            var cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index ++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x ++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y ++) {\r\n            // we use the index array to access the correct indices\r\n            var i1 = indexArray[ y ][ x ];\r\n            var i2 = indexArray[ y + 1 ][ x ];\r\n            var i3 = indexArray[ y + 1 ][ x + 1 ];\r\n            var i4 = indexArray[ y ][ x + 1 ];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        let m = new Matrix();\r\n        (options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion()).toRotationMatrix(m);\r\n        let v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    let vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n};\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions{\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\nMesh.CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene): Mesh => {\r\n    return CapsuleBuilder.CreateCapsule(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class CapsuleBuilder {\r\n    /**\r\n     * Creates a capsule or a pill mesh\r\n     * @param name defines the name of the mesh\r\n     * @param options The constructors options.\r\n     * @param scene The scene the mesh is scoped to.\r\n     * @returns Capsule Mesh\r\n     */\r\n    public static CreateCapsule(name: string, options: ICreateCapsuleOptions = {\r\n            orientation : Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6\r\n        }, scene: any): Mesh {\r\n\r\n        var capsule = new Mesh(name, scene);\r\n        var vertexData = VertexData.CreateCapsule(options);\r\n        vertexData.applyToMesh(capsule);\r\n        return capsule;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}