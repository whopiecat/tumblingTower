{"ast":null,"code":"import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\nimport { Camera } from \"./camera\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\nimport { Epsilon } from '../Maths/math.constants';\nimport { Axis } from '../Maths/math.axis';\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\n\nvar TargetCamera =\n/** @class */\nfunction (_super) {\n  __extends(TargetCamera, _super);\n  /**\r\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n   * This is the base of the follow, arc rotate cameras and Free camera\r\n   * @see https://doc.babylonjs.com/features/cameras\r\n   * @param name Defines the name of the camera in the scene\r\n   * @param position Defines the start position of the camera in the scene\r\n   * @param scene Defines the scene the camera belongs to\r\n   * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n   */\n\n\n  function TargetCamera(name, position, scene, setActiveOnSceneIfNoneActive) {\n    if (setActiveOnSceneIfNoneActive === void 0) {\n      setActiveOnSceneIfNoneActive = true;\n    }\n\n    var _this = _super.call(this, name, position, scene, setActiveOnSceneIfNoneActive) || this;\n\n    _this._tmpUpVector = Vector3.Zero();\n    _this._tmpTargetVector = Vector3.Zero();\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\n\n    _this.cameraDirection = new Vector3(0, 0, 0);\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\n\n    _this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n\n    _this.ignoreParentScaling = false;\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\n\n    _this.updateUpVectorFromRotation = false;\n    _this._tmpQuaternion = new Quaternion();\n    /**\r\n     * Define the current rotation of the camera\r\n     */\n\n    _this.rotation = new Vector3(0, 0, 0);\n    /**\r\n     * Define the current speed of the camera\r\n     */\n\n    _this.speed = 2.0;\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\n\n    _this.noRotationConstraint = false;\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\n\n    _this.invertRotation = false;\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\n\n    _this.inverseRotationSpeed = 0.2;\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     */\n\n    _this.lockedTarget = null;\n    /** @hidden */\n\n    _this._currentTarget = Vector3.Zero();\n    /** @hidden */\n\n    _this._initialFocalDistance = 1;\n    /** @hidden */\n\n    _this._viewMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._camMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraTransformMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._cameraRotationMatrix = Matrix.Zero();\n    /** @hidden */\n\n    _this._referencePoint = new Vector3(0, 0, 1);\n    /** @hidden */\n\n    _this._transformedReferencePoint = Vector3.Zero();\n    _this._defaultUp = Vector3.Up();\n    _this._cachedRotationZ = 0;\n    _this._cachedQuaternionRotationZ = 0;\n    return _this;\n  }\n  /**\r\n   * Gets the position in front of the camera at a given distance.\r\n   * @param distance The distance from the camera we want the position to be\r\n   * @returns the position\r\n   */\n\n\n  TargetCamera.prototype.getFrontPosition = function (distance) {\n    this.getWorldMatrix();\n    var direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getLockedTargetPosition = function () {\n    if (!this.lockedTarget) {\n      return null;\n    }\n\n    if (this.lockedTarget.absolutePosition) {\n      this.lockedTarget.computeWorldMatrix();\n    }\n\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  };\n  /**\r\n   * Store current camera state of the camera (fov, position, rotation, etc..)\r\n   * @returns the camera\r\n   */\n\n\n  TargetCamera.prototype.storeState = function () {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n\n    return _super.prototype.storeState.call(this);\n  };\n  /**\r\n   * Restored camera state. You must call storeState() first\r\n   * @returns whether it was successful or not\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype._restoreStateValues = function () {\n    if (!_super.prototype._restoreStateValues.call(this)) {\n      return false;\n    }\n\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._initCache = function () {\n    _super.prototype._initCache.call(this);\n\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._updateCache = function (ignoreParentClass) {\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n\n    this._cache.rotation.copyFrom(this.rotation);\n\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }; // Synchronized\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._isSynchronizedViewMatrix = function () {\n    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\n      return false;\n    }\n\n    var lockedTargetPosition = this._getLockedTargetPosition();\n\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }; // Methods\n\n  /** @hidden */\n\n\n  TargetCamera.prototype._computeLocalCameraSpeed = function () {\n    var engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }; // Target\n\n  /**\r\n   * Defines the target the camera should look at.\r\n   * @param target Defines the new target as a Vector or a mesh\r\n   */\n\n\n  TargetCamera.prototype.setTarget = function (target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n\n    this._camMatrix.invert();\n\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    var vDir = target.subtract(this.position);\n\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n\n    this.rotation.z = 0;\n\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  };\n\n  Object.defineProperty(TargetCamera.prototype, \"target\", {\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\n    get: function () {\n      return this.getTarget();\n    },\n    set: function (value) {\n      this.setTarget(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Return the current target position of the camera. This value is expressed in local space.\r\n   * @returns the target position\r\n   */\n\n  TargetCamera.prototype.getTarget = function () {\n    return this._currentTarget;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._decideIfNeedsToMove = function () {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._updatePosition = function () {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this.position.addInPlace(TmpVectors.Vector3[0]);\n      return;\n    }\n\n    this.position.addInPlace(this.cameraDirection);\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._checkInputs = function () {\n    var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n\n    var needToMove = this._decideIfNeedsToMove();\n\n    var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0; // Move\n\n    if (needToMove) {\n      this._updatePosition();\n    } // Rotate\n\n\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n      }\n\n      this.rotation.x += this.cameraRotation.x * directionMultiplier;\n      this.rotation.y += this.cameraRotation.y * directionMultiplier; // Apply constraints\n\n      if (!this.noRotationConstraint) {\n        var limit = 1.570796;\n\n        if (this.rotation.x > limit) {\n          this.rotation.x = limit;\n        }\n\n        if (this.rotation.x < -limit) {\n          this.rotation.x = -limit;\n        }\n      } //rotate, if quaternion is set and rotation was used\n\n\n      if (this.rotationQuaternion) {\n        var len = this.rotation.lengthSquared();\n\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n      }\n    } // Inertia\n\n\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n\n  TargetCamera.prototype._updateCameraRotationMatrix = function () {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  };\n  /**\r\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n   * @returns the current camera\r\n   */\n\n\n  TargetCamera.prototype._rotateUpVectorWithCameraRotationMatrix = function () {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  };\n  /** @hidden */\n\n\n  TargetCamera.prototype._getViewMatrix = function () {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    } // Compute\n\n\n    this._updateCameraRotationMatrix(); // Apply the changed rotation to the upVector\n\n\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ != this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n\n      this._cachedRotationZ = this.rotation.z;\n    }\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n\n    return this._viewMatrix;\n  };\n\n  TargetCamera.prototype._computeViewMatrix = function (position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        var parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n\n        this._tmpTargetVector.copyFrom(target);\n\n        this._tmpUpVector.copyFrom(up);\n      }\n\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n\n      return;\n    }\n\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n\n    if (this.parent) {\n      var parentWorldMatrix = this.parent.getWorldMatrix();\n\n      this._viewMatrix.invert();\n\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n\n      this._viewMatrix.invert();\n\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype.createRigCamera = function (name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n\n      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n\n      return rigCamera;\n    }\n\n    return null;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  TargetCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n        var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n        var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n\n        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n\n        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n\n        break;\n\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n\n    _super.prototype._updateRigCameras.call(this);\n  };\n\n  TargetCamera.prototype._getRigCamPositionAndTarget = function (halfSpace, rigCamera) {\n    var target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n\n    var newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  };\n  /**\r\n   * Gets the current object class name.\r\n   * @return the class name\r\n   */\n\n\n  TargetCamera.prototype.getClassName = function () {\n    return \"TargetCamera\";\n  };\n\n  TargetCamera._RigCamTransformMatrix = new Matrix();\n  TargetCamera._TargetTransformMatrix = new Matrix();\n  TargetCamera._TargetFocalPoint = new Vector3();\n\n  __decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n\n  __decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n\n  __decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);\n\n  return TargetCamera;\n}(Camera);\n\nexport { TargetCamera };","map":{"version":3,"sources":["../../../sourceES6/core/Cameras/targetCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from '../Maths/math.constants';\r\nimport { Axis } from '../Maths/math.axis';\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @hidden */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @hidden */\r\n    public _initialFocalDistance = 1;\r\n    /** @hidden */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @hidden */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @hidden */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @hidden */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    /** @hidden */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines wheter the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        var direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @hidden\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        }\r\n        else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            }\r\n            else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @hidden */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        var lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)\r\n            && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\r\n    }\r\n\r\n    // Methods\r\n    /** @hidden */\r\n    public _computeLocalCameraSpeed(): number {\r\n        var engine = this.getEngine();\r\n        return this.speed * Math.sqrt((engine.getDeltaTime() / (engine.getFps() * 100.0)));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector or a mesh\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        var vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);\r\n        } else {\r\n            this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkInputs(): void {\r\n        var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        var needToMove = this._decideIfNeedsToMove();\r\n        var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                var limit = 1.570796;\r\n\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                var len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @hidden */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ != this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _updateRigCameras() {\r\n        var camLeft = <TargetCamera>this._rigCameras[0];\r\n        var camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                var leftSign = (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? 1 : -1;\r\n                var rightSign = (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        var target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        var newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @return the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}