{"ast":null,"code":"import { Vector3 } from './math.vector';\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @return minimum and maximum values\r\n */\n\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {\n  if (bias === void 0) {\n    bias = null;\n  }\n\n  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n  for (var index = indexStart; index < indexStart + indexCount; index++) {\n    var offset = indices[index] * 3;\n    var x = positions[offset];\n    var y = positions[offset + 1];\n    var z = positions[offset + 2];\n    minimum.minimizeInPlaceFromFloats(x, y, z);\n    maximum.maximizeInPlaceFromFloats(x, y, z);\n  }\n\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @return minimum and maximum values\r\n */\n\nexport function extractMinAndMax(positions, start, count, bias, stride) {\n  if (bias === void 0) {\n    bias = null;\n  }\n\n  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n  if (!stride) {\n    stride = 3;\n  }\n\n  for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n    var x = positions[offset];\n    var y = positions[offset + 1];\n    var z = positions[offset + 2];\n    minimum.minimizeInPlaceFromFloats(x, y, z);\n    maximum.maximizeInPlaceFromFloats(x, y, z);\n  }\n\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}","map":{"version":3,"sources":["../../../sourceES6/core/Maths/math.functions.ts"],"names":[],"mappings":"AACA,SAAkB,OAAlB,QAAiC,eAAjC;AAEA;;;;;;;;;;AASA,OAAM,SAAU,uBAAV,CAAkC,SAAlC,EAAyD,OAAzD,EAAgF,UAAhF,EAAoG,UAApG,EAAwH,IAAxH,EAAsJ;AAA9B,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,IAAA;AAA8B;;AACxJ,MAAI,OAAO,GAAG,IAAI,OAAJ,CAAY,MAAM,CAAC,SAAnB,EAA8B,MAAM,CAAC,SAArC,EAAgD,MAAM,CAAC,SAAvD,CAAd;AACA,MAAI,OAAO,GAAG,IAAI,OAAJ,CAAY,CAAC,MAAM,CAAC,SAApB,EAA+B,CAAC,MAAM,CAAC,SAAvC,EAAkD,CAAC,MAAM,CAAC,SAA1D,CAAd;;AAEA,OAAK,IAAI,KAAK,GAAG,UAAjB,EAA6B,KAAK,GAAG,UAAU,GAAG,UAAlD,EAA8D,KAAK,EAAnE,EAAuE;AACnE,QAAM,MAAM,GAAG,OAAO,CAAC,KAAD,CAAP,GAAiB,CAAhC;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,MAAD,CAAnB;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAV,CAAnB;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAV,CAAnB;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC;AACH;;AAED,MAAI,IAAJ,EAAU;AACN,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACH;;AAED,SAAO;AACH,IAAA,OAAO,EAAE,OADN;AAEH,IAAA,OAAO,EAAE;AAFN,GAAP;AAIH;AAED;;;;;;;;;;AASA,OAAM,SAAU,gBAAV,CAA2B,SAA3B,EAAkD,KAAlD,EAAiE,KAAjE,EAAgF,IAAhF,EAAgH,MAAhH,EAA+H;AAA/C,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,IAAA;AAA8B;;AAChH,MAAI,OAAO,GAAG,IAAI,OAAJ,CAAY,MAAM,CAAC,SAAnB,EAA8B,MAAM,CAAC,SAArC,EAAgD,MAAM,CAAC,SAAvD,CAAd;AACA,MAAI,OAAO,GAAG,IAAI,OAAJ,CAAY,CAAC,MAAM,CAAC,SAApB,EAA+B,CAAC,MAAM,CAAC,SAAvC,EAAkD,CAAC,MAAM,CAAC,SAA1D,CAAd;;AAEA,MAAI,CAAC,MAAL,EAAa;AACT,IAAA,MAAM,GAAG,CAAT;AACH;;AAED,OAAK,IAAI,KAAK,GAAG,KAAZ,EAAmB,MAAM,GAAG,KAAK,GAAG,MAAzC,EAAiD,KAAK,GAAG,KAAK,GAAG,KAAjE,EAAwE,KAAK,IAAK,MAAM,IAAI,MAA5F,EAAoG;AAChG,QAAM,CAAC,GAAG,SAAS,CAAC,MAAD,CAAnB;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAV,CAAnB;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAV,CAAnB;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC;AACA,IAAA,OAAO,CAAC,yBAAR,CAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC;AACH;;AAED,MAAI,IAAJ,EAAU;AACN,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACA,IAAA,OAAO,CAAC,CAAR,IAAa,OAAO,CAAC,CAAR,GAAY,IAAI,CAAC,CAAjB,GAAqB,IAAI,CAAC,CAAvC;AACH;;AAED,SAAO;AACH,IAAA,OAAO,EAAE,OADN;AAEH,IAAA,OAAO,EAAE;AAFN,GAAP;AAIH","sourcesContent":["import { FloatArray, Nullable, IndicesArray } from '../types';\r\nimport { Vector2, Vector3 } from './math.vector';\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, bias: Nullable<Vector2> = null): { minimum: Vector3; maximum: Vector3 } {\r\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    for (var index = indexStart; index < indexStart + indexCount; index++) {\r\n        const offset = indices[index] * 3;\r\n        const x = positions[offset];\r\n        const y = positions[offset + 1];\r\n        const z = positions[offset + 2];\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n    }\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @return minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    for (var index = start, offset = start * stride; index < start + count; index++ , offset += stride) {\r\n        const x = positions[offset];\r\n        const y = positions[offset + 1];\r\n        const z = positions[offset + 2];\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n    }\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum\r\n    };\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}