{"ast":null,"code":"import { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport { Animation } from \"./animation\";\nimport { Size } from '../Maths/math.size'; // Static values to help the garbage collector\n// Quaternion\n\nvar _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0)); // Vector3\n\n\nvar _staticOffsetValueVector3 = Object.freeze(Vector3.Zero()); // Vector2\n\n\nvar _staticOffsetValueVector2 = Object.freeze(Vector2.Zero()); // Size\n\n\nvar _staticOffsetValueSize = Object.freeze(Size.Zero()); // Color3\n\n\nvar _staticOffsetValueColor3 = Object.freeze(Color3.Black());\n/**\r\n * Defines a runtime animation\r\n */\n\n\nvar RuntimeAnimation =\n/** @class */\nfunction () {\n  /**\r\n   * Create a new RuntimeAnimation object\r\n   * @param target defines the target of the animation\r\n   * @param animation defines the source animation object\r\n   * @param scene defines the hosting scene\r\n   * @param host defines the initiating Animatable\r\n   */\n  function RuntimeAnimation(target, animation, scene, host) {\n    var _this = this;\n\n    this._events = new Array();\n    /**\r\n     * The current frame of the runtime animation\r\n     */\n\n    this._currentFrame = 0;\n    /**\r\n     * The original value of the runtime animation\r\n     */\n\n    this._originalValue = new Array();\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\n\n    this._originalBlendValue = null;\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\n\n    this._offsetsCache = {};\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\n\n    this._highLimitsCache = {};\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\n\n    this._stopped = false;\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\n\n    this._blendingFactor = 0;\n    /**\r\n     * The current value of the runtime animation\r\n     */\n\n    this._currentValue = null;\n    this._currentActiveTarget = null;\n    this._directTarget = null;\n    /**\r\n     * The target path of the runtime animation\r\n     */\n\n    this._targetPath = \"\";\n    /**\r\n     * The weight of the runtime animation\r\n     */\n\n    this._weight = 1.0;\n    /**\r\n     * The ratio offset of the runtime animation\r\n     */\n\n    this._ratioOffset = 0;\n    /**\r\n     * The previous delay of the runtime animation\r\n     */\n\n    this._previousDelay = 0;\n    /**\r\n     * The previous ratio of the runtime animation\r\n     */\n\n    this._previousRatio = 0;\n    this._targetIsArray = false;\n    this._animation = animation;\n    this._target = target;\n    this._scene = scene;\n    this._host = host;\n    this._activeTargets = [];\n\n    animation._runtimeAnimations.push(this); // State\n\n\n    this._animationState = {\n      key: 0,\n      repeatCount: 0,\n      loopMode: this._getCorrectLoopMode()\n    };\n\n    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      this._animationState.workValue = Matrix.Zero();\n    } // Limits\n\n\n    this._keys = this._animation.getKeys();\n    this._minFrame = this._keys[0].frame;\n    this._maxFrame = this._keys[this._keys.length - 1].frame;\n    this._minValue = this._keys[0].value;\n    this._maxValue = this._keys[this._keys.length - 1].value; // Add a start key at frame 0 if missing\n\n    if (this._minFrame !== 0) {\n      var newKey = {\n        frame: 0,\n        value: this._minValue\n      };\n\n      this._keys.splice(0, 0, newKey);\n    } // Check data\n\n\n    if (this._target instanceof Array) {\n      var index = 0;\n\n      for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n        var target_1 = _a[_i];\n\n        this._preparePath(target_1, index);\n\n        this._getOriginalValues(index);\n\n        index++;\n      }\n\n      this._targetIsArray = true;\n    } else {\n      this._preparePath(this._target);\n\n      this._getOriginalValues();\n\n      this._targetIsArray = false;\n      this._directTarget = this._activeTargets[0];\n    } // Cloning events locally\n\n\n    var events = animation.getEvents();\n\n    if (events && events.length > 0) {\n      events.forEach(function (e) {\n        _this._events.push(e._clone());\n      });\n    }\n\n    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n  }\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentFrame\", {\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\n    get: function () {\n      return this._currentFrame;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"weight\", {\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\n    get: function () {\n      return this._weight;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"currentValue\", {\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\n    get: function () {\n      return this._currentValue;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"targetPath\", {\n    /**\r\n     * Gets the target path of the runtime animation\r\n     */\n    get: function () {\n      return this._targetPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"target\", {\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\n    get: function () {\n      return this._currentActiveTarget;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RuntimeAnimation.prototype, \"isAdditive\", {\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\n    get: function () {\n      return this._host && this._host.isAdditive;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RuntimeAnimation.prototype._preparePath = function (target, targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var targetPropertyPath = this._animation.targetPropertyPath;\n\n    if (targetPropertyPath.length > 1) {\n      var property = target[targetPropertyPath[0]];\n\n      for (var index = 1; index < targetPropertyPath.length - 1; index++) {\n        property = property[targetPropertyPath[index]];\n      }\n\n      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n      this._activeTargets[targetIndex] = property;\n    } else {\n      this._targetPath = targetPropertyPath[0];\n      this._activeTargets[targetIndex] = target;\n    }\n  };\n\n  Object.defineProperty(RuntimeAnimation.prototype, \"animation\", {\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\n    get: function () {\n      return this._animation;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets the runtime animation to the beginning\r\n   * @param restoreOriginal defines whether to restore the target property to the original value\r\n   */\n\n  RuntimeAnimation.prototype.reset = function (restoreOriginal) {\n    if (restoreOriginal === void 0) {\n      restoreOriginal = false;\n    }\n\n    if (restoreOriginal) {\n      if (this._target instanceof Array) {\n        var index = 0;\n\n        for (var _i = 0, _a = this._target; _i < _a.length; _i++) {\n          var target = _a[_i];\n\n          if (this._originalValue[index] !== undefined) {\n            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n          }\n\n          index++;\n        }\n      } else {\n        if (this._originalValue[0] !== undefined) {\n          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n        }\n      }\n    }\n\n    this._offsetsCache = {};\n    this._highLimitsCache = {};\n    this._currentFrame = 0;\n    this._blendingFactor = 0; // Events\n\n    for (var index = 0; index < this._events.length; index++) {\n      this._events[index].isDone = false;\n    }\n  };\n  /**\r\n   * Specifies if the runtime animation is stopped\r\n   * @returns Boolean specifying if the runtime animation is stopped\r\n   */\n\n\n  RuntimeAnimation.prototype.isStopped = function () {\n    return this._stopped;\n  };\n  /**\r\n   * Disposes of the runtime animation\r\n   */\n\n\n  RuntimeAnimation.prototype.dispose = function () {\n    var index = this._animation.runtimeAnimations.indexOf(this);\n\n    if (index > -1) {\n      this._animation.runtimeAnimations.splice(index, 1);\n    }\n  };\n  /**\r\n   * Apply the interpolated value to the target\r\n   * @param currentValue defines the value computed by the animation\r\n   * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n   */\n\n\n  RuntimeAnimation.prototype.setValue = function (currentValue, weight) {\n    if (this._targetIsArray) {\n      for (var index = 0; index < this._target.length; index++) {\n        var target = this._target[index];\n\n        this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n      }\n\n      return;\n    }\n\n    this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n  };\n\n  RuntimeAnimation.prototype._getOriginalValues = function (targetIndex) {\n    if (targetIndex === void 0) {\n      targetIndex = 0;\n    }\n\n    var originalValue;\n    var target = this._activeTargets[targetIndex];\n\n    if (target.getRestPose && this._targetPath === \"_matrix\") {\n      // For bones\n      originalValue = target.getRestPose();\n    } else {\n      originalValue = target[this._targetPath];\n    }\n\n    if (originalValue && originalValue.clone) {\n      this._originalValue[targetIndex] = originalValue.clone();\n    } else {\n      this._originalValue[targetIndex] = originalValue;\n    }\n  };\n\n  RuntimeAnimation.prototype._setValue = function (target, destination, currentValue, weight, targetIndex) {\n    // Set value\n    this._currentActiveTarget = destination;\n    this._weight = weight;\n\n    if (this._enableBlending && this._blendingFactor <= 1.0) {\n      if (!this._originalBlendValue) {\n        var originalValue = destination[this._targetPath];\n\n        if (originalValue.clone) {\n          this._originalBlendValue = originalValue.clone();\n        } else {\n          this._originalBlendValue = originalValue;\n        }\n      }\n\n      if (this._originalBlendValue.m) {\n        // Matrix\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\n          if (this._currentValue) {\n            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        } else {\n          if (this._currentValue) {\n            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        }\n      } else {\n        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n      }\n\n      var blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n      this._blendingFactor += blendingSpeed;\n    } else {\n      this._currentValue = currentValue;\n    }\n\n    if (weight !== -1.0) {\n      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n    } else {\n      destination[this._targetPath] = this._currentValue;\n    }\n\n    if (target.markAsDirty) {\n      target.markAsDirty(this._animation.targetProperty);\n    }\n  };\n  /**\r\n   * Gets the loop pmode of the runtime animation\r\n   * @returns Loop Mode\r\n   */\n\n\n  RuntimeAnimation.prototype._getCorrectLoopMode = function () {\n    if (this._target && this._target.animationPropertiesOverride) {\n      return this._target.animationPropertiesOverride.loopMode;\n    }\n\n    return this._animation.loopMode;\n  };\n  /**\r\n   * Move the current animation to a given frame\r\n   * @param frame defines the frame to move to\r\n   */\n\n\n  RuntimeAnimation.prototype.goToFrame = function (frame) {\n    var keys = this._animation.getKeys();\n\n    if (frame < keys[0].frame) {\n      frame = keys[0].frame;\n    } else if (frame > keys[keys.length - 1].frame) {\n      frame = keys[keys.length - 1].frame;\n    } // Need to reset animation events\n\n\n    var events = this._events;\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset events in the future\n          events[index].isDone = events[index].frame < frame;\n        }\n      }\n    }\n\n    this._currentFrame = frame;\n\n    var currentValue = this._animation._interpolate(frame, this._animationState);\n\n    this.setValue(currentValue, -1);\n  };\n  /**\r\n   * @hidden Internal use only\r\n   */\n\n\n  RuntimeAnimation.prototype._prepareForSpeedRatioChange = function (newSpeedRatio) {\n    var newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\n    this._ratioOffset = this._previousRatio - newRatio;\n  };\n  /**\r\n   * Execute the current animation\r\n   * @param delay defines the delay to add to the current frame\r\n   * @param from defines the lower bound of the animation range\r\n   * @param to defines the upper bound of the animation range\r\n   * @param loop defines if the current animation must loop\r\n   * @param speedRatio defines the current speed ratio\r\n   * @param weight defines the weight of the animation (default is -1 so no weight)\r\n   * @param onLoop optional callback called when animation loops\r\n   * @returns a boolean indicating if the animation is running\r\n   */\n\n\n  RuntimeAnimation.prototype.animate = function (delay, from, to, loop, speedRatio, weight) {\n    if (weight === void 0) {\n      weight = -1.0;\n    }\n\n    var animation = this._animation;\n    var targetPropertyPath = animation.targetPropertyPath;\n\n    if (!targetPropertyPath || targetPropertyPath.length < 1) {\n      this._stopped = true;\n      return false;\n    }\n\n    var returnValue = true; // Check limits\n\n    if (from < this._minFrame || from > this._maxFrame) {\n      from = this._minFrame;\n    }\n\n    if (to < this._minFrame || to > this._maxFrame) {\n      to = this._maxFrame;\n    }\n\n    var range = to - from;\n    var offsetValue; // Compute ratio which represents the frame delta between from and to\n\n    var ratio = delay * (animation.framePerSecond * speedRatio) / 1000.0 + this._ratioOffset;\n    var highLimitValue = 0;\n    this._previousDelay = delay;\n    this._previousRatio = ratio;\n\n    if (!loop && to >= from && ratio >= range) {\n      // If we are out of range and not looping get back to caller\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._maxValue);\n    } else if (!loop && from >= to && ratio <= range) {\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._minValue);\n    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n      var keyOffset = to.toString() + from.toString();\n\n      if (!this._offsetsCache[keyOffset]) {\n        this._animationState.repeatCount = 0;\n        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\n\n        var fromValue = animation._interpolate(from, this._animationState);\n\n        var toValue = animation._interpolate(to, this._animationState);\n\n        this._animationState.loopMode = this._getCorrectLoopMode();\n\n        switch (animation.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            this._offsetsCache[keyOffset] = toValue - fromValue;\n            break;\n          // Quaternion\n\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector3\n\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Vector2\n\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Size\n\n          case Animation.ANIMATIONTYPE_SIZE:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n          // Color3\n\n          case Animation.ANIMATIONTYPE_COLOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n\n          default:\n            break;\n        }\n\n        this._highLimitsCache[keyOffset] = toValue;\n      }\n\n      highLimitValue = this._highLimitsCache[keyOffset];\n      offsetValue = this._offsetsCache[keyOffset];\n    }\n\n    if (offsetValue === undefined) {\n      switch (animation.dataType) {\n        // Float\n        case Animation.ANIMATIONTYPE_FLOAT:\n          offsetValue = 0;\n          break;\n        // Quaternion\n\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          offsetValue = _staticOffsetValueQuaternion;\n          break;\n        // Vector3\n\n        case Animation.ANIMATIONTYPE_VECTOR3:\n          offsetValue = _staticOffsetValueVector3;\n          break;\n        // Vector2\n\n        case Animation.ANIMATIONTYPE_VECTOR2:\n          offsetValue = _staticOffsetValueVector2;\n          break;\n        // Size\n\n        case Animation.ANIMATIONTYPE_SIZE:\n          offsetValue = _staticOffsetValueSize;\n          break;\n        // Color3\n\n        case Animation.ANIMATIONTYPE_COLOR3:\n          offsetValue = _staticOffsetValueColor3;\n      }\n    } // Compute value\n\n\n    var currentFrame;\n\n    if (this._host && this._host.syncRoot) {\n      var syncRoot = this._host.syncRoot;\n      var hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n      currentFrame = from + (to - from) * hostNormalizedFrame;\n    } else {\n      currentFrame = returnValue && range !== 0 ? from + ratio % range : to;\n    } // Reset events if looping\n\n\n    var events = this._events;\n\n    if (range > 0 && this.currentFrame > currentFrame || range < 0 && this.currentFrame < currentFrame) {\n      this._onLoop(); // Need to reset animation events\n\n\n      if (events.length) {\n        for (var index = 0; index < events.length; index++) {\n          if (!events[index].onlyOnce) {\n            // reset event, the animation is looping\n            events[index].isDone = false;\n          }\n        }\n      }\n    }\n\n    this._currentFrame = currentFrame;\n    this._animationState.repeatCount = range === 0 ? 0 : ratio / range >> 0;\n    this._animationState.highLimitValue = highLimitValue;\n    this._animationState.offsetValue = offsetValue;\n\n    var currentValue = animation._interpolate(currentFrame, this._animationState); // Set value\n\n\n    this.setValue(currentValue, weight); // Check events\n\n    if (events.length) {\n      for (var index = 0; index < events.length; index++) {\n        // Make sure current frame has passed event frame and that event frame is within the current range\n        // Also, handle both forward and reverse animations\n        if (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from || range < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {\n          var event = events[index];\n\n          if (!event.isDone) {\n            // If event should be done only once, remove it.\n            if (event.onlyOnce) {\n              events.splice(index, 1);\n              index--;\n            }\n\n            event.isDone = true;\n            event.action(currentFrame);\n          } // Don't do anything if the event has already be done.\n\n        }\n      }\n    }\n\n    if (!returnValue) {\n      this._stopped = true;\n    }\n\n    return returnValue;\n  };\n\n  return RuntimeAnimation;\n}();\n\nexport { RuntimeAnimation };","map":{"version":3,"sources":["../../../sourceES6/core/Animations/runtimeAnimation.ts"],"names":[],"mappings":"AACA,SAAS,UAAT,EAAqB,OAArB,EAA8B,OAA9B,EAAuC,MAAvC,QAAqD,sBAArD;AACA,SAAS,MAAT,QAAuB,qBAAvB;AACA,SAAS,SAAT,QAA4C,aAA5C;AAOA,SAAS,IAAT,QAAqB,oBAArB,C,CAEA;AAEA;;AACA,IAAM,4BAA4B,GAA8B,MAAM,CAAC,MAAP,CAAc,IAAI,UAAJ,CAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAd,CAAhE,C,CAEA;;;AACA,IAAM,yBAAyB,GAA2B,MAAM,CAAC,MAAP,CAAc,OAAO,CAAC,IAAR,EAAd,CAA1D,C,CAEA;;;AACA,IAAM,yBAAyB,GAA2B,MAAM,CAAC,MAAP,CAAc,OAAO,CAAC,IAAR,EAAd,CAA1D,C,CAEA;;;AACA,IAAM,sBAAsB,GAAwB,MAAM,CAAC,MAAP,CAAc,IAAI,CAAC,IAAL,EAAd,CAApD,C,CAEA;;;AACA,IAAM,wBAAwB,GAA0B,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,KAAP,EAAd,CAAxD;AAEA;;;;;AAGA,IAAA,gBAAA;AAAA;AAAA,YAAA;AAwJI;;;;;;;AAOA,WAAA,gBAAA,CAAmB,MAAnB,EAAgC,SAAhC,EAAsD,KAAtD,EAAoE,IAApE,EAAoF;AAApF,QAAA,KAAA,GAAA,IAAA;;AA9JQ,SAAA,OAAA,GAAU,IAAI,KAAJ,EAAV;AAER;;;;AAGQ,SAAA,aAAA,GAAwB,CAAxB;AAiBR;;;;AAGQ,SAAA,cAAA,GAAiB,IAAI,KAAJ,EAAjB;AAER;;;;AAGQ,SAAA,mBAAA,GAAqC,IAArC;AAER;;;;AAGQ,SAAA,aAAA,GAAwC,EAAxC;AAER;;;;AAGQ,SAAA,gBAAA,GAA2C,EAA3C;AAER;;;;AAGQ,SAAA,QAAA,GAAW,KAAX;AAER;;;;AAGQ,SAAA,eAAA,GAAkB,CAAlB;AAOR;;;;AAGQ,SAAA,aAAA,GAA+B,IAA/B;AASA,SAAA,oBAAA,GAAsC,IAAtC;AACA,SAAA,aAAA,GAA+B,IAA/B;AAER;;;;AAGQ,SAAA,WAAA,GAAsB,EAAtB;AAER;;;;AAGQ,SAAA,OAAA,GAAU,GAAV;AAER;;;;AAGQ,SAAA,YAAA,GAAe,CAAf;AAER;;;;AAGQ,SAAA,cAAA,GAAyB,CAAzB;AAER;;;;AAGQ,SAAA,cAAA,GAAyB,CAAzB;AASA,SAAA,cAAA,GAAiB,KAAjB;AAuDJ,SAAK,UAAL,GAAkB,SAAlB;AACA,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,cAAL,GAAsB,EAAtB;;AAEA,IAAA,SAAS,CAAC,kBAAV,CAA6B,IAA7B,CAAkC,IAAlC,EAPgF,CAShF;;;AACA,SAAK,eAAL,GAAuB;AACnB,MAAA,GAAG,EAAE,CADc;AAEnB,MAAA,WAAW,EAAE,CAFM;AAGnB,MAAA,QAAQ,EAAE,KAAK,mBAAL;AAHS,KAAvB;;AAMA,QAAI,KAAK,UAAL,CAAgB,QAAhB,KAA6B,SAAS,CAAC,oBAA3C,EAAiE;AAC7D,WAAK,eAAL,CAAqB,SAArB,GAAiC,MAAM,CAAC,IAAP,EAAjC;AACH,KAlB+E,CAoBhF;;;AACA,SAAK,KAAL,GAAa,KAAK,UAAL,CAAgB,OAAhB,EAAb;AACA,SAAK,SAAL,GAAiB,KAAK,KAAL,CAAW,CAAX,EAAc,KAA/B;AACA,SAAK,SAAL,GAAiB,KAAK,KAAL,CAAW,KAAK,KAAL,CAAW,MAAX,GAAoB,CAA/B,EAAkC,KAAnD;AACA,SAAK,SAAL,GAAiB,KAAK,KAAL,CAAW,CAAX,EAAc,KAA/B;AACA,SAAK,SAAL,GAAiB,KAAK,KAAL,CAAW,KAAK,KAAL,CAAW,MAAX,GAAoB,CAA/B,EAAkC,KAAnD,CAzBgF,CA2BhF;;AACA,QAAI,KAAK,SAAL,KAAmB,CAAvB,EAA0B;AACtB,UAAM,MAAM,GAAG;AAAE,QAAA,KAAK,EAAE,CAAT;AAAY,QAAA,KAAK,EAAE,KAAK;AAAxB,OAAf;;AACA,WAAK,KAAL,CAAW,MAAX,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,MAAxB;AACH,KA/B+E,CAiChF;;;AACA,QAAI,KAAK,OAAL,YAAwB,KAA5B,EAAmC;AAC/B,UAAI,KAAK,GAAG,CAAZ;;AACA,WAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAmC;AAA9B,YAAM,QAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;;AACD,aAAK,YAAL,CAAkB,QAAlB,EAA0B,KAA1B;;AACA,aAAK,kBAAL,CAAwB,KAAxB;;AACA,QAAA,KAAK;AACR;;AACD,WAAK,cAAL,GAAsB,IAAtB;AACH,KARD,MASK;AACD,WAAK,YAAL,CAAkB,KAAK,OAAvB;;AACA,WAAK,kBAAL;;AACA,WAAK,cAAL,GAAsB,KAAtB;AACA,WAAK,aAAL,GAAqB,KAAK,cAAL,CAAoB,CAApB,CAArB;AACH,KAhD+E,CAkDhF;;;AACA,QAAI,MAAM,GAAG,SAAS,CAAC,SAAV,EAAb;;AACA,QAAI,MAAM,IAAI,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC;AAC7B,MAAA,MAAM,CAAC,OAAP,CAAe,UAAC,CAAD,EAAE;AACb,QAAA,KAAI,CAAC,OAAL,CAAa,IAAb,CAAkB,CAAC,CAAC,MAAF,EAAlB;AACH,OAFD;AAGH;;AAED,SAAK,eAAL,GAAuB,MAAM,IAAI,MAAM,CAAC,2BAAjB,GAA+C,MAAM,CAAC,2BAAP,CAAmC,cAAlF,GAAmG,KAAK,UAAL,CAAgB,cAA1I;AACH;;AA5GD,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA,YAAA;AACI,aAAO,KAAK,aAAZ;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAHjB;;;SAGA,YAAA;AACI,aAAO,KAAK,OAAZ;AACH,KAFgB;qBAAA;;AAAA,GAAjB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,cAAX,EAAuB;AAHvB;;;SAGA,YAAA;AACI,aAAO,KAAK,aAAZ;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,WAAZ;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,QAAX,EAAiB;AAHjB;;;SAGA,YAAA;AACI,aAAO,KAAK,oBAAZ;AACH,KAFgB;qBAAA;;AAAA,GAAjB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,UAAhC;AACH,KAFoB;qBAAA;;AAAA,GAArB;;AA2EQ,EAAA,gBAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,MAArB,EAAkC,WAAlC,EAAiD;AAAf,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,CAAA;AAAe;;AAC7C,QAAI,kBAAkB,GAAG,KAAK,UAAL,CAAgB,kBAAzC;;AAEA,QAAI,kBAAkB,CAAC,MAAnB,GAA4B,CAAhC,EAAmC;AAC/B,UAAI,QAAQ,GAAG,MAAM,CAAC,kBAAkB,CAAC,CAAD,CAAnB,CAArB;;AAEA,WAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,kBAAkB,CAAC,MAAnB,GAA4B,CAAxD,EAA2D,KAAK,EAAhE,EAAoE;AAChE,QAAA,QAAQ,GAAG,QAAQ,CAAC,kBAAkB,CAAC,KAAD,CAAnB,CAAnB;AACH;;AAED,WAAK,WAAL,GAAmB,kBAAkB,CAAC,kBAAkB,CAAC,MAAnB,GAA4B,CAA7B,CAArC;AACA,WAAK,cAAL,CAAoB,WAApB,IAAmC,QAAnC;AACH,KATD,MASO;AACH,WAAK,WAAL,GAAmB,kBAAkB,CAAC,CAAD,CAArC;AACA,WAAK,cAAL,CAAoB,WAApB,IAAmC,MAAnC;AACH;AACJ,GAhBO;;AAqBR,EAAA,MAAA,CAAA,cAAA,CAAW,gBAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA,YAAA;AACI,aAAO,KAAK,UAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAIA;;;;;AAIO,EAAA,gBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,eAAb,EAAoC;AAAvB,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,KAAA;AAAuB;;AAChC,QAAI,eAAJ,EAAqB;AACjB,UAAI,KAAK,OAAL,YAAwB,KAA5B,EAAmC;AAC/B,YAAI,KAAK,GAAG,CAAZ;;AACA,aAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,OAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAmC;AAA9B,cAAM,MAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;;AACD,cAAI,KAAK,cAAL,CAAoB,KAApB,MAA+B,SAAnC,EAA8C;AAC1C,iBAAK,SAAL,CAAe,MAAf,EAAuB,KAAK,cAAL,CAAoB,KAApB,CAAvB,EAAmD,KAAK,cAAL,CAAoB,KAApB,CAAnD,EAA+E,CAAC,CAAhF,EAAmF,KAAnF;AACH;;AACD,UAAA,KAAK;AACR;AACJ,OARD,MASK;AACD,YAAI,KAAK,cAAL,CAAoB,CAApB,MAA2B,SAA/B,EAA0C;AACtC,eAAK,SAAL,CAAe,KAAK,OAApB,EAA6B,KAAK,aAAlC,EAAiD,KAAK,cAAL,CAAoB,CAApB,CAAjD,EAAyE,CAAC,CAA1E,EAA6E,CAA7E;AACH;AACJ;AACJ;;AAED,SAAK,aAAL,GAAqB,EAArB;AACA,SAAK,gBAAL,GAAwB,EAAxB;AACA,SAAK,aAAL,GAAqB,CAArB;AACA,SAAK,eAAL,GAAuB,CAAvB,CArBgC,CAuBhC;;AACA,SAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,KAAK,OAAL,CAAa,MAAzC,EAAiD,KAAK,EAAtD,EAA0D;AACtD,WAAK,OAAL,CAAa,KAAb,EAAoB,MAApB,GAA6B,KAA7B;AACH;AACJ,GA3BM;AA6BP;;;;;;AAIO,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,KAAK,QAAZ;AACH,GAFM;AAIP;;;;;AAGO,EAAA,gBAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,QAAI,KAAK,GAAG,KAAK,UAAL,CAAgB,iBAAhB,CAAkC,OAAlC,CAA0C,IAA1C,CAAZ;;AAEA,QAAI,KAAK,GAAG,CAAC,CAAb,EAAgB;AACZ,WAAK,UAAL,CAAgB,iBAAhB,CAAkC,MAAlC,CAAyC,KAAzC,EAAgD,CAAhD;AACH;AACJ,GANM;AAQP;;;;;;;AAKO,EAAA,gBAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,YAAhB,EAAmC,MAAnC,EAAiD;AAC7C,QAAI,KAAK,cAAT,EAAyB;AACrB,WAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,KAAK,OAAL,CAAa,MAAzC,EAAiD,KAAK,EAAtD,EAA0D;AACtD,YAAM,MAAM,GAAG,KAAK,OAAL,CAAa,KAAb,CAAf;;AACA,aAAK,SAAL,CAAe,MAAf,EAAuB,KAAK,cAAL,CAAoB,KAApB,CAAvB,EAAmD,YAAnD,EAAiE,MAAjE,EAAyE,KAAzE;AACH;;AACD;AACH;;AACD,SAAK,SAAL,CAAe,KAAK,OAApB,EAA6B,KAAK,aAAlC,EAAiD,YAAjD,EAA+D,MAA/D,EAAuE,CAAvE;AACH,GATM;;AAWC,EAAA,gBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,WAA3B,EAA0C;AAAf,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,CAAA;AAAe;;AACtC,QAAI,aAAJ;AACA,QAAI,MAAM,GAAG,KAAK,cAAL,CAAoB,WAApB,CAAb;;AAEA,QAAI,MAAM,CAAC,WAAP,IAAsB,KAAK,WAAL,KAAqB,SAA/C,EAA0D;AAAE;AACxD,MAAA,aAAa,GAAG,MAAM,CAAC,WAAP,EAAhB;AACH,KAFD,MAEO;AACH,MAAA,aAAa,GAAG,MAAM,CAAC,KAAK,WAAN,CAAtB;AACH;;AAED,QAAI,aAAa,IAAI,aAAa,CAAC,KAAnC,EAA0C;AACtC,WAAK,cAAL,CAAoB,WAApB,IAAmC,aAAa,CAAC,KAAd,EAAnC;AACH,KAFD,MAEO;AACH,WAAK,cAAL,CAAoB,WAApB,IAAmC,aAAnC;AACH;AACJ,GAfO;;AAiBA,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,MAAlB,EAA+B,WAA/B,EAAiD,YAAjD,EAAoE,MAApE,EAAoF,WAApF,EAAuG;AACnG;AACA,SAAK,oBAAL,GAA4B,WAA5B;AAEA,SAAK,OAAL,GAAe,MAAf;;AAEA,QAAI,KAAK,eAAL,IAAwB,KAAK,eAAL,IAAwB,GAApD,EAAyD;AACrD,UAAI,CAAC,KAAK,mBAAV,EAA+B;AAC3B,YAAI,aAAa,GAAG,WAAW,CAAC,KAAK,WAAN,CAA/B;;AAEA,YAAI,aAAa,CAAC,KAAlB,EAAyB;AACrB,eAAK,mBAAL,GAA2B,aAAa,CAAC,KAAd,EAA3B;AACH,SAFD,MAEO;AACH,eAAK,mBAAL,GAA2B,aAA3B;AACH;AACJ;;AAED,UAAI,KAAK,mBAAL,CAAyB,CAA7B,EAAgC;AAAE;AAC9B,YAAI,SAAS,CAAC,oCAAd,EAAoD;AAChD,cAAI,KAAK,aAAT,EAAwB;AACpB,YAAA,MAAM,CAAC,kBAAP,CAA0B,KAAK,mBAA/B,EAAoD,YAApD,EAAkE,KAAK,eAAvE,EAAwF,KAAK,aAA7F;AACH,WAFD,MAEO;AACH,iBAAK,aAAL,GAAqB,MAAM,CAAC,aAAP,CAAqB,KAAK,mBAA1B,EAA+C,YAA/C,EAA6D,KAAK,eAAlE,CAArB;AACH;AACJ,SAND,MAMO;AACH,cAAI,KAAK,aAAT,EAAwB;AACpB,YAAA,MAAM,CAAC,SAAP,CAAiB,KAAK,mBAAtB,EAA2C,YAA3C,EAAyD,KAAK,eAA9D,EAA+E,KAAK,aAApF;AACH,WAFD,MAEO;AACH,iBAAK,aAAL,GAAqB,MAAM,CAAC,IAAP,CAAY,KAAK,mBAAjB,EAAsC,YAAtC,EAAoD,KAAK,eAAzD,CAArB;AACH;AACJ;AACJ,OAdD,MAcO;AACH,aAAK,aAAL,GAAqB,SAAS,CAAC,cAAV,CAAyB,KAAK,mBAA9B,EAAmD,YAAnD,EAAiE,KAAK,eAAtE,CAArB;AACH;;AAED,UAAM,aAAa,GAAG,MAAM,IAAI,MAAM,CAAC,2BAAjB,GAA+C,MAAM,CAAC,2BAAP,CAAmC,aAAlF,GAAkG,KAAK,UAAL,CAAgB,aAAxI;AACA,WAAK,eAAL,IAAwB,aAAxB;AACH,KA/BD,MA+BO;AACH,WAAK,aAAL,GAAqB,YAArB;AACH;;AAED,QAAI,MAAM,KAAK,CAAC,GAAhB,EAAqB;AACjB,WAAK,MAAL,CAAY,sCAAZ,CAAmD,IAAnD,EAAyD,KAAK,cAAL,CAAoB,WAApB,CAAzD;AACH,KAFD,MAEO;AACH,MAAA,WAAW,CAAC,KAAK,WAAN,CAAX,GAAgC,KAAK,aAArC;AACH;;AAED,QAAI,MAAM,CAAC,WAAX,EAAwB;AACpB,MAAA,MAAM,CAAC,WAAP,CAAmB,KAAK,UAAL,CAAgB,cAAnC;AACH;AACJ,GAlDO;AAoDR;;;;;;AAIQ,EAAA,gBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,YAAA;AACI,QAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,2BAAjC,EAA8D;AAC1D,aAAO,KAAK,OAAL,CAAa,2BAAb,CAAyC,QAAhD;AACH;;AAED,WAAO,KAAK,UAAL,CAAgB,QAAvB;AACH,GANO;AAQR;;;;;;AAIO,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAA8B;AAC1B,QAAI,IAAI,GAAG,KAAK,UAAL,CAAgB,OAAhB,EAAX;;AAEA,QAAI,KAAK,GAAG,IAAI,CAAC,CAAD,CAAJ,CAAQ,KAApB,EAA2B;AACvB,MAAA,KAAK,GAAG,IAAI,CAAC,CAAD,CAAJ,CAAQ,KAAhB;AACH,KAFD,MAEO,IAAI,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAJ,CAAsB,KAAlC,EAAyC;AAC5C,MAAA,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAJ,CAAsB,KAA9B;AACH,KAPyB,CAS1B;;;AACA,QAAM,MAAM,GAAG,KAAK,OAApB;;AACA,QAAI,MAAM,CAAC,MAAX,EAAmB;AACf,WAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,MAAM,CAAC,MAAnC,EAA2C,KAAK,EAAhD,EAAoD;AAChD,YAAI,CAAC,MAAM,CAAC,KAAD,CAAN,CAAc,QAAnB,EAA6B;AACzB;AACA,UAAA,MAAM,CAAC,KAAD,CAAN,CAAc,MAAd,GAAuB,MAAM,CAAC,KAAD,CAAN,CAAc,KAAd,GAAsB,KAA7C;AACH;AACJ;AACJ;;AAED,SAAK,aAAL,GAAqB,KAArB;;AACA,QAAI,YAAY,GAAG,KAAK,UAAL,CAAgB,YAAhB,CAA6B,KAA7B,EAAoC,KAAK,eAAzC,CAAnB;;AAEA,SAAK,QAAL,CAAc,YAAd,EAA4B,CAAC,CAA7B;AACH,GAxBM;AA0BP;;;;;AAGO,EAAA,gBAAA,CAAA,SAAA,CAAA,2BAAA,GAAP,UAAmC,aAAnC,EAAwD;AACpD,QAAI,QAAQ,GAAG,KAAK,cAAL,IAAuB,KAAK,UAAL,CAAgB,cAAhB,GAAiC,aAAxD,IAAyE,MAAxF;AAEA,SAAK,YAAL,GAAoB,KAAK,cAAL,GAAsB,QAA1C;AACH,GAJM;AAMP;;;;;;;;;;;;;AAWO,EAAA,gBAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAA8B,IAA9B,EAA4C,EAA5C,EAAwD,IAAxD,EAAuE,UAAvE,EAA2F,MAA3F,EAAwG;AAAb,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAU,GAAV;AAAa;;AACpG,QAAI,SAAS,GAAG,KAAK,UAArB;AACA,QAAI,kBAAkB,GAAG,SAAS,CAAC,kBAAnC;;AACA,QAAI,CAAC,kBAAD,IAAuB,kBAAkB,CAAC,MAAnB,GAA4B,CAAvD,EAA0D;AACtD,WAAK,QAAL,GAAgB,IAAhB;AACA,aAAO,KAAP;AACH;;AAED,QAAI,WAAW,GAAG,IAAlB,CARoG,CAUpG;;AACA,QAAI,IAAI,GAAG,KAAK,SAAZ,IAAyB,IAAI,GAAG,KAAK,SAAzC,EAAoD;AAChD,MAAA,IAAI,GAAG,KAAK,SAAZ;AACH;;AACD,QAAI,EAAE,GAAG,KAAK,SAAV,IAAuB,EAAE,GAAG,KAAK,SAArC,EAAgD;AAC5C,MAAA,EAAE,GAAG,KAAK,SAAV;AACH;;AAED,QAAM,KAAK,GAAG,EAAE,GAAG,IAAnB;AACA,QAAI,WAAJ,CAnBoG,CAqBpG;;AACA,QAAM,KAAK,GAAI,KAAK,IAAI,SAAS,CAAC,cAAV,GAA2B,UAA/B,CAAL,GAAkD,MAAnD,GAA6D,KAAK,YAAhF;AACA,QAAI,cAAc,GAAG,CAArB;AAEA,SAAK,cAAL,GAAsB,KAAtB;AACA,SAAK,cAAL,GAAsB,KAAtB;;AAEA,QAAI,CAAC,IAAD,IAAU,EAAE,IAAI,IAAN,IAAc,KAAK,IAAI,KAArC,EAA6C;AAAE;AAC3C,MAAA,WAAW,GAAG,KAAd;AACA,MAAA,cAAc,GAAG,SAAS,CAAC,YAAV,CAAuB,KAAK,SAA5B,CAAjB;AACH,KAHD,MAGO,IAAI,CAAC,IAAD,IAAU,IAAI,IAAI,EAAR,IAAc,KAAK,IAAI,KAArC,EAA6C;AAChD,MAAA,WAAW,GAAG,KAAd;AACA,MAAA,cAAc,GAAG,SAAS,CAAC,YAAV,CAAuB,KAAK,SAA5B,CAAjB;AACH,KAHM,MAGA,IAAI,KAAK,eAAL,CAAqB,QAArB,KAAkC,SAAS,CAAC,uBAAhD,EAAyE;AAC5E,UAAI,SAAS,GAAG,EAAE,CAAC,QAAH,KAAgB,IAAI,CAAC,QAAL,EAAhC;;AACA,UAAI,CAAC,KAAK,aAAL,CAAmB,SAAnB,CAAL,EAAoC;AAChC,aAAK,eAAL,CAAqB,WAArB,GAAmC,CAAnC;AACA,aAAK,eAAL,CAAqB,QAArB,GAAgC,SAAS,CAAC,uBAA1C;;AACA,YAAI,SAAS,GAAG,SAAS,CAAC,YAAV,CAAuB,IAAvB,EAA6B,KAAK,eAAlC,CAAhB;;AACA,YAAI,OAAO,GAAG,SAAS,CAAC,YAAV,CAAuB,EAAvB,EAA2B,KAAK,eAAhC,CAAd;;AAEA,aAAK,eAAL,CAAqB,QAArB,GAAgC,KAAK,mBAAL,EAAhC;;AACA,gBAAQ,SAAS,CAAC,QAAlB;AACI;AACA,eAAK,SAAS,CAAC,mBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,GAAG,SAA1C;AACA;AACJ;;AACA,eAAK,SAAS,CAAC,wBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAhC;AACA;AACJ;;AACA,eAAK,SAAS,CAAC,qBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAhC;AACJ;;AACA,eAAK,SAAS,CAAC,qBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAhC;AACJ;;AACA,eAAK,SAAS,CAAC,kBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAhC;AACJ;;AACA,eAAK,SAAS,CAAC,oBAAf;AACI,iBAAK,aAAL,CAAmB,SAAnB,IAAgC,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAhC;;AACJ;AACI;AAtBR;;AAyBA,aAAK,gBAAL,CAAsB,SAAtB,IAAmC,OAAnC;AACH;;AAED,MAAA,cAAc,GAAG,KAAK,gBAAL,CAAsB,SAAtB,CAAjB;AACA,MAAA,WAAW,GAAG,KAAK,aAAL,CAAmB,SAAnB,CAAd;AACH;;AAED,QAAI,WAAW,KAAK,SAApB,EAA+B;AAC3B,cAAQ,SAAS,CAAC,QAAlB;AACI;AACA,aAAK,SAAS,CAAC,mBAAf;AACI,UAAA,WAAW,GAAG,CAAd;AACA;AACJ;;AACA,aAAK,SAAS,CAAC,wBAAf;AACI,UAAA,WAAW,GAAG,4BAAd;AACA;AACJ;;AACA,aAAK,SAAS,CAAC,qBAAf;AACI,UAAA,WAAW,GAAG,yBAAd;AACA;AACJ;;AACA,aAAK,SAAS,CAAC,qBAAf;AACI,UAAA,WAAW,GAAG,yBAAd;AACA;AACJ;;AACA,aAAK,SAAS,CAAC,kBAAf;AACI,UAAA,WAAW,GAAG,sBAAd;AACA;AACJ;;AACA,aAAK,SAAS,CAAC,oBAAf;AACI,UAAA,WAAW,GAAG,wBAAd;AAvBR;AAyBH,KArGmG,CAuGpG;;;AACA,QAAI,YAAJ;;AAEA,QAAI,KAAK,KAAL,IAAc,KAAK,KAAL,CAAW,QAA7B,EAAuC;AACnC,UAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,QAA5B;AACA,UAAM,mBAAmB,GAAG,CAAC,QAAQ,CAAC,WAAT,GAAuB,QAAQ,CAAC,SAAjC,KAA+C,QAAQ,CAAC,OAAT,GAAmB,QAAQ,CAAC,SAA3E,CAA5B;AACA,MAAA,YAAY,GAAG,IAAI,GAAG,CAAC,EAAE,GAAG,IAAN,IAAc,mBAApC;AACH,KAJD,MAIO;AACH,MAAA,YAAY,GAAI,WAAW,IAAI,KAAK,KAAK,CAA1B,GAA+B,IAAI,GAAG,KAAK,GAAG,KAA9C,GAAsD,EAArE;AACH,KAhHmG,CAkHpG;;;AACA,QAAM,MAAM,GAAG,KAAK,OAApB;;AACA,QAAI,KAAK,GAAG,CAAR,IAAa,KAAK,YAAL,GAAoB,YAAjC,IACA,KAAK,GAAG,CAAR,IAAa,KAAK,YAAL,GAAoB,YADrC,EACmD;AAC/C,WAAK,OAAL,GAD+C,CAG/C;;;AACA,UAAI,MAAM,CAAC,MAAX,EAAmB;AACf,aAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,MAAM,CAAC,MAAnC,EAA2C,KAAK,EAAhD,EAAoD;AAChD,cAAI,CAAC,MAAM,CAAC,KAAD,CAAN,CAAc,QAAnB,EAA6B;AACzB;AACA,YAAA,MAAM,CAAC,KAAD,CAAN,CAAc,MAAd,GAAuB,KAAvB;AACH;AACJ;AACJ;AACJ;;AACD,SAAK,aAAL,GAAqB,YAArB;AACA,SAAK,eAAL,CAAqB,WAArB,GAAmC,KAAK,KAAK,CAAV,GAAc,CAAd,GAAmB,KAAK,GAAG,KAAT,IAAmB,CAAxE;AACA,SAAK,eAAL,CAAqB,cAArB,GAAsC,cAAtC;AACA,SAAK,eAAL,CAAqB,WAArB,GAAmC,WAAnC;;AAEA,QAAM,YAAY,GAAG,SAAS,CAAC,YAAV,CAAuB,YAAvB,EAAqC,KAAK,eAA1C,CAArB,CAvIoG,CAyIpG;;;AACA,SAAK,QAAL,CAAc,YAAd,EAA4B,MAA5B,EA1IoG,CA4IpG;;AACA,QAAI,MAAM,CAAC,MAAX,EAAmB;AACf,WAAK,IAAI,KAAK,GAAG,CAAjB,EAAoB,KAAK,GAAG,MAAM,CAAC,MAAnC,EAA2C,KAAK,EAAhD,EAAoD;AAChD;AACA;AACA,YACK,KAAK,GAAG,CAAR,IAAa,YAAY,IAAI,MAAM,CAAC,KAAD,CAAN,CAAc,KAA3C,IAAoD,MAAM,CAAC,KAAD,CAAN,CAAc,KAAd,IAAuB,IAA5E,IACC,KAAK,GAAG,CAAR,IAAa,YAAY,IAAI,MAAM,CAAC,KAAD,CAAN,CAAc,KAA3C,IAAoD,MAAM,CAAC,KAAD,CAAN,CAAc,KAAd,IAAuB,IAFhF,EAGE;AACE,cAAI,KAAK,GAAG,MAAM,CAAC,KAAD,CAAlB;;AACA,cAAI,CAAC,KAAK,CAAC,MAAX,EAAmB;AACf;AACA,gBAAI,KAAK,CAAC,QAAV,EAAoB;AAChB,cAAA,MAAM,CAAC,MAAP,CAAc,KAAd,EAAqB,CAArB;AACA,cAAA,KAAK;AACR;;AACD,YAAA,KAAK,CAAC,MAAN,GAAe,IAAf;AACA,YAAA,KAAK,CAAC,MAAN,CAAa,YAAb;AACH,WAVH,CAUI;;AACL;AACJ;AACJ;;AAED,QAAI,CAAC,WAAL,EAAkB;AACd,WAAK,QAAL,GAAgB,IAAhB;AACH;;AAED,WAAO,WAAP;AACH,GAxKM;;AAyKX,SAAA,gBAAA;AAAC,CArmBD,EAAA","sourcesContent":["import { DeepImmutable, Nullable } from \"../types\";\r\nimport { Quaternion, Vector3, Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Animation, _IAnimationState } from \"./animation\";\r\nimport { AnimationEvent } from \"./animationEvent\";\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { IAnimationKey } from './animationKey';\r\nimport { Size } from '../Maths/math.size';\r\n\r\n// Static values to help the garbage collector\r\n\r\n// Quaternion\r\nconst _staticOffsetValueQuaternion: DeepImmutable<Quaternion> = Object.freeze(new Quaternion(0, 0, 0, 0));\r\n\r\n// Vector3\r\nconst _staticOffsetValueVector3: DeepImmutable<Vector3> = Object.freeze(Vector3.Zero());\r\n\r\n// Vector2\r\nconst _staticOffsetValueVector2: DeepImmutable<Vector2> = Object.freeze(Vector2.Zero());\r\n\r\n// Size\r\nconst _staticOffsetValueSize: DeepImmutable<Size> = Object.freeze(Size.Zero());\r\n\r\n// Color3\r\nconst _staticOffsetValueColor3: DeepImmutable<Color3> = Object.freeze(Color3.Black());\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    private _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @hidden */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The ratio offset of the runtime animation\r\n     */\r\n    private _ratioOffset = 0;\r\n\r\n    /**\r\n     * The previous delay of the runtime animation\r\n     */\r\n    private _previousDelay: number = 0;\r\n\r\n    /**\r\n     * The previous ratio of the runtime animation\r\n     */\r\n    private _previousRatio: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode()\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            var index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        }\r\n        else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        var events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            events.forEach((e) => {\r\n                this._events.push(e._clone());\r\n            });\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        let targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            var property = target[targetPropertyPath[0]];\r\n\r\n            for (var index = 1; index < targetPropertyPath.length - 1; index++) {\r\n                property = property[targetPropertyPath[index]];\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                var index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n            else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (var index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        let index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (var index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        let target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getRestPose && this._targetPath === \"_matrix\") { // For bones\r\n            originalValue = target.getRestPose();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                let originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) { // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            this._currentValue = currentValue;\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            destination[this._targetPath] = this._currentValue;\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        let keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        var currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, -1);\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        let newRatio = this._previousDelay * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\r\n\r\n        this._ratioOffset = this._previousRatio - newRatio;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param delay defines the delay to add to the current frame\r\n     * @param from defines the lower bound of the animation range\r\n     * @param to defines the upper bound of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @param onLoop optional callback called when animation loops\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(delay: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        let animation = this._animation;\r\n        let targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n\r\n        // Check limits\r\n        if (from < this._minFrame || from > this._maxFrame) {\r\n            from = this._minFrame;\r\n        }\r\n        if (to < this._minFrame || to > this._maxFrame) {\r\n            to = this._maxFrame;\r\n        }\r\n\r\n        const range = to - from;\r\n        let offsetValue: any;\r\n\r\n        // Compute ratio which represents the frame delta between from and to\r\n        const ratio = (delay * (animation.framePerSecond * speedRatio) / 1000.0) + this._ratioOffset;\r\n        let highLimitValue = 0;\r\n\r\n        this._previousDelay = delay;\r\n        this._previousRatio = ratio;\r\n\r\n        if (!loop && (to >= from && ratio >= range)) { // If we are out of range and not looping get back to caller\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._maxValue);\r\n        } else if (!loop && (from >= to && ratio <= range)) {\r\n            returnValue = false;\r\n            highLimitValue = animation._getKeyValue(this._minValue);\r\n        } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n            var keyOffset = to.toString() + from.toString();\r\n            if (!this._offsetsCache[keyOffset]) {\r\n                this._animationState.repeatCount = 0;\r\n                this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\r\n                var fromValue = animation._interpolate(from, this._animationState);\r\n                var toValue = animation._interpolate(to, this._animationState);\r\n\r\n                this._animationState.loopMode = this._getCorrectLoopMode();\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                this._highLimitsCache[keyOffset] = toValue;\r\n            }\r\n\r\n            highLimitValue = this._highLimitsCache[keyOffset];\r\n            offsetValue = this._offsetsCache[keyOffset];\r\n        }\r\n\r\n        if (offsetValue === undefined) {\r\n            switch (animation.dataType) {\r\n                // Float\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    offsetValue = 0;\r\n                    break;\r\n                // Quaternion\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    offsetValue = _staticOffsetValueQuaternion;\r\n                    break;\r\n                // Vector3\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                    offsetValue = _staticOffsetValueVector3;\r\n                    break;\r\n                // Vector2\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                    offsetValue = _staticOffsetValueVector2;\r\n                    break;\r\n                // Size\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    offsetValue = _staticOffsetValueSize;\r\n                    break;\r\n                // Color3\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    offsetValue = _staticOffsetValueColor3;\r\n            }\r\n        }\r\n\r\n        // Compute value\r\n        let currentFrame: number;\r\n\r\n        if (this._host && this._host.syncRoot) {\r\n            const syncRoot = this._host.syncRoot;\r\n            const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n            currentFrame = from + (to - from) * hostNormalizedFrame;\r\n        } else {\r\n            currentFrame = (returnValue && range !== 0) ? from + ratio % range : to;\r\n        }\r\n\r\n        // Reset events if looping\r\n        const events = this._events;\r\n        if (range > 0 && this.currentFrame > currentFrame ||\r\n            range < 0 && this.currentFrame < currentFrame) {\r\n            this._onLoop();\r\n\r\n            // Need to reset animation events\r\n            if (events.length) {\r\n                for (var index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._currentFrame = currentFrame;\r\n        this._animationState.repeatCount = range === 0 ? 0 : (ratio / range) >> 0;\r\n        this._animationState.highLimitValue = highLimitValue;\r\n        this._animationState.offsetValue = offsetValue;\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (var index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (range > 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (range < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    var event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already be done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}