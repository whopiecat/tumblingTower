{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { NodeMaterial } from '../../nodeMaterial';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Texture } from '../../../Textures/texture';\nimport { NodeMaterialModes } from '../../Enums/nodeMaterialModes';\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\n/**\r\n * Block used to read a texture from a sampler\r\n */\n\nvar TextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(TextureBlock, _super);\n  /**\r\n   * Create a new TextureBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function TextureBlock(name, fragmentOnly) {\n    if (fragmentOnly === void 0) {\n      fragmentOnly = false;\n    }\n\n    var _this = _super.call(this, name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment) || this;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\n\n\n    _this.convertToGammaSpace = false;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._fragmentOnly = fragmentOnly;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    _this._inputs[0]._prioritizeVertex = !fragmentOnly;\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  TextureBlock.prototype.getClassName = function () {\n    return \"TextureBlock\";\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgba\", {\n    /**\r\n     * Gets the rgba output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"rgb\", {\n    /**\r\n     * Gets the rgb output component\r\n     */\n    get: function () {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"r\", {\n    /**\r\n     * Gets the r output component\r\n     */\n    get: function () {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"g\", {\n    /**\r\n     * Gets the g output component\r\n     */\n    get: function () {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"b\", {\n    /**\r\n     * Gets the b output component\r\n     */\n    get: function () {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"a\", {\n    /**\r\n     * Gets the a output component\r\n     */\n    get: function () {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TextureBlock.prototype, \"target\", {\n    get: function () {\n      if (this._fragmentOnly) {\n        return NodeMaterialBlockTargets.Fragment;\n      } // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\n      // But we need to detect uvs coming from fragment then\n\n\n      if (!this.uv.isConnected) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      if (this.uv.sourceBlock.isInput) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n\n      var parent = this.uv.connectedPoint;\n\n      while (parent) {\n        if (parent.target === NodeMaterialBlockTargets.Fragment) {\n          return NodeMaterialBlockTargets.Fragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Vertex) {\n          return NodeMaterialBlockTargets.VertexAndFragment;\n        }\n\n        if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\n          var parentBlock = parent.ownerBlock;\n          parent = null;\n\n          for (var _i = 0, _a = parentBlock.inputs; _i < _a.length; _i++) {\n            var input = _a[_i];\n\n            if (input.connectedPoint) {\n              parent = input.connectedPoint;\n              break;\n            }\n          }\n        }\n      }\n\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      if (material.mode === NodeMaterialModes.PostProcess) {\n        var uvInput = material.getBlockByPredicate(function (b) {\n          return b.name === \"uv\";\n        });\n\n        if (uvInput) {\n          uvInput.connectTo(this);\n        }\n      } else {\n        var attributeName_1 = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\n        var uvInput = material.getInputBlockByPredicate(function (b) {\n          return b.isAttribute && b.name === attributeName_1;\n        });\n\n        if (!uvInput) {\n          uvInput = new InputBlock(\"uv\");\n          uvInput.setAsAttribute(attributeName_1);\n        }\n\n        uvInput.output.connectTo(this.uv);\n      }\n    }\n  };\n\n  TextureBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    defines.setValue(this._mainUVDefineName, false);\n  };\n\n  TextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n\n    if (!this.texture || !this.texture.getTextureMatrix) {\n      defines.setValue(this._defineName, false);\n      defines.setValue(this._mainUVDefineName, true);\n      return;\n    }\n\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace);\n\n    if (this._isMixed) {\n      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\n        defines.setValue(this._defineName, true);\n      } else {\n        defines.setValue(this._defineName, false);\n        defines.setValue(this._mainUVDefineName, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  TextureBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (!this.texture) {\n      return;\n    }\n\n    if (this._isMixed) {\n      effect.setFloat(this._textureInfoName, this.texture.level);\n      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\n    }\n\n    effect.setTexture(this._samplerName, this.texture);\n  };\n\n  Object.defineProperty(TextureBlock.prototype, \"_isMixed\", {\n    get: function () {\n      return this.target !== NodeMaterialBlockTargets.Fragment;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextureBlock.prototype._injectVertexCode = function (state) {\n    var uvInput = this.uv; // Inject code in vertex\n\n    this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\n    this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\n\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n      }\n    }\n\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\n    this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n\n    state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\n\n    state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\n\n    state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\n\n    state.compilationString += \"#ifdef \" + this._defineName + \"\\r\\n\";\n    state.compilationString += this._transformedUVName + \" = vec2(\" + this._textureTransformName + \" * vec4(\" + uvInput.associatedVariableName + \".xy, 1.0, 0.0));\\r\\n\";\n    state.compilationString += \"#elif defined(\" + this._mainUVDefineName + \")\\r\\n\";\n    state.compilationString += this._mainUVName + \" = \" + uvInput.associatedVariableName + \".xy;\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInVertexShader;\n    })) {\n      return;\n    }\n\n    this._writeTextureRead(state, true);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  };\n\n  TextureBlock.prototype._writeTextureRead = function (state, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    var uvInput = this.uv;\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + uvInput.associatedVariableName + \");\\r\\n\";\n      return;\n    }\n\n    state.compilationString += \"#ifdef \" + this._defineName + \"\\r\\n\";\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this._transformedUVName + \");\\r\\n\";\n    state.compilationString += \"#elif defined(\" + this._mainUVDefineName + \")\\r\\n\";\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this._mainUVName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  TextureBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {\n    if (vertexMode === void 0) {\n      vertexMode = false;\n    }\n\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n      return;\n    }\n\n    var complement = \" * \" + this._textureInfoName;\n    state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + complement + \";\\r\\n\";\n\n    if (swizzle !== 'a') {\n      // no conversion if the output is \"a\" (alpha)\n      state.compilationString += \"#ifdef \" + this._linearDefineName + \"\\r\\n\";\n      state.compilationString += output.associatedVariableName + \" = toGammaSpace(\" + output.associatedVariableName + \");\\r\\n\";\n      state.compilationString += \"#endif\\r\\n\";\n      state.compilationString += \"#ifdef \" + this._gammaDefineName + \"\\r\\n\";\n      state.compilationString += output.associatedVariableName + \" = toLinearSpace(\" + output.associatedVariableName + \");\\r\\n\";\n      state.compilationString += \"#endif\\r\\n\";\n    }\n  };\n\n  TextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly) {\n      this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    }\n\n    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n\n      state._emit2DSampler(this._samplerName); // Declarations\n\n\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n\n      return;\n    } // Fragment\n\n\n    if (!this._outputs.some(function (o) {\n      return o.isConnectedInFragmentShader;\n    })) {\n      return;\n    }\n\n    if (this._isMixed) {\n      // Reexport the sampler\n      state._emit2DSampler(this._samplerName);\n    }\n\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    if (this._isMixed) {\n      state._emitUniformFromString(this._textureInfoName, \"float\");\n    }\n\n    this._writeTextureRead(state);\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  TextureBlock.prototype._dumpPropertiesCode = function () {\n    if (!this.texture) {\n      return \"\";\n    }\n\n    var codeString = this._codeVariableName + \".texture = new BABYLON.Texture(\\\"\" + this.texture.name + \"\\\", null);\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wrapU = \" + this.texture.wrapU + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wrapV = \" + this.texture.wrapV + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uAng = \" + this.texture.uAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vAng = \" + this.texture.vAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.wAng = \" + this.texture.wAng + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uOffset = \" + this.texture.uOffset + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vOffset = \" + this.texture.vOffset + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.uScale = \" + this.texture.uScale + \";\\r\\n\";\n    codeString += this._codeVariableName + \".texture.vScale = \" + this.texture.vScale + \";\\r\\n\";\n    codeString += this._codeVariableName + \".convertToGammaSpace = \" + this.convertToGammaSpace + \";\\r\\n\";\n    codeString += this._codeVariableName + \".convertToLinearSpace = \" + this.convertToLinearSpace + \";\\r\\n\";\n    return codeString;\n  };\n\n  TextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.fragmentOnly = this._fragmentOnly;\n\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  TextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this._fragmentOnly = !!serializationObject.fragmentOnly;\n\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return TextureBlock;\n}(NodeMaterialBlock);\n\nexport { TextureBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.TextureBlock\"] = TextureBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Dual/textureBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { Effect } from '../../../effect';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { Nullable } from '../../../../types';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { Texture } from '../../../Textures/texture';\r\nimport { Scene } from '../../../../scene';\r\nimport { NodeMaterialModes } from '../../Enums/nodeMaterialModes';\r\n\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\n\r\n/**\r\n * Block used to read a texture from a sampler\r\n */\r\nexport class TextureBlock extends NodeMaterialBlock {\r\n    private _defineName: string;\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _transformedUVName: string;\r\n    private _textureTransformName: string;\r\n    private _textureInfoName: string;\r\n    private _mainUVName: string;\r\n    private _mainUVDefineName: string;\r\n    private _fragmentOnly: boolean;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<Texture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new TextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string, fragmentOnly = false) {\r\n        super(name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._fragmentOnly = fragmentOnly;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n\r\n        this._inputs[0]._prioritizeVertex = !fragmentOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    public get target() {\r\n        if (this._fragmentOnly) {\r\n            return NodeMaterialBlockTargets.Fragment;\r\n        }\r\n\r\n        // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\r\n        // But we need to detect uvs coming from fragment then\r\n        if (!this.uv.isConnected) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        if (this.uv.sourceBlock!.isInput) {\r\n            return NodeMaterialBlockTargets.VertexAndFragment;\r\n        }\r\n\r\n        let parent = this.uv.connectedPoint;\r\n\r\n        while (parent) {\r\n            if (parent.target === NodeMaterialBlockTargets.Fragment) {\r\n                return NodeMaterialBlockTargets.Fragment;\r\n            }\r\n\r\n            if (parent.target === NodeMaterialBlockTargets.Vertex) {\r\n                return NodeMaterialBlockTargets.VertexAndFragment;\r\n            }\r\n\r\n            if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                let parentBlock = parent.ownerBlock;\r\n\r\n                parent = null;\r\n                for (var input of parentBlock.inputs) {\r\n                    if (input.connectedPoint) {\r\n                        parent = input.connectedPoint;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return NodeMaterialBlockTargets.VertexAndFragment;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.uv.isConnected) {\r\n            if (material.mode === NodeMaterialModes.PostProcess) {\r\n                let uvInput = material.getBlockByPredicate((b) => b.name === \"uv\");\r\n\r\n                if (uvInput) {\r\n                    uvInput.connectTo(this);\r\n                }\r\n            } else {\r\n                const attributeName = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\r\n\r\n                let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === attributeName);\r\n\r\n                if (!uvInput) {\r\n                    uvInput = new InputBlock(\"uv\");\r\n                    uvInput.setAsAttribute(attributeName);\r\n                }\r\n                uvInput.output.connectTo(this.uv);\r\n            }\r\n        }\r\n    }\r\n\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._mainUVDefineName, false);\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        if (!this.texture || !this.texture.getTextureMatrix) {\r\n            defines.setValue(this._defineName, false);\r\n            defines.setValue(this._mainUVDefineName, true);\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace);\r\n        if (this._isMixed) {\r\n            if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\r\n                defines.setValue(this._defineName, true);\r\n            } else {\r\n                defines.setValue(this._defineName, false);\r\n                defines.setValue(this._mainUVDefineName, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed) {\r\n            effect.setFloat(this._textureInfoName, this.texture.level);\r\n            effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\r\n        }\r\n        effect.setTexture(this._samplerName, this.texture);\r\n    }\r\n\r\n    private get _isMixed() {\r\n        return this.target !== NodeMaterialBlockTargets.Fragment;\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        let uvInput = this.uv;\r\n\r\n        // Inject code in vertex\r\n        this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\r\n        this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\r\n\r\n        if (uvInput.connectedPoint!.ownerBlock.isInput) {\r\n            let uvInputOwnerBlock = uvInput.connectedPoint!.ownerBlock as InputBlock;\r\n\r\n            if (!uvInputOwnerBlock.isAttribute) {\r\n                state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\r\n            }\r\n        }\r\n\r\n        this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\r\n        this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\r\n        this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\r\n        state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\r\n\r\n        state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\r\n\r\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\r\n        state.compilationString += `${this._transformedUVName} = vec2(${this._textureTransformName} * vec4(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\\r\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\r\n        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n            return;\r\n        }\r\n\r\n        this._writeTextureRead(state, true);\r\n\r\n        for (var output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _writeTextureRead(state: NodeMaterialBuildState, vertexMode = false) {\r\n        let uvInput = this.uv;\r\n\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        state.compilationString += `#ifdef ${this._defineName}\\r\\n`;\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._transformedUVName});\\r\\n`;\r\n        state.compilationString += `#elif defined(${this._mainUVDefineName})\\r\\n`;\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string, vertexMode = false) {\r\n        if (vertexMode) {\r\n            if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n                return;\r\n            }\r\n\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n            return;\r\n        }\r\n\r\n        const complement = ` * ${this._textureInfoName}`;\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\r\\n`;\r\n\r\n        if (swizzle !== 'a') { // no conversion if the output is \"a\" (alpha)\r\n            state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n            state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\r\n            state.compilationString += `#endif\\r\\n`;\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n            state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\r\n            state.compilationString += `#endif\\r\\n`;\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly) {\r\n            this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n        }\r\n\r\n        if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            state._emit2DSampler(this._samplerName);\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n            return;\r\n        }\r\n\r\n        // Fragment\r\n        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {\r\n            return;\r\n        }\r\n\r\n        if (this._isMixed) {\r\n            // Reexport the sampler\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        let comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        if (this._isMixed) {\r\n            state._emitUniformFromString(this._textureInfoName, \"float\");\r\n        }\r\n\r\n        this._writeTextureRead(state);\r\n\r\n        for (var output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        if (!this.texture) {\r\n            return \"\";\r\n        }\r\n\r\n        var codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.fragmentOnly = this._fragmentOnly;\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this._fragmentOnly = !!serializationObject.fragmentOnly;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.TextureBlock\"] = TextureBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}