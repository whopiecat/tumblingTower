{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\nvar planeIdProvider = 0;\n/**\r\n * The plane detector is used to detect planes in the real world when in AR\r\n * For more information see https://github.com/immersive-web/real-world-geometry/\r\n */\n\nvar WebXRPlaneDetector =\n/** @class */\nfunction (_super) {\n  __extends(WebXRPlaneDetector, _super);\n  /**\r\n   * construct a new Plane Detector\r\n   * @param _xrSessionManager an instance of xr Session manager\r\n   * @param _options configuration to use when constructing this feature\r\n   */\n\n\n  function WebXRPlaneDetector(_xrSessionManager, _options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    var _this = _super.call(this, _xrSessionManager) || this;\n\n    _this._options = _options;\n    _this._detectedPlanes = [];\n    _this._enabled = false;\n    _this._lastFrameDetected = new Set();\n    /**\r\n     * Observers registered here will be executed when a new plane was added to the session\r\n     */\n\n    _this.onPlaneAddedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when a plane is no longer detected in the session\r\n     */\n\n    _this.onPlaneRemovedObservable = new Observable();\n    /**\r\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\r\n     * This can execute N times every frame\r\n     */\n\n    _this.onPlaneUpdatedObservable = new Observable();\n    _this.xrNativeFeatureName = \"plane-detection\";\n\n    if (_this._xrSessionManager.session) {\n      _this._init();\n    } else {\n      _this._xrSessionManager.onXRSessionInit.addOnce(function () {\n        _this._init();\n      });\n    }\n\n    return _this;\n  }\n  /**\r\n   * detach this feature.\r\n   * Will usually be called by the features manager\r\n   *\r\n   * @returns true if successful.\r\n   */\n\n\n  WebXRPlaneDetector.prototype.detach = function () {\n    if (!_super.prototype.detach.call(this)) {\n      return false;\n    }\n\n    if (!this._options.doNotRemovePlanesOnSessionEnded) {\n      while (this._detectedPlanes.length) {\n        var toRemove = this._detectedPlanes.pop();\n\n        if (toRemove) {\n          this.onPlaneRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Dispose this feature and all of the resources attached\r\n   */\n\n\n  WebXRPlaneDetector.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.onPlaneAddedObservable.clear();\n    this.onPlaneRemovedObservable.clear();\n    this.onPlaneUpdatedObservable.clear();\n  };\n  /**\r\n   * Check if the needed objects are defined.\r\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n   */\n\n\n  WebXRPlaneDetector.prototype.isCompatible = function () {\n    return typeof XRPlane !== \"undefined\";\n  };\n\n  WebXRPlaneDetector.prototype._onXRFrame = function (frame) {\n    var _this = this;\n\n    if (!this.attached || !this._enabled || !frame) {\n      return;\n    } // const timestamp = this.xrSessionManager.currentTimestamp;\n\n\n    var detectedPlanes = frame.worldInformation.detectedPlanes;\n\n    if (detectedPlanes) {\n      var toRemove = this._detectedPlanes.filter(function (plane) {\n        return !detectedPlanes.has(plane.xrPlane);\n      }).map(function (plane) {\n        return _this._detectedPlanes.indexOf(plane);\n      });\n\n      var idxTracker_1 = 0;\n      toRemove.forEach(function (index) {\n        var plane = _this._detectedPlanes.splice(index - idxTracker_1, 1)[0];\n\n        _this.onPlaneRemovedObservable.notifyObservers(plane);\n\n        idxTracker_1++;\n      }); // now check for new ones\n\n      detectedPlanes.forEach(function (xrPlane) {\n        if (!_this._lastFrameDetected.has(xrPlane)) {\n          var newPlane = {\n            id: planeIdProvider++,\n            xrPlane: xrPlane,\n            polygonDefinition: []\n          };\n\n          var plane = _this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\n\n          _this._detectedPlanes.push(plane);\n\n          _this.onPlaneAddedObservable.notifyObservers(plane);\n        } else {\n          // updated?\n          if (xrPlane.lastChangedTime === _this._xrSessionManager.currentTimestamp) {\n            var index = _this.findIndexInPlaneArray(xrPlane);\n\n            var plane = _this._detectedPlanes[index];\n\n            _this._updatePlaneWithXRPlane(xrPlane, plane, frame);\n\n            _this.onPlaneUpdatedObservable.notifyObservers(plane);\n          }\n        }\n      });\n      this._lastFrameDetected = detectedPlanes;\n    }\n  };\n\n  WebXRPlaneDetector.prototype._init = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    var internalInit = function () {\n      _this._enabled = true;\n\n      if (_this._detectedPlanes.length) {\n        _this._detectedPlanes.length = 0;\n      }\n    };\n\n    if (!this._xrSessionManager.session.updateWorldTrackingState) {\n      // check if this was enabled by a flag\n      var alreadyEnabled = (_b = (_a = this._xrSessionManager.session.worldTrackingState) === null || _a === void 0 ? void 0 : _a.planeDetectionState) === null || _b === void 0 ? void 0 : _b.enabled;\n\n      if (alreadyEnabled) {\n        internalInit();\n      } // fail silently\n\n\n      return;\n    }\n\n    this._xrSessionManager.session.updateWorldTrackingState({\n      planeDetectionState: {\n        enabled: true\n      }\n    });\n\n    internalInit();\n  };\n\n  WebXRPlaneDetector.prototype._updatePlaneWithXRPlane = function (xrPlane, plane, xrFrame) {\n    var _this = this;\n\n    plane.polygonDefinition = xrPlane.polygon.map(function (xrPoint) {\n      var rightHandedSystem = _this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\n      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\n    }); // matrix\n\n    var pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\n\n    if (pose) {\n      var mat = plane.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n\n      plane.transformationMatrix = mat;\n\n      if (this._options.worldParentNode) {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n\n    return plane;\n  };\n  /**\r\n   * avoiding using Array.find for global support.\r\n   * @param xrPlane the plane to find in the array\r\n   */\n\n\n  WebXRPlaneDetector.prototype.findIndexInPlaneArray = function (xrPlane) {\n    for (var i = 0; i < this._detectedPlanes.length; ++i) {\n      if (this._detectedPlanes[i].xrPlane === xrPlane) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * The module's name\r\n   */\n\n\n  WebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;\n  /**\r\n   * The (Babylon) version of this module.\r\n   * This is an integer representing the implementation version.\r\n   * This number does not correspond to the WebXR specs version\r\n   */\n\n  WebXRPlaneDetector.Version = 1;\n  return WebXRPlaneDetector;\n}(WebXRAbstractFeature);\n\nexport { WebXRPlaneDetector }; //register the plugin\n\nWebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, function (xrSessionManager, options) {\n  return function () {\n    return new WebXRPlaneDetector(xrSessionManager, options);\n  };\n}, WebXRPlaneDetector.Version);","map":{"version":3,"sources":["../../../../sourceES6/core/XR/features/WebXRPlaneDetector.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\ndeclare const XRPlane: XRPlane;\r\n\r\n/**\r\n * Options used in the plane detector module\r\n */\r\nexport interface IWebXRPlaneDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created planes will be kept until the next session starts\r\n     * If not defined, planes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemovePlanesOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon interface for a WebXR plane.\r\n * A Plane is actually a polygon, built from N points in space\r\n *\r\n * Supported in chrome 79, not supported in canary 81 ATM\r\n */\r\nexport interface IWebXRPlane {\r\n    /**\r\n     * a babylon-assigned ID for this polygon\r\n     */\r\n    id: number;\r\n    /**\r\n     * an array of vector3 points in babylon space. right/left hand system is taken into account.\r\n     */\r\n    polygonDefinition: Array<Vector3>;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the polygonDefinition\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * the native xr-plane object\r\n     */\r\n    xrPlane: XRPlane;\r\n}\r\n\r\nlet planeIdProvider = 0;\r\n\r\n/**\r\n * The plane detector is used to detect planes in the real world when in AR\r\n * For more information see https://github.com/immersive-web/real-world-geometry/\r\n */\r\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\r\n    private _detectedPlanes: Array<IWebXRPlane> = [];\r\n    private _enabled: boolean = false;\r\n    private _lastFrameDetected: XRPlaneSet = new Set();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PLANE_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new plane was added to the session\r\n     */\r\n    public onPlaneAddedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a plane is no longer detected in the session\r\n     */\r\n    public onPlaneRemovedObservable: Observable<IWebXRPlane> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\r\n     * This can execute N times every frame\r\n     */\r\n    public onPlaneUpdatedObservable: Observable<IWebXRPlane> = new Observable();\r\n\r\n    /**\r\n     * construct a new Plane Detector\r\n     * @param _xrSessionManager an instance of xr Session manager\r\n     * @param _options configuration to use when constructing this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRPlaneDetectorOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"plane-detection\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemovePlanesOnSessionEnded) {\r\n            while (this._detectedPlanes.length) {\r\n                const toRemove = this._detectedPlanes.pop();\r\n                if (toRemove) {\r\n                    this.onPlaneRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onPlaneAddedObservable.clear();\r\n        this.onPlaneRemovedObservable.clear();\r\n        this.onPlaneUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRPlane !== \"undefined\";\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !this._enabled || !frame) {\r\n            return;\r\n        }\r\n        // const timestamp = this.xrSessionManager.currentTimestamp;\r\n\r\n        const detectedPlanes = frame.worldInformation!.detectedPlanes;\r\n        if (detectedPlanes) {\r\n            const toRemove = this._detectedPlanes\r\n                .filter((plane) => !detectedPlanes.has(plane.xrPlane))\r\n                .map((plane) => {\r\n                    return this._detectedPlanes.indexOf(plane);\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const plane = this._detectedPlanes.splice(index - idxTracker, 1)[0];\r\n                this.onPlaneRemovedObservable.notifyObservers(plane);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            detectedPlanes.forEach((xrPlane) => {\r\n                if (!this._lastFrameDetected.has(xrPlane)) {\r\n                    const newPlane: Partial<IWebXRPlane> = {\r\n                        id: planeIdProvider++,\r\n                        xrPlane: xrPlane,\r\n                        polygonDefinition: [],\r\n                    };\r\n                    const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\r\n                    this._detectedPlanes.push(plane);\r\n                    this.onPlaneAddedObservable.notifyObservers(plane);\r\n                } else {\r\n                    // updated?\r\n                    if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                        let index = this.findIndexInPlaneArray(xrPlane);\r\n                        const plane = this._detectedPlanes[index];\r\n                        this._updatePlaneWithXRPlane(xrPlane, plane, frame);\r\n                        this.onPlaneUpdatedObservable.notifyObservers(plane);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = detectedPlanes;\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        const internalInit = () => {\r\n            this._enabled = true;\r\n            if (this._detectedPlanes.length) {\r\n                this._detectedPlanes.length = 0;\r\n            }\r\n        };\r\n        if (!this._xrSessionManager.session.updateWorldTrackingState) {\r\n            // check if this was enabled by a flag\r\n            const alreadyEnabled = (this._xrSessionManager.session as any).worldTrackingState?.planeDetectionState?.enabled;\r\n            if (alreadyEnabled) {\r\n                internalInit();\r\n            }\r\n            // fail silently\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.updateWorldTrackingState({ planeDetectionState: { enabled: true } });\r\n        internalInit();\r\n    }\r\n\r\n    private _updatePlaneWithXRPlane(xrPlane: XRPlane, plane: Partial<IWebXRPlane>, xrFrame: XRFrame): IWebXRPlane {\r\n        plane.polygonDefinition = xrPlane.polygon.map((xrPoint) => {\r\n            const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\r\n            return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\r\n        });\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = plane.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            plane.transformationMatrix = mat;\r\n            if (this._options.worldParentNode) {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n        return <IWebXRPlane>plane;\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrPlane the plane to find in the array\r\n     */\r\n    private findIndexInPlaneArray(xrPlane: XRPlane) {\r\n        for (let i = 0; i < this._detectedPlanes.length; ++i) {\r\n            if (this._detectedPlanes[i].xrPlane === xrPlane) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRPlaneDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRPlaneDetector(xrSessionManager, options);\r\n    },\r\n    WebXRPlaneDetector.Version\r\n);\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}