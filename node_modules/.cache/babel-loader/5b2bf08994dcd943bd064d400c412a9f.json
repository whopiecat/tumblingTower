{"ast":null,"code":"import { Observable } from '../Misc/observable';\n/**\r\n * The current state of the timer\r\n */\n\nexport var TimerState;\n\n(function (TimerState) {\n  /**\r\n   * Timer initialized, not yet started\r\n   */\n  TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n  /**\r\n   * Timer started and counting\r\n   */\n\n  TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n  /**\r\n   * Timer ended (whether aborted or time reached)\r\n   */\n\n  TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n */\n\n\nexport function setAndStartTimer(options) {\n  var _a;\n\n  var timer = 0;\n  var startTime = Date.now();\n  options.observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n  var observer = options.contextObservable.add(function (payload) {\n    var now = Date.now();\n    timer = now - startTime;\n    var data = {\n      startTime: startTime,\n      currentTime: now,\n      deltaTime: timer,\n      completeRate: timer / options.timeout,\n      payload: payload\n    };\n    options.onTick && options.onTick(data);\n\n    if (options.breakCondition && options.breakCondition()) {\n      options.contextObservable.remove(observer);\n      options.onAborted && options.onAborted(data);\n    }\n\n    if (timer >= options.timeout) {\n      options.contextObservable.remove(observer);\n      options.onEnded && options.onEnded(data);\n    }\n  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n  return observer;\n}\n/**\r\n * An advanced implementation of a timer class\r\n */\n\nvar AdvancedTimer =\n/** @class */\nfunction () {\n  /**\r\n   * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n   * @param options construction options for this advanced timer\r\n   */\n  function AdvancedTimer(options) {\n    var _this = this;\n\n    var _a, _b;\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\n\n\n    this.onEachCountObservable = new Observable();\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\n\n    this.onTimerAbortedObservable = new Observable();\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\n\n    this.onTimerEndedObservable = new Observable();\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\n\n    this.onStateChangedObservable = new Observable();\n    this._observer = null;\n    this._breakOnNextTick = false;\n\n    this._tick = function (payload) {\n      var now = Date.now();\n      _this._timer = now - _this._startTime;\n      var data = {\n        startTime: _this._startTime,\n        currentTime: now,\n        deltaTime: _this._timer,\n        completeRate: _this._timer / _this._timeToEnd,\n        payload: payload\n      };\n\n      var shouldBreak = _this._breakOnNextTick || _this._breakCondition(data);\n\n      if (shouldBreak || _this._timer >= _this._timeToEnd) {\n        _this._stop(data, shouldBreak);\n      } else {\n        _this.onEachCountObservable.notifyObservers(data);\n      }\n    };\n\n    this._setState(TimerState.INIT);\n\n    this._contextObservable = options.contextObservable;\n    this._observableParameters = (_a = options.observableParameters) !== null && _a !== void 0 ? _a : {};\n    this._breakCondition = (_b = options.breakCondition) !== null && _b !== void 0 ? _b : function () {\n      return false;\n    };\n\n    if (options.onEnded) {\n      this.onTimerEndedObservable.add(options.onEnded);\n    }\n\n    if (options.onTick) {\n      this.onEachCountObservable.add(options.onTick);\n    }\n\n    if (options.onAborted) {\n      this.onTimerAbortedObservable.add(options.onAborted);\n    }\n  }\n\n  Object.defineProperty(AdvancedTimer.prototype, \"breakCondition\", {\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\n    set: function (predicate) {\n      this._breakCondition = predicate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Reset ALL associated observables in this advanced timer\r\n   */\n\n  AdvancedTimer.prototype.clearObservables = function () {\n    this.onEachCountObservable.clear();\n    this.onTimerAbortedObservable.clear();\n    this.onTimerEndedObservable.clear();\n    this.onStateChangedObservable.clear();\n  };\n  /**\r\n   * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n   *\r\n   * @param timeToEnd how much time to measure until timer ended\r\n   */\n\n\n  AdvancedTimer.prototype.start = function (timeToEnd) {\n    if (timeToEnd === void 0) {\n      timeToEnd = this._timeToEnd;\n    }\n\n    if (this._state === TimerState.STARTED) {\n      throw new Error('Timer already started. Please stop it before starting again');\n    }\n\n    this._timeToEnd = timeToEnd;\n    this._startTime = Date.now();\n    this._timer = 0;\n    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n\n    this._setState(TimerState.STARTED);\n  };\n  /**\r\n   * Will force a stop on the next tick.\r\n   */\n\n\n  AdvancedTimer.prototype.stop = function () {\n    if (this._state !== TimerState.STARTED) {\n      return;\n    }\n\n    this._breakOnNextTick = true;\n  };\n  /**\r\n   * Dispose this timer, clearing all resources\r\n   */\n\n\n  AdvancedTimer.prototype.dispose = function () {\n    if (this._observer) {\n      this._contextObservable.remove(this._observer);\n    }\n\n    this.clearObservables();\n  };\n\n  AdvancedTimer.prototype._setState = function (newState) {\n    this._state = newState;\n    this.onStateChangedObservable.notifyObservers(this._state);\n  };\n\n  AdvancedTimer.prototype._stop = function (data, aborted) {\n    if (aborted === void 0) {\n      aborted = false;\n    }\n\n    this._contextObservable.remove(this._observer);\n\n    this._setState(TimerState.ENDED);\n\n    if (aborted) {\n      this.onTimerAbortedObservable.notifyObservers(data);\n    } else {\n      this.onTimerEndedObservable.notifyObservers(data);\n    }\n  };\n\n  return AdvancedTimer;\n}();\n\nexport { AdvancedTimer };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/timer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Observer } from '../Misc/observable';\r\nimport { Nullable } from '../types';\r\nimport { IDisposable } from '../scene';\r\n\r\n/**\r\n * Construction options for a timer\r\n */\r\nexport interface ITimerOptions<T> {\r\n    /**\r\n     * Time-to-end\r\n     */\r\n    timeout: number;\r\n    /**\r\n     * The context observable is used to calculate time deltas and provides the context of the timer's callbacks. Will usually be OnBeforeRenderObservable.\r\n     * Countdown calculation is done ONLY when the observable is notifying its observers, meaning that if\r\n     * you choose an observable that doesn't trigger too often, the wait time might extend further than the requested max time\r\n     */\r\n    contextObservable: Observable<T>;\r\n    /**\r\n     * Optional parameters when adding an observer to the observable\r\n     */\r\n    observableParameters?: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    /**\r\n     * An optional break condition that will stop the times prematurely. In this case onEnded will not be triggered!\r\n     */\r\n    breakCondition?: (data?: ITimerData<T>) => boolean;\r\n    /**\r\n     * Will be triggered when the time condition has met\r\n     */\r\n    onEnded?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Will be triggered when the break condition has met (prematurely ended)\r\n     */\r\n    onAborted?: (data: ITimerData<any>) => void;\r\n    /**\r\n     * Optional function to execute on each tick (or count)\r\n     */\r\n    onTick?: (data: ITimerData<any>) => void;\r\n}\r\n\r\n/**\r\n * An interface defining the data sent by the timer\r\n */\r\nexport interface ITimerData<T> {\r\n    /**\r\n     * When did it start\r\n     */\r\n    startTime: number;\r\n    /**\r\n     * Time now\r\n     */\r\n    currentTime: number;\r\n    /**\r\n     * Time passed since started\r\n     */\r\n    deltaTime: number;\r\n    /**\r\n     * How much is completed, in [0.0...1.0].\r\n     * Note that this CAN be higher than 1 due to the fact that we don't actually measure time but delta between observable calls\r\n     */\r\n    completeRate: number;\r\n    /**\r\n     * What the registered observable sent in the last count\r\n     */\r\n    payload: T;\r\n}\r\n\r\n/**\r\n * The current state of the timer\r\n */\r\nexport enum TimerState {\r\n    /**\r\n     * Timer initialized, not yet started\r\n     */\r\n    INIT,\r\n    /**\r\n     * Timer started and counting\r\n     */\r\n    STARTED,\r\n    /**\r\n     * Timer ended (whether aborted or time reached)\r\n     */\r\n    ENDED\r\n}\r\n\r\n/**\r\n * A simple version of the timer. Will take options and start the timer immediately after calling it\r\n *\r\n * @param options options with which to initialize this timer\r\n */\r\nexport function setAndStartTimer(options: ITimerOptions<any>): Nullable<Observer<any>> {\r\n    let timer = 0;\r\n    const startTime = Date.now();\r\n    options.observableParameters = options.observableParameters ?? {};\r\n    const observer = options.contextObservable.add((payload: any) => {\r\n        const now = Date.now();\r\n        timer = now - startTime;\r\n        const data: ITimerData<any> = {\r\n            startTime,\r\n            currentTime: now,\r\n            deltaTime: timer,\r\n            completeRate: timer / options.timeout,\r\n            payload\r\n        };\r\n        options.onTick && options.onTick(data);\r\n        if (options.breakCondition && options.breakCondition()) {\r\n            options.contextObservable.remove(observer);\r\n            options.onAborted && options.onAborted(data);\r\n        }\r\n        if (timer >= options.timeout) {\r\n            options.contextObservable.remove(observer);\r\n            options.onEnded && options.onEnded(data);\r\n        }\r\n    }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\r\n    return observer;\r\n}\r\n\r\n/**\r\n * An advanced implementation of a timer class\r\n */\r\nexport class AdvancedTimer<T = any> implements IDisposable {\r\n\r\n    /**\r\n     * Will notify each time the timer calculates the remaining time\r\n     */\r\n    public onEachCountObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer was aborted due to the break condition\r\n     */\r\n    public onTimerAbortedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer ended successfully\r\n     */\r\n    public onTimerEndedObservable: Observable<ITimerData<T>> = new Observable();\r\n    /**\r\n     * Will trigger when the timer state has changed\r\n     */\r\n    public onStateChangedObservable: Observable<TimerState> = new Observable();\r\n\r\n    private _observer: Nullable<Observer<T>> = null;\r\n    private _contextObservable: Observable<T>;\r\n    private _observableParameters: {\r\n        mask?: number;\r\n        insertFirst?: boolean;\r\n        scope?: any;\r\n    };\r\n    private _startTime: number;\r\n    private _timer: number;\r\n    private _state: TimerState;\r\n    private _breakCondition: (data: ITimerData<T>) => boolean;\r\n    private _timeToEnd: number;\r\n    private _breakOnNextTick: boolean = false;\r\n\r\n    /**\r\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\r\n     * @param options construction options for this advanced timer\r\n     */\r\n    constructor(options: ITimerOptions<T>) {\r\n        this._setState(TimerState.INIT);\r\n        this._contextObservable = options.contextObservable;\r\n        this._observableParameters = options.observableParameters ?? {};\r\n        this._breakCondition = options.breakCondition ?? (() => false);\r\n        if (options.onEnded) {\r\n            this.onTimerEndedObservable.add(options.onEnded);\r\n        }\r\n        if (options.onTick) {\r\n            this.onEachCountObservable.add(options.onTick);\r\n        }\r\n        if (options.onAborted) {\r\n            this.onTimerAbortedObservable.add(options.onAborted);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set a breaking condition for this timer. Default is to never break during count\r\n     * @param predicate the new break condition. Returns true to break, false otherwise\r\n     */\r\n    public set breakCondition(predicate: (data: ITimerData<T>) => boolean) {\r\n        this._breakCondition = predicate;\r\n    }\r\n\r\n    /**\r\n     * Reset ALL associated observables in this advanced timer\r\n     */\r\n    public clearObservables() {\r\n        this.onEachCountObservable.clear();\r\n        this.onTimerAbortedObservable.clear();\r\n        this.onTimerEndedObservable.clear();\r\n        this.onStateChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\r\n     *\r\n     * @param timeToEnd how much time to measure until timer ended\r\n     */\r\n    public start(timeToEnd: number = this._timeToEnd) {\r\n        if (this._state === TimerState.STARTED) {\r\n            throw new Error('Timer already started. Please stop it before starting again');\r\n        }\r\n        this._timeToEnd = timeToEnd;\r\n        this._startTime = Date.now();\r\n        this._timer = 0;\r\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\r\n        this._setState(TimerState.STARTED);\r\n    }\r\n\r\n    /**\r\n     * Will force a stop on the next tick.\r\n     */\r\n    public stop() {\r\n        if (this._state !== TimerState.STARTED) {\r\n            return;\r\n        }\r\n        this._breakOnNextTick = true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this timer, clearing all resources\r\n     */\r\n    public dispose() {\r\n        if (this._observer) {\r\n            this._contextObservable.remove(this._observer);\r\n        }\r\n        this.clearObservables();\r\n    }\r\n\r\n    private _setState(newState: TimerState) {\r\n        this._state = newState;\r\n        this.onStateChangedObservable.notifyObservers(this._state);\r\n    }\r\n\r\n    private _tick = (payload: T) => {\r\n        const now = Date.now();\r\n        this._timer = now - this._startTime;\r\n        const data: ITimerData<T> = {\r\n            startTime: this._startTime,\r\n            currentTime: now,\r\n            deltaTime: this._timer,\r\n            completeRate: this._timer / this._timeToEnd,\r\n            payload\r\n        };\r\n        const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\r\n        if (shouldBreak || this._timer >= this._timeToEnd) {\r\n            this._stop(data, shouldBreak);\r\n        } else {\r\n            this.onEachCountObservable.notifyObservers(data);\r\n        }\r\n    }\r\n\r\n    private _stop(data: ITimerData<T>, aborted: boolean = false) {\r\n        this._contextObservable.remove(this._observer);\r\n        this._setState(TimerState.ENDED);\r\n        if (aborted) {\r\n            this.onTimerAbortedObservable.notifyObservers(data);\r\n        } else {\r\n            this.onTimerEndedObservable.notifyObservers(data);\r\n        }\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}