{"ast":null,"code":"import { Logger } from \"../../Misc/logger\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\nimport { VertexBuffer } from \"../../Meshes/buffer\";\nimport { PhysicsImpostor } from \"../../Physics/physicsImpostor\";\nimport { PhysicsJoint } from \"../../Physics/physicsJoint\";\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\n/** @hidden */\n\nvar CannonJSPlugin =\n/** @class */\nfunction () {\n  function CannonJSPlugin(_useDeltaForWorldStep, iterations, cannonInjection) {\n    if (_useDeltaForWorldStep === void 0) {\n      _useDeltaForWorldStep = true;\n    }\n\n    if (iterations === void 0) {\n      iterations = 10;\n    }\n\n    if (cannonInjection === void 0) {\n      cannonInjection = CANNON;\n    }\n\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodysToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n\n    this._extendNamespace();\n\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n\n  CannonJSPlugin.prototype.setGravity = function (gravity) {\n    var vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  };\n\n  CannonJSPlugin.prototype.setTimeStep = function (timeStep) {\n    this._fixedTimeStep = timeStep;\n  };\n\n  CannonJSPlugin.prototype.getTimeStep = function () {\n    return this._fixedTimeStep;\n  };\n\n  CannonJSPlugin.prototype.executeStep = function (delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n\n      for (var _i = 0, impostors_1 = impostors; _i < impostors_1.length; _i++) {\n        var impostor = impostors_1[_i];\n\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n\n    this._removeMarkedPhysicsBodiesFromWorld();\n  };\n\n  CannonJSPlugin.prototype._removeMarkedPhysicsBodiesFromWorld = function () {\n    var _this = this;\n\n    if (this._physicsBodysToRemoveAfterStep.length > 0) {\n      this._physicsBodysToRemoveAfterStep.forEach(function (physicsBody) {\n        _this.world.remove(physicsBody);\n      });\n\n      this._physicsBodysToRemoveAfterStep = [];\n    }\n  };\n\n  CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n    var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  };\n\n  CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld(); //parent-child relationship. Does this impostor has a parent impostor?\n\n\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor); //TODO is that needed?\n\n        impostor.forceUpdate();\n      }\n\n      return;\n    } //should a new body be created for this impostor?\n\n\n    if (impostor.isBodyInitRequired()) {\n      var shape = this._createShape(impostor); //unregister events, if body is being changed\n\n\n      var oldBody = impostor.physicsBody;\n\n      if (oldBody) {\n        this.removePhysicsBody(impostor);\n      } //create the body and material\n\n\n      var material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n\n      var bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      }; // A simple extend, in case native options were used.\n\n      var nativeOptions = impostor.getParam(\"nativeOptions\");\n\n      for (var key in nativeOptions) {\n        if (nativeOptions.hasOwnProperty(key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n      this.world.add(impostor.physicsBody); //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n\n      if (oldBody) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          var vec = oldBody[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n\n      this._processChildMeshes(impostor);\n    } //now update the body's transformation\n\n\n    this._updatePhysicsBodyTransformation(impostor);\n  };\n\n  CannonJSPlugin.prototype._processChildMeshes = function (mainImpostor) {\n    var _this = this;\n\n    var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    var currentRotation = mainImpostor.object.rotationQuaternion;\n\n    if (meshChildren.length) {\n      var processMesh_1 = function (mesh) {\n        if (!currentRotation || !mesh.rotationQuaternion) {\n          return;\n        }\n\n        var childImpostor = mesh.getPhysicsImpostor();\n\n        if (childImpostor) {\n          var parent = childImpostor.parent;\n\n          if (parent !== mainImpostor) {\n            var pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            var q = mesh.rotationQuaternion;\n\n            if (childImpostor.physicsBody) {\n              _this.removePhysicsBody(childImpostor);\n\n              childImpostor.physicsBody = null;\n            }\n\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new _this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new _this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)); //Add the mass of the children.\n\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n\n        currentRotation.multiplyInPlace(mesh.rotationQuaternion);\n        mesh.getChildMeshes(true).filter(function (m) {\n          return !!m.physicsImpostor;\n        }).forEach(processMesh_1);\n      };\n\n      meshChildren.filter(function (m) {\n        return !!m.physicsImpostor;\n      }).forEach(processMesh_1);\n    }\n  };\n\n  CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep); // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n\n    if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  };\n\n  CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {\n    var mainBody = impostorJoint.mainImpostor.physicsBody;\n    var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n\n    var constraint;\n    var jointData = impostorJoint.joint.jointData; //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n\n    var constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n\n      case PhysicsJoint.SpringJoint:\n        var springData = jointData;\n        constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n          restLength: springData.length,\n          stiffness: springData.stiffness,\n          damping: springData.damping,\n          localAnchorA: constraintData.pivotA,\n          localAnchorB: constraintData.pivotB\n        });\n        break;\n\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    } //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n\n\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint; //don't add spring as constraint, as it is not one.\n\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  };\n\n  CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {\n    var index;\n    var mat;\n\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n\n    var currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n\n    this._physicsMaterials.push(currentMat);\n\n    return currentMat;\n  };\n\n  CannonJSPlugin.prototype._checkWithEpsilon = function (value) {\n    return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;\n  };\n\n  CannonJSPlugin.prototype._createShape = function (impostor) {\n    var object = impostor.object;\n    var returnValue;\n    var extendSize = impostor.getObjectExtendSize();\n\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        var radiusX = extendSize.x;\n        var radiusY = extendSize.y;\n        var radiusZ = extendSize.z;\n        returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n        break;\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n\n      case PhysicsImpostor.CylinderImpostor:\n        var nativeParams = impostor.getParam(\"nativeOptions\");\n\n        if (!nativeParams) {\n          nativeParams = {};\n        }\n\n        var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;\n        var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;\n        var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);\n        var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n        returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments); // Rotate 90 degrees as this shape is horizontal in cannon\n\n        var quat = new this.BJSCANNON.Quaternion();\n        quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n        var translation = new this.BJSCANNON.Vec3(0, 0, 0);\n        returnValue.transformAllPoints(translation, quat);\n        break;\n\n      case PhysicsImpostor.BoxImpostor:\n        var box = extendSize.scale(0.5);\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n        break;\n\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n\n      case PhysicsImpostor.MeshImpostor:\n        // should transform the vertex data to world coordinates!!\n        var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n        var rawFaces = object.getIndices ? object.getIndices() : [];\n\n        if (!rawVerts) {\n          return;\n        } // get only scale! so the object could transform correctly.\n\n\n        var oldPosition = object.position.clone();\n        var oldRotation = object.rotation && object.rotation.clone();\n        var oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n        object.position.copyFromFloats(0, 0, 0);\n        object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n        var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n        var temp = new Array();\n        var index;\n\n        for (index = 0; index < rawVerts.length; index += 3) {\n          Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);\n        }\n\n        Logger.Warn(\"MeshImpostor only collides against spheres.\");\n        returnValue = new this.BJSCANNON.Trimesh(temp, rawFaces); //now set back the transformation!\n\n        object.position.copyFrom(oldPosition);\n        oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n        oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n        break;\n\n      case PhysicsImpostor.HeightmapImpostor:\n        var oldPosition2 = object.position.clone();\n        var oldRotation2 = object.rotation && object.rotation.clone();\n        var oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n        object.position.copyFromFloats(0, 0, 0);\n        object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n        object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n        object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n        object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n        returnValue = this._createHeightmap(object);\n        object.position.copyFrom(oldPosition2);\n        oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n        oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n        object.computeWorldMatrix(true);\n        break;\n\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n\n    return returnValue;\n  };\n\n  CannonJSPlugin.prototype._createHeightmap = function (object, pointDepth) {\n    var pos = object.getVerticesData(VertexBuffer.PositionKind);\n    var transform = object.computeWorldMatrix(true); // convert rawVerts to object space\n\n    var temp = new Array();\n    var index;\n\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);\n    }\n\n    pos = temp;\n    var matrix = new Array(); //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n\n    var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    var boundingInfo = object.getBoundingInfo();\n    var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    var minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    var elementSize = dim * 2 / arraySize;\n\n    for (var i = 0; i < pos.length; i = i + 3) {\n      var x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      var z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      var y = -pos[i + 2] + minY;\n\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n\n    for (var x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        var loc = 1;\n\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n\n        matrix[x] = matrix[(x + loc) % arraySize].slice(); //console.log(\"missing x\", x);\n      }\n\n      for (var z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          var loc = 1;\n          var newValue;\n\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n\n    var shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    }); //For future reference, needed for body transformation\n\n    shape.minY = minY;\n    return shape;\n  };\n\n  CannonJSPlugin.prototype._updatePhysicsBodyTransformation = function (impostor) {\n    var object = impostor.object; //make sure it is updated...\n\n    object.computeWorldMatrix && object.computeWorldMatrix(true); // The delta between the mesh position and the mesh bounding box center\n\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n\n    var center = impostor.getObjectCenter(); //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n\n    this._tmpPosition.copyFrom(center);\n\n    var quaternion = object.rotationQuaternion;\n\n    if (!quaternion) {\n      return;\n    } //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n\n\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X); //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n\n      impostor.setDeltaRotation(this._plus90X);\n    } //If it is a heightfield, if should be centered.\n\n\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      var mesh = object;\n      var boundingInfo = mesh.getBoundingInfo(); //calculate the correct body position:\n\n      var rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true); //get original center with no rotation\n\n      var c = center.clone();\n      var oldPivot = mesh.getPivotMatrix();\n\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      } //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n\n\n      var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true); //calculate the translation\n\n      var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z); //add it inverted to the delta\n\n\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y; //rotation is back\n\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n\n    impostor.setDeltaPosition(this._tmpDeltaPosition); //Now update the impostor object\n\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  };\n\n  CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n\n    if (impostor.object.rotationQuaternion) {\n      var q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  };\n\n  CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  };\n\n  CannonJSPlugin.prototype.isSupported = function () {\n    return this.BJSCANNON !== undefined;\n  };\n\n  CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  };\n\n  CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {\n    var v = impostor.physicsBody.velocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {\n    var v = impostor.physicsBody.angularVelocity;\n\n    if (!v) {\n      return null;\n    }\n\n    return new Vector3(v.x, v.y, v.z);\n  };\n\n  CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  };\n\n  CannonJSPlugin.prototype.getBodyMass = function (impostor) {\n    return impostor.physicsBody.mass;\n  };\n\n  CannonJSPlugin.prototype.getBodyFriction = function (impostor) {\n    return impostor.physicsBody.material.friction;\n  };\n\n  CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  };\n\n  CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {\n    return impostor.physicsBody.material.restitution;\n  };\n\n  CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  };\n\n  CannonJSPlugin.prototype.sleepBody = function (impostor) {\n    impostor.physicsBody.sleep();\n  };\n\n  CannonJSPlugin.prototype.wakeUpBody = function (impostor) {\n    impostor.physicsBody.wakeUp();\n  };\n\n  CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  };\n\n  CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  };\n\n  CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {\n    joint.physicsJoint.motorEquation.maxForce = upperLimit;\n    joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\n  };\n\n  CannonJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n    var body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  };\n\n  CannonJSPlugin.prototype.getRadius = function (impostor) {\n    var shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  };\n\n  CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n    var shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  };\n\n  CannonJSPlugin.prototype.dispose = function () {};\n\n  CannonJSPlugin.prototype._extendNamespace = function () {\n    //this will force cannon to execute at least one step when using interpolation\n    var step_tmp1 = new this.BJSCANNON.Vec3();\n    var Engine = this.BJSCANNON;\n\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        var t0 = performance.now();\n\n        for (var i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n\n        this.time += timeSinceLastCalled;\n        var h = this.time % dt;\n        var h_div_dt = h / dt;\n        var interpvelo = step_tmp1;\n        var bodies = this.bodies;\n\n        for (var j = 0; j !== bodies.length; j++) {\n          var b = bodies[j];\n\n          if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  };\n  /**\r\n   * Does a raycast in the physics world\r\n   * @param from when should the ray start?\r\n   * @param to when should the ray end?\r\n   * @returns PhysicsRaycastResult\r\n   */\n\n\n  CannonJSPlugin.prototype.raycast = function (from, to) {\n    this._cannonRaycastResult.reset();\n\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n\n    this._raycastResult.reset(from, to);\n\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      this._raycastResult.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n\n      this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);\n    }\n\n    return this._raycastResult;\n  };\n\n  return CannonJSPlugin;\n}();\n\nexport { CannonJSPlugin };\n\nPhysicsEngine.DefaultPluginFactory = function () {\n  return new CannonJSPlugin();\n};","map":{"version":3,"sources":["../../../../sourceES6/core/Physics/Plugins/cannonJSPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../../Physics/IPhysicsEngine\";\r\nimport { PhysicsImpostor, IPhysicsEnabledObject } from \"../../Physics/physicsImpostor\";\r\nimport { PhysicsJoint, IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../../Physics/physicsJoint\";\r\nimport { PhysicsEngine } from \"../../Physics/physicsEngine\";\r\nimport { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { TransformNode } from '../../Meshes/transformNode';\r\n\r\n//declare var require: any;\r\ndeclare var CANNON: any;\r\n\r\n/** @hidden */\r\nexport class CannonJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"CannonJSPlugin\";\r\n    private _physicsMaterials = new Array();\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _cannonRaycastResult: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _physicsBodysToRemoveAfterStep = new Array<any>();\r\n    private _firstFrame = true;\r\n    //See https://github.com/schteppe/CANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n    public BJSCANNON: any;\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, iterations: number = 10, cannonInjection = CANNON) {\r\n        this.BJSCANNON = cannonInjection;\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        this._extendNamespace();\r\n\r\n        this.world = new this.BJSCANNON.World();\r\n        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\r\n        this.world.solver.iterations = iterations;\r\n        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    public setGravity(gravity: Vector3): void {\r\n        const vec = gravity;\r\n        this.world.gravity.set(vec.x, vec.y, vec.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        // due to cannon's architecture, the first frame's before-step is skipped.\r\n        if (this._firstFrame) {\r\n            this._firstFrame = false;\r\n            for (const impostor of impostors) {\r\n                if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\r\n                    impostor.beforeStep();\r\n                }\r\n            }\r\n        }\r\n        this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n    }\r\n\r\n    private _removeMarkedPhysicsBodiesFromWorld(): void {\r\n        if (this._physicsBodysToRemoveAfterStep.length > 0) {\r\n            this._physicsBodysToRemoveAfterStep.forEach((physicsBody) => {\r\n                this.world.remove(physicsBody);\r\n            });\r\n            this._physicsBodysToRemoveAfterStep = [];\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n    }\r\n\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        var worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        var impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyForce(impulse, worldPoint);\r\n    }\r\n\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        //should a new body be created for this impostor?\r\n        if (impostor.isBodyInitRequired()) {\r\n            var shape = this._createShape(impostor);\r\n\r\n            //unregister events, if body is being changed\r\n            var oldBody = impostor.physicsBody;\r\n            if (oldBody) {\r\n                this.removePhysicsBody(impostor);\r\n            }\r\n\r\n            //create the body and material\r\n            var material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\r\n\r\n            var bodyCreationObject = {\r\n                mass: impostor.getParam(\"mass\"),\r\n                material: material,\r\n            };\r\n            // A simple extend, in case native options were used.\r\n            var nativeOptions = impostor.getParam(\"nativeOptions\");\r\n            for (var key in nativeOptions) {\r\n                if (nativeOptions.hasOwnProperty(key)) {\r\n                    (<any>bodyCreationObject)[key] = nativeOptions[key];\r\n                }\r\n            }\r\n            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\r\n            impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\r\n            this.world.addEventListener(\"preStep\", impostor.beforeStep);\r\n            this.world.addEventListener(\"postStep\", impostor.afterStep);\r\n            impostor.physicsBody.addShape(shape);\r\n            this.world.add(impostor.physicsBody);\r\n\r\n            //try to keep the body moving in the right direction by taking old properties.\r\n            //Should be tested!\r\n            if (oldBody) {\r\n                [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\r\n                    const vec = oldBody[param];\r\n                    impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\r\n                });\r\n            }\r\n            this._processChildMeshes(impostor);\r\n        }\r\n\r\n        //now update the body's transformation\r\n        this._updatePhysicsBodyTransformation(impostor);\r\n    }\r\n\r\n    private _processChildMeshes(mainImpostor: PhysicsImpostor) {\r\n        var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\r\n        let currentRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;\r\n        if (meshChildren.length) {\r\n            const processMesh = (mesh: AbstractMesh) => {\r\n                if (!currentRotation || !mesh.rotationQuaternion) {\r\n                    return;\r\n                }\r\n\r\n                var childImpostor = mesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    var parent = childImpostor.parent;\r\n                    if (parent !== mainImpostor) {\r\n                        const pPosition = mesh.getAbsolutePosition().subtract((mesh.parent as TransformNode).getAbsolutePosition());\r\n                        const q = mesh.rotationQuaternion;\r\n                        if (childImpostor.physicsBody) {\r\n                            this.removePhysicsBody(childImpostor);\r\n                            childImpostor.physicsBody = null;\r\n                        }\r\n                        childImpostor.parent = mainImpostor;\r\n                        childImpostor.resetUpdateFlags();\r\n                        mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z) , new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));\r\n                        //Add the mass of the children.\r\n                        mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\r\n                    }\r\n                }\r\n                currentRotation.multiplyInPlace(mesh.rotationQuaternion);\r\n                mesh.getChildMeshes(true)\r\n                    .filter((m) => !!m.physicsImpostor)\r\n                    .forEach(processMesh);\r\n            };\r\n            meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);\r\n        }\r\n    }\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\r\n        this.world.removeEventListener(\"preStep\", impostor.beforeStep);\r\n        this.world.removeEventListener(\"postStep\", impostor.afterStep);\r\n\r\n        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\r\n        if (this._physicsBodysToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\r\n            this._physicsBodysToRemoveAfterStep.push(impostor.physicsBody);\r\n        }\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        var mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        var connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        var constraint: any;\r\n        var jointData = impostorJoint.joint.jointData;\r\n        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n        var constraintData = {\r\n            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\r\n            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\r\n            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\r\n            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\r\n            maxForce: jointData.nativeParams.maxForce,\r\n            collideConnected: !!jointData.collision,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.HingeJoint:\r\n            case PhysicsJoint.Hinge2Joint:\r\n                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.DistanceJoint:\r\n                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, (<DistanceJointData>jointData).maxDistance || 2);\r\n                break;\r\n            case PhysicsJoint.SpringJoint:\r\n                var springData = <SpringJointData>jointData;\r\n                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\r\n                    restLength: springData.length,\r\n                    stiffness: springData.stiffness,\r\n                    damping: springData.damping,\r\n                    localAnchorA: constraintData.pivotA,\r\n                    localAnchorB: constraintData.pivotB,\r\n                });\r\n                break;\r\n            case PhysicsJoint.LockJoint:\r\n                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.PointToPointJoint:\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n            default:\r\n                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\r\n                break;\r\n        }\r\n        //set the collideConnected flag after the creation, since DistanceJoint ignores it.\r\n        constraint.collideConnected = !!jointData.collision;\r\n        impostorJoint.joint.physicsJoint = constraint;\r\n        //don't add spring as constraint, as it is not one.\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.addConstraint(constraint);\r\n        } else {\r\n            (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback =\r\n                (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback ||\r\n                function () {\r\n                    constraint.applyForce();\r\n                };\r\n            impostorJoint.mainImpostor.registerAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        } else {\r\n            impostorJoint.mainImpostor.unregisterAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    private _addMaterial(name: string, friction: number, restitution: number) {\r\n        var index;\r\n        var mat;\r\n\r\n        for (index = 0; index < this._physicsMaterials.length; index++) {\r\n            mat = this._physicsMaterials[index];\r\n\r\n            if (mat.friction === friction && mat.restitution === restitution) {\r\n                return mat;\r\n            }\r\n        }\r\n\r\n        var currentMat = new this.BJSCANNON.Material(name);\r\n        currentMat.friction = friction;\r\n        currentMat.restitution = restitution;\r\n\r\n        this._physicsMaterials.push(currentMat);\r\n        return currentMat;\r\n    }\r\n\r\n    private _checkWithEpsilon(value: number): number {\r\n        return value < PhysicsEngine.Epsilon ? PhysicsEngine.Epsilon : value;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n\r\n        var returnValue;\r\n        var extendSize = impostor.getObjectExtendSize();\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor:\r\n                var radiusX = extendSize.x;\r\n                var radiusY = extendSize.y;\r\n                var radiusZ = extendSize.z;\r\n\r\n                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\r\n\r\n                break;\r\n            //TMP also for cylinder - TODO Cannon supports cylinder natively.\r\n            case PhysicsImpostor.CylinderImpostor:\r\n                let nativeParams = impostor.getParam(\"nativeOptions\");\r\n                if (!nativeParams) {\r\n                    nativeParams = {};\r\n                }\r\n                let radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;\r\n                let radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;\r\n                let height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);\r\n                let numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\r\n                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\r\n\r\n                // Rotate 90 degrees as this shape is horizontal in cannon\r\n                var quat = new this.BJSCANNON.Quaternion();\r\n                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n                var translation = new this.BJSCANNON.Vec3(0, 0, 0);\r\n                returnValue.transformAllPoints(translation, quat);\r\n                break;\r\n            case PhysicsImpostor.BoxImpostor:\r\n                var box = extendSize.scale(0.5);\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\r\n                break;\r\n            case PhysicsImpostor.PlaneImpostor:\r\n                Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\r\n                returnValue = new this.BJSCANNON.Plane();\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor:\r\n                // should transform the vertex data to world coordinates!!\r\n                var rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\r\n                var rawFaces = object.getIndices ? object.getIndices() : [];\r\n                if (!rawVerts) {\r\n                    return;\r\n                }\r\n                // get only scale! so the object could transform correctly.\r\n                let oldPosition = object.position.clone();\r\n                let oldRotation = object.rotation && object.rotation.clone();\r\n                let oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n\r\n                let transform = object.computeWorldMatrix(true);\r\n                // convert rawVerts to object space\r\n                var temp = new Array<number>();\r\n                var index: number;\r\n                for (index = 0; index < rawVerts.length; index += 3) {\r\n                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(temp, index);\r\n                }\r\n\r\n                Logger.Warn(\"MeshImpostor only collides against spheres.\");\r\n                returnValue = new this.BJSCANNON.Trimesh(temp, <number[]>rawFaces);\r\n                //now set back the transformation!\r\n                object.position.copyFrom(oldPosition);\r\n                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\r\n                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\r\n                break;\r\n            case PhysicsImpostor.HeightmapImpostor:\r\n                let oldPosition2 = object.position.clone();\r\n                let oldRotation2 = object.rotation && object.rotation.clone();\r\n                let oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\r\n\r\n                returnValue = this._createHeightmap(object);\r\n                object.position.copyFrom(oldPosition2);\r\n                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\r\n                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\r\n                object.computeWorldMatrix(true);\r\n                break;\r\n            case PhysicsImpostor.ParticleImpostor:\r\n                returnValue = new this.BJSCANNON.Particle();\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {\r\n        var pos = <FloatArray>object.getVerticesData(VertexBuffer.PositionKind);\r\n        let transform = object.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        var temp = new Array<number>();\r\n        var index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);\r\n        }\r\n        pos = temp;\r\n        var matrix = new Array<Array<any>>();\r\n\r\n        //For now pointDepth will not be used and will be automatically calculated.\r\n        //Future reference - try and find the best place to add a reference to the pointDepth variable.\r\n        var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\r\n        let boundingInfo = object.getBoundingInfo();\r\n        var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\r\n        var minY = boundingInfo.boundingBox.extendSizeWorld.z;\r\n\r\n        var elementSize = (dim * 2) / arraySize;\r\n\r\n        for (var i = 0; i < pos.length; i = i + 3) {\r\n            var x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\r\n            var z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\r\n            var y = -pos[i + 2] + minY;\r\n            if (!matrix[x]) {\r\n                matrix[x] = [];\r\n            }\r\n            if (!matrix[x][z]) {\r\n                matrix[x][z] = y;\r\n            }\r\n            matrix[x][z] = Math.max(y, matrix[x][z]);\r\n        }\r\n\r\n        for (var x = 0; x <= arraySize; ++x) {\r\n            if (!matrix[x]) {\r\n                var loc = 1;\r\n                while (!matrix[(x + loc) % arraySize]) {\r\n                    loc++;\r\n                }\r\n                matrix[x] = matrix[(x + loc) % arraySize].slice();\r\n                //console.log(\"missing x\", x);\r\n            }\r\n            for (var z = 0; z <= arraySize; ++z) {\r\n                if (!matrix[x][z]) {\r\n                    var loc = 1;\r\n                    var newValue;\r\n                    while (newValue === undefined) {\r\n                        newValue = matrix[x][(z + loc++) % arraySize];\r\n                    }\r\n                    matrix[x][z] = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        var shape = new this.BJSCANNON.Heightfield(matrix, {\r\n            elementSize: elementSize,\r\n        });\r\n\r\n        //For future reference, needed for body transformation\r\n        shape.minY = minY;\r\n\r\n        return shape;\r\n    }\r\n\r\n    private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _tmpPosition: Vector3 = Vector3.Zero();\r\n    private _tmpDeltaPosition: Vector3 = Vector3.Zero();\r\n    private _tmpUnityRotation: Quaternion = new Quaternion();\r\n\r\n    private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {\r\n        var object = impostor.object;\r\n        //make sure it is updated...\r\n        object.computeWorldMatrix && object.computeWorldMatrix(true);\r\n        // The delta between the mesh position and the mesh bounding box center\r\n        if (!object.getBoundingInfo()) {\r\n            return;\r\n        }\r\n        var center = impostor.getObjectCenter();\r\n        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\r\n        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\r\n        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\r\n        this._tmpPosition.copyFrom(center);\r\n        var quaternion = object.rotationQuaternion;\r\n\r\n        if (!quaternion) {\r\n            return;\r\n        }\r\n\r\n        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\r\n        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\r\n        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            //-90 DEG in X, precalculated\r\n            quaternion = quaternion.multiply(this._minus90X);\r\n            //Invert! (Precalculated, 90 deg in X)\r\n            //No need to clone. this will never change.\r\n            impostor.setDeltaRotation(this._plus90X);\r\n        }\r\n\r\n        //If it is a heightfield, if should be centered.\r\n        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            var mesh = <AbstractMesh>(<any>object);\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n            //calculate the correct body position:\r\n            var rotationQuaternion = mesh.rotationQuaternion;\r\n            mesh.rotationQuaternion = this._tmpUnityRotation;\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //get original center with no rotation\r\n            var c = center.clone();\r\n\r\n            var oldPivot = mesh.getPivotMatrix();\r\n            if (oldPivot) {\r\n                // create a copy the pivot Matrix as it is modified in place\r\n                oldPivot = oldPivot.clone();\r\n            } else {\r\n                oldPivot = Matrix.Identity();\r\n            }\r\n\r\n            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\r\n            const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\r\n            mesh.setPreTransformMatrix(p);\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //calculate the translation\r\n            var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\r\n\r\n            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\r\n            //add it inverted to the delta\r\n            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\r\n            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\r\n            //rotation is back\r\n            mesh.rotationQuaternion = rotationQuaternion;\r\n\r\n            mesh.setPreTransformMatrix(oldPivot);\r\n            mesh.computeWorldMatrix(true);\r\n        } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpDeltaPosition);\r\n        //Now update the impostor object\r\n        impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\r\n        impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\r\n        if (impostor.object.rotationQuaternion) {\r\n            const q = impostor.physicsBody.quaternion;\r\n            impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSCANNON !== undefined;\r\n    }\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        var v = impostor.physicsBody.velocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        var v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        impostor.physicsBody.mass = mass;\r\n        impostor.physicsBody.updateMassProperties();\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.mass;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.material.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.material.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.wakeUp();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number) {\r\n        joint.physicsJoint.distance = maxDistance;\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        if (!motorIndex) {\r\n            joint.physicsJoint.enableMotor();\r\n            joint.physicsJoint.setMotorSpeed(speed);\r\n            if (maxForce) {\r\n                this.setLimit(joint, maxForce);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number) {\r\n        joint.physicsJoint.motorEquation.maxForce = upperLimit;\r\n        joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        var body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.quaternion.x;\r\n            mesh.rotationQuaternion.y = body.quaternion.y;\r\n            mesh.rotationQuaternion.z = body.quaternion.z;\r\n            mesh.rotationQuaternion.w = body.quaternion.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        var shape = impostor.physicsBody.shapes[0];\r\n        return shape.boundingSphereRadius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        var shape = impostor.physicsBody.shapes[0];\r\n        result.x = shape.halfExtents.x * 2;\r\n        result.y = shape.halfExtents.y * 2;\r\n        result.z = shape.halfExtents.z * 2;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    private _extendNamespace() {\r\n        //this will force cannon to execute at least one step when using interpolation\r\n        let step_tmp1 = new this.BJSCANNON.Vec3();\r\n        let Engine = this.BJSCANNON;\r\n        this.BJSCANNON.World.prototype.step = function (dt: number, timeSinceLastCalled: number, maxSubSteps: number) {\r\n            maxSubSteps = maxSubSteps || 10;\r\n            timeSinceLastCalled = timeSinceLastCalled || 0;\r\n            if (timeSinceLastCalled === 0) {\r\n                this.internalStep(dt);\r\n                this.time += dt;\r\n            } else {\r\n                var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\r\n                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\r\n                var t0 = performance.now();\r\n                for (var i = 0; i !== internalSteps; i++) {\r\n                    this.internalStep(dt);\r\n                    if (performance.now() - t0 > dt * 1000) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.time += timeSinceLastCalled;\r\n                var h = this.time % dt;\r\n                var h_div_dt = h / dt;\r\n                var interpvelo = step_tmp1;\r\n                var bodies = this.bodies;\r\n                for (var j = 0; j !== bodies.length; j++) {\r\n                    var b = bodies[j];\r\n                    if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {\r\n                        b.position.vsub(b.previousPosition, interpvelo);\r\n                        interpvelo.scale(h_div_dt, interpvelo);\r\n                        b.position.vadd(interpvelo, b.interpolatedPosition);\r\n                    } else {\r\n                        b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\r\n                        b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._cannonRaycastResult.reset();\r\n        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\r\n\r\n        this._raycastResult.reset(from, to);\r\n        if (this._cannonRaycastResult.hasHit) {\r\n            // TODO: do we also want to get the body it hit?\r\n            this._raycastResult.setHitData(\r\n                {\r\n                    x: this._cannonRaycastResult.hitNormalWorld.x,\r\n                    y: this._cannonRaycastResult.hitNormalWorld.y,\r\n                    z: this._cannonRaycastResult.hitNormalWorld.z,\r\n                },\r\n                {\r\n                    x: this._cannonRaycastResult.hitPointWorld.x,\r\n                    y: this._cannonRaycastResult.hitPointWorld.y,\r\n                    z: this._cannonRaycastResult.hitPointWorld.z,\r\n                }\r\n            );\r\n            this._raycastResult.setHitDistance(this._cannonRaycastResult.distance);\r\n        }\r\n\r\n        return this._raycastResult;\r\n    }\r\n}\r\n\r\nPhysicsEngine.DefaultPluginFactory = () => {\r\n    return new CannonJSPlugin();\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}