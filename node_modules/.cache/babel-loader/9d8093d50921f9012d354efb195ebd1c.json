{"ast":null,"code":"import { PostProcess } from \"../PostProcesses/postProcess\";\nimport \"../Shaders/rgbdDecode.fragment\";\nimport \"../Engines/Extensions/engine.renderTarget\";\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\n\nvar RGBDTextureTools =\n/** @class */\nfunction () {\n  function RGBDTextureTools() {}\n  /**\r\n   * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n   * @param texture the texture to expand.\r\n   */\n\n\n  RGBDTextureTools.ExpandRGBDTexture = function (texture) {\n    var internalTexture = texture._texture;\n\n    if (!internalTexture || !texture.isRGBD) {\n      return;\n    } // Gets everything ready.\n\n\n    var engine = internalTexture.getEngine();\n    var caps = engine.getCaps();\n    var expandTexture = false; // If half float available we can uncompress the texture\n\n    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 2;\n    } // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n        expandTexture = true;\n        internalTexture.type = 1;\n      }\n\n    if (expandTexture) {\n      // Do not use during decode.\n      internalTexture.isReady = false;\n      internalTexture._isRGBD = false;\n      internalTexture.invertY = false;\n    }\n\n    texture.onLoadObservable.addOnce(function () {\n      // Expand the texture if possible\n      if (expandTexture) {\n        // Simply run through the decode PP.\n        var rgbdPostProcess_1 = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false); // Hold the output of the decoding.\n\n        var expandedTexture_1 = engine.createRenderTargetTexture(internalTexture.width, {\n          generateDepthBuffer: false,\n          generateMipMaps: false,\n          generateStencilBuffer: false,\n          samplingMode: internalTexture.samplingMode,\n          type: internalTexture.type,\n          format: 5\n        });\n        rgbdPostProcess_1.getEffect().executeWhenCompiled(function () {\n          // PP Render Pass\n          rgbdPostProcess_1.onApply = function (effect) {\n            effect._bindTexture(\"textureSampler\", internalTexture);\n\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n\n          texture.getScene().postProcessManager.directRender([rgbdPostProcess_1], expandedTexture_1, true); // Cleanup\n\n          engine.restoreDefaultFramebuffer();\n\n          engine._releaseTexture(internalTexture);\n\n          engine._releaseFramebufferObjects(expandedTexture_1);\n\n          if (rgbdPostProcess_1) {\n            rgbdPostProcess_1.dispose();\n          } // Internal Swap\n\n\n          expandedTexture_1._swapAndDie(internalTexture); // Ready to get rolling again.\n\n\n          internalTexture.isReady = true;\n        });\n      }\n    });\n  };\n\n  return RGBDTextureTools;\n}();\n\nexport { RGBDTextureTools };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/rgbdTextureTools.ts"],"names":[],"mappings":"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","sourcesContent":["\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { Engine } from '../Engines/engine';\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\n\r\ndeclare type Texture = import(\"../Materials/Textures/texture\").Texture;\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = 2;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = 1;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        texture.onLoadObservable.addOnce(() => {\r\n            // Expand the texture if possible\r\n            if (expandTexture) {\r\n                // Simply run through the decode PP.\r\n                const rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false);\r\n\r\n                // Hold the output of the decoding.\r\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                    generateDepthBuffer: false,\r\n                    generateMipMaps: false,\r\n                    generateStencilBuffer: false,\r\n                    samplingMode: internalTexture.samplingMode,\r\n                    type: internalTexture.type,\r\n                    format: 5\r\n                });\r\n\r\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                    // PP Render Pass\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", internalTexture);\r\n                        effect.setFloat2(\"scale\", 1, 1);\r\n                    };\r\n                    texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    engine._releaseTexture(internalTexture);\r\n                    engine._releaseFramebufferObjects(expandedTexture);\r\n                    if (rgbdPostProcess) {\r\n                        rgbdPostProcess.dispose();\r\n                    }\r\n\r\n                    // Internal Swap\r\n                    expandedTexture._swapAndDie(internalTexture);\r\n\r\n                    // Ready to get rolling again.\r\n                    internalTexture.isReady = true;\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}