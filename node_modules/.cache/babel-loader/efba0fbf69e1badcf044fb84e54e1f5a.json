{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Texture } from \"./texture\";\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\n\nvar RawTexture =\n/** @class */\nfunction (_super) {\n  __extends(RawTexture, _super);\n  /**\r\n   * Instantiates a new RawTexture.\r\n   * Raw texture can help creating a texture directly from an array of data.\r\n   * This can be super useful if you either get the data from an uncompressed source or\r\n   * if you wish to create your texture pixel by pixel.\r\n   * @param data define the array of data to use to create the texture\r\n   * @param width define the width of the texture\r\n   * @param height define the height of the texture\r\n   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps define whether mip maps should be generated or not\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   */\n\n\n  function RawTexture(data, width, height,\n  /**\r\n   * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n   */\n  format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY) || this;\n\n    _this.format = format;\n\n    if (!_this._engine) {\n      return _this;\n    }\n\n    _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type);\n    _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    return _this;\n  }\n  /**\r\n   * Updates the texture underlying data.\r\n   * @param data Define the new data of the texture\r\n   */\n\n\n  RawTexture.prototype.update = function (data) {\n    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n  };\n  /**\r\n   * Creates a luminance texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the luminance texture\r\n   */\n\n\n  RawTexture.CreateLuminanceTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates a luminance alpha texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the luminance alpha texture\r\n   */\n\n\n  RawTexture.CreateLuminanceAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates an alpha texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @returns the alpha texture\r\n   */\n\n\n  RawTexture.CreateAlphaTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  };\n  /**\r\n   * Creates a RGB texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the RGB alpha texture\r\n   */\n\n\n  RawTexture.CreateRGBTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\r\n   * Creates a RGBA texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the RGBA texture\r\n   */\n\n\n  RawTexture.CreateRGBATexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (type === void 0) {\n      type = 0;\n    }\n\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n  /**\r\n   * Creates a R texture from some data.\r\n   * @param data Define the texture data\r\n   * @param width Define the width of the texture\r\n   * @param height Define the height of the texture\r\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n   * @returns the R texture\r\n   */\n\n\n  RawTexture.CreateRTexture = function (data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = true;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (type === void 0) {\n      type = 1;\n    }\n\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  };\n\n  return RawTexture;\n}(Texture);\n\nexport { RawTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/rawTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Texture } from \"./texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Nullable } from '../../types';\r\nimport { ThinEngine } from '../../Engines/thinEngine';\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     */\r\n    constructor(data: ArrayBufferView, width: number, height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3, type: number = 0) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3): RawTexture {\r\n        return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3): RawTexture {\r\n        return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3): RawTexture {\r\n        return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3, type: number = 0): RawTexture {\r\n        return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = 3, type: number = 0): RawTexture {\r\n        return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(data: ArrayBufferView, width: number, height: number, sceneOrEngine: Nullable<Scene | ThinEngine>, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE, type: number = 1): RawTexture {\r\n        return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}