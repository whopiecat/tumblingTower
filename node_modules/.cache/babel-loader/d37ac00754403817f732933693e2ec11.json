{"ast":null,"code":"import { RenderingGroup } from \"./renderingGroup\";\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\n\nvar RenderingGroupInfo =\n/** @class */\nfunction () {\n  function RenderingGroupInfo() {}\n\n  return RenderingGroupInfo;\n}();\n\nexport { RenderingGroupInfo };\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\n\nvar RenderingManager =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiates a new rendering group for a particular scene\r\n   * @param scene Defines the scene the groups belongs to\r\n   */\n  function RenderingManager(scene) {\n    /**\r\n     * @hidden\r\n     */\n    this._useSceneAutoClearSetup = false;\n    this._renderingGroups = new Array();\n    this._autoClearDepthStencil = {};\n    this._customOpaqueSortCompareFn = {};\n    this._customAlphaTestSortCompareFn = {};\n    this._customTransparentSortCompareFn = {};\n    this._renderingGroupInfo = new RenderingGroupInfo();\n    this._scene = scene;\n\n    for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n      this._autoClearDepthStencil[i] = {\n        autoClear: true,\n        depth: true,\n        stencil: true\n      };\n    }\n  }\n\n  RenderingManager.prototype._clearDepthStencilBuffer = function (depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    if (this._depthStencilBufferAlreadyCleaned) {\n      return;\n    }\n\n    this._scene.getEngine().clear(null, false, depth, stencil);\n\n    this._depthStencilBufferAlreadyCleaned = true;\n  };\n  /**\r\n   * Renders the entire managed groups. This is used by the scene or the different rennder targets.\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.render = function (customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n    // Update the observable context (not null as it only goes away on dispose)\n    var info = this._renderingGroupInfo;\n    info.scene = this._scene;\n    info.camera = this._scene.activeCamera; // Dispatch sprites\n\n    if (this._scene.spriteManagers && renderSprites) {\n      for (var index = 0; index < this._scene.spriteManagers.length; index++) {\n        var manager = this._scene.spriteManagers[index];\n        this.dispatchSprites(manager);\n      }\n    } // Render\n\n\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n      var renderingGroup = this._renderingGroups[index];\n\n      if (!renderingGroup) {\n        continue;\n      }\n\n      var renderingGroupMask = Math.pow(2, index);\n      info.renderingGroupId = index; // Before Observable\n\n      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask); // Clear depth/stencil if needed\n\n\n      if (RenderingManager.AUTOCLEAR) {\n        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n\n        if (autoClear && autoClear.autoClear) {\n          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n        }\n      } // Render\n\n\n      for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {\n        var step = _a[_i];\n        step.action(index);\n      }\n\n      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n\n      for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {\n        var step = _c[_b];\n        step.action(index);\n      } // After Observable\n\n\n      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n    }\n  };\n  /**\r\n   * Resets the different information of the group to prepare a new frame\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.reset = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.prepare();\n      }\n    }\n  };\n  /**\r\n   * Dispose and release the group and its associated resources.\r\n   * @hidden\r\n   */\n\n\n  RenderingManager.prototype.dispose = function () {\n    this.freeRenderingGroups();\n    this._renderingGroups.length = 0;\n    this._renderingGroupInfo = null;\n  };\n  /**\r\n   * Clear the info related to rendering groups preventing retention points during dispose.\r\n   */\n\n\n  RenderingManager.prototype.freeRenderingGroups = function () {\n    for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      var renderingGroup = this._renderingGroups[index];\n\n      if (renderingGroup) {\n        renderingGroup.dispose();\n      }\n    }\n  };\n\n  RenderingManager.prototype._prepareRenderingGroup = function (renderingGroupId) {\n    if (this._renderingGroups[renderingGroupId] === undefined) {\n      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n    }\n  };\n  /**\r\n   * Add a sprite manager to the rendering manager in order to render it this frame.\r\n   * @param spriteManager Define the sprite manager to render\r\n   */\n\n\n  RenderingManager.prototype.dispatchSprites = function (spriteManager) {\n    var renderingGroupId = spriteManager.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\n  };\n  /**\r\n   * Add a particle system to the rendering manager in order to render it this frame.\r\n   * @param particleSystem Define the particle system to render\r\n   */\n\n\n  RenderingManager.prototype.dispatchParticles = function (particleSystem) {\n    var renderingGroupId = particleSystem.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\n  };\n  /**\r\n   * Add a submesh to the manager in order to render it this frame\r\n   * @param subMesh The submesh to dispatch\r\n   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n   */\n\n\n  RenderingManager.prototype.dispatch = function (subMesh, mesh, material) {\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n\n    var renderingGroupId = mesh.renderingGroupId || 0;\n\n    this._prepareRenderingGroup(renderingGroupId);\n\n    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\n  };\n  /**\r\n   * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n   * This allowed control for front to back rendering or reversly depending of the special needs.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n   */\n\n\n  RenderingManager.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n    if (opaqueSortCompareFn === void 0) {\n      opaqueSortCompareFn = null;\n    }\n\n    if (alphaTestSortCompareFn === void 0) {\n      alphaTestSortCompareFn = null;\n    }\n\n    if (transparentSortCompareFn === void 0) {\n      transparentSortCompareFn = null;\n    }\n\n    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n\n    if (this._renderingGroups[renderingGroupId]) {\n      var group = this._renderingGroups[renderingGroupId];\n      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n    }\n  };\n  /**\r\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n   *\r\n   * @param renderingGroupId The rendering group id corresponding to its index\r\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n   */\n\n\n  RenderingManager.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n    if (depth === void 0) {\n      depth = true;\n    }\n\n    if (stencil === void 0) {\n      stencil = true;\n    }\n\n    this._autoClearDepthStencil[renderingGroupId] = {\n      autoClear: autoClearDepthStencil,\n      depth: depth,\n      stencil: stencil\n    };\n  };\n  /**\r\n   * Gets the current auto clear configuration for one rendering group of the rendering\r\n   * manager.\r\n   * @param index the rendering group index to get the information for\r\n   * @returns The auto clear setup for the requested rendering group\r\n   */\n\n\n  RenderingManager.prototype.getAutoClearDepthStencilSetup = function (index) {\n    return this._autoClearDepthStencil[index];\n  };\n  /**\r\n   * The max id used for rendering groups (not included)\r\n   */\n\n\n  RenderingManager.MAX_RENDERINGGROUPS = 4;\n  /**\r\n   * The min id used for rendering groups (included)\r\n   */\n\n  RenderingManager.MIN_RENDERINGGROUPS = 0;\n  /**\r\n   * Used to globally prevent autoclearing scenes.\r\n   */\n\n  RenderingManager.AUTOCLEAR = true;\n  return RenderingManager;\n}();\n\nexport { RenderingManager };","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/renderingManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different rennder targets.\r\n     * @hidden\r\n     */\r\n    public render(customRenderFunction: Nullable<(opaqueSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>) => void>,\r\n        activeMeshes: Nullable<AbstractMesh[]>, renderParticles: boolean, renderSprites: boolean): void {\r\n\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                var manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            var renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup) {\r\n                continue;\r\n            }\r\n\r\n            let renderingGroupMask = Math.pow(2, index);\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ?\r\n                    this._scene.getAutoClearDepthStencilSetup(index) :\r\n                    this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (let step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (let step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @hidden\r\n     */\r\n    public reset(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            var renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @hidden\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            var renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        var renderingGroupId = spriteManager.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        var renderingGroupId = particleSystem.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        var renderingGroupId = mesh.renderingGroupId || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null) {\r\n\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            var group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean,\r\n        depth = true,\r\n        stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}