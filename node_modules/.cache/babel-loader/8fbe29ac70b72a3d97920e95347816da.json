{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PanoramaToCubeMapTools } from '../../Misc/HighDynamicRange/panoramaToCubemap';\nimport { BaseTexture } from './baseTexture';\nimport { Texture } from './texture';\nimport { Tools } from '../../Misc/tools';\nimport \"../../Engines/Extensions/engine.rawTexture\";\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\n\nvar EquiRectangularCubeTexture =\n/** @class */\nfunction (_super) {\n  __extends(EquiRectangularCubeTexture, _super);\n  /**\r\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n   * @param url The location of the image\r\n   * @param scene The scene the texture will be used in\r\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n   * @param noMipmap Forces to not generate the mipmap if true\r\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n   * @param onLoad — defines a callback called when texture is loaded\r\n   * @param onError — defines a callback called if there is an error\r\n   */\n\n\n  function EquiRectangularCubeTexture(url, scene, size, noMipmap, gammaSpace, onLoad, onError) {\n    if (noMipmap === void 0) {\n      noMipmap = false;\n    }\n\n    if (gammaSpace === void 0) {\n      gammaSpace = true;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    var _this = _super.call(this, scene) || this;\n\n    _this._onLoad = null;\n    _this._onError = null;\n\n    if (!url) {\n      throw new Error('Image url is not set');\n    }\n\n    _this._coordinatesMode = Texture.CUBIC_MODE;\n    _this.name = url;\n    _this.url = url;\n    _this._size = size;\n    _this._noMipmap = noMipmap;\n    _this.gammaSpace = gammaSpace;\n    _this._onLoad = onLoad;\n    _this._onError = onError;\n    _this.hasAlpha = false;\n    _this.isCube = true;\n    _this._texture = _this._getFromCache(url, _this._noMipmap);\n\n    if (!_this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        _this.loadImage(_this.loadTexture.bind(_this), _this._onError);\n      } else {\n        _this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (_this._texture.isReady) {\n        Tools.SetImmediate(function () {\n          return onLoad();\n        });\n      } else {\n        _this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n\n    return _this;\n  }\n  /**\r\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.loadImage = function (loadTextureCallback, onError) {\n    var _this = this;\n\n    var canvas = document.createElement('canvas');\n    var image = new Image();\n    image.addEventListener('load', function () {\n      _this._width = image.width;\n      _this._height = image.height;\n      canvas.width = _this._width;\n      canvas.height = _this._height;\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0);\n      var imageData = ctx.getImageData(0, 0, image.width, image.height);\n      _this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    });\n    image.addEventListener('error', function (error) {\n      if (onError) {\n        onError(_this.getClassName() + \" could not be loaded\", error);\n      }\n    });\n    image.src = this.url;\n  };\n  /**\r\n   * Convert the image buffer into a cubemap and create a CubeTexture.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.loadTexture = function () {\n    var _this = this;\n\n    var scene = this.getScene();\n\n    var callback = function () {\n      var imageData = _this.getFloat32ArrayFromArrayBuffer(_this._buffer); // Extract the raw linear data.\n\n\n      var data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, _this._width, _this._height, _this._size);\n      var results = []; // Push each faces.\n\n      for (var i = 0; i < 6; i++) {\n        var dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n\n      return results;\n    };\n\n    if (!scene) {\n      return;\n    }\n\n    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);\n  };\n  /**\r\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n   * @param buffer The ArrayBuffer that should be converted.\r\n   * @returns The buffer as Float32Array.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.getFloat32ArrayFromArrayBuffer = function (buffer) {\n    var dataView = new DataView(buffer);\n    var floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    var k = 0;\n\n    for (var i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n\n    return floatImageData;\n  };\n  /**\r\n   * Get the current class name of the texture useful for serialization or dynamic coding.\r\n   * @returns \"EquiRectangularCubeTexture\"\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.getClassName = function () {\n    return \"EquiRectangularCubeTexture\";\n  };\n  /**\r\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n   * @returns A clone of the current EquiRectangularCubeTexture.\r\n   */\n\n\n  EquiRectangularCubeTexture.prototype.clone = function () {\n    var scene = this.getScene();\n\n    if (!scene) {\n      return this;\n    }\n\n    var newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace); // Base texture\n\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  };\n  /** The six faces of the cube. */\n\n\n  EquiRectangularCubeTexture._FacesMapping = ['right', 'left', 'up', 'down', 'front', 'back'];\n  return EquiRectangularCubeTexture;\n}(BaseTexture);\n\nexport { EquiRectangularCubeTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/equiRectangularCubeTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { PanoramaToCubeMapTools } from '../../Misc/HighDynamicRange/panoramaToCubemap';\nimport { BaseTexture } from './baseTexture';\nimport { Texture } from './texture';\nimport { Scene } from \"../../scene\";\nimport { Nullable } from \"../../types\";\nimport { Tools } from '../../Misc/tools';\nimport \"../../Engines/Extensions/engine.rawTexture\";\n\n\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n    /** The six faces of the cube. */\n    private static _FacesMapping = ['right', 'left', 'up', 'down', 'front', 'back'];\n\n    private _noMipmap: boolean;\n    private _onLoad: Nullable<() => void> = null;\n    private _onError: Nullable<() => void> = null;\n\n    /** The size of the cubemap. */\n    private _size: number;\n\n    /** The buffer of the image. */\n    private _buffer: ArrayBuffer;\n\n    /** The width of the input image. */\n    private _width: number;\n\n    /** The height of the input image. */\n    private _height: number;\n\n    /** The URL to the image. */\n    public url: string;\n\n    /**\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\n     * @param url The location of the image\n     * @param scene The scene the texture will be used in\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\n     * @param noMipmap Forces to not generate the mipmap if true\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n     * @param onLoad — defines a callback called when texture is loaded\n     * @param onError — defines a callback called if there is an error\n     */\n    constructor(\n        url: string,\n        scene: Scene,\n        size: number,\n        noMipmap: boolean = false,\n        gammaSpace: boolean = true,\n        onLoad: Nullable<() => void> = null,\n        onError: Nullable<(message?: string, exception?: any) => void> = null\n    ) {\n        super(scene);\n\n        if (!url) {\n            throw new Error('Image url is not set');\n        }\n\n        this._coordinatesMode = Texture.CUBIC_MODE;\n        this.name = url;\n        this.url = url;\n        this._size = size;\n        this._noMipmap = noMipmap;\n        this.gammaSpace = gammaSpace;\n        this._onLoad = onLoad;\n        this._onError = onError;\n\n        this.hasAlpha = false;\n        this.isCube = true;\n\n        this._texture = this._getFromCache(url, this._noMipmap);\n\n        if (!this._texture) {\n            if (!scene.useDelayedTextureLoading) {\n                this.loadImage(this.loadTexture.bind(this), this._onError);\n            } else {\n                this.delayLoadState = 4;\n            }\n        } else if (onLoad) {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoad());\n            } else {\n                this._texture.onLoadedObservable.add(onLoad);\n            }\n        }\n    }\n\n    /**\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\n     */\n    private loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\n        const canvas = document.createElement('canvas');\n        const image = new Image();\n\n        image.addEventListener('load', () => {\n            this._width = image.width;\n            this._height = image.height;\n            canvas.width = this._width;\n            canvas.height = this._height;\n\n            const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n            ctx.drawImage(image, 0, 0);\n\n            const imageData = ctx.getImageData(0, 0, image.width, image.height);\n            this._buffer = imageData.data.buffer as ArrayBuffer;\n\n            canvas.remove();\n            loadTextureCallback();\n        });\n        image.addEventListener('error', (error) => {\n            if (onError) {\n                onError(`${this.getClassName()} could not be loaded`, error);\n            }\n        });\n        image.src = this.url;\n    }\n\n    /**\n     * Convert the image buffer into a cubemap and create a CubeTexture.\n     */\n    private loadTexture(): void {\n        const scene = this.getScene();\n        const callback = (): Nullable<ArrayBufferView[]> => {\n            const imageData = this.getFloat32ArrayFromArrayBuffer(this._buffer);\n\n            // Extract the raw linear data.\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\n\n            const results = [];\n\n            // Push each faces.\n            for (let i = 0; i < 6; i++) {\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\n                results.push(dataFace);\n            }\n\n            return results;\n        };\n\n        if (!scene) {\n            return;\n        }\n        this._texture = scene\n            .getEngine()\n            .createRawCubeTextureFromUrl(\n                this.url,\n                scene,\n                this._size,\n                4,\n                scene.getEngine().getCaps().textureFloat\n                    ? 1\n                    : 7,\n                this._noMipmap,\n                callback,\n                null,\n                this._onLoad,\n                this._onError\n            );\n    }\n\n    /**\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n     * @param buffer The ArrayBuffer that should be converted.\n     * @returns The buffer as Float32Array.\n     */\n    private getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\n        const dataView = new DataView(buffer);\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\n\n        let k = 0;\n        for (let i = 0; i < buffer.byteLength; i++) {\n            // We drop the transparency channel, because we do not need/want it\n            if ((i + 1) % 4 !== 0) {\n                floatImageData[k++] = dataView.getUint8(i) / 255;\n            }\n        }\n\n        return floatImageData;\n    }\n\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"EquiRectangularCubeTexture\"\n     */\n    public getClassName(): string {\n        return \"EquiRectangularCubeTexture\";\n    }\n\n    /**\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\n     * @returns A clone of the current EquiRectangularCubeTexture.\n     */\n    public clone(): EquiRectangularCubeTexture {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n\n        // Base texture\n        newTexture.level = this.level;\n        newTexture.wrapU = this.wrapU;\n        newTexture.wrapV = this.wrapV;\n        newTexture.coordinatesIndex = this.coordinatesIndex;\n        newTexture.coordinatesMode = this.coordinatesMode;\n\n        return newTexture;\n    }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}