{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { SerializationHelper, serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\nimport { Color3 } from '../../Maths/math.color';\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\n/**\r\n * Define the code related to the Sheen parameters of the pbr material.\r\n */\n\nvar PBRSheenConfiguration =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new istance of clear coat configuration.\r\n   * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n   */\n  function PBRSheenConfiguration(markAllSubMeshesAsTexturesDirty) {\n    this._isEnabled = false;\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\n\n    this.isEnabled = false;\n    this._linkSheenWithAlbedo = false;\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\n\n    this.linkSheenWithAlbedo = false;\n    /**\r\n     * Defines the sheen intensity.\r\n     */\n\n    this.intensity = 1;\n    /**\r\n     * Defines the sheen color.\r\n     */\n\n    this.color = Color3.White();\n    this._texture = null;\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\n\n    this.texture = null;\n    this._useRoughnessFromMainTexture = true;\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\n\n    this.useRoughnessFromMainTexture = true;\n    this._roughness = null;\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\n\n    this.roughness = null;\n    this._textureRoughness = null;\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\n\n    this.textureRoughness = null;\n    this._albedoScaling = false;\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\n\n    this.albedoScaling = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\n  }\n  /** @hidden */\n\n\n  PBRSheenConfiguration.prototype._markAllSubMeshesAsTexturesDirty = function () {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @returns - boolean indicating that the submesh is ready or not.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.isReadyForSubMesh = function (defines, scene) {\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.SheenTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n\n        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n          if (!this._textureRoughness.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param defines the list of \"defines\" to update.\r\n   * @param scene defines the scene the material belongs to.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.prepareDefines = function (defines, scene) {\n    var _a;\n\n    if (this._isEnabled) {\n      defines.SHEEN = this._isEnabled;\n      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\n      defines.SHEEN_ROUGHNESS = this._roughness !== null;\n      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);\n\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.SheenTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\n          } else {\n            defines.SHEEN_TEXTURE = false;\n          }\n\n          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\n          } else {\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\n          }\n        }\n      }\n    } else {\n      defines.SHEEN = false;\n      defines.SHEEN_TEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS = false;\n      defines.SHEEN_LINKWITHALBEDO = false;\n      defines.SHEEN_ROUGHNESS = false;\n      defines.SHEEN_ALBEDOSCALING = false;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n    }\n  };\n  /**\r\n   * Binds the material data.\r\n   * @param uniformBuffer defines the Uniform buffer to fill in.\r\n   * @param scene defines the scene the material belongs to.\r\n   * @param isFrozen defines wether the material is frozen or not.\r\n   * @param subMesh the submesh to bind data for\r\n   */\n\n\n  PBRSheenConfiguration.prototype.bindForSubMesh = function (uniformBuffer, scene, isFrozen, subMesh) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    var defines = subMesh._materialDefines;\n    var identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\n\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n      } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);\n\n        if (this._texture) {\n          MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n        }\n\n        if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\n          MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\n        }\n      } // Sheen\n\n\n      uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\n\n      if (this._roughness !== null) {\n        uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\n      }\n    } // Textures\n\n\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenSampler\", this._texture);\n      }\n\n      if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\n      }\n    }\n  };\n  /**\r\n   * Checks to see if a texture is used in the material.\r\n   * @param texture - Base texture to use.\r\n   * @returns - Boolean specifying if a texture is used in the material.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.hasTexture = function (texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n\n    if (this._textureRoughness === texture) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns an array of the actively used textures.\r\n   * @param activeTextures Array of BaseTextures\r\n   */\n\n\n  PBRSheenConfiguration.prototype.getActiveTextures = function (activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n\n    if (this._textureRoughness) {\n      activeTextures.push(this._textureRoughness);\n    }\n  };\n  /**\r\n   * Returns the animatable textures.\r\n   * @param animatables Array of animatable textures.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.getAnimatables = function (animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n\n    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\n      animatables.push(this._textureRoughness);\n    }\n  };\n  /**\r\n   * Disposes the resources of the material.\r\n   * @param forceDisposeTextures - Forces the disposal of all textures.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.dispose = function (forceDisposeTextures) {\n    var _a, _b;\n\n    if (forceDisposeTextures) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();\n      (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n  };\n  /**\r\n  * Get the current class name of the texture useful for serialization or dynamic coding.\r\n  * @returns \"PBRSheenConfiguration\"\r\n  */\n\n\n  PBRSheenConfiguration.prototype.getClassName = function () {\n    return \"PBRSheenConfiguration\";\n  };\n  /**\r\n   * Add fallbacks to the effect fallbacks list.\r\n   * @param defines defines the Base texture to use.\r\n   * @param fallbacks defines the current fallback list.\r\n   * @param currentRank defines the current fallback rank.\r\n   * @returns the new fallback rank.\r\n   */\n\n\n  PBRSheenConfiguration.AddFallbacks = function (defines, fallbacks, currentRank) {\n    if (defines.SHEEN) {\n      fallbacks.addFallback(currentRank++, \"SHEEN\");\n    }\n\n    return currentRank;\n  };\n  /**\r\n   * Add the required uniforms to the current list.\r\n   * @param uniforms defines the current uniform list.\r\n   */\n\n\n  PBRSheenConfiguration.AddUniforms = function (uniforms) {\n    uniforms.push(\"vSheenColor\", \"vSheenRoughness\", \"vSheenInfos\", \"sheenMatrix\", \"sheenRoughnessMatrix\");\n  };\n  /**\r\n   * Add the required uniforms to the current buffer.\r\n   * @param uniformBuffer defines the current uniform buffer.\r\n   */\n\n\n  PBRSheenConfiguration.PrepareUniformBuffer = function (uniformBuffer) {\n    uniformBuffer.addUniform(\"vSheenColor\", 4);\n    uniformBuffer.addUniform(\"vSheenRoughness\", 1);\n    uniformBuffer.addUniform(\"vSheenInfos\", 4);\n    uniformBuffer.addUniform(\"sheenMatrix\", 16);\n    uniformBuffer.addUniform(\"sheenRoughnessMatrix\", 16);\n  };\n  /**\r\n   * Add the required samplers to the current list.\r\n   * @param samplers defines the current sampler list.\r\n   */\n\n\n  PBRSheenConfiguration.AddSamplers = function (samplers) {\n    samplers.push(\"sheenSampler\");\n    samplers.push(\"sheenRoughnessSampler\");\n  };\n  /**\r\n   * Makes a duplicate of the current configuration into another one.\r\n   * @param sheenConfiguration define the config where to copy the info\r\n   */\n\n\n  PBRSheenConfiguration.prototype.copyTo = function (sheenConfiguration) {\n    SerializationHelper.Clone(function () {\n      return sheenConfiguration;\n    }, this);\n  };\n  /**\r\n   * Serializes this BRDF configuration.\r\n   * @returns - An object with the serialized config.\r\n   */\n\n\n  PBRSheenConfiguration.prototype.serialize = function () {\n    return SerializationHelper.Serialize(this);\n  };\n  /**\r\n   * Parses a anisotropy Configuration from a serialized object.\r\n   * @param source - Serialized object.\r\n   * @param scene Defines the scene we are parsing for\r\n   * @param rootUrl Defines the rootUrl to load from\r\n   */\n\n\n  PBRSheenConfiguration.prototype.parse = function (source, scene, rootUrl) {\n    var _this = this;\n\n    SerializationHelper.Parse(function () {\n      return _this;\n    }, source, scene, rootUrl);\n  };\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"isEnabled\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"linkSheenWithAlbedo\", void 0);\n\n  __decorate([serialize()], PBRSheenConfiguration.prototype, \"intensity\", void 0);\n\n  __decorate([serializeAsColor3()], PBRSheenConfiguration.prototype, \"color\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"texture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"useRoughnessFromMainTexture\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"roughness\", void 0);\n\n  __decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"textureRoughness\", void 0);\n\n  __decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"albedoScaling\", void 0);\n\n  return PBRSheenConfiguration;\n}();\n\nexport { PBRSheenConfiguration };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/PBR/pbrSheenConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["import { SerializationHelper, serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { Scene } from \"../../scene\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Nullable } from \"../../types\";\r\nimport { IAnimatable } from '../../Animations/animatable.interface';\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\nimport { SubMesh } from '../../Meshes/subMesh';\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface IMaterialSheenDefines {\r\n    SHEEN: boolean;\r\n    SHEEN_TEXTURE: boolean;\r\n    SHEEN_TEXTURE_ROUGHNESS: boolean;\r\n    SHEEN_TEXTUREDIRECTUV: number;\r\n    SHEEN_TEXTURE_ROUGHNESSDIRECTUV: number;\r\n    SHEEN_LINKWITHALBEDO: boolean;\r\n    SHEEN_ROUGHNESS: boolean;\r\n    SHEEN_ALBEDOSCALING: boolean;\r\n    SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE: boolean;\r\n    SHEEN_TEXTURE_ROUGHNESS_IDENTICAL: boolean;\r\n\r\n    /** @hidden */\r\n    _areTexturesDirty: boolean;\r\n}\r\n\r\n/**\r\n * Define the code related to the Sheen parameters of the pbr material.\r\n */\r\nexport class PBRSheenConfiguration {\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the material uses sheen.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    private _linkSheenWithAlbedo = false;\r\n    /**\r\n     * Defines if the sheen is linked to the sheen color.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkSheenWithAlbedo = false;\r\n\r\n    /**\r\n     * Defines the sheen intensity.\r\n     */\r\n    @serialize()\r\n    public intensity = 1;\r\n\r\n    /**\r\n     * Defines the sheen color.\r\n     */\r\n    @serializeAsColor3()\r\n    public color = Color3.White();\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen tint values in a texture.\r\n     * rgb is tint\r\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\r\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    private _useRoughnessFromMainTexture = true;\r\n    /**\r\n     * Indicates that the alpha channel of the texture property will be used for roughness.\r\n     * Has no effect if the roughness (and texture!) property is not defined\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRoughnessFromMainTexture = true;\r\n\r\n    private _roughness: Nullable<number> = null;\r\n    /**\r\n     * Defines the sheen roughness.\r\n     * It is not taken into account if linkSheenWithAlbedo is true.\r\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: Nullable<number> = null;\r\n\r\n    private _textureRoughness: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the sheen roughness in a texture.\r\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public textureRoughness: Nullable<BaseTexture> = null;\r\n\r\n    private _albedoScaling = false;\r\n    /**\r\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\r\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\r\n     * making it easier to setup and tweak the effect\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public albedoScaling = false;\r\n\r\n    /** @hidden */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @hidden */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new istance of clear coat configuration.\r\n     * @param markAllSubMeshesAsTexturesDirty Callback to flag the material to dirty\r\n     */\r\n    constructor(markAllSubMeshesAsTexturesDirty: () => void) {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = markAllSubMeshesAsTexturesDirty;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(defines: IMaterialSheenDefines, scene: Scene): boolean {\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                    if (!this._textureRoughness.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     */\r\n    public prepareDefines(defines: IMaterialSheenDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.SHEEN = this._isEnabled;\r\n            defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\r\n            defines.SHEEN_ROUGHNESS = this._roughness !== null;\r\n            defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === this._textureRoughness?._texture && this._texture.checkTransformsAreIdentical(this._textureRoughness);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE = false;\r\n                    }\r\n\r\n                    if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\r\n                    } else {\r\n                        defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.SHEEN = false;\r\n            defines.SHEEN_TEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\r\n            defines.SHEEN_LINKWITHALBEDO = false;\r\n            defines.SHEEN_ROUGHNESS = false;\r\n            defines.SHEEN_ALBEDOSCALING = false;\r\n            defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\r\n            defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param isFrozen defines wether the material is frozen or not.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, isFrozen: boolean, subMesh?: SubMesh): void {\r\n        const defines = subMesh!._materialDefines as unknown as IMaterialSheenDefines;\r\n\r\n        const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture!.coordinatesIndex, this._texture!.level, -1, -1);\r\n                MaterialHelper.BindTextureMatrix(this._texture!, uniformBuffer, \"sheen\");\r\n            } else  if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);\r\n                if (this._texture) {\r\n                    MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\r\n                }\r\n                if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\r\n                    MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\r\n                }\r\n            }\r\n\r\n            // Sheen\r\n            uniformBuffer.updateFloat4(\"vSheenColor\",\r\n                this.color.r,\r\n                this.color.g,\r\n                this.color.b,\r\n                this.intensity);\r\n\r\n            if (this._roughness !== null) {\r\n                uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenSampler\", this._texture);\r\n            }\r\n\r\n            if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\r\n                uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._textureRoughness === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness) {\r\n            activeTextures.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n\r\n        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\r\n            animatables.push(this._textureRoughness);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n            this._textureRoughness?.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Get the current class name of the texture useful for serialization or dynamic coding.\r\n    * @returns \"PBRSheenConfiguration\"\r\n    */\r\n    public getClassName(): string {\r\n        return \"PBRSheenConfiguration\";\r\n    }\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public static AddFallbacks(defines: IMaterialSheenDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SHEEN) {\r\n            fallbacks.addFallback(currentRank++, \"SHEEN\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"vSheenColor\", \"vSheenRoughness\", \"vSheenInfos\", \"sheenMatrix\", \"sheenRoughnessMatrix\");\r\n    }\r\n\r\n    /**\r\n     * Add the required uniforms to the current buffer.\r\n     * @param uniformBuffer defines the current uniform buffer.\r\n     */\r\n    public static PrepareUniformBuffer(uniformBuffer: UniformBuffer): void {\r\n        uniformBuffer.addUniform(\"vSheenColor\", 4);\r\n        uniformBuffer.addUniform(\"vSheenRoughness\", 1);\r\n        uniformBuffer.addUniform(\"vSheenInfos\", 4);\r\n        uniformBuffer.addUniform(\"sheenMatrix\", 16);\r\n        uniformBuffer.addUniform(\"sheenRoughnessMatrix\", 16);\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    public static AddSamplers(samplers: string[]): void {\r\n        samplers.push(\"sheenSampler\");\r\n        samplers.push(\"sheenRoughnessSampler\");\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param sheenConfiguration define the config where to copy the info\r\n     */\r\n    public copyTo(sheenConfiguration: PBRSheenConfiguration): void {\r\n        SerializationHelper.Clone(() => sheenConfiguration, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this BRDF configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a anisotropy Configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}