{"ast":null,"code":"import { PrecisionDate } from \"./precisionDate\";\n/**\r\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\r\n */\n\nvar PerformanceMonitor =\n/** @class */\nfunction () {\n  /**\r\n   * constructor\r\n   * @param frameSampleSize The number of samples required to saturate the sliding window\r\n   */\n  function PerformanceMonitor(frameSampleSize) {\n    if (frameSampleSize === void 0) {\n      frameSampleSize = 30;\n    }\n\n    this._enabled = true;\n    this._rollingFrameTime = new RollingAverage(frameSampleSize);\n  }\n  /**\r\n   * Samples current frame\r\n   * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\r\n   */\n\n\n  PerformanceMonitor.prototype.sampleFrame = function (timeMs) {\n    if (timeMs === void 0) {\n      timeMs = PrecisionDate.Now;\n    }\n\n    if (!this._enabled) {\n      return;\n    }\n\n    if (this._lastFrameTimeMs != null) {\n      var dt = timeMs - this._lastFrameTimeMs;\n\n      this._rollingFrameTime.add(dt);\n    }\n\n    this._lastFrameTimeMs = timeMs;\n  };\n\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFrameTime\", {\n    /**\r\n     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function () {\n      return this._rollingFrameTime.average;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFrameTimeVariance\", {\n    /**\r\n     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function () {\n      return this._rollingFrameTime.variance;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"instantaneousFrameTime\", {\n    /**\r\n     * Returns the frame time of the most recent frame\r\n     */\n    get: function () {\n      return this._rollingFrameTime.history(0);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"averageFPS\", {\n    /**\r\n     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\r\n     */\n    get: function () {\n      return 1000.0 / this._rollingFrameTime.average;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"instantaneousFPS\", {\n    /**\r\n     * Returns the average framerate in frames per second using the most recent frame time\r\n     */\n    get: function () {\n      var history = this._rollingFrameTime.history(0);\n\n      if (history === 0) {\n        return 0;\n      }\n\n      return 1000.0 / history;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PerformanceMonitor.prototype, \"isSaturated\", {\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     */\n    get: function () {\n      return this._rollingFrameTime.isSaturated();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Enables contributions to the sliding window sample set\r\n   */\n\n  PerformanceMonitor.prototype.enable = function () {\n    this._enabled = true;\n  };\n  /**\r\n   * Disables contributions to the sliding window sample set\r\n   * Samples will not be interpolated over the disabled period\r\n   */\n\n\n  PerformanceMonitor.prototype.disable = function () {\n    this._enabled = false; //clear last sample to avoid interpolating over the disabled period when next enabled\n\n    this._lastFrameTimeMs = null;\n  };\n\n  Object.defineProperty(PerformanceMonitor.prototype, \"isEnabled\", {\n    /**\r\n     * Returns true if sampling is enabled\r\n     */\n    get: function () {\n      return this._enabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Resets performance monitor\r\n   */\n\n  PerformanceMonitor.prototype.reset = function () {\n    //clear last sample to avoid interpolating over the disabled period when next enabled\n    this._lastFrameTimeMs = null; //wipe record\n\n    this._rollingFrameTime.reset();\n  };\n\n  return PerformanceMonitor;\n}();\n\nexport { PerformanceMonitor };\n/**\r\n * RollingAverage\r\n *\r\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\r\n */\n\nvar RollingAverage =\n/** @class */\nfunction () {\n  /**\r\n   * constructor\r\n   * @param length The number of samples required to saturate the sliding window\r\n   */\n  function RollingAverage(length) {\n    this._samples = new Array(length);\n    this.reset();\n  }\n  /**\r\n   * Adds a sample to the sample set\r\n   * @param v The sample value\r\n   */\n\n\n  RollingAverage.prototype.add = function (v) {\n    //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n    var delta; //we need to check if we've already wrapped round\n\n    if (this.isSaturated()) {\n      //remove bottom of stack from mean\n      var bottomValue = this._samples[this._pos];\n      delta = bottomValue - this.average;\n      this.average -= delta / (this._sampleCount - 1);\n      this._m2 -= delta * (bottomValue - this.average);\n    } else {\n      this._sampleCount++;\n    } //add new value to mean\n\n\n    delta = v - this.average;\n    this.average += delta / this._sampleCount;\n    this._m2 += delta * (v - this.average); //set the new variance\n\n    this.variance = this._m2 / (this._sampleCount - 1);\n    this._samples[this._pos] = v;\n    this._pos++;\n    this._pos %= this._samples.length; //positive wrap around\n  };\n  /**\r\n   * Returns previously added values or null if outside of history or outside the sliding window domain\r\n   * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\r\n   * @return Value previously recorded with add() or null if outside of range\r\n   */\n\n\n  RollingAverage.prototype.history = function (i) {\n    if (i >= this._sampleCount || i >= this._samples.length) {\n      return 0;\n    }\n\n    var i0 = this._wrapPosition(this._pos - 1.0);\n\n    return this._samples[this._wrapPosition(i0 - i)];\n  };\n  /**\r\n   * Returns true if enough samples have been taken to completely fill the sliding window\r\n   * @return true if sample-set saturated\r\n   */\n\n\n  RollingAverage.prototype.isSaturated = function () {\n    return this._sampleCount >= this._samples.length;\n  };\n  /**\r\n   * Resets the rolling average (equivalent to 0 samples taken so far)\r\n   */\n\n\n  RollingAverage.prototype.reset = function () {\n    this.average = 0;\n    this.variance = 0;\n    this._sampleCount = 0;\n    this._pos = 0;\n    this._m2 = 0;\n  };\n  /**\r\n   * Wraps a value around the sample range boundaries\r\n   * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\r\n   * @return Wrapped position in sample range\r\n   */\n\n\n  RollingAverage.prototype._wrapPosition = function (i) {\n    var max = this._samples.length;\n    return (i % max + max) % max;\n  };\n\n  return RollingAverage;\n}();\n\nexport { RollingAverage };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/performanceMonitor.ts"],"names":[],"mappings":"AACA,SAAS,aAAT,QAA8B,iBAA9B;AAEA;;;;AAGA,IAAA,kBAAA;AAAA;AAAA,YAAA;AAMI;;;;AAIA,WAAA,kBAAA,CAAY,eAAZ,EAAwC;AAA5B,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,EAAA;AAA4B;;AARhC,SAAA,QAAA,GAAoB,IAApB;AASJ,SAAK,iBAAL,GAAyB,IAAI,cAAJ,CAAmB,eAAnB,CAAzB;AACH;AAED;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAqD;AAAlC,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAiB,aAAa,CAAC,GAA/B;AAAkC;;AACjD,QAAI,CAAC,KAAK,QAAV,EAAoB;AAAE;AAAS;;AAE/B,QAAI,KAAK,gBAAL,IAAyB,IAA7B,EAAmC;AAC/B,UAAI,EAAE,GAAG,MAAM,GAAG,KAAK,gBAAvB;;AACA,WAAK,iBAAL,CAAuB,GAAvB,CAA2B,EAA3B;AACH;;AAED,SAAK,gBAAL,GAAwB,MAAxB;AACH,GATM;;AAcP,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,kBAAX,EAA2B;AAH3B;;;SAGA,YAAA;AACI,aAAO,KAAK,iBAAL,CAAuB,OAA9B;AACH,KAF0B;qBAAA;;AAAA,GAA3B;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,0BAAX,EAAmC;AAHnC;;;SAGA,YAAA;AACI,aAAO,KAAK,iBAAL,CAAuB,QAA9B;AACH,KAFkC;qBAAA;;AAAA,GAAnC;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,wBAAX,EAAiC;AAHjC;;;SAGA,YAAA;AACI,aAAO,KAAK,iBAAL,CAAuB,OAAvB,CAA+B,CAA/B,CAAP;AACH,KAFgC;qBAAA;;AAAA,GAAjC;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,YAAX,EAAqB;AAHrB;;;SAGA,YAAA;AACI,aAAO,SAAS,KAAK,iBAAL,CAAuB,OAAvC;AACH,KAFoB;qBAAA;;AAAA,GAArB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,kBAAX,EAA2B;AAH3B;;;SAGA,YAAA;AACI,UAAI,OAAO,GAAG,KAAK,iBAAL,CAAuB,OAAvB,CAA+B,CAA/B,CAAd;;AAEA,UAAI,OAAO,KAAK,CAAhB,EAAmB;AACf,eAAO,CAAP;AACH;;AAED,aAAO,SAAS,OAAhB;AACH,KAR0B;qBAAA;;AAAA,GAA3B;AAaA,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AAHtB;;;SAGA,YAAA;AACI,aAAO,KAAK,iBAAL,CAAuB,WAAvB,EAAP;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAIA;;;;AAGO,EAAA,kBAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,SAAK,QAAL,GAAgB,IAAhB;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,kBAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,SAAK,QAAL,GAAgB,KAAhB,CADJ,CAEI;;AACA,SAAK,gBAAL,GAAwB,IAAxB;AACH,GAJM;;AASP,EAAA,MAAA,CAAA,cAAA,CAAW,kBAAA,CAAA,SAAX,EAAW,WAAX,EAAoB;AAHpB;;;SAGA,YAAA;AACI,aAAO,KAAK,QAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAIA;;;;AAGO,EAAA,kBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI;AACA,SAAK,gBAAL,GAAwB,IAAxB,CAFJ,CAGI;;AACA,SAAK,iBAAL,CAAuB,KAAvB;AACH,GALM;;AAOX,SAAA,kBAAA;AAAC,CA/GD,EAAA;;;AAiHA;;;;;;AAKA,IAAA,cAAA;AAAA;AAAA,YAAA;AAgBI;;;;AAIA,WAAA,cAAA,CAAY,MAAZ,EAA0B;AACtB,SAAK,QAAL,GAAgB,IAAI,KAAJ,CAAkB,MAAlB,CAAhB;AACA,SAAK,KAAL;AACH;AAED;;;;;;AAIO,EAAA,cAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAoB;AAChB;AACA,QAAI,KAAJ,CAFgB,CAIhB;;AACA,QAAI,KAAK,WAAL,EAAJ,EAAwB;AACpB;AACA,UAAI,WAAW,GAAG,KAAK,QAAL,CAAc,KAAK,IAAnB,CAAlB;AACA,MAAA,KAAK,GAAG,WAAW,GAAG,KAAK,OAA3B;AACA,WAAK,OAAL,IAAgB,KAAK,IAAI,KAAK,YAAL,GAAoB,CAAxB,CAArB;AACA,WAAK,GAAL,IAAY,KAAK,IAAI,WAAW,GAAG,KAAK,OAAvB,CAAjB;AACH,KAND,MAMO;AACH,WAAK,YAAL;AACH,KAbe,CAehB;;;AACA,IAAA,KAAK,GAAG,CAAC,GAAG,KAAK,OAAjB;AACA,SAAK,OAAL,IAAgB,KAAK,GAAI,KAAK,YAA9B;AACA,SAAK,GAAL,IAAY,KAAK,IAAI,CAAC,GAAG,KAAK,OAAb,CAAjB,CAlBgB,CAoBhB;;AACA,SAAK,QAAL,GAAgB,KAAK,GAAL,IAAY,KAAK,YAAL,GAAoB,CAAhC,CAAhB;AAEA,SAAK,QAAL,CAAc,KAAK,IAAnB,IAA2B,CAA3B;AACA,SAAK,IAAL;AAEA,SAAK,IAAL,IAAa,KAAK,QAAL,CAAc,MAA3B,CA1BgB,CA0BmB;AACtC,GA3BM;AA6BP;;;;;;;AAKO,EAAA,cAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,CAAf,EAAwB;AACpB,QAAK,CAAC,IAAI,KAAK,YAAX,IAA6B,CAAC,IAAI,KAAK,QAAL,CAAc,MAApD,EAA6D;AACzD,aAAO,CAAP;AACH;;AAED,QAAI,EAAE,GAAG,KAAK,aAAL,CAAmB,KAAK,IAAL,GAAY,GAA/B,CAAT;;AACA,WAAO,KAAK,QAAL,CAAc,KAAK,aAAL,CAAmB,EAAE,GAAG,CAAxB,CAAd,CAAP;AACH,GAPM;AASP;;;;;;AAIO,EAAA,cAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACI,WAAO,KAAK,YAAL,IAAqB,KAAK,QAAL,CAAc,MAA1C;AACH,GAFM;AAIP;;;;;AAGO,EAAA,cAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,SAAK,OAAL,GAAe,CAAf;AACA,SAAK,QAAL,GAAgB,CAAhB;AACA,SAAK,YAAL,GAAoB,CAApB;AACA,SAAK,IAAL,GAAY,CAAZ;AACA,SAAK,GAAL,GAAW,CAAX;AACH,GANM;AAQP;;;;;;;AAKU,EAAA,cAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,CAAxB,EAAiC;AAC7B,QAAI,GAAG,GAAG,KAAK,QAAL,CAAc,MAAxB;AACA,WAAO,CAAE,CAAC,GAAG,GAAL,GAAY,GAAb,IAAoB,GAA3B;AACH,GAHS;;AAId,SAAA,cAAA;AAAC,CApGD,EAAA","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { PrecisionDate } from \"./precisionDate\";\r\n\r\n/**\r\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\r\n */\r\nexport class PerformanceMonitor {\r\n\r\n    private _enabled: boolean = true;\r\n    private _rollingFrameTime: RollingAverage;\r\n    private _lastFrameTimeMs: Nullable<number>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param frameSampleSize The number of samples required to saturate the sliding window\r\n     */\r\n    constructor(frameSampleSize: number = 30) {\r\n        this._rollingFrameTime = new RollingAverage(frameSampleSize);\r\n    }\r\n\r\n    /**\r\n     * Samples current frame\r\n     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\r\n     */\r\n    public sampleFrame(timeMs: number = PrecisionDate.Now) {\r\n        if (!this._enabled) { return; }\r\n\r\n        if (this._lastFrameTimeMs != null) {\r\n            let dt = timeMs - this._lastFrameTimeMs;\r\n            this._rollingFrameTime.add(dt);\r\n        }\r\n\r\n        this._lastFrameTimeMs = timeMs;\r\n    }\r\n\r\n    /**\r\n     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFrameTime(): number {\r\n        return this._rollingFrameTime.average;\r\n    }\r\n\r\n    /**\r\n     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFrameTimeVariance(): number {\r\n        return this._rollingFrameTime.variance;\r\n    }\r\n\r\n    /**\r\n     * Returns the frame time of the most recent frame\r\n     */\r\n    public get instantaneousFrameTime(): number {\r\n        return this._rollingFrameTime.history(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\r\n     */\r\n    public get averageFPS(): number {\r\n        return 1000.0 / this._rollingFrameTime.average;\r\n    }\r\n\r\n    /**\r\n     * Returns the average framerate in frames per second using the most recent frame time\r\n     */\r\n    public get instantaneousFPS(): number {\r\n        let history = this._rollingFrameTime.history(0);\r\n\r\n        if (history === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return 1000.0 / history;\r\n    }\r\n\r\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     */\r\n    public get isSaturated(): boolean {\r\n        return this._rollingFrameTime.isSaturated();\r\n    }\r\n\r\n    /**\r\n     * Enables contributions to the sliding window sample set\r\n     */\r\n    public enable() {\r\n        this._enabled = true;\r\n    }\r\n\r\n    /**\r\n     * Disables contributions to the sliding window sample set\r\n     * Samples will not be interpolated over the disabled period\r\n     */\r\n    public disable() {\r\n        this._enabled = false;\r\n        //clear last sample to avoid interpolating over the disabled period when next enabled\r\n        this._lastFrameTimeMs = null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if sampling is enabled\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    /**\r\n     * Resets performance monitor\r\n     */\r\n    public reset() {\r\n        //clear last sample to avoid interpolating over the disabled period when next enabled\r\n        this._lastFrameTimeMs = null;\r\n        //wipe record\r\n        this._rollingFrameTime.reset();\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * RollingAverage\r\n *\r\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\r\n */\r\nexport class RollingAverage {\r\n\r\n    /**\r\n     * Current average\r\n     */\r\n    public average: number;\r\n    /**\r\n     * Current variance\r\n     */\r\n    public variance: number;\r\n\r\n    protected _samples: Array<number>;\r\n    protected _sampleCount: number;\r\n    protected _pos: number;\r\n    protected _m2: number; //sum of squares of differences from the (current) mean\r\n\r\n    /**\r\n     * constructor\r\n     * @param length The number of samples required to saturate the sliding window\r\n     */\r\n    constructor(length: number) {\r\n        this._samples = new Array<number>(length);\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Adds a sample to the sample set\r\n     * @param v The sample value\r\n     */\r\n    public add(v: number) {\r\n        //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\r\n        let delta: number;\r\n\r\n        //we need to check if we've already wrapped round\r\n        if (this.isSaturated()) {\r\n            //remove bottom of stack from mean\r\n            let bottomValue = this._samples[this._pos];\r\n            delta = bottomValue - this.average;\r\n            this.average -= delta / (this._sampleCount - 1);\r\n            this._m2 -= delta * (bottomValue - this.average);\r\n        } else {\r\n            this._sampleCount++;\r\n        }\r\n\r\n        //add new value to mean\r\n        delta = v - this.average;\r\n        this.average += delta / (this._sampleCount);\r\n        this._m2 += delta * (v - this.average);\r\n\r\n        //set the new variance\r\n        this.variance = this._m2 / (this._sampleCount - 1);\r\n\r\n        this._samples[this._pos] = v;\r\n        this._pos++;\r\n\r\n        this._pos %= this._samples.length; //positive wrap around\r\n    }\r\n\r\n    /**\r\n     * Returns previously added values or null if outside of history or outside the sliding window domain\r\n     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\r\n     * @return Value previously recorded with add() or null if outside of range\r\n     */\r\n    public history(i: number): number {\r\n        if ((i >= this._sampleCount) || (i >= this._samples.length)) {\r\n            return 0;\r\n        }\r\n\r\n        let i0 = this._wrapPosition(this._pos - 1.0);\r\n        return this._samples[this._wrapPosition(i0 - i)];\r\n    }\r\n\r\n    /**\r\n     * Returns true if enough samples have been taken to completely fill the sliding window\r\n     * @return true if sample-set saturated\r\n     */\r\n    public isSaturated(): boolean {\r\n        return this._sampleCount >= this._samples.length;\r\n    }\r\n\r\n    /**\r\n     * Resets the rolling average (equivalent to 0 samples taken so far)\r\n     */\r\n    public reset() {\r\n        this.average = 0;\r\n        this.variance = 0;\r\n        this._sampleCount = 0;\r\n        this._pos = 0;\r\n        this._m2 = 0;\r\n    }\r\n\r\n    /**\r\n     * Wraps a value around the sample range boundaries\r\n     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\r\n     * @return Wrapped position in sample range\r\n     */\r\n    protected _wrapPosition(i: number): number {\r\n        let max = this._samples.length;\r\n        return ((i % max) + max) % max;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}