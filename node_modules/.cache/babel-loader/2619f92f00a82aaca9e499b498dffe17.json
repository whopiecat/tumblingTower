{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Tools } from \"../Misc/tools\";\nimport { Observable } from \"../Misc/observable\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Engine } from \"../Engines/engine\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { TransformNode } from \"../Meshes/transformNode\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\nimport { _MeshCollisionData } from '../Collisions/meshCollisionData';\nimport { _DevTools } from '../Misc/devTools';\nimport { extractMinAndMax } from '../Maths/math.functions';\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { Epsilon } from '../Maths/math.constants';\nimport { Axis } from '../Maths/math.axis';\nimport { _TypeStore } from '../Misc/typeStore';\n/** @hidden */\n\nvar _FacetDataStorage =\n/** @class */\nfunction () {\n  function _FacetDataStorage() {\n    this.facetNb = 0; // facet number\n\n    this.partitioningSubdivisions = 10; // number of subdivisions per axis in the partioning space\n\n    this.partitioningBBoxRatio = 1.01; // the partioning array space is by default 1% bigger than the bounding box\n\n    this.facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n\n    this.facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n\n    this.bbSize = Vector3.Zero(); // bbox size approximated for facet data\n\n    this.subDiv = {\n      max: 1,\n      X: 1,\n      Y: 1,\n      Z: 1\n    };\n    this.facetDepthSort = false; // is the facet depth sort to be computed\n\n    this.facetDepthSortEnabled = false; // is the facet depth sort initialized\n  }\n\n  return _FacetDataStorage;\n}();\n/**\r\n * @hidden\r\n **/\n\n\nvar _InternalAbstractMeshDataInfo =\n/** @class */\nfunction () {\n  function _InternalAbstractMeshDataInfo() {\n    this._hasVertexAlpha = false;\n    this._useVertexColors = true;\n    this._numBoneInfluencers = 4;\n    this._applyFog = true;\n    this._receiveShadows = false;\n    this._facetData = new _FacetDataStorage();\n    this._visibility = 1.0;\n    this._skeleton = null;\n    this._layerMask = 0x0FFFFFFF;\n    this._computeBonesUsingShaders = true;\n    this._isActive = false;\n    this._onlyForInstances = false;\n    this._isActiveIntermediate = false;\n    this._onlyForInstancesIntermediate = false;\n    this._actAsRegularMesh = false;\n    this._currentLOD = null;\n    this._currentLODIsUpToDate = false;\n  }\n\n  return _InternalAbstractMeshDataInfo;\n}();\n/**\r\n * Class used to store all common mesh properties\r\n */\n\n\nvar AbstractMesh =\n/** @class */\nfunction (_super) {\n  __extends(AbstractMesh, _super); // Constructor\n\n  /**\r\n   * Creates a new AbstractMesh\r\n   * @param name defines the name of the mesh\r\n   * @param scene defines the hosting scene\r\n   */\n\n\n  function AbstractMesh(name, scene) {\n    if (scene === void 0) {\n      scene = null;\n    }\n\n    var _this = _super.call(this, name, scene, false) || this; // Internal data\n\n    /** @hidden */\n\n\n    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\n\n    _this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY; // Events\n\n    /**\r\n    * An event triggered when this mesh collides with another one\r\n    */\n\n    _this.onCollideObservable = new Observable();\n    /**\r\n    * An event triggered when the collision's position changes\r\n    */\n\n    _this.onCollisionPositionChangeObservable = new Observable();\n    /**\r\n    * An event triggered when material is changed\r\n    */\n\n    _this.onMaterialChangedObservable = new Observable(); // Properties\n\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\n\n    _this.definedFacingForward = true;\n    /** @hidden */\n\n    _this._occlusionQuery = null;\n    /** @hidden */\n\n    _this._renderingGroup = null;\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\r\n     */\n\n    _this.alphaIndex = Number.MAX_VALUE;\n    /**\r\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\r\n     */\n\n    _this.isVisible = true;\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\n\n    _this.isPickable = true;\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\n\n    _this.showSubMeshesBoundingBox = false;\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     */\n\n    _this.isBlocker = false;\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\n\n    _this.enablePointerMoveEvents = false;\n    _this._renderingGroupId = 0;\n    _this._material = null;\n    /** Defines color to use when rendering outline */\n\n    _this.outlineColor = Color3.Red();\n    /** Define width to use when rendering outline */\n\n    _this.outlineWidth = 0.02;\n    /** Defines color to use when rendering overlay */\n\n    _this.overlayColor = Color3.Red();\n    /** Defines alpha to use when rendering overlay */\n\n    _this.overlayAlpha = 0.5;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\n\n    _this.useOctreeForRenderingSelection = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\n\n    _this.useOctreeForPicking = true;\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\n\n    _this.useOctreeForCollisions = true;\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\n\n    _this.alwaysSelectAsActiveMesh = false;\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\n\n    _this.doNotSyncBoundingInfo = false;\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n     */\n\n    _this.actionManager = null; // Collisions\n\n    _this._meshCollisionData = new _MeshCollisionData();\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n\n    _this.ellipsoidOffset = new Vector3(0, 0, 0); // Edges\n\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\n\n    _this.edgesWidth = 1;\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\n\n    _this.edgesColor = new Color4(1, 0, 0, 1);\n    /** @hidden */\n\n    _this._edgesRenderer = null;\n    /** @hidden */\n\n    _this._masterMesh = null;\n    /** @hidden */\n\n    _this._boundingInfo = null;\n    /** @hidden */\n\n    _this._renderId = 0;\n    /** @hidden */\n\n    _this._intersectionsInProgress = new Array();\n    /** @hidden */\n\n    _this._unIndexed = false;\n    /** @hidden */\n\n    _this._lightSources = new Array(); // Loading properties\n\n    /** @hidden */\n\n    _this._waitingData = {\n      lods: null,\n      actions: null,\n      freezeWorldMatrix: null\n    };\n    /** @hidden */\n\n    _this._bonesTransformMatrices = null;\n    /** @hidden */\n\n    _this._transformMatrixTexture = null;\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\n\n    _this.onRebuildObservable = new Observable();\n\n    _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n      if (collidedMesh === void 0) {\n        collidedMesh = null;\n      }\n\n      newPosition.subtractToRef(_this._meshCollisionData._oldPositionForCollisions, _this._meshCollisionData._diffPositionForCollisions);\n\n      if (_this._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\n        _this.position.addInPlace(_this._meshCollisionData._diffPositionForCollisions);\n      }\n\n      if (collidedMesh) {\n        _this.onCollideObservable.notifyObservers(collidedMesh);\n      }\n\n      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);\n    };\n\n    _this.getScene().addMesh(_this);\n\n    _this._resyncLightSources();\n\n    return _this;\n  }\n\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_NONE\", {\n    /**\r\n     * No billboard\r\n     */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_X\", {\n    /** Billboard on X axis */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_X;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Y\", {\n    /** Billboard on Y axis */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_Y;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Z\", {\n    /** Billboard on Z axis */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_Z;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_ALL\", {\n    /** Billboard on all axes */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_ALL;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_USE_POSITION\", {\n    /** Billboard on using position instead of orientation */\n    get: function () {\n      return TransformNode.BILLBOARDMODE_USE_POSITION;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetNb\", {\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.facetNb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningSubdivisions\", {\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partioning space\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\n    },\n    set: function (nb) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"partitioningBBoxRatio\", {\n    /**\r\n     * The ratio (float) to apply to the bouding box size to set to the partioning space.\r\n     * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\n    },\n    set: function (ratio) {\n      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"mustDepthSortFacets\", {\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\n    },\n    set: function (sort) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"facetDepthSortFrom\", {\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\n    },\n    set: function (location) {\n      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isFacetDataEnabled\", {\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._updateNonUniformScalingState = function (value) {\n    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {\n      return false;\n    }\n\n    this._markSubMeshesAsMiscDirty();\n\n    return true;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"onCollide\", {\n    /** Set a function to call when this mesh collides with another one */\n    set: function (callback) {\n      if (this._meshCollisionData._onCollideObserver) {\n        this.onCollideObservable.remove(this._meshCollisionData._onCollideObserver);\n      }\n\n      this._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"onCollisionPositionChange\", {\n    /** Set a function to call when the collision's position changes */\n    set: function (callback) {\n      if (this._meshCollisionData._onCollisionPositionChangeObserver) {\n        this.onCollisionPositionChangeObservable.remove(this._meshCollisionData._onCollisionPositionChangeObserver);\n      }\n\n      this._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"visibility\", {\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._visibility;\n    },\n\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._visibility === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._visibility = value;\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"renderingGroupId\", {\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\n    get: function () {\n      return this._renderingGroupId;\n    },\n    set: function (value) {\n      this._renderingGroupId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"material\", {\n    /** Gets or sets current material */\n    get: function () {\n      return this._material;\n    },\n    set: function (value) {\n      if (this._material === value) {\n        return;\n      } // remove from material mesh map id needed\n\n\n      if (this._material && this._material.meshMap) {\n        this._material.meshMap[this.uniqueId] = undefined;\n      }\n\n      this._material = value;\n\n      if (value && value.meshMap) {\n        value.meshMap[this.uniqueId] = this;\n      }\n\n      if (this.onMaterialChangedObservable.hasObservers()) {\n        this.onMaterialChangedObservable.notifyObservers(this);\n      }\n\n      if (!this.subMeshes) {\n        return;\n      }\n\n      this._unBindEffect();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"receiveShadows\", {\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/babylon101/shadows\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._receiveShadows;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._receiveShadows = value;\n\n      this._markSubMeshesAsLightDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasVertexAlpha\", {\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._hasVertexAlpha;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\n\n      this._markSubMeshesAsAttributesDirty();\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"useVertexColors\", {\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._useVertexColors;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._useVertexColors = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"computeBonesUsingShaders\", {\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"numBoneInfluencers\", {\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._numBoneInfluencers;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"applyFog\", {\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._applyFog;\n    },\n    set: function (value) {\n      if (this._internalAbstractMeshDataInfo._applyFog === value) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._applyFog = value;\n\n      this._markSubMeshesAsMiscDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"layerMask\", {\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures\r\n     */\n    get: function () {\n      return this._internalAbstractMeshDataInfo._layerMask;\n    },\n    set: function (value) {\n      if (value === this._internalAbstractMeshDataInfo._layerMask) {\n        return;\n      }\n\n      this._internalAbstractMeshDataInfo._layerMask = value;\n\n      this._resyncLightSources();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionMask\", {\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\n    get: function () {\n      return this._meshCollisionData._collisionMask;\n    },\n    set: function (mask) {\n      this._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionResponse\", {\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\n    get: function () {\n      return this._meshCollisionData._collisionResponse;\n    },\n    set: function (response) {\n      this._meshCollisionData._collisionResponse = response;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collisionGroup\", {\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\n    get: function () {\n      return this._meshCollisionData._collisionGroup;\n    },\n    set: function (mask) {\n      this._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"surroundingMeshes\", {\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\n    get: function () {\n      return this._meshCollisionData._surroundingMeshes;\n    },\n    set: function (meshes) {\n      this._meshCollisionData._surroundingMeshes = meshes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"lightSources\", {\n    /** Gets the list of lights affecting that mesh */\n    get: function () {\n      return this._lightSources;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"_positions\", {\n    /** @hidden */\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"skeleton\", {\n    get: function () {\n      return this._internalAbstractMeshDataInfo._skeleton;\n    },\n\n    /**\r\n     * Gets or sets a skeleton to apply skining transformations\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\n    set: function (value) {\n      var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n      if (skeleton && skeleton.needInitialSkinMatrix) {\n        skeleton._unregisterMeshWithPoseMatrix(this);\n      }\n\n      if (value && value.needInitialSkinMatrix) {\n        value._registerMeshWithPoseMatrix(this);\n      }\n\n      this._internalAbstractMeshDataInfo._skeleton = value;\n\n      if (!this._internalAbstractMeshDataInfo._skeleton) {\n        this._bonesTransformMatrices = null;\n      }\n\n      this._markSubMeshesAsAttributesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the string \"AbstractMesh\"\r\n   * @returns \"AbstractMesh\"\r\n   */\n\n  AbstractMesh.prototype.getClassName = function () {\n    return \"AbstractMesh\";\n  };\n  /**\r\n   * Gets a string representation of the current mesh\r\n   * @param fullDetails defines a boolean indicating if full details must be included\r\n   * @returns a string representation of the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.toString = function (fullDetails) {\n    var ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\n    ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n    var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n\n    if (skeleton) {\n      ret += \", skeleton: \" + skeleton.name;\n    }\n\n    if (fullDetails) {\n      ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\n      ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\n    }\n\n    return ret;\n  };\n  /**\r\n   * @hidden\r\n   */\n\n\n  AbstractMesh.prototype._getEffectiveParent = function () {\n    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh;\n    }\n\n    return _super.prototype._getEffectiveParent.call(this);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getActionManagerForTrigger = function (trigger, initialCall) {\n    if (initialCall === void 0) {\n      initialCall = true;\n    }\n\n    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\n      if (trigger) {\n        if (this.actionManager.hasSpecificTrigger(trigger)) {\n          return this.actionManager;\n        }\n      } else {\n        return this.actionManager;\n      }\n    }\n\n    if (!this.parent) {\n      return null;\n    }\n\n    return this.parent._getActionManagerForTrigger(trigger, false);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._rebuild = function () {\n    this.onRebuildObservable.notifyObservers(this);\n\n    if (this._occlusionQuery) {\n      this._occlusionQuery = null;\n    }\n\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      subMesh._rebuild();\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._resyncLightSources = function () {\n    this._lightSources.length = 0;\n\n    for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {\n      var light = _a[_i];\n\n      if (!light.isEnabled()) {\n        continue;\n      }\n\n      if (light.canAffectMesh(this)) {\n        this._lightSources.push(light);\n      }\n    }\n\n    this._markSubMeshesAsLightDirty();\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._resyncLightSource = function (light) {\n    var isIn = light.isEnabled() && light.canAffectMesh(this);\n\n    var index = this._lightSources.indexOf(light);\n\n    var removed = false;\n\n    if (index === -1) {\n      if (!isIn) {\n        return;\n      }\n\n      this._lightSources.push(light);\n    } else {\n      if (isIn) {\n        return;\n      }\n\n      removed = true;\n\n      this._lightSources.splice(index, 1);\n    }\n\n    this._markSubMeshesAsLightDirty(removed);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unBindEffect = function () {\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n      subMesh.setEffect(null);\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._removeLightSource = function (light, dispose) {\n    var index = this._lightSources.indexOf(light);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._lightSources.splice(index, 1);\n\n    this._markSubMeshesAsLightDirty(dispose);\n  };\n\n  AbstractMesh.prototype._markSubMeshesAsDirty = function (func) {\n    if (!this.subMeshes) {\n      return;\n    }\n\n    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n      var subMesh = _a[_i];\n\n      if (subMesh._materialDefines) {\n        func(subMesh._materialDefines);\n      }\n    }\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsLightDirty = function (dispose) {\n    if (dispose === void 0) {\n      dispose = false;\n    }\n\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsLightDirty(dispose);\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsAttributesDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsAttributesDirty();\n    });\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._markSubMeshesAsMiscDirty = function () {\n    this._markSubMeshesAsDirty(function (defines) {\n      return defines.markAsMiscDirty();\n    });\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"scaling\", {\n    /**\r\n    * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)\r\n    */\n    get: function () {\n      return this._scaling;\n    },\n    set: function (newScaling) {\n      this._scaling = newScaling;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"isBlocked\", {\n    // Methods\n\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns the mesh itself by default. Implemented by child classes\r\n   * @param camera defines the camera to use to pick the right LOD level\r\n   * @returns the currentAbstractMesh\r\n   */\n\n  AbstractMesh.prototype.getLOD = function (camera) {\n    return this;\n  };\n  /**\r\n   * Returns 0 by default. Implemented by child classes\r\n   * @returns an integer\r\n   */\n\n\n  AbstractMesh.prototype.getTotalVertices = function () {\n    return 0;\n  };\n  /**\r\n   * Returns a positive integer : the total number of indices in this mesh geometry.\r\n   * @returns the numner of indices or zero if the mesh has no geometry.\r\n   */\n\n\n  AbstractMesh.prototype.getTotalIndices = function () {\n    return 0;\n  };\n  /**\r\n   * Returns null by default. Implemented by child classes\r\n   * @returns null\r\n   */\n\n\n  AbstractMesh.prototype.getIndices = function () {\n    return null;\n  };\n  /**\r\n   * Returns the array of the requested vertex data kind. Implemented by child classes\r\n   * @param kind defines the vertex data kind to use\r\n   * @returns null\r\n   */\n\n\n  AbstractMesh.prototype.getVerticesData = function (kind) {\n    return null;\n  };\n  /**\r\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n   * Note that a new underlying VertexBuffer object is created each call.\r\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n   * @param kind defines vertex data kind:\r\n   * * VertexBuffer.PositionKind\r\n   * * VertexBuffer.UVKind\r\n   * * VertexBuffer.UV2Kind\r\n   * * VertexBuffer.UV3Kind\r\n   * * VertexBuffer.UV4Kind\r\n   * * VertexBuffer.UV5Kind\r\n   * * VertexBuffer.UV6Kind\r\n   * * VertexBuffer.ColorKind\r\n   * * VertexBuffer.MatricesIndicesKind\r\n   * * VertexBuffer.MatricesIndicesExtraKind\r\n   * * VertexBuffer.MatricesWeightsKind\r\n   * * VertexBuffer.MatricesWeightsExtraKind\r\n   * @param data defines the data source\r\n   * @param updatable defines if the data must be flagged as updatable (or static)\r\n   * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n    return this;\n  };\n  /**\r\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n   * If the mesh has no geometry, it is simply returned as it is.\r\n   * @param kind defines vertex data kind:\r\n   * * VertexBuffer.PositionKind\r\n   * * VertexBuffer.UVKind\r\n   * * VertexBuffer.UV2Kind\r\n   * * VertexBuffer.UV3Kind\r\n   * * VertexBuffer.UV4Kind\r\n   * * VertexBuffer.UV5Kind\r\n   * * VertexBuffer.UV6Kind\r\n   * * VertexBuffer.ColorKind\r\n   * * VertexBuffer.MatricesIndicesKind\r\n   * * VertexBuffer.MatricesIndicesExtraKind\r\n   * * VertexBuffer.MatricesWeightsKind\r\n   * * VertexBuffer.MatricesWeightsExtraKind\r\n   * @param data defines the data source\r\n   * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n   * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n    return this;\n  };\n  /**\r\n   * Sets the mesh indices,\r\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n   * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n   * @param totalVertices Defines the total number of vertices\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setIndices = function (indices, totalVertices) {\n    return this;\n  };\n  /**\r\n   * Gets a boolean indicating if specific vertex data is present\r\n   * @param kind defines the vertex data kind to use\r\n   * @returns true is data kind is present\r\n   */\n\n\n  AbstractMesh.prototype.isVerticesDataPresent = function (kind) {\n    return false;\n  };\n  /**\r\n   * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n   * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n   * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n   * @returns a BoundingInfo\r\n   */\n\n\n  AbstractMesh.prototype.getBoundingInfo = function () {\n    if (this._masterMesh) {\n      return this._masterMesh.getBoundingInfo();\n    }\n\n    if (!this._boundingInfo) {\n      // this._boundingInfo is being created here\n      this._updateBoundingInfo();\n    } // cannot be null.\n\n\n    return this._boundingInfo;\n  };\n  /**\r\n   * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n   * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n   * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n   * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n    if (includeDescendants === void 0) {\n      includeDescendants = true;\n    }\n\n    if (ignoreRotation === void 0) {\n      ignoreRotation = false;\n    }\n\n    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);\n  };\n  /**\r\n   * Overwrite the current bounding info\r\n   * @param boundingInfo defines the new bounding info\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.setBoundingInfo = function (boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"useBones\", {\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\n    get: function () {\n      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @hidden */\n\n  AbstractMesh.prototype._preActivate = function () {};\n  /** @hidden */\n\n\n  AbstractMesh.prototype._preActivateForIntermediateRendering = function (renderId) {};\n  /** @hidden */\n\n\n  AbstractMesh.prototype._activate = function (renderId, intermediateRendering) {\n    this._renderId = renderId;\n    return true;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._postActivate = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._freeze = function () {// Do nothing\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._unFreeze = function () {// Do nothing\n  };\n  /**\r\n   * Gets the current world matrix\r\n   * @returns a Matrix\r\n   */\n\n\n  AbstractMesh.prototype.getWorldMatrix = function () {\n    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\n      return this._masterMesh.getWorldMatrix();\n    }\n\n    return _super.prototype.getWorldMatrix.call(this);\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getWorldMatrixDeterminant = function () {\n    if (this._masterMesh) {\n      return this._masterMesh._getWorldMatrixDeterminant();\n    }\n\n    return _super.prototype._getWorldMatrixDeterminant.call(this);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"isAnInstance\", {\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasInstances\", {\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"hasThinInstances\", {\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  }); // ================================== Point of View Movement =================================\n\n  /**\r\n   * Perform relative position change from the point of view of behind the front of the mesh.\r\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param amountRight defines the distance on the right axis\r\n   * @param amountUp defines the distance on the up axis\r\n   * @param amountForward defines the distance on the forward axis\r\n   * @returns the current mesh\r\n   */\n\n  AbstractMesh.prototype.movePOV = function (amountRight, amountUp, amountForward) {\n    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n    return this;\n  };\n  /**\r\n   * Calculate relative position change from the point of view of behind the front of the mesh.\r\n   * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param amountRight defines the distance on the right axis\r\n   * @param amountUp defines the distance on the up axis\r\n   * @param amountForward defines the distance on the forward axis\r\n   * @returns the new displacement vector\r\n   */\n\n\n  AbstractMesh.prototype.calcMovePOV = function (amountRight, amountUp, amountForward) {\n    var rotMatrix = new Matrix();\n    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n    rotQuaternion.toRotationMatrix(rotMatrix);\n    var translationDelta = Vector3.Zero();\n    var defForwardMult = this.definedFacingForward ? -1 : 1;\n    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n    return translationDelta;\n  }; // ================================== Point of View Rotation =================================\n\n  /**\r\n   * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n   * Supports definition of mesh facing forward or backward\r\n   * @param flipBack defines the flip\r\n   * @param twirlClockwise defines the twirl\r\n   * @param tiltRight defines the tilt\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.rotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n    return this;\n  };\n  /**\r\n   * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n   * Supports definition of mesh facing forward or backward.\r\n   * @param flipBack defines the flip\r\n   * @param twirlClockwise defines the twirl\r\n   * @param tiltRight defines the tilt\r\n   * @returns the new rotation vector\r\n   */\n\n\n  AbstractMesh.prototype.calcRotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n    var defForwardMult = this.definedFacingForward ? 1 : -1;\n    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n  };\n  /**\r\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n   * This means the mesh underlying bounding box and sphere are recomputed.\r\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\n    if (applySkeleton === void 0) {\n      applySkeleton = false;\n    }\n\n    if (this._boundingInfo && this._boundingInfo.isLocked) {\n      return this;\n    }\n\n    this._refreshBoundingInfo(this._getPositionData(applySkeleton), null);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._refreshBoundingInfo = function (data, bias) {\n    if (data) {\n      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\n\n      if (this._boundingInfo) {\n        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n      } else {\n        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n      }\n    }\n\n    if (this.subMeshes) {\n      for (var index = 0; index < this.subMeshes.length; index++) {\n        this.subMeshes[index].refreshBoundingInfo(data);\n      }\n    }\n\n    this._updateBoundingInfo();\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._getPositionData = function (applySkeleton) {\n    var data = this.getVerticesData(VertexBuffer.PositionKind);\n\n    if (data && applySkeleton && this.skeleton) {\n      data = Tools.Slice(data);\n\n      this._generatePointsArray();\n\n      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n\n      if (matricesWeightsData && matricesIndicesData) {\n        var needExtras = this.numBoneInfluencers > 4;\n        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n        this.skeleton.prepare();\n        var skeletonMatrices = this.skeleton.getTransformMatrices(this);\n        var tempVector = TmpVectors.Vector3[0];\n        var finalMatrix = TmpVectors.Matrix[0];\n        var tempMatrix = TmpVectors.Matrix[1];\n        var matWeightIdx = 0;\n\n        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {\n          finalMatrix.reset();\n          var inf;\n          var weight;\n\n          for (inf = 0; inf < 4; inf++) {\n            weight = matricesWeightsData[matWeightIdx + inf];\n\n            if (weight > 0) {\n              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n              finalMatrix.addToSelf(tempMatrix);\n            }\n          }\n\n          if (needExtras) {\n            for (inf = 0; inf < 4; inf++) {\n              weight = matricesWeightsExtraData[matWeightIdx + inf];\n\n              if (weight > 0) {\n                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                finalMatrix.addToSelf(tempMatrix);\n              }\n            }\n          }\n\n          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n          tempVector.toArray(data, index);\n\n          if (this._positions) {\n            this._positions[index / 3].copyFrom(tempVector);\n          }\n        }\n      }\n    }\n\n    return data;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._updateBoundingInfo = function () {\n    var effectiveMesh = this._effectiveMesh;\n\n    if (this._boundingInfo) {\n      this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\n    } else {\n      this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\n    }\n\n    this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._updateSubMeshesBoundingInfo = function (matrix) {\n    if (!this.subMeshes) {\n      return this;\n    }\n\n    var count = this.subMeshes.length;\n\n    for (var subIndex = 0; subIndex < count; subIndex++) {\n      var subMesh = this.subMeshes[subIndex];\n\n      if (count > 1 || !subMesh.IsGlobal) {\n        subMesh.updateBoundingInfo(matrix);\n      }\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._afterComputeWorldMatrix = function () {\n    if (this.doNotSyncBoundingInfo) {\n      return;\n    } // Bounding info\n\n\n    this._updateBoundingInfo();\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"_effectiveMesh\", {\n    /** @hidden */\n    get: function () {\n      return this.skeleton && this.skeleton.overrideMesh || this;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n   * A mesh is in the frustum if its bounding box intersects the frustum\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @returns true if the mesh is in the frustum planes\r\n   */\n\n  AbstractMesh.prototype.isInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  };\n  /**\r\n   * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n   * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n   * @param frustumPlanes defines the frustum to test\r\n   * @returns true if the mesh is completely in the frustum planes\r\n   */\n\n\n  AbstractMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  };\n  /**\r\n   * True if the mesh intersects another mesh or a SolidParticle object\r\n   * @param mesh defines a target mesh or SolidParticle to test\r\n   * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n   * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  AbstractMesh.prototype.intersectsMesh = function (mesh, precise, includeDescendants) {\n    if (precise === void 0) {\n      precise = false;\n    }\n\n    if (!this._boundingInfo || !mesh._boundingInfo) {\n      return false;\n    }\n\n    if (this._boundingInfo.intersects(mesh._boundingInfo, precise)) {\n      return true;\n    }\n\n    if (includeDescendants) {\n      for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {\n        var child = _a[_i];\n\n        if (child.intersectsMesh(mesh, precise, true)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n   * @param point defines the point to test\r\n   * @returns true if there is an intersection\r\n   */\n\n\n  AbstractMesh.prototype.intersectsPoint = function (point) {\n    if (!this._boundingInfo) {\n      return false;\n    }\n\n    return this._boundingInfo.intersectsPoint(point);\n  };\n\n  Object.defineProperty(AbstractMesh.prototype, \"checkCollisions\", {\n    // Collisions\n\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n    get: function () {\n      return this._meshCollisionData._checkCollisions;\n    },\n    set: function (collisionEnabled) {\n      this._meshCollisionData._checkCollisions = collisionEnabled;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMesh.prototype, \"collider\", {\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\n    get: function () {\n      return this._meshCollisionData._collider;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Move the mesh using collision engine\r\n   * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n   * @param displacement defines the requested displacement vector\r\n   * @returns the current mesh\r\n   */\n\n  AbstractMesh.prototype.moveWithCollisions = function (displacement) {\n    var globalPosition = this.getAbsolutePosition();\n    globalPosition.addToRef(this.ellipsoidOffset, this._meshCollisionData._oldPositionForCollisions);\n    var coordinator = this.getScene().collisionCoordinator;\n\n    if (!this._meshCollisionData._collider) {\n      this._meshCollisionData._collider = coordinator.createCollider();\n    }\n\n    this._meshCollisionData._collider._radius = this.ellipsoid;\n    coordinator.getNewPosition(this._meshCollisionData._oldPositionForCollisions, displacement, this._meshCollisionData._collider, 3, this, this._onCollisionPositionChange, this.uniqueId);\n    return this;\n  }; // Collisions\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._collideForSubMesh = function (subMesh, transformMatrix, collider) {\n    this._generatePointsArray();\n\n    if (!this._positions) {\n      return this;\n    } // Transformation\n\n\n    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n      subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n      subMesh._lastColliderWorldVertices = [];\n      subMesh._trianglePlanes = [];\n      var start = subMesh.verticesStart;\n      var end = subMesh.verticesStart + subMesh.verticesCount;\n\n      for (var i = start; i < end; i++) {\n        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n      }\n    } // Collide\n\n\n    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this);\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._processCollisionsForSubMeshes = function (collider, transformMatrix) {\n    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\n\n    var len = subMeshes.length;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh._checkCollision(collider)) {\n        continue;\n      }\n\n      this._collideForSubMesh(subMesh, transformMatrix, collider);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._checkCollision = function (collider) {\n    // Bounding box test\n    if (!this._boundingInfo || !this._boundingInfo._checkCollision(collider)) {\n      return this;\n    } // Transformation matrix\n\n\n    var collisionsScalingMatrix = TmpVectors.Matrix[0];\n    var collisionsTransformMatrix = TmpVectors.Matrix[1];\n    Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\n    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\n\n    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\n\n    return this;\n  }; // Picking\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._generatePointsArray = function () {\n    return false;\n  };\n  /**\r\n   * Checks if the passed Ray intersects with the mesh\r\n   * @param ray defines the ray to use\r\n   * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n   * @returns the picking info\r\n   * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n   */\n\n\n  AbstractMesh.prototype.intersects = function (ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {\n    var _a;\n\n    if (onlyBoundingInfo === void 0) {\n      onlyBoundingInfo = false;\n    }\n\n    if (skipBoundingInfo === void 0) {\n      skipBoundingInfo = false;\n    }\n\n    var pickingInfo = new PickingInfo();\n    var intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? this.intersectionThreshold : 0;\n    var boundingInfo = this._boundingInfo;\n\n    if (!this.subMeshes || !boundingInfo) {\n      return pickingInfo;\n    }\n\n    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\n      return pickingInfo;\n    }\n\n    if (onlyBoundingInfo) {\n      pickingInfo.hit = skipBoundingInfo ? false : true;\n      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\n      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = 0;\n      return pickingInfo;\n    }\n\n    if (!this._generatePointsArray()) {\n      return pickingInfo;\n    }\n\n    var intersectInfo = null;\n\n    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\n\n    var len = subMeshes.length; // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\n    // if no submesh can be picked that way, then fallback to BBox picking\n\n    var anySubmeshSupportIntersect = false;\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index];\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        continue;\n      }\n\n      if (((_a = this.getIndices()) === null || _a === void 0 ? void 0 : _a.length) && (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2)) {\n        anySubmeshSupportIntersect = true;\n        break;\n      }\n    } // no sub mesh support intersection, fallback to BBox that has already be done\n\n\n    if (!anySubmeshSupportIntersect) {\n      pickingInfo.hit = true;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n      pickingInfo.subMeshId = -1;\n      return pickingInfo;\n    } // at least 1 submesh supports intersection, keep going\n\n\n    for (var index = 0; index < len; index++) {\n      var subMesh = subMeshes.data[index]; // Bounding test\n\n      if (len > 1 && !subMesh.canIntersects(ray)) {\n        continue;\n      }\n\n      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);\n\n      if (currentIntersectInfo) {\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.subMeshId = index;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    if (intersectInfo) {\n      // Get picked point\n      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.skeleton && this.skeleton.overrideMesh ? this.skeleton.overrideMesh.getWorldMatrix() : this.getWorldMatrix();\n      var worldOrigin = TmpVectors.Vector3[0];\n      var direction = TmpVectors.Vector3[1];\n      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\n      ray.direction.scaleToRef(intersectInfo.distance, direction);\n      var worldDirection = Vector3.TransformNormal(direction, world);\n      var pickedPoint = worldDirection.addInPlace(worldOrigin); // Return result\n\n      pickingInfo.hit = true;\n      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\n      pickingInfo.pickedPoint = pickedPoint;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.bu = intersectInfo.bu || 0;\n      pickingInfo.bv = intersectInfo.bv || 0;\n      pickingInfo.subMeshFaceId = intersectInfo.faceId;\n      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\n      pickingInfo.subMeshId = intersectInfo.subMeshId;\n      return pickingInfo;\n    }\n\n    return pickingInfo;\n  };\n  /**\r\n   * Clones the current mesh\r\n   * @param name defines the mesh name\r\n   * @param newParent defines the new mesh parent\r\n   * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n   * @returns the new mesh\r\n   */\n\n\n  AbstractMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n    return null;\n  };\n  /**\r\n   * Disposes all the submeshes of the current meshnp\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.releaseSubMeshes = function () {\n    if (this.subMeshes) {\n      while (this.subMeshes.length) {\n        this.subMeshes[0].dispose();\n      }\n    } else {\n      this.subMeshes = new Array();\n    }\n\n    return this;\n  };\n  /**\r\n   * Releases resources associated with this abstract mesh.\r\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n   */\n\n\n  AbstractMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n    var _this = this;\n\n    if (disposeMaterialAndTextures === void 0) {\n      disposeMaterialAndTextures = false;\n    }\n\n    var index; // mesh map release.\n\n    if (this._scene.useMaterialMeshMap) {\n      // remove from material mesh map id needed\n      if (this._material && this._material.meshMap) {\n        this._material.meshMap[this.uniqueId] = undefined;\n      }\n    } // Smart Array Retainers.\n\n\n    this.getScene().freeActiveMeshes();\n    this.getScene().freeRenderingGroups(); // Action manager\n\n    if (this.actionManager !== undefined && this.actionManager !== null) {\n      this.actionManager.dispose();\n      this.actionManager = null;\n    } // Skeleton\n\n\n    this._internalAbstractMeshDataInfo._skeleton = null;\n\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n\n      this._transformMatrixTexture = null;\n    } // Intersections in progress\n\n\n    for (index = 0; index < this._intersectionsInProgress.length; index++) {\n      var other = this._intersectionsInProgress[index];\n\n      var pos = other._intersectionsInProgress.indexOf(this);\n\n      other._intersectionsInProgress.splice(pos, 1);\n    }\n\n    this._intersectionsInProgress = []; // Lights\n\n    var lights = this.getScene().lights;\n    lights.forEach(function (light) {\n      var meshIndex = light.includedOnlyMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.includedOnlyMeshes.splice(meshIndex, 1);\n      }\n\n      meshIndex = light.excludedMeshes.indexOf(_this);\n\n      if (meshIndex !== -1) {\n        light.excludedMeshes.splice(meshIndex, 1);\n      } // Shadow generators\n\n\n      var generator = light.getShadowGenerator();\n\n      if (generator) {\n        var shadowMap = generator.getShadowMap();\n\n        if (shadowMap && shadowMap.renderList) {\n          meshIndex = shadowMap.renderList.indexOf(_this);\n\n          if (meshIndex !== -1) {\n            shadowMap.renderList.splice(meshIndex, 1);\n          }\n        }\n      }\n    }); // SubMeshes\n\n    if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\n      this.releaseSubMeshes();\n    } // Query\n\n\n    var engine = this.getScene().getEngine();\n\n    if (this._occlusionQuery) {\n      this.isOcclusionQueryInProgress = false;\n      engine.deleteQuery(this._occlusionQuery);\n      this._occlusionQuery = null;\n    } // Engine\n\n\n    engine.wipeCaches(); // Remove from scene\n\n    this.getScene().removeMesh(this);\n\n    if (disposeMaterialAndTextures) {\n      if (this.material) {\n        if (this.material.getClassName() === \"MultiMaterial\") {\n          this.material.dispose(false, true, true);\n        } else {\n          this.material.dispose(false, true);\n        }\n      }\n    }\n\n    if (!doNotRecurse) {\n      // Particles\n      for (index = 0; index < this.getScene().particleSystems.length; index++) {\n        if (this.getScene().particleSystems[index].emitter === this) {\n          this.getScene().particleSystems[index].dispose();\n          index--;\n        }\n      }\n    } // facet data\n\n\n    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\n      this.disableFacetData();\n    }\n\n    this.onAfterWorldMatrixUpdateObservable.clear();\n    this.onCollideObservable.clear();\n    this.onCollisionPositionChangeObservable.clear();\n    this.onRebuildObservable.clear();\n\n    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n  };\n  /**\r\n   * Adds the passed mesh as a child to the current mesh\r\n   * @param mesh defines the child mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.addChild = function (mesh) {\n    mesh.setParent(this);\n    return this;\n  };\n  /**\r\n   * Removes the passed mesh from the current mesh children list\r\n   * @param mesh defines the child mesh\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.removeChild = function (mesh) {\n    mesh.setParent(null);\n    return this;\n  }; // Facet data\n\n  /** @hidden */\n\n\n  AbstractMesh.prototype._initFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetNormals) {\n      data.facetNormals = new Array();\n    }\n\n    if (!data.facetPositions) {\n      data.facetPositions = new Array();\n    }\n\n    if (!data.facetPartitioning) {\n      data.facetPartitioning = new Array();\n    }\n\n    data.facetNb = this.getIndices().length / 3 | 0;\n    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n\n    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n\n    for (var f = 0; f < data.facetNb; f++) {\n      data.facetNormals[f] = Vector3.Zero();\n      data.facetPositions[f] = Vector3.Zero();\n    }\n\n    data.facetDataEnabled = true;\n    return this;\n  };\n  /**\r\n   * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n   * This method can be called within the render loop.\r\n   * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.updateFacetData = function () {\n    var data = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!data.facetDataEnabled) {\n      this._initFacetData();\n    }\n\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals = this.getVerticesData(VertexBuffer.NormalKind);\n    var bInfo = this.getBoundingInfo();\n\n    if (data.facetDepthSort && !data.facetDepthSortEnabled) {\n      // init arrays, matrix and sort function on first call\n      data.facetDepthSortEnabled = true;\n\n      if (indices instanceof Uint16Array) {\n        data.depthSortedIndices = new Uint16Array(indices);\n      } else if (indices instanceof Uint32Array) {\n        data.depthSortedIndices = new Uint32Array(indices);\n      } else {\n        var needs32bits = false;\n\n        for (var i = 0; i < indices.length; i++) {\n          if (indices[i] > 65535) {\n            needs32bits = true;\n            break;\n          }\n        }\n\n        if (needs32bits) {\n          data.depthSortedIndices = new Uint32Array(indices);\n        } else {\n          data.depthSortedIndices = new Uint16Array(indices);\n        }\n      }\n\n      data.facetDepthSortFunction = function (f1, f2) {\n        return f2.sqDistance - f1.sqDistance;\n      };\n\n      if (!data.facetDepthSortFrom) {\n        var camera = this.getScene().activeCamera;\n        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\n      }\n\n      data.depthSortedFacets = [];\n\n      for (var f = 0; f < data.facetNb; f++) {\n        var depthSortedFacet = {\n          ind: f * 3,\n          sqDistance: 0.0\n        };\n        data.depthSortedFacets.push(depthSortedFacet);\n      }\n\n      data.invertedMatrix = Matrix.Identity();\n      data.facetDepthSortOrigin = Vector3.Zero();\n    }\n\n    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\n    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\n    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\n    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\n    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\n    data.subDiv.max = data.partitioningSubdivisions;\n    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax); // adjust the number of subdivisions per axis\n\n    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax); // according to each bbox size per axis\n\n    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);\n    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\n\n    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\n    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z; // set the parameters for ComputeNormals()\n\n    data.facetParameters.facetNormals = this.getFacetLocalNormals();\n    data.facetParameters.facetPositions = this.getFacetLocalPositions();\n    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n    data.facetParameters.bInfo = bInfo;\n    data.facetParameters.bbSize = data.bbSize;\n    data.facetParameters.subDiv = data.subDiv;\n    data.facetParameters.ratio = this.partitioningBBoxRatio;\n    data.facetParameters.depthSort = data.facetDepthSort;\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      this.computeWorldMatrix(true);\n\n      this._worldMatrix.invertToRef(data.invertedMatrix);\n\n      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\n      data.facetParameters.distanceTo = data.facetDepthSortOrigin;\n    }\n\n    data.facetParameters.depthSortedFacets = data.depthSortedFacets;\n    VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\n\n    if (data.facetDepthSort && data.facetDepthSortEnabled) {\n      data.depthSortedFacets.sort(data.facetDepthSortFunction);\n      var l = data.depthSortedIndices.length / 3 | 0;\n\n      for (var f = 0; f < l; f++) {\n        var sind = data.depthSortedFacets[f].ind;\n        data.depthSortedIndices[f * 3] = indices[sind];\n        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];\n        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];\n      }\n\n      this.updateIndices(data.depthSortedIndices, undefined, true);\n    }\n\n    return this;\n  };\n  /**\r\n   * Returns the facetLocalNormals array.\r\n   * The normals are expressed in the mesh local spac\r\n   * @returns an array of Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalNormals = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetNormals) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetNormals;\n  };\n  /**\r\n   * Returns the facetLocalPositions array.\r\n   * The facet positions are expressed in the mesh local space\r\n   * @returns an array of Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPositions = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPositions) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPositions;\n  };\n  /**\r\n   * Returns the facetLocalPartioning array\r\n   * @returns an array of array of numbers\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetLocalPartitioning = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (!facetData.facetPartitioning) {\n      this.updateFacetData();\n    }\n\n    return facetData.facetPartitioning;\n  };\n  /**\r\n   * Returns the i-th facet position in the world system.\r\n   * This method allocates a new Vector3 per call\r\n   * @param i defines the facet index\r\n   * @returns a new Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetPosition = function (i) {\n    var pos = Vector3.Zero();\n    this.getFacetPositionToRef(i, pos);\n    return pos;\n  };\n  /**\r\n   * Sets the reference Vector3 with the i-th facet position in the world system\r\n   * @param i defines the facet index\r\n   * @param ref defines the target vector\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetPositionToRef = function (i, ref) {\n    var localPos = this.getFacetLocalPositions()[i];\n    var world = this.getWorldMatrix();\n    Vector3.TransformCoordinatesToRef(localPos, world, ref);\n    return this;\n  };\n  /**\r\n   * Returns the i-th facet normal in the world system.\r\n   * This method allocates a new Vector3 per call\r\n   * @param i defines the facet index\r\n   * @returns a new Vector3\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetNormal = function (i) {\n    var norm = Vector3.Zero();\n    this.getFacetNormalToRef(i, norm);\n    return norm;\n  };\n  /**\r\n   * Sets the reference Vector3 with the i-th facet normal in the world system\r\n   * @param i defines the facet index\r\n   * @param ref defines the target vector\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetNormalToRef = function (i, ref) {\n    var localNorm = this.getFacetLocalNormals()[i];\n    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n    return this;\n  };\n  /**\r\n   * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the array of facet indexes\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetsAtLocalCoordinates = function (x, y, z) {\n    var bInfo = this.getBoundingInfo();\n    var data = this._internalAbstractMeshDataInfo._facetData;\n    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);\n    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);\n    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);\n\n    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\n      return null;\n    }\n\n    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\n  };\n  /**\r\n   * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n   * @param projected sets as the (x,y,z) world projection on the facet\r\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the face index if found (or null instead)\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var world = this.getWorldMatrix();\n    var invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    var invVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n\n    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n\n    if (projected) {\n      // tranform the local computed projected vector to world coordinates\n      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n    }\n\n    return closest;\n  };\n  /**\r\n   * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n   * @param projected sets as the (x,y,z) local projection on the facet\r\n   * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n   * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n   * @param x defines x coordinate\r\n   * @param y defines y coordinate\r\n   * @param z defines z coordinate\r\n   * @returns the face index if found (or null instead)\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getClosestFacetAtLocalCoordinates = function (x, y, z, projected, checkFace, facing) {\n    if (checkFace === void 0) {\n      checkFace = false;\n    }\n\n    if (facing === void 0) {\n      facing = true;\n    }\n\n    var closest = null;\n    var tmpx = 0.0;\n    var tmpy = 0.0;\n    var tmpz = 0.0;\n    var d = 0.0; // tmp dot facet normal * facet position\n\n    var t0 = 0.0;\n    var projx = 0.0;\n    var projy = 0.0;\n    var projz = 0.0; // Get all the facets in the same partitioning block than (x, y, z)\n\n    var facetPositions = this.getFacetLocalPositions();\n    var facetNormals = this.getFacetLocalNormals();\n    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n\n    if (!facetsInBlock) {\n      return null;\n    } // Get the closest facet to (x, y, z)\n\n\n    var shortest = Number.MAX_VALUE; // init distance vars\n\n    var tmpDistance = shortest;\n    var fib; // current facet in the block\n\n    var norm; // current facet normal\n\n    var p0; // current facet barycenter position\n    // loop on all the facets in the current partitioning block\n\n    for (var idx = 0; idx < facetsInBlock.length; idx++) {\n      fib = facetsInBlock[idx];\n      norm = facetNormals[fib];\n      p0 = facetPositions[fib];\n      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n\n      if (!checkFace || checkFace && facing && d >= 0.0 || checkFace && !facing && d <= 0.0) {\n        // compute (x,y,z) projection on the facet = (projx, projy, projz)\n        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n        projx = x + norm.x * t0;\n        projy = y + norm.y * t0;\n        projz = z + norm.z * t0;\n        tmpx = projx - x;\n        tmpy = projy - y;\n        tmpz = projz - z;\n        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n\n        if (tmpDistance < shortest) {\n          // just keep the closest facet to (x, y, z)\n          shortest = tmpDistance;\n          closest = fib;\n\n          if (projected) {\n            projected.x = projx;\n            projected.y = projy;\n            projected.z = projz;\n          }\n        }\n      }\n    }\n\n    return closest;\n  };\n  /**\r\n   * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n   * @returns the parameters\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.getFacetDataParameters = function () {\n    return this._internalAbstractMeshDataInfo._facetData.facetParameters;\n  };\n  /**\r\n   * Disables the feature FacetData and frees the related memory\r\n   * @returns the current mesh\r\n   * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n   */\n\n\n  AbstractMesh.prototype.disableFacetData = function () {\n    var facetData = this._internalAbstractMeshDataInfo._facetData;\n\n    if (facetData.facetDataEnabled) {\n      facetData.facetDataEnabled = false;\n      facetData.facetPositions = new Array();\n      facetData.facetNormals = new Array();\n      facetData.facetPartitioning = new Array();\n      facetData.facetParameters = null;\n      facetData.depthSortedIndices = new Uint32Array(0);\n    }\n\n    return this;\n  };\n  /**\r\n   * Updates the AbstractMesh indices array\r\n   * @param indices defines the data source\r\n   * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n    if (gpuMemoryOnly === void 0) {\n      gpuMemoryOnly = false;\n    }\n\n    return this;\n  };\n  /**\r\n   * Creates new normals data for the mesh\r\n   * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.createNormals = function (updatable) {\n    var positions = this.getVerticesData(VertexBuffer.PositionKind);\n    var indices = this.getIndices();\n    var normals;\n\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      normals = this.getVerticesData(VertexBuffer.NormalKind);\n    } else {\n      normals = [];\n    }\n\n    VertexData.ComputeNormals(positions, indices, normals, {\n      useRightHandedSystem: this.getScene().useRightHandedSystem\n    });\n    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\n    return this;\n  };\n  /**\r\n   * Align the mesh with a normal\r\n   * @param normal defines the normal to use\r\n   * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n   * @returns the current mesh\r\n   */\n\n\n  AbstractMesh.prototype.alignWithNormal = function (normal, upDirection) {\n    if (!upDirection) {\n      upDirection = Axis.Y;\n    }\n\n    var axisX = TmpVectors.Vector3[0];\n    var axisZ = TmpVectors.Vector3[1];\n    Vector3.CrossToRef(upDirection, normal, axisZ);\n    Vector3.CrossToRef(normal, axisZ, axisX);\n\n    if (this.rotationQuaternion) {\n      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\n    } else {\n      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\n    }\n\n    return this;\n  };\n  /** @hidden */\n\n\n  AbstractMesh.prototype._checkOcclusionQuery = function () {\n    return false;\n  };\n  /**\r\n   * Disables the mesh edge rendering mode\r\n   * @returns the currentAbstractMesh\r\n   */\n\n\n  AbstractMesh.prototype.disableEdgesRendering = function () {\n    throw _DevTools.WarnImport(\"EdgesRenderer\");\n  };\n  /**\r\n   * Enables the edge rendering mode on the mesh.\r\n   * This mode makes the mesh edges visible\r\n   * @param epsilon defines the maximal distance between two angles to detect a face\r\n   * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n   * @param options options to the edge renderer\r\n   * @returns the currentAbstractMesh\r\n   * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n   */\n\n\n  AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n    throw _DevTools.WarnImport(\"EdgesRenderer\");\n  };\n  /**\r\n   * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n   * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n   */\n\n\n  AbstractMesh.prototype.getConnectedParticleSystems = function () {\n    var _this = this;\n\n    return this._scene.particleSystems.filter(function (particleSystem) {\n      return particleSystem.emitter === _this;\n    });\n  };\n  /** No occlusion */\n\n\n  AbstractMesh.OCCLUSION_TYPE_NONE = 0;\n  /** Occlusion set to optimisitic */\n\n  AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;\n  /** Occlusion set to strict */\n\n  AbstractMesh.OCCLUSION_TYPE_STRICT = 2;\n  /** Use an accurante occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\n  /** Use a conservative occlusion algorithm */\n\n  AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\n  /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n   *  Test order :\r\n   *  Is the bounding sphere outside the frustum ?\r\n   *  If not, are the bounding box vertices outside the frustum ?\r\n   *  It not, then the cullable object is in the frustum.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;\n  /** Culling strategy : Bounding Sphere Only.\r\n   *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n   *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n   *  Test : is the bounding sphere outside the frustum ?\r\n   *  If not, then the cullable object is in the frustum.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\n  /** Culling strategy : Optimistic Inclusion.\r\n   *  This in an inclusion test first, then the standard exclusion test.\r\n   *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n   *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n   *  Anyway, it's as accurate as the standard strategy.\r\n   *  Test :\r\n   *  Is the cullable object bounding sphere center in the frustum ?\r\n   *  If not, apply the default culling strategy.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\n  /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n   *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n   *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n   *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n   *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n   *  Test :\r\n   *  Is the cullable object bounding sphere center in the frustum ?\r\n   *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n   */\n\n  AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\n  return AbstractMesh;\n}(TransformNode);\n\nexport { AbstractMesh };\n_TypeStore.RegisteredTypes[\"BABYLON.AbstractMesh\"] = AbstractMesh;","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/abstractMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, TmpVectors, Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { VertexData, IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport { ICullable, BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { IEdgesRenderer } from \"../Rendering/edgesRenderer\";\r\nimport { SolidParticle } from \"../Particles/solidParticle\";\r\n\r\nimport { AbstractActionManager } from '../Actions/abstractActionManager';\r\nimport { _MeshCollisionData } from '../Collisions/meshCollisionData';\r\nimport { _DevTools } from '../Misc/devTools';\r\nimport { RawTexture } from '../Materials/Textures/rawTexture';\r\nimport { extractMinAndMax } from '../Maths/math.functions';\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { Epsilon } from '../Maths/math.constants';\r\nimport { Plane } from '../Maths/math.plane';\r\nimport { Axis } from '../Maths/math.axis';\r\nimport { IParticleSystem } from '../Particles/IParticleSystem';\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\ndeclare type RenderingGroup = import(\"../Rendering/renderingGroup\").RenderingGroup;\r\ndeclare type IEdgesRendererOptions = import(\"../Rendering/edgesRenderer\").IEdgesRendererOptions;\r\n\r\n/** @hidden */\r\nclass _FacetDataStorage {\r\n    // facetData private properties\r\n    public facetPositions: Vector3[];             // facet local positions\r\n    public facetNormals: Vector3[];               // facet local normals\r\n    public facetPartitioning: number[][];         // partitioning array of facet index arrays\r\n    public facetNb: number = 0;                   // facet number\r\n    public partitioningSubdivisions: number = 10; // number of subdivisions per axis in the partioning space\r\n    public partitioningBBoxRatio: number = 1.01;  // the partioning array space is by default 1% bigger than the bounding box\r\n    public facetDataEnabled: boolean = false;     // is the facet data feature enabled on this mesh ?\r\n    public facetParameters: any = {};             // keep a reference to the object parameters to avoid memory re-allocation\r\n    public bbSize: Vector3 = Vector3.Zero();      // bbox size approximated for facet data\r\n    public subDiv = {                             // actual number of subdivisions per axis for ComputeNormals()\r\n        max: 1,\r\n        X: 1,\r\n        Y: 1,\r\n        Z: 1\r\n    };\r\n\r\n    public facetDepthSort: boolean = false;                           // is the facet depth sort to be computed\r\n    public facetDepthSortEnabled: boolean = false;                    // is the facet depth sort initialized\r\n    public depthSortedIndices: IndicesArray;                          // copy of the indices array to store them once sorted\r\n    public depthSortedFacets: { ind: number, sqDistance: number }[];    // array of depth sorted facets\r\n    public facetDepthSortFunction: (f1: { ind: number, sqDistance: number }, f2: { ind: number, sqDistance: number }) => number;  // facet depth sort function\r\n    public facetDepthSortFrom: Vector3;                               // location where to depth sort from\r\n    public facetDepthSortOrigin: Vector3;                             // same as facetDepthSortFrom but expressed in the mesh local space\r\n\r\n    public invertedMatrix: Matrix; // Inverted world matrix.\r\n}\r\n\r\n/**\r\n * @hidden\r\n **/\r\nclass _InternalAbstractMeshDataInfo {\r\n    public _hasVertexAlpha = false;\r\n    public _useVertexColors = true;\r\n    public _numBoneInfluencers = 4;\r\n    public _applyFog = true;\r\n    public _receiveShadows = false;\r\n    public _facetData = new _FacetDataStorage();\r\n    public _visibility = 1.0;\r\n    public _skeleton: Nullable<Skeleton> = null;\r\n    public _layerMask: number = 0x0FFFFFFF;\r\n    public _computeBonesUsingShaders = true;\r\n    public _isActive = false;\r\n    public _onlyForInstances = false;\r\n    public _isActiveIntermediate = false;\r\n    public _onlyForInstancesIntermediate = false;\r\n    public _actAsRegularMesh = false;\r\n    public _currentLOD: Nullable<AbstractMesh> = null;\r\n    public _currentLODIsUpToDate: boolean = false;\r\n}\r\n\r\n/**\r\n * Class used to store all common mesh properties\r\n */\r\nexport class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {\r\n    /** No occlusion */\r\n    public static OCCLUSION_TYPE_NONE = 0;\r\n    /** Occlusion set to optimisitic */\r\n    public static OCCLUSION_TYPE_OPTIMISTIC = 1;\r\n    /** Occlusion set to strict */\r\n    public static OCCLUSION_TYPE_STRICT = 2;\r\n    /** Use an accurante occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\r\n    /** Use a conservative occlusion algorithm */\r\n    public static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\r\n\r\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n     *  Test order :\r\n     *  Is the bounding sphere outside the frustum ?\r\n     *  If not, are the bounding box vertices outside the frustum ?\r\n     *  It not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_STANDARD = 0;\r\n    /** Culling strategy : Bounding Sphere Only.\r\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n     *  Test : is the bounding sphere outside the frustum ?\r\n     *  If not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\r\n    /** Culling strategy : Optimistic Inclusion.\r\n     *  This in an inclusion test first, then the standard exclusion test.\r\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n     *  Anyway, it's as accurate as the standard strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the default culling strategy.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\r\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n     */\r\n    public static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\r\n\r\n    /**\r\n     * No billboard\r\n     */\r\n    public static get BILLBOARDMODE_NONE(): number {\r\n        return TransformNode.BILLBOARDMODE_NONE;\r\n    }\r\n\r\n    /** Billboard on X axis */\r\n    public static get BILLBOARDMODE_X(): number {\r\n        return TransformNode.BILLBOARDMODE_X;\r\n    }\r\n\r\n    /** Billboard on Y axis */\r\n    public static get BILLBOARDMODE_Y(): number {\r\n        return TransformNode.BILLBOARDMODE_Y;\r\n    }\r\n\r\n    /** Billboard on Z axis */\r\n    public static get BILLBOARDMODE_Z(): number {\r\n        return TransformNode.BILLBOARDMODE_Z;\r\n    }\r\n\r\n    /** Billboard on all axes */\r\n    public static get BILLBOARDMODE_ALL(): number {\r\n        return TransformNode.BILLBOARDMODE_ALL;\r\n    }\r\n\r\n    /** Billboard on using position instead of orientation */\r\n    public static get BILLBOARDMODE_USE_POSITION(): number {\r\n        return TransformNode.BILLBOARDMODE_USE_POSITION;\r\n    }\r\n\r\n    // Internal data\r\n    /** @hidden */\r\n    public _internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\r\n\r\n    /**\r\n     * The culling strategy to use to check whether the mesh must be rendered or not.\r\n     * This value can be changed at any time and will be used on the next render mesh selection.\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * Please read each static variable documentation to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * Gets the number of facets in the mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\r\n    public get facetNb(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetNb;\r\n    }\r\n    /**\r\n     * Gets or set the number (integer) of subdivisions per axis in the partioning space\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\r\n    public get partitioningSubdivisions(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\r\n    }\r\n    public set partitioningSubdivisions(nb: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\r\n    }\r\n    /**\r\n     * The ratio (float) to apply to the bouding box size to set to the partioning space.\r\n     * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\r\n     */\r\n    public get partitioningBBoxRatio(): number {\r\n        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\r\n    }\r\n    public set partitioningBBoxRatio(ratio: number) {\r\n        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\r\n     * Works only for updatable meshes.\r\n     * Doesn't work with multi-materials\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\r\n    public get mustDepthSortFacets(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\r\n    }\r\n    public set mustDepthSortFacets(sort: boolean) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\r\n    }\r\n\r\n    /**\r\n     * The location (Vector3) where the facet depth sort must be computed from.\r\n     * By default, the active camera position.\r\n     * Used only when facet depth sort is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\r\n     */\r\n    public get facetDepthSortFrom(): Vector3 {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\r\n    }\r\n    public set facetDepthSortFrom(location: Vector3) {\r\n        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\r\n    }\r\n\r\n    /**\r\n     * gets a boolean indicating if facetData is enabled\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\r\n     */\r\n    public get isFacetDataEnabled(): boolean {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateNonUniformScalingState(value: boolean): boolean {\r\n        if (!super._updateNonUniformScalingState(value)) {\r\n            return false;\r\n        }\r\n        this._markSubMeshesAsMiscDirty();\r\n        return true;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n    * An event triggered when this mesh collides with another one\r\n    */\r\n    public onCollideObservable = new Observable<AbstractMesh>();\r\n\r\n    /** Set a function to call when this mesh collides with another one */\r\n    public set onCollide(callback: () => void) {\r\n        if (this._meshCollisionData._onCollideObserver) {\r\n            this.onCollideObservable.remove(this._meshCollisionData._onCollideObserver);\r\n        }\r\n        this._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the collision's position changes\r\n    */\r\n    public onCollisionPositionChangeObservable = new Observable<Vector3>();\r\n\r\n    /** Set a function to call when the collision's position changes */\r\n    public set onCollisionPositionChange(callback: () => void) {\r\n        if (this._meshCollisionData._onCollisionPositionChangeObserver) {\r\n            this.onCollisionPositionChangeObservable.remove(this._meshCollisionData._onCollisionPositionChangeObserver);\r\n        }\r\n        this._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when material is changed\r\n    */\r\n    public onMaterialChangedObservable = new Observable<AbstractMesh>();\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets or sets the orientation for POV movement & rotation\r\n     */\r\n    public definedFacingForward = true;\r\n\r\n    /** @hidden */\r\n    public _occlusionQuery: Nullable<WebGLQuery> = null;\r\n\r\n    /** @hidden */\r\n    public _renderingGroup: Nullable<RenderingGroup> = null;\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public get visibility(): number {\r\n        return this._internalAbstractMeshDataInfo._visibility;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets mesh visibility between 0 and 1 (default is 1)\r\n     */\r\n    public set visibility(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._visibility === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._visibility = value;\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets the alpha index used to sort transparent meshes\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\r\n     */\r\n    public alphaIndex = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\r\n     */\r\n    public isVisible = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    public isPickable = true;\r\n\r\n    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\r\n    public showSubMeshesBoundingBox = false;\r\n\r\n    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\r\n     */\r\n    public isBlocker = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\r\n     */\r\n    public enablePointerMoveEvents = false;\r\n\r\n    private _renderingGroupId = 0;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\r\n     */\r\n    public get renderingGroupId() {\r\n        return this._renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        this._renderingGroupId = value;\r\n    }\r\n    private _material: Nullable<Material> = null;\r\n\r\n    /** Gets or sets current material */\r\n    public get material(): Nullable<Material> {\r\n        return this._material;\r\n    }\r\n    public set material(value: Nullable<Material>) {\r\n        if (this._material === value) {\r\n            return;\r\n        }\r\n\r\n        // remove from material mesh map id needed\r\n        if (this._material && this._material.meshMap) {\r\n            this._material.meshMap[this.uniqueId] = undefined;\r\n        }\r\n\r\n        this._material = value;\r\n\r\n        if (value && value.meshMap) {\r\n            value.meshMap[this.uniqueId] = this;\r\n        }\r\n\r\n        if (this.onMaterialChangedObservable.hasObservers()) {\r\n            this.onMaterialChangedObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        this._unBindEffect();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can receive realtime shadows\r\n     * @see https://doc.babylonjs.com/babylon101/shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._internalAbstractMeshDataInfo._receiveShadows;\r\n    }\r\n    public set receiveShadows(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._receiveShadows = value;\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /** Defines color to use when rendering outline */\r\n    public outlineColor = Color3.Red();\r\n    /** Define width to use when rendering outline */\r\n    public outlineWidth = 0.02;\r\n\r\n    /** Defines color to use when rendering overlay */\r\n    public overlayColor = Color3.Red();\r\n    /** Defines alpha to use when rendering overlay */\r\n    public overlayAlpha = 0.5;\r\n\r\n    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\r\n    public get hasVertexAlpha(): boolean {\r\n        return this._internalAbstractMeshDataInfo._hasVertexAlpha;\r\n    }\r\n    public set hasVertexAlpha(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\r\n    public get useVertexColors(): boolean {\r\n        return this._internalAbstractMeshDataInfo._useVertexColors;\r\n    }\r\n    public set useVertexColors(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._useVertexColors = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\r\n     */\r\n    public get computeBonesUsingShaders(): boolean {\r\n        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\r\n    }\r\n    public set computeBonesUsingShaders(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\r\n    public get numBoneInfluencers(): number {\r\n        return this._internalAbstractMeshDataInfo._numBoneInfluencers;\r\n    }\r\n    public set numBoneInfluencers(value: number) {\r\n        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\r\n    public get applyFog(): boolean {\r\n        return this._internalAbstractMeshDataInfo._applyFog;\r\n    }\r\n    public set applyFog(value: boolean) {\r\n        if (this._internalAbstractMeshDataInfo._applyFog === value) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._applyFog = value;\r\n        this._markSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\r\n    public useOctreeForRenderingSelection = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\r\n    public useOctreeForPicking = true;\r\n    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\r\n    public useOctreeForCollisions = true;\r\n\r\n    /**\r\n     * Gets or sets the current layer mask (default is 0x0FFFFFFF)\r\n     * @see https://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures\r\n     */\r\n    public get layerMask(): number {\r\n        return this._internalAbstractMeshDataInfo._layerMask;\r\n    }\r\n\r\n    public set layerMask(value: number) {\r\n        if (value === this._internalAbstractMeshDataInfo._layerMask) {\r\n            return;\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._layerMask = value;\r\n        this._resyncLightSources();\r\n    }\r\n\r\n    /**\r\n     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\r\n     */\r\n    public alwaysSelectAsActiveMesh = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\r\n     */\r\n    public doNotSyncBoundingInfo = false;\r\n\r\n    /**\r\n     * Gets or sets the current action manager\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_actions\r\n     */\r\n    public actionManager: Nullable<AbstractActionManager> = null;\r\n\r\n    // Collisions\r\n    private _meshCollisionData = new _MeshCollisionData();\r\n\r\n    /**\r\n     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n    /**\r\n     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Gets or sets a collision mask used to mask collisions (default is -1).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._meshCollisionData._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a collision response flag (default is true).\r\n     * when collisionResponse is false, events are still triggered but colliding entity has no response\r\n     * This helps creating trigger volume when user wants collision feedback events but not position/velocity\r\n     * to respond to the collision.\r\n     */\r\n    public get collisionResponse(): boolean {\r\n        return this._meshCollisionData._collisionResponse;\r\n    }\r\n\r\n    public set collisionResponse(response: boolean) {\r\n        this._meshCollisionData._collisionResponse = response;\r\n    }\r\n    /**\r\n     * Gets or sets the current collision group mask (-1 by default).\r\n     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\r\n     */\r\n    public get collisionGroup(): number {\r\n        return this._meshCollisionData._collisionGroup;\r\n    }\r\n\r\n    public set collisionGroup(mask: number) {\r\n        this._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets current surrounding meshes (null by default).\r\n     *\r\n     * By default collision detection is tested against every mesh in the scene.\r\n     * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\r\n     * meshes will be tested for the collision.\r\n     *\r\n     * Note: if set to an empty array no collision will happen when this mesh is moved.\r\n     */\r\n    public get surroundingMeshes(): Nullable<AbstractMesh[]> {\r\n        return this._meshCollisionData._surroundingMeshes;\r\n    }\r\n\r\n    public set surroundingMeshes(meshes: Nullable<AbstractMesh[]>) {\r\n        this._meshCollisionData._surroundingMeshes = meshes;\r\n    }\r\n\r\n    // Edges\r\n    /**\r\n     * Defines edge width used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesWidth = 1;\r\n    /**\r\n     * Defines edge color used when edgesRenderer is enabled\r\n     * @see https://www.babylonjs-playground.com/#10OJSG#13\r\n     */\r\n    public edgesColor = new Color4(1, 0, 0, 1);\r\n    /** @hidden */\r\n    public _edgesRenderer: Nullable<IEdgesRenderer> = null;\r\n\r\n    /** @hidden */\r\n    public _masterMesh: Nullable<AbstractMesh> = null;\r\n    /** @hidden */\r\n    public _boundingInfo: Nullable<BoundingInfo> = null;\r\n    /** @hidden */\r\n    public _renderId = 0;\r\n\r\n    /**\r\n     * Gets or sets the list of subMeshes\r\n     * @see https://doc.babylonjs.com/how_to/multi_materials\r\n     */\r\n    public subMeshes: SubMesh[];\r\n\r\n    /** @hidden */\r\n    public _intersectionsInProgress = new Array<AbstractMesh>();\r\n\r\n    /** @hidden */\r\n    public _unIndexed = false;\r\n\r\n    /** @hidden */\r\n    public _lightSources = new Array<Light>();\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._lightSources;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return null;\r\n    }\r\n\r\n    // Loading properties\r\n    /** @hidden */\r\n    public _waitingData: {\r\n        lods: Nullable<any>,\r\n        actions: Nullable<any>\r\n        freezeWorldMatrix: Nullable<boolean>\r\n    } = {\r\n            lods: null,\r\n            actions: null,\r\n            freezeWorldMatrix: null\r\n        };\r\n\r\n    /** @hidden */\r\n    public _bonesTransformMatrices: Nullable<Float32Array> = null;\r\n\r\n    /** @hidden */\r\n    public _transformMatrixTexture: Nullable<RawTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets a skeleton to apply skining transformations\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\r\n     */\r\n    public set skeleton(value: Nullable<Skeleton>) {\r\n        let skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton && skeleton.needInitialSkinMatrix) {\r\n            skeleton._unregisterMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        if (value && value.needInitialSkinMatrix) {\r\n            value._registerMeshWithPoseMatrix(this);\r\n        }\r\n\r\n        this._internalAbstractMeshDataInfo._skeleton = value;\r\n\r\n        if (!this._internalAbstractMeshDataInfo._skeleton) {\r\n            this._bonesTransformMatrices = null;\r\n        }\r\n\r\n        this._markSubMeshesAsAttributesDirty();\r\n    }\r\n\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._internalAbstractMeshDataInfo._skeleton;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the mesh is rebuilt.\r\n     */\r\n    public onRebuildObservable = new Observable<AbstractMesh>();\r\n\r\n    // Constructor\r\n\r\n    /**\r\n     * Creates a new AbstractMesh\r\n     * @param name defines the name of the mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(name: string, scene: Nullable<Scene> = null) {\r\n        super(name, scene, false);\r\n\r\n        this.getScene().addMesh(this);\r\n\r\n        this._resyncLightSources();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AbstractMesh\"\r\n     * @returns \"AbstractMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AbstractMesh\";\r\n    }\r\n\r\n    /**\r\n     * Gets a string representation of the current mesh\r\n     * @param fullDetails defines a boolean indicating if full details must be included\r\n     * @returns a string representation of the current mesh\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\r\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\r\n\r\n        let skeleton = this._internalAbstractMeshDataInfo._skeleton;\r\n        if (skeleton) {\r\n            ret += \", skeleton: \" + skeleton.name;\r\n        }\r\n        if (fullDetails) {\r\n            ret += \", billboard mode: \" + ([\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"])[this.billboardMode];\r\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    protected _getEffectiveParent(): Nullable<Node> {\r\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh;\r\n        }\r\n\r\n        return super._getEffectiveParent();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getActionManagerForTrigger(trigger?: number, initialCall = true): Nullable<AbstractActionManager> {\r\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\r\n            if (trigger) {\r\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\r\n                    return this.actionManager;\r\n                }\r\n            }\r\n            else {\r\n                return this.actionManager;\r\n            }\r\n        }\r\n\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n\r\n        return this.parent._getActionManagerForTrigger(trigger, false);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.onRebuildObservable.notifyObservers(this);\r\n\r\n        if (this._occlusionQuery) {\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (var subMesh of this.subMeshes) {\r\n            subMesh._rebuild();\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _resyncLightSources(): void {\r\n        this._lightSources.length = 0;\r\n\r\n        for (var light of this.getScene().lights) {\r\n            if (!light.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (light.canAffectMesh(this)) {\r\n                this._lightSources.push(light);\r\n            }\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _resyncLightSource(light: Light): void {\r\n        var isIn = light.isEnabled() && light.canAffectMesh(this);\r\n\r\n        var index = this._lightSources.indexOf(light);\r\n        var removed = false;\r\n        if (index === -1) {\r\n            if (!isIn) {\r\n                return;\r\n            }\r\n            this._lightSources.push(light);\r\n        } else {\r\n            if (isIn) {\r\n                return;\r\n            }\r\n            removed = true;\r\n            this._lightSources.splice(index, 1);\r\n        }\r\n\r\n        this._markSubMeshesAsLightDirty(removed);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unBindEffect() {\r\n        for (var subMesh of this.subMeshes) {\r\n            subMesh.setEffect(null);\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _removeLightSource(light: Light, dispose: boolean): void {\r\n        var index = this._lightSources.indexOf(light);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this._lightSources.splice(index, 1);\r\n\r\n        this._markSubMeshesAsLightDirty(dispose);\r\n    }\r\n\r\n    private _markSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        if (!this.subMeshes) {\r\n            return;\r\n        }\r\n\r\n        for (var subMesh of this.subMeshes) {\r\n            if (subMesh._materialDefines) {\r\n                func(subMesh._materialDefines);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markSubMeshesAsLightDirty(dispose: boolean = false) {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markSubMeshesAsAttributesDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());\r\n    }\r\n\r\n    /** @hidden */\r\n    public _markSubMeshesAsMiscDirty() {\r\n        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());\r\n    }\r\n\r\n    /**\r\n    * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)\r\n    */\r\n    public get scaling(): Vector3 {\r\n        return this._scaling;\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this._scaling = newScaling;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Returns true if the mesh is blocked. Implemented by child classes\r\n     */\r\n    public get isBlocked(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh itself by default. Implemented by child classes\r\n     * @param camera defines the camera to use to pick the right LOD level\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    public getLOD(camera: Camera): Nullable<AbstractMesh> {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns 0 by default. Implemented by child classes\r\n     * @returns an integer\r\n     */\r\n    public getTotalVertices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns null by default. Implemented by child classes\r\n     * @returns null\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the array of the requested vertex data kind. Implemented by child classes\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns null\r\n     */\r\n    public getVerticesData(kind: string): Nullable<FloatArray> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (or static)\r\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * @param kind defines vertex data kind:\r\n     * * VertexBuffer.PositionKind\r\n     * * VertexBuffer.UVKind\r\n     * * VertexBuffer.UV2Kind\r\n     * * VertexBuffer.UV3Kind\r\n     * * VertexBuffer.UV4Kind\r\n     * * VertexBuffer.UV5Kind\r\n     * * VertexBuffer.UV6Kind\r\n     * * VertexBuffer.ColorKind\r\n     * * VertexBuffer.MatricesIndicesKind\r\n     * * VertexBuffer.MatricesIndicesExtraKind\r\n     * * VertexBuffer.MatricesWeightsKind\r\n     * * VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\r\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\r\n     * @returns the current mesh\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices,\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\r\n     * @param totalVertices Defines the total number of vertices\r\n     * @returns the current mesh\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\r\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\r\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh.getBoundingInfo();\r\n        }\r\n\r\n        if (!this._boundingInfo) {\r\n            // this._boundingInfo is being created here\r\n            this._updateBoundingInfo();\r\n        }\r\n        // cannot be null.\r\n        return this._boundingInfo!;\r\n    }\r\n\r\n    /**\r\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\r\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\r\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\r\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\r\n     * @returns the current mesh\r\n     */\r\n    public normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh {\r\n        return <AbstractMesh>super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);\r\n    }\r\n    /**\r\n     * Overwrite the current bounding info\r\n     * @param boundingInfo defines the new bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\r\n    public get useBones(): boolean {\r\n        return (<boolean>(this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)));\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivate(): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _preActivateForIntermediateRendering(renderId: number): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        this._renderId = renderId;\r\n        return true;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _postActivate(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _freeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unFreeze() {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix\r\n     * @returns a Matrix\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\r\n            return this._masterMesh.getWorldMatrix();\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getWorldMatrixDeterminant(): number {\r\n        if (this._masterMesh) {\r\n            return this._masterMesh._getWorldMatrixDeterminant();\r\n        }\r\n\r\n        return super._getWorldMatrixDeterminant();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh is an instance or a regular mesh\r\n     */\r\n    public get isAnInstance(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has instances\r\n     */\r\n    public get hasInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this mesh has thin instances\r\n     */\r\n    public get hasThinInstances(): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ================================== Point of View Movement =================================\r\n\r\n    /**\r\n     * Perform relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the current mesh\r\n     */\r\n    public movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh {\r\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative position change from the point of view of behind the front of the mesh.\r\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param amountRight defines the distance on the right axis\r\n     * @param amountUp defines the distance on the up axis\r\n     * @param amountForward defines the distance on the forward axis\r\n     * @returns the new displacement vector\r\n     */\r\n    public calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3 {\r\n        var rotMatrix = new Matrix();\r\n        var rotQuaternion = (this.rotationQuaternion) ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\r\n        rotQuaternion.toRotationMatrix(rotMatrix);\r\n\r\n        var translationDelta = Vector3.Zero();\r\n        var defForwardMult = this.definedFacingForward ? -1 : 1;\r\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\r\n        return translationDelta;\r\n    }\r\n    // ================================== Point of View Rotation =================================\r\n    /**\r\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the current mesh\r\n     */\r\n    public rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh {\r\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\r\n     * Supports definition of mesh facing forward or backward.\r\n     * @param flipBack defines the flip\r\n     * @param twirlClockwise defines the twirl\r\n     * @param tiltRight defines the tilt\r\n     * @returns the new rotation vector\r\n     */\r\n    public calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3 {\r\n        var defForwardMult = this.definedFacingForward ? 1 : -1;\r\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false): AbstractMesh {\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n\r\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton), null);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void {\r\n        if (data) {\r\n            var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\r\n            if (this._boundingInfo) {\r\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n            }\r\n            else {\r\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n            }\r\n        }\r\n\r\n        if (this.subMeshes) {\r\n            for (var index = 0; index < this.subMeshes.length; index++) {\r\n                this.subMeshes[index].refreshBoundingInfo(data);\r\n            }\r\n        }\r\n\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getPositionData(applySkeleton: boolean): Nullable<FloatArray> {\r\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (data && applySkeleton && this.skeleton) {\r\n            data = Tools.Slice(data);\r\n            this._generatePointsArray();\r\n\r\n            var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n            var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\r\n            if (matricesWeightsData && matricesIndicesData) {\r\n                var needExtras = this.numBoneInfluencers > 4;\r\n                var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n                var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n                this.skeleton.prepare();\r\n                var skeletonMatrices = this.skeleton.getTransformMatrices(this);\r\n\r\n                var tempVector = TmpVectors.Vector3[0];\r\n                var finalMatrix = TmpVectors.Matrix[0];\r\n                var tempMatrix = TmpVectors.Matrix[1];\r\n\r\n                var matWeightIdx = 0;\r\n                for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {\r\n                    finalMatrix.reset();\r\n\r\n                    var inf: number;\r\n                    var weight: number;\r\n                    for (inf = 0; inf < 4; inf++) {\r\n                        weight = matricesWeightsData[matWeightIdx + inf];\r\n                        if (weight > 0) {\r\n                            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                            finalMatrix.addToSelf(tempMatrix);\r\n                        }\r\n                    }\r\n                    if (needExtras) {\r\n                        for (inf = 0; inf < 4; inf++) {\r\n                            weight = matricesWeightsExtraData![matWeightIdx + inf];\r\n                            if (weight > 0) {\r\n                                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData![matWeightIdx + inf] * 16), weight, tempMatrix);\r\n                                finalMatrix.addToSelf(tempMatrix);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\r\n                    tempVector.toArray(data, index);\r\n\r\n                    if (this._positions) {\r\n                        this._positions[index / 3].copyFrom(tempVector);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        const effectiveMesh = this._effectiveMesh;\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.update(effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        else {\r\n            this._boundingInfo = new BoundingInfo(this.absolutePosition, this.absolutePosition, effectiveMesh.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(effectiveMesh.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh {\r\n        if (!this.subMeshes) {\r\n            return this;\r\n        }\r\n        let count = this.subMeshes.length;\r\n        for (var subIndex = 0; subIndex < count; subIndex++) {\r\n            var subMesh = this.subMeshes[subIndex];\r\n            if (count > 1 || !subMesh.IsGlobal) {\r\n                subMesh.updateBoundingInfo(matrix);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _afterComputeWorldMatrix(): void {\r\n        if (this.doNotSyncBoundingInfo) {\r\n            return;\r\n        }\r\n        // Bounding info\r\n        this._updateBoundingInfo();\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _effectiveMesh(): AbstractMesh {\r\n        return (this.skeleton && this.skeleton.overrideMesh) || this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\r\n     * A mesh is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\r\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the mesh is completely in the frustum planes\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this._boundingInfo !== null && this._boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * True if the mesh intersects another mesh or a SolidParticle object\r\n     * @param mesh defines a target mesh or SolidParticle to test\r\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\r\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMesh(mesh: AbstractMesh | SolidParticle, precise: boolean = false, includeDescendants?: boolean): boolean {\r\n        if (!this._boundingInfo || !mesh._boundingInfo) {\r\n            return false;\r\n        }\r\n\r\n        if (this._boundingInfo.intersects(mesh._boundingInfo, precise)) {\r\n            return true;\r\n        }\r\n\r\n        if (includeDescendants) {\r\n            for (var child of this.getChildMeshes()) {\r\n                if (child.intersectsMesh(mesh, precise, true)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsPoint(point: Vector3): boolean {\r\n        if (!this._boundingInfo) {\r\n            return false;\r\n        }\r\n\r\n        return this._boundingInfo.intersectsPoint(point);\r\n    }\r\n\r\n    // Collisions\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that this mesh can be used in the collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return this._meshCollisionData._checkCollisions;\r\n    }\r\n\r\n    public set checkCollisions(collisionEnabled: boolean) {\r\n        this._meshCollisionData._checkCollisions = collisionEnabled;\r\n    }\r\n\r\n    /**\r\n     * Gets Collider object used to compute collisions (not physics)\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     */\r\n    public get collider(): Nullable<Collider> {\r\n        return this._meshCollisionData._collider;\r\n    }\r\n\r\n    /**\r\n     * Move the mesh using collision engine\r\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\r\n     * @param displacement defines the requested displacement vector\r\n     * @returns the current mesh\r\n     */\r\n    public moveWithCollisions(displacement: Vector3): AbstractMesh {\r\n        var globalPosition = this.getAbsolutePosition();\r\n\r\n        globalPosition.addToRef(this.ellipsoidOffset, this._meshCollisionData._oldPositionForCollisions);\r\n        let coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._meshCollisionData._collider) {\r\n            this._meshCollisionData._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._meshCollisionData._collider._radius = this.ellipsoid;\r\n\r\n        coordinator.getNewPosition(this._meshCollisionData._oldPositionForCollisions, displacement, this._meshCollisionData._collider, 3, this, this._onCollisionPositionChange, this.uniqueId);\r\n        return this;\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        newPosition.subtractToRef(this._meshCollisionData._oldPositionForCollisions, this._meshCollisionData._diffPositionForCollisions);\r\n\r\n        if (this._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addInPlace(this._meshCollisionData._diffPositionForCollisions);\r\n        }\r\n\r\n        if (collidedMesh) {\r\n            this.onCollideObservable.notifyObservers(collidedMesh);\r\n        }\r\n\r\n        this.onCollisionPositionChangeObservable.notifyObservers(this.position);\r\n    }\r\n\r\n    // Collisions\r\n    /** @hidden */\r\n    public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh {\r\n        this._generatePointsArray();\r\n\r\n        if (!this._positions) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation\r\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix!.equals(transformMatrix)) {\r\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\r\n            subMesh._lastColliderWorldVertices = [];\r\n            subMesh._trianglePlanes = [];\r\n            var start = subMesh.verticesStart;\r\n            var end = (subMesh.verticesStart + subMesh.verticesCount);\r\n            for (var i = start; i < end; i++) {\r\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\r\n            }\r\n        }\r\n\r\n        // Collide\r\n        collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, (<IndicesArray>this.getIndices()), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this);\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh {\r\n        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\r\n        const len = subMeshes.length;\r\n\r\n        for (var index = 0; index < len; index++) {\r\n            var subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh._checkCollision(collider)) {\r\n                continue;\r\n            }\r\n\r\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkCollision(collider: Collider): AbstractMesh {\r\n        // Bounding box test\r\n        if (!this._boundingInfo || !this._boundingInfo._checkCollision(collider)) {\r\n            return this;\r\n        }\r\n\r\n        // Transformation matrix\r\n        const collisionsScalingMatrix = TmpVectors.Matrix[0];\r\n        const collisionsTransformMatrix = TmpVectors.Matrix[1];\r\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\r\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\r\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\r\n        return this;\r\n    }\r\n\r\n    // Picking\r\n    /** @hidden */\r\n    public _generatePointsArray(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the passed Ray intersects with the mesh\r\n     * @param ray defines the ray to use\r\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns the picking info\r\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\r\n     */\r\n    public intersects(ray: Ray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate, onlyBoundingInfo = false, worldToUse?: Matrix, skipBoundingInfo = false): PickingInfo {\r\n        var pickingInfo = new PickingInfo();\r\n        const intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? (this as any).intersectionThreshold : 0;\r\n        const boundingInfo = this._boundingInfo;\r\n        if (!this.subMeshes || !boundingInfo) {\r\n            return pickingInfo;\r\n        }\r\n        if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (onlyBoundingInfo) {\r\n            pickingInfo.hit = skipBoundingInfo ? false : true;\r\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\r\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = 0;\r\n            return pickingInfo;\r\n        }\r\n\r\n        if (!this._generatePointsArray()) {\r\n            return pickingInfo;\r\n        }\r\n\r\n        var intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\r\n        var len: number = subMeshes.length;\r\n\r\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\r\n        // if no submesh can be picked that way, then fallback to BBox picking\r\n        var anySubmeshSupportIntersect = false;\r\n        for (var index = 0; index < len; index++) {\r\n            var subMesh = subMeshes.data[index];\r\n            var material = subMesh.getMaterial();\r\n            if (!material) {\r\n                continue;\r\n            }\r\n            if (this.getIndices()?.length && (material.fillMode == 7 ||\r\n                    material.fillMode == 0 ||\r\n                    material.fillMode == 1 ||\r\n                    material.fillMode == 2)) {\r\n                anySubmeshSupportIntersect = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // no sub mesh support intersection, fallback to BBox that has already be done\r\n        if (!anySubmeshSupportIntersect) {\r\n            pickingInfo.hit = true;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\r\n            pickingInfo.subMeshId = -1;\r\n            return pickingInfo;\r\n        }\r\n\r\n        // at least 1 submesh supports intersection, keep going\r\n        for (var index = 0; index < len; index++) {\r\n            var subMesh = subMeshes.data[index];\r\n\r\n            // Bounding test\r\n            if (len > 1 && !subMesh.canIntersects(ray)) {\r\n                continue;\r\n            }\r\n\r\n            var currentIntersectInfo = subMesh.intersects(ray, (<Vector3[]>this._positions),\r\n                (<IndicesArray>this.getIndices()), fastCheck,\r\n                trianglePredicate);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.subMeshId = index;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (intersectInfo) {\r\n            // Get picked point\r\n            const world = worldToUse ?? (this.skeleton && this.skeleton.overrideMesh ? this.skeleton.overrideMesh.getWorldMatrix() : this.getWorldMatrix());\r\n            const worldOrigin = TmpVectors.Vector3[0];\r\n            const direction = TmpVectors.Vector3[1];\r\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\r\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\r\n            const worldDirection = Vector3.TransformNormal(direction, world);\r\n            const pickedPoint = worldDirection.addInPlace(worldOrigin);\r\n\r\n            // Return result\r\n            pickingInfo.hit = true;\r\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\r\n            pickingInfo.pickedPoint = pickedPoint;\r\n            pickingInfo.pickedMesh = this;\r\n            pickingInfo.bu = intersectInfo.bu || 0;\r\n            pickingInfo.bv = intersectInfo.bv || 0;\r\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\r\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\r\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\r\n            return pickingInfo;\r\n        }\r\n\r\n        return pickingInfo;\r\n    }\r\n\r\n    /**\r\n     * Clones the current mesh\r\n     * @param name defines the mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes all the submeshes of the current meshnp\r\n     * @returns the current mesh\r\n     */\r\n    public releaseSubMeshes(): AbstractMesh {\r\n        if (this.subMeshes) {\r\n            while (this.subMeshes.length) {\r\n                this.subMeshes[0].dispose();\r\n            }\r\n        } else {\r\n            this.subMeshes = new Array<SubMesh>();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this abstract mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        var index: number;\r\n\r\n        // mesh map release.\r\n        if (this._scene.useMaterialMeshMap) {\r\n            // remove from material mesh map id needed\r\n            if (this._material && this._material.meshMap) {\r\n                this._material.meshMap[this.uniqueId] = undefined;\r\n            }\r\n        }\r\n\r\n        // Smart Array Retainers.\r\n        this.getScene().freeActiveMeshes();\r\n        this.getScene().freeRenderingGroups();\r\n\r\n        // Action manager\r\n        if (this.actionManager !== undefined && this.actionManager !== null) {\r\n            this.actionManager.dispose();\r\n            this.actionManager = null;\r\n        }\r\n\r\n        // Skeleton\r\n        this._internalAbstractMeshDataInfo._skeleton = null;\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n\r\n        // Intersections in progress\r\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\r\n            var other = this._intersectionsInProgress[index];\r\n\r\n            var pos = other._intersectionsInProgress.indexOf(this);\r\n            other._intersectionsInProgress.splice(pos, 1);\r\n        }\r\n\r\n        this._intersectionsInProgress = [];\r\n\r\n        // Lights\r\n        var lights = this.getScene().lights;\r\n\r\n        lights.forEach((light: Light) => {\r\n            var meshIndex = light.includedOnlyMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.includedOnlyMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            meshIndex = light.excludedMeshes.indexOf(this);\r\n\r\n            if (meshIndex !== -1) {\r\n                light.excludedMeshes.splice(meshIndex, 1);\r\n            }\r\n\r\n            // Shadow generators\r\n            var generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                var shadowMap = generator.getShadowMap();\r\n\r\n                if (shadowMap && shadowMap.renderList) {\r\n                    meshIndex = shadowMap.renderList.indexOf(this);\r\n\r\n                    if (meshIndex !== -1) {\r\n                        shadowMap.renderList.splice(meshIndex, 1);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // SubMeshes\r\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\r\n            this.releaseSubMeshes();\r\n        }\r\n\r\n        // Query\r\n        let engine = this.getScene().getEngine();\r\n        if (this._occlusionQuery) {\r\n            this.isOcclusionQueryInProgress = false;\r\n            engine.deleteQuery(this._occlusionQuery);\r\n            this._occlusionQuery = null;\r\n        }\r\n\r\n        // Engine\r\n        engine.wipeCaches();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeMesh(this);\r\n\r\n        if (disposeMaterialAndTextures) {\r\n            if (this.material) {\r\n                if (this.material.getClassName() === \"MultiMaterial\") {\r\n                    this.material.dispose(false, true, true);\r\n                } else {\r\n                    this.material.dispose(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!doNotRecurse) {\r\n            // Particles\r\n            for (index = 0; index < this.getScene().particleSystems.length; index++) {\r\n                if (this.getScene().particleSystems[index].emitter === this) {\r\n                    this.getScene().particleSystems[index].dispose();\r\n                    index--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // facet data\r\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\r\n            this.disableFacetData();\r\n        }\r\n\r\n        this.onAfterWorldMatrixUpdateObservable.clear();\r\n        this.onCollideObservable.clear();\r\n        this.onCollisionPositionChangeObservable.clear();\r\n        this.onRebuildObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Adds the passed mesh as a child to the current mesh\r\n     * @param mesh defines the child mesh\r\n     * @returns the current mesh\r\n     */\r\n    public addChild(mesh: AbstractMesh): AbstractMesh {\r\n        mesh.setParent(this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the passed mesh from the current mesh children list\r\n     * @param mesh defines the child mesh\r\n     * @returns the current mesh\r\n     */\r\n    public removeChild(mesh: AbstractMesh): AbstractMesh {\r\n        mesh.setParent(null);\r\n        return this;\r\n    }\r\n\r\n    // Facet data\r\n    /** @hidden */\r\n    private _initFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetNormals) {\r\n            data.facetNormals = new Array<Vector3>();\r\n        }\r\n        if (!data.facetPositions) {\r\n            data.facetPositions = new Array<Vector3>();\r\n        }\r\n        if (!data.facetPartitioning) {\r\n            data.facetPartitioning = new Array<number[]>();\r\n        }\r\n        data.facetNb = ((<IndicesArray>this.getIndices()).length / 3) | 0;\r\n        data.partitioningSubdivisions = (data.partitioningSubdivisions) ? data.partitioningSubdivisions : 10;   // default nb of partitioning subdivisions = 10\r\n        data.partitioningBBoxRatio = (data.partitioningBBoxRatio) ? data.partitioningBBoxRatio : 1.01;          // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\r\n        for (var f = 0; f < data.facetNb; f++) {\r\n            data.facetNormals[f] = Vector3.Zero();\r\n            data.facetPositions[f] = Vector3.Zero();\r\n        }\r\n        data.facetDataEnabled = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\r\n     * This method can be called within the render loop.\r\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public updateFacetData(): AbstractMesh {\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!data.facetDataEnabled) {\r\n            this._initFacetData();\r\n        }\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        var indices = this.getIndices();\r\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\r\n        var bInfo = this.getBoundingInfo();\r\n\r\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\r\n            // init arrays, matrix and sort function on first call\r\n            data.facetDepthSortEnabled = true;\r\n            if (indices instanceof Uint16Array) {\r\n                data.depthSortedIndices = new Uint16Array(indices!);\r\n            }\r\n            else if (indices instanceof Uint32Array) {\r\n                data.depthSortedIndices = new Uint32Array(indices!);\r\n            }\r\n            else {\r\n                var needs32bits = false;\r\n                for (var i = 0; i < indices!.length; i++) {\r\n                    if (indices![i] > 65535) {\r\n                        needs32bits = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (needs32bits) {\r\n                    data.depthSortedIndices = new Uint32Array(indices!);\r\n                }\r\n                else {\r\n                    data.depthSortedIndices = new Uint16Array(indices!);\r\n                }\r\n            }\r\n            data.facetDepthSortFunction = function(f1, f2) {\r\n                return (f2.sqDistance - f1.sqDistance);\r\n            };\r\n            if (!data.facetDepthSortFrom) {\r\n                var camera = this.getScene().activeCamera;\r\n                data.facetDepthSortFrom = (camera) ? camera.position : Vector3.Zero();\r\n            }\r\n            data.depthSortedFacets = [];\r\n            for (var f = 0; f < data.facetNb; f++) {\r\n                var depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\r\n                data.depthSortedFacets.push(depthSortedFacet);\r\n            }\r\n            data.invertedMatrix = Matrix.Identity();\r\n            data.facetDepthSortOrigin = Vector3.Zero();\r\n        }\r\n\r\n        data.bbSize.x = (bInfo.maximum.x - bInfo.minimum.x > Epsilon) ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\r\n        data.bbSize.y = (bInfo.maximum.y - bInfo.minimum.y > Epsilon) ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\r\n        data.bbSize.z = (bInfo.maximum.z - bInfo.minimum.z > Epsilon) ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\r\n        var bbSizeMax = (data.bbSize.x > data.bbSize.y) ? data.bbSize.x : data.bbSize.y;\r\n        bbSizeMax = (bbSizeMax > data.bbSize.z) ? bbSizeMax : data.bbSize.z;\r\n        data.subDiv.max = data.partitioningSubdivisions;\r\n        data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);   // adjust the number of subdivisions per axis\r\n        data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);   // according to each bbox size per axis\r\n        data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);\r\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;                     // at least one subdivision\r\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\r\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\r\n        // set the parameters for ComputeNormals()\r\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\r\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\r\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\r\n        data.facetParameters.bInfo = bInfo;\r\n        data.facetParameters.bbSize = data.bbSize;\r\n        data.facetParameters.subDiv = data.subDiv;\r\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\r\n        data.facetParameters.depthSort = data.facetDepthSort;\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            this.computeWorldMatrix(true);\r\n            this._worldMatrix.invertToRef(data.invertedMatrix);\r\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\r\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\r\n        }\r\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\r\n        VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\r\n\r\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\r\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\r\n            var l = (data.depthSortedIndices.length / 3) | 0;\r\n            for (var f = 0; f < l; f++) {\r\n                var sind = data.depthSortedFacets[f].ind;\r\n                data.depthSortedIndices[f * 3] = indices![sind];\r\n                data.depthSortedIndices[f * 3 + 1] = indices![sind + 1];\r\n                data.depthSortedIndices[f * 3 + 2] = indices![sind + 2];\r\n            }\r\n            this.updateIndices(data.depthSortedIndices, undefined, true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalNormals array.\r\n     * The normals are expressed in the mesh local spac\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalNormals(): Vector3[] {\r\n        let facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetNormals) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetNormals;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPositions array.\r\n     * The facet positions are expressed in the mesh local space\r\n     * @returns an array of Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalPositions(): Vector3[] {\r\n        let facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (!facetData.facetPositions) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPositions;\r\n    }\r\n\r\n    /**\r\n     * Returns the facetLocalPartioning array\r\n     * @returns an array of array of numbers\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetLocalPartitioning(): number[][] {\r\n        let facetData = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        if (!facetData.facetPartitioning) {\r\n            this.updateFacetData();\r\n        }\r\n        return facetData.facetPartitioning;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet position in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetPosition(i: number): Vector3 {\r\n        var pos = Vector3.Zero();\r\n        this.getFacetPositionToRef(i, pos);\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet position in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh {\r\n        var localPos = (this.getFacetLocalPositions())[i];\r\n        var world = this.getWorldMatrix();\r\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the i-th facet normal in the world system.\r\n     * This method allocates a new Vector3 per call\r\n     * @param i defines the facet index\r\n     * @returns a new Vector3\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetNormal(i: number): Vector3 {\r\n        var norm = Vector3.Zero();\r\n        this.getFacetNormalToRef(i, norm);\r\n        return norm;\r\n    }\r\n\r\n    /**\r\n     * Sets the reference Vector3 with the i-th facet normal in the world system\r\n     * @param i defines the facet index\r\n     * @param ref defines the target vector\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetNormalToRef(i: number, ref: Vector3) {\r\n        var localNorm = (this.getFacetLocalNormals())[i];\r\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the array of facet indexes\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]> {\r\n        var bInfo = this.getBoundingInfo();\r\n        const data = this._internalAbstractMeshDataInfo._facetData;\r\n\r\n        var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);\r\n        var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);\r\n        var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);\r\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\r\n            return null;\r\n        }\r\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\r\n     * @param projected sets as the (x,y,z) world projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var invVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);  // transform (x,y,z) to coordinates in the mesh local space\r\n        var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\r\n        if (projected) {\r\n            // tranform the local computed projected vector to world coordinates\r\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\r\n     * @param projected sets as the (x,y,z) local projection on the facet\r\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\r\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\r\n     * @param x defines x coordinate\r\n     * @param y defines y coordinate\r\n     * @param z defines z coordinate\r\n     * @returns the face index if found (or null instead)\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace: boolean = false, facing: boolean = true): Nullable<number> {\r\n        var closest = null;\r\n        var tmpx = 0.0;\r\n        var tmpy = 0.0;\r\n        var tmpz = 0.0;\r\n        var d = 0.0;            // tmp dot facet normal * facet position\r\n        var t0 = 0.0;\r\n        var projx = 0.0;\r\n        var projy = 0.0;\r\n        var projz = 0.0;\r\n        // Get all the facets in the same partitioning block than (x, y, z)\r\n        var facetPositions = this.getFacetLocalPositions();\r\n        var facetNormals = this.getFacetLocalNormals();\r\n        var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\r\n        if (!facetsInBlock) {\r\n            return null;\r\n        }\r\n        // Get the closest facet to (x, y, z)\r\n        var shortest = Number.MAX_VALUE;            // init distance vars\r\n        var tmpDistance = shortest;\r\n        var fib;                                    // current facet in the block\r\n        var norm;                                   // current facet normal\r\n        var p0;                                     // current facet barycenter position\r\n        // loop on all the facets in the current partitioning block\r\n        for (var idx = 0; idx < facetsInBlock.length; idx++) {\r\n            fib = facetsInBlock[idx];\r\n            norm = facetNormals[fib];\r\n            p0 = facetPositions[fib];\r\n\r\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\r\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\r\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\r\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\r\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\r\n                projx = x + norm.x * t0;\r\n                projy = y + norm.y * t0;\r\n                projz = z + norm.z * t0;\r\n\r\n                tmpx = projx - x;\r\n                tmpy = projy - y;\r\n                tmpz = projz - z;\r\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;             // compute length between (x, y, z) and its projection on the facet\r\n                if (tmpDistance < shortest) {                                      // just keep the closest facet to (x, y, z)\r\n                    shortest = tmpDistance;\r\n                    closest = fib;\r\n                    if (projected) {\r\n                        projected.x = projx;\r\n                        projected.y = projy;\r\n                        projected.z = projz;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    /**\r\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\r\n     * @returns the parameters\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public getFacetDataParameters(): any {\r\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\r\n    }\r\n\r\n    /**\r\n     * Disables the feature FacetData and frees the related memory\r\n     * @returns the current mesh\r\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\r\n     */\r\n    public disableFacetData(): AbstractMesh {\r\n        let facetData = this._internalAbstractMeshDataInfo._facetData;\r\n        if (facetData.facetDataEnabled) {\r\n            facetData.facetDataEnabled = false;\r\n            facetData.facetPositions = new Array<Vector3>();\r\n            facetData.facetNormals = new Array<Vector3>();\r\n            facetData.facetPartitioning = new Array<number[]>();\r\n            facetData.facetParameters = null;\r\n            facetData.depthSortedIndices = new Uint32Array(0);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the AbstractMesh indices array\r\n     * @param indices defines the data source\r\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     * @returns the current mesh\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): AbstractMesh {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates new normals data for the mesh\r\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\r\n     * @returns the current mesh\r\n     */\r\n    public createNormals(updatable: boolean): AbstractMesh {\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n        var indices = this.getIndices();\r\n        var normals: FloatArray;\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            normals = (<FloatArray>this.getVerticesData(VertexBuffer.NormalKind));\r\n        } else {\r\n            normals = [];\r\n        }\r\n\r\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\r\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Align the mesh with a normal\r\n     * @param normal defines the normal to use\r\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\r\n     * @returns the current mesh\r\n     */\r\n    public alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh {\r\n        if (!upDirection) {\r\n            upDirection = Axis.Y;\r\n        }\r\n\r\n        var axisX = TmpVectors.Vector3[0];\r\n        var axisZ = TmpVectors.Vector3[1];\r\n        Vector3.CrossToRef(upDirection, normal, axisZ);\r\n        Vector3.CrossToRef(normal, axisZ, axisX);\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\r\n        } else {\r\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _checkOcclusionQuery(): boolean { // Will be replaced by correct code if Occlusion queries are referenced\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disables the mesh edge rendering mode\r\n     * @returns the currentAbstractMesh\r\n     */\r\n    disableEdgesRendering(): AbstractMesh {\r\n        throw _DevTools.WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * Enables the edge rendering mode on the mesh.\r\n     * This mode makes the mesh edges visible\r\n     * @param epsilon defines the maximal distance between two angles to detect a face\r\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\r\n     * @param options options to the edge renderer\r\n     * @returns the currentAbstractMesh\r\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\r\n     */\r\n    enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean, options?: IEdgesRendererOptions): AbstractMesh {\r\n        throw _DevTools.WarnImport(\"EdgesRenderer\");\r\n    }\r\n\r\n    /**\r\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\r\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\r\n     */\r\n    public getConnectedParticleSystems(): IParticleSystem[] {\r\n        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.AbstractMesh\"] = AbstractMesh;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}