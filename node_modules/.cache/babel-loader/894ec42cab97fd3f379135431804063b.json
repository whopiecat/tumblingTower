{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { MaterialHelper } from '../../../materialHelper';\nimport { VertexBuffer } from '../../../../Meshes/buffer';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\n\nvar MorphTargetsBlock =\n/** @class */\nfunction (_super) {\n  __extends(MorphTargetsBlock, _super);\n  /**\r\n   * Create a new MorphTargetsBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function MorphTargetsBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;\n\n    _this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    _this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  MorphTargetsBlock.prototype.getClassName = function () {\n    return \"MorphTargetsBlock\";\n  };\n\n  Object.defineProperty(MorphTargetsBlock.prototype, \"position\", {\n    /**\r\n     * Gets the position input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normal\", {\n    /**\r\n     * Gets the normal input component\r\n     */\n    get: function () {\n      return this._inputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangent\", {\n    /**\r\n     * Gets the tangent input component\r\n     */\n    get: function () {\n      return this._inputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the tangent input component\r\n     */\n    get: function () {\n      return this._inputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"positionOutput\", {\n    /**\r\n     * Gets the position output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"normalOutput\", {\n    /**\r\n     * Gets the normal output component\r\n     */\n    get: function () {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"tangentOutput\", {\n    /**\r\n     * Gets the tangent output component\r\n     */\n    get: function () {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MorphTargetsBlock.prototype, \"uvOutput\", {\n    /**\r\n     * Gets the tangent output component\r\n     */\n    get: function () {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MorphTargetsBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"morphTargetInfluences\");\n  };\n\n  MorphTargetsBlock.prototype.autoConfigure = function (material) {\n    if (!this.position.isConnected) {\n      var positionInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"position\";\n      });\n\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n\n      positionInput.output.connectTo(this.position);\n    }\n\n    if (!this.normal.isConnected) {\n      var normalInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"normal\";\n      });\n\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n\n      normalInput.output.connectTo(this.normal);\n    }\n\n    if (!this.tangent.isConnected) {\n      var tangentInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"tangent\";\n      });\n\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n\n      tangentInput.output.connectTo(this.tangent);\n    }\n\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  MorphTargetsBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n\n    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\n  };\n\n  MorphTargetsBlock.prototype.bind = function (effect, nodeMaterial, mesh) {\n    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\n      MaterialHelper.BindMorphTargetParameters(mesh, effect);\n    }\n  };\n\n  MorphTargetsBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var state = vertexShaderState;\n    var repeatCount = defines.NUM_MORPH_INFLUENCERS;\n    var manager = mesh.morphTargetManager;\n    var hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    var hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    var hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\n    var injectionCode = \"\";\n\n    for (var index = 0; index < repeatCount; index++) {\n      injectionCode += \"#ifdef MORPHTARGETS\\r\\n\";\n      injectionCode += positionOutput.associatedVariableName + \" += (position\" + index + \" - \" + position.associatedVariableName + \") * morphTargetInfluences[\" + index + \"];\\r\\n\";\n\n      if (hasNormals) {\n        injectionCode += \"#ifdef MORPHTARGETS_NORMAL\\r\\n\";\n        injectionCode += normalOutput.associatedVariableName + \" += (normal\" + index + \" - \" + normal.associatedVariableName + \") * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasTangents) {\n        injectionCode += \"#ifdef MORPHTARGETS_TANGENT\\r\\n\";\n        injectionCode += tangentOutput.associatedVariableName + \".xyz += (tangent\" + index + \" - \" + tangent.associatedVariableName + \".xyz) * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      if (hasUVs) {\n        injectionCode += \"#ifdef MORPHTARGETS_UV\\r\\n\";\n        injectionCode += uvOutput.associatedVariableName + \".xy += (uv_\" + index + \" - \" + uv.associatedVariableName + \".xy) * morphTargetInfluences[\" + index + \"];\\r\\n\";\n        injectionCode += \"#endif\\r\\n\";\n      }\n\n      injectionCode += \"#endif\\r\\n\";\n    }\n\n    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\n\n    if (repeatCount > 0) {\n      for (var index = 0; index < repeatCount; index++) {\n        state.attributes.push(VertexBuffer.PositionKind + index);\n\n        if (hasNormals) {\n          state.attributes.push(VertexBuffer.NormalKind + index);\n        }\n\n        if (hasTangents) {\n          state.attributes.push(VertexBuffer.TangentKind + index);\n        }\n\n        if (hasUVs) {\n          state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n    }\n  };\n\n  MorphTargetsBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state); // Register for defines\n\n\n    state.sharedData.blocksWithDefines.push(this); // Register for binding\n\n    state.sharedData.bindableBlocks.push(this); // Register for repeatable content generation\n\n    state.sharedData.repeatableContentBlocks.push(this); // Emit code\n\n    var position = this.position;\n    var normal = this.normal;\n    var tangent = this.tangent;\n    var uv = this.uv;\n    var positionOutput = this.positionOutput;\n    var normalOutput = this.normalOutput;\n    var tangentOutput = this.tangentOutput;\n    var uvOutput = this.uvOutput;\n    var comments = \"//\" + this.name;\n    state.uniforms.push(\"morphTargetInfluences\");\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\n\n    state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\n      repeatKey: \"maxSimultaneousMorphTargets\"\n    });\n\n    state.compilationString += this._declareOutput(positionOutput, state) + \" = \" + position.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#ifdef NORMAL\\r\\n\";\n    state.compilationString += this._declareOutput(normalOutput, state) + \" = \" + normal.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(normalOutput, state) + \" = vec3(0., 0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef TANGENT\\r\\n\";\n    state.compilationString += this._declareOutput(tangentOutput, state) + \" = \" + tangent.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(tangentOutput, state) + \" = vec3(0., 0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef UV1\\r\\n\";\n    state.compilationString += this._declareOutput(uvOutput, state) + \" = \" + uv.associatedVariableName + \";\\r\\n\";\n    state.compilationString += \"#else\\r\\n\";\n    state.compilationString += this._declareOutput(uvOutput, state) + \" = vec2(0., 0.);\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\"; // Repeatable content\n\n    this._repeatableContentAnchor = state._repeatableContentAnchor;\n    state.compilationString += this._repeatableContentAnchor;\n    return this;\n  };\n\n  return MorphTargetsBlock;\n}(NodeMaterialBlock);\n\nexport { MorphTargetsBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.MorphTargetsBlock\"] = MorphTargetsBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Vertex/morphTargetsBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { Effect } from '../../../effect';\r\nimport { Mesh } from '../../../../Meshes/mesh';\r\nimport { MaterialHelper } from '../../../materialHelper';\r\nimport { VertexBuffer } from '../../../../Meshes/buffer';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\n\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\n\r\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\r\nexport class MorphTargetsBlock extends NodeMaterialBlock {\r\n    private _repeatableContentAnchor: string;\r\n\r\n    /**\r\n     * Create a new MorphTargetsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MorphTargetsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the position output component\r\n     */\r\n    public get positionOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal output component\r\n     */\r\n    public get normalOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get tangentOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get uvOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"morphTargetInfluences\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\");\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\");\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areAttributesDirty) {\r\n            return;\r\n        }\r\n        MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\r\n            MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n        }\r\n    }\r\n\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        let position = this.position;\r\n        let normal = this.normal;\r\n        let tangent = this.tangent;\r\n        let uv = this.uv;\r\n        let positionOutput = this.positionOutput;\r\n        let normalOutput = this.normalOutput;\r\n        let tangentOutput = this.tangentOutput;\r\n        let uvOutput = this.uvOutput;\r\n        let state = vertexShaderState;\r\n        let repeatCount = defines.NUM_MORPH_INFLUENCERS as number;\r\n\r\n        var manager = (<Mesh>mesh).morphTargetManager;\r\n        var hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        var hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        var hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\r\n\r\n        let injectionCode = \"\";\r\n\r\n        for (var index = 0; index < repeatCount; index++) {\r\n            injectionCode += `#ifdef MORPHTARGETS\\r\\n`;\r\n            injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n\r\n            if (hasNormals) {\r\n                injectionCode += `#ifdef MORPHTARGETS_NORMAL\\r\\n`;\r\n                injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasTangents) {\r\n                injectionCode += `#ifdef MORPHTARGETS_TANGENT\\r\\n`;\r\n                injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasUVs) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV\\r\\n`;\r\n                injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\r\\n`;\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            injectionCode += `#endif\\r\\n`;\r\n        }\r\n\r\n        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\r\n\r\n        if (repeatCount > 0) {\r\n            for (var index = 0; index < repeatCount; index++) {\r\n                state.attributes.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (hasNormals) {\r\n                    state.attributes.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (hasTangents) {\r\n                    state.attributes.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (hasUVs) {\r\n                    state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Register for repeatable content generation\r\n        state.sharedData.repeatableContentBlocks.push(this);\r\n\r\n        // Emit code\r\n        let position = this.position;\r\n        let normal = this.normal;\r\n        let tangent = this.tangent;\r\n        let uv = this.uv;\r\n        let positionOutput = this.positionOutput;\r\n        let normalOutput = this.normalOutput;\r\n        let tangentOutput = this.tangentOutput;\r\n        let uvOutput = this.uvOutput;\r\n        let comments = `//${this.name}`;\r\n\r\n        state.uniforms.push(\"morphTargetInfluences\");\r\n\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\r\n            repeatKey: \"maxSimultaneousMorphTargets\"\r\n        });\r\n\r\n        state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#ifdef NORMAL\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef TANGENT\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef UV1\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        // Repeatable content\r\n        this._repeatableContentAnchor = state._repeatableContentAnchor;\r\n        state.compilationString += this._repeatableContentAnchor;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.MorphTargetsBlock\"] = MorphTargetsBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}