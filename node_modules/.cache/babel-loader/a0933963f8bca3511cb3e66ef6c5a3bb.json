{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { SerializationHelper } from \"../Misc/decorators\";\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { MaterialHelper } from \"./materialHelper\";\nimport { Material } from \"./material\";\nimport { _TypeStore } from '../Misc/typeStore';\nimport { Color3, Color4 } from '../Maths/math.color';\nimport { EffectFallbacks } from './effectFallbacks';\nimport { WebRequest } from '../Misc/webRequest';\nimport { Engine } from '../Engines/engine';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/shader_material\r\n */\n\nvar ShaderMaterial =\n/** @class */\nfunction (_super) {\n  __extends(ShaderMaterial, _super);\n  /**\r\n   * Instantiate a new shader material.\r\n   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n   * This returned material effects how the mesh will look based on the code in the shaders.\r\n   * @see https://doc.babylonjs.com/how_to/shader_material\r\n   * @param name Define the name of the material in the scene\r\n   * @param scene Define the scene the material belongs to\r\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n   *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n   *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n   *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n   *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n   * @param options Define the options used to create the shader\r\n   */\n\n\n  function ShaderMaterial(name, scene, shaderPath, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, name, scene) || this;\n\n    _this._textures = {};\n    _this._textureArrays = {};\n    _this._floats = {};\n    _this._ints = {};\n    _this._floatsArrays = {};\n    _this._colors3 = {};\n    _this._colors3Arrays = {};\n    _this._colors4 = {};\n    _this._colors4Arrays = {};\n    _this._vectors2 = {};\n    _this._vectors3 = {};\n    _this._vectors4 = {};\n    _this._matrices = {};\n    _this._matrixArrays = {};\n    _this._matrices3x3 = {};\n    _this._matrices2x2 = {};\n    _this._vectors2Arrays = {};\n    _this._vectors3Arrays = {};\n    _this._vectors4Arrays = {};\n    _this._cachedWorldViewMatrix = new Matrix();\n    _this._cachedWorldViewProjectionMatrix = new Matrix();\n    _this._multiview = false;\n    _this._shaderPath = shaderPath;\n    _this._options = __assign({\n      needAlphaBlending: false,\n      needAlphaTesting: false,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\"],\n      uniformBuffers: [],\n      samplers: [],\n      defines: []\n    }, options);\n    return _this;\n  }\n\n  Object.defineProperty(ShaderMaterial.prototype, \"shaderPath\", {\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\n    get: function () {\n      return this._shaderPath;\n    },\n\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\n    set: function (shaderPath) {\n      this._shaderPath = shaderPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ShaderMaterial.prototype, \"options\", {\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\n    get: function () {\n      return this._options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n   * Mainly use in serialization.\r\n   * @returns the class name\r\n   */\n\n  ShaderMaterial.prototype.getClassName = function () {\n    return \"ShaderMaterial\";\n  };\n  /**\r\n   * Specifies if the material will require alpha blending\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n\n  ShaderMaterial.prototype.needAlphaBlending = function () {\n    return this.alpha < 1.0 || this._options.needAlphaBlending;\n  };\n  /**\r\n   * Specifies if this material should be rendered in alpha test mode\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  ShaderMaterial.prototype.needAlphaTesting = function () {\n    return this._options.needAlphaTesting;\n  };\n\n  ShaderMaterial.prototype._checkUniform = function (uniformName) {\n    if (this._options.uniforms.indexOf(uniformName) === -1) {\n      this._options.uniforms.push(uniformName);\n    }\n  };\n  /**\r\n   * Set a texture in the shader.\r\n   * @param name Define the name of the uniform samplers as defined in the shader\r\n   * @param texture Define the texture to bind to this sampler\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setTexture = function (name, texture) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n\n    this._textures[name] = texture;\n    return this;\n  };\n  /**\r\n   * Set a texture array in the shader.\r\n   * @param name Define the name of the uniform sampler array as defined in the shader\r\n   * @param textures Define the list of textures to bind to this sampler\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setTextureArray = function (name, textures) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n\n    this._checkUniform(name);\n\n    this._textureArrays[name] = textures;\n    return this;\n  };\n  /**\r\n   * Set a float in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setFloat = function (name, value) {\n    this._checkUniform(name);\n\n    this._floats[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a int in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setInt = function (name, value) {\n    this._checkUniform(name);\n\n    this._ints[name] = value;\n    return this;\n  };\n  /**\r\n   * Set an array of floats in the shader.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setFloats = function (name, value) {\n    this._checkUniform(name);\n\n    this._floatsArrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Color3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 array in the shader from a Color3 array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor3Array = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors3Arrays[name] = value.reduce(function (arr, color) {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Color4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 array in the shader from a Color4 array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setColor4Array = function (name, value) {\n    this._checkUniform(name);\n\n    this._colors4Arrays[name] = value.reduce(function (arr, color) {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  };\n  /**\r\n   * Set a vec2 in the shader from a Vector2.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 in the shader from a Vector3.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 in the shader from a Vector4.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setVector4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors4[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat4 in the shader from a Matrix.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a float32Array in the shader from a matrix array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrices = function (name, value) {\n    this._checkUniform(name);\n\n    var float32Array = new Float32Array(value.length * 16);\n\n    for (var index = 0; index < value.length; index++) {\n      var matrix = value[index];\n      matrix.copyToArray(float32Array, index * 16);\n    }\n\n    this._matrixArrays[name] = float32Array;\n    return this;\n  };\n  /**\r\n   * Set a mat3 in the shader from a Float32Array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix3x3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices3x3[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a mat2 in the shader from a Float32Array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setMatrix2x2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._matrices2x2[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec2 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray2 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors2Arrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec3 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray3 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors3Arrays[name] = value;\n    return this;\n  };\n  /**\r\n   * Set a vec4 array in the shader from a number array.\r\n   * @param name Define the name of the uniform as defined in the shader\r\n   * @param value Define the value to give to the uniform\r\n   * @return the material itself allowing \"fluent\" like uniform updates\r\n   */\n\n\n  ShaderMaterial.prototype.setArray4 = function (name, value) {\n    this._checkUniform(name);\n\n    this._vectors4Arrays[name] = value;\n    return this;\n  };\n\n  ShaderMaterial.prototype._checkCache = function (mesh, useInstances) {\n    if (!mesh) {\n      return true;\n    }\n\n    if (this._effect && this._effect.defines.indexOf(\"#define INSTANCES\") !== -1 !== useInstances) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Specifies that the submesh is ready to be used\r\n   * @param mesh defines the mesh to check\r\n   * @param subMesh defines which submesh to check\r\n   * @param useInstances specifies that instances should be used\r\n   * @returns a boolean indicating that the submesh is ready or not\r\n   */\n\n\n  ShaderMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    return this.isReady(mesh, useInstances);\n  };\n  /**\r\n   * Checks if the material is ready to render the requested mesh\r\n   * @param mesh Define the mesh to render\r\n   * @param useInstances Define whether or not the material is used with instances\r\n   * @returns true if ready, otherwise false\r\n   */\n\n\n  ShaderMaterial.prototype.isReady = function (mesh, useInstances) {\n    var _a, _b;\n\n    if (this._effect && this.isFrozen) {\n      if (this._effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    var scene = this.getScene();\n    var engine = scene.getEngine();\n\n    if (!this.checkReadyOnEveryCall) {\n      if (this._renderId === scene.getRenderId()) {\n        if (this._checkCache(mesh, useInstances)) {\n          return true;\n        }\n      }\n    } // Instances\n\n\n    var defines = [];\n    var attribs = [];\n    var fallbacks = new EffectFallbacks(); // global multiview\n\n    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\n      this._multiview = true;\n      defines.push(\"#define MULTIVIEW\");\n\n      if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 && this._options.uniforms.push(\"viewProjectionR\") === -1) {\n        this._options.uniforms.push(\"viewProjectionR\");\n      }\n    }\n\n    for (var index = 0; index < this._options.defines.length; index++) {\n      defines.push(this._options.defines[index]);\n    }\n\n    for (var index = 0; index < this._options.attributes.length; index++) {\n      attribs.push(this._options.attributes[index]);\n    }\n\n    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXCOLOR\");\n    }\n\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n\n      if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    } // Bones\n\n\n    var numInfluencers = 0;\n\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n\n      var skeleton = mesh.skeleton;\n      numInfluencers = mesh.numBoneInfluencers;\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + numInfluencers);\n      fallbacks.addCPUSkinningFallback(0, mesh);\n\n      if (skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n\n        if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\n          this._options.uniforms.push(\"boneTextureWidth\");\n        }\n\n        if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\n          this._options.samplers.push(\"boneSampler\");\n        }\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n\n        if (this._options.uniforms.indexOf(\"mBones\") === -1) {\n          this._options.uniforms.push(\"mBones\");\n        }\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    } // Textures\n\n\n    for (var name in this._textures) {\n      if (!this._textures[name].isReady()) {\n        return false;\n      }\n    } // Alpha test\n\n\n    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\n      defines.push(\"#define ALPHATEST\");\n    }\n\n    var shaderName = this._shaderPath,\n        uniforms = this._options.uniforms,\n        uniformBuffers = this._options.uniformBuffers,\n        samplers = this._options.samplers;\n\n    if (this.customShaderNameResolve) {\n      uniforms = uniforms.slice();\n      uniformBuffers = uniformBuffers.slice();\n      samplers = samplers.slice();\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\n    }\n\n    var previousEffect = this._effect;\n    var join = defines.join(\"\\n\");\n\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      this._effect = engine.createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousMorphTargets: numInfluencers\n        }\n      }, engine);\n\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = this._effect;\n\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      }\n    }\n\n    if ((_b = !((_a = this._effect) === null || _a === void 0 ? void 0 : _a.isReady())) !== null && _b !== void 0 ? _b : true) {\n      return false;\n    }\n\n    if (previousEffect !== this._effect) {\n      scene.resetCachedMaterial();\n    }\n\n    this._renderId = scene.getRenderId();\n    this._effect._wasPreviouslyReady = true;\n    return true;\n  };\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   * @param effectOverride - If provided, use this effect instead of internal effect\r\n   */\n\n\n  ShaderMaterial.prototype.bindOnlyWorldMatrix = function (world, effectOverride) {\n    var scene = this.getScene();\n    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;\n\n    if (!effect) {\n      return;\n    }\n\n    if (this._options.uniforms.indexOf(\"world\") !== -1) {\n      effect.setMatrix(\"world\", world);\n    }\n\n    if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n      effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n    }\n\n    if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n      effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\n    }\n  };\n  /**\r\n   * Binds the submesh to this material by preparing the effect and shader to draw\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  ShaderMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    this.bind(world, mesh, subMesh._effectOverride);\n  };\n  /**\r\n   * Binds the material to the mesh\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh to bind the material to\r\n   * @param effectOverride - If provided, use this effect instead of internal effect\r\n   */\n\n\n  ShaderMaterial.prototype.bind = function (world, mesh, effectOverride) {\n    // Std values\n    this.bindOnlyWorldMatrix(world, effectOverride);\n    var effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this._effect;\n\n    if (effect && this.getScene().getCachedMaterial() !== this) {\n      if (this._options.uniforms.indexOf(\"view\") !== -1) {\n        effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n      }\n\n      if (this._options.uniforms.indexOf(\"projection\") !== -1) {\n        effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n      }\n\n      if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n        effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n\n        if (this._multiview) {\n          effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\n        }\n      }\n\n      if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\n        effect.setVector3(\"cameraPosition\", this.getScene().activeCamera.globalPosition);\n      } // Bones\n\n\n      MaterialHelper.BindBonesParameters(mesh, effect);\n      var name; // Texture\n\n      for (name in this._textures) {\n        effect.setTexture(name, this._textures[name]);\n      } // Texture arrays\n\n\n      for (name in this._textureArrays) {\n        effect.setTextureArray(name, this._textureArrays[name]);\n      } // Int\n\n\n      for (name in this._ints) {\n        effect.setInt(name, this._ints[name]);\n      } // Float\n\n\n      for (name in this._floats) {\n        effect.setFloat(name, this._floats[name]);\n      } // Floats\n\n\n      for (name in this._floatsArrays) {\n        effect.setArray(name, this._floatsArrays[name]);\n      } // Color3\n\n\n      for (name in this._colors3) {\n        effect.setColor3(name, this._colors3[name]);\n      } // Color3Array\n\n\n      for (name in this._colors3Arrays) {\n        effect.setArray3(name, this._colors3Arrays[name]);\n      } // Color4\n\n\n      for (name in this._colors4) {\n        var color = this._colors4[name];\n        effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      } // Color4Array\n\n\n      for (name in this._colors4Arrays) {\n        effect.setArray4(name, this._colors4Arrays[name]);\n      } // Vector2\n\n\n      for (name in this._vectors2) {\n        effect.setVector2(name, this._vectors2[name]);\n      } // Vector3\n\n\n      for (name in this._vectors3) {\n        effect.setVector3(name, this._vectors3[name]);\n      } // Vector4\n\n\n      for (name in this._vectors4) {\n        effect.setVector4(name, this._vectors4[name]);\n      } // Matrix\n\n\n      for (name in this._matrices) {\n        effect.setMatrix(name, this._matrices[name]);\n      } // MatrixArray\n\n\n      for (name in this._matrixArrays) {\n        effect.setMatrices(name, this._matrixArrays[name]);\n      } // Matrix 3x3\n\n\n      for (name in this._matrices3x3) {\n        effect.setMatrix3x3(name, this._matrices3x3[name]);\n      } // Matrix 2x2\n\n\n      for (name in this._matrices2x2) {\n        effect.setMatrix2x2(name, this._matrices2x2[name]);\n      } // Vector2Array\n\n\n      for (name in this._vectors2Arrays) {\n        effect.setArray2(name, this._vectors2Arrays[name]);\n      } // Vector3Array\n\n\n      for (name in this._vectors3Arrays) {\n        effect.setArray3(name, this._vectors3Arrays[name]);\n      } // Vector4Array\n\n\n      for (name in this._vectors4Arrays) {\n        effect.setArray4(name, this._vectors4Arrays[name]);\n      }\n    }\n\n    var seffect = this._effect;\n    this._effect = effect; // make sure the active effect is the right one if there are some observers for onBind that would need to get the current effect\n\n    this._afterBind(mesh);\n\n    this._effect = seffect;\n  };\n\n  ShaderMaterial.prototype._afterBind = function (mesh) {\n    _super.prototype._afterBind.call(this, mesh);\n\n    this.getScene()._cachedEffect = this._effect;\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  ShaderMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    for (var name in this._textures) {\n      activeTextures.push(this._textures[name]);\n    }\n\n    for (var name in this._textureArrays) {\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        activeTextures.push(array[index]);\n      }\n    }\n\n    return activeTextures;\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  ShaderMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    for (var name in this._textures) {\n      if (this._textures[name] === texture) {\n        return true;\n      }\n    }\n\n    for (var name in this._textureArrays) {\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        if (array[index] === texture) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Makes a duplicate of the material, and gives it a new name\r\n   * @param name defines the new name for the duplicated material\r\n   * @returns the cloned material\r\n   */\n\n\n  ShaderMaterial.prototype.clone = function (name) {\n    var _this = this;\n\n    var result = SerializationHelper.Clone(function () {\n      return new ShaderMaterial(name, _this.getScene(), _this._shaderPath, _this._options);\n    }, this);\n    result.name = name;\n    result.id = name; // Shader code path\n\n    if (typeof result._shaderPath === 'object') {\n      result._shaderPath = __assign({}, result._shaderPath);\n    } // Options\n\n\n    this._options = __assign({}, this._options);\n    Object.keys(this._options).forEach(function (propName) {\n      var propValue = _this._options[propName];\n\n      if (Array.isArray(propValue)) {\n        _this._options[propName] = propValue.slice(0);\n      }\n    }); // Texture\n\n    for (var key in this._textures) {\n      result.setTexture(key, this._textures[key]);\n    } // Float\n\n\n    for (var key in this._floats) {\n      result.setFloat(key, this._floats[key]);\n    } // Floats\n\n\n    for (var key in this._floatsArrays) {\n      result.setFloats(key, this._floatsArrays[key]);\n    } // Color3\n\n\n    for (var key in this._colors3) {\n      result.setColor3(key, this._colors3[key]);\n    } // Color4\n\n\n    for (var key in this._colors4) {\n      result.setColor4(key, this._colors4[key]);\n    } // Vector2\n\n\n    for (var key in this._vectors2) {\n      result.setVector2(key, this._vectors2[key]);\n    } // Vector3\n\n\n    for (var key in this._vectors3) {\n      result.setVector3(key, this._vectors3[key]);\n    } // Vector4\n\n\n    for (var key in this._vectors4) {\n      result.setVector4(key, this._vectors4[key]);\n    } // Matrix\n\n\n    for (var key in this._matrices) {\n      result.setMatrix(key, this._matrices[key]);\n    } // Matrix 3x3\n\n\n    for (var key in this._matrices3x3) {\n      result.setMatrix3x3(key, this._matrices3x3[key]);\n    } // Matrix 2x2\n\n\n    for (var key in this._matrices2x2) {\n      result.setMatrix2x2(key, this._matrices2x2[key]);\n    }\n\n    return result;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  ShaderMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      var name;\n\n      for (name in this._textures) {\n        this._textures[name].dispose();\n      }\n\n      for (name in this._textureArrays) {\n        var array = this._textureArrays[name];\n\n        for (var index = 0; index < array.length; index++) {\n          array[index].dispose();\n        }\n      }\n    }\n\n    this._textures = {};\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  };\n  /**\r\n   * Serializes this material in a JSON representation\r\n   * @returns the serialized material object\r\n   */\n\n\n  ShaderMaterial.prototype.serialize = function () {\n    var serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.ShaderMaterial\";\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    var name; // Texture\n\n    serializationObject.textures = {};\n\n    for (name in this._textures) {\n      serializationObject.textures[name] = this._textures[name].serialize();\n    } // Texture arrays\n\n\n    serializationObject.textureArrays = {};\n\n    for (name in this._textureArrays) {\n      serializationObject.textureArrays[name] = [];\n      var array = this._textureArrays[name];\n\n      for (var index = 0; index < array.length; index++) {\n        serializationObject.textureArrays[name].push(array[index].serialize());\n      }\n    } // Float\n\n\n    serializationObject.floats = {};\n\n    for (name in this._floats) {\n      serializationObject.floats[name] = this._floats[name];\n    } // Floats\n\n\n    serializationObject.FloatArrays = {};\n\n    for (name in this._floatsArrays) {\n      serializationObject.FloatArrays[name] = this._floatsArrays[name];\n    } // Color3\n\n\n    serializationObject.colors3 = {};\n\n    for (name in this._colors3) {\n      serializationObject.colors3[name] = this._colors3[name].asArray();\n    } // Color3 array\n\n\n    serializationObject.colors3Arrays = {};\n\n    for (name in this._colors3Arrays) {\n      serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\n    } // Color4\n\n\n    serializationObject.colors4 = {};\n\n    for (name in this._colors4) {\n      serializationObject.colors4[name] = this._colors4[name].asArray();\n    } // Color4 array\n\n\n    serializationObject.colors4Arrays = {};\n\n    for (name in this._colors4Arrays) {\n      serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\n    } // Vector2\n\n\n    serializationObject.vectors2 = {};\n\n    for (name in this._vectors2) {\n      serializationObject.vectors2[name] = this._vectors2[name].asArray();\n    } // Vector3\n\n\n    serializationObject.vectors3 = {};\n\n    for (name in this._vectors3) {\n      serializationObject.vectors3[name] = this._vectors3[name].asArray();\n    } // Vector4\n\n\n    serializationObject.vectors4 = {};\n\n    for (name in this._vectors4) {\n      serializationObject.vectors4[name] = this._vectors4[name].asArray();\n    } // Matrix\n\n\n    serializationObject.matrices = {};\n\n    for (name in this._matrices) {\n      serializationObject.matrices[name] = this._matrices[name].asArray();\n    } // MatrixArray\n\n\n    serializationObject.matrixArray = {};\n\n    for (name in this._matrixArrays) {\n      serializationObject.matrixArray[name] = this._matrixArrays[name];\n    } // Matrix 3x3\n\n\n    serializationObject.matrices3x3 = {};\n\n    for (name in this._matrices3x3) {\n      serializationObject.matrices3x3[name] = this._matrices3x3[name];\n    } // Matrix 2x2\n\n\n    serializationObject.matrices2x2 = {};\n\n    for (name in this._matrices2x2) {\n      serializationObject.matrices2x2[name] = this._matrices2x2[name];\n    } // Vector2Array\n\n\n    serializationObject.vectors2Arrays = {};\n\n    for (name in this._vectors2Arrays) {\n      serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\n    } // Vector3Array\n\n\n    serializationObject.vectors3Arrays = {};\n\n    for (name in this._vectors3Arrays) {\n      serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n    } // Vector4Array\n\n\n    serializationObject.vectors4Arrays = {};\n\n    for (name in this._vectors4Arrays) {\n      serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\n    }\n\n    return serializationObject;\n  };\n  /**\r\n   * Creates a shader material from parsed shader material data\r\n   * @param source defines the JSON represnetation of the material\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a new material\r\n   */\n\n\n  ShaderMaterial.Parse = function (source, scene, rootUrl) {\n    var material = SerializationHelper.Parse(function () {\n      return new ShaderMaterial(source.name, scene, source.shaderPath, source.options);\n    }, source, scene, rootUrl);\n    var name; // Texture\n\n    for (name in source.textures) {\n      material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));\n    } // Texture arrays\n\n\n    for (name in source.textureArrays) {\n      var array = source.textureArrays[name];\n      var textureArray = new Array();\n\n      for (var index = 0; index < array.length; index++) {\n        textureArray.push(Texture.Parse(array[index], scene, rootUrl));\n      }\n\n      material.setTextureArray(name, textureArray);\n    } // Float\n\n\n    for (name in source.floats) {\n      material.setFloat(name, source.floats[name]);\n    } // Float s\n\n\n    for (name in source.floatsArrays) {\n      material.setFloats(name, source.floatsArrays[name]);\n    } // Color3\n\n\n    for (name in source.colors3) {\n      material.setColor3(name, Color3.FromArray(source.colors3[name]));\n    } // Color3 arrays\n\n\n    for (name in source.colors3Arrays) {\n      var colors = source.colors3Arrays[name].reduce(function (arr, num, i) {\n        if (i % 3 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n\n        return arr;\n      }, []).map(function (color) {\n        return Color3.FromArray(color);\n      });\n      material.setColor3Array(name, colors);\n    } // Color4\n\n\n    for (name in source.colors4) {\n      material.setColor4(name, Color4.FromArray(source.colors4[name]));\n    } // Color4 arrays\n\n\n    for (name in source.colors4Arrays) {\n      var colors = source.colors4Arrays[name].reduce(function (arr, num, i) {\n        if (i % 4 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n\n        return arr;\n      }, []).map(function (color) {\n        return Color4.FromArray(color);\n      });\n      material.setColor4Array(name, colors);\n    } // Vector2\n\n\n    for (name in source.vectors2) {\n      material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\n    } // Vector3\n\n\n    for (name in source.vectors3) {\n      material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\n    } // Vector4\n\n\n    for (name in source.vectors4) {\n      material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\n    } // Matrix\n\n\n    for (name in source.matrices) {\n      material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\n    } // MatrixArray\n\n\n    for (name in source.matrixArray) {\n      material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\n    } // Matrix 3x3\n\n\n    for (name in source.matrices3x3) {\n      material.setMatrix3x3(name, source.matrices3x3[name]);\n    } // Matrix 2x2\n\n\n    for (name in source.matrices2x2) {\n      material.setMatrix2x2(name, source.matrices2x2[name]);\n    } // Vector2Array\n\n\n    for (name in source.vectors2Arrays) {\n      material.setArray2(name, source.vectors2Arrays[name]);\n    } // Vector3Array\n\n\n    for (name in source.vectors3Arrays) {\n      material.setArray3(name, source.vectors3Arrays[name]);\n    } // Vector4Array\n\n\n    for (name in source.vectors4Arrays) {\n      material.setArray4(name, source.vectors4Arrays[name]);\n    }\n\n    return material;\n  };\n  /**\r\n   * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new ShaderMaterial\r\n   */\n\n\n  ShaderMaterial.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var serializationObject = JSON.parse(request.responseText);\n\n            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            if (name) {\n              output.name = name;\n            }\n\n            resolve(output);\n          } else {\n            reject(\"Unable to load the ShaderMaterial\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n   * @param snippetId defines the snippet to load\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a promise that will resolve to the new ShaderMaterial\r\n   */\n\n\n  ShaderMaterial.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.shaderMaterial);\n\n            var output = _this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\n\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /** Define the Url to load snippets */\n\n\n  ShaderMaterial.SnippetUrl = \"https://snippet.babylonjs.com\";\n  return ShaderMaterial;\n}(Material);\n\nexport { ShaderMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;","map":{"version":3,"sources":["../../../sourceES6/core/Materials/shaderMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { WebRequest } from '../Misc/webRequest';\r\nimport { Engine } from '../Engines/engine';\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of unifrom names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/shader_material\r\n */\r\nexport class ShaderMaterial extends Material {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _renderId: number;\r\n    private _multiview: boolean = false;\r\n    private _cachedDefines: string;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/how_to/shader_material\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n     *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}) {\r\n        super(name, scene);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            defines: [],\r\n            ...options\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0) || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        let float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (var index = 0; index < value.length; index++) {\r\n            let matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _checkCache(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this._effect && (this._effect.defines.indexOf(\"#define INSTANCES\") !== -1) !== useInstances) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (this._effect && this.isFrozen) {\r\n            if (this._effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this.checkReadyOnEveryCall) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                if (this._checkCache(mesh, useInstances)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        var defines = [];\r\n        var attribs = [];\r\n        var fallbacks = new EffectFallbacks();\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview &&\r\n            scene.activeCamera &&\r\n            scene.activeCamera.outputRenderTarget &&\r\n            scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 &&\r\n                this._options.uniforms.push(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (var index = 0; index < this._options.defines.length; index++) {\r\n            defines.push(this._options.defines[index]);\r\n        }\r\n\r\n        for (var index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        let numInfluencers = 0;\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            numInfluencers = mesh.numBoneInfluencers;\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + numInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Textures\r\n        for (var name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        var previousEffect = this._effect;\r\n        var join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            this._effect = engine.createEffect(shaderName, <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousMorphTargets: numInfluencers }\r\n            }, engine);\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = this._effect;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        if (!this._effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== this._effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        this._effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        var scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._effectOverride);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>): void {\r\n        // Std values\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (effect && this.getScene().getCachedMaterial() !== this) {\r\n            if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            var name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                var color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n        }\r\n\r\n        const seffect = this._effect;\r\n\r\n        this._effect = effect; // make sure the active effect is the right one if there are some observers for onBind that would need to get the current effect\r\n        this._afterBind(mesh);\r\n        this._effect = seffect;\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh): void {\r\n        super._afterBind(mesh);\r\n        this.getScene()._cachedEffect = this._effect;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        for (var name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (var name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        var result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === 'object') {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Texture\r\n        for (var key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // Float\r\n        for (var key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (var key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (var key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color4\r\n        for (var key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Vector2\r\n        for (var key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (var key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (var key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Matrix\r\n        for (var key in this._matrices) {\r\n            result.setMatrix(key,  this._matrices[key]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (var key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (var key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n\r\n        if (forceDisposeTextures) {\r\n            var name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                var array = this._textureArrays[name];\r\n                for (var index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON represnetation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        var material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            var array = source.textureArrays[name];\r\n            var textureArray = new Array<Texture>();\r\n\r\n            for (var index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Float s\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 3 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 4 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        let serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}