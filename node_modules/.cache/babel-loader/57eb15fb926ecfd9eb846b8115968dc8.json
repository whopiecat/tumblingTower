{"ast":null,"code":"import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\nimport { Color4 } from '../../Maths/math.color';\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { Scene } from \"../../scene\";\nimport { Axis } from '../../Maths/math.axis';\n\nVertexData.CreateCylinder = function (options) {\n  var height = options.height || 2;\n  var diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n  var diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n  diameterTop = diameterTop || 0.00001; // Prevent broken normals\n\n  diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n\n  var tessellation = options.tessellation || 24;\n  var subdivisions = options.subdivisions || 1;\n  var hasRings = options.hasRings ? true : false;\n  var enclose = options.enclose ? true : false;\n  var cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n  var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  var faceUV = options.faceUV || new Array(3);\n  var faceColors = options.faceColors; // default face colors and UV if undefined\n\n  var quadNb = arc !== 1 && enclose ? 2 : 0;\n  var ringNb = hasRings ? subdivisions : 1;\n  var surfaceNb = 2 + (1 + quadNb) * ringNb;\n  var f;\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceUV && faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n  }\n\n  var indices = new Array();\n  var positions = new Array();\n  var normals = new Array();\n  var uvs = new Array();\n  var colors = new Array();\n  var angle_step = Math.PI * 2 * arc / tessellation;\n  var angle;\n  var h;\n  var radius;\n  var tan = (diameterBottom - diameterTop) / 2 / height;\n  var ringVertex = Vector3.Zero();\n  var ringNormal = Vector3.Zero();\n  var ringFirstVertex = Vector3.Zero();\n  var ringFirstNormal = Vector3.Zero();\n  var quadNormal = Vector3.Zero();\n  var Y = Axis.Y; // positions, normals, uvs\n\n  var i;\n  var j;\n  var r;\n  var ringIdx = 1;\n  var s = 1; // surface index\n\n  var cs = 0;\n  var v = 0;\n\n  for (i = 0; i <= subdivisions; i++) {\n    h = i / subdivisions;\n    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n\n    for (r = 0; r < ringIdx; r++) {\n      if (hasRings) {\n        s += r;\n      }\n\n      if (enclose) {\n        s += 2 * r;\n      }\n\n      for (j = 0; j <= tessellation; j++) {\n        angle = j * angle_step; // position\n\n        ringVertex.x = Math.cos(-angle) * radius;\n        ringVertex.y = -height / 2 + h * height;\n        ringVertex.z = Math.sin(-angle) * radius; // normal\n\n        if (diameterTop === 0 && i === subdivisions) {\n          // if no top cap, reuse former normals\n          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n        } else {\n          ringNormal.x = ringVertex.x;\n          ringNormal.z = ringVertex.z;\n          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n          ringNormal.normalize();\n        } // keep first ring vertex values for enclose\n\n\n        if (j === 0) {\n          ringFirstVertex.copyFrom(ringVertex);\n          ringFirstNormal.copyFrom(ringNormal);\n        }\n\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s].y : faceUV[s].w;\n        } else {\n          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n        }\n\n        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);\n\n        if (faceColors) {\n          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n        }\n      } // if enclose, add four vertices and their dedicated normals\n\n\n      if (arc !== 1 && enclose) {\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n        Vector3.CrossToRef(Y, ringNormal, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n        } else {\n          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n        }\n\n        uvs.push(faceUV[s + 1].x, v);\n        uvs.push(faceUV[s + 1].z, v);\n\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n        } else {\n          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n        }\n\n        uvs.push(faceUV[s + 2].x, v);\n        uvs.push(faceUV[s + 2].z, v);\n\n        if (faceColors) {\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n        }\n      }\n\n      if (cs !== s) {\n        cs = s;\n      }\n    }\n  } // indices\n\n\n  var e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n\n  var s;\n  i = 0;\n\n  for (s = 0; s < subdivisions; s++) {\n    var i0 = 0;\n    var i1 = 0;\n    var i2 = 0;\n    var i3 = 0;\n\n    for (j = 0; j < tessellation; j++) {\n      i0 = i * (e + 1) + j;\n      i1 = (i + 1) * (e + 1) + j;\n      i2 = i * (e + 1) + (j + 1);\n      i3 = (i + 1) * (e + 1) + (j + 1);\n      indices.push(i0, i1, i2);\n      indices.push(i3, i2, i1);\n    }\n\n    if (arc !== 1 && enclose) {\n      // if enclose, add two quads\n      indices.push(i0 + 2, i1 + 2, i2 + 2);\n      indices.push(i3 + 2, i2 + 2, i1 + 2);\n      indices.push(i0 + 4, i1 + 4, i2 + 4);\n      indices.push(i3 + 4, i2 + 4, i1 + 4);\n    }\n\n    i = hasRings ? i + 2 : i + 1;\n  } // Caps\n\n\n  var createCylinderCap = function (isTop) {\n    var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n\n    if (radius === 0) {\n      return;\n    } // Cap positions, normals & uvs\n\n\n    var angle;\n    var circleVector;\n    var i;\n    var u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n    var c = null;\n\n    if (faceColors) {\n      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n    } // cap center\n\n\n    var vbase = positions.length / 3;\n    var offset = isTop ? height / 2 : -height / 2;\n    var center = new Vector3(0, offset, 0);\n    positions.push(center.x, center.y, center.z);\n    normals.push(0, isTop ? 1 : -1, 0);\n    uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);\n\n    if (c) {\n      colors.push(c.r, c.g, c.b, c.a);\n    }\n\n    var textureScale = new Vector2(0.5, 0.5);\n\n    for (i = 0; i <= tessellation; i++) {\n      angle = Math.PI * 2 * i * arc / tessellation;\n      var cos = Math.cos(-angle);\n      var sin = Math.sin(-angle);\n      circleVector = new Vector3(cos * radius, offset, sin * radius);\n      var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n      positions.push(circleVector.x, circleVector.y, circleVector.z);\n      normals.push(0, isTop ? 1 : -1, 0);\n      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);\n\n      if (c) {\n        colors.push(c.r, c.g, c.b, c.a);\n      }\n    } // Cap indices\n\n\n    for (i = 0; i < tessellation; i++) {\n      if (!isTop) {\n        indices.push(vbase);\n        indices.push(vbase + (i + 1));\n        indices.push(vbase + (i + 2));\n      } else {\n        indices.push(vbase);\n        indices.push(vbase + (i + 2));\n        indices.push(vbase + (i + 1));\n      }\n    }\n  }; // add caps to geometry based on cap parameter\n\n\n  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n    createCylinderCap(false);\n  }\n\n  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n    createCylinderCap(true);\n  } // Sides\n\n\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n\n  var vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n\n  if (faceColors) {\n    vertexData.colors = colors;\n  }\n\n  return vertexData;\n};\n\nMesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\n  if (scene === undefined || !(scene instanceof Scene)) {\n    if (scene !== undefined) {\n      sideOrientation = updatable || Mesh.DEFAULTSIDE;\n      updatable = scene;\n    }\n\n    scene = subdivisions;\n    subdivisions = 1;\n  }\n\n  var options = {\n    height: height,\n    diameterTop: diameterTop,\n    diameterBottom: diameterBottom,\n    tessellation: tessellation,\n    subdivisions: subdivisions,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CylinderBuilder.CreateCylinder(name, options, scene);\n};\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\n\n\nvar CylinderBuilder =\n/** @class */\nfunction () {\n  function CylinderBuilder() {}\n  /**\r\n   * Creates a cylinder or a cone mesh\r\n   * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n   * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n   * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n   * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n   * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n   * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n   * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n   * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n   * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n   * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n   * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n   * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n   * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n   * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n   * * If `enclose` is false, a ring surface is one element.\r\n   * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n   * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n   * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n   * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n   * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n   * @param name defines the name of the mesh\r\n   * @param options defines the options used to create the mesh\r\n   * @param scene defines the hosting scene\r\n   * @returns the cylinder mesh\r\n   * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n   */\n\n\n  CylinderBuilder.CreateCylinder = function (name, options, scene) {\n    var cylinder = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = VertexData.CreateCylinder(options);\n    vertexData.applyToMesh(cylinder, options.updatable);\n    return cylinder;\n  };\n\n  return CylinderBuilder;\n}();\n\nexport { CylinderBuilder };","map":{"version":3,"sources":["../../../../sourceES6/core/Meshes/Builders/cylinderBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Axis } from '../../Maths/math.axis';\r\n\r\nVertexData.CreateCylinder = function(options: { height?: number, diameterTop?: number, diameterBottom?: number, diameter?: number, tessellation?: number, subdivisions?: number, arc?: number, faceColors?: Color4[], faceUV?: Vector4[], hasRings?: boolean, enclose?: boolean, cap?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var height: number = options.height || 2;\r\n    var diameterTop: number = (options.diameterTop === 0) ? 0 : options.diameterTop || options.diameter || 1;\r\n    var diameterBottom: number = (options.diameterBottom === 0) ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    var tessellation: number = options.tessellation || 24;\r\n    var subdivisions: number = options.subdivisions || 1;\r\n    var hasRings: boolean = options.hasRings ? true : false;\r\n    var enclose: boolean = options.enclose ? true : false;\r\n    var cap = (options.cap === 0) ? 0 : options.cap || Mesh.CAP_ALL;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var sideOrientation: number = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    var faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    var quadNb: number = (arc !== 1 && enclose) ? 2 : 0;\r\n    var ringNb: number = (hasRings) ? subdivisions : 1;\r\n    var surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    var f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n    var colors = new Array<number>();\r\n\r\n    var angle_step = Math.PI * 2 * arc / tessellation;\r\n    var angle: number;\r\n    var h: number;\r\n    var radius: number;\r\n    var tan = (diameterBottom - diameterTop) / 2 / height;\r\n    var ringVertex: Vector3 = Vector3.Zero();\r\n    var ringNormal: Vector3 = Vector3.Zero();\r\n    var ringFirstVertex: Vector3 = Vector3.Zero();\r\n    var ringFirstNormal: Vector3 = Vector3.Zero();\r\n    var quadNormal: Vector3 = Vector3.Zero();\r\n    var Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    var i: number;\r\n    var j: number;\r\n    var r: number;\r\n    var ringIdx: number = 1;\r\n    var s: number = 1;      // surface index\r\n    var cs: number = 0;\r\n    var v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = (hasRings && i !== 0 && i !== subdivisions) ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angle_step;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                }\r\n                else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, v);\r\n                uvs.push(faceUV[s + 1].z, v);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, v);\r\n                uvs.push(faceUV[s + 2].z, v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // indices\r\n    var e: number = (arc !== 1 && enclose) ? tessellation + 4 : tessellation;     // correction of number of iteration if enclose\r\n    var s: number;\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {      // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = (hasRings) ? (i + 2) : (i + 1);\r\n    }\r\n\r\n    // Caps\r\n    var createCylinderCap = (isTop: boolean) => {\r\n        var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        var angle;\r\n        var circleVector;\r\n        var i: number;\r\n        var u: Vector4 = (isTop) ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        var c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = (isTop) ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        var vbase = positions.length / 3;\r\n        var offset = isTop ? height / 2 : -height / 2;\r\n        var center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        var textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = Math.PI * 2 * i * arc / tessellation;\r\n            var cos = Math.cos(-angle);\r\n            var sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            }\r\n            else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if ((cap === Mesh.CAP_START)\r\n        || (cap === Mesh.CAP_ALL)) {\r\n        createCylinderCap(false);\r\n    }\r\n    if ((cap === Mesh.CAP_END)\r\n        || (cap === Mesh.CAP_ALL)) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateCylinder = (name: string, height: number, diameterTop: number, diameterBottom: number, tessellation: number, subdivisions: any, scene?: Scene, updatable?: any, sideOrientation?: number): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    var options = {\r\n        height: height,\r\n        diameterTop: diameterTop,\r\n        diameterBottom: diameterBottom,\r\n        tessellation: tessellation,\r\n        subdivisions: subdivisions,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return CylinderBuilder.CreateCylinder(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class CylinderBuilder {\r\n    /**\r\n     * Creates a cylinder or a cone mesh\r\n     * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n     * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n     * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n     * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n     * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n     * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n     * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n     * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n     * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n     * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n     * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n     * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n     * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n     * * If `enclose` is false, a ring surface is one element.\r\n     * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n     * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the cylinder mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n     */\r\n    public static CreateCylinder(name: string, options: { height?: number, diameterTop?: number, diameterBottom?: number, diameter?: number, tessellation?: number, subdivisions?: number, arc?: number, faceColors?: Color4[], faceUV?: Vector4[], updatable?: boolean, hasRings?: boolean, enclose?: boolean, cap?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: any): Mesh {\r\n        var cylinder = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateCylinder(options);\r\n\r\n        vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n        return cylinder;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}