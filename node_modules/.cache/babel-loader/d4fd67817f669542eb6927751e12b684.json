{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\n/**\r\n * Class used to host texture specific utilities\r\n */\n\nvar TextureTools =\n/** @class */\nfunction () {\n  function TextureTools() {}\n  /**\r\n   * Uses the GPU to create a copy texture rescaled at a given size\r\n   * @param texture Texture to copy from\r\n   * @param width defines the desired width\r\n   * @param height defines the desired height\r\n   * @param useBilinearMode defines if bilinear mode has to be used\r\n   * @return the generated texture\r\n   */\n\n\n  TextureTools.CreateResizedCopy = function (texture, width, height, useBilinearMode) {\n    if (useBilinearMode === void 0) {\n      useBilinearMode = true;\n    }\n\n    var scene = texture.getScene();\n    var engine = scene.getEngine();\n    var rtt = new RenderTargetTexture('resized' + texture.name, {\n      width: width,\n      height: height\n    }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);\n    rtt.wrapU = texture.wrapU;\n    rtt.wrapV = texture.wrapV;\n    rtt.uOffset = texture.uOffset;\n    rtt.vOffset = texture.vOffset;\n    rtt.uScale = texture.uScale;\n    rtt.vScale = texture.vScale;\n    rtt.uAng = texture.uAng;\n    rtt.vAng = texture.vAng;\n    rtt.wAng = texture.wAng;\n    rtt.coordinatesIndex = texture.coordinatesIndex;\n    rtt.level = texture.level;\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n    rtt._texture.isReady = false;\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    var passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\n    passPostProcess.getEffect().executeWhenCompiled(function () {\n      passPostProcess.onApply = function (effect) {\n        effect.setTexture(\"textureSampler\", texture);\n      };\n\n      var internalTexture = rtt.getInternalTexture();\n\n      if (internalTexture) {\n        scene.postProcessManager.directRender([passPostProcess], internalTexture);\n        engine.unBindFramebuffer(internalTexture);\n        rtt.disposeFramebufferObjects();\n        passPostProcess.dispose();\n        internalTexture.isReady = true;\n      }\n    });\n    return rtt;\n  };\n\n  return TextureTools;\n}();\n\nexport { TextureTools };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/textureTools.ts"],"names":[],"mappings":"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","sourcesContent":["import { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\n\r\nimport { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport class TextureTools {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @return the generated texture\r\n     */\r\n    public static CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n\r\n        var scene = <Scene>texture.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        let rtt = new RenderTargetTexture(\r\n            'resized' + texture.name,\r\n            { width: width, height: height },\r\n            scene,\r\n            !texture.noMipmap,\r\n            true,\r\n            (<InternalTexture>texture._texture).type,\r\n            false,\r\n            texture.samplingMode,\r\n            false\r\n        );\r\n\r\n        rtt.wrapU = texture.wrapU;\r\n        rtt.wrapV = texture.wrapV;\r\n        rtt.uOffset = texture.uOffset;\r\n        rtt.vOffset = texture.vOffset;\r\n        rtt.uScale = texture.uScale;\r\n        rtt.vScale = texture.vScale;\r\n        rtt.uAng = texture.uAng;\r\n        rtt.vAng = texture.vAng;\r\n        rtt.wAng = texture.wAng;\r\n        rtt.coordinatesIndex = texture.coordinatesIndex;\r\n        rtt.level = texture.level;\r\n        rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n        (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        let passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\r\n        passPostProcess.getEffect().executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function(effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            let internalTexture = rtt.getInternalTexture();\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                internalTexture.isReady = true;\r\n            }\r\n        });\r\n\r\n        return rtt;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}