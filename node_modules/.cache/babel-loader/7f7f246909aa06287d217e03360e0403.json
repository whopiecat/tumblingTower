{"ast":null,"code":"import { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer\";\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\n  get: function () {\n    this._geometryBufferRenderer;\n  },\n  set: function (value) {\n    if (value && value.isSupported) {\n      this._geometryBufferRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n\nScene.prototype.enableGeometryBufferRenderer = function (ratio) {\n  if (ratio === void 0) {\n    ratio = 1;\n  }\n\n  if (this._geometryBufferRenderer) {\n    return this._geometryBufferRenderer;\n  }\n\n  this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio);\n\n  if (!this._geometryBufferRenderer.isSupported) {\n    this._geometryBufferRenderer = null;\n  }\n\n  return this._geometryBufferRenderer;\n};\n\nScene.prototype.disableGeometryBufferRenderer = function () {\n  if (!this._geometryBufferRenderer) {\n    return;\n  }\n\n  this._geometryBufferRenderer.dispose();\n\n  this._geometryBufferRenderer = null;\n};\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\n\n\nvar GeometryBufferRendererSceneComponent =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of the component for the given scene\r\n   * @param scene Defines the scene to register the component in\r\n   */\n  function GeometryBufferRendererSceneComponent(scene) {\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\n    this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\n    this.scene = scene;\n  }\n  /**\r\n   * Registers the component in a given scene\r\n   */\n\n\n  GeometryBufferRendererSceneComponent.prototype.register = function () {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\n  };\n  /**\r\n   * Rebuilds the elements related to this component in case of\r\n   * context lost for instance.\r\n   */\n\n\n  GeometryBufferRendererSceneComponent.prototype.rebuild = function () {// Nothing to do for this component\n  };\n  /**\r\n   * Disposes the component and the associated ressources\r\n   */\n\n\n  GeometryBufferRendererSceneComponent.prototype.dispose = function () {// Nothing to do for this component\n  };\n\n  GeometryBufferRendererSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {\n    if (this.scene._geometryBufferRenderer) {\n      renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\n    }\n  };\n\n  return GeometryBufferRendererSceneComponent;\n}();\n\nexport { GeometryBufferRendererSceneComponent };\n\nGeometryBufferRenderer._SceneComponentInitialization = function (scene) {\n  // Register the G Buffer component to the scene.\n  var component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);\n\n  if (!component) {\n    component = new GeometryBufferRendererSceneComponent(scene);\n\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"sources":["../../../sourceES6/core/Rendering/geometryBufferRendererSceneComponent.ts"],"names":[],"mappings":"AACA,SAAS,KAAT,QAAsB,UAAtB;AACA,SAA0B,uBAA1B,QAAyD,mBAAzD;AAGA,SAAS,sBAAT,QAAuC,0BAAvC;AA0BA,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAC,SAA5B,EAAuC,wBAAvC,EAAiE;AAC7D,EAAA,GAAG,EAAE,YAAA;AACD,SAAK,uBAAL;AACH,GAH4D;AAI7D,EAAA,GAAG,EAAE,UAAsB,KAAtB,EAA6D;AAC9D,QAAI,KAAK,IAAI,KAAK,CAAC,WAAnB,EAAgC;AAC5B,WAAK,uBAAL,GAA+B,KAA/B;AACH;AACJ,GAR4D;AAS7D,EAAA,UAAU,EAAE,IATiD;AAU7D,EAAA,YAAY,EAAE;AAV+C,CAAjE;;AAaA,KAAK,CAAC,SAAN,CAAgB,4BAAhB,GAA+C,UAAS,KAAT,EAA0B;AAAjB,MAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,KAAA,GAAA,CAAA;AAAiB;;AACrE,MAAI,KAAK,uBAAT,EAAkC;AAC9B,WAAO,KAAK,uBAAZ;AACH;;AAED,OAAK,uBAAL,GAA+B,IAAI,sBAAJ,CAA2B,IAA3B,EAAiC,KAAjC,CAA/B;;AACA,MAAI,CAAC,KAAK,uBAAL,CAA6B,WAAlC,EAA+C;AAC3C,SAAK,uBAAL,GAA+B,IAA/B;AACH;;AAED,SAAO,KAAK,uBAAZ;AACH,CAXD;;AAaA,KAAK,CAAC,SAAN,CAAgB,6BAAhB,GAAgD,YAAA;AAC5C,MAAI,CAAC,KAAK,uBAAV,EAAmC;AAC/B;AACH;;AAED,OAAK,uBAAL,CAA6B,OAA7B;;AACA,OAAK,uBAAL,GAA+B,IAA/B;AACH,CAPD;AASA;;;;;;AAIA,IAAA,oCAAA;AAAA;AAAA,YAAA;AAWI;;;;AAIA,WAAA,oCAAA,CAAY,KAAZ,EAAwB;AAdxB;;;AAGgB,SAAA,IAAA,GAAO,uBAAuB,CAAC,2BAA/B;AAYZ,SAAK,KAAL,GAAa,KAAb;AACH;AAED;;;;;AAGO,EAAA,oCAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,SAAK,KAAL,CAAW,yBAAX,CAAqC,YAArC,CAAkD,uBAAuB,CAAC,+CAA1E,EAA2H,IAA3H,EAAiI,KAAK,oBAAtI;AACH,GAFM;AAIP;;;;;;AAIO,EAAA,oCAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACI;AACH,GAFM;AAIP;;;;;AAGO,EAAA,oCAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACI;AACH,GAFM;;AAIC,EAAA,oCAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,aAA7B,EAAsF;AAClF,QAAI,KAAK,KAAL,CAAW,uBAAf,EAAwC;AACpC,MAAA,aAAa,CAAC,IAAd,CAAmB,KAAK,KAAL,CAAW,uBAAX,CAAmC,UAAnC,EAAnB;AACH;AACJ,GAJO;;AAKZ,SAAA,oCAAA;AAAC,CA9CD,EAAA;;;;AAgDA,sBAAsB,CAAC,6BAAvB,GAAuD,UAAC,KAAD,EAAa;AAChE;AACA,MAAI,SAAS,GAAG,KAAK,CAAC,aAAN,CAAoB,uBAAuB,CAAC,2BAA5C,CAAhB;;AACA,MAAI,CAAC,SAAL,EAAgB;AACZ,IAAA,SAAS,GAAG,IAAI,oCAAJ,CAAyC,KAAzC,CAAZ;;AACA,IAAA,KAAK,CAAC,aAAN,CAAoB,SAApB;AACH;AACJ,CAPD","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden (Backing field) */\r\n        _geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Gets or Sets the current geometry buffer associated to the scene.\r\n         */\r\n        geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Enables a GeometryBufferRender and associates it with the scene\r\n         * @param ratio defines the scaling ratio to apply to the renderer (1 by default which means same resolution)\r\n         * @returns the GeometryBufferRenderer\r\n         */\r\n        enableGeometryBufferRenderer(ratio?: number): Nullable<GeometryBufferRenderer>;\r\n\r\n        /**\r\n         * Disables the GeometryBufferRender associated with the scene\r\n         */\r\n        disableGeometryBufferRenderer(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\r\n    get: function(this: Scene) {\r\n        this._geometryBufferRenderer;\r\n    },\r\n    set: function(this: Scene, value: Nullable<GeometryBufferRenderer>) {\r\n        if (value && value.isSupported) {\r\n            this._geometryBufferRenderer = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\nScene.prototype.enableGeometryBufferRenderer = function(ratio: number = 1): Nullable<GeometryBufferRenderer> {\r\n    if (this._geometryBufferRenderer) {\r\n        return this._geometryBufferRenderer;\r\n    }\r\n\r\n    this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio);\r\n    if (!this._geometryBufferRenderer.isSupported) {\r\n        this._geometryBufferRenderer = null;\r\n    }\r\n\r\n    return this._geometryBufferRenderer;\r\n};\r\n\r\nScene.prototype.disableGeometryBufferRenderer = function(): void {\r\n    if (!this._geometryBufferRenderer) {\r\n        return;\r\n    }\r\n\r\n    this._geometryBufferRenderer.dispose();\r\n    this._geometryBufferRenderer = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class GeometryBufferRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._geometryBufferRenderer) {\r\n            renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\r\n        }\r\n    }\r\n}\r\n\r\nGeometryBufferRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER) as GeometryBufferRendererSceneComponent;\r\n    if (!component) {\r\n        component = new GeometryBufferRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}