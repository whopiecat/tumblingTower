{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\nimport { Gamepad } from \"../../Gamepads/gamepad\";\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\nimport { Node } from \"../../node\";\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\nimport { Logger } from '../../Misc/logger';\nimport { VRMultiviewToSingleviewPostProcess } from '../../PostProcesses/vrMultiviewToSingleviewPostProcess'; // Side effect import to define the stereoscopic mode.\n\nimport \"../RigModes/webVRRigMode\"; // Side effect import to add webvr support to engine\n\nimport \"../../Engines/Extensions/engine.webVR\";\nimport { Tools } from '../../Misc/tools';\nNode.AddNodeConstructor(\"WebVRFreeCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", function (name, scene) {\n  return function () {\n    return new WebVRFreeCamera(name, Vector3.Zero(), scene);\n  };\n});\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @example https://doc.babylonjs.com/how_to/webvr_camera\r\n */\n\nvar WebVRFreeCamera =\n/** @class */\nfunction (_super) {\n  __extends(WebVRFreeCamera, _super);\n  /**\r\n   * Instantiates a WebVRFreeCamera.\r\n   * @param name The name of the WebVRFreeCamera\r\n   * @param position The starting anchor position for the camera\r\n   * @param scene The scene the camera belongs to\r\n   * @param webVROptions a set of customizable options for the webVRCamera\r\n   */\n\n\n  function WebVRFreeCamera(name, position, scene, webVROptions) {\n    if (webVROptions === void 0) {\n      webVROptions = {};\n    }\n\n    var _this = _super.call(this, name, position, scene) || this;\n\n    _this.webVROptions = webVROptions;\n    /**\r\n     * @hidden\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\n\n    _this._vrDevice = null;\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\n\n    _this.rawPose = null;\n    _this._specsVersion = \"1.1\";\n    _this._attached = false;\n    _this._descendants = []; // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n\n    _this._deviceRoomPosition = Vector3.Zero();\n    /** @hidden */\n\n    _this._deviceRoomRotationQuaternion = Quaternion.Identity();\n    _this._standingMatrix = null;\n    /**\r\n     * Represents device position in babylon space.\r\n     */\n\n    _this.devicePosition = Vector3.Zero();\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\n\n    _this.deviceRotationQuaternion = Quaternion.Identity();\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\n\n    _this.deviceScaleFactor = 1;\n    _this._deviceToWorld = Matrix.Identity();\n    _this._worldToDevice = Matrix.Identity();\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\n\n    _this.controllers = [];\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\n\n    _this.onControllersAttachedObservable = new Observable();\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\n\n    _this.onControllerMeshLoadedObservable = new Observable();\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\n\n    _this.onPoseUpdatedFromDeviceObservable = new Observable();\n    _this._poseSet = false;\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\n\n    _this.rigParenting = true;\n    _this._defaultHeight = undefined;\n\n    _this._detachIfAttached = function () {\n      var vrDisplay = _this.getEngine().getVRDevice();\n\n      if (vrDisplay && !vrDisplay.isPresenting) {\n        _this.detachControl();\n      }\n    };\n\n    _this._workingVector = Vector3.Zero();\n    _this._oneVector = Vector3.One();\n    _this._workingMatrix = Matrix.Identity();\n    _this._tmpMatrix = new Matrix();\n    _this._cache.position = Vector3.Zero();\n\n    if (webVROptions.defaultHeight) {\n      _this._defaultHeight = webVROptions.defaultHeight;\n      _this.position.y = _this._defaultHeight;\n    }\n\n    _this.minZ = 0.1; //legacy support - the compensation boolean was removed.\n\n    if (arguments.length === 5) {\n      _this.webVROptions = arguments[4];\n    } // default webVR options\n\n\n    if (_this.webVROptions.trackPosition == undefined) {\n      _this.webVROptions.trackPosition = true;\n    }\n\n    if (_this.webVROptions.controllerMeshes == undefined) {\n      _this.webVROptions.controllerMeshes = true;\n    }\n\n    if (_this.webVROptions.defaultLightingOnControllers == undefined) {\n      _this.webVROptions.defaultLightingOnControllers = true;\n    }\n\n    _this.rotationQuaternion = new Quaternion();\n\n    if (_this.webVROptions && _this.webVROptions.positionScale) {\n      _this.deviceScaleFactor = _this.webVROptions.positionScale;\n    } //enable VR\n\n\n    var engine = _this.getEngine();\n\n    _this._onVREnabled = function (success) {\n      if (success) {\n        _this.initControllers();\n      }\n    };\n\n    engine.onVRRequestPresentComplete.add(_this._onVREnabled);\n    engine.initWebVR().add(function (event) {\n      if (!event.vrDisplay || _this._vrDevice === event.vrDisplay) {\n        return;\n      }\n\n      _this._vrDevice = event.vrDisplay; //reset the rig parameters.\n\n      _this.setCameraRigMode(Camera.RIG_MODE_WEBVR, {\n        parentCamera: _this,\n        vrDisplay: _this._vrDevice,\n        frameData: _this._frameData,\n        specs: _this._specsVersion\n      });\n\n      if (_this._attached) {\n        _this.getEngine().enableVR(_this.webVROptions);\n      }\n    });\n\n    if (typeof VRFrameData !== \"undefined\") {\n      _this._frameData = new VRFrameData();\n    }\n\n    if (webVROptions.useMultiview) {\n      if (!_this.getScene().getEngine().getCaps().multiview) {\n        Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n        _this._useMultiviewToSingleView = false;\n      } else {\n        _this._useMultiviewToSingleView = true;\n        _this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", _this, 1.0);\n      }\n    }\n    /**\r\n     * The idea behind the following lines:\r\n     * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n     * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n     * the second will not show it correctly.\r\n     *\r\n     * To solve this - each object that has the camera as parent will be added to a protected array.\r\n     * When the rig camera renders, it will take this array and set all of those to be its children.\r\n     * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n     * Amazing!\r\n     */\n\n\n    scene.onBeforeCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants = _this.getDescendants(true, function (n) {\n          // don't take the cameras or the controllers!\n          var isController = _this.controllers.some(function (controller) {\n            return controller._mesh === n;\n          });\n\n          var isRigCamera = _this._rigCameras.indexOf(n) !== -1;\n          return !isController && !isRigCamera;\n        });\n\n        _this._descendants.forEach(function (node) {\n          node.parent = camera;\n        });\n      }\n    });\n    scene.onAfterCameraRenderObservable.add(function (camera) {\n      if (camera.parent === _this && _this.rigParenting) {\n        _this._descendants.forEach(function (node) {\n          node.parent = _this;\n        });\n      }\n    });\n    return _this;\n  }\n  /**\r\n   * Gets the device distance from the ground in meters.\r\n   * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n   */\n\n\n  WebVRFreeCamera.prototype.deviceDistanceToRoomGround = function () {\n    if (this._standingMatrix) {\n      // Add standing matrix offset to get real offset from ground in room\n      this._standingMatrix.getTranslationToRef(this._workingVector);\n\n      return this._deviceRoomPosition.y + this._workingVector.y;\n    } //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\n\n\n    return this._defaultHeight || 0;\n  };\n  /**\r\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n   * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n   */\n\n\n  WebVRFreeCamera.prototype.useStandingMatrix = function (callback) {\n    var _this = this;\n\n    if (callback === void 0) {\n      callback = function (bool) {};\n    } // Use standing matrix if available\n\n\n    this.getEngine().initWebVRAsync().then(function (result) {\n      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !_this.webVROptions.trackPosition) {\n        callback(false);\n      } else {\n        _this._standingMatrix = new Matrix();\n        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, _this._standingMatrix);\n\n        if (!_this.getScene().useRightHandedSystem) {\n          if (_this._standingMatrix) {\n            _this._standingMatrix.toggleModelMatrixHandInPlace();\n          }\n        }\n\n        callback(true);\n      }\n    });\n  };\n  /**\r\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n   * @returns A promise with a boolean set to if the standing matrix is supported.\r\n   */\n\n\n  WebVRFreeCamera.prototype.useStandingMatrixAsync = function () {\n    var _this = this;\n\n    return new Promise(function (res) {\n      _this.useStandingMatrix(function (supported) {\n        res(supported);\n      });\n    });\n  };\n  /**\r\n   * Disposes the camera\r\n   */\n\n\n  WebVRFreeCamera.prototype.dispose = function () {\n    this._detachIfAttached();\n\n    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\n\n    if (this._updateCacheWhenTrackingDisabledObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\n    }\n\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Gets a vrController by name.\r\n   * @param name The name of the controller to retreive\r\n   * @returns the controller matching the name specified or null if not found\r\n   */\n\n\n  WebVRFreeCamera.prototype.getControllerByName = function (name) {\n    for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {\n      var gp = _a[_i];\n\n      if (gp.hand === name) {\n        return gp;\n      }\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(WebVRFreeCamera.prototype, \"leftController\", {\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\n    get: function () {\n      if (!this._leftController) {\n        this._leftController = this.getControllerByName(\"left\");\n      }\n\n      return this._leftController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(WebVRFreeCamera.prototype, \"rightController\", {\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\n    get: function () {\n      if (!this._rightController) {\n        this._rightController = this.getControllerByName(\"right\");\n      }\n\n      return this._rightController;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Casts a ray forward from the vrCamera's gaze.\r\n   * @param length Length of the ray (default: 100)\r\n   * @returns the ray corresponding to the gaze\r\n   */\n\n  WebVRFreeCamera.prototype.getForwardRay = function (length) {\n    if (length === void 0) {\n      length = 100;\n    }\n\n    if (this.leftCamera) {\n      // Use left eye to avoid computation to compute center on every call\n      return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\n    } else {\n      return _super.prototype.getForwardRay.call(this, length);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Updates the camera based on device's frame data\r\n   */\n\n\n  WebVRFreeCamera.prototype._checkInputs = function () {\n    if (this._vrDevice && this._vrDevice.isPresenting) {\n      this._vrDevice.getFrameData(this._frameData);\n\n      this.updateFromDevice(this._frameData.pose);\n    }\n\n    _super.prototype._checkInputs.call(this);\n  };\n  /**\r\n   * Updates the poseControlled values based on the input device pose.\r\n   * @param poseData Pose coming from the device\r\n   */\n\n\n  WebVRFreeCamera.prototype.updateFromDevice = function (poseData) {\n    if (poseData && poseData.orientation && poseData.orientation.length === 4) {\n      this.rawPose = poseData;\n\n      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\n\n      if (this.getScene().useRightHandedSystem) {\n        this._deviceRoomRotationQuaternion.z *= -1;\n        this._deviceRoomRotationQuaternion.w *= -1;\n      }\n\n      if (this.webVROptions.trackPosition && this.rawPose.position) {\n        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n\n        if (this.getScene().useRightHandedSystem) {\n          this._deviceRoomPosition.z *= -1;\n        }\n      }\n\n      this._poseSet = true;\n    }\n  };\n  /**\r\n   * WebVR's attach control will start broadcasting frames to the device.\r\n   * Note that in certain browsers (chrome for example) this function must be called\r\n   * within a user-interaction callback. Example:\r\n   * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n   *\r\n   * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n   */\n\n\n  WebVRFreeCamera.prototype.attachControl = function (noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n\n    _super.prototype.attachControl.call(this, noPreventDefault);\n\n    this._attached = true;\n    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n\n    if (this._vrDevice) {\n      this.getEngine().enableVR(this.webVROptions);\n    }\n\n    var hostWindow = this._scene.getEngine().getHostWindow();\n\n    if (hostWindow) {\n      hostWindow.addEventListener('vrdisplaypresentchange', this._detachIfAttached);\n    }\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  WebVRFreeCamera.prototype.detachControl = function (ignored) {\n    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n\n    _super.prototype.detachControl.call(this);\n\n    this._attached = false;\n    this.getEngine().disableVR();\n    window.removeEventListener('vrdisplaypresentchange', this._detachIfAttached);\n  };\n  /**\r\n   * @returns the name of this class\r\n   */\n\n\n  WebVRFreeCamera.prototype.getClassName = function () {\n    return \"WebVRFreeCamera\";\n  };\n  /**\r\n   * Calls resetPose on the vrDisplay\r\n   * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n   */\n\n\n  WebVRFreeCamera.prototype.resetToCurrentRotation = function () {\n    //uses the vrDisplay's \"resetPose()\".\n    //pitch and roll won't be affected.\n    this._vrDevice.resetPose();\n  };\n  /**\r\n   * @hidden\r\n   * Updates the rig cameras (left and right eye)\r\n   */\n\n\n  WebVRFreeCamera.prototype._updateRigCameras = function () {\n    var camLeft = this._rigCameras[0];\n    var camRight = this._rigCameras[1];\n    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camLeft.position.copyFrom(this._deviceRoomPosition);\n    camRight.position.copyFrom(this._deviceRoomPosition);\n  }; // Remove translation from 6dof headset if trackposition is set to false\n\n\n  WebVRFreeCamera.prototype._correctPositionIfNotTrackPosition = function (matrix, isViewMatrix) {\n    if (isViewMatrix === void 0) {\n      isViewMatrix = false;\n    }\n\n    if (this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition) {\n      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\n\n      if (!isViewMatrix) {\n        this._tmpMatrix.invert();\n      }\n\n      this._tmpMatrix.multiplyToRef(matrix, matrix);\n    }\n  };\n  /**\r\n   * @hidden\r\n   * Updates the cached values of the camera\r\n   * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n   */\n\n\n  WebVRFreeCamera.prototype._updateCache = function (ignoreParentClass) {\n    var _this = this;\n\n    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\n      // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\n      if (!this.updateCacheCalled) {\n        // make sure it is only called once per loop. this.update() might cause an infinite loop.\n        this.updateCacheCalled = true;\n        this.update();\n      } // Set working vector to the device position in room space rotated by the new rotation\n\n\n      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\n      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector); // Subtract this vector from the current device position in world to get the translation for the device world matrix\n\n      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\n      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld); // Add translation from anchor position\n\n      this._deviceToWorld.getTranslationToRef(this._workingVector);\n\n      this._workingVector.addInPlace(this.position);\n\n      this._workingVector.subtractInPlace(this._cache.position);\n\n      this._deviceToWorld.setTranslation(this._workingVector); // Set an inverted matrix to be used when updating the camera\n\n\n      this._deviceToWorld.invertToRef(this._worldToDevice); // Update the gamepad to ensure the mesh is updated on the same frame as camera\n\n\n      this.controllers.forEach(function (controller) {\n        controller._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\n\n        controller.update();\n      });\n    }\n\n    if (!ignoreParentClass) {\n      _super.prototype._updateCache.call(this);\n    }\n\n    this.updateCacheCalled = false;\n  };\n  /**\r\n   * @hidden\r\n   * Get current device position in babylon world\r\n   */\n\n\n  WebVRFreeCamera.prototype._computeDevicePosition = function () {\n    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n  };\n  /**\r\n   * Updates the current device position and rotation in the babylon world\r\n   */\n\n\n  WebVRFreeCamera.prototype.update = function () {\n    this._computeDevicePosition(); // Get current device rotation in babylon world\n\n\n    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\n\n    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n\n    if (this._poseSet) {\n      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\n    }\n\n    _super.prototype.update.call(this);\n  };\n  /**\r\n   * @hidden\r\n   * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n   * @returns an identity matrix\r\n   */\n\n\n  WebVRFreeCamera.prototype._getViewMatrix = function () {\n    return Matrix.Identity();\n  };\n  /**\r\n   * This function is called by the two RIG cameras.\r\n   * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n   * @hidden\r\n   */\n\n\n  WebVRFreeCamera.prototype._getWebVRViewMatrix = function () {\n    // Update the parent camera prior to using a child camera to avoid desynchronization\n    var parentCamera = this._cameraRigParams[\"parentCamera\"];\n\n    parentCamera._updateCache(); //WebVR 1.1\n\n\n    var viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._webvrViewMatrix.toggleModelMatrixHandInPlace();\n    } // update the camera rotation matrix\n\n\n    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint); // Computing target and final matrix\n\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget); // should the view matrix be updated with scale and position offset?\n\n    if (parentCamera.deviceScaleFactor !== 1) {\n      this._webvrViewMatrix.invert(); // scale the position, if set\n\n\n      if (parentCamera.deviceScaleFactor) {\n        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\n\n        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\n      }\n\n      this._webvrViewMatrix.invert();\n    } // Remove translation from 6dof headset if trackposition is set to false\n\n\n    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\n\n    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix); // Compute global position\n\n\n    this._workingMatrix = this._workingMatrix || Matrix.Identity();\n\n    this._webvrViewMatrix.invertToRef(this._workingMatrix);\n\n    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\n\n    this._workingMatrix.getTranslationToRef(this._globalPosition);\n\n    this._markSyncedWithParent();\n\n    return this._webvrViewMatrix;\n  };\n  /** @hidden */\n\n\n  WebVRFreeCamera.prototype._getWebVRProjectionMatrix = function () {\n    var parentCamera = this.parent;\n    parentCamera._vrDevice.depthNear = parentCamera.minZ;\n    parentCamera._vrDevice.depthFar = parentCamera.maxZ;\n    var projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix); //babylon compatible matrix\n\n    if (!this.getScene().useRightHandedSystem) {\n      this._projectionMatrix.toggleProjectionMatrixHandInPlace();\n    }\n\n    return this._projectionMatrix;\n  };\n  /**\r\n   * Initializes the controllers and their meshes\r\n   */\n\n\n  WebVRFreeCamera.prototype.initControllers = function () {\n    var _this = this;\n\n    this.controllers = [];\n    var manager = this.getScene().gamepadManager;\n    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController = gamepad;\n\n        if (webVrController.defaultModel) {\n          webVrController.defaultModel.setEnabled(false);\n        }\n\n        if (webVrController.hand === \"right\") {\n          _this._rightController = null;\n        }\n\n        if (webVrController.hand === \"left\") {\n          _this._leftController = null;\n        }\n\n        var controllerIndex = _this.controllers.indexOf(webVrController);\n\n        if (controllerIndex !== -1) {\n          _this.controllers.splice(controllerIndex, 1);\n        }\n      }\n    });\n    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(function (gamepad) {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        var webVrController_1 = gamepad;\n\n        if (!_this.webVROptions.trackPosition) {\n          webVrController_1._disableTrackPosition(new Vector3(webVrController_1.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25)); // Cache must be updated before rendering controllers to avoid them being one frame behind\n\n\n          if (!_this._updateCacheWhenTrackingDisabledObserver) {\n            _this._updateCacheWhenTrackingDisabledObserver = _this._scene.onBeforeRenderObservable.add(function () {\n              _this._updateCache();\n            });\n          }\n        }\n\n        webVrController_1.deviceScaleFactor = _this.deviceScaleFactor;\n\n        webVrController_1._deviceToWorld.copyFrom(_this._deviceToWorld);\n\n        _this._correctPositionIfNotTrackPosition(webVrController_1._deviceToWorld);\n\n        if (_this.webVROptions.controllerMeshes) {\n          if (webVrController_1.defaultModel) {\n            webVrController_1.defaultModel.setEnabled(true);\n          } else {\n            // Load the meshes\n            webVrController_1.initControllerMesh(_this.getScene(), function (loadedMesh) {\n              loadedMesh.scaling.scaleInPlace(_this.deviceScaleFactor);\n\n              _this.onControllerMeshLoadedObservable.notifyObservers(webVrController_1);\n\n              if (_this.webVROptions.defaultLightingOnControllers) {\n                if (!_this._lightOnControllers) {\n                  _this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), _this.getScene());\n                }\n\n                var activateLightOnSubMeshes_1 = function (mesh, light) {\n                  var children = mesh.getChildren();\n\n                  if (children && children.length !== 0) {\n                    children.forEach(function (mesh) {\n                      light.includedOnlyMeshes.push(mesh);\n                      activateLightOnSubMeshes_1(mesh, light);\n                    });\n                  }\n                };\n\n                _this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\n\n                activateLightOnSubMeshes_1(loadedMesh, _this._lightOnControllers);\n              }\n            });\n          }\n        }\n\n        webVrController_1.attachToPoseControlledCamera(_this); // since this is async - sanity check. Is the controller already stored?\n\n        if (_this.controllers.indexOf(webVrController_1) === -1) {\n          //add to the controllers array\n          _this.controllers.push(webVrController_1); // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n          // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n          // So we're overriding setting left & right manually to be sure\n\n\n          var firstViveWandDetected = false;\n\n          for (var i = 0; i < _this.controllers.length; i++) {\n            if (_this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\n              if (!firstViveWandDetected) {\n                firstViveWandDetected = true;\n                _this.controllers[i].hand = \"left\";\n              } else {\n                _this.controllers[i].hand = \"right\";\n              }\n            }\n          } //did we find enough controllers? Great! let the developer know.\n\n\n          if (_this.controllers.length >= 2) {\n            _this.onControllersAttachedObservable.notifyObservers(_this.controllers);\n          }\n        }\n      }\n    });\n  };\n\n  return WebVRFreeCamera;\n}(FreeCamera);\n\nexport { WebVRFreeCamera };","map":{"version":3,"sources":["../../../../sourceES6/core/Cameras/VR/webVRCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Observer, Observable } from \"../../Misc/observable\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\r\nimport { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\r\nimport { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport { Node } from \"../../node\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\r\nimport { Logger } from '../../Misc/logger';\r\nimport { VRMultiviewToSingleviewPostProcess } from '../../PostProcesses/vrMultiviewToSingleviewPostProcess';\r\n\r\n// Side effect import to define the stereoscopic mode.\r\nimport \"../RigModes/webVRRigMode\";\r\n\r\n// Side effect import to add webvr support to engine\r\nimport \"../../Engines/Extensions/engine.webVR\";\r\nimport { Tools } from '../../Misc/tools';\r\n\r\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose\r\n * IMPORTANT!! The data is right-hand data.\r\n * @export\r\n * @interface DevicePose\r\n */\r\nexport interface DevicePose {\r\n    /**\r\n     * The position of the device, values in array are [x,y,z].\r\n     */\r\n    readonly position: Nullable<Float32Array>;\r\n    /**\r\n     * The linearVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The linearAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearAcceleration: Nullable<Float32Array>;\r\n\r\n    /**\r\n     * The orientation of the device in a quaternion array, values in array are [x,y,z,w].\r\n     */\r\n    readonly orientation: Nullable<Float32Array>;\r\n    /**\r\n     * The angularVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The angularAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularAcceleration: Nullable<Float32Array>;\r\n}\r\n\r\n/**\r\n* Interface representing a pose controlled object in Babylon.\r\n* A pose controlled object has both regular pose values as well as pose values\r\n* from an external device such as a VR head mounted display\r\n*/\r\nexport interface PoseControlled {\r\n    /**\r\n     * The position of the object in babylon space.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation quaternion of the object in babylon space.\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n    /**\r\n     * The position of the device in babylon space.\r\n     */\r\n    devicePosition?: Vector3;\r\n    /**\r\n     * The rotation quaternion of the device in babylon space.\r\n     */\r\n    deviceRotationQuaternion: Quaternion;\r\n    /**\r\n     * The raw pose coming from the device.\r\n     */\r\n    rawPose: Nullable<DevicePose>;\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    deviceScaleFactor: number;\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData the pose data to update the object with\r\n     */\r\n    updateFromDevice(poseData: DevicePose): void;\r\n}\r\n\r\n/**\r\n * Set of options to customize the webVRCamera\r\n */\r\nexport interface WebVROptions {\r\n    /**\r\n     * Sets if the webVR camera should be tracked to the vrDevice. (default: true)\r\n     */\r\n    trackPosition?: boolean;\r\n    /**\r\n     * Sets the scale of the vrDevice in babylon space. (default: 1)\r\n     */\r\n    positionScale?: number;\r\n    /**\r\n     * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)\r\n     */\r\n    displayName?: string;\r\n    /**\r\n     * Should the native controller meshes be initialized. (default: true)\r\n     */\r\n    controllerMeshes?: boolean;\r\n    /**\r\n     * Creating a default HemiLight only on controllers. (default: true)\r\n     */\r\n    defaultLightingOnControllers?: boolean;\r\n    /**\r\n     * If you don't want to use the default VR button of the helper. (default: false)\r\n     */\r\n    useCustomVRButton?: boolean;\r\n\r\n    /**\r\n     * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)\r\n     */\r\n    customVRButton?: HTMLButtonElement;\r\n\r\n    /**\r\n     * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)\r\n     */\r\n    rayLength?: number;\r\n\r\n    /**\r\n     * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)\r\n     */\r\n    defaultHeight?: number;\r\n\r\n    /**\r\n     * If multiview should be used if availible (default: false)\r\n     */\r\n    useMultiview?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @example https://doc.babylonjs.com/how_to/webvr_camera\r\n */\r\nexport class WebVRFreeCamera extends FreeCamera implements PoseControlled {\r\n    /**\r\n     * @hidden\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\r\n    public _vrDevice: any = null;\r\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\r\n    public rawPose: Nullable<DevicePose> = null;\r\n    private _onVREnabled: (success: boolean) => void;\r\n    private _specsVersion: string = \"1.1\";\r\n    private _attached: boolean = false;\r\n\r\n    private _frameData: any;\r\n\r\n    protected _descendants: Array<Node> = [];\r\n\r\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\r\n    private _deviceRoomPosition = Vector3.Zero();\r\n    /** @hidden */\r\n    public _deviceRoomRotationQuaternion = Quaternion.Identity();\r\n\r\n    private _standingMatrix: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Represents device position in babylon space.\r\n     */\r\n    public devicePosition = Vector3.Zero();\r\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\r\n    public deviceRotationQuaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    public deviceScaleFactor: number = 1;\r\n\r\n    private _deviceToWorld = Matrix.Identity();\r\n    private _worldToDevice = Matrix.Identity();\r\n\r\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\r\n    public controllers: Array<WebVRController> = [];\r\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\r\n    public onControllersAttachedObservable = new Observable<Array<WebVRController>>();\r\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\r\n    public onControllerMeshLoadedObservable = new Observable<WebVRController>();\r\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\r\n    public onPoseUpdatedFromDeviceObservable = new Observable<any>();\r\n    private _poseSet = false;\r\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\r\n    public rigParenting: boolean = true;\r\n\r\n    private _lightOnControllers: HemisphericLight;\r\n\r\n    private _defaultHeight?: number = undefined;\r\n\r\n    /**\r\n     * Instantiates a WebVRFreeCamera.\r\n     * @param name The name of the WebVRFreeCamera\r\n     * @param position The starting anchor position for the camera\r\n     * @param scene The scene the camera belongs to\r\n     * @param webVROptions a set of customizable options for the webVRCamera\r\n     */\r\n    constructor(name: string, position: Vector3, scene: Scene, private webVROptions: WebVROptions = {}) {\r\n        super(name, position, scene);\r\n        this._cache.position = Vector3.Zero();\r\n        if (webVROptions.defaultHeight) {\r\n            this._defaultHeight = webVROptions.defaultHeight;\r\n            this.position.y = this._defaultHeight;\r\n        }\r\n\r\n        this.minZ = 0.1;\r\n\r\n        //legacy support - the compensation boolean was removed.\r\n        if (arguments.length === 5) {\r\n            this.webVROptions = arguments[4];\r\n        }\r\n\r\n        // default webVR options\r\n        if (this.webVROptions.trackPosition == undefined) {\r\n            this.webVROptions.trackPosition = true;\r\n        }\r\n        if (this.webVROptions.controllerMeshes == undefined) {\r\n            this.webVROptions.controllerMeshes = true;\r\n        }\r\n        if (this.webVROptions.defaultLightingOnControllers == undefined) {\r\n            this.webVROptions.defaultLightingOnControllers = true;\r\n        }\r\n\r\n        this.rotationQuaternion = new Quaternion();\r\n\r\n        if (this.webVROptions && this.webVROptions.positionScale) {\r\n            this.deviceScaleFactor = this.webVROptions.positionScale;\r\n        }\r\n\r\n        //enable VR\r\n        var engine = this.getEngine();\r\n        this._onVREnabled = (success: boolean) => { if (success) { this.initControllers(); } };\r\n        engine.onVRRequestPresentComplete.add(this._onVREnabled);\r\n        engine.initWebVR().add((event: IDisplayChangedEventArgs) => {\r\n            if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\r\n                return;\r\n            }\r\n\r\n            this._vrDevice = event.vrDisplay;\r\n\r\n            //reset the rig parameters.\r\n            this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });\r\n\r\n            if (this._attached) {\r\n                this.getEngine().enableVR(this.webVROptions);\r\n            }\r\n        });\r\n\r\n        if (typeof (VRFrameData) !== \"undefined\") {\r\n            this._frameData = new VRFrameData();\r\n        }\r\n\r\n        if (webVROptions.useMultiview) {\r\n            if (!this.getScene().getEngine().getCaps().multiview) {\r\n                Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n                this._useMultiviewToSingleView = false;\r\n            } else {\r\n                this._useMultiviewToSingleView = true;\r\n                this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The idea behind the following lines:\r\n         * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n         * the second will not show it correctly.\r\n         *\r\n         * To solve this - each object that has the camera as parent will be added to a protected array.\r\n         * When the rig camera renders, it will take this array and set all of those to be its children.\r\n         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n         * Amazing!\r\n         */\r\n        scene.onBeforeCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants = this.getDescendants(true, (n) => {\r\n                    // don't take the cameras or the controllers!\r\n                    let isController = this.controllers.some((controller) => { return controller._mesh === n; });\r\n                    let isRigCamera = this._rigCameras.indexOf(<Camera>n) !== -1;\r\n                    return !isController && !isRigCamera;\r\n                });\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = camera;\r\n                });\r\n            }\r\n        });\r\n\r\n        scene.onAfterCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = this;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the device distance from the ground in meters.\r\n     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n     */\r\n    public deviceDistanceToRoomGround(): number {\r\n        if (this._standingMatrix) {\r\n            // Add standing matrix offset to get real offset from ground in room\r\n            this._standingMatrix.getTranslationToRef(this._workingVector);\r\n            return this._deviceRoomPosition.y + this._workingVector.y;\r\n        }\r\n        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\r\n        return this._defaultHeight || 0;\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n     */\r\n    public useStandingMatrix(callback = (bool: boolean) => { }) {\r\n        // Use standing matrix if available\r\n        this.getEngine().initWebVRAsync().then((result) => {\r\n            if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this.webVROptions.trackPosition) {\r\n                callback(false);\r\n            } else {\r\n                this._standingMatrix = new Matrix();\r\n                Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\r\n                if (!this.getScene().useRightHandedSystem) {\r\n                    if (this._standingMatrix) {\r\n                        this._standingMatrix.toggleModelMatrixHandInPlace();\r\n                    }\r\n                }\r\n                callback(true);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @returns A promise with a boolean set to if the standing matrix is supported.\r\n     */\r\n    public useStandingMatrixAsync(): Promise<boolean> {\r\n        return new Promise((res) => {\r\n            this.useStandingMatrix((supported) => {\r\n                res(supported);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the camera\r\n     */\r\n    public dispose(): void {\r\n        this._detachIfAttached();\r\n        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\r\n        if (this._updateCacheWhenTrackingDisabledObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets a vrController by name.\r\n     * @param name The name of the controller to retreive\r\n     * @returns the controller matching the name specified or null if not found\r\n     */\r\n    public getControllerByName(name: string): Nullable<WebVRController> {\r\n        for (var gp of this.controllers) {\r\n            if (gp.hand === name) {\r\n                return gp;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _leftController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\r\n    public get leftController(): Nullable<WebVRController> {\r\n        if (!this._leftController) {\r\n            this._leftController = this.getControllerByName(\"left\");\r\n        }\r\n\r\n        return this._leftController;\r\n    }\r\n\r\n    private _rightController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\r\n    public get rightController(): Nullable<WebVRController> {\r\n        if (!this._rightController) {\r\n            this._rightController = this.getControllerByName(\"right\");\r\n        }\r\n\r\n        return this._rightController;\r\n    }\r\n\r\n    /**\r\n     * Casts a ray forward from the vrCamera's gaze.\r\n     * @param length Length of the ray (default: 100)\r\n     * @returns the ray corresponding to the gaze\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (this.leftCamera) {\r\n            // Use left eye to avoid computation to compute center on every call\r\n            return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\r\n        }\r\n        else {\r\n            return super.getForwardRay(length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the camera based on device's frame data\r\n     */\r\n    public _checkInputs(): void {\r\n        if (this._vrDevice && this._vrDevice.isPresenting) {\r\n            this._vrDevice.getFrameData(this._frameData);\r\n\r\n            this.updateFromDevice(this._frameData.pose);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData Pose coming from the device\r\n     */\r\n    updateFromDevice(poseData: DevicePose) {\r\n        if (poseData && poseData.orientation && poseData.orientation.length === 4) {\r\n            this.rawPose = poseData;\r\n            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                this._deviceRoomRotationQuaternion.z *= -1;\r\n                this._deviceRoomRotationQuaternion.w *= -1;\r\n            }\r\n            if (this.webVROptions.trackPosition && this.rawPose.position) {\r\n                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\r\n                if (this.getScene().useRightHandedSystem) {\r\n                    this._deviceRoomPosition.z *= -1;\r\n                }\r\n            }\r\n            this._poseSet = true;\r\n        }\r\n    }\r\n\r\n    private _detachIfAttached = () => {\r\n        var vrDisplay = this.getEngine().getVRDevice();\r\n        if (vrDisplay && !vrDisplay.isPresenting) {\r\n            this.detachControl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * WebVR's attach control will start broadcasting frames to the device.\r\n     * Note that in certain browsers (chrome for example) this function must be called\r\n     * within a user-interaction callback. Example:\r\n     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n     *\r\n     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        super.attachControl(noPreventDefault);\r\n        this._attached = true;\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n\r\n        if (this._vrDevice) {\r\n            this.getEngine().enableVR(this.webVROptions);\r\n        }\r\n\r\n        let hostWindow = this._scene.getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            hostWindow.addEventListener('vrdisplaypresentchange', this._detachIfAttached);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored?: any): void {\r\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n\r\n        super.detachControl();\r\n        this._attached = false;\r\n        this.getEngine().disableVR();\r\n        window.removeEventListener('vrdisplaypresentchange', this._detachIfAttached);\r\n    }\r\n\r\n    /**\r\n     * @returns the name of this class\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebVRFreeCamera\";\r\n    }\r\n\r\n    /**\r\n     * Calls resetPose on the vrDisplay\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n     */\r\n    public resetToCurrentRotation() {\r\n        //uses the vrDisplay's \"resetPose()\".\r\n        //pitch and roll won't be affected.\r\n        this._vrDevice.resetPose();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the rig cameras (left and right eye)\r\n     */\r\n    public _updateRigCameras() {\r\n        var camLeft = <TargetCamera>this._rigCameras[0];\r\n        var camRight = <TargetCamera>this._rigCameras[1];\r\n        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n\r\n        camLeft.position.copyFrom(this._deviceRoomPosition);\r\n        camRight.position.copyFrom(this._deviceRoomPosition);\r\n    }\r\n\r\n    private _workingVector = Vector3.Zero();\r\n    private _oneVector = Vector3.One();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    private updateCacheCalled: boolean;\r\n\r\n    // Remove translation from 6dof headset if trackposition is set to false\r\n    private _correctPositionIfNotTrackPosition(matrix: Matrix, isViewMatrix = false) {\r\n        if (this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition) {\r\n            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\r\n            if (!isViewMatrix) {\r\n                this._tmpMatrix.invert();\r\n            }\r\n            this._tmpMatrix.multiplyToRef(matrix, matrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Updates the cached values of the camera\r\n     * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\r\n            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\r\n            if (!this.updateCacheCalled) {\r\n                // make sure it is only called once per loop. this.update() might cause an infinite loop.\r\n                this.updateCacheCalled = true;\r\n                this.update();\r\n            }\r\n\r\n            // Set working vector to the device position in room space rotated by the new rotation\r\n            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\r\n            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\r\n\r\n            // Subtract this vector from the current device position in world to get the translation for the device world matrix\r\n            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\r\n            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\r\n\r\n            // Add translation from anchor position\r\n            this._deviceToWorld.getTranslationToRef(this._workingVector);\r\n            this._workingVector.addInPlace(this.position);\r\n            this._workingVector.subtractInPlace(this._cache.position);\r\n            this._deviceToWorld.setTranslation(this._workingVector);\r\n\r\n            // Set an inverted matrix to be used when updating the camera\r\n            this._deviceToWorld.invertToRef(this._worldToDevice);\r\n\r\n            // Update the gamepad to ensure the mesh is updated on the same frame as camera\r\n            this.controllers.forEach((controller) => {\r\n                controller._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\r\n                controller.update();\r\n            });\r\n        }\r\n\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n        this.updateCacheCalled = false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Get current device position in babylon world\r\n     */\r\n    public _computeDevicePosition() {\r\n        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\r\n    }\r\n\r\n    /**\r\n     * Updates the current device position and rotation in the babylon world\r\n     */\r\n    public update() {\r\n        this._computeDevicePosition();\r\n\r\n        // Get current device rotation in babylon world\r\n        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\r\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\r\n\r\n        if (this._poseSet) {\r\n            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\r\n        }\r\n        super.update();\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n     * @returns an identity matrix\r\n     */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * This function is called by the two RIG cameras.\r\n     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n     * @hidden\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        // Update the parent camera prior to using a child camera to avoid desynchronization\r\n        let parentCamera: WebVRFreeCamera = this._cameraRigParams[\"parentCamera\"];\r\n        parentCamera._updateCache();\r\n\r\n        //WebVR 1.1\r\n        var viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\r\n\r\n        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\r\n\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._webvrViewMatrix.toggleModelMatrixHandInPlace();\r\n        }\r\n\r\n        // update the camera rotation matrix\r\n        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n\r\n        // should the view matrix be updated with scale and position offset?\r\n        if (parentCamera.deviceScaleFactor !== 1) {\r\n            this._webvrViewMatrix.invert();\r\n            // scale the position, if set\r\n            if (parentCamera.deviceScaleFactor) {\r\n                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\r\n            }\r\n\r\n            this._webvrViewMatrix.invert();\r\n        }\r\n\r\n        // Remove translation from 6dof headset if trackposition is set to false\r\n        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\r\n\r\n        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\r\n\r\n        // Compute global position\r\n        this._workingMatrix = this._workingMatrix || Matrix.Identity();\r\n        this._webvrViewMatrix.invertToRef(this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\r\n        this._workingMatrix.getTranslationToRef(this._globalPosition);\r\n        this._markSyncedWithParent();\r\n\r\n        return this._webvrViewMatrix;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n\r\n        let parentCamera = <WebVRFreeCamera>this.parent;\r\n\r\n        parentCamera._vrDevice.depthNear = parentCamera.minZ;\r\n        parentCamera._vrDevice.depthFar = parentCamera.maxZ;\r\n\r\n        var projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\r\n        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\r\n\r\n        //babylon compatible matrix\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n        }\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _updateCacheWhenTrackingDisabledObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * Initializes the controllers and their meshes\r\n     */\r\n    public initControllers() {\r\n        this.controllers = [];\r\n\r\n        let manager = this.getScene().gamepadManager;\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                let webVrController: WebVRController = <WebVRController>gamepad;\r\n\r\n                if (webVrController.defaultModel) {\r\n                    webVrController.defaultModel.setEnabled(false);\r\n                }\r\n\r\n                if (webVrController.hand === \"right\") {\r\n                    this._rightController = null;\r\n                }\r\n                if (webVrController.hand === \"left\") {\r\n                    this._leftController = null;\r\n                }\r\n                const controllerIndex = this.controllers.indexOf(webVrController);\r\n                if (controllerIndex !== -1) {\r\n                    this.controllers.splice(controllerIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                let webVrController: WebVRController = <WebVRController>gamepad;\r\n                if (!this.webVROptions.trackPosition) {\r\n                    webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\r\n                    // Cache must be updated before rendering controllers to avoid them being one frame behind\r\n                    if (!this._updateCacheWhenTrackingDisabledObserver) {\r\n                        this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n                            this._updateCache();\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.deviceScaleFactor = this.deviceScaleFactor;\r\n                webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\r\n\r\n                if (this.webVROptions.controllerMeshes) {\r\n                    if (webVrController.defaultModel) {\r\n                        webVrController.defaultModel.setEnabled(true);\r\n                    } else {\r\n                        // Load the meshes\r\n                        webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {\r\n                            loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\r\n                            this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\r\n                            if (this.webVROptions.defaultLightingOnControllers) {\r\n                                if (!this._lightOnControllers) {\r\n                                    this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\r\n                                }\r\n                                let activateLightOnSubMeshes = function(mesh: AbstractMesh, light: HemisphericLight) {\r\n                                    let children = mesh.getChildren();\r\n                                    if (children && children.length !== 0) {\r\n                                        children.forEach((mesh) => {\r\n                                            light.includedOnlyMeshes.push(<AbstractMesh>mesh);\r\n                                            activateLightOnSubMeshes(<AbstractMesh>mesh, light);\r\n                                        });\r\n                                    }\r\n                                };\r\n                                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\r\n                                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.attachToPoseControlledCamera(this);\r\n\r\n                // since this is async - sanity check. Is the controller already stored?\r\n                if (this.controllers.indexOf(webVrController) === -1) {\r\n                    //add to the controllers array\r\n                    this.controllers.push(webVrController);\r\n\r\n                    // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\r\n                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\r\n                    // So we're overriding setting left & right manually to be sure\r\n                    let firstViveWandDetected = false;\r\n\r\n                    for (let i = 0; i < this.controllers.length; i++) {\r\n                        if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\r\n                            if (!firstViveWandDetected) {\r\n                                firstViveWandDetected = true;\r\n                                this.controllers[i].hand = \"left\";\r\n                            }\r\n                            else {\r\n                                this.controllers[i].hand = \"right\";\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //did we find enough controllers? Great! let the developer know.\r\n                    if (this.controllers.length >= 2) {\r\n                        this.onControllersAttachedObservable.notifyObservers(this.controllers);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}