{"ast":null,"code":"import { Observable } from \"../Misc/observable\";\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Color3 } from '../Maths/math.color';\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\nimport { Gizmo } from \"./gizmo\";\nimport { RotationGizmo } from \"./rotationGizmo\";\nimport { PositionGizmo } from \"./positionGizmo\";\nimport { ScaleGizmo } from \"./scaleGizmo\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\n\nvar GizmoManager =\n/** @class */\nfunction () {\n  /**\r\n   * Instatiates a gizmo manager\r\n   * @param scene the scene to overlay the gizmos on top of\r\n   * @param thickness display gizmo axis thickness\r\n   * @param utilityLayer the layer where gizmos are rendered\r\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n   */\n  function GizmoManager(scene, thickness, utilityLayer, keepDepthUtilityLayer) {\n    if (thickness === void 0) {\n      thickness = 1;\n    }\n\n    if (utilityLayer === void 0) {\n      utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer;\n    }\n\n    if (keepDepthUtilityLayer === void 0) {\n      keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer;\n    }\n\n    this.scene = scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** Fires an event when the manager is attached to a mesh */\n\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    /** Node Caching for quick lookup */\n\n    this._gizmoAxisCache = new Map();\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\n\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\n\n    this.attachableMeshes = null;\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\n\n    this.attachableNodes = null;\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\n\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n\n    var attachToMeshPointerObserver = this._attachToMeshPointerObserver(scene);\n\n    var gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n\n  Object.defineProperty(GizmoManager.prototype, \"keepDepthUtilityLayer\", {\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\n    get: function () {\n      return this._defaultKeepDepthUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"utilityLayer\", {\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\n    get: function () {\n      return this._defaultUtilityLayer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"isHovered\", {\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\n    get: function () {\n      var hovered = false;\n\n      for (var key in this.gizmos) {\n        var gizmo = this.gizmos[key];\n\n        if (gizmo && gizmo.isHovered) {\n          hovered = true;\n          break;\n        }\n      }\n\n      return hovered;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Subscribes to pointer down events, for attaching and detaching mesh\r\n   * @param scene The sceme layer the observer will be added to\r\n   */\n\n  GizmoManager.prototype._attachToMeshPointerObserver = function (scene) {\n    var _this = this; // Instatiate/dispose gizmos based on pointer actions\n\n\n    var pointerObserver = scene.onPointerObservable.add(function (pointerInfo) {\n      if (!_this.usePointerToAttachGizmos) {\n        return;\n      }\n\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          var node = pointerInfo.pickInfo.pickedMesh;\n\n          if (_this.attachableMeshes == null) {\n            // Attach to the most parent node\n            while (node && node.parent != null) {\n              node = node.parent;\n            }\n          } else {\n            // Attach to the parent node that is an attachableMesh\n            var found = false;\n\n            _this.attachableMeshes.forEach(function (mesh) {\n              if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                node = mesh;\n                found = true;\n              }\n            });\n\n            if (!found) {\n              node = null;\n            }\n          }\n\n          if (node instanceof AbstractMesh) {\n            if (_this._attachedMesh != node) {\n              _this.attachToMesh(node);\n            }\n          } else {\n            if (_this.clearGizmoOnEmptyPointerEvent) {\n              _this.attachToMesh(null);\n            }\n          }\n        } else {\n          if (_this.clearGizmoOnEmptyPointerEvent) {\n            _this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  };\n  /**\r\n   * Attaches a set of gizmos to the specified mesh\r\n   * @param mesh The mesh the gizmo's should be attached to\r\n   */\n\n\n  GizmoManager.prototype.attachToMesh = function (mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  };\n  /**\r\n   * Attaches a set of gizmos to the specified node\r\n   * @param node The node the gizmo's should be attached to\r\n   */\n\n\n  GizmoManager.prototype.attachToNode = function (node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this._attachedMesh = null;\n    this._attachedNode = node;\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  };\n\n  Object.defineProperty(GizmoManager.prototype, \"positionGizmoEnabled\", {\n    get: function () {\n      return this._gizmosEnabled.positionGizmo;\n    },\n\n    /**\r\n     * If the position gizmo is enabled\r\n     */\n    set: function (value) {\n      if (value) {\n        if (!this.gizmos.positionGizmo) {\n          this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.positionGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"rotationGizmoEnabled\", {\n    get: function () {\n      return this._gizmosEnabled.rotationGizmo;\n    },\n\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\n    set: function (value) {\n      if (value) {\n        if (!this.gizmos.rotationGizmo) {\n          this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n        }\n\n        if (this._attachedNode) {\n          this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.rotationGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"scaleGizmoEnabled\", {\n    get: function () {\n      return this._gizmosEnabled.scaleGizmo;\n    },\n\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\n    set: function (value) {\n      if (value) {\n        this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n\n        if (this._attachedNode) {\n          this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n        } else {\n          this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n        }\n      } else if (this.gizmos.scaleGizmo) {\n        this.gizmos.scaleGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.scaleGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GizmoManager.prototype, \"boundingBoxGizmoEnabled\", {\n    get: function () {\n      return this._gizmosEnabled.boundingBoxGizmo;\n    },\n\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\n    set: function (value) {\n      if (value) {\n        this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n\n        if (this._attachedMesh) {\n          this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n        } else {\n          this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n        }\n\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n\n          this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n        }\n      } else if (this.gizmos.boundingBoxGizmo) {\n        if (this._attachedMesh) {\n          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        } else if (this._attachedNode) {\n          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n\n        this.gizmos.boundingBoxGizmo.attachedNode = null;\n      }\n\n      this._gizmosEnabled.boundingBoxGizmo = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n   */\n\n  GizmoManager.prototype.addToAxisCache = function (gizmoAxisCache) {\n    var _this = this;\n\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach(function (v, k) {\n        _this._gizmoAxisCache.set(k, v);\n      });\n    }\n  };\n  /**\r\n   * Disposes of the gizmo manager\r\n   */\n\n\n  GizmoManager.prototype.dispose = function () {\n    var _this = this;\n\n    this._pointerObservers.forEach(function (observer) {\n      _this.scene.onPointerObservable.remove(observer);\n    });\n\n    for (var key in this.gizmos) {\n      var gizmo = this.gizmos[key];\n\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n\n    this._defaultKeepDepthUtilityLayer.dispose();\n\n    this._defaultUtilityLayer.dispose();\n\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  };\n\n  return GizmoManager;\n}();\n\nexport { GizmoManager };","map":{"version":3,"sources":["../../../sourceES6/core/Gizmos/gizmoManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\nimport { Nullable } from \"../types\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\nimport { Scene, IDisposable } from \"../scene\";\nimport { Node } from \"../node\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from '../Meshes/mesh';\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { Color3 } from '../Maths/math.color';\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\nimport { Gizmo, GizmoAxisCache } from \"./gizmo\";\nimport { RotationGizmo } from \"./rotationGizmo\";\nimport { PositionGizmo } from \"./positionGizmo\";\nimport { ScaleGizmo } from \"./scaleGizmo\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\n\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\nexport class GizmoManager implements IDisposable {\n    /**\n     * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time\n     */\n    public gizmos: { positionGizmo: Nullable<PositionGizmo>, rotationGizmo: Nullable<RotationGizmo>, scaleGizmo: Nullable<ScaleGizmo>, boundingBoxGizmo: Nullable<BoundingBoxGizmo> };\n\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n    public clearGizmoOnEmptyPointerEvent = false;\n\n    /** Fires an event when the manager is attached to a mesh */\n    public onAttachedToMeshObservable = new Observable<Nullable<AbstractMesh>>();\n\n    /** Fires an event when the manager is attached to a node */\n    public onAttachedToNodeObservable = new Observable<Nullable<Node>>();\n\n    private _gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\n    private _pointerObservers: Observer<PointerInfo>[] = [];\n    private _attachedMesh: Nullable<AbstractMesh> = null;\n    private _attachedNode: Nullable<Node> = null;\n    private _boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    private _defaultUtilityLayer: UtilityLayerRenderer;\n    private _defaultKeepDepthUtilityLayer: UtilityLayerRenderer;\n    private _thickness: number = 1;\n    /** Node Caching for quick lookup */\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\n    /**\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\n     */\n    public boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n     */\n    public attachableMeshes: Nullable<Array<AbstractMesh>> = null;\n    /**\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n     */\n    public attachableNodes: Nullable<Array<Node>> = null;\n    /**\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n     */\n    public usePointerToAttachGizmos = true;\n\n    /**\n     * Utility layer that the bounding box gizmo belongs to\n     */\n    public get keepDepthUtilityLayer() {\n        return this._defaultKeepDepthUtilityLayer;\n    }\n\n    /**\n     * Utility layer that all gizmos besides bounding box belong to\n     */\n    public get utilityLayer() {\n        return this._defaultUtilityLayer;\n    }\n\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    public get isHovered() {\n        var hovered = false;\n        for (var key in this.gizmos) {\n            var gizmo = <Nullable<Gizmo>>((<any>this.gizmos)[key]);\n            if (gizmo && gizmo.isHovered) {\n                hovered = true;\n                break;\n            }\n        }\n        return hovered;\n    }\n\n    /**\n     * Instatiates a gizmo manager\n     * @param scene the scene to overlay the gizmos on top of\n     * @param thickness display gizmo axis thickness\n     * @param utilityLayer the layer where gizmos are rendered\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n     */\n    constructor(private scene: Scene, thickness: number = 1, utilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n        this._defaultUtilityLayer = utilityLayer;\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n        this._thickness = thickness;\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\n\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(scene);\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n    }\n\n    /**\n     * Subscribes to pointer down events, for attaching and detaching mesh\n     * @param scene The sceme layer the observer will be added to\n     */\n    private _attachToMeshPointerObserver(scene: Scene): Observer<PointerInfo> {\n        // Instatiate/dispose gizmos based on pointer actions\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\n            if (!this.usePointerToAttachGizmos) {\n                return;\n            }\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n                    var node: Nullable<Node> = pointerInfo.pickInfo.pickedMesh;\n                    if (this.attachableMeshes == null) {\n                        // Attach to the most parent node\n                        while (node && node.parent != null) {\n                            node = node.parent;\n                        }\n                    } else {\n                        // Attach to the parent node that is an attachableMesh\n                        var found = false;\n                        this.attachableMeshes.forEach((mesh) => {\n                            if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                                node = mesh;\n                                found = true;\n                            }\n                        });\n                        if (!found) {\n                            node = null;\n                        }\n                    }\n                    if (node instanceof AbstractMesh) {\n                        if (this._attachedMesh != node) {\n                            this.attachToMesh(node);\n                        }\n                    } else {\n                        if (this.clearGizmoOnEmptyPointerEvent) {\n                            this.attachToMesh(null);\n                        }\n                    }\n                } else {\n                    if (this.clearGizmoOnEmptyPointerEvent) {\n                        this.attachToMesh(null);\n                    }\n                }\n            }\n        });\n        return pointerObserver!;\n    }\n\n    /**\n     * Attaches a set of gizmos to the specified mesh\n     * @param mesh The mesh the gizmo's should be attached to\n     */\n    public attachToMesh(mesh: Nullable<AbstractMesh>) {\n        if (this._attachedMesh) {\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        if (this._attachedNode) {\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        this._attachedMesh = mesh;\n        this._attachedNode = null;\n        for (var key in this.gizmos) {\n            var gizmo = <Nullable<Gizmo>>((<any>this.gizmos)[key]);\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\n                gizmo.attachedMesh = mesh;\n            }\n        }\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n        }\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\n    }\n\n    /**\n     * Attaches a set of gizmos to the specified node\n     * @param node The node the gizmo's should be attached to\n     */\n    public attachToNode(node: Nullable<Node>) {\n        if (this._attachedMesh) {\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        if (this._attachedNode) {\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        this._attachedMesh = null;\n        this._attachedNode = node;\n        for (var key in this.gizmos) {\n            var gizmo = <Nullable<Gizmo>>((<any>this.gizmos)[key]);\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\n                gizmo.attachedNode = node;\n            }\n        }\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n        }\n        this.onAttachedToNodeObservable.notifyObservers(node);\n    }\n\n    /**\n     * If the position gizmo is enabled\n     */\n    public set positionGizmoEnabled(value: boolean) {\n        if (value) {\n            if (!this.gizmos.positionGizmo) {\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n            }\n            if (this._attachedNode) {\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n            } else {\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n            }\n        } else if (this.gizmos.positionGizmo) {\n            this.gizmos.positionGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.positionGizmo = value;\n    }\n    public get positionGizmoEnabled(): boolean {\n        return this._gizmosEnabled.positionGizmo;\n    }\n    /**\n     * If the rotation gizmo is enabled\n     */\n    public set rotationGizmoEnabled(value: boolean) {\n        if (value) {\n            if (!this.gizmos.rotationGizmo) {\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n            }\n            if (this._attachedNode) {\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n            } else {\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n            }\n        } else if (this.gizmos.rotationGizmo) {\n            this.gizmos.rotationGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.rotationGizmo = value;\n    }\n    public get rotationGizmoEnabled(): boolean {\n        return this._gizmosEnabled.rotationGizmo;\n    }\n    /**\n     * If the scale gizmo is enabled\n     */\n    public set scaleGizmoEnabled(value: boolean) {\n        if (value) {\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n            if (this._attachedNode) {\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n            } else {\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n            }\n        } else if (this.gizmos.scaleGizmo) {\n            this.gizmos.scaleGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.scaleGizmo = value;\n    }\n    public get scaleGizmoEnabled(): boolean {\n        return this._gizmosEnabled.scaleGizmo;\n    }\n    /**\n     * If the boundingBox gizmo is enabled\n     */\n    public set boundingBoxGizmoEnabled(value: boolean) {\n        if (value) {\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n            if (this._attachedMesh) {\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n            } else {\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n            }\n\n            if (this._attachedMesh) {\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n            } else if (this._attachedNode) {\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n            }\n        } else if (this.gizmos.boundingBoxGizmo) {\n            if (this._attachedMesh) {\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n            } else if (this._attachedNode) {\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n            }\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.boundingBoxGizmo = value;\n    }\n    public get boundingBoxGizmoEnabled(): boolean {\n        return this._gizmosEnabled.boundingBoxGizmo;\n    }\n\n    /**\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n     */\n    public addToAxisCache(gizmoAxisCache: Map<Mesh, GizmoAxisCache>) {\n        if (gizmoAxisCache.size > 0) {\n            gizmoAxisCache.forEach((v, k) => {\n                this._gizmoAxisCache.set(k, v);\n            });\n        }\n    }\n\n    /**\n     * Disposes of the gizmo manager\n     */\n    public dispose() {\n\n        this._pointerObservers.forEach((observer) => {\n            this.scene.onPointerObservable.remove(observer);\n        });\n        for (var key in this.gizmos) {\n            var gizmo = <Nullable<Gizmo>>((<any>this.gizmos)[key]);\n            if (gizmo) {\n                gizmo.dispose();\n            }\n        }\n        this._defaultKeepDepthUtilityLayer.dispose();\n        this._defaultUtilityLayer.dispose();\n        this.boundingBoxDragBehavior.detach();\n        this.onAttachedToMeshObservable.clear();\n    }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}