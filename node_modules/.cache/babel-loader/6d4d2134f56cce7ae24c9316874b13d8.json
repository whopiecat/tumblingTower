{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport { PushMaterial } from '../pushMaterial';\nimport { AbstractMesh } from '../../Meshes/abstractMesh';\nimport { Matrix, Vector2 } from '../../Maths/math.vector';\nimport { Color3, Color4 } from '../../Maths/math.color';\nimport { Engine } from '../../Engines/engine';\nimport { NodeMaterialBuildState } from './nodeMaterialBuildState';\nimport { Observable } from '../../Misc/observable';\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\nimport { NodeMaterialBuildStateSharedData } from './nodeMaterialBuildStateSharedData';\nimport { MaterialDefines } from '../../Materials/materialDefines';\nimport { VertexBuffer } from '../../Meshes/buffer';\nimport { Tools } from '../../Misc/tools';\nimport { TransformBlock } from './Blocks/transformBlock';\nimport { VertexOutputBlock } from './Blocks/Vertex/vertexOutputBlock';\nimport { FragmentOutputBlock } from './Blocks/Fragment/fragmentOutputBlock';\nimport { InputBlock } from './Blocks/Input/inputBlock';\nimport { _TypeStore } from '../../Misc/typeStore';\nimport { serialize, SerializationHelper } from '../../Misc/decorators';\nimport { CurrentScreenBlock } from './Blocks/Dual/currentScreenBlock';\nimport { ParticleTextureBlock } from './Blocks/Particle/particleTextureBlock';\nimport { ParticleRampGradientBlock } from './Blocks/Particle/particleRampGradientBlock';\nimport { ParticleBlendMultiplyBlock } from './Blocks/Particle/particleBlendMultiplyBlock';\nimport { EffectFallbacks } from '../effectFallbacks';\nimport { WebRequest } from '../../Misc/webRequest';\nimport { Effect } from '../effect';\nimport { PostProcess } from '../../PostProcesses/postProcess';\nimport { VectorMergerBlock } from './Blocks/vectorMergerBlock';\nimport { RemapBlock } from './Blocks/remapBlock';\nimport { MultiplyBlock } from './Blocks/multiplyBlock';\nimport { NodeMaterialModes } from './Enums/nodeMaterialModes';\nimport { Texture } from '../Textures/texture';\nimport { BaseParticleSystem } from '../../Particles/baseParticleSystem';\nimport { ColorSplitterBlock } from './Blocks/colorSplitterBlock';\nimport { TimingTools } from '../../Misc/timingTools';\nimport { ProceduralTexture } from '../Textures/Procedurals/proceduralTexture';\nimport { AnimatedInputBlockTypes } from './Blocks/Input/animatedInputBlockTypes';\nimport { TrigonometryBlock, TrigonometryBlockOperations } from './Blocks/trigonometryBlock';\nvar onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @hidden */\n\nvar NodeMaterialDefines =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterialDefines, _super);\n\n  function NodeMaterialDefines() {\n    var _this = _super.call(this) || this;\n\n    _this.NORMAL = false;\n    _this.TANGENT = false;\n    _this.UV1 = false;\n    /** BONES */\n\n    _this.NUM_BONE_INFLUENCERS = 0;\n    _this.BonesPerMesh = 0;\n    _this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n\n    _this.MORPHTARGETS = false;\n    _this.MORPHTARGETS_NORMAL = false;\n    _this.MORPHTARGETS_TANGENT = false;\n    _this.MORPHTARGETS_UV = false;\n    _this.NUM_MORPH_INFLUENCERS = 0;\n    /** IMAGE PROCESSING */\n\n    _this.IMAGEPROCESSING = false;\n    _this.VIGNETTE = false;\n    _this.VIGNETTEBLENDMODEMULTIPLY = false;\n    _this.VIGNETTEBLENDMODEOPAQUE = false;\n    _this.TONEMAPPING = false;\n    _this.TONEMAPPING_ACES = false;\n    _this.CONTRAST = false;\n    _this.EXPOSURE = false;\n    _this.COLORCURVES = false;\n    _this.COLORGRADING = false;\n    _this.COLORGRADING3D = false;\n    _this.SAMPLER3DGREENDEPTH = false;\n    _this.SAMPLER3DBGRMAP = false;\n    _this.IMAGEPROCESSINGPOSTPROCESS = false;\n    /** MISC. */\n\n    _this.BUMPDIRECTUV = 0;\n\n    _this.rebuild();\n\n    return _this;\n  }\n\n  NodeMaterialDefines.prototype.setValue = function (name, value, markAsUnprocessedIfDirty) {\n    if (markAsUnprocessedIfDirty === void 0) {\n      markAsUnprocessedIfDirty = false;\n    }\n\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n\n    this[name] = value;\n  };\n\n  return NodeMaterialDefines;\n}(MaterialDefines);\n\nexport { NodeMaterialDefines };\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\n\nvar NodeMaterial =\n/** @class */\nfunction (_super) {\n  __extends(NodeMaterial, _super);\n  /**\r\n   * Create a new node based material\r\n   * @param name defines the material name\r\n   * @param scene defines the hosting scene\r\n   * @param options defines creation option\r\n   */\n\n\n  function NodeMaterial(name, scene, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, name, scene || Engine.LastCreatedScene) || this;\n\n    _this._buildId = NodeMaterial._BuildIdGenerator++;\n    _this._buildWasSuccessful = false;\n    _this._cachedWorldViewMatrix = new Matrix();\n    _this._cachedWorldViewProjectionMatrix = new Matrix();\n    _this._optimizers = new Array();\n    _this._animationFrame = -1;\n    _this.BJSNODEMATERIALEDITOR = _this._getGlobalNodeMaterialEditor();\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\n\n    _this.editorData = null;\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\n\n    _this.ignoreAlpha = false;\n    /**\r\n    * Defines the maximum number of lights that can be used in the material\r\n    */\n\n    _this.maxSimultaneousLights = 4;\n    /**\r\n     * Observable raised when the material is built\r\n     */\n\n    _this.onBuildObservable = new Observable();\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\n\n    _this._vertexOutputNodes = new Array();\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\n\n    _this._fragmentOutputNodes = new Array();\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\n\n    _this.attachedBlocks = new Array();\n    /**\r\n     * Specifies the mode of the node material\r\n     * @hidden\r\n     */\n\n    _this._mode = NodeMaterialModes.Material;\n    _this._options = __assign({\n      emitComments: false\n    }, options); // Setup the default processing configuration to the scene.\n\n    _this._attachImageProcessingConfiguration(null);\n\n    return _this;\n  }\n  /** Get the inspector from bundle or global */\n\n\n  NodeMaterial.prototype._getGlobalNodeMaterialEditor = function () {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== 'undefined') {\n      return NODEEDITOR;\n    } // In case of module let's check the global emitted from the editor entry point.\n\n\n    if (typeof BABYLON !== 'undefined' && typeof BABYLON.NodeEditor !== 'undefined') {\n      return BABYLON;\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"options\", {\n    /** Gets or sets options to control the node material overall behavior */\n    get: function () {\n      return this._options;\n    },\n    set: function (options) {\n      this._options = options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"imageProcessingConfiguration\", {\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\n    get: function () {\n      return this._imageProcessingConfiguration;\n    },\n\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\n    set: function (value) {\n      this._attachImageProcessingConfiguration(value); // Ensure the effect will be rebuilt.\n\n\n      this._markAllSubMeshesAsTexturesDirty();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeMaterial.prototype, \"mode\", {\n    /**\r\n     * Gets the mode property\r\n     */\n    get: function () {\n      return this._mode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n   * @returns the class name\r\n   */\n\n  NodeMaterial.prototype.getClassName = function () {\n    return \"NodeMaterial\";\n  };\n  /**\r\n   * Attaches a new image processing configuration to the Standard Material.\r\n   * @param configuration\r\n   */\n\n\n  NodeMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n    var _this = this;\n\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    } // Detaches observer.\n\n\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    } // Pick the scene configuration if needed.\n\n\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    } // Attaches observer.\n\n\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function () {\n        _this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  };\n  /**\r\n   * Get a block by its name\r\n   * @param name defines the name of the block to retrieve\r\n   * @returns the required block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getBlockByName = function (name) {\n    var result = null;\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\r\n   * Get a block by its name\r\n   * @param predicate defines the predicate used to find the good candidate\r\n   * @returns the required block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Get an input block by its name\r\n   * @param predicate defines the predicate used to find the good candidate\r\n   * @returns the required input block or null if not found\r\n   */\n\n\n  NodeMaterial.prototype.getInputBlockByPredicate = function (predicate) {\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Gets the list of input blocks attached to this material\r\n   * @returns an array of InputBlocks\r\n   */\n\n\n  NodeMaterial.prototype.getInputBlocks = function () {\n    var blocks = [];\n\n    for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n      var block = _a[_i];\n\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n\n    return blocks;\n  };\n  /**\r\n   * Adds a new optimizer to the list of optimizers\r\n   * @param optimizer defines the optimizers to add\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.registerOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index > -1) {\n      return;\n    }\n\n    this._optimizers.push(optimizer);\n\n    return this;\n  };\n  /**\r\n   * Remove an optimizer from the list of optimizers\r\n   * @param optimizer defines the optimizers to remove\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.unregisterOptimizer = function (optimizer) {\n    var index = this._optimizers.indexOf(optimizer);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._optimizers.splice(index, 1);\n\n    return this;\n  };\n  /**\r\n   * Add a new block to the list of output nodes\r\n   * @param node defines the node to add\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.addOutputNode = function (node) {\n    if (node.target === null) {\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n  /**\r\n   * Remove a block from the list of root nodes\r\n   * @param node defines the node to remove\r\n   * @returns the current material\r\n   */\n\n\n  NodeMaterial.prototype.removeOutputNode = function (node) {\n    if (node.target === null) {\n      return this;\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addVertexOutputNode = function (node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Vertex;\n\n    this._vertexOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeVertexOutputNode = function (node) {\n    var index = this._vertexOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._vertexOutputNodes.splice(index, 1);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._addFragmentOutputNode = function (node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n\n    node.target = NodeMaterialBlockTargets.Fragment;\n\n    this._fragmentOutputNodes.push(node);\n\n    return this;\n  };\n\n  NodeMaterial.prototype._removeFragmentOutputNode = function (node) {\n    var index = this._fragmentOutputNodes.indexOf(node);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._fragmentOutputNodes.splice(index, 1);\n\n    return this;\n  };\n  /**\r\n   * Specifies if the material will require alpha blending\r\n   * @returns a boolean specifying if alpha blending is needed\r\n   */\n\n\n  NodeMaterial.prototype.needAlphaBlending = function () {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n\n    return this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  };\n  /**\r\n   * Specifies if this material should be rendered in alpha test mode\r\n   * @returns a boolean specifying if an alpha test is needed.\r\n   */\n\n\n  NodeMaterial.prototype.needAlphaTesting = function () {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  };\n\n  NodeMaterial.prototype._initializeBlock = function (node, state, nodesToProcessForOtherBuildState) {\n    node.initialize(state);\n    node.autoConfigure(this);\n    node._preparationId = this._buildId;\n\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        var className = node.getClassName();\n\n        for (var _i = 0, _a = this.attachedBlocks; _i < _a.length; _i++) {\n          var other = _a[_i];\n\n          if (other.getClassName() === className) {\n            throw \"Cannot have multiple blocks of type \" + className + \" in the same NodeMaterial\";\n          }\n        }\n      }\n\n      this.attachedBlocks.push(node);\n    }\n\n    for (var _b = 0, _c = node.inputs; _b < _c.length; _b++) {\n      var input = _c[_b];\n      input.associatedVariableName = \"\";\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n            nodesToProcessForOtherBuildState.push(block);\n          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n            nodesToProcessForOtherBuildState.push(block);\n          }\n\n          this._initializeBlock(block, state, nodesToProcessForOtherBuildState);\n        }\n      }\n    }\n\n    for (var _d = 0, _e = node.outputs; _d < _e.length; _d++) {\n      var output = _e[_d];\n      output.associatedVariableName = \"\";\n    }\n  };\n\n  NodeMaterial.prototype._resetDualBlocks = function (node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n\n    for (var _i = 0, _a = node.inputs; _i < _a.length; _i++) {\n      var inputs = _a[_i];\n      var connectedPoint = inputs.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n  };\n  /**\r\n   * Remove a block from the current node material\r\n   * @param block defines the block to remove\r\n   */\n\n\n  NodeMaterial.prototype.removeBlock = function (block) {\n    var attachedBlockIndex = this.attachedBlocks.indexOf(block);\n\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  };\n  /**\r\n   * Build the material and generates the inner effect\r\n   * @param verbose defines if the build should log activity\r\n   */\n\n\n  NodeMaterial.prototype.build = function (verbose) {\n    if (verbose === void 0) {\n      verbose = false;\n    }\n\n    this._buildWasSuccessful = false;\n    var engine = this.getScene().getEngine();\n    var allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      throw \"You must define at least one vertexOutputNode\";\n    }\n\n    if (this._fragmentOutputNodes.length === 0) {\n      throw \"You must define at least one fragmentOutputNode\";\n    } // Compilation state\n\n\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment; // Shared data\n\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram; // Initialize blocks\n\n    var vertexNodes = [];\n    var fragmentNodes = [];\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var vertexOutputNode = _a[_i];\n      vertexNodes.push(vertexOutputNode);\n\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes);\n    }\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var fragmentOutputNode = _c[_b];\n      fragmentNodes.push(fragmentOutputNode);\n\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes);\n    } // Optimize\n\n\n    this.optimize(); // Vertex\n\n    for (var _d = 0, vertexNodes_1 = vertexNodes; _d < vertexNodes_1.length; _d++) {\n      var vertexOutputNode = vertexNodes_1[_d];\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    } // Fragment\n\n\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n\n    for (var _e = 0, fragmentNodes_1 = fragmentNodes; _e < fragmentNodes_1.length; _e++) {\n      var fragmentOutputNode = fragmentNodes_1[_e];\n\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n\n    for (var _f = 0, fragmentNodes_2 = fragmentNodes; _f < fragmentNodes_2.length; _f++) {\n      var fragmentOutputNode = fragmentNodes_2[_f];\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    } // Finalize\n\n\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n\n    this._buildId = NodeMaterial._BuildIdGenerator++; // Errors\n\n    this._sharedData.emitErrors();\n\n    if (verbose) {\n      console.log(\"Vertex shader:\");\n      console.log(this._vertexCompilationState.compilationString);\n      console.log(\"Fragment shader:\");\n      console.log(this._fragmentCompilationState.compilationString);\n    }\n\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this); // Wipe defines\n\n    var meshes = this.getScene().meshes;\n\n    for (var _g = 0, meshes_1 = meshes; _g < meshes_1.length; _g++) {\n      var mesh = meshes_1[_g];\n\n      if (!mesh.subMeshes) {\n        continue;\n      }\n\n      for (var _h = 0, _j = mesh.subMeshes; _h < _j.length; _h++) {\n        var subMesh = _j[_h];\n\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n\n        if (!subMesh._materialDefines) {\n          continue;\n        }\n\n        var defines = subMesh._materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n  };\n  /**\r\n   * Runs an otpimization phase to try to improve the shader code\r\n   */\n\n\n  NodeMaterial.prototype.optimize = function () {\n    for (var _i = 0, _a = this._optimizers; _i < _a.length; _i++) {\n      var optimizer = _a[_i];\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  };\n\n  NodeMaterial.prototype._prepareDefinesForAttributes = function (mesh, defines) {\n    var oldNormal = defines[\"NORMAL\"];\n    var oldTangent = defines[\"TANGENT\"];\n    var oldUV1 = defines[\"UV1\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\n\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldUV1 !== defines[\"UV1\"]) {\n      defines.markAsAttributesDirty();\n    }\n  };\n  /**\r\n   * Create a post process from the material\r\n   * @param camera The camera to apply the render pass to.\r\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n   * @param engine The engine which the post process will be applied. (default: current engine)\r\n   * @param reusable If the post process can be reused on the same frame. (default: false)\r\n   * @param textureType Type of textures used when performing the post process. (default: 0)\r\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n   * @returns the post process created\r\n   */\n\n\n  NodeMaterial.prototype.createPostProcess = function (camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  };\n  /**\r\n   * Create the post process effect from the material\r\n   * @param postProcess The post process to create the effect for\r\n   */\n\n\n  NodeMaterial.prototype.createEffectForPostProcess = function (postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  };\n\n  NodeMaterial.prototype._createEffectForPostProcess = function (postProcess, camera, options, samplingMode, engine, reusable, textureType, textureFormat) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = 1;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = 1;\n    }\n\n    if (textureType === void 0) {\n      textureType = 0;\n    }\n\n    if (textureFormat === void 0) {\n      textureFormat = 5;\n    }\n\n    var tempName = this.name + this._buildId;\n    var defines = new NodeMaterialDefines();\n    var dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    var buildId = this._buildId;\n\n    this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          return postProcess.updateEffect(defines.toString(), _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, {\n            maxSimultaneousLights: _this.maxSimultaneousLights\n          }, undefined, undefined, tempName, tempName);\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return postProcess;\n  };\n  /**\r\n   * Create a new procedural texture based on this node material\r\n   * @param size defines the size of the texture\r\n   * @param scene defines the hosting scene\r\n   * @returns the new procedural texture attached to this node material\r\n   */\n\n\n  NodeMaterial.prototype.createProceduralTexture = function (size, scene) {\n    var _this = this;\n\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n\n    var tempName = this.name + this._buildId;\n    var proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    var dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    var defines = new NodeMaterialDefines();\n\n    var result = this._processDefines(dummyMesh, defines);\n\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    var effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n    proceduralTexture._effect = effect;\n    var buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(function () {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString, _this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(function () {\n          effect = _this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n          proceduralTexture._effect = effect;\n        });\n      }\n\n      _this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  };\n\n  NodeMaterial.prototype._createEffectForParticles = function (particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined_) {\n    var _this = this;\n\n    if (particleSystemDefinesJoined_ === void 0) {\n      particleSystemDefinesJoined_ = \"\";\n    }\n\n    var tempName = this.name + this._buildId + \"_\" + blendMode;\n\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n\n    var buildId = this._buildId;\n    var particleSystemDefines = [];\n    var particleSystemDefinesJoined = particleSystemDefinesJoined_;\n\n    if (!effect) {\n      var result = this._processDefines(dummyMesh, defines);\n\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      particleSystemDefinesJoined = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + particleSystemDefinesJoined, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n\n    effect.onBindObservable.add(function (effect) {\n      if (buildId !== _this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = _this.name + _this._buildId + \"_\" + blendMode;\n        defines.markAsUnprocessed();\n        buildId = _this._buildId;\n      }\n\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      var particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n\n      if (particleSystemDefinesJoinedCurrent !== particleSystemDefinesJoined) {\n        defines.markAsUnprocessed();\n        particleSystemDefinesJoined = particleSystemDefinesJoinedCurrent;\n      }\n\n      var result = _this._processDefines(dummyMesh, defines);\n\n      if (result) {\n        Effect.RegisterShader(tempName, _this._fragmentCompilationState._builtCompilationString);\n        effect = _this.getScene().getEngine().createEffectForParticles(tempName, _this._fragmentCompilationState.uniforms, _this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + particleSystemDefinesJoined, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n\n        _this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n\n\n        return;\n      }\n\n      _this._checkInternals(effect);\n    });\n  };\n\n  NodeMaterial.prototype._checkInternals = function (effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      var scene = this.getScene();\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    } // Bindable blocks\n\n\n    for (var _b = 0, _c = this._sharedData.bindableBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.bind(effect, this);\n    } // Connection points\n\n\n    for (var _d = 0, _e = this._sharedData.inputBlocks; _d < _e.length; _d++) {\n      var inputBlock = _e[_d];\n\n      inputBlock._transmit(effect, this.getScene());\n    }\n  };\n  /**\r\n   * Create the effect to be used as the custom effect for a particle system\r\n   * @param particleSystem Particle system to create the effect for\r\n   * @param onCompiled defines a function to call when the effect creation is successful\r\n   * @param onError defines a function to call when the effect creation has failed\r\n   */\n\n\n  NodeMaterial.prototype.createEffectForParticles = function (particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  };\n\n  NodeMaterial.prototype._processDefines = function (mesh, defines, useInstances, subMesh) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    var result = null; // Shared defines\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.initializeDefines(mesh, _this, defines, useInstances);\n    });\n\n    this._sharedData.blocksWithDefines.forEach(function (b) {\n      b.prepareDefines(mesh, _this, defines, useInstances, subMesh);\n    }); // Need to recompile?\n\n\n    if (defines.isDirty) {\n      var lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed(); // Repeatable content generators\n\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n\n      this._sharedData.repeatableContentBlocks.forEach(function (b) {\n        b.replaceRepeatableContent(_this._vertexCompilationState, _this._fragmentCompilationState, mesh, defines);\n      }); // Uniforms\n\n\n      var uniformBuffers_1 = [];\n\n      this._sharedData.dynamicUniformBlocks.forEach(function (b) {\n        b.updateUniformsAndSamples(_this._vertexCompilationState, _this, defines, uniformBuffers_1);\n      });\n\n      var mergedUniforms_1 = this._vertexCompilationState.uniforms;\n\n      this._fragmentCompilationState.uniforms.forEach(function (u) {\n        var index = mergedUniforms_1.indexOf(u);\n\n        if (index === -1) {\n          mergedUniforms_1.push(u);\n        }\n      }); // Samplers\n\n\n      var mergedSamplers_1 = this._vertexCompilationState.samplers;\n\n      this._fragmentCompilationState.samplers.forEach(function (s) {\n        var index = mergedSamplers_1.indexOf(s);\n\n        if (index === -1) {\n          mergedSamplers_1.push(s);\n        }\n      });\n\n      var fallbacks = new EffectFallbacks();\n\n      this._sharedData.blocksWithFallbacks.forEach(function (b) {\n        b.provideFallbacks(mesh, fallbacks);\n      });\n\n      result = {\n        lightDisposed: lightDisposed,\n        uniformBuffers: uniformBuffers_1,\n        mergedUniforms: mergedUniforms_1,\n        mergedSamplers: mergedSamplers_1,\n        fallbacks: fallbacks\n      };\n    }\n\n    return result;\n  };\n  /**\r\n    * Get if the submesh is ready to be used and all its information available.\r\n    * Child classes can use it to update shaders\r\n    * @param mesh defines the mesh to check\r\n    * @param subMesh defines which submesh to check\r\n    * @param useInstances specifies that instances should be used\r\n    * @returns a boolean indicating that the submesh is ready or not\r\n    */\n\n\n  NodeMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n    var _this = this;\n\n    if (useInstances === void 0) {\n      useInstances = false;\n    }\n\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n\n    var scene = this.getScene();\n\n    if (this._sharedData.animatedInputs) {\n      var frameId = scene.getFrameId();\n\n      if (this._animationFrame !== frameId) {\n        for (var _i = 0, _a = this._sharedData.animatedInputs; _i < _a.length; _i++) {\n          var input = _a[_i];\n          input.animate(scene);\n        }\n\n        this._animationFrame = frameId;\n      }\n    }\n\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady) {\n        return true;\n      }\n    }\n\n    if (!subMesh._materialDefines) {\n      subMesh._materialDefines = new NodeMaterialDefines();\n    }\n\n    var defines = subMesh._materialDefines;\n\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n\n    var engine = scene.getEngine();\n\n    this._prepareDefinesForAttributes(mesh, defines); // Check if blocks are ready\n\n\n    if (this._sharedData.blockingBlocks.some(function (b) {\n      return !b.isReady(mesh, _this, defines, useInstances);\n    })) {\n      return false;\n    }\n\n    var result = this._processDefines(mesh, defines, useInstances, subMesh);\n\n    if (result) {\n      var previousEffect = subMesh.effect; // Compilation\n\n      var join = defines.toString();\n      var effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        } // Use previous effect while new one is compiling\n\n\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines);\n        }\n      }\n    }\n\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    return true;\n  };\n\n  Object.defineProperty(NodeMaterial.prototype, \"compiledShaders\", {\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\n    get: function () {\n      return \"// Vertex shader\\r\\n\" + this._vertexCompilationState.compilationString + \"\\r\\n\\r\\n// Fragment shader\\r\\n\" + this._fragmentCompilationState.compilationString;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Binds the world matrix to the material\r\n   * @param world defines the world transformation matrix\r\n   */\n\n  NodeMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n    var scene = this.getScene();\n\n    if (!this._activeEffect) {\n      return;\n    }\n\n    var hints = this._sharedData.hints;\n\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    } // Connection points\n\n\n    for (var _i = 0, _a = this._sharedData.inputBlocks; _i < _a.length; _i++) {\n      var inputBlock = _a[_i];\n\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  };\n  /**\r\n   * Binds the submesh to this material by preparing the effect and shader to draw\r\n   * @param world defines the world transformation matrix\r\n   * @param mesh defines the mesh containing the submesh\r\n   * @param subMesh defines the submesh to bind the material to\r\n   */\n\n\n  NodeMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n    var scene = this.getScene();\n    var effect = subMesh.effect;\n\n    if (!effect) {\n      return;\n    }\n\n    this._activeEffect = effect; // Matrices\n\n    this.bindOnlyWorldMatrix(world);\n\n    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n\n    if (mustRebind) {\n      var sharedData = this._sharedData;\n\n      if (effect && scene.getCachedEffect() !== effect) {\n        // Bindable blocks\n        for (var _i = 0, _a = sharedData.bindableBlocks; _i < _a.length; _i++) {\n          var block = _a[_i];\n          block.bind(effect, this, mesh, subMesh);\n        } // Connection points\n\n\n        for (var _b = 0, _c = sharedData.inputBlocks; _b < _c.length; _b++) {\n          var inputBlock = _c[_b];\n\n          inputBlock._transmit(effect, scene);\n        }\n      }\n    }\n\n    this._afterBind(mesh, this._activeEffect);\n  };\n  /**\r\n   * Gets the active textures from the material\r\n   * @returns an array of textures\r\n   */\n\n\n  NodeMaterial.prototype.getActiveTextures = function () {\n    var activeTextures = _super.prototype.getActiveTextures.call(this);\n\n    if (this._sharedData) {\n      activeTextures.push.apply(activeTextures, this._sharedData.textureBlocks.filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }));\n    }\n\n    return activeTextures;\n  };\n  /**\r\n   * Gets the list of texture blocks\r\n   * @returns an array of texture blocks\r\n   */\n\n\n  NodeMaterial.prototype.getTextureBlocks = function () {\n    if (!this._sharedData) {\n      return [];\n    }\n\n    return this._sharedData.textureBlocks;\n  };\n  /**\r\n   * Specifies if the material uses a texture\r\n   * @param texture defines the texture to check against the material\r\n   * @returns a boolean specifying if the material uses the texture\r\n   */\n\n\n  NodeMaterial.prototype.hasTexture = function (texture) {\n    if (_super.prototype.hasTexture.call(this, texture)) {\n      return true;\n    }\n\n    if (!this._sharedData) {\n      return false;\n    }\n\n    for (var _i = 0, _a = this._sharedData.textureBlocks; _i < _a.length; _i++) {\n      var t = _a[_i];\n\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Disposes the material\r\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n   */\n\n\n  NodeMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (var _i = 0, _a = this._sharedData.textureBlocks.filter(function (tb) {\n        return tb.texture;\n      }).map(function (tb) {\n        return tb.texture;\n      }); _i < _a.length; _i++) {\n        var texture = _a[_i];\n        texture.dispose();\n      }\n    }\n\n    for (var _b = 0, _c = this.attachedBlocks; _b < _c.length; _b++) {\n      var block = _c[_b];\n      block.dispose();\n    }\n\n    this.onBuildObservable.clear();\n\n    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  };\n  /** Creates the node editor window. */\n\n\n  NodeMaterial.prototype._createNodeEditor = function () {\n    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\n      nodeMaterial: this\n    });\n  };\n  /**\r\n   * Launch the node material editor\r\n   * @param config Define the configuration of the editor\r\n   * @return a promise fulfilled when the node editor is visible\r\n   */\n\n\n  NodeMaterial.prototype.edit = function (config) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (typeof _this.BJSNODEMATERIALEDITOR == 'undefined') {\n        var editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL; // Load editor and add it to the DOM\n\n        Tools.LoadScript(editorUrl, function () {\n          _this._createNodeEditor();\n\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        _this._createNodeEditor();\n\n        resolve();\n      }\n    });\n  };\n  /**\r\n   * Clear the current material\r\n   */\n\n\n  NodeMaterial.prototype.clear = function () {\n    this._vertexOutputNodes = [];\n    this._fragmentOutputNodes = [];\n    this.attachedBlocks = [];\n  };\n  /**\r\n   * Clear the current material and set it to a default state\r\n   */\n\n\n  NodeMaterial.prototype.setToDefault = function () {\n    this.clear();\n    this.editorData = null;\n    var positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    var worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.World);\n    var worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    var viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.ViewProjection);\n    var worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput); // Pixel\n\n    var pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for post process\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultPostProcess = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    var uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    var uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    var currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    }); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for procedural texture\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultProceduralTexture = function () {\n    this.clear();\n    this.editorData = null;\n    var position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    var const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    var vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput); // Pixel\n\n    var time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    var color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    var vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    var cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb); // Add to nodes\n\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  };\n  /**\r\n   * Clear the current material and set it to a default state for particle\r\n   */\n\n\n  NodeMaterial.prototype.setToDefaultParticle = function () {\n    this.clear();\n    this.editorData = null; // Pixel\n\n    var uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    var texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    var color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    var multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    var rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    var cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    var blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      \"output\": \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      \"output\": \"a\"\n    });\n    var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput); // Add to nodes\n\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  };\n  /**\r\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n   * @param url defines the url to load from\r\n   * @returns a promise that will fullfil when the material is fully loaded\r\n   */\n\n\n  NodeMaterial.prototype.loadAsync = function (url) {\n    var _this = this;\n\n    return this.getScene()._loadFileAsync(url).then(function (data) {\n      var serializationObject = JSON.parse(data);\n\n      _this.loadFromSerialization(serializationObject, \"\");\n    });\n  };\n\n  NodeMaterial.prototype._gatherBlocks = function (rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n\n    list.push(rootNode);\n\n    for (var _i = 0, _a = rootNode.inputs; _i < _a.length; _i++) {\n      var input = _a[_i];\n      var connectedPoint = input.connectedPoint;\n\n      if (connectedPoint) {\n        var block = connectedPoint.ownerBlock;\n\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n  };\n  /**\r\n   * Generate a string containing the code declaration required to create an equivalent of this material\r\n   * @returns a string\r\n   */\n\n\n  NodeMaterial.prototype.generateCode = function () {\n    var alreadyDumped = [];\n    var vertexBlocks = [];\n    var uniqueNames = []; // Gets active blocks\n\n    for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n      var outputNode = _a[_i];\n\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n\n    var fragmentBlocks = [];\n\n    for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n      var outputNode = _c[_b];\n\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    } // Generate vertex shader\n\n\n    var codeString = \"var nodeMaterial = new BABYLON.NodeMaterial(\\\"\" + (this.name || \"node material\") + \"\\\");\\r\\n\";\n\n    for (var _d = 0, vertexBlocks_1 = vertexBlocks; _d < vertexBlocks_1.length; _d++) {\n      var node = vertexBlocks_1[_d];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Generate fragment shader\n\n\n    for (var _e = 0, fragmentBlocks_1 = fragmentBlocks; _e < fragmentBlocks_1.length; _e++) {\n      var node = fragmentBlocks_1[_e];\n\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    } // Connections\n\n\n    alreadyDumped = [];\n    codeString += \"\\r\\n// Connections\\r\\n\";\n\n    for (var _f = 0, _g = this._vertexOutputNodes; _f < _g.length; _f++) {\n      var node = _g[_f];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n\n    for (var _h = 0, _j = this._fragmentOutputNodes; _h < _j.length; _h++) {\n      var node = _j[_h];\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    } // Output nodes\n\n\n    codeString += \"\\r\\n// Output nodes\\r\\n\";\n\n    for (var _k = 0, _l = this._vertexOutputNodes; _k < _l.length; _k++) {\n      var node = _l[_k];\n      codeString += \"nodeMaterial.addOutputNode(\" + node._codeVariableName + \");\\r\\n\";\n    }\n\n    for (var _m = 0, _o = this._fragmentOutputNodes; _m < _o.length; _m++) {\n      var node = _o[_m];\n      codeString += \"nodeMaterial.addOutputNode(\" + node._codeVariableName + \");\\r\\n\";\n    }\n\n    codeString += \"nodeMaterial.build();\\r\\n\";\n    return codeString;\n  };\n  /**\r\n   * Serializes this material in a JSON representation\r\n   * @returns the serialized material object\r\n   */\n\n\n  NodeMaterial.prototype.serialize = function (selectedBlocks) {\n    var serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n\n    var blocks = [];\n\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = []; // Outputs\n\n      for (var _i = 0, _a = this._vertexOutputNodes; _i < _a.length; _i++) {\n        var outputNode = _a[_i];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n\n      for (var _b = 0, _c = this._fragmentOutputNodes; _b < _c.length; _b++) {\n        var outputNode = _c[_b];\n\n        this._gatherBlocks(outputNode, blocks);\n\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    } // Blocks\n\n\n    serializationObject.blocks = [];\n\n    for (var _d = 0, blocks_1 = blocks; _d < blocks_1.length; _d++) {\n      var block = blocks_1[_d];\n      serializationObject.blocks.push(block.serialize());\n    }\n\n    if (!selectedBlocks) {\n      for (var _e = 0, _f = this.attachedBlocks; _e < _f.length; _e++) {\n        var block = _f[_e];\n\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n\n    return serializationObject;\n  };\n\n  NodeMaterial.prototype._restoreConnections = function (block, source, map) {\n    for (var _i = 0, _a = block.outputs; _i < _a.length; _i++) {\n      var outputPoint = _a[_i];\n\n      for (var _b = 0, _c = source.blocks; _b < _c.length; _b++) {\n        var candidate = _c[_b];\n        var target = map[candidate.id];\n\n        if (!target) {\n          continue;\n        }\n\n        for (var _d = 0, _e = candidate.inputs; _d < _e.length; _d++) {\n          var input = _e[_d];\n\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            var inputPoint = target.getInputByName(input.inputName);\n\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n\n            outputPoint.connectTo(inputPoint, true);\n\n            this._restoreConnections(target, source, map);\n\n            continue;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Clear the current graph and load a new one from a serialization object\r\n   * @param source defines the JSON representation of the material\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @param merge defines whether or not the source must be merged or replace the current content\r\n   */\n\n\n  NodeMaterial.prototype.loadFromSerialization = function (source, rootUrl, merge) {\n    var _a;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (merge === void 0) {\n      merge = false;\n    }\n\n    if (!merge) {\n      this.clear();\n    }\n\n    var map = {}; // Create blocks\n\n    for (var _i = 0, _b = source.blocks; _i < _b.length; _i++) {\n      var parsedBlock = _b[_i];\n\n      var blockType = _TypeStore.GetClass(parsedBlock.customType);\n\n      if (blockType) {\n        var block = new blockType();\n\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    } // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n\n\n    for (var blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      var parsedBlock_1 = source.blocks[blockIndex];\n      var block = map[parsedBlock_1.id];\n\n      if (!block) {\n        continue;\n      }\n\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n\n      this._restoreConnections(block, source, map);\n    } // Outputs\n\n\n    if (source.outputNodes) {\n      for (var _c = 0, _d = source.outputNodes; _c < _d.length; _c++) {\n        var outputNodeId = _d[_c];\n        this.addOutputNode(map[outputNodeId]);\n      }\n    } // UI related info\n\n\n    if (source.locations || source.editorData && source.editorData.locations) {\n      var locations = source.locations || source.editorData.locations;\n\n      for (var _e = 0, locations_1 = locations; _e < locations_1.length; _e++) {\n        var location = locations_1[_e];\n\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n\n      var blockMap = [];\n\n      for (var key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n\n      this.editorData.map = blockMap;\n    }\n\n    this.comment = source.comment;\n\n    if (!merge) {\n      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;\n    }\n  };\n  /**\r\n   * Makes a duplicate of the current material.\r\n   * @param name - name to use for the new material.\r\n   */\n\n\n  NodeMaterial.prototype.clone = function (name) {\n    var _this = this;\n\n    var serializationObject = this.serialize();\n    var clone = SerializationHelper.Clone(function () {\n      return new NodeMaterial(name, _this.getScene(), _this.options);\n    }, this);\n    clone.id = name;\n    clone.name = name;\n    clone.loadFromSerialization(serializationObject);\n    clone.build();\n    return clone;\n  };\n  /**\r\n   * Creates a node material from parsed material data\r\n   * @param source defines the JSON representation of the material\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @returns a new node material\r\n   */\n\n\n  NodeMaterial.Parse = function (source, scene, rootUrl) {\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    var nodeMaterial = SerializationHelper.Parse(function () {\n      return new NodeMaterial(source.name, scene);\n    }, source, scene, rootUrl);\n    nodeMaterial.loadFromSerialization(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  };\n  /**\r\n   * Creates a node material from a snippet saved in a remote file\r\n   * @param name defines the name of the material to create\r\n   * @param url defines the url to load from\r\n   * @param scene defines the hosting scene\r\n   * @returns a promise that will resolve to the new node material\r\n   */\n\n\n  NodeMaterial.ParseFromFileAsync = function (name, url, scene) {\n    var material = new NodeMaterial(name, scene);\n    return new Promise(function (resolve, reject) {\n      return material.loadAsync(url).then(function () {\n        material.build();\n        resolve(material);\n      }).catch(reject);\n    });\n  };\n  /**\r\n   * Creates a node material from a snippet saved by the node material editor\r\n   * @param snippetId defines the snippet to load\r\n   * @param scene defines the hosting scene\r\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n   * @returns a promise that will resolve to the new node material\r\n   */\n\n\n  NodeMaterial.ParseFromSnippetAsync = function (snippetId, scene, rootUrl, nodeMaterial) {\n    var _this = this;\n\n    if (rootUrl === void 0) {\n      rootUrl = \"\";\n    }\n\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(this.CreateDefault(\"blank\", scene));\n    }\n\n    return new Promise(function (resolve, reject) {\n      var request = new WebRequest();\n      request.addEventListener(\"readystatechange\", function () {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            var serializationObject = JSON.parse(snippet.nodeMaterial);\n\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(function () {\n                return new NodeMaterial(snippetId, scene);\n              }, serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n\n            nodeMaterial.loadFromSerialization(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n\n            try {\n              nodeMaterial.build();\n              resolve(nodeMaterial);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  };\n  /**\r\n   * Creates a new node material set to default basic configuration\r\n   * @param name defines the name of the material\r\n   * @param scene defines the hosting scene\r\n   * @returns a new NodeMaterial\r\n   */\n\n\n  NodeMaterial.CreateDefault = function (name, scene) {\n    var newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  };\n\n  NodeMaterial._BuildIdGenerator = 0;\n  /** Define the Url to load node editor script */\n\n  NodeMaterial.EditorURL = \"https://unpkg.com/babylonjs-node-editor@\" + Engine.Version + \"/babylon.nodeEditor.js\";\n  /** Define the Url to load snippets */\n\n  NodeMaterial.SnippetUrl = \"https://snippet.babylonjs.com\";\n  /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\n\n  NodeMaterial.IgnoreTexturesAtLoadTime = false;\n\n  __decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n\n  __decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n\n  return NodeMaterial;\n}(PushMaterial);\n\nexport { NodeMaterial };\n_TypeStore.RegisteredTypes[\"BABYLON.NodeMaterial\"] = NodeMaterial;","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Node/nodeMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from './nodeMaterialBlock';\r\nimport { PushMaterial } from '../pushMaterial';\r\nimport { Scene } from '../../scene';\r\nimport { AbstractMesh } from '../../Meshes/abstractMesh';\r\nimport { Matrix, Vector2 } from '../../Maths/math.vector';\r\nimport { Color3, Color4 } from '../../Maths/math.color';\r\nimport { Mesh } from '../../Meshes/mesh';\r\nimport { Engine } from '../../Engines/engine';\r\nimport { NodeMaterialBuildState } from './nodeMaterialBuildState';\r\nimport { IEffectCreationOptions } from '../effect';\r\nimport { BaseTexture } from '../../Materials/Textures/baseTexture';\r\nimport { Observable, Observer } from '../../Misc/observable';\r\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialBuildStateSharedData } from './nodeMaterialBuildStateSharedData';\r\nimport { SubMesh } from '../../Meshes/subMesh';\r\nimport { MaterialDefines } from '../../Materials/materialDefines';\r\nimport { NodeMaterialOptimizer } from './Optimizers/nodeMaterialOptimizer';\r\nimport { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from '../imageProcessingConfiguration';\r\nimport { Nullable } from '../../types';\r\nimport { VertexBuffer } from '../../Meshes/buffer';\r\nimport { Tools } from '../../Misc/tools';\r\nimport { TransformBlock } from './Blocks/transformBlock';\r\nimport { VertexOutputBlock } from './Blocks/Vertex/vertexOutputBlock';\r\nimport { FragmentOutputBlock } from './Blocks/Fragment/fragmentOutputBlock';\r\nimport { InputBlock } from './Blocks/Input/inputBlock';\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { serialize, SerializationHelper } from '../../Misc/decorators';\r\nimport { TextureBlock } from './Blocks/Dual/textureBlock';\r\nimport { ReflectionTextureBaseBlock } from './Blocks/Dual/reflectionTextureBaseBlock';\r\nimport { RefractionBlock } from './Blocks/PBR/refractionBlock';\r\nimport { CurrentScreenBlock } from './Blocks/Dual/currentScreenBlock';\r\nimport { ParticleTextureBlock } from './Blocks/Particle/particleTextureBlock';\r\nimport { ParticleRampGradientBlock } from './Blocks/Particle/particleRampGradientBlock';\r\nimport { ParticleBlendMultiplyBlock } from './Blocks/Particle/particleBlendMultiplyBlock';\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\nimport { WebRequest } from '../../Misc/webRequest';\r\nimport { Effect } from '../effect';\r\nimport { PostProcess, PostProcessOptions } from '../../PostProcesses/postProcess';\r\n\r\nimport { Camera } from '../../Cameras/camera';\r\nimport { VectorMergerBlock } from './Blocks/vectorMergerBlock';\r\nimport { RemapBlock } from './Blocks/remapBlock';\r\nimport { MultiplyBlock } from './Blocks/multiplyBlock';\r\nimport { NodeMaterialModes } from './Enums/nodeMaterialModes';\r\nimport { Texture } from '../Textures/texture';\r\nimport { IParticleSystem } from '../../Particles/IParticleSystem';\r\nimport { BaseParticleSystem } from '../../Particles/baseParticleSystem';\r\nimport { ColorSplitterBlock } from './Blocks/colorSplitterBlock';\r\nimport { TimingTools } from '../../Misc/timingTools';\r\nimport { ProceduralTexture } from '../Textures/Procedurals/proceduralTexture';\r\nimport { AnimatedInputBlockTypes } from './Blocks/Input/animatedInputBlockTypes';\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from './Blocks/trigonometryBlock';\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare var NODEEDITOR: any;\r\ndeclare var BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URl to load node editor script */\r\n    editorURL?: string;\r\n}\r\n\r\n/** @hidden */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n}\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== 'undefined') {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== 'undefined' && typeof BABYLON.NodeEditor !== 'undefined') {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n    * Defines the maximum number of lights that can be used in the material\r\n    */\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @hidden\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || Engine.LastCreatedScene!);\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            ...options\r\n        };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        }\r\n        else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (var block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (var block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (var block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        let blocks: InputBlock[] = [];\r\n        for (var block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        let index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        let index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        let index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        let index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return (this.alpha < 1.0) || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[]) {\r\n        node.initialize(state);\r\n        node.autoConfigure(this);\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (var other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (var input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            let connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                let block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    } else if (state.target ===  NodeMaterialBlockTargets.Fragment\r\n                        && block.target === NodeMaterialBlockTargets.Vertex\r\n                        && block._preparationId !== this._buildId) {\r\n                            nodesToProcessForOtherBuildState.push(block);\r\n                        }\r\n                    this._initializeBlock(block, state, nodesToProcessForOtherBuildState);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (var inputs of node.inputs) {\r\n            let connectedPoint = inputs.connectedPoint;\r\n            if (connectedPoint) {\r\n                let block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        let attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     */\r\n    public build(verbose: boolean = false) {\r\n        this._buildWasSuccessful = false;\r\n        var engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            throw \"You must define at least one vertexOutputNode\";\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            throw \"You must define at least one fragmentOutputNode\";\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        let vertexNodes: NodeMaterialBlock[] = [];\r\n        let fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (var vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes);\r\n        }\r\n\r\n        for (var fragmentOutputNode of this._fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (var vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (var fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (var fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        this._buildId = NodeMaterial._BuildIdGenerator++;\r\n\r\n        // Errors\r\n        this._sharedData.emitErrors();\r\n\r\n        if (verbose) {\r\n            console.log(\"Vertex shader:\");\r\n            console.log(this._vertexCompilationState.compilationString);\r\n            console.log(\"Fragment shader:\");\r\n            console.log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        this._buildWasSuccessful = true;\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (var mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (var subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh._materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                let defines = subMesh._materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an otpimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (var optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        let oldNormal = defines[\"NORMAL\"];\r\n        let oldTangent = defines[\"TANGENT\"];\r\n        let oldUV1 = defines[\"UV1\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldUV1 !== defines[\"UV1\"]) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>, options: number | PostProcessOptions = 1, samplingMode: number = 1, engine?: Engine, reusable?: boolean,\r\n        textureType: number = 0, textureFormat = 5): Nullable<PostProcess> {\r\n            if (this.mode !== NodeMaterialModes.PostProcess) {\r\n                console.log(\"Incompatible material mode\");\r\n                return null;\r\n            }\r\n            return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>, options: number | PostProcessOptions = 1, samplingMode: number = 1, engine?: Engine, reusable?: boolean,\r\n        textureType: number = 0, textureFormat = 5): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(dummyMesh, defines);\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers,\r\n                options, camera!, samplingMode, engine, reusable, defines.toString(), textureType, tempName, { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, undefined, undefined, tempName, tempName);\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAsUnprocessed();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess!.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, undefined, undefined, tempName, tempName)\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number, height: number, layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        let proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\r\n        dummyMesh.reservedDataStore = {\r\n            hidden: true\r\n        };\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        let result = this._processDefines(dummyMesh, defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        let effect = this.getScene().getEngine().createEffect({\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(), result?.fallbacks, undefined);\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._effect = effect;\r\n\r\n        let buildId = this._buildId;\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAsUnprocessed();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect({\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(), result?.fallbacks, undefined);\r\n\r\n                    proceduralTexture._effect = effect;\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(particleSystem: IParticleSystem, blendMode: number, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void, effect?: Effect, defines?: NodeMaterialDefines, dummyMesh?: Nullable<AbstractMesh>, particleSystemDefinesJoined_ = \"\") {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        if (!dummyMesh) {\r\n            dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\r\n            if (!dummyMesh) {\r\n                dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\r\n                dummyMesh.reservedDataStore = {\r\n                    hidden: true\r\n                };\r\n            }\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        let particleSystemDefines: Array<string> = [];\r\n        let particleSystemDefinesJoined = particleSystemDefinesJoined_;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            particleSystemDefinesJoined = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + particleSystemDefinesJoined, result?.fallbacks, onCompiled, onError, particleSystem);\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines!.markAsUnprocessed();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== particleSystemDefinesJoined) {\r\n                defines!.markAsUnprocessed();\r\n                particleSystemDefinesJoined = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh!, defines!);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n                effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines!.toString() + \"\\n\" + particleSystemDefinesJoined, result?.fallbacks, onCompiled, onError, particleSystem);\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n         // Animated blocks\r\n         if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            let frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (var input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (var block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (var inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    private _processDefines(mesh: AbstractMesh, defines: NodeMaterialDefines, useInstances = false, subMesh?: SubMesh): Nullable<{\r\n        lightDisposed: boolean,\r\n        uniformBuffers: string[],\r\n        mergedUniforms: string[],\r\n        mergedSamplers: string[],\r\n        fallbacks: EffectFallbacks,\r\n     }> {\r\n         let result = null;\r\n\r\n        // Shared defines\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.initializeDefines(mesh, this, defines, useInstances);\r\n        });\r\n\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.prepareDefines(mesh, this, defines, useInstances, subMesh);\r\n        });\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            this._sharedData.repeatableContentBlocks.forEach((b) => {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\r\n            });\r\n\r\n            // Uniforms\r\n            let uniformBuffers: string[] = [];\r\n            this._sharedData.dynamicUniformBlocks.forEach((b) => {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            });\r\n\r\n            let mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            this._fragmentCompilationState.uniforms.forEach((u) => {\r\n                let index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            });\r\n\r\n            // Samplers\r\n            let mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            this._fragmentCompilationState.samplers.forEach((s) => {\r\n                let index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            });\r\n\r\n            var fallbacks = new EffectFallbacks();\r\n\r\n            this._sharedData.blocksWithFallbacks.forEach((b) => {\r\n                b.provideFallbacks(mesh, fallbacks);\r\n            });\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n      * Get if the submesh is ready to be used and all its information available.\r\n      * Child classes can use it to update shaders\r\n      * @param mesh defines the mesh to check\r\n      * @param subMesh defines which submesh to check\r\n      * @param useInstances specifies that instances should be used\r\n      * @returns a boolean indicating that the submesh is ready or not\r\n      */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            let frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (var input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        var defines = <NodeMaterialDefines>subMesh._materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(mesh, defines, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            let previousEffect = subMesh.effect;\r\n            // Compilation\r\n            var join = defines.toString();\r\n            var effect = engine.createEffect({\r\n                vertex: \"nodeMaterial\" + this._buildId,\r\n                fragment: \"nodeMaterial\" + this._buildId,\r\n                vertexSource: this._vertexCompilationState.compilationString,\r\n                fragmentSource: this._fragmentCompilationState.compilationString\r\n            }, <IEffectCreationOptions>{\r\n                attributes: this._vertexCompilationState.attributes,\r\n                uniformsNames: result.mergedUniforms,\r\n                uniformBuffersNames: result.uniformBuffers,\r\n                samplers: result.mergedSamplers,\r\n                defines: join,\r\n                fallbacks: result.fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }\r\n            }, engine);\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        return `// Vertex shader\\r\\n${this._vertexCompilationState.compilationString}\\r\\n\\r\\n// Fragment shader\\r\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        let hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (var inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        let scene = this.getScene();\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        let mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            let sharedData = this._sharedData;\r\n            if (effect && scene.getCachedEffect() !== effect) {\r\n                // Bindable blocks\r\n                for (var block of sharedData.bindableBlocks) {\r\n                    block.bind(effect, this, mesh, subMesh);\r\n                }\r\n\r\n                // Connection points\r\n                for (var inputBlock of sharedData.inputBlocks) {\r\n                    inputBlock._transmit(effect, scene);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): (TextureBlock | ReflectionTextureBaseBlock | RefractionBlock | CurrentScreenBlock | ParticleTextureBlock)[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (var t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n\r\n        if (forceDisposeTextures) {\r\n            for (var texture of this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (var block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.onBuildObservable.clear();\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor() {\r\n        this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\r\n            nodeMaterial: this\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @return a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            if (typeof this.BJSNODEMATERIALEDITOR == 'undefined') {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadScript(editorUrl, () => {\r\n                    this._createNodeEditor();\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor();\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes = [];\r\n        this._fragmentOutputNodes = [];\r\n        this.attachedBlocks = [];\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        var positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        var worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.World);\r\n\r\n        var worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        var viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(BABYLON.NodeMaterialSystemValues.ViewProjection);\r\n\r\n        var worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        var vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        var pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n\r\n        currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\r\n\r\n        var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        var time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        var fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        var vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        var cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { \"output\": \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { \"output\": \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will fullfil when the material is fully loaded\r\n     */\r\n    public loadAsync(url: string) {\r\n        return this.getScene()._loadFileAsync(url).then((data) => {\r\n            const serializationObject = JSON.parse(data as string);\r\n            this.loadFromSerialization(serializationObject, \"\");\r\n        });\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (var input of rootNode.inputs) {\r\n            let connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                let block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        let vertexBlocks: NodeMaterialBlock[] = [];\r\n        let uniqueNames: string[] = [];\r\n        // Gets active blocks\r\n        for (var outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n\r\n        }\r\n\r\n        let fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (var outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\r\\n`;\r\n        for (var node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (var node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\r\\n// Connections\\r\\n\";\r\n        for (var node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (var node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\r\\n// Output nodes\\r\\n\";\r\n        for (var node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        for (var node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        var serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (var outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (var outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (var block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (var block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: {[key: number]: NodeMaterialBlock}) {\r\n        for (var outputPoint of block.outputs) {\r\n            for (var candidate of source.blocks) {\r\n                let target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (var input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        let inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        let map: {[key: number]: NodeMaterialBlock} = {};\r\n\r\n        // Create blocks\r\n        for (var parsedBlock of source.blocks) {\r\n            let blockType = _TypeStore.GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                let block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (var blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            let parsedBlock = source.blocks[blockIndex];\r\n            let block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (var outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || source.editorData && source.editorData.locations) {\r\n            let locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (var location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            let blockMap: number[] = [];\r\n\r\n            for (var key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name - name to use for the new material.\r\n     */\r\n    public clone(name: string): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.loadFromSerialization(serializationObject);\r\n        clone.build();\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new node material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string = \"\"): NodeMaterial {\r\n        let nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        nodeMaterial.loadFromSerialization(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromFileAsync(name: string, url: string, scene: Scene): Promise<NodeMaterial> {\r\n        var material = new NodeMaterial(name, scene);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            return material.loadAsync(url).then(() => {\r\n                material.build();\r\n                resolve(material);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\", nodeMaterial?: NodeMaterial): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(this.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        let serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.loadFromSerialization(serializationObject);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        try {\r\n                            nodeMaterial.build();\r\n                            resolve(nodeMaterial);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        let newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.NodeMaterial\"] = NodeMaterial;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}