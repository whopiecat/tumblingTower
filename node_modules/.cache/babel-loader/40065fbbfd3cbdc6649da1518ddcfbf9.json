{"ast":null,"code":"import { Color4 } from '../Maths/math.color';\n/** Class used to store color4 gradient */\n\nvar ColorGradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new color4 gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param color1 gets or sets first associated color\r\n   * @param color2 gets or sets first second color\r\n   */\n  function ColorGradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets first associated color\r\n   */\n  color1,\n  /**\r\n   * Gets or sets second associated color\r\n   */\n  color2) {\n    this.gradient = gradient;\n    this.color1 = color1;\n    this.color2 = color2;\n  }\n  /**\r\n   * Will get a color picked randomly between color1 and color2.\r\n   * If color2 is undefined then color1 will be used\r\n   * @param result defines the target Color4 to store the result in\r\n   */\n\n\n  ColorGradient.prototype.getColorToRef = function (result) {\n    if (!this.color2) {\n      result.copyFrom(this.color1);\n      return;\n    }\n\n    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\n  };\n\n  return ColorGradient;\n}();\n\nexport { ColorGradient };\n/** Class used to store color 3 gradient */\n\nvar Color3Gradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new color3 gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param color gets or sets associated color\r\n   */\n  function Color3Gradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets the associated color\r\n   */\n  color) {\n    this.gradient = gradient;\n    this.color = color;\n  }\n\n  return Color3Gradient;\n}();\n\nexport { Color3Gradient };\n/** Class used to store factor gradient */\n\nvar FactorGradient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new factor gradient\r\n   * @param gradient gets or sets the gradient value (between 0 and 1)\r\n   * @param factor1 gets or sets first associated factor\r\n   * @param factor2 gets or sets second associated factor\r\n   */\n  function FactorGradient(\n  /**\r\n   * Gets or sets the gradient value (between 0 and 1)\r\n   */\n  gradient,\n  /**\r\n   * Gets or sets first associated factor\r\n   */\n  factor1,\n  /**\r\n   * Gets or sets second associated factor\r\n   */\n  factor2) {\n    this.gradient = gradient;\n    this.factor1 = factor1;\n    this.factor2 = factor2;\n  }\n  /**\r\n   * Will get a number picked randomly between factor1 and factor2.\r\n   * If factor2 is undefined then factor1 will be used\r\n   * @returns the picked number\r\n   */\n\n\n  FactorGradient.prototype.getFactor = function () {\n    if (this.factor2 === undefined || this.factor2 === this.factor1) {\n      return this.factor1;\n    }\n\n    return this.factor1 + (this.factor2 - this.factor1) * Math.random();\n  };\n\n  return FactorGradient;\n}();\n\nexport { FactorGradient };\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\n\nvar GradientHelper =\n/** @class */\nfunction () {\n  function GradientHelper() {}\n  /**\r\n   * Gets the current gradient from an array of IValueGradient\r\n   * @param ratio defines the current ratio to get\r\n   * @param gradients defines the array of IValueGradient\r\n   * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n   */\n\n\n  GradientHelper.GetCurrentGradient = function (ratio, gradients, updateFunc) {\n    // Use last index if over\n    if (gradients[0].gradient > ratio) {\n      updateFunc(gradients[0], gradients[0], 1.0);\n      return;\n    }\n\n    for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\n      var currentGradient = gradients[gradientIndex];\n      var nextGradient = gradients[gradientIndex + 1];\n\n      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\n        var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\n        updateFunc(currentGradient, nextGradient, scale);\n        return;\n      }\n    } // Use last index if over\n\n\n    var lastIndex = gradients.length - 1;\n    updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\n  };\n\n  return GradientHelper;\n}();\n\nexport { GradientHelper };","map":{"version":3,"sources":["../../../sourceES6/core/Misc/gradients.ts"],"names":[],"mappings":"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","sourcesContent":["import { Color3, Color4 } from '../Maths/math.color';\r\n\r\n/** Interface used by value gradients (color, factor, ...) */\r\nexport interface IValueGradient {\r\n    /**\r\n     * Gets or sets the gradient value (between 0 and 1)\r\n     */\r\n    gradient: number;\r\n}\r\n\r\n/** Class used to store color4 gradient */\r\nexport class ColorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color4 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color1 gets or sets first associated color\r\n     * @param color2 gets or sets first second color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated color\r\n         */\r\n        public color1: Color4,\r\n        /**\r\n         * Gets or sets second associated color\r\n         */\r\n        public color2?: Color4) {\r\n    }\r\n\r\n    /**\r\n     * Will get a color picked randomly between color1 and color2.\r\n     * If color2 is undefined then color1 will be used\r\n     * @param result defines the target Color4 to store the result in\r\n     */\r\n    public getColorToRef(result: Color4) {\r\n        if (!this.color2) {\r\n            result.copyFrom(this.color1);\r\n            return;\r\n        }\r\n\r\n        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\r\n    }\r\n}\r\n\r\n/** Class used to store color 3 gradient */\r\nexport class Color3Gradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color3 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color gets or sets associated color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets the associated color\r\n         */\r\n        public color: Color3) {\r\n    }\r\n}\r\n\r\n/** Class used to store factor gradient */\r\nexport class FactorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new factor gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param factor1 gets or sets first associated factor\r\n     * @param factor2 gets or sets second associated factor\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated factor\r\n         */\r\n        public factor1: number,\r\n        /**\r\n         * Gets or sets second associated factor\r\n         */\r\n        public factor2?: number) {\r\n    }\r\n\r\n    /**\r\n     * Will get a number picked randomly between factor1 and factor2.\r\n     * If factor2 is undefined then factor1 will be used\r\n     * @returns the picked number\r\n     */\r\n    public getFactor(): number {\r\n        if (this.factor2 === undefined || this.factor2 === this.factor1) {\r\n            return this.factor1;\r\n        }\r\n\r\n        return this.factor1 + ((this.factor2 - this.factor1) * Math.random());\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\r\nexport class GradientHelper {\r\n    /**\r\n     * Gets the current gradient from an array of IValueGradient\r\n     * @param ratio defines the current ratio to get\r\n     * @param gradients defines the array of IValueGradient\r\n     * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n     */\r\n    public static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void) {\r\n\r\n        // Use last index if over\r\n        if (gradients[0].gradient > ratio) {\r\n            updateFunc(gradients[0], gradients[0], 1.0);\r\n            return;\r\n        }\r\n\r\n        for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\r\n            let currentGradient = gradients[gradientIndex];\r\n            let nextGradient = gradients[gradientIndex + 1];\r\n\r\n            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\r\n                let scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\r\n                updateFunc(currentGradient, nextGradient, scale);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Use last index if over\r\n        const lastIndex = gradients.length - 1;\r\n        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}