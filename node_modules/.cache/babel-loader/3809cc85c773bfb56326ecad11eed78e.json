{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Meshes/buffer\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Engine } from \"../Engines/engine\";\nimport { Path2 } from '../Maths/math.path';\n/**\r\n * Vector2 wth index property\r\n */\n\nvar IndexedVector2 =\n/** @class */\nfunction (_super) {\n  __extends(IndexedVector2, _super);\n\n  function IndexedVector2(original,\n  /** Index of the vector2 */\n  index) {\n    var _this = _super.call(this, original.x, original.y) || this;\n\n    _this.index = index;\n    return _this;\n  }\n\n  return IndexedVector2;\n}(Vector2);\n/**\r\n * Defines points to create a polygon\r\n */\n\n\nvar PolygonPoints =\n/** @class */\nfunction () {\n  function PolygonPoints() {\n    this.elements = new Array();\n  }\n\n  PolygonPoints.prototype.add = function (originalPoints) {\n    var _this = this;\n\n    var result = new Array();\n    originalPoints.forEach(function (point) {\n      var newPoint = new IndexedVector2(point, _this.elements.length);\n      result.push(newPoint);\n\n      _this.elements.push(newPoint);\n    });\n    return result;\n  };\n\n  PolygonPoints.prototype.computeBounds = function () {\n    var lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n    var lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n    this.elements.forEach(function (point) {\n      // x\n      if (point.x < lmin.x) {\n        lmin.x = point.x;\n      } else if (point.x > lmax.x) {\n        lmax.x = point.x;\n      } // y\n\n\n      if (point.y < lmin.y) {\n        lmin.y = point.y;\n      } else if (point.y > lmax.y) {\n        lmax.y = point.y;\n      }\n    });\n    return {\n      min: lmin,\n      max: lmax,\n      width: lmax.x - lmin.x,\n      height: lmax.y - lmin.y\n    };\n  };\n\n  return PolygonPoints;\n}();\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\r\n */\n\n\nvar Polygon =\n/** @class */\nfunction () {\n  function Polygon() {}\n  /**\r\n   * Creates a rectangle\r\n   * @param xmin bottom X coord\r\n   * @param ymin bottom Y coord\r\n   * @param xmax top X coord\r\n   * @param ymax top Y coord\r\n   * @returns points that make the resulting rectation\r\n   */\n\n\n  Polygon.Rectangle = function (xmin, ymin, xmax, ymax) {\n    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n  };\n  /**\r\n   * Creates a circle\r\n   * @param radius radius of circle\r\n   * @param cx scale in x\r\n   * @param cy scale in y\r\n   * @param numberOfSides number of sides that make up the circle\r\n   * @returns points that make the resulting circle\r\n   */\n\n\n  Polygon.Circle = function (radius, cx, cy, numberOfSides) {\n    if (cx === void 0) {\n      cx = 0;\n    }\n\n    if (cy === void 0) {\n      cy = 0;\n    }\n\n    if (numberOfSides === void 0) {\n      numberOfSides = 32;\n    }\n\n    var result = new Array();\n    var angle = 0;\n    var increment = Math.PI * 2 / numberOfSides;\n\n    for (var i = 0; i < numberOfSides; i++) {\n      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n      angle -= increment;\n    }\n\n    return result;\n  };\n  /**\r\n   * Creates a polygon from input string\r\n   * @param input Input polygon data\r\n   * @returns the parsed points\r\n   */\n\n\n  Polygon.Parse = function (input) {\n    var floats = input.split(/[^-+eE\\.\\d]+/).map(parseFloat).filter(function (val) {\n      return !isNaN(val);\n    });\n    var i,\n        result = [];\n\n    for (i = 0; i < (floats.length & 0x7FFFFFFE); i += 2) {\n      result.push(new Vector2(floats[i], floats[i + 1]));\n    }\n\n    return result;\n  };\n  /**\r\n   * Starts building a polygon from x and y coordinates\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @returns the started path2\r\n   */\n\n\n  Polygon.StartingAt = function (x, y) {\n    return Path2.StartingAt(x, y);\n  };\n\n  return Polygon;\n}();\n\nexport { Polygon };\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\r\n */\n\nvar PolygonMeshBuilder =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a PolygonMeshBuilder\r\n   * @param name name of the builder\r\n   * @param contours Path of the polygon\r\n   * @param scene scene to add to when creating the mesh\r\n   * @param earcutInjection can be used to inject your own earcut reference\r\n   */\n  function PolygonMeshBuilder(name, contours, scene, earcutInjection) {\n    if (earcutInjection === void 0) {\n      earcutInjection = earcut;\n    }\n\n    this._points = new PolygonPoints();\n    this._outlinepoints = new PolygonPoints();\n    this._holes = new Array();\n    this._epoints = new Array();\n    this._eholes = new Array();\n    this.bjsEarcut = earcutInjection;\n    this._name = name;\n    this._scene = scene || Engine.LastCreatedScene;\n    var points;\n\n    if (contours instanceof Path2) {\n      points = contours.getPoints();\n    } else {\n      points = contours;\n    }\n\n    this._addToepoint(points);\n\n    this._points.add(points);\n\n    this._outlinepoints.add(points);\n\n    if (typeof this.bjsEarcut === 'undefined') {\n      Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n    }\n  }\n\n  PolygonMeshBuilder.prototype._addToepoint = function (points) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var p = points_1[_i];\n\n      this._epoints.push(p.x, p.y);\n    }\n  };\n  /**\r\n   * Adds a whole within the polygon\r\n   * @param hole Array of points defining the hole\r\n   * @returns this\r\n   */\n\n\n  PolygonMeshBuilder.prototype.addHole = function (hole) {\n    this._points.add(hole);\n\n    var holepoints = new PolygonPoints();\n    holepoints.add(hole);\n\n    this._holes.push(holepoints);\n\n    this._eholes.push(this._epoints.length / 2);\n\n    this._addToepoint(hole);\n\n    return this;\n  };\n  /**\r\n   * Creates the polygon\r\n   * @param updatable If the mesh should be updatable\r\n   * @param depth The depth of the mesh created\r\n   * @returns the created mesh\r\n   */\n\n\n  PolygonMeshBuilder.prototype.build = function (updatable, depth) {\n    if (updatable === void 0) {\n      updatable = false;\n    }\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var result = new Mesh(this._name, this._scene);\n    var vertexData = this.buildVertexData(depth);\n    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n    result.setIndices(vertexData.indices);\n    return result;\n  };\n  /**\r\n   * Creates the polygon\r\n   * @param depth The depth of the mesh created\r\n   * @returns the created VertexData\r\n   */\n\n\n  PolygonMeshBuilder.prototype.buildVertexData = function (depth) {\n    var _this = this;\n\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    var result = new VertexData();\n    var normals = new Array();\n    var positions = new Array();\n    var uvs = new Array();\n\n    var bounds = this._points.computeBounds();\n\n    this._points.elements.forEach(function (p) {\n      normals.push(0, 1.0, 0);\n      positions.push(p.x, 0, p.y);\n      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n    });\n\n    var indices = new Array();\n    var res = this.bjsEarcut(this._epoints, this._eholes, 2);\n\n    for (var i = 0; i < res.length; i++) {\n      indices.push(res[i]);\n    }\n\n    if (depth > 0) {\n      var positionscount = positions.length / 3; //get the current pointcount\n\n      this._points.elements.forEach(function (p) {\n        normals.push(0, -1.0, 0);\n        positions.push(p.x, -depth, p.y);\n        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n      });\n\n      var totalCount = indices.length;\n\n      for (var i = 0; i < totalCount; i += 3) {\n        var i0 = indices[i + 0];\n        var i1 = indices[i + 1];\n        var i2 = indices[i + 2];\n        indices.push(i2 + positionscount);\n        indices.push(i1 + positionscount);\n        indices.push(i0 + positionscount);\n      } //Add the sides\n\n\n      this.addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false);\n\n      this._holes.forEach(function (hole) {\n        _this.addSide(positions, normals, uvs, indices, bounds, hole, depth, true);\n      });\n    }\n\n    result.indices = indices;\n    result.positions = positions;\n    result.normals = normals;\n    result.uvs = uvs;\n    return result;\n  };\n  /**\r\n   * Adds a side to the polygon\r\n   * @param positions points that make the polygon\r\n   * @param normals normals of the polygon\r\n   * @param uvs uvs of the polygon\r\n   * @param indices indices of the polygon\r\n   * @param bounds bounds of the polygon\r\n   * @param points points of the polygon\r\n   * @param depth depth of the polygon\r\n   * @param flip flip of the polygon\r\n   */\n\n\n  PolygonMeshBuilder.prototype.addSide = function (positions, normals, uvs, indices, bounds, points, depth, flip) {\n    var StartIndex = positions.length / 3;\n    var ulength = 0;\n\n    for (var i = 0; i < points.elements.length; i++) {\n      var p = points.elements[i];\n      var p1;\n\n      if (i + 1 > points.elements.length - 1) {\n        p1 = points.elements[0];\n      } else {\n        p1 = points.elements[i + 1];\n      }\n\n      positions.push(p.x, 0, p.y);\n      positions.push(p.x, -depth, p.y);\n      positions.push(p1.x, 0, p1.y);\n      positions.push(p1.x, -depth, p1.y);\n      var v1 = new Vector3(p.x, 0, p.y);\n      var v2 = new Vector3(p1.x, 0, p1.y);\n      var v3 = v2.subtract(v1);\n      var v4 = new Vector3(0, 1, 0);\n      var vn = Vector3.Cross(v3, v4);\n      vn = vn.normalize();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      ulength += v3.length();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n\n      if (!flip) {\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        normals.push(-vn.x, -vn.y, -vn.z);\n        indices.push(StartIndex);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 3);\n        indices.push(StartIndex + 2);\n      } else {\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        normals.push(vn.x, vn.y, vn.z);\n        indices.push(StartIndex);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 1);\n        indices.push(StartIndex + 2);\n        indices.push(StartIndex + 3);\n      }\n\n      StartIndex += 4;\n    }\n  };\n\n  return PolygonMeshBuilder;\n}();\n\nexport { PolygonMeshBuilder };","map":{"version":3,"sources":["../../../sourceES6/core/Meshes/polygonMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Nullable } from \"../types\";\r\nimport { Path2 } from '../Maths/math.path';\r\n\r\ndeclare var earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = new Array<IndexedVector2>();\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n\r\n        var result = new Array<IndexedVector2>();\r\n        originalPoints.forEach((point) => {\r\n            var newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        var lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        var lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            }\r\n            else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            }\r\n            else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectation\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [\r\n            new Vector2(xmin, ymin),\r\n            new Vector2(xmax, ymin),\r\n            new Vector2(xmax, ymax),\r\n            new Vector2(xmin, ymax)\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        var result = new Array<Vector2>();\r\n\r\n        var angle = 0;\r\n        var increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (var i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(\r\n                cx + Math.cos(angle) * radius,\r\n                cy + Math.sin(angle) * radius\r\n            ));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        var floats = input.split(/[^-+eE\\.\\d]+/).map(parseFloat).filter((val) => (!isNaN(val)));\r\n        var i: number, result = [];\r\n        for (i = 0; i < (floats.length & 0x7FFFFFFE); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (let p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || Engine.LastCreatedScene;\r\n\r\n        var points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = (<Vector2[]>contours);\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === 'undefined') {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a whole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        var holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0): Mesh {\r\n        var result = new Mesh(this._name, this._scene);\r\n\r\n        var vertexData = this.buildVertexData(depth);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0): VertexData {\r\n        var result = new VertexData();\r\n\r\n        var normals = new Array<number>();\r\n        var positions = new Array<number>();\r\n        var uvs = new Array<number>();\r\n\r\n        var bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        var indices = new Array<number>();\r\n\r\n        let res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            var positionscount = (positions.length / 3); //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => { //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            let totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                let i0 = indices[i + 0];\r\n                let i1 = indices[i + 1];\r\n                let i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this.addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this.addSide(positions, normals, uvs, indices, bounds, hole, depth, true);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     */\r\n    private addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean) {\r\n        var StartIndex: number = positions.length / 3;\r\n        var ulength: number = 0;\r\n        for (var i: number = 0; i < points.elements.length; i++) {\r\n            var p: IndexedVector2 = points.elements[i];\r\n            var p1: IndexedVector2;\r\n            if ((i + 1) > points.elements.length - 1) {\r\n                p1 = points.elements[0];\r\n            }\r\n            else {\r\n                p1 = points.elements[i + 1];\r\n            }\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            var v1 = new Vector3(p.x, 0, p.y);\r\n            var v2 = new Vector3(p1.x, 0, p1.y);\r\n            var v3 = v2.subtract(v1);\r\n            var v4 = new Vector3(0, 1, 0);\r\n            var vn = Vector3.Cross(v3, v4);\r\n            vn = vn.normalize();\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += v3.length();\r\n            uvs.push((ulength / bounds.width), 0);\r\n            uvs.push((ulength / bounds.width), 1);\r\n\r\n            if (!flip) {\r\n                normals.push(-vn.x, - vn.y, -vn.z);\r\n                normals.push(-vn.x, -vn.y, -vn.z);\r\n                normals.push(-vn.x, -vn.y, -vn.z);\r\n                normals.push(-vn.x, -vn.y, -vn.z);\r\n\r\n                indices.push(StartIndex);\r\n                indices.push(StartIndex + 1);\r\n                indices.push(StartIndex + 2);\r\n\r\n                indices.push(StartIndex + 1);\r\n                indices.push(StartIndex + 3);\r\n                indices.push(StartIndex + 2);\r\n            }\r\n            else {\r\n                normals.push(vn.x, vn.y, vn.z);\r\n                normals.push(vn.x, vn.y, vn.z);\r\n                normals.push(vn.x, vn.y, vn.z);\r\n                normals.push(vn.x, vn.y, vn.z);\r\n\r\n                indices.push(StartIndex);\r\n                indices.push(StartIndex + 2);\r\n                indices.push(StartIndex + 1);\r\n\r\n                indices.push(StartIndex + 1);\r\n                indices.push(StartIndex + 2);\r\n                indices.push(StartIndex + 3);\r\n            }\r\n            StartIndex += 4;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}