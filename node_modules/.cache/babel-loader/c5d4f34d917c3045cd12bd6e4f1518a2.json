{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\nimport { Scene } from \"../scene\";\nimport { Camera } from \"../Cameras/camera\";\n/**\r\n * Class representing a ray with position and direction\r\n */\n\nvar Ray =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new ray\r\n   * @param origin origin point\r\n   * @param direction direction\r\n   * @param length length of the ray\r\n   */\n  function Ray(\n  /** origin point */\n  origin,\n  /** direction */\n  direction,\n  /** length of the ray */\n  length) {\n    if (length === void 0) {\n      length = Number.MAX_VALUE;\n    }\n\n    this.origin = origin;\n    this.direction = direction;\n    this.length = length;\n  } // Methods\n\n  /**\r\n   * Checks if the ray intersects a box\r\n   * This does not account for the ray lenght by design to improve perfs.\r\n   * @param minimum bound of the box\r\n   * @param maximum bound of the box\r\n   * @param intersectionTreshold extra extend to be added to the box in all direction\r\n   * @returns if the box was hit\r\n   */\n\n\n  Ray.prototype.intersectsBoxMinMax = function (minimum, maximum, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n\n    var newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n\n    var d = 0.0;\n    var maxValue = Number.MAX_VALUE;\n    var inv;\n    var min;\n    var max;\n    var temp;\n\n    if (Math.abs(this.direction.x) < 0.0000001) {\n      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.x;\n      min = (newMinimum.x - this.origin.x) * inv;\n      max = (newMaximum.x - this.origin.x) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.y) < 0.0000001) {\n      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.y;\n      min = (newMinimum.y - this.origin.y) * inv;\n      max = (newMaximum.y - this.origin.y) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    if (Math.abs(this.direction.z) < 0.0000001) {\n      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.z;\n      min = (newMinimum.z - this.origin.z) * inv;\n      max = (newMaximum.z - this.origin.z) * inv;\n\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n\n      if (d > maxValue) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks if the ray intersects a box\r\n   * This does not account for the ray lenght by design to improve perfs.\r\n   * @param box the bounding box to check\r\n   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n   * @returns if the box was hit\r\n   */\n\n\n  Ray.prototype.intersectsBox = function (box, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n  };\n  /**\r\n   * If the ray hits a sphere\r\n   * @param sphere the bounding sphere to check\r\n   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n   * @returns true if it hits the sphere\r\n   */\n\n\n  Ray.prototype.intersectsSphere = function (sphere, intersectionTreshold) {\n    if (intersectionTreshold === void 0) {\n      intersectionTreshold = 0;\n    }\n\n    var x = sphere.center.x - this.origin.x;\n    var y = sphere.center.y - this.origin.y;\n    var z = sphere.center.z - this.origin.z;\n    var pyth = x * x + y * y + z * z;\n    var radius = sphere.radius + intersectionTreshold;\n    var rr = radius * radius;\n\n    if (pyth <= rr) {\n      return true;\n    }\n\n    var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n\n    if (dot < 0.0) {\n      return false;\n    }\n\n    var temp = pyth - dot * dot;\n    return temp <= rr;\n  };\n  /**\r\n   * If the ray hits a triange\r\n   * @param vertex0 triangle vertex\r\n   * @param vertex1 triangle vertex\r\n   * @param vertex2 triangle vertex\r\n   * @returns intersection information if hit\r\n   */\n\n\n  Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {\n    var edge1 = Ray._TmpVector3[0];\n    var edge2 = Ray._TmpVector3[1];\n    var pvec = Ray._TmpVector3[2];\n    var tvec = Ray._TmpVector3[3];\n    var qvec = Ray._TmpVector3[4];\n    vertex1.subtractToRef(vertex0, edge1);\n    vertex2.subtractToRef(vertex0, edge2);\n    Vector3.CrossToRef(this.direction, edge2, pvec);\n    var det = Vector3.Dot(edge1, pvec);\n\n    if (det === 0) {\n      return null;\n    }\n\n    var invdet = 1 / det;\n    this.origin.subtractToRef(vertex0, tvec);\n    var bv = Vector3.Dot(tvec, pvec) * invdet;\n\n    if (bv < 0 || bv > 1.0) {\n      return null;\n    }\n\n    Vector3.CrossToRef(tvec, edge1, qvec);\n    var bw = Vector3.Dot(this.direction, qvec) * invdet;\n\n    if (bw < 0 || bv + bw > 1.0) {\n      return null;\n    } //check if the distance is longer than the predefined length.\n\n\n    var distance = Vector3.Dot(edge2, qvec) * invdet;\n\n    if (distance > this.length) {\n      return null;\n    }\n\n    return new IntersectionInfo(1 - bv - bw, bv, distance);\n  };\n  /**\r\n   * Checks if ray intersects a plane\r\n   * @param plane the plane to check\r\n   * @returns the distance away it was hit\r\n   */\n\n\n  Ray.prototype.intersectsPlane = function (plane) {\n    var distance;\n    var result1 = Vector3.Dot(plane.normal, this.direction);\n\n    if (Math.abs(result1) < 9.99999997475243e-7) {\n      return null;\n    } else {\n      var result2 = Vector3.Dot(plane.normal, this.origin);\n      distance = (-plane.d - result2) / result1;\n\n      if (distance < 0.0) {\n        if (distance < -9.99999997475243e-7) {\n          return null;\n        } else {\n          return 0;\n        }\n      }\n\n      return distance;\n    }\n  };\n  /**\r\n   * Calculate the intercept of a ray on a given axis\r\n   * @param axis to check 'x' | 'y' | 'z'\r\n   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n   */\n\n\n  Ray.prototype.intersectsAxis = function (axis, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    switch (axis) {\n      case \"y\":\n        var t = (this.origin.y - offset) / this.direction.y;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n\n      case \"x\":\n        var t = (this.origin.x - offset) / this.direction.x;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n\n      case \"z\":\n        var t = (this.origin.z - offset) / this.direction.z;\n\n        if (t > 0) {\n          return null;\n        }\n\n        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Checks if ray intersects a mesh\r\n   * @param mesh the mesh to check\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @returns picking info of the intersecton\r\n   */\n\n\n  Ray.prototype.intersectsMesh = function (mesh, fastCheck) {\n    var tm = TmpVectors.Matrix[0];\n    mesh.getWorldMatrix().invertToRef(tm);\n\n    if (this._tmpRay) {\n      Ray.TransformToRef(this, tm, this._tmpRay);\n    } else {\n      this._tmpRay = Ray.Transform(this, tm);\n    }\n\n    return mesh.intersects(this._tmpRay, fastCheck);\n  };\n  /**\r\n   * Checks if ray intersects a mesh\r\n   * @param meshes the meshes to check\r\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n   * @param results array to store result in\r\n   * @returns Array of picking infos\r\n   */\n\n\n  Ray.prototype.intersectsMeshes = function (meshes, fastCheck, results) {\n    if (results) {\n      results.length = 0;\n    } else {\n      results = [];\n    }\n\n    for (var i = 0; i < meshes.length; i++) {\n      var pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n\n      if (pickInfo.hit) {\n        results.push(pickInfo);\n      }\n    }\n\n    results.sort(this._comparePickingInfo);\n    return results;\n  };\n\n  Ray.prototype._comparePickingInfo = function (pickingInfoA, pickingInfoB) {\n    if (pickingInfoA.distance < pickingInfoB.distance) {\n      return -1;\n    } else if (pickingInfoA.distance > pickingInfoB.distance) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n  /**\r\n   * Intersection test between the ray and a given segment whithin a given tolerance (threshold)\r\n   * @param sega the first point of the segment to test the intersection against\r\n   * @param segb the second point of the segment to test the intersection against\r\n   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n   * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n   */\n\n\n  Ray.prototype.intersectionSegment = function (sega, segb, threshold) {\n    var o = this.origin;\n    var u = TmpVectors.Vector3[0];\n    var rsegb = TmpVectors.Vector3[1];\n    var v = TmpVectors.Vector3[2];\n    var w = TmpVectors.Vector3[3];\n    segb.subtractToRef(sega, u);\n    this.direction.scaleToRef(Ray.rayl, v);\n    o.addToRef(v, rsegb);\n    sega.subtractToRef(o, w);\n    var a = Vector3.Dot(u, u); // always >= 0\n\n    var b = Vector3.Dot(u, v);\n    var c = Vector3.Dot(v, v); // always >= 0\n\n    var d = Vector3.Dot(u, w);\n    var e = Vector3.Dot(v, w);\n    var D = a * c - b * b; // always >= 0\n\n    var sc,\n        sN,\n        sD = D; // sc = sN / sD, default sD = D >= 0\n\n    var tc,\n        tN,\n        tD = D; // tc = tN / tD, default tD = D >= 0\n    // compute the line parameters of the two closest points\n\n    if (D < Ray.smallnum) {\n      // the lines are almost parallel\n      sN = 0.0; // force using point P0 on segment S1\n\n      sD = 1.0; // to prevent possible division by 0.0 later\n\n      tN = e;\n      tD = c;\n    } else {\n      // get the closest points on the infinite lines\n      sN = b * e - c * d;\n      tN = a * e - b * d;\n\n      if (sN < 0.0) {\n        // sc < 0 => the s=0 edge is visible\n        sN = 0.0;\n        tN = e;\n        tD = c;\n      } else if (sN > sD) {\n        // sc > 1 => the s=1 edge is visible\n        sN = sD;\n        tN = e + b;\n        tD = c;\n      }\n    }\n\n    if (tN < 0.0) {\n      // tc < 0 => the t=0 edge is visible\n      tN = 0.0; // recompute sc for this edge\n\n      if (-d < 0.0) {\n        sN = 0.0;\n      } else if (-d > a) {\n        sN = sD;\n      } else {\n        sN = -d;\n        sD = a;\n      }\n    } else if (tN > tD) {\n      // tc > 1 => the t=1 edge is visible\n      tN = tD; // recompute sc for this edge\n\n      if (-d + b < 0.0) {\n        sN = 0;\n      } else if (-d + b > a) {\n        sN = sD;\n      } else {\n        sN = -d + b;\n        sD = a;\n      }\n    } // finally do the division to get sc and tc\n\n\n    sc = Math.abs(sN) < Ray.smallnum ? 0.0 : sN / sD;\n    tc = Math.abs(tN) < Ray.smallnum ? 0.0 : tN / tD; // get the difference of the two closest points\n\n    var qtc = TmpVectors.Vector3[4];\n    v.scaleToRef(tc, qtc);\n    var qsc = TmpVectors.Vector3[5];\n    u.scaleToRef(sc, qsc);\n    qsc.addInPlace(w);\n    var dP = TmpVectors.Vector3[6];\n    qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n\n    var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n\n    if (isIntersected) {\n      return qsc.length();\n    }\n\n    return -1;\n  };\n  /**\r\n   * Update the ray from viewport position\r\n   * @param x position\r\n   * @param y y position\r\n   * @param viewportWidth viewport width\r\n   * @param viewportHeight viewport height\r\n   * @param world world matrix\r\n   * @param view view matrix\r\n   * @param projection projection matrix\r\n   * @returns this ray updated\r\n   */\n\n\n  Ray.prototype.update = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n    this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n    return this;\n  }; // Statics\n\n  /**\r\n   * Creates a ray with origin and direction of 0,0,0\r\n   * @returns the new ray\r\n   */\n\n\n  Ray.Zero = function () {\n    return new Ray(Vector3.Zero(), Vector3.Zero());\n  };\n  /**\r\n   * Creates a new ray from screen space and viewport\r\n   * @param x position\r\n   * @param y y position\r\n   * @param viewportWidth viewport width\r\n   * @param viewportHeight viewport height\r\n   * @param world world matrix\r\n   * @param view view matrix\r\n   * @param projection projection matrix\r\n   * @returns new ray\r\n   */\n\n\n  Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n    var result = Ray.Zero();\n    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n  };\n  /**\r\n   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n   * transformed to the given world matrix.\r\n   * @param origin The origin point\r\n   * @param end The end point\r\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n   * @returns the new ray\r\n   */\n\n\n  Ray.CreateNewFromTo = function (origin, end, world) {\n    if (world === void 0) {\n      world = Matrix.IdentityReadOnly;\n    }\n\n    var direction = end.subtract(origin);\n    var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    direction.normalize();\n    return Ray.Transform(new Ray(origin, direction, length), world);\n  };\n  /**\r\n   * Transforms a ray by a matrix\r\n   * @param ray ray to transform\r\n   * @param matrix matrix to apply\r\n   * @returns the resulting new ray\r\n   */\n\n\n  Ray.Transform = function (ray, matrix) {\n    var result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    Ray.TransformToRef(ray, matrix, result);\n    return result;\n  };\n  /**\r\n   * Transforms a ray by a matrix\r\n   * @param ray ray to transform\r\n   * @param matrix matrix to apply\r\n   * @param result ray to store result in\r\n   */\n\n\n  Ray.TransformToRef = function (ray, matrix, result) {\n    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n    result.length = ray.length;\n    var dir = result.direction;\n    var len = dir.length();\n\n    if (!(len === 0 || len === 1)) {\n      var num = 1.0 / len;\n      dir.x *= num;\n      dir.y *= num;\n      dir.z *= num;\n      result.length *= len;\n    }\n  };\n  /**\r\n   * Unproject a ray from screen space to object space\r\n   * @param sourceX defines the screen space x coordinate to use\r\n   * @param sourceY defines the screen space y coordinate to use\r\n   * @param viewportWidth defines the current width of the viewport\r\n   * @param viewportHeight defines the current height of the viewport\r\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n   * @param view defines the view matrix to use\r\n   * @param projection defines the projection matrix to use\r\n   */\n\n\n  Ray.prototype.unprojectRayToRef = function (sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n    var matrix = TmpVectors.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    var nearScreenSource = TmpVectors.Vector3[0];\n    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;\n    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    nearScreenSource.z = -1.0;\n    var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0);\n    var nearVec3 = TmpVectors.Vector3[2];\n    var farVec3 = TmpVectors.Vector3[3];\n\n    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n\n    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n\n    this.origin.copyFrom(nearVec3);\n    farVec3.subtractToRef(nearVec3, this.direction);\n    this.direction.normalize();\n  };\n\n  Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\n  Ray.smallnum = 0.00000001;\n  Ray.rayl = 10e8;\n  return Ray;\n}();\n\nexport { Ray };\n\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  var result = Ray.Zero();\n  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n  return result;\n};\n\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace) {\n  if (cameraViewSpace === void 0) {\n    cameraViewSpace = false;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      return this;\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight()); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix());\n  return this;\n};\n\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n  var result = Ray.Zero();\n  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n  return result;\n};\n\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n  if (!PickingInfo) {\n    return this;\n  }\n\n  var engine = this.getEngine();\n\n  if (!camera) {\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n\n    camera = this.activeCamera;\n  }\n\n  var cameraViewport = camera.viewport;\n  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n  var identity = Matrix.Identity(); // Moving coordinates to local viewport world\n\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n  return this;\n};\n\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n  var ray = rayFunction(world);\n  var result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n\n  if (!result || !result.hit) {\n    return null;\n  }\n\n  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n    return null;\n  }\n\n  return result;\n};\n\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfo = null;\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      // first check if the ray intersects the whole bounding box/sphere of the mesh\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        if (onlyBoundingInfo) {\n          // the user only asked for a bounding info check so we can return\n          return pickingInfo;\n        }\n\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_1 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n\n          if (result_1) {\n            pickingInfo = result_1;\n            pickingInfo.thinInstanceIndex = index;\n\n            if (fastCheck) {\n              return pickingInfo;\n            }\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n\n      if (result) {\n        pickingInfo = result;\n\n        if (fastCheck) {\n          return pickingInfo;\n        }\n      }\n    }\n  }\n\n  return pickingInfo || new PickingInfo();\n};\n\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var pickingInfos = new Array();\n\n  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    var mesh = this.meshes[meshIndex];\n\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n\n    var world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\n\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n\n      if (result) {\n        var tmpMatrix = TmpVectors.Matrix[1];\n        var thinMatrices = mesh.thinInstanceGetWorldMatrices();\n\n        for (var index = 0; index < thinMatrices.length; index++) {\n          var thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n\n          var result_2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n\n          if (result_2) {\n            result_2.thinInstanceIndex = index;\n            pickingInfos.push(result_2);\n          }\n        }\n      }\n    } else {\n      var result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n\n      if (result) {\n        pickingInfos.push(result);\n      }\n    }\n  }\n\n  return pickingInfos;\n};\n\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n  var _this = this;\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, true);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate) {\n  var _this = this;\n\n  if (!PickingInfo) {\n    return null;\n  }\n\n  var result = this._internalPick(function (world) {\n    if (!_this._tempPickingRay) {\n      _this._tempPickingRay = Ray.Zero();\n    }\n\n    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);\n\n    return _this._tempPickingRay;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n\n  return result;\n};\n\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n  var _this = this;\n\n  var result = this._internalPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, fastCheck, false, trianglePredicate);\n\n  if (result) {\n    result.ray = ray;\n  }\n\n  return result;\n};\n\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    return _this.createPickingRay(x, y, world, camera || null);\n  }, predicate, trianglePredicate);\n};\n\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n  var _this = this;\n\n  return this._internalMultiPick(function (world) {\n    if (!_this._pickWithRayInverseMatrix) {\n      _this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n\n    world.invertToRef(_this._pickWithRayInverseMatrix);\n\n    if (!_this._cachedRayForTransform) {\n      _this._cachedRayForTransform = Ray.Zero();\n    }\n\n    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);\n    return _this._cachedRayForTransform;\n  }, predicate, trianglePredicate);\n};\n\nCamera.prototype.getForwardRay = function (length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\n\nCamera.prototype.getForwardRayToRef = function (refRay, length, transform, origin) {\n  if (length === void 0) {\n    length = 100;\n  }\n\n  if (!transform) {\n    transform = this.getWorldMatrix();\n  }\n\n  refRay.length = length;\n\n  if (!origin) {\n    refRay.origin.copyFrom(this.position);\n  } else {\n    refRay.origin.copyFrom(origin);\n  }\n\n  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\n  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\n  return refRay;\n};","map":{"version":3,"sources":["../../../sourceES6/core/Culling/ray.ts"],"names":[],"mappings":"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","sourcesContent":["import { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        var d = 0.0;\r\n        var maxValue = Number.MAX_VALUE;\r\n        var inv: number;\r\n        var min: number;\r\n        var max: number;\r\n        var temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        var x = sphere.center.x - this.origin.x;\r\n        var y = sphere.center.y - this.origin.y;\r\n        var z = sphere.center.z - this.origin.z;\r\n        var pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        var rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        var temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        var det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        var invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        var bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        var bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        var distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        var distance: number;\r\n        var result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            var result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\":\r\n                var t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            case \"x\":\r\n                var t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            case \"z\":\r\n                var t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info of the intersecton\r\n     */\r\n    public intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo {\r\n        var tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (var i = 0; i < meshes.length; i++) {\r\n            var pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static smallnum = 0.00000001;\r\n    private static rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment whithin a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray.rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        var a = Vector3.Dot(u, u); // always >= 0\r\n        var b = Vector3.Dot(u, v);\r\n        var c = Vector3.Dot(v, v); // always >= 0\r\n        var d = Vector3.Dot(u, w);\r\n        var e = Vector3.Dot(v, w);\r\n        var D = a * c - b * b; // always >= 0\r\n        var sc: number,\r\n            sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        var tc: number,\r\n            tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray.smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        sc = Math.abs(sN) < Ray.smallnum ? 0.0 : sN / sD;\r\n        tc = Math.abs(tN) < Ray.smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns this ray updated\r\n     */\r\n    public update(x: number, y: number, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Ray {\r\n        this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(x: number, y: number, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): Ray {\r\n        let result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        var direction = end.subtract(origin);\r\n        var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        var result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        var dir = result.direction;\r\n        var len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            var num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(sourceX: float, sourceY: float, viewportWidth: number, viewportHeight: number, world: DeepImmutable<Matrix>, view: DeepImmutable<Matrix>, projection: DeepImmutable<Matrix>): void {\r\n        var matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n        var nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = -1.0;\r\n        var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @hidden */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @hidden */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @hidden */\r\n        _internalPick(rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo>;\r\n\r\n        /** @hidden */\r\n        _internalMultiPick(rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]>;\r\n\r\n        /** @hidden */\r\n        _internalPickForMesh(pickingInfo: Nullable<PickingInfo>, rayFunction: (world: Matrix) => Ray, mesh: AbstractMesh, world: Matrix, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate, skipBoundingInfo?: boolean): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Matrix, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    let result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (x: number, y: number, world: Matrix, result: Ray, camera: Nullable<Camera>, cameraViewSpace = false): Scene {\r\n    var engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    var cameraViewport = camera.viewport;\r\n    var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    let result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    var engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    var cameraViewport = camera.viewport;\r\n    var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    var identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (pickingInfo: Nullable<PickingInfo>, rayFunction: (world: Matrix) => Ray, mesh: AbstractMesh, world: Matrix, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate, skipBoundingInfo?: boolean) {\r\n    let ray = rayFunction(world);\r\n\r\n    let result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, onlyBoundingInfo?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    let pickingInfo = null;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        let mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        let world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            let result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return pickingInfo;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                let thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    let thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    let result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            let result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (rayFunction: (world: Matrix) => Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    let pickingInfos = new Array<PickingInfo>();\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        let mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        let world = mesh.skeleton && mesh.skeleton.overrideMesh ? mesh.skeleton.overrideMesh.getWorldMatrix() : mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            let result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                let thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    let thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    let result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            let result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    var result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pick = function (x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, camera?: Nullable<Camera>, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    var result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    var result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (x: number, y: number, predicate?: (mesh: AbstractMesh) => boolean, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}