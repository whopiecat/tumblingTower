{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport \"../Meshes/Builders/linesBuilder\";\n/**\r\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n * in order to better appreciate the issue one might have.\r\n * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n */\n\nvar RayHelper =\n/** @class */\nfunction () {\n  /**\r\n   * Instantiate a new ray helper.\r\n   * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n   * in order to better appreciate the issue one might have.\r\n   * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n   * @param ray Defines the ray we are currently tryin to visualize\r\n   */\n  function RayHelper(ray) {\n    this.ray = ray;\n  }\n  /**\r\n   * Helper function to create a colored helper in a scene in one line.\r\n   * @param ray Defines the ray we are currently tryin to visualize\r\n   * @param scene Defines the scene the ray is used in\r\n   * @param color Defines the color we want to see the ray in\r\n   * @returns The newly created ray helper.\r\n   */\n\n\n  RayHelper.CreateAndShow = function (ray, scene, color) {\n    var helper = new RayHelper(ray);\n    helper.show(scene, color);\n    return helper;\n  };\n  /**\r\n   * Shows the ray we are willing to debug.\r\n   * @param scene Defines the scene the ray needs to be rendered in\r\n   * @param color Defines the color the ray needs to be rendered in\r\n   */\n\n\n  RayHelper.prototype.show = function (scene, color) {\n    if (!this._renderFunction && this.ray) {\n      var ray = this.ray;\n      this._renderFunction = this._render.bind(this);\n      this._scene = scene;\n      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n      this._renderLine = Mesh.CreateLines(\"ray\", this._renderPoints, scene, true);\n      this._renderLine.isPickable = false;\n\n      if (this._renderFunction) {\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n    }\n\n    if (color && this._renderLine) {\n      this._renderLine.color.copyFrom(color);\n    }\n  };\n  /**\r\n   * Hides the ray we are debugging.\r\n   */\n\n\n  RayHelper.prototype.hide = function () {\n    if (this._renderFunction && this._scene) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n\n      this._scene = null;\n      this._renderFunction = null;\n\n      if (this._renderLine) {\n        this._renderLine.dispose();\n\n        this._renderLine = null;\n      }\n\n      this._renderPoints = [];\n    }\n  };\n\n  RayHelper.prototype._render = function () {\n    var ray = this.ray;\n\n    if (!ray) {\n      return;\n    }\n\n    var point = this._renderPoints[1];\n    var len = Math.min(ray.length, 1000000);\n    point.copyFrom(ray.direction);\n    point.scaleInPlace(len);\n    point.addInPlace(ray.origin);\n\n    this._renderPoints[0].copyFrom(ray.origin);\n\n    Mesh.CreateLines(\"ray\", this._renderPoints, this._scene, true, this._renderLine);\n  };\n  /**\r\n   * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\r\n   * @param mesh Defines the mesh we want the helper attached to\r\n   * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\r\n   * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\r\n   * @param length Defines the length of the ray\r\n   */\n\n\n  RayHelper.prototype.attachToMesh = function (mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n    var _this = this;\n\n    this._attachedToMesh = mesh;\n    var ray = this.ray;\n\n    if (!ray) {\n      return;\n    }\n\n    if (!ray.direction) {\n      ray.direction = Vector3.Zero();\n    }\n\n    if (!ray.origin) {\n      ray.origin = Vector3.Zero();\n    }\n\n    if (length) {\n      ray.length = length;\n    }\n\n    if (!meshSpaceOrigin) {\n      meshSpaceOrigin = Vector3.Zero();\n    }\n\n    if (!meshSpaceDirection) {\n      // -1 so that this will work with Mesh.lookAt\n      meshSpaceDirection = new Vector3(0, 0, -1);\n    }\n\n    if (!this._scene) {\n      this._scene = mesh.getScene();\n    }\n\n    if (!this._meshSpaceDirection) {\n      this._meshSpaceDirection = meshSpaceDirection.clone();\n      this._meshSpaceOrigin = meshSpaceOrigin.clone();\n    } else {\n      this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n\n      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n    }\n\n    if (!this._onAfterRenderObserver) {\n      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n        return _this._updateToMesh();\n      });\n      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(function () {\n        return _this._updateToMesh();\n      });\n    } // force world matrix computation before the first ray helper computation\n\n\n    this._attachedToMesh.computeWorldMatrix(true);\n\n    this._updateToMesh();\n  };\n  /**\r\n   * Detach the ray helper from the mesh it has previously been attached to.\r\n   */\n\n\n  RayHelper.prototype.detachFromMesh = function () {\n    if (this._attachedToMesh && this._scene) {\n      if (this._onAfterRenderObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\n\n        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\n      }\n\n      this._attachedToMesh = null;\n      this._onAfterRenderObserver = null;\n      this._onAfterStepObserver = null;\n      this._scene = null;\n    }\n  };\n\n  RayHelper.prototype._updateToMesh = function () {\n    var ray = this.ray;\n\n    if (!this._attachedToMesh || !ray) {\n      return;\n    }\n\n    if (this._attachedToMesh._isDisposed) {\n      this.detachFromMesh();\n      return;\n    }\n\n    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n\n    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n  };\n  /**\r\n   * Dispose the helper and release its associated resources.\r\n   */\n\n\n  RayHelper.prototype.dispose = function () {\n    this.hide();\n    this.detachFromMesh();\n    this.ray = null;\n  };\n\n  return RayHelper;\n}();\n\nexport { RayHelper };","map":{"version":3,"sources":["../../../sourceES6/core/Debug/rayHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from '../Maths/math.color';\r\nimport { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { LinesMesh } from \"../Meshes/linesMesh\";\r\n\r\nimport \"../Meshes/Builders/linesBuilder\";\r\nimport { Observer } from '../Misc/observable';\r\n\r\n/**\r\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n * in order to better appreciate the issue one might have.\r\n * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n */\r\nexport class RayHelper {\r\n\r\n    /**\r\n     * Defines the ray we are currently tryin to visualize.\r\n     */\r\n    public ray: Nullable<Ray>;\r\n\r\n    private _renderPoints: Vector3[];\r\n    private _renderLine: Nullable<LinesMesh>;\r\n    private _renderFunction: Nullable<() => void>;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>>;\r\n    private _onAfterStepObserver: Nullable<Observer<Scene>>;\r\n    private _attachedToMesh: Nullable<AbstractMesh>;\r\n    private _meshSpaceDirection: Vector3;\r\n    private _meshSpaceOrigin: Vector3;\r\n\r\n    /**\r\n     * Helper function to create a colored helper in a scene in one line.\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     * @param scene Defines the scene the ray is used in\r\n     * @param color Defines the color we want to see the ray in\r\n     * @returns The newly created ray helper.\r\n     */\r\n    public static CreateAndShow(ray: Ray, scene: Scene, color: Color3): RayHelper {\r\n        var helper = new RayHelper(ray);\r\n\r\n        helper.show(scene, color);\r\n\r\n        return helper;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new ray helper.\r\n     * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n     * in order to better appreciate the issue one might have.\r\n     * @see https://doc.babylonjs.com/babylon101/raycasts#debugging\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     */\r\n    constructor(ray: Ray) {\r\n        this.ray = ray;\r\n    }\r\n\r\n    /**\r\n     * Shows the ray we are willing to debug.\r\n     * @param scene Defines the scene the ray needs to be rendered in\r\n     * @param color Defines the color the ray needs to be rendered in\r\n     */\r\n    public show(scene: Scene, color?: Color3): void {\r\n\r\n        if (!this._renderFunction && this.ray) {\r\n\r\n            var ray = this.ray;\r\n\r\n            this._renderFunction = this._render.bind(this);\r\n            this._scene = scene;\r\n            this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\r\n            this._renderLine = Mesh.CreateLines(\"ray\", this._renderPoints, scene, true);\r\n            this._renderLine.isPickable = false;\r\n\r\n            if (this._renderFunction) {\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n        }\r\n\r\n        if (color && this._renderLine) {\r\n            this._renderLine.color.copyFrom(color);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Hides the ray we are debugging.\r\n     */\r\n    public hide(): void {\r\n\r\n        if (this._renderFunction && this._scene) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n            this._scene = null;\r\n            this._renderFunction = null;\r\n            if (this._renderLine) {\r\n                this._renderLine.dispose();\r\n                this._renderLine = null;\r\n            }\r\n\r\n            this._renderPoints = [];\r\n        }\r\n\r\n    }\r\n\r\n    private _render(): void {\r\n\r\n        var ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        var point = this._renderPoints[1];\r\n        var len = Math.min(ray.length, 1000000);\r\n\r\n        point.copyFrom(ray.direction);\r\n        point.scaleInPlace(len);\r\n        point.addInPlace(ray.origin);\r\n\r\n        this._renderPoints[0].copyFrom(ray.origin);\r\n\r\n        Mesh.CreateLines(\"ray\", this._renderPoints, this._scene, true, this._renderLine);\r\n\r\n    }\r\n\r\n    /**\r\n     * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\r\n     * @param mesh Defines the mesh we want the helper attached to\r\n     * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\r\n     * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\r\n     * @param length Defines the length of the ray\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, meshSpaceDirection?: Vector3, meshSpaceOrigin?: Vector3, length?: number): void {\r\n\r\n        this._attachedToMesh = mesh;\r\n\r\n        var ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        if (!ray.direction) {\r\n            ray.direction = Vector3.Zero();\r\n        }\r\n\r\n        if (!ray.origin) {\r\n            ray.origin = Vector3.Zero();\r\n        }\r\n\r\n        if (length) {\r\n            ray.length = length;\r\n        }\r\n\r\n        if (!meshSpaceOrigin) {\r\n            meshSpaceOrigin = Vector3.Zero();\r\n        }\r\n\r\n        if (!meshSpaceDirection) {\r\n            // -1 so that this will work with Mesh.lookAt\r\n            meshSpaceDirection = new Vector3(0, 0, -1);\r\n        }\r\n\r\n        if (!this._scene) {\r\n            this._scene = mesh.getScene();\r\n        }\r\n\r\n        if (!this._meshSpaceDirection) {\r\n            this._meshSpaceDirection = meshSpaceDirection.clone();\r\n            this._meshSpaceOrigin = meshSpaceOrigin.clone();\r\n        } else {\r\n            this._meshSpaceDirection.copyFrom(meshSpaceDirection);\r\n            this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\r\n        }\r\n\r\n        if (!this._onAfterRenderObserver) {\r\n            this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\r\n            this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\r\n        }\r\n\r\n        // force world matrix computation before the first ray helper computation\r\n        this._attachedToMesh.computeWorldMatrix(true);\r\n\r\n        this._updateToMesh();\r\n    }\r\n\r\n    /**\r\n     * Detach the ray helper from the mesh it has previously been attached to.\r\n     */\r\n    public detachFromMesh(): void {\r\n        if (this._attachedToMesh && this._scene) {\r\n            if (this._onAfterRenderObserver) {\r\n                this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\r\n                this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\r\n            }\r\n            this._attachedToMesh = null;\r\n            this._onAfterRenderObserver = null;\r\n            this._onAfterStepObserver = null;\r\n            this._scene = null;\r\n        }\r\n    }\r\n\r\n    private _updateToMesh(): void {\r\n        var ray = this.ray;\r\n\r\n        if (!this._attachedToMesh || !ray) {\r\n            return;\r\n        }\r\n\r\n        if (this._attachedToMesh._isDisposed) {\r\n            this.detachFromMesh();\r\n            return;\r\n        }\r\n\r\n        this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\r\n        Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\r\n    }\r\n\r\n    /**\r\n     * Dispose the helper and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.hide();\r\n        this.detachFromMesh();\r\n        this.ray = null;\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}