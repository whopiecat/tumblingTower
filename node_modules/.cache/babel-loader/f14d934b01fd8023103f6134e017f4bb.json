{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Observable } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport \"../../Engines/Extensions/engine.videoTexture\";\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/how_to/video_texture\r\n */\n\nvar VideoTexture =\n/** @class */\nfunction (_super) {\n  __extends(VideoTexture, _super);\n  /**\r\n   * Creates a video texture.\r\n   * If you want to display a video in your scene, this is the special texture for that.\r\n   * This special texture works similar to other textures, with the exception of a few parameters.\r\n   * @see https://doc.babylonjs.com/how_to/video_texture\r\n   * @param name optional name, will detect from video source, if not defined\r\n   * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n   * @param scene is obviously the current scene.\r\n   * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n   * @param invertY is false by default but can be used to invert video on Y axis\r\n   * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n   * @param settings allows finer control over video usage\r\n   */\n\n\n  function VideoTexture(name, src, scene, generateMipMaps, invertY, samplingMode, settings) {\n    if (generateMipMaps === void 0) {\n      generateMipMaps = false;\n    }\n\n    if (invertY === void 0) {\n      invertY = false;\n    }\n\n    if (samplingMode === void 0) {\n      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;\n    }\n\n    if (settings === void 0) {\n      settings = {\n        autoPlay: true,\n        loop: true,\n        autoUpdateTexture: true\n      };\n    }\n\n    var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n\n    _this._onUserActionRequestedObservable = null;\n    _this._stillImageCaptured = false;\n    _this._displayingPosterTexture = false;\n    _this._frameId = -1;\n    _this._currentSrc = null;\n\n    _this._createInternalTexture = function () {\n      if (_this._texture != null) {\n        if (_this._displayingPosterTexture) {\n          _this._texture.dispose();\n\n          _this._displayingPosterTexture = false;\n        } else {\n          return;\n        }\n      }\n\n      if (!_this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(_this.video.videoWidth) && Tools.IsExponentOfTwo(_this.video.videoHeight)) {\n        _this.wrapU = Texture.WRAP_ADDRESSMODE;\n        _this.wrapV = Texture.WRAP_ADDRESSMODE;\n      } else {\n        _this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        _this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        _this._generateMipMaps = false;\n      }\n\n      _this._texture = _this._getEngine().createDynamicTexture(_this.video.videoWidth, _this.video.videoHeight, _this._generateMipMaps, _this.samplingMode);\n\n      if (!_this.video.autoplay && !_this._settings.poster) {\n        var oldHandler_1 = _this.video.onplaying;\n        var error_1 = false;\n        var oldMuted_1 = _this.video.muted;\n        _this.video.muted = true;\n\n        _this.video.onplaying = function () {\n          _this.video.muted = oldMuted_1;\n          _this.video.onplaying = oldHandler_1;\n          _this._texture.isReady = true;\n\n          _this._updateInternalTexture();\n\n          if (!error_1) {\n            _this.video.pause();\n          }\n\n          if (_this.onLoadObservable.hasObservers()) {\n            _this.onLoadObservable.notifyObservers(_this);\n          }\n        };\n\n        var playing = _this.video.play();\n\n        if (playing) {\n          playing.then(function () {// Everything is good.\n          }).catch(function () {\n            error_1 = true; // On Chrome for instance, new policies might prevent playing without user interaction.\n\n            if (_this._onUserActionRequestedObservable && _this._onUserActionRequestedObservable.hasObservers()) {\n              _this._onUserActionRequestedObservable.notifyObservers(_this);\n            }\n          });\n        } else {\n          _this.video.onplaying = oldHandler_1;\n          _this._texture.isReady = true;\n\n          _this._updateInternalTexture();\n\n          if (_this.onLoadObservable.hasObservers()) {\n            _this.onLoadObservable.notifyObservers(_this);\n          }\n        }\n      } else {\n        _this._texture.isReady = true;\n\n        _this._updateInternalTexture();\n\n        if (_this.onLoadObservable.hasObservers()) {\n          _this.onLoadObservable.notifyObservers(_this);\n        }\n      }\n    };\n\n    _this.reset = function () {\n      if (_this._texture == null) {\n        return;\n      }\n\n      if (!_this._displayingPosterTexture) {\n        _this._texture.dispose();\n\n        _this._texture = null;\n      }\n    };\n\n    _this._updateInternalTexture = function () {\n      if (_this._texture == null || !_this._texture.isReady) {\n        return;\n      }\n\n      if (_this.video.readyState < _this.video.HAVE_CURRENT_DATA) {\n        return;\n      }\n\n      if (_this._displayingPosterTexture) {\n        return;\n      }\n\n      var frameId = _this.getScene().getFrameId();\n\n      if (_this._frameId === frameId) {\n        return;\n      }\n\n      _this._frameId = frameId;\n\n      _this._getEngine().updateVideoTexture(_this._texture, _this.video, _this._invertY);\n    };\n\n    _this._generateMipMaps = generateMipMaps;\n    _this._initialSamplingMode = samplingMode;\n    _this.autoUpdateTexture = settings.autoUpdateTexture;\n    _this._currentSrc = src;\n    _this.name = name || _this._getName(src);\n    _this.video = _this._getVideo(src);\n    _this._settings = settings;\n\n    if (settings.poster) {\n      _this.video.poster = settings.poster;\n    }\n\n    if (settings.autoPlay !== undefined) {\n      _this.video.autoplay = settings.autoPlay;\n    }\n\n    if (settings.loop !== undefined) {\n      _this.video.loop = settings.loop;\n    }\n\n    if (settings.muted !== undefined) {\n      _this.video.muted = settings.muted;\n    }\n\n    _this.video.setAttribute(\"playsinline\", \"\");\n\n    _this.video.addEventListener(\"paused\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"seeked\", _this._updateInternalTexture);\n\n    _this.video.addEventListener(\"emptied\", _this.reset);\n\n    _this._createInternalTextureOnEvent = settings.poster && !settings.autoPlay ? \"play\" : \"canplay\";\n\n    _this.video.addEventListener(_this._createInternalTextureOnEvent, _this._createInternalTexture);\n\n    if (settings.autoPlay) {\n      _this.video.play();\n    }\n\n    var videoHasEnoughData = _this.video.readyState >= _this.video.HAVE_CURRENT_DATA;\n\n    if (settings.poster && (!settings.autoPlay || !videoHasEnoughData)) {\n      _this._texture = _this._getEngine().createTexture(settings.poster, false, !_this.invertY, scene);\n      _this._displayingPosterTexture = true;\n    } else if (videoHasEnoughData) {\n      _this._createInternalTexture();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(VideoTexture.prototype, \"onUserActionRequestedObservable\", {\n    /**\r\n     * Event triggerd when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\n    get: function () {\n      if (!this._onUserActionRequestedObservable) {\n        this._onUserActionRequestedObservable = new Observable();\n      }\n\n      return this._onUserActionRequestedObservable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  VideoTexture.prototype._getName = function (src) {\n    if (src instanceof HTMLVideoElement) {\n      return src.currentSrc;\n    }\n\n    if (typeof src === \"object\") {\n      return src.toString();\n    }\n\n    return src;\n  };\n\n  VideoTexture.prototype._getVideo = function (src) {\n    if (src instanceof HTMLVideoElement) {\n      Tools.SetCorsBehavior(src.currentSrc, src);\n      return src;\n    }\n\n    var video = document.createElement(\"video\");\n\n    if (typeof src === \"string\") {\n      Tools.SetCorsBehavior(src, video);\n      video.src = src;\n    } else {\n      Tools.SetCorsBehavior(src[0], video);\n      src.forEach(function (url) {\n        var source = document.createElement(\"source\");\n        source.src = url;\n        video.appendChild(source);\n      });\n    }\n\n    return video;\n  };\n  /**\r\n   * @hidden Internal method to initiate `update`.\r\n   */\n\n\n  VideoTexture.prototype._rebuild = function () {\n    this.update();\n  };\n  /**\r\n   * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n   */\n\n\n  VideoTexture.prototype.update = function () {\n    if (!this.autoUpdateTexture) {\n      // Expecting user to call `updateTexture` manually\n      return;\n    }\n\n    this.updateTexture(true);\n  };\n  /**\r\n   * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n   * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.\r\n   */\n\n\n  VideoTexture.prototype.updateTexture = function (isVisible) {\n    if (!isVisible) {\n      return;\n    }\n\n    if (this.video.paused && this._stillImageCaptured) {\n      return;\n    }\n\n    this._stillImageCaptured = true;\n\n    this._updateInternalTexture();\n  };\n  /**\r\n   * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n   * @param url New url.\r\n   */\n\n\n  VideoTexture.prototype.updateURL = function (url) {\n    this.video.src = url;\n    this._currentSrc = url;\n  };\n  /**\r\n   * Clones the texture.\r\n   * @returns the cloned texture\r\n   */\n\n\n  VideoTexture.prototype.clone = function () {\n    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\n  };\n  /**\r\n   * Dispose the texture and release its associated resources.\r\n   */\n\n\n  VideoTexture.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this._currentSrc = null;\n\n    if (this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable.clear();\n\n      this._onUserActionRequestedObservable = null;\n    }\n\n    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    this.video.removeEventListener(\"paused\", this._updateInternalTexture);\n    this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\n    this.video.removeEventListener(\"emptied\", this.reset);\n    this.video.pause();\n  };\n  /**\r\n   * Creates a video texture straight from a stream.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param stream Define the stream the texture should be created from\r\n   * @returns The created video texture as a promise\r\n   */\n\n\n  VideoTexture.CreateFromStreamAsync = function (scene, stream) {\n    var video = document.createElement(\"video\");\n\n    if (scene.getEngine()._badOS) {\n      // Yes... I know and I hope to remove it soon...\n      document.body.appendChild(video);\n      video.style.transform = 'scale(0.0001, 0.0001)';\n      video.style.opacity = '0';\n      video.style.position = 'fixed';\n      video.style.bottom = '0px';\n      video.style.right = '0px';\n    }\n\n    video.setAttribute('autoplay', '');\n    video.setAttribute('muted', 'true');\n    video.setAttribute('playsinline', '');\n    video.muted = true;\n\n    if (video.mozSrcObject !== undefined) {\n      // hack for Firefox < 19\n      video.mozSrcObject = stream;\n    } else {\n      if (typeof video.srcObject == \"object\") {\n        video.srcObject = stream;\n      } else {\n        window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n        video.src = window.URL && window.URL.createObjectURL(stream);\n      }\n    }\n\n    return new Promise(function (resolve) {\n      var onPlaying = function () {\n        resolve(new VideoTexture(\"video\", video, scene, true, true));\n        video.removeEventListener(\"playing\", onPlaying);\n      };\n\n      video.addEventListener(\"playing\", onPlaying);\n      video.play();\n    });\n  };\n  /**\r\n   * Creates a video texture straight from your WebCam video feed.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n   * @returns The created video texture as a promise\r\n   */\n\n\n  VideoTexture.CreateFromWebCamAsync = function (scene, constraints, audioConstaints) {\n    var _this = this;\n\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    var constraintsDeviceId;\n\n    if (constraints && constraints.deviceId) {\n      constraintsDeviceId = {\n        exact: constraints.deviceId\n      };\n    }\n\n    if (navigator.mediaDevices) {\n      return navigator.mediaDevices.getUserMedia({\n        video: constraints,\n        audio: audioConstaints\n      }).then(function (stream) {\n        return _this.CreateFromStreamAsync(scene, stream);\n      });\n    } else {\n      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\n      if (navigator.getUserMedia) {\n        navigator.getUserMedia({\n          video: {\n            deviceId: constraintsDeviceId,\n            width: {\n              min: constraints && constraints.minWidth || 256,\n              max: constraints && constraints.maxWidth || 640\n            },\n            height: {\n              min: constraints && constraints.minHeight || 256,\n              max: constraints && constraints.maxHeight || 480\n            }\n          },\n          audio: audioConstaints\n        }, function (stream) {\n          return _this.CreateFromStreamAsync(scene, stream);\n        }, function (e) {\n          Logger.Error(e.name);\n        });\n      }\n    }\n\n    return Promise.reject(\"No support for userMedia on this device\");\n  };\n  /**\r\n   * Creates a video texture straight from your WebCam video feed.\r\n   * @param scene Define the scene the texture should be created in\r\n   * @param onReady Define a callback to triggered once the texture will be ready\r\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n   */\n\n\n  VideoTexture.CreateFromWebCam = function (scene, onReady, constraints, audioConstaints) {\n    if (audioConstaints === void 0) {\n      audioConstaints = false;\n    }\n\n    this.CreateFromWebCamAsync(scene, constraints, audioConstaints).then(function (videoTexture) {\n      if (onReady) {\n        onReady(videoTexture);\n      }\n    }).catch(function (err) {\n      Logger.Error(err.name);\n    });\n  };\n\n  return VideoTexture;\n}(Texture);\n\nexport { VideoTexture };","map":{"version":3,"sources":["../../../../sourceES6/core/Materials/Textures/videoTexture.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,QAA2B,uBAA3B;AACA,SAAS,KAAT,QAAsB,kBAAtB;AACA,SAAS,MAAT,QAAuB,mBAAvB;AAGA,SAAS,OAAT,QAAwB,kCAAxB;AAEA,OAAO,8CAAP;AACA,OAAO,gDAAP;AAgCA;;;;;;AAKA,IAAA,YAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAkC,EAAA,SAAA,CAAA,YAAA,EAAA,MAAA,CAAA;AAgC9B;;;;;;;;;;;;;;;AAaA,WAAA,YAAA,CACI,IADJ,EAEI,GAFJ,EAGI,KAHJ,EAII,eAJJ,EAKI,OALJ,EAMI,YANJ,EAOI,QAPJ,EAWK;AAPD,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,KAAA;AAAuB;;AACvB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,KAAA;AAAe;;AACf,QAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,YAAA,GAAuB,OAAO,CAAC,sBAA/B;AAAqD;;AACrD,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA;AACI,QAAA,QAAQ,EAAE,IADd;AAEI,QAAA,IAAI,EAAE,IAFV;AAGI,QAAA,iBAAiB,EAAE;AAHvB,OAAA;AAIC;;AAXL,QAAA,KAAA,GAaI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,KAAZ,EAAmB,CAAC,eAApB,EAAqC,OAArC,KAA6C,IAbjD;;AAlCQ,IAAA,KAAA,CAAA,gCAAA,GAAkE,IAAlE;AAcA,IAAA,KAAA,CAAA,mBAAA,GAAsB,KAAtB;AACA,IAAA,KAAA,CAAA,wBAAA,GAA2B,KAA3B;AAGA,IAAA,KAAA,CAAA,QAAA,GAAW,CAAC,CAAZ;AACA,IAAA,KAAA,CAAA,WAAA,GAA8D,IAA9D;;AA2GA,IAAA,KAAA,CAAA,sBAAA,GAAyB,YAAA;AAC7B,UAAI,KAAI,CAAC,QAAL,IAAiB,IAArB,EAA2B;AACvB,YAAI,KAAI,CAAC,wBAAT,EAAmC;AAC/B,UAAA,KAAI,CAAC,QAAL,CAAc,OAAd;;AACA,UAAA,KAAI,CAAC,wBAAL,GAAgC,KAAhC;AACH,SAHD,MAIK;AACD;AACH;AACJ;;AAED,UAAI,CAAC,KAAI,CAAC,UAAL,GAAmB,eAApB,IACC,KAAK,CAAC,eAAN,CAAsB,KAAI,CAAC,KAAL,CAAW,UAAjC,KAAgD,KAAK,CAAC,eAAN,CAAsB,KAAI,CAAC,KAAL,CAAW,WAAjC,CADrD,EACqG;AACjG,QAAA,KAAI,CAAC,KAAL,GAAa,OAAO,CAAC,gBAArB;AACA,QAAA,KAAI,CAAC,KAAL,GAAa,OAAO,CAAC,gBAArB;AACH,OAJD,MAIO;AACH,QAAA,KAAI,CAAC,KAAL,GAAa,OAAO,CAAC,iBAArB;AACA,QAAA,KAAI,CAAC,KAAL,GAAa,OAAO,CAAC,iBAArB;AACA,QAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;AACH;;AAED,MAAA,KAAI,CAAC,QAAL,GAAgB,KAAI,CAAC,UAAL,GAAmB,oBAAnB,CACZ,KAAI,CAAC,KAAL,CAAW,UADC,EAEZ,KAAI,CAAC,KAAL,CAAW,WAFC,EAGZ,KAAI,CAAC,gBAHO,EAIZ,KAAI,CAAC,YAJO,CAAhB;;AAOA,UAAI,CAAC,KAAI,CAAC,KAAL,CAAW,QAAZ,IAAwB,CAAC,KAAI,CAAC,SAAL,CAAe,MAA5C,EAAoD;AAChD,YAAI,YAAU,GAAG,KAAI,CAAC,KAAL,CAAW,SAA5B;AACA,YAAI,OAAK,GAAG,KAAZ;AACA,YAAI,UAAQ,GAAG,KAAI,CAAC,KAAL,CAAW,KAA1B;AACA,QAAA,KAAI,CAAC,KAAL,CAAW,KAAX,GAAmB,IAAnB;;AACA,QAAA,KAAI,CAAC,KAAL,CAAW,SAAX,GAAuB,YAAA;AACnB,UAAA,KAAI,CAAC,KAAL,CAAW,KAAX,GAAmB,UAAnB;AACA,UAAA,KAAI,CAAC,KAAL,CAAW,SAAX,GAAuB,YAAvB;AACA,UAAA,KAAI,CAAC,QAAL,CAAe,OAAf,GAAyB,IAAzB;;AACA,UAAA,KAAI,CAAC,sBAAL;;AACA,cAAI,CAAC,OAAL,EAAY;AACR,YAAA,KAAI,CAAC,KAAL,CAAW,KAAX;AACH;;AACD,cAAI,KAAI,CAAC,gBAAL,CAAsB,YAAtB,EAAJ,EAA0C;AACtC,YAAA,KAAI,CAAC,gBAAL,CAAsB,eAAtB,CAAsC,KAAtC;AACH;AACJ,SAXD;;AAYA,YAAI,OAAO,GAAG,KAAI,CAAC,KAAL,CAAW,IAAX,EAAd;;AACA,YAAI,OAAJ,EAAa;AACT,UAAA,OAAO,CAAC,IAAR,CAAa,YAAA,CACT;AACH,WAFD,EAGK,KAHL,CAGW,YAAA;AACH,YAAA,OAAK,GAAG,IAAR,CADG,CAEH;;AACA,gBAAI,KAAI,CAAC,gCAAL,IAAyC,KAAI,CAAC,gCAAL,CAAsC,YAAtC,EAA7C,EAAmG;AAC/F,cAAA,KAAI,CAAC,gCAAL,CAAsC,eAAtC,CAAsD,KAAtD;AACH;AACJ,WATL;AAUH,SAXD,MAYK;AACD,UAAA,KAAI,CAAC,KAAL,CAAW,SAAX,GAAuB,YAAvB;AACA,UAAA,KAAI,CAAC,QAAL,CAAc,OAAd,GAAwB,IAAxB;;AACA,UAAA,KAAI,CAAC,sBAAL;;AACA,cAAI,KAAI,CAAC,gBAAL,CAAsB,YAAtB,EAAJ,EAA0C;AACtC,YAAA,KAAI,CAAC,gBAAL,CAAsB,eAAtB,CAAsC,KAAtC;AACH;AACJ;AACJ,OAtCD,MAuCK;AACD,QAAA,KAAI,CAAC,QAAL,CAAc,OAAd,GAAwB,IAAxB;;AACA,QAAA,KAAI,CAAC,sBAAL;;AACA,YAAI,KAAI,CAAC,gBAAL,CAAsB,YAAtB,EAAJ,EAA0C;AACtC,UAAA,KAAI,CAAC,gBAAL,CAAsB,eAAtB,CAAsC,KAAtC;AACH;AACJ;AACJ,KA1EO;;AA4EA,IAAA,KAAA,CAAA,KAAA,GAAQ,YAAA;AACZ,UAAI,KAAI,CAAC,QAAL,IAAiB,IAArB,EAA2B;AACvB;AACH;;AAED,UAAI,CAAC,KAAI,CAAC,wBAAV,EAAoC;AAChC,QAAA,KAAI,CAAC,QAAL,CAAc,OAAd;;AACA,QAAA,KAAI,CAAC,QAAL,GAAgB,IAAhB;AACH;AACJ,KATO;;AA6CE,IAAA,KAAA,CAAA,sBAAA,GAAyB,YAAA;AAC/B,UAAI,KAAI,CAAC,QAAL,IAAiB,IAAjB,IAAyB,CAAC,KAAI,CAAC,QAAL,CAAc,OAA5C,EAAqD;AACjD;AACH;;AACD,UAAI,KAAI,CAAC,KAAL,CAAW,UAAX,GAAwB,KAAI,CAAC,KAAL,CAAW,iBAAvC,EAA0D;AACtD;AACH;;AACD,UAAI,KAAI,CAAC,wBAAT,EAAmC;AAC/B;AACH;;AAED,UAAI,OAAO,GAAG,KAAI,CAAC,QAAL,GAAiB,UAAjB,EAAd;;AACA,UAAI,KAAI,CAAC,QAAL,KAAkB,OAAtB,EAA+B;AAC3B;AACH;;AAED,MAAA,KAAI,CAAC,QAAL,GAAgB,OAAhB;;AAEA,MAAA,KAAI,CAAC,UAAL,GAAmB,kBAAnB,CAAsC,KAAI,CAAC,QAA3C,EAAqD,KAAI,CAAC,KAA1D,EAAiE,KAAI,CAAC,QAAtE;AACH,KAnBS;;AAtMN,IAAA,KAAI,CAAC,gBAAL,GAAwB,eAAxB;AACA,IAAA,KAAI,CAAC,oBAAL,GAA4B,YAA5B;AACA,IAAA,KAAI,CAAC,iBAAL,GAAyB,QAAQ,CAAC,iBAAlC;AAEA,IAAA,KAAI,CAAC,WAAL,GAAmB,GAAnB;AACA,IAAA,KAAI,CAAC,IAAL,GAAY,IAAI,IAAI,KAAI,CAAC,QAAL,CAAc,GAAd,CAApB;AACA,IAAA,KAAI,CAAC,KAAL,GAAa,KAAI,CAAC,SAAL,CAAe,GAAf,CAAb;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,QAAjB;;AAEA,QAAI,QAAQ,CAAC,MAAb,EAAqB;AACjB,MAAA,KAAI,CAAC,KAAL,CAAW,MAAX,GAAoB,QAAQ,CAAC,MAA7B;AACH;;AACD,QAAI,QAAQ,CAAC,QAAT,KAAsB,SAA1B,EAAqC;AACjC,MAAA,KAAI,CAAC,KAAL,CAAW,QAAX,GAAsB,QAAQ,CAAC,QAA/B;AACH;;AACD,QAAI,QAAQ,CAAC,IAAT,KAAkB,SAAtB,EAAiC;AAC7B,MAAA,KAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,QAAQ,CAAC,IAA3B;AACH;;AACD,QAAI,QAAQ,CAAC,KAAT,KAAmB,SAAvB,EAAkC;AAC9B,MAAA,KAAI,CAAC,KAAL,CAAW,KAAX,GAAmB,QAAQ,CAAC,KAA5B;AACH;;AAED,IAAA,KAAI,CAAC,KAAL,CAAW,YAAX,CAAwB,aAAxB,EAAuC,EAAvC;;AAEA,IAAA,KAAI,CAAC,KAAL,CAAW,gBAAX,CAA4B,QAA5B,EAAsC,KAAI,CAAC,sBAA3C;;AACA,IAAA,KAAI,CAAC,KAAL,CAAW,gBAAX,CAA4B,QAA5B,EAAsC,KAAI,CAAC,sBAA3C;;AACA,IAAA,KAAI,CAAC,KAAL,CAAW,gBAAX,CAA4B,SAA5B,EAAuC,KAAI,CAAC,KAA5C;;AACA,IAAA,KAAI,CAAC,6BAAL,GAAsC,QAAQ,CAAC,MAAT,IAAmB,CAAC,QAAQ,CAAC,QAA9B,GAA0C,MAA1C,GAAmD,SAAxF;;AACA,IAAA,KAAI,CAAC,KAAL,CAAW,gBAAX,CAA4B,KAAI,CAAC,6BAAjC,EAAgE,KAAI,CAAC,sBAArE;;AAEA,QAAI,QAAQ,CAAC,QAAb,EAAuB;AACnB,MAAA,KAAI,CAAC,KAAL,CAAW,IAAX;AACH;;AAED,QAAM,kBAAkB,GAAI,KAAI,CAAC,KAAL,CAAW,UAAX,IAAyB,KAAI,CAAC,KAAL,CAAW,iBAAhE;;AACA,QAAI,QAAQ,CAAC,MAAT,KACC,CAAC,QAAQ,CAAC,QAAV,IAAsB,CAAC,kBADxB,CAAJ,EACiD;AAC7C,MAAA,KAAI,CAAC,QAAL,GAAgB,KAAI,CAAC,UAAL,GAAmB,aAAnB,CAAiC,QAAQ,CAAC,MAA1C,EAAmD,KAAnD,EAA0D,CAAC,KAAI,CAAC,OAAhE,EAAyE,KAAzE,CAAhB;AACA,MAAA,KAAI,CAAC,wBAAL,GAAgC,IAAhC;AACH,KAJD,MAKK,IAAI,kBAAJ,EAAwB;AACzB,MAAA,KAAI,CAAC,sBAAL;AACH;;;AACJ;;AAtFD,EAAA,MAAA,CAAA,cAAA,CAAW,YAAA,CAAA,SAAX,EAAW,iCAAX,EAA0C;AAJ1C;;;;SAIA,YAAA;AACI,UAAI,CAAC,KAAK,gCAAV,EAA4C;AACxC,aAAK,gCAAL,GAAwC,IAAI,UAAJ,EAAxC;AACH;;AACD,aAAO,KAAK,gCAAZ;AACH,KALyC;qBAAA;;AAAA,GAA1C;;AAwFQ,EAAA,YAAA,CAAA,SAAA,CAAA,QAAA,GAAR,UAAiB,GAAjB,EAA0D;AACtD,QAAI,GAAG,YAAY,gBAAnB,EAAqC;AACjC,aAAO,GAAG,CAAC,UAAX;AACH;;AAED,QAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,aAAO,GAAG,CAAC,QAAJ,EAAP;AACH;;AAED,WAAO,GAAP;AACH,GAVO;;AAYA,EAAA,YAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,GAAlB,EAA2D;AACvD,QAAI,GAAG,YAAY,gBAAnB,EAAqC;AACjC,MAAA,KAAK,CAAC,eAAN,CAAsB,GAAG,CAAC,UAA1B,EAAsC,GAAtC;AACA,aAAO,GAAP;AACH;;AACD,QAAM,KAAK,GAAqB,QAAQ,CAAC,aAAT,CAAuB,OAAvB,CAAhC;;AACA,QAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,MAAA,KAAK,CAAC,eAAN,CAAsB,GAAtB,EAA2B,KAA3B;AACA,MAAA,KAAK,CAAC,GAAN,GAAY,GAAZ;AACH,KAHD,MAGO;AACH,MAAA,KAAK,CAAC,eAAN,CAAsB,GAAG,CAAC,CAAD,CAAzB,EAA8B,KAA9B;AACA,MAAA,GAAG,CAAC,OAAJ,CAAY,UAAC,GAAD,EAAI;AACZ,YAAM,MAAM,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,CAAf;AACA,QAAA,MAAM,CAAC,GAAP,GAAa,GAAb;AACA,QAAA,KAAK,CAAC,WAAN,CAAkB,MAAlB;AACH,OAJD;AAKH;;AACD,WAAO,KAAP;AACH,GAlBO;AA2GR;;;;;AAGO,EAAA,YAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,SAAK,MAAL;AACH,GAFM;AAIP;;;;;AAGO,EAAA,YAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACI,QAAI,CAAC,KAAK,iBAAV,EAA6B;AACzB;AACA;AACH;;AAED,SAAK,aAAL,CAAmB,IAAnB;AACH,GAPM;AASP;;;;;;AAIO,EAAA,YAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,SAArB,EAAuC;AACnC,QAAI,CAAC,SAAL,EAAgB;AACZ;AACH;;AACD,QAAI,KAAK,KAAL,CAAW,MAAX,IAAqB,KAAK,mBAA9B,EAAmD;AAC/C;AACH;;AACD,SAAK,mBAAL,GAA2B,IAA3B;;AACA,SAAK,sBAAL;AACH,GATM;AAgCP;;;;;;AAIO,EAAA,YAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,GAAjB,EAA4B;AACxB,SAAK,KAAL,CAAW,GAAX,GAAiB,GAAjB;AACA,SAAK,WAAL,GAAmB,GAAnB;AACH,GAHM;AAKP;;;;;;AAIO,EAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA;AACI,WAAO,IAAI,YAAJ,CAAiB,KAAK,IAAtB,EACH,KAAK,WADF,EAEH,KAAK,QAAL,EAFG,EAGH,KAAK,gBAHF,EAIH,KAAK,OAJF,EAKH,KAAK,YALF,EAMH,KAAK,SANF,CAAP;AAOH,GARM;AAUP;;;;;AAGO,EAAA,YAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,IAAA,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb;;AAEA,SAAK,WAAL,GAAmB,IAAnB;;AAEA,QAAI,KAAK,gCAAT,EAA2C;AACvC,WAAK,gCAAL,CAAsC,KAAtC;;AACA,WAAK,gCAAL,GAAwC,IAAxC;AACH;;AAED,SAAK,KAAL,CAAW,mBAAX,CAA+B,KAAK,6BAApC,EAAmE,KAAK,sBAAxE;AACA,SAAK,KAAL,CAAW,mBAAX,CAA+B,QAA/B,EAAyC,KAAK,sBAA9C;AACA,SAAK,KAAL,CAAW,mBAAX,CAA+B,QAA/B,EAAyC,KAAK,sBAA9C;AACA,SAAK,KAAL,CAAW,mBAAX,CAA+B,SAA/B,EAA0C,KAAK,KAA/C;AACA,SAAK,KAAL,CAAW,KAAX;AACH,GAfM;AAiBP;;;;;;;;AAMc,EAAA,YAAA,CAAA,qBAAA,GAAd,UAAoC,KAApC,EAAkD,MAAlD,EAAqE;AACjE,QAAI,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,OAAvB,CAAZ;;AAEA,QAAI,KAAK,CAAC,SAAN,GAAkB,MAAtB,EAA8B;AAC1B;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,KAA1B;AACA,MAAA,KAAK,CAAC,KAAN,CAAY,SAAZ,GAAwB,uBAAxB;AACA,MAAA,KAAK,CAAC,KAAN,CAAY,OAAZ,GAAsB,GAAtB;AACA,MAAA,KAAK,CAAC,KAAN,CAAY,QAAZ,GAAuB,OAAvB;AACA,MAAA,KAAK,CAAC,KAAN,CAAY,MAAZ,GAAqB,KAArB;AACA,MAAA,KAAK,CAAC,KAAN,CAAY,KAAZ,GAAoB,KAApB;AACH;;AAED,IAAA,KAAK,CAAC,YAAN,CAAmB,UAAnB,EAA+B,EAA/B;AACA,IAAA,KAAK,CAAC,YAAN,CAAmB,OAAnB,EAA4B,MAA5B;AACA,IAAA,KAAK,CAAC,YAAN,CAAmB,aAAnB,EAAkC,EAAlC;AACA,IAAA,KAAK,CAAC,KAAN,GAAc,IAAd;;AAEA,QAAI,KAAK,CAAC,YAAN,KAAuB,SAA3B,EAAsC;AAClC;AACA,MAAA,KAAK,CAAC,YAAN,GAAqB,MAArB;AACH,KAHD,MAGO;AACH,UAAI,OAAO,KAAK,CAAC,SAAb,IAA0B,QAA9B,EAAwC;AACpC,QAAA,KAAK,CAAC,SAAN,GAAkB,MAAlB;AACH,OAFD,MAEO;AACH,QAAA,MAAM,CAAC,GAAP,GAAa,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC,SAArB,IAAkC,MAAM,CAAC,MAAzC,IAAmD,MAAM,CAAC,KAAvE;AACA,QAAA,KAAK,CAAC,GAAN,GAAa,MAAM,CAAC,GAAP,IAAc,MAAM,CAAC,GAAP,CAAW,eAAX,CAA2B,MAA3B,CAA3B;AACH;AACJ;;AAED,WAAO,IAAI,OAAJ,CAA0B,UAAC,OAAD,EAAQ;AACrC,UAAI,SAAS,GAAG,YAAA;AACZ,QAAA,OAAO,CAAC,IAAI,YAAJ,CAAiB,OAAjB,EAA0B,KAA1B,EAAiC,KAAjC,EAAwC,IAAxC,EAA8C,IAA9C,CAAD,CAAP;AACA,QAAA,KAAK,CAAC,mBAAN,CAA0B,SAA1B,EAAqC,SAArC;AACH,OAHD;;AAKA,MAAA,KAAK,CAAC,gBAAN,CAAuB,SAAvB,EAAkC,SAAlC;AACA,MAAA,KAAK,CAAC,IAAN;AACH,KARM,CAAP;AASH,GAvCa;AAyCd;;;;;;;;;AAOc,EAAA,YAAA,CAAA,qBAAA,GAAd,UACI,KADJ,EAEI,WAFJ,EASI,eATJ,EAS4D;AAT5D,QAAA,KAAA,GAAA,IAAA;;AASI,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,KAAA;AAAwD;;AAExD,QAAI,mBAAJ;;AACA,QAAI,WAAW,IAAI,WAAW,CAAC,QAA/B,EAAyC;AACrC,MAAA,mBAAmB,GAAG;AAClB,QAAA,KAAK,EAAE,WAAW,CAAC;AADD,OAAtB;AAGH;;AAED,QAAI,SAAS,CAAC,YAAd,EAA4B;AACxB,aAAO,SAAS,CAAC,YAAV,CAAuB,YAAvB,CAAoC;AACnC,QAAA,KAAK,EAAE,WAD4B;AAEnC,QAAA,KAAK,EAAE;AAF4B,OAApC,EAIF,IAJE,CAIG,UAAC,MAAD,EAAO;AACT,eAAO,KAAI,CAAC,qBAAL,CAA2B,KAA3B,EAAkC,MAAlC,CAAP;AACH,OANE,CAAP;AAOH,KARD,MASK;AACD,MAAA,SAAS,CAAC,YAAV,GACI,SAAS,CAAC,YAAV,IACA,SAAS,CAAC,kBADV,IAEA,SAAS,CAAC,eAFV,IAGA,SAAS,CAAC,cAJd;;AAMA,UAAI,SAAS,CAAC,YAAd,EAA4B;AACxB,QAAA,SAAS,CAAC,YAAV,CACI;AACI,UAAA,KAAK,EAAE;AACH,YAAA,QAAQ,EAAE,mBADP;AAEH,YAAA,KAAK,EAAE;AACH,cAAA,GAAG,EAAG,WAAW,IAAI,WAAW,CAAC,QAA5B,IAAyC,GAD3C;AAEH,cAAA,GAAG,EAAG,WAAW,IAAI,WAAW,CAAC,QAA5B,IAAyC;AAF3C,aAFJ;AAMH,YAAA,MAAM,EAAE;AACJ,cAAA,GAAG,EAAG,WAAW,IAAI,WAAW,CAAC,SAA5B,IAA0C,GAD3C;AAEJ,cAAA,GAAG,EAAG,WAAW,IAAI,WAAW,CAAC,SAA5B,IAA0C;AAF3C;AANL,WADX;AAYI,UAAA,KAAK,EAAE;AAZX,SADJ,EAeI,UAAC,MAAD,EAAY;AACR,iBAAO,KAAI,CAAC,qBAAL,CAA2B,KAA3B,EAAkC,MAAlC,CAAP;AACH,SAjBL,EAkBI,UAAS,CAAT,EAA4B;AACxB,UAAA,MAAM,CAAC,KAAP,CAAa,CAAC,CAAC,IAAf;AACH,SApBL;AAsBH;AACJ;;AAED,WAAO,OAAO,CAAC,MAAR,CAAe,yCAAf,CAAP;AACH,GA7Da;AA+Dd;;;;;;;;;AAOc,EAAA,YAAA,CAAA,gBAAA,GAAd,UACI,KADJ,EAEI,OAFJ,EAGI,WAHJ,EAUI,eAVJ,EAU4D;AAAxD,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,KAAA;AAAwD;;AAExD,SAAK,qBAAL,CAA2B,KAA3B,EAAkC,WAAlC,EAA+C,eAA/C,EACK,IADL,CACU,UAAS,YAAT,EAAqB;AACvB,UAAI,OAAJ,EAAa;AACT,QAAA,OAAO,CAAC,YAAD,CAAP;AACH;AACJ,KALL,EAMK,KANL,CAMW,UAAS,GAAT,EAAY;AACf,MAAA,MAAM,CAAC,KAAP,CAAa,GAAG,CAAC,IAAjB;AACH,KARL;AASH,GArBa;;AAsBlB,SAAA,YAAA;AAAC,CApdD,CAAkC,OAAlC,CAAA","sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `muted` to video, if specified\r\n     */\r\n    muted?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/how_to/video_texture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggerd when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/how_to/video_texture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: VideoTextureSettings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n        }\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n        this._settings = settings;\r\n\r\n        if (settings.poster) {\r\n            this.video.poster = settings.poster;\r\n        }\r\n        if (settings.autoPlay !== undefined) {\r\n            this.video.autoplay = settings.autoPlay;\r\n        }\r\n        if (settings.loop !== undefined) {\r\n            this.video.loop = settings.loop;\r\n        }\r\n        if (settings.muted !== undefined) {\r\n            this.video.muted = settings.muted;\r\n        }\r\n\r\n        this.video.setAttribute(\"playsinline\", \"\");\r\n\r\n        this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"emptied\", this.reset);\r\n        this._createInternalTextureOnEvent = (settings.poster && !settings.autoPlay) ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n\r\n        if (settings.autoPlay) {\r\n            this.video.play();\r\n        }\r\n\r\n        const videoHasEnoughData = (this.video.readyState >= this.video.HAVE_CURRENT_DATA);\r\n        if (settings.poster &&\r\n            (!settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._getEngine()!.createTexture(settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        }\r\n        else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n        return video;\r\n    }\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._texture.dispose();\r\n                this._displayingPosterTexture = false;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!this._getEngine()!.needPOTTextures ||\r\n            (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(\r\n            this.video.videoWidth,\r\n            this.video.videoHeight,\r\n            this._generateMipMaps,\r\n            this.samplingMode\r\n        );\r\n\r\n        if (!this.video.autoplay && !this._settings.poster) {\r\n            let oldHandler = this.video.onplaying;\r\n            let error = false;\r\n            let oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._texture!.isReady = true;\r\n                this._updateInternalTexture();\r\n                if (!error) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            var playing = this.video.play();\r\n            if (playing) {\r\n                playing.then(() => {\r\n                    // Everything is good.\r\n                })\r\n                    .catch(() => {\r\n                        error = true;\r\n                        // On Chrome for instance, new policies might prevent playing without user interaction.\r\n                        if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                            this._onUserActionRequestedObservable.notifyObservers(this);\r\n                        }\r\n                    });\r\n            }\r\n            else {\r\n                this.video.onplaying = oldHandler;\r\n                this._texture.isReady = true;\r\n                this._updateInternalTexture();\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._texture.isReady = true;\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    private reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null || !this._texture.isReady) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        let frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._getEngine()!.updateVideoTexture(this._texture, this.video, this._invertY);\r\n    }\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name,\r\n            this._currentSrc!,\r\n            this.getScene(),\r\n            this._generateMipMaps,\r\n            this.invertY,\r\n            this.samplingMode,\r\n            this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"emptied\", this.reset);\r\n        this.video.pause();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream): Promise<VideoTexture> {\r\n        var video = document.createElement(\"video\");\r\n\r\n        if (scene.getEngine()._badOS) {\r\n            // Yes... I know and I hope to remove it soon...\r\n            document.body.appendChild(video);\r\n            video.style.transform = 'scale(0.0001, 0.0001)';\r\n            video.style.opacity = '0';\r\n            video.style.position = 'fixed';\r\n            video.style.bottom = '0px';\r\n            video.style.right = '0px';\r\n        }\r\n\r\n        video.setAttribute('autoplay', '');\r\n        video.setAttribute('muted', 'true');\r\n        video.setAttribute('playsinline', '');\r\n        video.muted = true;\r\n\r\n        if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\r\n                video.src = (window.URL && window.URL.createObjectURL(stream));\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            let onPlaying = () => {\r\n                resolve(new VideoTexture(\"video\", video, scene, true, true));\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false\r\n    ): Promise<VideoTexture> {\r\n        var constraintsDeviceId;\r\n        if (constraints && constraints.deviceId) {\r\n            constraintsDeviceId = {\r\n                exact: constraints.deviceId,\r\n            };\r\n        }\r\n\r\n        if (navigator.mediaDevices) {\r\n            return navigator.mediaDevices.getUserMedia({\r\n                    video: constraints,\r\n                    audio: audioConstaints\r\n                })\r\n                .then((stream) => {\r\n                    return this.CreateFromStreamAsync(scene, stream);\r\n                });\r\n        }\r\n        else {\r\n            navigator.getUserMedia =\r\n                navigator.getUserMedia ||\r\n                navigator.webkitGetUserMedia ||\r\n                navigator.mozGetUserMedia ||\r\n                navigator.msGetUserMedia;\r\n\r\n            if (navigator.getUserMedia) {\r\n                navigator.getUserMedia(\r\n                    {\r\n                        video: {\r\n                            deviceId: constraintsDeviceId,\r\n                            width: {\r\n                                min: (constraints && constraints.minWidth) || 256,\r\n                                max: (constraints && constraints.maxWidth) || 640,\r\n                            },\r\n                            height: {\r\n                                min: (constraints && constraints.minHeight) || 256,\r\n                                max: (constraints && constraints.maxHeight) || 480,\r\n                            },\r\n                        },\r\n                        audio: audioConstaints\r\n                    },\r\n                    (stream: any) => {\r\n                        return this.CreateFromStreamAsync(scene, stream);\r\n                    },\r\n                    function(e: MediaStreamError) {\r\n                        Logger.Error(e.name);\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param onReady Define a callback to triggered once the texture will be ready\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints)\r\n            .then(function(videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function(err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}