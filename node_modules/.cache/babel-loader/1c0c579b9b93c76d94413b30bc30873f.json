{"ast":null,"code":"import { StringTools } from '../../Misc/stringTools';\n/** @hidden */\n\nvar ShaderCodeNode =\n/** @class */\nfunction () {\n  function ShaderCodeNode() {\n    this.children = [];\n  }\n\n  ShaderCodeNode.prototype.isValid = function (preprocessors) {\n    return true;\n  };\n\n  ShaderCodeNode.prototype.process = function (preprocessors, options) {\n    var result = \"\";\n\n    if (this.line) {\n      var value = this.line;\n      var processor = options.processor;\n\n      if (processor) {\n        // This must be done before other replacements to avoid mistakenly changing something that was already changed.\n        if (processor.lineProcessor) {\n          value = processor.lineProcessor(value, options.isFragment);\n        }\n\n        if (processor.attributeProcessor && StringTools.StartsWith(this.line, \"attribute\")) {\n          value = processor.attributeProcessor(this.line);\n        } else if (processor.varyingProcessor && StringTools.StartsWith(this.line, \"varying\")) {\n          value = processor.varyingProcessor(this.line, options.isFragment);\n        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StringTools.StartsWith(this.line, \"uniform\")) {\n          var regex = /uniform (.+) (.+)/;\n\n          if (regex.test(this.line)) {\n            // uniform\n            if (processor.uniformProcessor) {\n              value = processor.uniformProcessor(this.line, options.isFragment);\n            }\n          } else {\n            // Uniform buffer\n            if (processor.uniformBufferProcessor) {\n              value = processor.uniformBufferProcessor(this.line, options.isFragment);\n              options.lookForClosingBracketForUniformBuffer = true;\n            }\n          }\n        }\n\n        if (processor.endOfUniformBufferProcessor) {\n          if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\n            options.lookForClosingBracketForUniformBuffer = false;\n            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment);\n          }\n        }\n      }\n\n      result += value + \"\\r\\n\";\n    }\n\n    this.children.forEach(function (child) {\n      result += child.process(preprocessors, options);\n    });\n\n    if (this.additionalDefineKey) {\n      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\n    }\n\n    return result;\n  };\n\n  return ShaderCodeNode;\n}();\n\nexport { ShaderCodeNode };","map":{"version":3,"sources":["../../../../sourceES6/core/Engines/Processors/shaderCodeNode.ts"],"names":[],"mappings":"AACA,SAAS,WAAT,QAA4B,wBAA5B;AAEA;;AACA,IAAA,cAAA;AAAA;AAAA,YAAA;AAAA,WAAA,cAAA,GAAA;AAEI,SAAA,QAAA,GAA6B,EAA7B;AA2DH;;AAvDG,EAAA,cAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,aAAR,EAAgD;AAC5C,WAAO,IAAP;AACH,GAFD;;AAIA,EAAA,cAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,aAAR,EAAkD,OAAlD,EAA4E;AACxE,QAAI,MAAM,GAAG,EAAb;;AACA,QAAI,KAAK,IAAT,EAAe;AACX,UAAI,KAAK,GAAW,KAAK,IAAzB;AACA,UAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;;AACA,UAAI,SAAJ,EAAe;AACX;AACA,YAAI,SAAS,CAAC,aAAd,EAA6B;AACzB,UAAA,KAAK,GAAG,SAAS,CAAC,aAAV,CAAwB,KAAxB,EAA+B,OAAO,CAAC,UAAvC,CAAR;AACH;;AAED,YAAI,SAAS,CAAC,kBAAV,IAAgC,WAAW,CAAC,UAAZ,CAAuB,KAAK,IAA5B,EAAkC,WAAlC,CAApC,EAAoF;AAChF,UAAA,KAAK,GAAG,SAAS,CAAC,kBAAV,CAA6B,KAAK,IAAlC,CAAR;AACH,SAFD,MAEO,IAAI,SAAS,CAAC,gBAAV,IAA8B,WAAW,CAAC,UAAZ,CAAuB,KAAK,IAA5B,EAAkC,SAAlC,CAAlC,EAAgF;AACnF,UAAA,KAAK,GAAG,SAAS,CAAC,gBAAV,CAA2B,KAAK,IAAhC,EAAsC,OAAO,CAAC,UAA9C,CAAR;AACH,SAFM,MAEA,IAAI,CAAC,SAAS,CAAC,gBAAV,IAA8B,SAAS,CAAC,sBAAzC,KAAoE,WAAW,CAAC,UAAZ,CAAuB,KAAK,IAA5B,EAAkC,SAAlC,CAAxE,EAAsH;AACzH,cAAI,KAAK,GAAG,mBAAZ;;AAEA,cAAI,KAAK,CAAC,IAAN,CAAW,KAAK,IAAhB,CAAJ,EAA2B;AAAE;AACzB,gBAAI,SAAS,CAAC,gBAAd,EAAgC;AAC5B,cAAA,KAAK,GAAG,SAAS,CAAC,gBAAV,CAA2B,KAAK,IAAhC,EAAsC,OAAO,CAAC,UAA9C,CAAR;AACH;AACJ,WAJD,MAIO;AAAE;AACL,gBAAI,SAAS,CAAC,sBAAd,EAAsC;AAClC,cAAA,KAAK,GAAG,SAAS,CAAC,sBAAV,CAAiC,KAAK,IAAtC,EAA4C,OAAO,CAAC,UAApD,CAAR;AACA,cAAA,OAAO,CAAC,qCAAR,GAAgD,IAAhD;AACH;AACJ;AACJ;;AAED,YAAI,SAAS,CAAC,2BAAd,EAA2C;AACvC,cAAI,OAAO,CAAC,qCAAR,IAAiD,KAAK,IAAL,CAAU,OAAV,CAAkB,GAAlB,MAA2B,CAAC,CAAjF,EAAoF;AAChF,YAAA,OAAO,CAAC,qCAAR,GAAgD,KAAhD;AACA,YAAA,KAAK,GAAG,SAAS,CAAC,2BAAV,CAAsC,KAAK,IAA3C,EAAiD,OAAO,CAAC,UAAzD,CAAR;AACH;AACJ;AACJ;;AAED,MAAA,MAAM,IAAI,KAAK,GAAG,MAAlB;AACH;;AAED,SAAK,QAAL,CAAc,OAAd,CAAsB,UAAC,KAAD,EAAM;AACxB,MAAA,MAAM,IAAI,KAAK,CAAC,OAAN,CAAc,aAAd,EAA6B,OAA7B,CAAV;AACH,KAFD;;AAIA,QAAI,KAAK,mBAAT,EAA8B;AAC1B,MAAA,aAAa,CAAC,KAAK,mBAAN,CAAb,GAA0C,KAAK,qBAAL,IAA8B,MAAxE;AACH;;AAED,WAAO,MAAP;AACH,GAlDD;;AAmDJ,SAAA,cAAA;AAAC,CA7DD,EAAA","sourcesContent":["import { ProcessingOptions } from './shaderProcessingOptions';\r\nimport { StringTools } from '../../Misc/stringTools';\r\n\r\n/** @hidden */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            let processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment);\r\n                }\r\n\r\n                if (processor.attributeProcessor && StringTools.StartsWith(this.line, \"attribute\")) {\r\n                    value = processor.attributeProcessor(this.line);\r\n                } else if (processor.varyingProcessor && StringTools.StartsWith(this.line, \"varying\")) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StringTools.StartsWith(this.line, \"uniform\")) {\r\n                    let regex = /uniform (.+) (.+)/;\r\n\r\n                    if (regex.test(this.line)) { // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment);\r\n                        }\r\n                    } else { // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (processor.endOfUniformBufferProcessor) {\r\n                    if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                        options.lookForClosingBracketForUniformBuffer = false;\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\r\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}