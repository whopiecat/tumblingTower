{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { FreeCamera } from \"./freeCamera\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport \"./Inputs/freeCameraDeviceOrientationInput\";\nimport { Axis } from '../Maths/math.axis';\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", function (name, scene) {\n  return function () {\n    return new DeviceOrientationCamera(name, Vector3.Zero(), scene);\n  };\n}); // We're mainly based on the logic defined into the FreeCamera code\n\n/**\r\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\r\n * being tilted forward or back and left or right.\r\n */\n\nvar DeviceOrientationCamera =\n/** @class */\nfunction (_super) {\n  __extends(DeviceOrientationCamera, _super);\n  /**\r\n   * Creates a new device orientation camera\r\n   * @param name The name of the camera\r\n   * @param position The start position camera\r\n   * @param scene The scene the camera belongs to\r\n   */\n\n\n  function DeviceOrientationCamera(name, position, scene) {\n    var _this = _super.call(this, name, position, scene) || this;\n\n    _this._tmpDragQuaternion = new Quaternion();\n    _this._disablePointerInputWhenUsingDeviceOrientation = true;\n    _this._dragFactor = 0;\n    _this._quaternionCache = new Quaternion();\n\n    _this.inputs.addDeviceOrientation(); // When the orientation sensor fires it's first event, disable mouse input\n\n\n    if (_this.inputs._deviceOrientationInput) {\n      _this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(function () {\n        if (_this._disablePointerInputWhenUsingDeviceOrientation) {\n          if (_this.inputs._mouseInput) {\n            _this.inputs._mouseInput._allowCameraRotation = false;\n\n            _this.inputs._mouseInput.onPointerMovedObservable.add(function (e) {\n              if (_this._dragFactor != 0) {\n                if (!_this._initialQuaternion) {\n                  _this._initialQuaternion = new Quaternion();\n                } // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\n\n\n                Quaternion.FromEulerAnglesToRef(0, e.offsetX * _this._dragFactor, 0, _this._tmpDragQuaternion);\n\n                _this._initialQuaternion.multiplyToRef(_this._tmpDragQuaternion, _this._initialQuaternion);\n              }\n            });\n          }\n        }\n      });\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(DeviceOrientationCamera.prototype, \"disablePointerInputWhenUsingDeviceOrientation\", {\n    /**\r\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\r\n     */\n    get: function () {\n      return this._disablePointerInputWhenUsingDeviceOrientation;\n    },\n    set: function (value) {\n      this._disablePointerInputWhenUsingDeviceOrientation = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Enabled turning on the y axis when the orientation sensor is active\r\n   * @param dragFactor the factor that controls the turn speed (default: 1/300)\r\n   */\n\n  DeviceOrientationCamera.prototype.enableHorizontalDragging = function (dragFactor) {\n    if (dragFactor === void 0) {\n      dragFactor = 1 / 300;\n    }\n\n    this._dragFactor = dragFactor;\n  };\n  /**\r\n   * Gets the current instance class name (\"DeviceOrientationCamera\").\r\n   * This helps avoiding instanceof at run time.\r\n   * @returns the class name\r\n   */\n\n\n  DeviceOrientationCamera.prototype.getClassName = function () {\n    return \"DeviceOrientationCamera\";\n  };\n  /**\r\n   * @hidden\r\n   * Checks and applies the current values of the inputs to the camera. (Internal use only)\r\n   */\n\n\n  DeviceOrientationCamera.prototype._checkInputs = function () {\n    _super.prototype._checkInputs.call(this);\n\n    this._quaternionCache.copyFrom(this.rotationQuaternion);\n\n    if (this._initialQuaternion) {\n      this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n    }\n  };\n  /**\r\n   * Reset the camera to its default orientation on the specified axis only.\r\n   * @param axis The axis to reset\r\n   */\n\n\n  DeviceOrientationCamera.prototype.resetToCurrentRotation = function (axis) {\n    var _this = this;\n\n    if (axis === void 0) {\n      axis = Axis.Y;\n    } //can only work if this camera has a rotation quaternion already.\n\n\n    if (!this.rotationQuaternion) {\n      return;\n    }\n\n    if (!this._initialQuaternion) {\n      this._initialQuaternion = new Quaternion();\n    }\n\n    this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\n\n    ['x', 'y', 'z'].forEach(function (axisName) {\n      if (!axis[axisName]) {\n        _this._initialQuaternion[axisName] = 0;\n      } else {\n        _this._initialQuaternion[axisName] *= -1;\n      }\n    });\n\n    this._initialQuaternion.normalize(); //force rotation update\n\n\n    this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n  };\n\n  return DeviceOrientationCamera;\n}(FreeCamera);\n\nexport { DeviceOrientationCamera };","map":{"version":3,"sources":["../../../sourceES6/core/Cameras/deviceOrientationCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { FreeCamera } from \"./freeCamera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\n\r\nimport \"./Inputs/freeCameraDeviceOrientationInput\";\r\nimport { Axis } from '../Maths/math.axis';\r\n\r\nNode.AddNodeConstructor(\"DeviceOrientationCamera\", (name, scene) => {\r\n    return () => new DeviceOrientationCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// We're mainly based on the logic defined into the FreeCamera code\r\n/**\r\n * This is a camera specifically designed to react to device orientation events such as a modern mobile device\r\n * being tilted forward or back and left or right.\r\n */\r\nexport class DeviceOrientationCamera extends FreeCamera {\r\n\r\n    private _initialQuaternion: Quaternion;\r\n    private _quaternionCache: Quaternion;\r\n    private _tmpDragQuaternion = new Quaternion();\r\n    private _disablePointerInputWhenUsingDeviceOrientation = true;\r\n\r\n    /**\r\n     * Creates a new device orientation camera\r\n     * @param name The name of the camera\r\n     * @param position The start position camera\r\n     * @param scene The scene the camera belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene: Scene) {\r\n        super(name, position, scene);\r\n        this._quaternionCache = new Quaternion();\r\n        this.inputs.addDeviceOrientation();\r\n\r\n        // When the orientation sensor fires it's first event, disable mouse input\r\n        if (this.inputs._deviceOrientationInput) {\r\n            this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(() => {\r\n                if (this._disablePointerInputWhenUsingDeviceOrientation) {\r\n                    if (this.inputs._mouseInput) {\r\n                        this.inputs._mouseInput._allowCameraRotation = false;\r\n                        this.inputs._mouseInput.onPointerMovedObservable.add((e) => {\r\n                            if (this._dragFactor != 0) {\r\n                                if (!this._initialQuaternion) {\r\n                                    this._initialQuaternion = new Quaternion();\r\n                                }\r\n                                // Rotate the initial space around the y axis to allow users to \"turn around\" via touch/mouse\r\n                                Quaternion.FromEulerAnglesToRef(0, e.offsetX * this._dragFactor, 0, this._tmpDragQuaternion);\r\n                                this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion, this._initialQuaternion);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that pointer input must be disabled on first orientation sensor update (Default: true)\r\n     */\r\n    public get disablePointerInputWhenUsingDeviceOrientation() {\r\n        return this._disablePointerInputWhenUsingDeviceOrientation;\r\n    }\r\n\r\n    public set disablePointerInputWhenUsingDeviceOrientation(value: boolean) {\r\n        this._disablePointerInputWhenUsingDeviceOrientation = value;\r\n    }\r\n\r\n    private _dragFactor = 0;\r\n    /**\r\n     * Enabled turning on the y axis when the orientation sensor is active\r\n     * @param dragFactor the factor that controls the turn speed (default: 1/300)\r\n     */\r\n    public enableHorizontalDragging(dragFactor = 1 / 300) {\r\n        this._dragFactor = dragFactor;\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"DeviceOrientationCamera\").\r\n     * This helps avoiding instanceof at run time.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DeviceOrientationCamera\";\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Checks and applies the current values of the inputs to the camera. (Internal use only)\r\n     */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._quaternionCache.copyFrom(this.rotationQuaternion);\r\n        if (this._initialQuaternion) {\r\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the camera to its default orientation on the specified axis only.\r\n     * @param axis The axis to reset\r\n     */\r\n    public resetToCurrentRotation(axis: Axis = Axis.Y): void {\r\n\r\n        //can only work if this camera has a rotation quaternion already.\r\n        if (!this.rotationQuaternion) { return; }\r\n\r\n        if (!this._initialQuaternion) {\r\n            this._initialQuaternion = new Quaternion();\r\n        }\r\n\r\n        this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\r\n\r\n        ['x', 'y', 'z'].forEach((axisName) => {\r\n            if (!(<any>axis)[axisName]) {\r\n                (<any>this._initialQuaternion)[axisName] = 0;\r\n            } else {\r\n                (<any>this._initialQuaternion)[axisName] *= -1;\r\n            }\r\n        });\r\n        this._initialQuaternion.normalize();\r\n        //force rotation update\r\n        this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}