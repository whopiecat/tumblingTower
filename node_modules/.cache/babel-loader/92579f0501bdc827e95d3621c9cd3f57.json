{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { NodeMaterialBlock } from '../../nodeMaterialBlock';\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\nimport { InputBlock } from '../Input/inputBlock';\nimport { _TypeStore } from '../../../../Misc/typeStore';\nimport { Texture } from '../../../Textures/texture';\n/**\r\n * Base block used for the particle texture\r\n */\n\nvar ParticleTextureBlock =\n/** @class */\nfunction (_super) {\n  __extends(ParticleTextureBlock, _super);\n  /**\r\n   * Create a new ParticleTextureBlock\r\n   * @param name defines the block name\r\n   */\n\n\n  function ParticleTextureBlock(name) {\n    var _this = _super.call(this, name, NodeMaterialBlockTargets.Fragment) || this;\n\n    _this._samplerName = \"diffuseSampler\";\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\n\n    _this.convertToGammaSpace = false;\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\n\n    _this.convertToLinearSpace = false;\n    _this._isUnique = false;\n\n    _this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\n\n    _this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\n\n    _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\n\n    return _this;\n  }\n  /**\r\n   * Gets the current class name\r\n   * @returns the class name\r\n   */\n\n\n  ParticleTextureBlock.prototype.getClassName = function () {\n    return \"ParticleTextureBlock\";\n  };\n\n  Object.defineProperty(ParticleTextureBlock.prototype, \"uv\", {\n    /**\r\n     * Gets the uv input component\r\n     */\n    get: function () {\n      return this._inputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgba\", {\n    /**\r\n     * Gets the rgba output component\r\n     */\n    get: function () {\n      return this._outputs[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"rgb\", {\n    /**\r\n     * Gets the rgb output component\r\n     */\n    get: function () {\n      return this._outputs[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"r\", {\n    /**\r\n     * Gets the r output component\r\n     */\n    get: function () {\n      return this._outputs[2];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"g\", {\n    /**\r\n     * Gets the g output component\r\n     */\n    get: function () {\n      return this._outputs[3];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"b\", {\n    /**\r\n     * Gets the b output component\r\n     */\n    get: function () {\n      return this._outputs[4];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ParticleTextureBlock.prototype, \"a\", {\n    /**\r\n     * Gets the a output component\r\n     */\n    get: function () {\n      return this._outputs[5];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Initialize the block and prepare the context for build\r\n   * @param state defines the state that will be used for the build\r\n   */\n\n  ParticleTextureBlock.prototype.initialize = function (state) {\n    state._excludeVariableName(\"diffuseSampler\");\n  };\n\n  ParticleTextureBlock.prototype.autoConfigure = function (material) {\n    if (!this.uv.isConnected) {\n      var uvInput = material.getInputBlockByPredicate(function (b) {\n        return b.isAttribute && b.name === \"particle_uv\";\n      });\n\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"particle_uv\");\n      }\n\n      uvInput.output.connectTo(this.uv);\n    }\n  };\n\n  ParticleTextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  };\n\n  ParticleTextureBlock.prototype.isReady = function () {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ParticleTextureBlock.prototype._writeOutput = function (state, output, swizzle) {\n    state.compilationString += this._declareOutput(output, state) + \" = \" + this._tempTextureRead + \".\" + swizzle + \";\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._linearDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toGammaSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n    state.compilationString += \"#ifdef \" + this._gammaDefineName + \"\\r\\n\";\n    state.compilationString += output.associatedVariableName + \" = toLinearSpace(\" + output.associatedVariableName + \");\\r\\n\";\n    state.compilationString += \"#endif\\r\\n\";\n  };\n\n  ParticleTextureBlock.prototype._buildBlock = function (state) {\n    _super.prototype._buildBlock.call(this, state);\n\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      return;\n    }\n\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n\n    state._emit2DSampler(this._samplerName);\n\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    var comments = \"//\" + this.name;\n\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n\n    state.compilationString += \"vec4 \" + this._tempTextureRead + \" = texture2D(\" + this._samplerName + \", \" + this.uv.associatedVariableName + \");\\r\\n\";\n\n    for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {\n      var output = _a[_i];\n\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n\n    return this;\n  };\n\n  ParticleTextureBlock.prototype.serialize = function () {\n    var serializationObject = _super.prototype.serialize.call(this);\n\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n\n    if (this.texture) {\n      serializationObject.texture = this.texture.serialize();\n    }\n\n    return serializationObject;\n  };\n\n  ParticleTextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {\n    _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);\n\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  };\n\n  return ParticleTextureBlock;\n}(NodeMaterialBlock);\n\nexport { ParticleTextureBlock };\n_TypeStore.RegisteredTypes[\"BABYLON.ParticleTextureBlock\"] = ParticleTextureBlock;","map":{"version":3,"sources":["../../../../../../sourceES6/core/Materials/Node/Blocks/Particle/particleTextureBlock.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeMaterialBlock } from '../../nodeMaterialBlock';\r\nimport { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from '../../nodeMaterialBuildState';\r\nimport { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';\r\nimport { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';\r\nimport { AbstractMesh } from '../../../../Meshes/abstractMesh';\r\nimport { NodeMaterialDefines } from '../../nodeMaterial';\r\nimport { InputBlock } from '../Input/inputBlock';\r\nimport { BaseTexture } from '../../../Textures/baseTexture';\r\nimport { Nullable } from '../../../../types';\r\nimport { _TypeStore } from '../../../../Misc/typeStore';\r\nimport { Texture } from '../../../Textures/texture';\r\nimport { Scene } from '../../../../scene';\r\n\r\ndeclare type NodeMaterial = import(\"../../nodeMaterial\").NodeMaterial;\r\n\r\n/**\r\n * Base block used for the particle texture\r\n */\r\nexport class ParticleTextureBlock extends NodeMaterialBlock {\r\n\r\n    private _samplerName = \"diffuseSampler\";\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    private _tempTextureRead: string;\r\n\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public convertToGammaSpace = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public convertToLinearSpace = false;\r\n\r\n    /**\r\n     * Create a new ParticleTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = false;\r\n\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"diffuseSampler\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"particle_uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"particle_uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\r\n        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._linearDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += `#ifdef ${this._gammaDefineName}\\r\\n`;\r\n        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        let comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\\r\\n`;\r\n\r\n        for (var output of this._outputs) {\r\n            if (output.hasEndpoints) {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        let serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        if (this.texture) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n\r\n        if (serializationObject.texture) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ParticleTextureBlock\"] = ParticleTextureBlock;"],"sourceRoot":""},"metadata":{},"sourceType":"module"}