{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger\";\nimport { Engine } from \"../Engines/engine\";\nimport { RenderTargetCreationOptions } from \"../Materials/Textures/renderTargetCreationOptions\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\nimport { DataBuffer } from '../Meshes/dataBuffer';\nimport { PerformanceConfigurator } from './performanceConfigurator';\n/**\r\n * Options to create the null engine\r\n */\n\nvar NullEngineOptions =\n/** @class */\nfunction () {\n  function NullEngineOptions() {\n    /**\r\n     * Render width (Default: 512)\r\n     */\n    this.renderWidth = 512;\n    /**\r\n     * Render height (Default: 256)\r\n     */\n\n    this.renderHeight = 256;\n    /**\r\n     * Texture size (Default: 512)\r\n     */\n\n    this.textureSize = 512;\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\n\n    this.deterministicLockstep = false;\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\n\n    this.lockstepMaxSteps = 4;\n  }\n\n  return NullEngineOptions;\n}();\n\nexport { NullEngineOptions };\n/**\r\n * The null engine class provides support for headless version of babylon.js.\r\n * This can be used in server side scenario or for testing purposes\r\n */\n\nvar NullEngine =\n/** @class */\nfunction (_super) {\n  __extends(NullEngine, _super);\n\n  function NullEngine(options) {\n    if (options === void 0) {\n      options = new NullEngineOptions();\n    }\n\n    var _this = _super.call(this, null) || this;\n\n    Engine.Instances.push(_this);\n\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n\n    _this._options = options;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix); // Init caps\n    // We consider we are on a webgl1 capable device\n\n    _this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: false,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 0,\n      uintIndices: false,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      canUseTimestampForTimerQuery: false,\n      maxMSAASamples: 1,\n      blendMinMax: false\n    };\n    Logger.Log(\"Babylon.js v\" + Engine.Version + \" - Null engine\"); // Wrappers\n\n    var theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n\n    if (typeof URL === \"undefined\") {\n      theCurrentGlobal.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n\n    if (typeof Blob === \"undefined\") {\n      theCurrentGlobal.Blob = function () {};\n    }\n\n    return _this;\n  }\n  /**\r\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns true if engine is in deterministic lock step mode\r\n   */\n\n\n  NullEngine.prototype.isDeterministicLockStep = function () {\n    return this._options.deterministicLockstep;\n  };\n  /**\r\n   * Gets the max steps when engine is running in deterministic lock step\r\n   * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n   * @returns the max steps\r\n   */\n\n\n  NullEngine.prototype.getLockstepMaxSteps = function () {\n    return this._options.lockstepMaxSteps;\n  };\n  /**\r\n   * Gets the current hardware scaling level.\r\n   * By default the hardware scaling level is computed from the window device ratio.\r\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n   * @returns a number indicating the current hardware scaling level\r\n   */\n\n\n  NullEngine.prototype.getHardwareScalingLevel = function () {\n    return 1.0;\n  };\n  /**\r\n   * Creates a vertex buffer\r\n   * @param vertices the data for the vertex buffer\r\n   * @returns the new WebGL static buffer\r\n   */\n\n\n  NullEngine.prototype.createVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\r\n   * Creates a new index buffer\r\n   * @param indices defines the content of the index buffer\r\n   * @param updatable defines if the index buffer must be updatable\r\n   * @returns a new webGL buffer\r\n   */\n\n\n  NullEngine.prototype.createIndexBuffer = function (indices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  };\n  /**\r\n   * Clear the current render buffer or the current render target (if any is set up)\r\n   * @param color defines the color to use\r\n   * @param backBuffer defines if the back buffer must be cleared\r\n   * @param depth defines if the depth buffer must be cleared\r\n   * @param stencil defines if the stencil buffer must be cleared\r\n   */\n\n\n  NullEngine.prototype.clear = function (color, backBuffer, depth, stencil) {\n    if (stencil === void 0) {\n      stencil = false;\n    }\n  };\n  /**\r\n   * Gets the current render width\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render width\r\n   */\n\n\n  NullEngine.prototype.getRenderWidth = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n\n    return this._options.renderWidth;\n  };\n  /**\r\n   * Gets the current render height\r\n   * @param useScreen defines if screen size must be used (or the current render target if any)\r\n   * @returns a number defining the current render height\r\n   */\n\n\n  NullEngine.prototype.getRenderHeight = function (useScreen) {\n    if (useScreen === void 0) {\n      useScreen = false;\n    }\n\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n\n    return this._options.renderHeight;\n  };\n  /**\r\n   * Set the WebGL's viewport\r\n   * @param viewport defines the viewport element to be used\r\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n   */\n\n\n  NullEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n  };\n\n  NullEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context) {\n    return {\n      __SPECTOR_rebuildProgram: null\n    };\n  };\n  /**\r\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param uniformsNames defines the list of uniform names\r\n   * @returns an array of webGL uniform locations\r\n   */\n\n\n  NullEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {\n    return [];\n  };\n  /**\r\n   * Gets the lsit of active attributes for a given webGL program\r\n   * @param pipelineContext defines the pipeline context to use\r\n   * @param attributesNames defines the list of attribute names to get\r\n   * @returns an array of indices indicating the offset of each attribute\r\n   */\n\n\n  NullEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {\n    return [];\n  };\n  /**\r\n   * Binds an effect to the webGL context\r\n   * @param effect defines the effect to bind\r\n   */\n\n\n  NullEngine.prototype.bindSamplers = function (effect) {\n    this._currentEffect = null;\n  };\n  /**\r\n   * Activates an effect, mkaing it the current one (ie. the one used for rendering)\r\n   * @param effect defines the effect to activate\r\n   */\n\n\n  NullEngine.prototype.enableEffect = function (effect) {\n    this._currentEffect = effect;\n\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  };\n  /**\r\n   * Set various states to the webGL context\r\n   * @param culling defines backface culling state\r\n   * @param zOffset defines the value to apply to zOffset (0 by default)\r\n   * @param force defines if states must be applied even if cache is up to date\r\n   * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)\r\n   */\n\n\n  NullEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {\n    if (zOffset === void 0) {\n      zOffset = 0;\n    }\n\n    if (reverseSide === void 0) {\n      reverseSide = false;\n    }\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of int32 (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of int32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setIntArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloatArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray2 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray3 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of number (stored as vec4)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param array defines the array of number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setArray4 = function (uniform, array) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to an array of float32 (stored as matrices)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrices defines the array of float32 to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrices = function (uniform, matrices) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (3x3)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrix3x3 = function (uniform, matrix) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a matrix (2x2)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setMatrix2x2 = function (uniform, matrix) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a number (float)\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param value defines the float number to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat = function (uniform, value) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec2\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat2 = function (uniform, x, y) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec3\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat3 = function (uniform, x, y, z) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a boolean\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param bool defines the boolean to store\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setBool = function (uniform, bool) {\n    return true;\n  };\n  /**\r\n   * Set the value of an uniform to a vec4\r\n   * @param uniform defines the webGL uniform location where to store the value\r\n   * @param x defines the 1st component of the value\r\n   * @param y defines the 2nd component of the value\r\n   * @param z defines the 3rd component of the value\r\n   * @param w defines the 4th component of the value\r\n   * @returns true if value was set\r\n   */\n\n\n  NullEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n    return true;\n  };\n  /**\r\n   * Sets the current alpha mode\r\n   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n   * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n   */\n\n\n  NullEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {\n    if (noDepthWriteChange === void 0) {\n      noDepthWriteChange = false;\n    }\n\n    if (this._alphaMode === mode) {\n      return;\n    }\n\n    this.alphaState.alphaBlend = mode !== 0;\n\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n\n    this._alphaMode = mode;\n  };\n  /**\r\n   * Bind webGl buffers directly to the webGL context\r\n   * @param vertexBuffers defines the vertex buffer to bind\r\n   * @param indexBuffer defines the index buffer to bind\r\n   * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer\r\n   * @param vertexStrideSize defines the vertex stride of the vertex buffer\r\n   * @param effect defines the effect associated with the vertex buffer\r\n   */\n\n\n  NullEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {};\n  /**\r\n   * Force the entire cache to be cleared\r\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n   */\n\n\n  NullEngine.prototype.wipeCaches = function (bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n\n    this.resetTextureCache();\n    this._currentEffect = null;\n\n    if (bruteForce) {\n      this._currentProgram = null;\n      this.stencilState.reset();\n      this.depthCullingState.reset();\n      this.alphaState.reset();\n    }\n\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  };\n  /**\r\n   * Send a draw order\r\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {};\n  /**\r\n   * Draw a list of indexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param indexStart defines the starting index\r\n   * @param indexCount defines the number of index to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {};\n  /**\r\n   * Draw a list of unindexed primitives\r\n   * @param fillMode defines the primitive to use\r\n   * @param verticesStart defines the index of first vertex to draw\r\n   * @param verticesCount defines the count of vertices to draw\r\n   * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n   */\n\n\n  NullEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {};\n  /** @hidden */\n\n\n  NullEngine.prototype._createTexture = function () {\n    return {};\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._releaseTexture = function (texture) {};\n  /**\r\n   * Usually called from Texture.ts.\r\n   * Passed information to create a WebGLTexture\r\n   * @param urlArg defines a value which contains one of the following:\r\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n   * @param scene needed for loading to the correct scene\r\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n   * @param onLoad optional callback to be called upon successful completion\r\n   * @param onError optional callback to be called upon failure\r\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n   * @param forcedExtension defines the extension to use to pick the right loader\r\n   * @param mimeType defines an optional mime type\r\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n   */\n\n\n  NullEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType) {\n    if (samplingMode === void 0) {\n      samplingMode = 3;\n    }\n\n    if (onLoad === void 0) {\n      onLoad = null;\n    }\n\n    if (onError === void 0) {\n      onError = null;\n    }\n\n    if (buffer === void 0) {\n      buffer = null;\n    }\n\n    if (fallback === void 0) {\n      fallback = null;\n    }\n\n    if (format === void 0) {\n      format = null;\n    }\n\n    if (forcedExtension === void 0) {\n      forcedExtension = null;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.Url);\n    var url = String(urlArg);\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = this._options.textureSize;\n    texture.baseHeight = this._options.textureSize;\n    texture.width = this._options.textureSize;\n    texture.height = this._options.textureSize;\n\n    if (format) {\n      texture.format = format;\n    }\n\n    texture.isReady = true;\n\n    if (onLoad) {\n      onLoad();\n    }\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n  /**\r\n   * Creates a new render target texture\r\n   * @param size defines the size of the texture\r\n   * @param options defines the options used to create the texture\r\n   * @returns a new render target texture stored in an InternalTexture\r\n   */\n\n\n  NullEngine.prototype.createRenderTargetTexture = function (size, options) {\n    var fullOptions = new RenderTargetCreationOptions();\n\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n    }\n\n    var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    var width = size.width || size;\n    var height = size.height || size;\n    texture._depthStencilBuffer = {};\n    texture._framebuffer = {};\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n\n    this._internalTexturesCache.push(texture);\n\n    return texture;\n  };\n  /**\r\n   * Update the sampling mode of a given texture\r\n   * @param samplingMode defines the required sampling mode\r\n   * @param texture defines the texture to update\r\n   */\n\n\n  NullEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {\n    texture.samplingMode = samplingMode;\n  };\n  /**\r\n   * Binds the frame buffer to the specified texture.\r\n   * @param texture The texture to render to or null for the default canvas\r\n   * @param faceIndex The face of the texture to render to in case of cube texture\r\n   * @param requiredWidth The width of the target to render to\r\n   * @param requiredHeight The height of the target to render to\r\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n   * @param lodLevel defines le lod level to bind to the frame buffer\r\n   */\n\n\n  NullEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n\n    this._currentRenderTarget = texture;\n    this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;\n\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    }\n  };\n  /**\r\n   * Unbind the current render target texture from the webGL context\r\n   * @param texture defines the render target texture to unbind\r\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n   */\n\n\n  NullEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n    if (disableGenerateMipMaps === void 0) {\n      disableGenerateMipMaps = false;\n    }\n\n    this._currentRenderTarget = null;\n\n    if (onBeforeUnbind) {\n      if (texture._MSAAFramebuffer) {\n        this._currentFramebuffer = texture._framebuffer;\n      }\n\n      onBeforeUnbind();\n    }\n\n    this._currentFramebuffer = null;\n  };\n  /**\r\n   * Creates a dynamic vertex buffer\r\n   * @param vertices the data for the dynamic vertex buffer\r\n   * @returns the new WebGL dynamic buffer\r\n   */\n\n\n  NullEngine.prototype.createDynamicVertexBuffer = function (vertices) {\n    var buffer = new DataBuffer();\n    buffer.references = 1;\n    buffer.capacity = 1;\n    return buffer;\n  };\n  /**\r\n   * Update the content of a dynamic texture\r\n   * @param texture defines the texture to update\r\n   * @param canvas defines the canvas containing the source\r\n   * @param invertY defines if data must be stored with Y axis inverted\r\n   * @param premulAlpha defines if alpha is stored as premultiplied\r\n   * @param format defines the format of the data\r\n   * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n   */\n\n\n  NullEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n  };\n  /**\r\n   * Gets a boolean indicating if all created effects are ready\r\n   * @returns true if all effects are ready\r\n   */\n\n\n  NullEngine.prototype.areAllEffectsReady = function () {\n    return true;\n  };\n  /**\r\n   * @hidden\r\n   * Get the current error code of the webGL context\r\n   * @returns the error code\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n   */\n\n\n  NullEngine.prototype.getError = function () {\n    return 0;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._getUnpackAlignement = function () {\n    return 1;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._unpackFlipY = function (value) {};\n  /**\r\n   * Update a dynamic index buffer\r\n   * @param indexBuffer defines the target index buffer\r\n   * @param indices defines the data to update\r\n   * @param offset defines the offset in the target index buffer where update should start\r\n   */\n\n\n  NullEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n  };\n  /**\r\n   * Updates a dynamic vertex buffer.\r\n   * @param vertexBuffer the vertex buffer to update\r\n   * @param vertices the data used to update the vertex buffer\r\n   * @param byteOffset the byte offset of the data (optional)\r\n   * @param byteLength the byte length of the data (optional)\r\n   */\n\n\n  NullEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, byteOffset, byteLength) {};\n  /** @hidden */\n\n\n  NullEngine.prototype._bindTextureDirectly = function (target, texture) {\n    if (this._boundTexturesCache[this._activeChannel] !== texture) {\n      this._boundTexturesCache[this._activeChannel] = texture;\n      return true;\n    }\n\n    return false;\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._bindTexture = function (channel, texture) {\n    if (channel < 0) {\n      return;\n    }\n\n    this._bindTextureDirectly(0, texture);\n  };\n\n  NullEngine.prototype._deleteBuffer = function (buffer) {};\n  /**\r\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n   */\n\n\n  NullEngine.prototype.releaseEffects = function () {};\n\n  NullEngine.prototype.displayLoadingUI = function () {};\n\n  NullEngine.prototype.hideLoadingUI = function () {};\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n  /** @hidden */\n\n\n  NullEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {\n    if (faceIndex === void 0) {\n      faceIndex = 0;\n    }\n\n    if (lod === void 0) {\n      lod = 0;\n    }\n  };\n\n  return NullEngine;\n}(Engine);\n\nexport { NullEngine };","map":{"version":3,"sources":["../../../sourceES6/core/Engines/nullEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { RenderTargetCreationOptions } from \"../Materials/Textures/renderTargetCreationOptions\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { IPipelineContext } from './IPipelineContext';\r\nimport { DataBuffer } from '../Meshes/dataBuffer';\r\nimport { IColor4Like, IViewportLike } from '../Maths/math.like';\r\nimport { ISceneLike } from './thinEngine';\r\nimport { PerformanceConfigurator } from './performanceConfigurator';\r\n\r\ndeclare const global: any;\r\n\r\n/**\r\n * Options to create the null engine\r\n */\r\nexport class NullEngineOptions {\r\n    /**\r\n     * Render width (Default: 512)\r\n     */\r\n    public renderWidth = 512;\r\n    /**\r\n     * Render height (Default: 256)\r\n     */\r\n    public renderHeight = 256;\r\n\r\n    /**\r\n     * Texture size (Default: 512)\r\n     */\r\n    public textureSize = 512;\r\n\r\n    /**\r\n     * If delta time between frames should be constant\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public deterministicLockstep = false;\r\n\r\n    /**\r\n     * Maximum about of steps between frames (Default: 4)\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     */\r\n    public lockstepMaxSteps = 4;\r\n\r\n    /**\r\n     * Make the matrix computations to be performed in 64 bits instead of 32 bits. False by default\r\n     */\r\n    useHighPrecisionMatrix?: boolean;\r\n}\r\n\r\n/**\r\n * The null engine class provides support for headless version of babylon.js.\r\n * This can be used in server side scenario or for testing purposes\r\n */\r\nexport class NullEngine extends Engine {\r\n    private _options: NullEngineOptions;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns true if engine is in deterministic lock step mode\r\n     */\r\n    public isDeterministicLockStep(): boolean {\r\n        return this._options.deterministicLockstep;\r\n    }\r\n\r\n    /**\r\n     * Gets the max steps when engine is running in deterministic lock step\r\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\r\n     * @returns the max steps\r\n     */\r\n    public getLockstepMaxSteps(): number {\r\n        return this._options.lockstepMaxSteps;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hardware scaling level.\r\n     * By default the hardware scaling level is computed from the window device ratio.\r\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\r\n     * @returns a number indicating the current hardware scaling level\r\n     */\r\n    public getHardwareScalingLevel(): number {\r\n        return 1.0;\r\n    }\r\n\r\n    public constructor(options: NullEngineOptions = new NullEngineOptions()) {\r\n        super(null);\r\n\r\n        Engine.Instances.push(this);\r\n\r\n        if (options.deterministicLockstep === undefined) {\r\n            options.deterministicLockstep = false;\r\n        }\r\n\r\n        if (options.lockstepMaxSteps === undefined) {\r\n            options.lockstepMaxSteps = 4;\r\n        }\r\n\r\n        this._options = options;\r\n\r\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\r\n\r\n        // Init caps\r\n        // We consider we are on a webgl1 capable device\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: 512,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: false,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 0,\r\n            uintIndices: false,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            textureFloat: false,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: false,\r\n            textureHalfFloat: false,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: false,\r\n            textureLOD: false,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: false,\r\n            instancedArrays: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            maxMSAASamples: 1,\r\n            blendMinMax: false\r\n        };\r\n\r\n        Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\r\n\r\n        // Wrappers\r\n        const theCurrentGlobal = (typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window);\r\n        if (typeof URL === \"undefined\") {\r\n            theCurrentGlobal.URL = {\r\n                createObjectURL: function() { },\r\n                revokeObjectURL: function() { }\r\n            };\r\n        }\r\n        if (typeof Blob === \"undefined\") {\r\n            theCurrentGlobal.Blob = function() { };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a vertex buffer\r\n     * @param vertices the data for the vertex buffer\r\n     * @returns the new WebGL static buffer\r\n     */\r\n    public createVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        let buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the content of the index buffer\r\n     * @param updatable defines if the index buffer must be updatable\r\n     * @returns a new webGL buffer\r\n     */\r\n    public createIndexBuffer(indices: IndicesArray): DataBuffer {\r\n        let buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Clear the current render buffer or the current render target (if any is set up)\r\n     * @param color defines the color to use\r\n     * @param backBuffer defines if the back buffer must be cleared\r\n     * @param depth defines if the depth buffer must be cleared\r\n     * @param stencil defines if the stencil buffer must be cleared\r\n     */\r\n    public clear(color: IColor4Like, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n    }\r\n\r\n    /**\r\n     * Gets the current render width\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render width\r\n     */\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._options.renderWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets the current render height\r\n     * @param useScreen defines if screen size must be used (or the current render target if any)\r\n     * @returns a number defining the current render height\r\n     */\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._options.renderHeight;\r\n    }\r\n\r\n    /**\r\n     * Set the WebGL's viewport\r\n     * @param viewport defines the viewport element to be used\r\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\r\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\r\n     */\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n    }\r\n\r\n    public createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram {\r\n        return {\r\n            __SPECTOR_rebuildProgram: null,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param uniformsNames defines the list of uniform names\r\n     * @returns an array of webGL uniform locations\r\n     */\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Gets the lsit of active attributes for a given webGL program\r\n     * @param pipelineContext defines the pipeline context to use\r\n     * @param attributesNames defines the list of attribute names to get\r\n     * @returns an array of indices indicating the offset of each attribute\r\n     */\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Binds an effect to the webGL context\r\n     * @param effect defines the effect to bind\r\n     */\r\n    public bindSamplers(effect: Effect): void {\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    /**\r\n     * Activates an effect, mkaing it the current one (ie. the one used for rendering)\r\n     * @param effect defines the effect to activate\r\n     */\r\n    public enableEffect(effect: Effect): void {\r\n        this._currentEffect = effect;\r\n\r\n        if (effect.onBind) {\r\n            effect.onBind(effect);\r\n        }\r\n        if (effect._onBindObservable) {\r\n            effect._onBindObservable.notifyObservers(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set various states to the webGL context\r\n     * @param culling defines backface culling state\r\n     * @param zOffset defines the value to apply to zOffset (0 by default)\r\n     * @param force defines if states must be applied even if cache is up to date\r\n     * @param reverseSide defines if culling must be reversed (CCW instead of CW and CW instead of CCW)\r\n     */\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false): void {\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of int32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of int32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of number (stored as vec4)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param array defines the array of number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to an array of float32 (stored as matrices)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrices defines the array of float32 to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (3x3)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 3x3 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a matrix (2x2)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param matrix defines the Float32Array representing the 2x2 matrix to store\r\n     * @returns true if value was set\r\n     */\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a number (float)\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param value defines the float number to store\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec2\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec3\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a boolean\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param bool defines the boolean to store\r\n     * @returns true if value was set\r\n     */\r\n    public setBool(uniform: WebGLUniformLocation, bool: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set the value of an uniform to a vec4\r\n     * @param uniform defines the webGL uniform location where to store the value\r\n     * @param x defines the 1st component of the value\r\n     * @param y defines the 2nd component of the value\r\n     * @param z defines the 3rd component of the value\r\n     * @param w defines the 4th component of the value\r\n     * @returns true if value was set\r\n     */\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        this.alphaState.alphaBlend = (mode !== 0);\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === 0);\r\n        }\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Bind webGl buffers directly to the webGL context\r\n     * @param vertexBuffers defines the vertex buffer to bind\r\n     * @param indexBuffer defines the index buffer to bind\r\n     * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer\r\n     * @param vertexStrideSize defines the vertex stride of the vertex buffer\r\n     * @param effect defines the effect associated with the vertex buffer\r\n     */\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer; }, indexBuffer: DataBuffer, effect: Effect): void {\r\n    }\r\n\r\n    /**\r\n     * Force the entire cache to be cleared\r\n     * You should not have to use this function unless your engine needs to share the webGL context with another engine\r\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\r\n     */\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this.stencilState.reset();\r\n            this.depthCullingState.reset();\r\n            this.alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    /**\r\n     * Send a draw order\r\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n     */\r\n    public draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _createTexture(): WebGLTexture {\r\n        return {};\r\n    }\r\n\r\n    /** @hidden */\r\n    public _releaseTexture(texture: InternalTexture): void {\r\n    }\r\n\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a WebGLTexture\r\n     * @param urlArg defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(urlArg: Nullable<string>, noMipmap: boolean, invertY: boolean, scene: Nullable<ISceneLike>, samplingMode: number = 3,\r\n        onLoad: Nullable<() => void> = null, onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null, fallback: Nullable<InternalTexture> = null, format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null, mimeType?: string): InternalTexture {\r\n        var texture = new InternalTexture(this, InternalTextureSource.Url);\r\n        var url = String(urlArg);\r\n\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = this._options.textureSize;\r\n        texture.baseHeight = this._options.textureSize;\r\n        texture.width = this._options.textureSize;\r\n        texture.height = this._options.textureSize;\r\n        if (format) {\r\n            texture.format = format;\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a new render target texture\r\n     * @param size defines the size of the texture\r\n     * @param options defines the options used to create the texture\r\n     * @returns a new render target texture stored in an InternalTexture\r\n     */\r\n    public createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): InternalTexture {\r\n        let fullOptions = new RenderTargetCreationOptions();\r\n\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            fullOptions.generateMipMaps = options.generateMipMaps;\r\n            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\r\n            fullOptions.type = options.type === undefined ? 0 : options.type;\r\n            fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\r\n        } else {\r\n            fullOptions.generateMipMaps = <boolean>options;\r\n            fullOptions.generateDepthBuffer = true;\r\n            fullOptions.generateStencilBuffer = false;\r\n            fullOptions.type = 0;\r\n            fullOptions.samplingMode = 3;\r\n        }\r\n        var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\r\n\r\n        var width = size.width || size;\r\n        var height = size.height || size;\r\n\r\n        texture._depthStencilBuffer = {};\r\n        texture._framebuffer = {};\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\r\n        texture.samplingMode = fullOptions.samplingMode;\r\n        texture.type = fullOptions.type;\r\n        texture._generateDepthBuffer = fullOptions.generateDepthBuffer;\r\n        texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of a given texture\r\n     * @param samplingMode defines the required sampling mode\r\n     * @param texture defines the texture to update\r\n     */\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Binds the frame buffer to the specified texture.\r\n     * @param texture The texture to render to or null for the default canvas\r\n     * @param faceIndex The face of the texture to render to in case of cube texture\r\n     * @param requiredWidth The width of the target to render to\r\n     * @param requiredHeight The height of the target to render to\r\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\r\n     * @param lodLevel defines le lod level to bind to the frame buffer\r\n     */\r\n    public bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n        this._currentRenderTarget = texture;\r\n        this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;\r\n        if (this._cachedViewport && !forceFullscreenViewport) {\r\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbind the current render target texture from the webGL context\r\n     * @param texture defines the render target texture to unbind\r\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n     */\r\n    public unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            if (texture._MSAAFramebuffer) {\r\n                this._currentFramebuffer = texture._framebuffer;\r\n            }\r\n            onBeforeUnbind();\r\n        }\r\n        this._currentFramebuffer = null;\r\n    }\r\n\r\n    /**\r\n     * Creates a dynamic vertex buffer\r\n     * @param vertices the data for the dynamic vertex buffer\r\n     * @returns the new WebGL dynamic buffer\r\n     */\r\n    public createDynamicVertexBuffer(vertices: FloatArray): DataBuffer {\r\n        let buffer = new DataBuffer();\r\n        buffer.references = 1;\r\n        buffer.capacity = 1;\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha: boolean = false, format?: number): void {\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if all created effects are ready\r\n     * @returns true if all effects are ready\r\n     */\r\n    public areAllEffectsReady(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Get the current error code of the webGL context\r\n     * @returns the error code\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\r\n     */\r\n    public getError(): number {\r\n        return 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getUnpackAlignement(): number {\r\n        return 1;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _unpackFlipY(value: boolean) {\r\n    }\r\n\r\n    /**\r\n     * Update a dynamic index buffer\r\n     * @param indexBuffer defines the target index buffer\r\n     * @param indices defines the data to update\r\n     * @param offset defines the offset in the target index buffer where update should start\r\n     */\r\n    public updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset: number = 0): void {\r\n    }\r\n\r\n    /**\r\n     * Updates a dynamic vertex buffer.\r\n     * @param vertexBuffer the vertex buffer to update\r\n     * @param vertices the data used to update the vertex buffer\r\n     * @param byteOffset the byte offset of the data (optional)\r\n     * @param byteLength the byte length of the data (optional)\r\n     */\r\n    public updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bindTextureDirectly(target: number, texture: InternalTexture): boolean {\r\n        if (this._boundTexturesCache[this._activeChannel] !== texture) {\r\n            this._boundTexturesCache[this._activeChannel] = texture;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        if (channel < 0) {\r\n            return;\r\n        }\r\n\r\n        this._bindTextureDirectly(0, texture);\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: WebGLBuffer): void {\r\n    }\r\n\r\n    /**\r\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n     */\r\n    public releaseEffects() {\r\n    }\r\n\r\n    public displayLoadingUI(): void {\r\n    }\r\n\r\n    public hideLoadingUI(): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex: number = 0, lod: number = 0) {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n    }\r\n\r\n    /** @hidden */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}