{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\nimport { Quaternion } from \"../../Maths/math.vector\";\nimport { Axis } from '../../Maths/math.axis';\nimport { Tools } from '../../Misc/tools';\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\n\nvar FlyCameraMouseInput =\n/** @class */\nfunction () {\n  /**\r\n   * Listen to mouse events to control the camera.\r\n   * @param touchEnabled Define if touch is enabled. (Default is true.)\r\n   * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n   */\n  function FlyCameraMouseInput(touchEnabled) {\n    if (touchEnabled === void 0) {\n      touchEnabled = true;\n    }\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\n\n\n    this.buttons = [0, 1, 2];\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\n\n    this.buttonsYaw = [-1, 0, 1];\n    /**\r\n    * Assign buttons for Pitch control.\r\n    */\n\n    this.buttonsPitch = [-1, 0, 1];\n    /**\r\n    * Assign buttons for Roll control.\r\n    */\n\n    this.buttonsRoll = [2];\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\n\n    this.activeButton = -1;\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\n\n    this.angularSensibility = 1000.0;\n    this.previousPosition = null;\n  }\n  /**\r\n   * Attach the mouse control to the HTML DOM element.\r\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n   */\n\n\n  FlyCameraMouseInput.prototype.attachControl = function (noPreventDefault) {\n    var _this = this;\n\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene().onPointerObservable.add(function (p, s) {\n      _this._pointerInput(p, s);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE); // Correct Roll by rate, if enabled.\n\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(function () {\n      if (_this.camera.rollCorrect) {\n        _this.camera.restoreRoll(_this.camera.rollCorrect);\n      }\n    });\n  };\n  /**\r\n   * Detach the current controls from the specified dom element.\r\n   * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n   */\n\n\n  FlyCameraMouseInput.prototype.detachControl = function (ignored) {\n    if (this._observer) {\n      this.camera.getScene().onPointerObservable.remove(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this.previousPosition = null;\n      this.noPreventDefault = undefined;\n    }\n  };\n  /**\r\n   * Gets the class name of the current input.\r\n   * @returns the class name.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.getClassName = function () {\n    return \"FlyCameraMouseInput\";\n  };\n  /**\r\n   * Get the friendly name associated with the input class.\r\n   * @returns the input's friendly name.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.getSimpleName = function () {\n    return \"mouse\";\n  }; // Track mouse movement, when the pointer is not locked.\n\n\n  FlyCameraMouseInput.prototype._pointerInput = function (p, s) {\n    var e = p.event;\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    } // Mouse is moved but an unknown mouse button is pressed.\n\n\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n\n    var srcElement = e.srcElement || e.target; // Mouse down.\n\n    if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n      try {\n        srcElement.setPointerCapture(e.pointerId);\n      } catch (e) {// Nothing to do with the error. Execution continues.\n      }\n\n      this.previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n\n      if (!this.noPreventDefault) {\n        e.preventDefault();\n        this.element.focus();\n      } // This is required to move while pointer button is down\n\n\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    } else // Mouse up.\n      if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n        try {\n          srcElement.releasePointerCapture(e.pointerId);\n        } catch (e) {// Nothing to do with the error. Execution continues.\n        }\n\n        this.activeButton = -1;\n        this.previousPosition = null;\n\n        if (!this.noPreventDefault) {\n          e.preventDefault();\n        }\n      } else // Mouse move.\n        if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!this.previousPosition) {\n            if (engine.isPointerLock) {\n              this._onMouseMove(p.event);\n            }\n\n            return;\n          }\n\n          var offsetX = e.clientX - this.previousPosition.x;\n          var offsetY = e.clientY - this.previousPosition.y;\n          this.rotateCamera(offsetX, offsetY);\n          this.previousPosition = {\n            x: e.clientX,\n            y: e.clientY\n          };\n\n          if (!this.noPreventDefault) {\n            e.preventDefault();\n          }\n        }\n  }; // Track mouse movement, when pointer is locked.\n\n\n  FlyCameraMouseInput.prototype._onMouseMove = function (e) {\n    var camera = this.camera;\n    var engine = camera.getEngine();\n\n    if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\n      return;\n    }\n\n    var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\n    var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\n    this.rotateCamera(offsetX, offsetY);\n    this.previousPosition = null;\n\n    if (!this.noPreventDefault) {\n      e.preventDefault();\n    }\n  };\n  /**\r\n   * Rotate camera by mouse offset.\r\n   */\n\n\n  FlyCameraMouseInput.prototype.rotateCamera = function (offsetX, offsetY) {\n    var _this = this;\n\n    var camera = this.camera;\n    var scene = this.camera.getScene();\n\n    if (scene.useRightHandedSystem) {\n      offsetX *= -1;\n    }\n\n    if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\n      offsetX *= -1;\n    }\n\n    var x = offsetX / this.angularSensibility;\n    var y = offsetY / this.angularSensibility; // Initialize to current rotation.\n\n    var currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    var rotationChange; // Pitch.\n\n    if (this.buttonsPitch.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y); // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Yaw.\n\n\n    if (this.buttonsYaw.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x); // Apply Yaw to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange); // Add Roll, if banked turning is enabled, within Roll limit.\n\n      var limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90° plus manual roll.\n\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        var bankingDelta = camera.bankedTurnMultiplier * -x; // Apply change in Radians to vector Angle.\n\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta); // Apply Yaw to quaternion.\n\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    } // Roll.\n\n\n    if (this.buttonsRoll.some(function (v) {\n      return v === _this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x); // Track Rolling.\n\n      camera._trackRoll -= x; // Apply Pitch to quaternion.\n\n      currentRotation.multiplyInPlace(rotationChange);\n    } // Apply rotationQuaternion to Euler camera.rotation.\n\n\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  };\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n\n  __decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\n\n  return FlyCameraMouseInput;\n}();\n\nexport { FlyCameraMouseInput };\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;","map":{"version":3,"sources":["../../../../sourceES6/core/Cameras/Inputs/flyCameraMouseInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { Observer } from \"../../Misc/observable\";\r\nimport { ICameraInput, CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { FlyCamera } from \"../../Cameras/flyCamera\";\r\nimport { PointerInfo, PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Quaternion } from \"../../Maths/math.vector\";\r\nimport { Axis } from '../../Maths/math.axis';\r\nimport { Tools } from '../../Misc/tools';\r\n/**\r\n * Listen to mouse events to control the camera.\r\n * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n */\r\nexport class FlyCameraMouseInput implements ICameraInput<FlyCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FlyCamera;\r\n\r\n    /**\r\n     * Defines if touch is enabled. (Default is true.)\r\n     */\r\n    public touchEnabled: boolean;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera rotation.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Assign buttons for Yaw control.\r\n     */\r\n    public buttonsYaw: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n    * Assign buttons for Pitch control.\r\n    */\r\n    public buttonsPitch: number[] = [-1, 0, 1];\r\n\r\n    /**\r\n    * Assign buttons for Roll control.\r\n    */\r\n    public buttonsRoll: number[] = [2];\r\n\r\n    /**\r\n     * Detect if any button is being pressed while mouse is moved.\r\n     * -1 = Mouse locked.\r\n     * 0 = Left button.\r\n     * 1 = Middle Button.\r\n     * 2 = Right Button.\r\n     */\r\n    public activeButton: number = -1;\r\n\r\n    /**\r\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\r\n     * Higher values reduce its sensitivity.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 1000.0;\r\n\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _rollObserver: Nullable<Observer<Scene>>;\r\n    private previousPosition: Nullable<{ x: number, y: number }> = null;\r\n    private noPreventDefault: boolean | undefined;\r\n    private element: HTMLElement;\r\n\r\n    /**\r\n     * Listen to mouse events to control the camera.\r\n     * @param touchEnabled Define if touch is enabled. (Default is true.)\r\n     * @see https://doc.babylonjs.com/how_to/customizing_camera_inputs\r\n     */\r\n    constructor(touchEnabled = true) {\r\n    }\r\n\r\n    /**\r\n     * Attach the mouse control to the HTML DOM element.\r\n     * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        this._observer = this.camera.getScene().onPointerObservable.add(\r\n            (p: any, s: any) => {\r\n                this._pointerInput(p, s);\r\n            },\r\n            PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE\r\n        );\r\n\r\n        // Correct Roll by rate, if enabled.\r\n        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(\r\n            () => {\r\n                if (this.camera.rollCorrect) {\r\n                    this.camera.restoreRoll(this.camera.rollCorrect);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility. If you want to define the source input element, you can set engine.inputElement before calling camera.attachControl\r\n     */\r\n    public detachControl(ignored?: any): void {\r\n        if (this._observer) {\r\n            this.camera.getScene().onPointerObservable.remove(this._observer);\r\n\r\n            this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\r\n\r\n            this._observer = null;\r\n            this._rollObserver = null;\r\n            this.previousPosition = null;\r\n            this.noPreventDefault = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input's friendly name.\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n\r\n    // Track mouse movement, when the pointer is not locked.\r\n    private _pointerInput(p: any, s: any): void {\r\n        var e = <PointerEvent>p.event;\r\n\r\n        let camera = this.camera;\r\n        let engine = camera.getEngine();\r\n\r\n        if (engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        if (!this.touchEnabled && e.pointerType === \"touch\") {\r\n            return;\r\n        }\r\n\r\n        // Mouse is moved but an unknown mouse button is pressed.\r\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\r\n            return;\r\n        }\r\n\r\n        var srcElement = <HTMLElement>(e.srcElement || e.target);\r\n\r\n        // Mouse down.\r\n        if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\r\n            try {\r\n                srcElement.setPointerCapture(e.pointerId);\r\n            } catch (e) {\r\n                // Nothing to do with the error. Execution continues.\r\n            }\r\n\r\n            this.previousPosition = {\r\n                x: e.clientX,\r\n                y: e.clientY\r\n            };\r\n\r\n            this.activeButton = e.button;\r\n\r\n            if (!this.noPreventDefault) {\r\n                e.preventDefault();\r\n                this.element.focus();\r\n            }\r\n\r\n            // This is required to move while pointer button is down\r\n            if (engine.isPointerLock) {\r\n                this._onMouseMove(p.event);\r\n            }\r\n        } else\r\n            // Mouse up.\r\n            if (p.type === PointerEventTypes.POINTERUP && srcElement) {\r\n                try {\r\n                    srcElement.releasePointerCapture(e.pointerId);\r\n                } catch (e) {\r\n                    // Nothing to do with the error. Execution continues.\r\n                }\r\n\r\n                this.activeButton = -1;\r\n\r\n                this.previousPosition = null;\r\n                if (!this.noPreventDefault) {\r\n                    e.preventDefault();\r\n                }\r\n            } else\r\n                // Mouse move.\r\n                if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!this.previousPosition) {\r\n                        if (engine.isPointerLock) {\r\n                            this._onMouseMove(p.event);\r\n                        }\r\n\r\n                        return;\r\n                    }\r\n\r\n                    var offsetX = e.clientX - this.previousPosition.x;\r\n                    var offsetY = e.clientY - this.previousPosition.y;\r\n\r\n                    this.rotateCamera(offsetX, offsetY);\r\n\r\n                    this.previousPosition = {\r\n                        x: e.clientX,\r\n                        y: e.clientY\r\n                    };\r\n\r\n                    if (!this.noPreventDefault) {\r\n                        e.preventDefault();\r\n                    }\r\n                }\r\n    }\r\n\r\n    // Track mouse movement, when pointer is locked.\r\n    private _onMouseMove(e: any): void {\r\n        let camera = this.camera;\r\n        let engine = camera.getEngine();\r\n\r\n        if (!engine.isPointerLock || engine.isInVRExclusivePointerMode) {\r\n            return;\r\n        }\r\n\r\n        var offsetX = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\r\n        var offsetY = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\r\n\r\n        this.rotateCamera(offsetX, offsetY);\r\n\r\n        this.previousPosition = null;\r\n\r\n        if (!this.noPreventDefault) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate camera by mouse offset.\r\n     */\r\n    private rotateCamera(offsetX: number, offsetY: number): void {\r\n        let camera = this.camera;\r\n        let scene = this.camera.getScene();\r\n\r\n        if (scene.useRightHandedSystem) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        if (camera.parent && camera.parent._getWorldMatrixDeterminant() < 0) {\r\n            offsetX *= -1;\r\n        }\r\n\r\n        var x = offsetX / this.angularSensibility;\r\n        var y = offsetY / this.angularSensibility;\r\n\r\n        // Initialize to current rotation.\r\n        var currentRotation = Quaternion.RotationYawPitchRoll(\r\n            camera.rotation.y,\r\n            camera.rotation.x,\r\n            camera.rotation.z\r\n        );\r\n        var rotationChange: Quaternion;\r\n\r\n        // Pitch.\r\n        if (this.buttonsPitch.some((v) => { return v === this.activeButton; })) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.X, y);\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Yaw.\r\n        if (this.buttonsYaw.some((v) => { return v === this.activeButton; })) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Y, x);\r\n            // Apply Yaw to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n\r\n            // Add Roll, if banked turning is enabled, within Roll limit.\r\n            let limit = (camera.bankedTurnLimit) + camera._trackRoll; // Defaults to 90° plus manual roll.\r\n            if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\r\n                let bankingDelta = camera.bankedTurnMultiplier * -x;\r\n                // Apply change in Radians to vector Angle.\r\n                rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\r\n                // Apply Yaw to quaternion.\r\n                currentRotation.multiplyInPlace(rotationChange);\r\n            }\r\n        }\r\n\r\n        // Roll.\r\n        if (this.buttonsRoll.some((v) => { return v === this.activeButton; })) {\r\n            // Apply change in Radians to vector Angle.\r\n            rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\r\n            // Track Rolling.\r\n            camera._trackRoll -= x;\r\n            // Apply Pitch to quaternion.\r\n            currentRotation.multiplyInPlace(rotationChange);\r\n        }\r\n\r\n        // Apply rotationQuaternion to Euler camera.rotation.\r\n        currentRotation.toEulerAnglesToRef(camera.rotation);\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}